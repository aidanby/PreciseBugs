{"buggy_code": ["#ifndef IGNOREALL\n/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2015 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.476 $\n   $Date: 2015/05/25 02:29:14 $\n */\n/*@out DEFINES\n#ifndef USE_JPEG\n#define NO_JPEG\n#endif\n#ifndef USE_JASPER\n#define NO_JASPER\n#endif\n@end DEFINES */\n\n#define NO_LCMS\n#define DCRAW_VERBOSE\n//@out DEFINES\n#define DCRAW_VERSION \"9.26\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _USE_MATH_DEFINES\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n//@end DEFINES\n\n#if defined(DJGPP) || defined(__MINGW32__)\n#define fseeko fseek\n#define ftello ftell\n#else\n#define fgetc getc_unlocked\n#endif\n//@out DEFINES\n#ifdef __CYGWIN__\n#include <io.h>\n#endif\n#if defined WIN32 || defined(__MINGW32__)\n#include <sys/utime.h>\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define snprintf _snprintf\n#define strcasecmp stricmp\n#define strncasecmp strnicmp\n//@end DEFINES\ntypedef __int64 INT64;\ntypedef unsigned __int64 UINT64;\n//@out DEFINES\n#else\n#include <unistd.h>\n#include <utime.h>\n#include <netinet/in.h>\ntypedef long long INT64;\ntypedef unsigned long long UINT64;\n#endif\n\n#ifdef NODEPS\n#define NO_JASPER\n#define NO_JPEG\n#define NO_LCMS\n#endif\n#ifndef NO_JASPER\n#include <jasper/jasper.h> /* Decode Red camera movies */\n#endif\n#ifndef NO_JPEG\n#include <jpeglib.h> /* Decode compressed Kodak DC120 photos */\n#endif               /* and Adobe Lossy DNGs */\n#ifndef NO_LCMS\n#ifdef USE_LCMS\n#include <lcms.h> /* Support color profiles */\n#else\n#include <lcms2.h> /* Support color profiles */\n#endif\n#endif\n#ifdef LOCALEDIR\n#include <libintl.h>\n#define _(String) gettext(String)\n#else\n#define _(String) (String)\n#endif\n\n#ifdef LJPEG_DECODE\n#error Please compile dcraw.c by itself.\n#error Do not link it with ljpeg_decode.\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * sizeof(long))\n#endif\n//@end DEFINES\n\n#if !defined(uchar)\n#define uchar unsigned char\n#endif\n#if !defined(ushort)\n#define ushort unsigned short\n#endif\n\n/*\n   All global variables are defined here, and all functions that\n   access them are prefixed with \"CLASS\".  Note that a thread-safe\n   C++ class cannot have non-const static local variables.\n */\nFILE *ifp, *ofp;\nshort order;\nconst char *ifname;\nchar *meta_data, xtrans[6][6], xtrans_abs[6][6];\nchar cdesc[5], desc[512], make[64], model[64], model2[64], artist[64], software[64];\nfloat flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;\ntime_t timestamp;\noff_t strip_offset, data_offset;\noff_t thumb_offset, meta_offset, profile_offset;\nunsigned shot_order, kodak_cbpp, exif_cfa, unique_id;\nunsigned thumb_length, meta_length, profile_length;\nunsigned thumb_misc, *oprof, fuji_layout, shot_select = 0, multi_out = 0;\nunsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;\nunsigned black, maximum, mix_green, raw_color, zero_is_bad;\nunsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;\nunsigned tile_width, tile_length, gpsdata[32], load_flags;\nunsigned flip, tiff_flip, filters, colors;\nushort raw_height, raw_width, height, width, top_margin, left_margin;\nushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;\nushort *raw_image, (*image)[4], cblack[4102];\nushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];\ndouble pixel_aspect, aber[4] = {1, 1, 1, 1}, gamm[6] = {0.45, 4.5, 0, 0, 0, 0};\nfloat bright = 1, user_mul[4] = {0, 0, 0, 0}, threshold = 0;\nint mask[8][4];\nint half_size = 0, four_color_rgb = 0, document_mode = 0, highlight = 0;\nint verbose = 0, use_auto_wb = 0, use_camera_wb = 0, use_camera_matrix = 1;\nint output_color = 1, output_bps = 8, output_tiff = 0, med_passes = 0;\nint no_auto_bright = 0;\nunsigned greybox[4] = {0, 0, UINT_MAX, UINT_MAX};\nfloat cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];\nconst double xyz_rgb[3][3] = {/* XYZ from RGB */\n                              {0.412453, 0.357580, 0.180423},\n                              {0.212671, 0.715160, 0.072169},\n                              {0.019334, 0.119193, 0.950227}};\nconst float d65_white[3] = {0.950456, 1, 1.088754};\nint histogram[4][0x2000];\nvoid (*write_thumb)(), (*write_fun)();\nvoid (*load_raw)(), (*thumb_load_raw)();\njmp_buf failure;\n\nstruct decode\n{\n  struct decode *branch[2];\n  int leaf;\n} first_decode[2048], *second_decode, *free_decode;\n\nstruct tiff_ifd\n{\n  int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;\n  int t_tile_width, t_tile_length, sample_format, predictor;\n  float t_shutter;\n} tiff_ifd[10];\n\nstruct ph1\n{\n  int format, key_off, tag_21a;\n  int t_black, split_col, black_col, split_row, black_row;\n  float tag_210;\n} ph1;\n\n#define CLASS\n\n//@out DEFINES\n#define FORC(cnt) for (c = 0; c < cnt; c++)\n#define FORC3 FORC(3)\n#define FORC4 FORC(4)\n#define FORCC for (c = 0; c < colors && c < 4; c++)\n\n#define SQR(x) ((x) * (x))\n#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))\n#define CLIP(x) LIM((int)(x), 0, 65535)\n#define SWAP(a, b)                                                                                                     \\\n  {                                                                                                                    \\\n    a = a + b;                                                                                                         \\\n    b = a - b;                                                                                                         \\\n    a = a - b;                                                                                                         \\\n  }\n\n#define my_swap(type, i, j)                                                                                            \\\n  {                                                                                                                    \\\n    type t = i;                                                                                                        \\\n    i = j;                                                                                                             \\\n    j = t;                                                                                                             \\\n  }\n\nstatic float fMAX(float a, float b) { return MAX(a, b); }\n\n/*\n   In order to inline this calculation, I make the risky\n   assumption that all filter patterns can be described\n   by a repeating pattern of eight rows and two columns\n\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\n   because its pattern is 16x16, not 2x8.\n\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\n\n        PowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\n        0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\n\n          0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n        0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\n        1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\n        2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\n        3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\n                        4 C Y C Y C Y\t4 Y C Y C Y C\n        PowerShot A5\t5 G M G M G M\t5 G M G M G M\n        0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\n                        7 M G M G M G\t7 M G M G M G\n          0 1 2 3 4 5\n        0 C Y C Y C Y\n        1 G M G M G M\n        2 C Y C Y C Y\n        3 M G M G M G\n\n   All RGB cameras use one of these Bayer grids:\n\n        0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\n\n          0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n        0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\n        1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\n        2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\n        3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n */\n\n#define RAW(row, col) raw_image[(row)*raw_width + (col)]\n//@end DEFINES\n\n#define FC(row, col) (filters >> ((((row) << 1 & 14) + ((col)&1)) << 1) & 3)\n\n//@out DEFINES\n#define BAYER(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][FC(row, col)]\n\n#define BAYER2(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][fcol(row, col)]\n//@end DEFINES\n\n/* @out COMMON\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end COMMON */\n\n//@out COMMON\nint CLASS fcol(int row, int col)\n{\n  static const char filter[16][16] = {\n      {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},\n      {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},\n      {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},\n      {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},\n      {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},\n      {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},\n      {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},\n      {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};\n\n  if (filters == 1)\n    return filter[(row + top_margin) & 15][(col + left_margin) & 15];\n  if (filters == 9)\n    return xtrans[(row + 6) % 6][(col + 6) % 6];\n  return FC(row, col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a, b) local_strnlen(a, b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n  int r = fp->read(buf, len, 1);\n  buf[len - 1] = 0;\n  return r;\n}\n#define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp(c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)\n\n//@end COMMON\n\nvoid CLASS merror(void *ptr, const char *where)\n{\n  if (ptr)\n    return;\n  fprintf(stderr, _(\"%s: Out of memory in %s\\n\"), ifname, where);\n  longjmp(failure, 1);\n}\n\nvoid CLASS derror()\n{\n  if (!data_error)\n  {\n    fprintf(stderr, \"%s: \", ifname);\n    if (feof(ifp))\n      fprintf(stderr, _(\"Unexpected end of file\\n\"));\n    else\n      fprintf(stderr, _(\"Corrupt data near 0x%llx\\n\"), (INT64)ftello(ifp));\n  }\n  data_error++;\n}\n\n//@out COMMON\nushort CLASS sget2(uchar *s)\n{\n  if (order == 0x4949) /* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG 1\n#define AdobeDNG 2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)\n{\n  if ((a >> 4) > 9)\n    return 0;\n  else if ((a & 0x0f) > 9)\n    return 0;\n  else if ((b >> 4) > 9)\n    return 0;\n  else if ((b & 0x0f) > 9)\n    return 0;\n  else if ((c >> 4) > 9)\n    return 0;\n  else if ((c & 0x0f) > 9)\n    return 0;\n  else if ((d >> 4) > 9)\n    return 0;\n  else if ((d & 0x0f) > 9)\n    return 0;\n  else if ((e >> 4) > 9)\n    return 0;\n  else if ((e & 0x0f) > 9)\n    return 0;\n  else if ((f >> 4) > 9)\n    return 0;\n  else if ((f & 0x0f) > 9)\n    return 0;\n  return 1;\n}\n\nstatic ushort bcd2dec(uchar data)\n{\n  if ((data >> 4) > 9)\n    return 0;\n  else if ((data & 0x0f) > 9)\n    return 0;\n  else\n    return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] =\n    \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"\n    \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"\n    \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"\n    \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"\n    \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"\n    \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"\n    \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"\n    \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"\n    \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"\n    \"\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse\n{\n  if (order == 0x4d4d) /* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian... */\n    return s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = {0xff, 0xff};\n  fread(str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4(uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }\n\nfloat CLASS int_to_float(int i)\n{\n  union {\n    int i;\n    float f;\n  } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n\n  switch (type)\n  {\n  case 3:\n    return (unsigned short)get2();\n  case 4:\n    return (unsigned int)get4();\n  case 5:\n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8:\n    return (signed short)get2();\n  case 9:\n    return (signed int)get4();\n  case 10:\n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11:\n    return int_to_float(get4());\n  case 12:\n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts(ushort *pixel, int count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}\n\nvoid CLASS cubic_spline(const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);\n  if (!A)\n    return;\n  A[0] = (float *)(A + 2 * len);\n  for (i = 1; i < 2 * len; i++)\n    A[i] = A[0] + 2 * len * i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));\n  for (i = 0; i < len; i++)\n  {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len - 1; i > 0; i--)\n  {\n    b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);\n    d[i - 1] = x[i] - x[i - 1];\n  }\n  for (i = 1; i < len - 1; i++)\n  {\n    A[i][i] = 2 * (d[i - 1] + d[i]);\n    if (i > 1)\n    {\n      A[i][i - 1] = d[i - 1];\n      A[i - 1][i] = d[i - 1];\n    }\n    A[i][len - 1] = 6 * (b[i + 1] - b[i]);\n  }\n  for (i = 1; i < len - 2; i++)\n  {\n    float v = A[i + 1][i] / A[i][i];\n    for (j = 1; j <= len - 1; j++)\n      A[i + 1][j] -= v * A[i][j];\n  }\n  for (i = len - 2; i > 0; i--)\n  {\n    float acc = 0;\n    for (j = i; j <= len - 2; j++)\n      acc += A[i][j] * c[j];\n    c[i] = (A[i][len - 1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len - 1; j++)\n    {\n      if (x[j] <= x_out && x_out <= x[j + 1])\n      {\n        float v = x_out - x[j];\n        y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +\n                ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));\n  }\n  free(A);\n}\n\nvoid CLASS canon_600_fixed_wb(int temp)\n{\n  static const short mul[4][5] = {\n      {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};\n  int lo, hi, i;\n  float frac = 0;\n\n  for (lo = 4; --lo;)\n    if (*mul[lo] <= temp)\n      break;\n  for (hi = 0; hi < 3; hi++)\n    if (*mul[hi] >= temp)\n      break;\n  if (lo != hi)\n    frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i = 1; i < 5; i++)\n    pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color(int ratio[2], int mar)\n{\n  int clipped = 0, target, miss;\n\n  if (flash_used)\n  {\n    if (ratio[1] < -104)\n    {\n      ratio[1] = -104;\n      clipped = 1;\n    }\n    if (ratio[1] > 12)\n    {\n      ratio[1] = 12;\n      clipped = 1;\n    }\n  }\n  else\n  {\n    if (ratio[1] < -264 || ratio[1] > 461)\n      return 2;\n    if (ratio[1] < -50)\n    {\n      ratio[1] = -50;\n      clipped = 1;\n    }\n    if (ratio[1] > 307)\n    {\n      ratio[1] = 307;\n      clipped = 1;\n    }\n  }\n  target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)\n    return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar * 4)\n    return 2;\n  if (miss < -20)\n    miss = -20;\n  if (miss > mar)\n    miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = {0, 0};\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset(&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if (i < 10)\n    mar = 150;\n  else if (i > 12)\n    mar = 20;\n  else\n    mar = 280 - 20 * i;\n  if (flash_used)\n    mar = 80;\n  for (row = 14; row < height - 14; row += 4)\n    for (col = 10; col < width; col += 2)\n    {\n      for (i = 0; i < 8; i++)\n        test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));\n      for (i = 0; i < 8; i++)\n        if (test[i] < 150 || test[i] > 1500)\n          goto next;\n      for (i = 0; i < 4; i++)\n        if (abs(test[i] - test[i + 4]) > 50)\n          goto next;\n      for (i = 0; i < 2; i++)\n      {\n        for (j = 0; j < 4; j += 2)\n          ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];\n        stat[i] = canon_600_color(ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1)\n        goto next;\n      for (i = 0; i < 2; i++)\n        if (stat[i])\n          for (j = 0; j < 2; j++)\n            test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;\n      for (i = 0; i < 8; i++)\n        total[st][i] += test[i];\n      count[st]++;\n    next:;\n    }\n  if (count[0] | count[1])\n  {\n    st = count[0] * 200 < count[1];\n    for (i = 0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},\n                                     {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},\n                                     {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},\n                                     {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};\n  int t = 0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789)\n    t = 1;\n  if (mc > 1.28 && mc <= 2)\n  {\n    if (yc < 0.8789)\n      t = 3;\n    else if (yc <= 2)\n      t = 4;\n  }\n  if (flash_used)\n    t = 5;\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow = row = 0; irow < height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(data, 1, 1120, ifp) < 1120)\n      derror();\n    pix = raw_image + row * raw_width;\n    for (dp = data; dp < data + 1120; dp += 10, pix += 8)\n    {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6);\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1] & 3);\n      pix[4] = (dp[5] << 2) + (dp[9] & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6);\n    }\n    if ((row += 2) > height)\n      row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n    {\n      if ((val = BAYER(row, col) - black) < 0)\n        val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row, col) = val;\n    }\n  }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row = 0; row < 100; row++)\n  {\n    fseek(ifp, row * 3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15)\n      return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n, 0)\n#define gethuff(h) getbithuff(*h, h + 1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *CLASS make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }\n\nvoid CLASS crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,\n       0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,\n       0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,\n       0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,\n       0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,\n       0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,\n       0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,\n       0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,\n       0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,\n       0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,\n       0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,\n       0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,\n       0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,\n       0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,\n       0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,\n       0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,\n       0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row += 8)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free(huff[c]);\n}\n//@end COMMON\n\nstruct jhead\n{\n  int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];\n  ushort quant[64], idct[64], *huff[20], *free[20], *row;\n};\n\n//@out COMMON\n\nint CLASS ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint CLASS ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *CLASS ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp(failure, 3);\n#endif\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  ljpeg_end(&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n#endif\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n#endif\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))\n#endif\n      for (; rp < ip[0]; rp += 4)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||\n            unique_id == 0x80000287)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select)\n    (*rp)++;\n  if (raw_image)\n  {\n    if (row < raw_height && col < raw_width)\n      RAW(row, col) = curve[**rp];\n    *rp += tiff_samples;\n  }\n  else\n  {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n    image[row * width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select)\n    (*rp)--;\n}\n\nvoid CLASS ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,\n                                   40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,\n                                   29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n                                   47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n    if (!ljpeg_start(&jh, 0))\n      break;\n    jwide = jh.wide;\n    if (filters)\n      jwide *= jh.clrs;\n    jwide /= MIN(is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      switch (jh.algo)\n      {\n      case 0xc1:\n        jh.vpred[0] = 16384;\n        getbits(-1);\n        for (jrow = 0; jrow + 7 < jh.high; jrow += 8)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)\n          {\n            ljpeg_idct(&jh);\n            rp = jh.idct;\n            row = trow + jcol / tile_width + jrow * 2;\n            col = tcol + jcol % tile_width;\n            for (i = 0; i < 16; i += 2)\n              for (j = 0; j < 8; j++)\n                adobe_copy_pixel(row + i, col + j, &rp);\n          }\n        }\n        break;\n      case 0xc3:\n        for (row = col = jrow = 0; jrow < jh.high; jrow++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          rp = ljpeg_row(jrow, &jh);\n          for (jcol = 0; jcol < jwide; jcol++)\n          {\n            adobe_copy_pixel(trow + row, tcol + col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      ljpeg_end(&jh);\n      throw;\n    }\n#endif\n    fseek(ifp, save + 4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end(&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);\n  merror(pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (tiff_bps == 16)\n        read_shorts(pixel, raw_width * tiff_samples);\n      else\n      {\n        getbits(-1);\n        for (col = 0; col < raw_width * tiff_samples; col++)\n          pixel[col] = getbits(tiff_bps);\n      }\n      for (rp = pixel, col = 0; col < raw_width; col++)\n        adobe_copy_pixel(row, col, &rp);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width * 3 * tiff_bps / 8;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for (int row = 0; row < raw_height; row++)\n  {\n    int red = fread(buf, 1, bufsize, ifp);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (tiff_bps <= 8)\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    else\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n  }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0, 0, 0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0, 0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0)\n  {\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n  while (curve[max - 2] == curve[max - 1])\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (min = row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n#endif\n  free(huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = {0x00, 0x55, 0xaa, 0xff};\n\n  memset(histo, 0, sizeof histo);\n  fseek(ifp, -2000, SEEK_END);\n  for (i = 0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i = 0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek(ifp, 0, SEEK_SET);\n  for (i = 0; i < 1024; i++)\n  {\n    fread(t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct\n  {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n      {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};\n\n  fseek(ifp, 3072, SEEK_SET);\n  fread(dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits)\n    {\n      strcpy(make, table[i].t_make);\n      strcpy(model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}\n//@end COMMON\n\nvoid CLASS jpeg_thumb();\n\n//@out COMMON\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"ppm_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread(thumb, 1, thumb_length, ifp);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *)calloc(thumb_length, 2);\n  merror(thumb, \"rollei_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts(thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n  {\n    putc(thumb[i] << 3, ofp);\n    putc(thumb[i] >> 5 << 2, ofp);\n    putc(thumb[i] >> 11 << 3, ofp);\n  }\n  free(thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }\n\nvoid CLASS phase_one_flat_field(int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts(head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0)\n    return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *)calloc(nc * wide, sizeof *mrow);\n  merror(mrow, \"phase_one_flat_field()\");\n  for (y = 0; y < high; y++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x = 0; x < wide; x++)\n      for (c = 0; c < nc; c += 2)\n      {\n        num = is_float ? getreal(11) : get2() / 32768.0;\n        if (y == 0)\n          mrow[c * wide + x] = num;\n        else\n          mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];\n      }\n    if (y == 0)\n      continue;\n    rend = head[1] + y * head[5];\n    for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)\n    {\n      for (x = 1; x < wide; x++)\n      {\n        for (c = 0; c < nc; c += 2)\n        {\n          mult[c] = mrow[c * wide + x - 1];\n          mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];\n        }\n        cend = head[0] + x * head[4];\n        for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)\n        {\n          c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;\n          if (!(c & 1))\n          {\n            c = RAW(row, col) * mult[c];\n            RAW(row, col) = LIM(c, 0, 65535);\n          }\n          for (c = 0; c < nc; c += 2)\n            mult[c] += mult[c + 1];\n        }\n      }\n      for (x = 0; x < wide; x++)\n        for (c = 0; c < nc; c += 2)\n          mrow[c * wide + x] += mrow[(c + 1) * wide + x];\n    }\n  }\n  free(mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {{-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n                                               {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n  if (half_size || !meta_length)\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Phase One correction...\\n\"));\n#endif\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    while (entries--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x419)\n      { /* Polynomial curve */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(11);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x41a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(11);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n            for (row = 0; row < raw_height; row++)\n              if (FC(row - top_margin, col - left_margin) == 1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;\n              }\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += raw(row + dir[i][0], col + dir[i][1]);\n            RAW(row, col) = (sum + 4) >> 3;\n          }\n        }\n      }\n      else if (tag == 0x401)\n      { /* All-color flat fields */\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x416 || tag == 0x410)\n      {\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x40b)\n      { /* Red+blue flat field */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x41f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 16; i++)\n              lc[qr][qc][i] = get4();\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x41e && !qmult_applied)\n      { /* Quadrant multipliers */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(11);\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x431 && !qmult_applied)\n      { /* Quadrant combined */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      merror(yval[0], \"phase_one_correct()\");\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(11);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek(ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555 : 0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");\n    if (ph1.black_col)\n    {\n      fseek(ifp, ph1.black_col, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);\n    }\n    if (ph1.black_row)\n    {\n      fseek(ifp, ph1.black_row, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);\n    }\n  }\n#endif\n  fseek(ifp, data_offset, SEEK_SET);\n  read_shorts(raw_image, raw_width * raw_height);\n  if (ph1.format)\n    for (i = 0; i < raw_width * raw_height; i += 2)\n    {\n      a = raw_image[i + 0] ^ akey;\n      b = raw_image[i + 1] ^ bkey;\n      raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n, 0)\n#define ph1_huff(h) ph1_bithuff(*h, h + 1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short(*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);\n  merror(pixel, \"phase_one_load_raw_c()\");\n  offset = (int *)(pixel + raw_width);\n  fseek(ifp, strip_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short(*)[2])(offset + raw_height);\n  fseek(ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n    read_shorts((ushort *)c_black[0], raw_height * 2);\n  r_black = c_black + raw_height;\n  fseek(ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n    read_shorts((ushort *)r_black[0], raw_width * 2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));\n  }\n#endif\n\n  for (i = 0; i < 256; i++)\n    curve[i] = i * i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + offset[row], SEEK_SET);\n      ph1_bits(-1);\n      pred[0] = pred[1] = 0;\n      for (col = 0; col < raw_width; col++)\n      {\n        if (col >= (raw_width & -8))\n          len[0] = len[1] = 14;\n        else if ((col & 7) == 0)\n          for (i = 0; i < 2; i++)\n          {\n            for (j = 0; j < 5 && !ph1_bits(1); j++)\n              ;\n            if (j--)\n              len[i] = length[j * 2 + ph1_bits(1)];\n          }\n        if ((i = len[col & 1]) == 14)\n          pixel[col] = pred[col & 1] = ph1_bits(16);\n        else\n          pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n        if (pred[col & 1] >> 16)\n          derror();\n        if (ph1.format == 5 && pixel[col] < 256)\n          pixel[col] = curve[pixel[col]];\n      }\n#ifndef LIBRAW_LIBRARY_BUILD\n      for (col = 0; col < raw_width; col++)\n      {\n        int shift = ph1.format == 8 ? 0 : 2;\n        i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +\n            r_black[col][row >= ph1.split_row];\n        if (i > 0)\n          RAW(row, col) = i;\n      }\n#else\n    if (ph1.format == 8)\n      memmove(&RAW(row, 0), &pixel[0], raw_width * 2);\n    else\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = pixel[col] << 2;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    back[4] = (int *)calloc(raw_width, 3 * sizeof **back);\n    merror(back[4], \"hasselblad_load_raw()\");\n    FORC3 back[c] = back[4] + c * raw_width;\n    cblack[6] >>= sh = tiff_samples > 1;\n    shot = LIM(shot_select, 1, tiff_samples) - 1;\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      FORC4 back[(c + 3) & 3] = back[c];\n      for (col = 0; col < raw_width; col += 2)\n      {\n        for (s = 0; s < tiff_samples * 2; s += 2)\n        {\n          FORC(2) len[c] = ph1_huff(jh.huff[0]);\n          FORC(2)\n          {\n            diff[s + c] = ph1_bits(len[c]);\n            if ((diff[s + c] & (1 << (len[c] - 1))) == 0)\n              diff[s + c] -= (1 << len[c]) - 1;\n            if (diff[s + c] == 65535)\n              diff[s + c] = -32768;\n          }\n        }\n        for (s = col; s < col + 2; s++)\n        {\n          pred = 0x8000 + load_flags;\n          if (col)\n            pred = back[2][s - 2];\n          if (col && row > 1)\n            switch (jh.psv)\n            {\n            case 11:\n              pred += back[0][s] / 2 - back[0][s - 2] / 2;\n              break;\n            }\n          f = (row & 1) * 3 ^ ((col + s) & 1);\n          FORC(tiff_samples)\n          {\n            pred += diff[(s & 1) * tiff_samples + c];\n            upix = pred >> sh & 0xffff;\n            if (raw_image && c == shot)\n              RAW(row, s) = upix;\n            if (image)\n            {\n              urow = row - top_margin + (c & 1);\n              ucol = col - left_margin - ((c >> 1) & 1);\n              ip = &image[urow * width + ucol][f];\n              if (urow < height && ucol < width)\n                *ip = c < 4 ? upix : (*ip + upix) >> 1;\n            }\n          }\n          back[2][s] = pred;\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(back[4]);\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  free(back[4]);\n  ljpeg_end(&jh);\n  if (image)\n    mix_green = 1;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel = 0;\n  unsigned tile = 0, r, c, row, col;\n\n  if (!filters)\n  {\n    pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n    merror(pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    FORC(tiff_samples)\n    for (r = 0; r < raw_height; r++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (r % tile_length == 0)\n      {\n        fseek(ifp, data_offset + 4 * tile++, SEEK_SET);\n        fseek(ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select)\n        continue;\n      if (filters)\n        pixel = raw_image + r * raw_width;\n      read_shorts(pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n        for (col = 0; col < width; col++)\n          image[row * width + col][c] = pixel[col + left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (!filters)\n      free(pixel);\n    throw;\n  }\n#endif\n  if (!filters)\n  {\n    maximum = 0xffff;\n    raw_color = 1;\n    free(pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  read_shorts(raw_image, raw_width * raw_height);\n  if (maximum < 0xffff)\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < raw_width; col++)\n        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n            (unsigned)(col - left_margin) < width)\n          derror();\n    }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \"imacon_full_load_raw\");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf = 0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height + 1) >> 1;\n  for (irow = 0; irow < raw_height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)\n    {\n      if (vbits = 0, tiff_compress)\n        fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);\n      else\n      {\n        fseek(ifp, 0, SEEK_END);\n        fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col = 0; col < raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n      RAW(row, col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)\n        derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom()\n{\n\n  /* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct\n  {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek(ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread(&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616; /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order)\n  {\n  case 0: /* RGGB */\n    filters = 0x94949494;\n    break;\n  case 1: /* GBRG */\n    filters = 0x49494949;\n    break;\n  case 3: /* GRBG */\n    filters = 0x61616161;\n    break;\n  }\n}\n\nvoid CLASS broadcom_load_raw()\n{\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *)malloc(raw_stride * 2);\n  merror(data, \"broadcom_load_raw()\");\n\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)\n      derror();\n    FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n#endif\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf = 0;\n\n  bwide = (raw_width + 5) / 6 << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_loose_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)\n    {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];\n      FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;\n    }\n  }\n  free(data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n#endif\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#else\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = get4();\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits(int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits)\n    return vbits = 0;\n  if (!vbits)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},\n                                    {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,\n      23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,\n      46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,\n      69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,\n      101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,\n      149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,\n      197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,\n      361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,\n      457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,\n      631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,\n      878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))\n\n#define FORYX                                                                                                          \\\n  for (y = 1; y < 3; y++)                                                                                              \\\n    for (x = col + 1; x >= col; x--)\n\n#define PREDICTOR                                                                                                      \\\n  (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)\n\n#ifdef __GNUC__\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n#pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n#endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }\n  for (i = 0; i < height * width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread(jpeg_buffer, 1, 4096, ifp);\n  swab(jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header(&cinfo, TRUE);\n  jpeg_start_decompress(&cinfo);\n  if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n  {\n    fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress(&cinfo);\n    longjmp(failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines(&cinfo, buf, 1);\n    pixel = (JSAMPLE(*)[3])buf[0];\n    for (col = 0; col < width; col += 2)\n    {\n      RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n      RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n      RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n      RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n    }\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf, \"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);\n  jpeg_create_decompress(&cinfo);\n  merror(pixel_buf, \"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf, data_size, 1, ifp);\n  swab((char *)jpg_buf, (char *)jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf;\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    free(pixel_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  unsigned sorder = order, ntags, opcode, deg, i, j, c;\n  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset)\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--)\n    {\n      opcode = get4();\n      get4();\n      get4();\n      if (opcode != 8)\n      {\n        fseek(ifp, get4(), SEEK_CUR);\n        continue;\n      }\n      fseek(ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2)\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8)\n        break;\n      for (i = 0; i <= deg && i < 9; i++)\n        coeff[i] = getreal(12);\n      for (i = 0; i < 256; i++)\n      {\n        for (tot = j = 0; j <= deg; j++)\n          tot += coeff[j] * pow(i / 255.0, (int)j);\n        cur[c][i] = tot * 0xffff;\n      }\n    }\n    order = sorder;\n  }\n  else\n  {\n    gamma_curve(1 / 2.4, 12.92, 1, 255);\n    FORC3 memcpy(cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  while (trow < raw_height)\n  {\n    fseek(ifp, save += 4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n#else\n    jpeg_stdio_src(&cinfo, ifp);\n#endif\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        jpeg_read_scanlines(&cinfo, buf, 1);\n        pixel = (JSAMPLE(*)[3])buf[0];\n        for (col = 0; col < cinfo.output_width && tcol + col < width; col++)\n        {\n          FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw;\n    }\n#endif\n    jpeg_abort_decompress(&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = {162, 192, 187, 92};\n  static const int add[4] = {0, 636, 424, 212};\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 848, ifp) < 848)\n      derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col = 0; col < width; col++)\n      RAW(row, col) = (ushort)pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, 1, raw_width, ifp) < raw_width)\n        derror();\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = curve[pixel[col]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] = {\n      {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n      {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder(kodak_tree[c]);\n  ns = (raw_height + 63) >> 5;\n  pixel = (uchar *)malloc(raw_width * 32 + ns * 4);\n  merror(pixel, \"kodak_262_load_raw()\");\n  strip = (int *)(pixel + raw_width * 32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if ((row & 31) == 0)\n      {\n        fseek(ifp, strip[row >> 5], SEEK_SET);\n        getbits(-1);\n        pi = 0;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        chess = (row + col) & 1;\n        pi1 = chess ? pi - 2 : pi - raw_width - 1;\n        pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;\n        if (col <= chess)\n          pi1 = -1;\n        if (pi1 < 0)\n          pi1 = pi2;\n        if (pi2 < 0)\n          pi2 = pi1;\n        if (pi1 < 0 && col > 1)\n          pi1 = pi2 = pi - 2;\n        pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n        pixel[pi] = val = pred + ljpeg_diff(huff[chess]);\n        if (val >> 8)\n          derror();\n        val = curve[pixel[pi++]];\n        RAW(row, col) = val;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  FORC(2) free(huff[c]);\n}\n\nint CLASS kodak_65000_decode(short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf = 0;\n  int save, bits = 0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i = 0; i < bsize; i += 2)\n  {\n    c = fgetc(ifp);\n    if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)\n    {\n      fseek(ifp, save, SEEK_SET);\n      for (i = 0; i < bsize; i += 8)\n      {\n        read_shorts(raw, 6);\n        out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n        out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n        for (j = 0; j < 6; j++)\n          out[i + 2 + j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4)\n  {\n    bitbuf = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i = 0; i < bsize; i++)\n  {\n    len = blen[i];\n    if (bits < len)\n    {\n      for (j = 0; j < 32; j += 8)\n        bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16 - len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len - 1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      pred[0] = pred[1] = 0;\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len);\n      for (i = 0; i < len; i++)\n        if ((RAW(row, col + i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])]) >> 12)\n          derror();\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt(unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start)\n  {\n    for (p = 0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;\n    for (p = 4; p < 127; p++)\n      pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;\n    for (p = 0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n  {\n    *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];\n    p++;\n  }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,\n                                 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n#ifdef LIBRAW_LIBRARY_BUILD\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit = 30, i = 0; i < 16; i++)\n        if (i == imax)\n          pix[i] = max;\n        else if (i == imin)\n          pix[i] = min;\n        else\n        {\n          pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n          if (pix[i] > 0x7ff)\n            pix[i] = 0x7ff;\n          bit += 7;\n        }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr\n                                ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)\n                                : 0;\n          }\n        }\n        else\n        {\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        }\n#else\n      for (i = 0; i < 16; i++, col += 2)\n        RAW(row, col) = curve[pix[i] << 1] >> 2;\n#endif\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n#endif\n  free(data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +\n                            (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,\n                                 0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        pred =\n            (pmode == 7 || row < 2)\n                ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment(unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {3, 3, 0, 0, 63, 47, 31, 15, 0}};\n  int low, high = 0xff, carry = 0, nbits = 8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[] = {0, 0};\n  ushort data = 0, range = 0;\n\n  fseek(ifp, seg[0][1] + 1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width * raw_height)\n    seg[1][0] = raw_width * raw_height;\n  for (pix = seg[0][0]; pix < seg[1][0]; pix++)\n  {\n    for (s = 0; s < 3; s++)\n    {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n        carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;\n      while (--nbits >= 0)\n        if ((data >> nbits & 0xff) == 0xff)\n          break;\n      if (nbits > 0)\n        data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |\n               ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0)\n      {\n        data += getbits(1);\n        carry = nbits - 8;\n      }\n      count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin = 0; hist[s][bin + 5] > count; bin++)\n        ;\n      low = hist[s][bin + 5] * (high >> 4) >> 2;\n      if (bin)\n        high = hist[s][bin + 4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits = 0; high << nbits < 128; nbits++)\n        ;\n      range = (range + low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3])\n      {\n        next = (next + 1) & hist[s][0];\n        hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;\n        hist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)\n      {\n        if (bin < hist[s][1])\n          for (i = bin; i < hist[s][1]; i++)\n            hist[s][i + 5]--;\n        else if (next <= bin)\n          for (i = hist[s][1]; i < bin; i++)\n            hist[s][i + 5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (pix >= raw_width * raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width))\n      pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek(ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment(seg, 0);\n}\n\nint CLASS median4(int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i = 1; i < 4; i++)\n  {\n    sum += p[i];\n    if (min > p[i])\n      min = p[i];\n    if (max < p[i])\n      max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes(int holes)\n{\n  int row, col, val[4];\n\n  for (row = 2; row < height - 2; row++)\n  {\n    if (!HOLE(row))\n      continue;\n    for (col = 1; col < width - 1; col += 4)\n    {\n      val[0] = RAW(row - 1, col - 1);\n      val[1] = RAW(row - 1, col + 1);\n      val[2] = RAW(row + 1, col - 1);\n      val[3] = RAW(row + 1, col + 1);\n      RAW(row, col) = median4(val);\n    }\n    for (col = 2; col < width - 2; col += 4)\n      if (HOLE(row - 2) || HOLE(row + 2))\n        RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;\n      else\n      {\n        val[0] = RAW(row, col - 2);\n        val[1] = RAW(row, col + 2);\n        val[2] = RAW(row - 2, col);\n        val[3] = RAW(row + 2, col);\n        RAW(row, col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek(ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar)fgetc(ifp);\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < nseg * 2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);\n  fseek(ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek(ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i = 0; i < nseg; i++)\n    smal_decode_segment(seg + i, holes);\n  if (holes)\n    fill_holes(holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen(ifname, \"rb\");\n#else\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg)\n    longjmp(failure, 3);\n#else\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n#endif\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try\n  {\n#endif\n    FORC4\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n#endif\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\n//@end COMMON\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder(unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code)\n  {\n    for (i = 0; i < size; i++)\n      huff[i] = get4();\n    memset(first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode + 2048)\n  {\n    fprintf(stderr, _(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp(failure, 2);\n  }\n  if (code)\n    for (i = 0; i < size; i++)\n      if (huff[i] == code)\n      {\n        cur->leaf = i;\n        return;\n      }\n  if ((len = code >> 27) > 26)\n    return;\n  code = (len + 1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder(size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder(size, code + 1);\n}\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf = 0, bit = 1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0)\n  {\n    if (bwide < thumb_width * 3)\n      return;\n    buf = (char *)malloc(bwide);\n    merror(buf, \"foveon_thumb()\");\n    for (row = 0; row < thumb_height; row++)\n    {\n      fread(buf, 1, bwide, ifp);\n      fwrite(buf, 3, thumb_width, ofp);\n    }\n    free(buf);\n    return;\n  }\n  foveon_decoder(256, 0);\n\n  for (row = 0; row < thumb_height; row++)\n  {\n    memset(pred, 0, sizeof pred);\n    if (!bit)\n      get4();\n    for (bit = col = 0; col < thumb_width; col++)\n      FORC3\n      {\n        for (dindex = first_decode; dindex->branch[0];)\n        {\n          if ((bit = (bit - 1) & 31) == 31)\n            for (i = 0; i < 4; i++)\n              bitbuf = (bitbuf << 8) + fgetc(ifp);\n          dindex = dindex->branch[bitbuf >> bit & 1];\n        }\n        pred[c] += dindex->leaf;\n        fputc(pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf = 0;\n  int pred[3], row, col, bit = -1, c, i;\n\n  read_shorts((ushort *)diff, 1024);\n  if (!load_flags)\n    foveon_decoder(1024, 0);\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model + 2) < 14)\n      get4();\n    for (col = bit = 0; col < width; col++)\n    {\n      if (load_flags)\n      {\n        bitbuf = get4();\n        FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];\n      }\n      else\n        FORC3\n        {\n          for (dindex = first_decode; dindex->branch[0];)\n          {\n            if ((bit = (bit - 1) & 31) == 31)\n              for (i = 0; i < 4; i++)\n                bitbuf = (bitbuf << 8) + fgetc(ifp);\n            dindex = dindex->branch[bitbuf >> bit & 1];\n          }\n          pred[c] += diff[dindex->leaf];\n          if (pred[c] >> 16 && ~pred[c] >> 16)\n            derror();\n        }\n      FORC3 image[row * width + col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff(ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i = 0; i < 13; i++)\n  {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j = 0; j<256>> clen;)\n      huff[code + ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek(ifp, 8, SEEK_CUR);\n  foveon_huff(huff);\n  roff[0] = 48;\n  FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);\n  FORC3\n  {\n    fseek(ifp, data_offset + roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        image[row * width + col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512, 512}, {512, 512}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  type = get4();\n  get4();\n  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2)\n  {\n    fread(meta_data, 1, meta_length, ifp);\n    for (i = 0; i < meta_length; i++)\n    {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64)301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  }\n  else if (type == 4)\n  {\n    free(meta_data);\n    meta_data = (char *)malloc(meta_length = wide * high * 3 / 2);\n    merror(meta_data, \"foveon_load_camf()\");\n    foveon_huff(huff);\n    get4();\n    getbits(-1);\n    for (j = row = 0; row < high; row++)\n    {\n      for (col = 0; col < wide; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if (col & 1)\n        {\n          meta_data[j++] = hpred[0] >> 4;\n          meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n          meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  }\n#ifdef DCRAW_VERBOSE\n  else\n    fprintf(stderr, _(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n#endif\n}\n\nconst char *CLASS foveon_camf_param(const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx = 0; idx < meta_length; idx += sget4(pos + 8))\n  {\n    pos = meta_data + idx;\n    if (strncmp(pos, \"CMb\", 3))\n      break;\n    if (pos[3] != 'P')\n      continue;\n    if (strcmp(block, pos + sget4(pos + 12)))\n      continue;\n    cp = pos + sget4(pos + 16);\n    num = sget4(cp);\n    dp = pos + sget4(cp + 4);\n    while (num--)\n    {\n      cp += 8;\n      if (!strcmp(param, dp + sget4(cp)))\n        return dp + sget4(cp + 4);\n    }\n  }\n  return 0;\n}\n\nvoid *CLASS foveon_camf_matrix(unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx = 0; idx < meta_length; idx += sget4(pos + 8))\n  {\n    pos = meta_data + idx;\n    if (strncmp(pos, \"CMb\", 3))\n      break;\n    if (pos[3] != 'M')\n      continue;\n    if (strcmp(name, pos + sget4(pos + 12)))\n      continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos + 16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp + 4)) > 3)\n      break;\n    dp = pos + sget4(cp + 8);\n    for (i = ndim; i--;)\n    {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double)dim[0] * dim[1] * dim[2]) > meta_length / 4)\n      break;\n    mat = (unsigned *)malloc((size = dsize) * 4);\n    merror(mat, \"foveon_camf_matrix()\");\n    for (i = 0; i < size; i++)\n      if (type && type != 6)\n        mat[i] = sget4(dp + i * 4);\n      else\n        mat[i] = sget4(dp + i * 2) & 0xffff;\n    return mat;\n  }\n#ifdef DCRAW_VERBOSE\n  fprintf(stderr, _(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n#endif\n  return 0;\n}\n\nint CLASS foveon_fixed(void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name)\n    return 0;\n  dp = foveon_camf_matrix(dim, name);\n  if (!dp)\n    return 0;\n  memcpy(ptr, dp, size * 4);\n  free(dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg(short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min = FLT_MAX, max = -FLT_MAX, sum = 0;\n\n  for (i = range[0]; i <= range[1]; i++)\n  {\n    sum += val = pix[i * 4] + (pix[i * 4] - pix[(i - 1) * 4]) * cfilt;\n    if (min > val)\n      min = val;\n    if (max < val)\n      max = val;\n  }\n  if (range[1] - range[0] == 1)\n    return sum / 2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort *CLASS foveon_make_curve(double max, double mul, double filt)\n{\n  short *curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt)\n    filt = 0.8;\n  size = 4 * M_PI * max / filt;\n  if (size == UINT_MAX)\n    size--;\n  curve = (short *)calloc(size + 1, sizeof *curve);\n  merror(curve, \"foveon_make_curve()\");\n  curve[0] = size;\n  for (i = 0; i < size; i++)\n  {\n    x = i * filt / max / 4;\n    curve[i + 1] = (cos(x) + 1) / 2 * tanh(i * filt / mul) * mul + 0.5;\n  }\n  return curve;\n}\n\nvoid CLASS foveon_make_curves(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max = 0;\n  int c;\n\n  FORC3 mul[c] = dq[c] / div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve(max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve(short *curve, int i)\n{\n  if (abs(i) >= curve[0])\n    return 0;\n  return i < 0 ? -curve[1 - i] : curve[1 + i];\n}\n\n#define image ((short(*)[4])image)\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = {-1, -1, -1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1};\n  short *pix, prev[3], *curve[8], (*shrink)[3];\n  float cfilt = 0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float(*black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p = 0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum = 0, trsum[3];\n  char str[128];\n  const char *cp;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Foveon interpolation...\\n\"));\n#endif\n\n  foveon_load_camf();\n  foveon_fixed(dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed(ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed(satlev, 3, \"SaturationLevel\");\n  foveon_fixed(keep, 4, \"KeepImageArea\");\n  foveon_fixed(active, 4, \"ActiveImageArea\");\n  foveon_fixed(chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed(color_dq, 3, foveon_camf_param(\"IncludeBlocks\", \"ColorDQ\") ? \"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param(\"IncludeBlocks\", \"ColumnFilter\"))\n    foveon_fixed(&cfilt, 1, \"ColumnFilter\");\n\n  memset(ddft, 0, sizeof ddft);\n  if (!foveon_camf_param(\"IncludeBlocks\", \"DarkDrift\") || !foveon_fixed(ddft[1][0], 12, \"DarkDrift\"))\n    for (i = 0; i < 2; i++)\n    {\n      foveon_fixed(dstb, 4, i ? \"DarkShieldBottom\" : \"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n        for (col = dstb[0]; col <= dstb[2]; col++)\n          FORC3 ddft[i + 1][c][1] += (short)image[row * width + col][c];\n      FORC3 ddft[i + 1][c][1] /= (dstb[3] - dstb[1] + 1) * (dstb[2] - dstb[0] + 1);\n    }\n\n  if (!(cp = foveon_camf_param(\"WhiteBalanceIlluminants\", model2)))\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n#endif\n    return;\n  }\n  foveon_fixed(cam_xyz, 9, cp);\n  foveon_fixed(correct, 9, foveon_camf_param(\"WhiteBalanceCorrections\", model2));\n  memset(last, 0, sizeof last);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n#define LAST(x, y) last[(i + x) % 3][(c + y) % 3]\n  for (i = 0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1, 1) * LAST(2, 2) - LAST(1, 2) * LAST(2, 1);\n#undef LAST\n  FORC3 div[c] = diag[c][0] * 0.3127 + diag[c][1] * 0.329 + diag[c][2] * 0.3583;\n  sprintf(str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param(\"IncludeBlocks\", str))\n    foveon_fixed(div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset(trans, 0, sizeof trans);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6 * trsum[0] + 11 * trsum[1] + 3 * trsum[2]) / 20;\n  for (i = 0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset(trans, 0, sizeof trans);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      FORC3 trans[i][j] += (i == c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves(curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves(curve + 3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  curve[6] = foveon_make_curve(dsum, dsum, cfilt);\n  curve[7] = foveon_make_curve(dsum * 2, dsum * 2, cfilt);\n\n  sgain = (float(*)[3])foveon_camf_matrix(dim, \"SpatialGain\");\n  if (!sgain)\n    return;\n  sgrow = (float(*)[3])calloc(dim[1], sizeof *sgrow);\n  sgx = (width + dim[1] - 2) / (dim[1] - 1);\n\n  black = (float(*)[3])calloc(height, sizeof *black);\n  for (row = 0; row < height; row++)\n  {\n    for (i = 0; i < 6; i++)\n      ((float *)ddft[0])[i] =\n          ((float *)ddft[1])[i] + row / (height - 1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    FORC3 black[row][c] = (foveon_avg(image[row * width] + c, dscr[0], cfilt) +\n                           foveon_avg(image[row * width] + c, dscr[1], cfilt) * 3 - ddft[0][c][0]) /\n                              4 -\n                          ddft[0][c][1];\n  }\n  memcpy(black, black + 8, sizeof *black * 8);\n  memcpy(black + height - 11, black + height - 22, 11 * sizeof *black);\n  memcpy(last, black, sizeof last);\n\n  for (row = 1; row < height - 1; row++)\n  {\n    FORC3 if (last[1][c] > last[0][c])\n    {\n      if (last[1][c] > last[2][c])\n        black[row][c] = (last[0][c] > last[2][c]) ? last[0][c] : last[2][c];\n    }\n    else if (last[1][c] < last[2][c]) black[row][c] = (last[0][c] < last[2][c]) ? last[0][c] : last[2][c];\n    memmove(last, last + 1, 2 * sizeof last[0]);\n    memcpy(last[2], black[row + 1], sizeof last[2]);\n  }\n  FORC3 black[row][c] = (last[0][c] + last[1][c]) / 2;\n  FORC3 black[0][c] = (black[1][c] + black[3][c]) / 2;\n\n  val = 1 - exp(-1 / 24.0);\n  memcpy(fsum, black, sizeof fsum);\n  for (row = 1; row < height; row++)\n    FORC3 fsum[c] += black[row][c] = (black[row][c] - black[row - 1][c]) * val + black[row - 1][c];\n  memcpy(last[0], black[height - 1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--;)\n    FORC3 last[0][c] = black[row][c] = (black[row][c] - fsum[c] - last[0][c]) * val + last[0][c];\n\n  memset(total, 0, sizeof total);\n  for (row = 2; row < height; row += 4)\n    for (col = 2; col < width; col += 4)\n    {\n      FORC3 total[c] += (short)image[row * width + col][c];\n      total[3]++;\n    }\n  for (row = 0; row < height; row++)\n    FORC3 black[row][c] += fsum[c] / 2 + total[c] / (total[3] * 100.0);\n\n  for (row = 0; row < height; row++)\n  {\n    for (i = 0; i < 6; i++)\n      ((float *)ddft[0])[i] =\n          ((float *)ddft[1])[i] + row / (height - 1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    pix = image[row * width];\n    memcpy(prev, pix, sizeof prev);\n    frow = row / (height - 1.0) * (dim[2] - 1);\n    if ((irow = frow) == dim[2] - 1)\n      irow--;\n    frow -= irow;\n    for (i = 0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[irow * dim[1] + i][c] * (1 - frow) + sgain[(irow + 1) * dim[1] + i][c] * frow;\n    for (col = 0; col < width; col++)\n    {\n      FORC3\n      {\n        diff = pix[c] - prev[c];\n        prev[c] = pix[c];\n        ipix[c] = pix[c] + floor((diff + (diff * diff >> 14)) * cfilt - ddft[0][c][1] -\n                                 ddft[0][c][0] * ((float)col / width - 0.5) - black[row][c]);\n      }\n      FORC3\n      {\n        work[0][c] = ipix[c] * ipix[c] >> 14;\n        work[2][c] = ipix[c] * work[0][c] >> 14;\n        work[1][2 - c] = ipix[(c + 1) % 3] * ipix[(c + 2) % 3] >> 14;\n      }\n      FORC3\n      {\n        for (val = i = 0; i < 3; i++)\n          for (j = 0; j < 3; j++)\n            val += ppm[c][i][j] * work[i][j];\n        ipix[c] =\n            floor((ipix[c] + floor(val)) *\n                  (sgrow[col / sgx][c] * (sgx - col % sgx) + sgrow[col / sgx + 1][c] * (col % sgx)) / sgx / div[c]);\n        if (ipix[c] > 32000)\n          ipix[c] = 32000;\n        pix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free(black);\n  free(sgrow);\n  free(sgain);\n\n  if ((badpix = (unsigned *)foveon_camf_matrix(dim, \"BadPixels\")))\n  {\n    for (i = 0; i < dim[0]; i++)\n    {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20) - keep[1];\n      if ((unsigned)(row - 1) > height - 3 || (unsigned)(col - 1) > width - 3)\n        continue;\n      memset(fsum, 0, sizeof fsum);\n      for (sum = j = 0; j < 8; j++)\n        if (badpix[i] & (1 << j))\n        {\n          FORC3 fsum[c] += (short)image[(row + hood[j * 2]) * width + col + hood[j * 2 + 1]][c];\n          sum++;\n        }\n      if (sum)\n        FORC3 image[row * width + col][c] = fsum[c] / sum;\n    }\n    free(badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int(*)[3])calloc(width * 5, sizeof **smrow);\n  merror(smrow[6], \"foveon_interpolate()\");\n  for (i = 0; i < 5; i++)\n    smrow[i] = smrow[6] + i * width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast = -1, row = 2; row < height - 2; row++)\n  {\n    while (smlast < row + 2)\n    {\n      for (i = 0; i < 6; i++)\n        smrow[(i + 5) % 6] = smrow[i];\n      pix = image[++smlast * width + 2];\n      for (col = 2; col < width - 2; col++)\n      {\n        smrow[4][col][0] = (pix[0] * 6 + (pix[-4] + pix[4]) * 4 + pix[-8] + pix[8] + 8) >> 4;\n        pix += 4;\n      }\n    }\n    pix = image[row * width + 2];\n    for (col = 2; col < width - 2; col++)\n    {\n      smred = (6 * smrow[2][col][0] + 4 * (smrow[1][col][0] + smrow[3][col][0]) + smrow[0][col][0] + smrow[4][col][0] +\n               8) >>\n              4;\n      if (col == 2)\n        smred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred * 7 + smred_p) >> 3)) >> 3);\n      if (i > 32000)\n        i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3\n  {\n    i = satlev[c] / div[c];\n    if (min > i)\n      min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix = image[0]; pix < image[height * width]; pix += 4)\n  {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c = 1; c < 3; c++)\n    {\n      if (min > pix[c])\n        min = pix[c];\n      if (max < pix[c])\n        max = pix[c];\n    }\n    if (min >= limit * 2)\n    {\n      pix[0] = pix[1] = pix[2] = max;\n    }\n    else\n    {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i * i >> 14);\n      i = i * i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n  /*\n     Because photons that miss one detector often hit another,\n     the sum R+G+B is much less noisy than the individual colors.\n     So smooth the hues without smoothing the total.\n   */\n  for (smlast = -1, row = 2; row < height - 2; row++)\n  {\n    while (smlast < row + 2)\n    {\n      for (i = 0; i < 6; i++)\n        smrow[(i + 5) % 6] = smrow[i];\n      pix = image[++smlast * width + 2];\n      for (col = 2; col < width - 2; col++)\n      {\n        FORC3 smrow[4][col][c] = (pix[c - 4] + 2 * pix[c] + pix[c + 4] + 2) >> 2;\n        pix += 4;\n      }\n    }\n    pix = image[row * width + 2];\n    for (col = 2; col < width - 2; col++)\n    {\n      FORC3 dev[c] =\n          -foveon_apply_curve(curve[7], pix[c] - ((smrow[1][col][c] + 2 * smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast = -1, row = 2; row < height - 2; row++)\n  {\n    while (smlast < row + 2)\n    {\n      for (i = 0; i < 6; i++)\n        smrow[(i + 5) % 6] = smrow[i];\n      pix = image[++smlast * width + 2];\n      for (col = 2; col < width - 2; col++)\n      {\n        FORC3 smrow[4][col][c] = (pix[c - 8] + pix[c - 4] + pix[c] + pix[c + 4] + pix[c + 8] + 2) >> 2;\n        pix += 4;\n      }\n    }\n    pix = image[row * width + 2];\n    for (col = 2; col < width - 2; col++)\n    {\n      for (total[3] = 375, sum = 60, c = 0; c < 3; c++)\n      {\n        for (total[c] = i = 0; i < 5; i++)\n          total[c] += smrow[i][col][c];\n        total[3] += total[c];\n        sum += pix[c];\n      }\n      if (sum < 0)\n        sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve(curve[6], ((j * total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix = image[0]; pix < image[height * width]; pix += 4)\n  {\n    FORC3 pix[c] -= foveon_apply_curve(curve[c], pix[c]);\n    sum = (pix[0] + pix[1] + pix[1] + pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve(curve[c], pix[c] - sum);\n    FORC3\n    {\n      for (dsum = i = 0; i < 3; i++)\n        dsum += trans[c][i] * pix[i];\n      if (dsum < 0)\n        dsum = 0;\n      if (dsum > 24000)\n        dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  shrink = (short(*)[3])calloc((height / 4), (width / 4) * sizeof *shrink);\n  merror(shrink, \"foveon_interpolate()\");\n  for (row = height / 4; row--;)\n    for (col = 0; col < width / 4; col++)\n    {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n          FORC3 ipix[c] += image[(row * 4 + i) * width + col * 4 + j][c];\n      FORC3\n      if (row + 2 > height / 4)\n        shrink[row * (width / 4) + col][c] = ipix[c] >> 4;\n      else\n        shrink[row * (width / 4) + col][c] =\n            (shrink[(row + 1) * (width / 4) + col][c] * 1840 + ipix[c] * 141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row = 0; row < (height & ~3); row++)\n  {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3; col--;)\n        FORC3 smrow[0][col][c] = ipix[c] =\n            (shrink[(row / 4) * (width / 4) + col / 4][c] * 1485 + ipix[c] * 6707 + 4096) >> 13;\n\n    /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col = 0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] = (smrow[0][col][c] * 1485 + ipix[c] * 6707 + 4096) >> 13;\n\n    /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy(smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col = 0; col < (width & ~3); col++)\n        FORC3 smrow[2][col][c] = (smrow[2][col][c] * 6707 + smrow[1][col][c] * 1485 + 4096) >> 13;\n\n    /* Adjust the chroma toward the smooth values */\n    for (col = 0; col < (width & ~3); col++)\n    {\n      for (i = j = 30, c = 0; c < 3; c++)\n      {\n        i += smrow[2][col][c];\n        j += image[row * width + col][c];\n      }\n      j = (j << 16) / i;\n      for (sum = c = 0; c < 3; c++)\n      {\n        ipix[c] =\n            foveon_apply_curve(curve[c + 3], ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row * width + col][c]);\n        sum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3\n      {\n        i = image[row * width + col][c] + ipix[c] - sum;\n        if (i < 0)\n          i = 0;\n        image[row * width + col][c] = i;\n      }\n    }\n  }\n  free(shrink);\n  free(smrow[6]);\n  for (i = 0; i < 8; i++)\n    free(curve[i]);\n\n  /* Trim off the black border */\n  active[1] -= keep[1];\n  active[3] -= 2;\n  i = active[2] - active[0];\n  for (row = 0; row < active[3] - active[1]; row++)\n    memcpy(image[row * i], image[(row + active[1]) * width + active[0]], i * sizeof *image);\n  width = i;\n  height = row;\n}\n#undef image\n\n/* RESTRICTED code ends here */\n\n//@out COMMON\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n      r,\n      raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;\n#else\n      c,\n      m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width)\n  {\n    for (row = 0; row < raw_height - top_margin * 2; row++)\n    {\n      for (col = 0; col < fuji_width << !fuji_layout; col++)\n      {\n        if (fuji_layout)\n        {\n          r = fuji_width - 1 - col + (row >> 1);\n          c = col + ((row + 1) >> 1);\n        }\n        else\n        {\n          r = fuji_width - 1 + row - (col >> 1);\n          c = row + ((col + 1) >> 1);\n        }\n        if (r < height && c < width)\n          BAYER(r, c) = RAW(row + top_margin, col + left_margin);\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < height; row++)\n      for (col = 0; col < width; col++)\n        BAYER2(row, col) = RAW(row + top_margin, col + left_margin);\n  }\n#endif\n  if (mask[0][3] > 0)\n    goto mask_set;\n  if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)\n  {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||\n      (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||\n      (load_raw == &CLASS packed_load_raw && (load_flags & 32)))\n  {\n  sides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin + height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin + width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset(mblack, 0, sizeof mblack);\n  for (zero = m = 0; m < 8; m++)\n    for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)\n      for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)\n      {\n        c = FC(row - top_margin, col - left_margin);\n        mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];\n        mblack[4 + c]++;\n        zero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width)\n  {\n    black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  }\n  else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n  {\n    FORC4 cblack[c] = mblack[c] / mblack[4 + c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);\n#endif\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      if (BAYER(row, col) == 0)\n      {\n        tot = n = 0;\n        for (r = row - 2; r <= row + 2; r++)\n          for (c = col - 2; c <= col + 2; c++)\n            if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))\n              tot += (n++, BAYER(r, c));\n        if (n)\n          BAYER(row, col) = tot / n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);\n#endif\n}\n//@end COMMON\n\n/* @out FILEIO\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end FILEIO */\n\n// @out FILEIO\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels(const char *cfname)\n{\n  FILE *fp = NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed = 0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 0, 2);\n#endif\n  if (cfname)\n    fp = fopen(cfname, \"r\");\n  // @end FILEIO\n  else\n  {\n    for (len = 32;; len *= 2)\n    {\n      fname = (char *)malloc(len);\n      if (!fname)\n        return;\n      if (getcwd(fname, len - 16))\n        break;\n      free(fname);\n      if (errno != ERANGE)\n        return;\n    }\n#if defined(WIN32) || defined(DJGPP)\n    if (fname[1] == ':')\n      memmove(fname, fname + 2, len - 2);\n    for (cp = fname; *cp; cp++)\n      if (*cp == '\\\\')\n        *cp = '/';\n#endif\n    cp = fname + strlen(fname);\n    if (cp[-1] == '/')\n      cp--;\n    while (*fname == '/')\n    {\n      strcpy(cp, \"/.badpixels\");\n      if ((fp = fopen(fname, \"r\")))\n        break;\n      if (cp == fname)\n        break;\n      while (*--cp != '/')\n        ;\n    }\n    free(fname);\n  }\n  // @out FILEIO\n  if (!fp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n    return;\n  }\n  while (fgets(line, 128, fp))\n  {\n    cp = strchr(line, '#');\n    if (cp)\n      *cp = 0;\n    if (sscanf(line, \"%d %d %d\", &col, &row, &time) != 3)\n      continue;\n    if ((unsigned)col >= width || (unsigned)row >= height)\n      continue;\n    if (time > timestamp)\n      continue;\n    for (tot = n = 0, rad = 1; rad < 3 && n == 0; rad++)\n      for (r = row - rad; r <= row + rad; r++)\n        for (c = col - rad; c <= col + rad; c++)\n          if ((unsigned)r < height && (unsigned)c < width && (r != row || c != col) && fcol(r, c) == fcol(row, col))\n          {\n            tot += BAYER2(r, c);\n            n++;\n          }\n    BAYER2(row, col) = tot / n;\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n    {\n      if (!fixed++)\n        fprintf(stderr, _(\"Fixed dead pixels at:\"));\n      fprintf(stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed)\n    fputc('\\n', stderr);\n#endif\n  fclose(fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 1, 2);\n#endif\n}\n\nvoid CLASS subtract(const char *fname)\n{\n  FILE *fp;\n  int dim[3] = {0, 0, 0}, comment = 0, number = 0, error = 0, nd = 0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 0, 2);\n#endif\n\n  if (!(fp = fopen(fname, \"rb\")))\n  {\n#ifdef DCRAW_VERBOSE\n    perror(fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5')\n    error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF)\n  {\n    if (c == '#')\n      comment = 1;\n    if (c == '\\n')\n      comment = 0;\n    if (comment)\n      continue;\n    if (isdigit(c))\n      number = 1;\n    if (number)\n    {\n      if (isdigit(c))\n        dim[nd] = dim[nd] * 10 + c - '0';\n      else if (isspace(c))\n      {\n        number = 0;\n        nd++;\n      }\n      else\n        error = 1;\n    }\n  }\n  if (error || nd < 3)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose(fp);\n    return;\n  }\n  else if (dim[0] != width || dim[1] != height || dim[2] != 65535)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose(fp);\n    return;\n  }\n  pixel = (ushort *)calloc(width, sizeof *pixel);\n  merror(pixel, \"subtract()\");\n  for (row = 0; row < height; row++)\n  {\n    fread(pixel, 2, width, fp);\n    for (col = 0; col < width; col++)\n      BAYER(row, col) = MAX(BAYER(row, col) - ntohs(pixel[col]), 0);\n  }\n  free(pixel);\n  fclose(fp);\n  memset(cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 1, 2);\n#endif\n}\n//@end FILEIO\n\n//@out COMMON\n\nstatic const uchar xlat[2][256] = {\n    {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,\n     0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,\n     0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,\n     0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,\n     0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,\n     0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,\n     0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,\n     0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,\n     0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,\n     0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,\n     0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,\n     0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,\n     0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,\n     0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},\n    {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,\n     0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,\n     0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,\n     0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,\n     0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,\n     0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,\n     0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,\n     0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,\n     0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,\n     0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,\n     0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,\n     0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,\n     0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,\n     0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};\n\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2] = {0, 0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)\n  {\n    for (i = 0; i < 48; i++)\n    {\n      g[2] = (bnd[0] + bnd[1]) / 2;\n      if (g[0])\n        bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];\n      else\n        bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0])\n      g[4] = g[2] * (1 / g[0] - 1);\n  }\n  if (g[0])\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;\n  else\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;\n  if (!mode--)\n  {\n    memcpy(gamm, g, sizeof gamm);\n    return;\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    curve[i] = 0xffff;\n    if ((r = (double)i / imax) < 1)\n      curve[i] = 0x10000 *\n                 (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))\n                       : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < 6; j++)\n      work[i][j] = j == i + 3;\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < size; k++)\n        work[i][j] += in[k][i] * in[k][j];\n  }\n  for (i = 0; i < 3; i++)\n  {\n    num = work[i][i];\n    for (j = 0; j < 6; j++)\n      work[i][j] /= num;\n    for (k = 0; k < 3; k++)\n    {\n      if (k == i)\n        continue;\n      num = work[k][i];\n      for (j = 0; j < 6; j++)\n        work[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i = 0; i < size; i++)\n    for (j = 0; j < 3; j++)\n      for (out[i][j] = k = 0; k < 3; k++)\n        out[i][j] += work[j][k + 3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i = 0; i < colors; i++) /* Multiply out XYZ colorspace */\n    for (j = 0; j < 3; j++)\n      for (cam_rgb[i][j] = k = 0; k < 3; k++)\n        cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i = 0; i < colors; i++)\n  {                               /* Normalize cam_rgb so that */\n    for (num = j = 0; j < 3; j++) /* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if (num > 0.00001)\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] /= num;\n      pre_mul[i] = 1 / num;\n    }\n    else\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] = 0.0;\n      pre_mul[i] = 1.0;\n    }\n  }\n  pseudoinverse(cam_rgb, inverse, colors);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n  // Coordinates of the GretagMacbeth ColorChecker squares\n  // width, height, 1st_column, 1st_row\n  int cut[NSQ][4];                                             // you must set these\n                                                               // ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin\n                                         {0.377, 0.345, 35.8}, // Light Skin\n                                         {0.247, 0.251, 19.3}, // Blue Sky\n                                         {0.337, 0.422, 13.3}, // Foliage\n                                         {0.265, 0.240, 24.3}, // Blue Flower\n                                         {0.261, 0.343, 43.1}, // Bluish Green\n                                         {0.506, 0.407, 30.1}, // Orange\n                                         {0.211, 0.175, 12.0}, // Purplish Blue\n                                         {0.453, 0.306, 19.8}, // Moderate Red\n                                         {0.285, 0.202, 6.6},  // Purple\n                                         {0.380, 0.489, 44.3}, // Yellow Green\n                                         {0.473, 0.438, 43.1}, // Orange Yellow\n                                         {0.187, 0.129, 6.1},  // Blue\n                                         {0.305, 0.478, 23.4}, // Green\n                                         {0.539, 0.313, 12.0}, // Red\n                                         {0.448, 0.470, 59.1}, // Yellow\n                                         {0.364, 0.233, 19.8}, // Magenta\n                                         {0.196, 0.252, 19.8}, // Cyan\n                                         {0.310, 0.316, 90.0}, // White\n                                         {0.310, 0.316, 59.1}, // Neutral 8\n                                         {0.310, 0.316, 36.2}, // Neutral 6.5\n                                         {0.310, 0.316, 19.8}, // Neutral 5\n                                         {0.310, 0.316, 9.0},  // Neutral 3.5\n                                         {0.310, 0.316, 3.1}}; // Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset(gmb_cam, 0, sizeof gmb_cam);\n  for (sq = 0; sq < NSQ; sq++)\n  {\n    FORCC count[c] = 0;\n    for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)\n      for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)\n      {\n        c = FC(row, col);\n        if (c >= colors)\n          c -= 2;\n        gmb_cam[sq][c] += BAYER2(row, col);\n        BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;\n        count[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse(gmb_xyz, inverse, NSQ);\n  for (pass = 0; pass < 2; pass++)\n  {\n    for (raw_color = i = 0; i < colors; i++)\n      for (j = 0; j < 3; j++)\n        for (cam_xyz[i][j] = k = 0; k < NSQ; k++)\n          cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff(rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq = 0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose)\n  {\n    printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));\n    puts(\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n  FORC(nc)\n  { /* denoise R,G1,B,G3 individually */\n    for (i = 0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass = lev = 0; lev < 5; lev++)\n    {\n      lpass = size * ((lev & 1) + 1);\n      for (row = 0; row < iheight; row++)\n      {\n        hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n        for (col = 0; col < iwidth; col++)\n          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n      }\n      for (col = 0; col < iwidth; col++)\n      {\n        hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n        for (row = 0; row < iheight; row++)\n          fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i = 0; i < size; i++)\n      {\n        fimg[hpass + i] -= fimg[lpass + i];\n        if (fimg[hpass + i] < -thold)\n          fimg[hpass + i] += thold;\n        else if (fimg[hpass + i] > thold)\n          fimg[hpass + i] -= thold;\n        else\n          fimg[hpass + i] = 0;\n        if (hpass)\n          fimg[i] += fimg[hpass + i];\n      }\n      hpass = lpass;\n    }\n    for (i = 0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n  }\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)\n#endif\n  {\n    temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);\n    FORC(nc)\n    { /* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass = lev = 0; lev < 5; lev++)\n      {\n        lpass = size * ((lev & 1) + 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (row = 0; row < iheight; row++)\n        {\n          hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n          for (col = 0; col < iwidth; col++)\n            fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n        }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (col = 0; col < iwidth; col++)\n        {\n          hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n          for (row = 0; row < iheight; row++)\n            fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n        }\n        thold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (i = 0; i < size; i++)\n        {\n          fimg[hpass + i] -= fimg[lpass + i];\n          if (fimg[hpass + i] < -thold)\n            fimg[hpass + i] += thold;\n          else if (fimg[hpass + i] > thold)\n            fimg[hpass + i] -= thold;\n          else\n            fimg[hpass + i] = 0;\n          if (hpass)\n            fimg[i] += fimg[hpass + i];\n        }\n        hpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n  /* the following loops are hard to parallize, no idea yes,\n   * problem is wlast which is carrying dependency\n   * second part should be easyer, but did not yet get it right.\n   */\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i, j;\n  double m1, m2, c1, c2;\n  int o1_1, o1_2, o1_3, o1_4;\n  int o2_1, o2_2, o2_3, o2_4;\n  ushort(*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if (half_size || shrink)\n    return;\n  if (FC(oj, oi) != 3)\n    oj++;\n  if (FC(oj, oi) != 3)\n    oi++;\n  if (FC(oj, oi) != 3)\n    oj--;\n\n  img = (ushort(*)[4])calloc(height * width, sizeof *image);\n  merror(img, \"green_matching()\");\n  memcpy(img, image, height * width * sizeof *image);\n\n  for (j = oj; j < height - margin; j += 2)\n    for (i = oi; i < width - margin; i += 2)\n    {\n      o1_1 = img[(j - 1) * width + i - 1][1];\n      o1_2 = img[(j - 1) * width + i + 1][1];\n      o1_3 = img[(j + 1) * width + i - 1][1];\n      o1_4 = img[(j + 1) * width + i + 1][1];\n      o2_1 = img[(j - 2) * width + i][3];\n      o2_2 = img[(j + 2) * width + i][3];\n      o2_3 = img[j * width + i - 2][3];\n      o2_4 = img[j * width + i + 2][3];\n\n      m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;\n      m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;\n\n      c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +\n            abs(o1_2 - o1_4)) /\n           6.0;\n      c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +\n            abs(o2_2 - o2_4)) /\n           6.0;\n      if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))\n      {\n        f = image[j * width + i][3] * m1 / m2;\n        image[j * width + i][3] = f > 0xffff ? 0xffff : f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img = 0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);\n#endif\n\n  if (user_mul[0])\n    memcpy(pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))\n  {\n    memset(dsum, 0, sizeof dsum);\n    bottom = MIN(greybox[1] + greybox[3], height);\n    right = MIN(greybox[0] + greybox[2], width);\n    for (row = greybox[1]; row < bottom; row += 8)\n      for (col = greybox[0]; col < right; col += 8)\n      {\n        memset(sum, 0, sizeof sum);\n        for (y = row; y < row + 8 && y < bottom; y++)\n          for (x = col; x < col + 8 && x < right; x++)\n            FORC4\n            {\n              if (filters)\n              {\n                c = fcol(y, x);\n                val = BAYER2(y, x);\n              }\n              else\n                val = image[y * width + x][c];\n              if (val > maximum - 25)\n                goto skip_block;\n              if ((val -= cblack[c]) < 0)\n                val = 0;\n              sum[c] += val;\n              sum[c + 4]++;\n              if (filters)\n                break;\n            }\n        FORC(8) dsum[c] += sum[c];\n      skip_block:;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1)\n  {\n    memset(sum, 0, sizeof sum);\n    for (row = 0; row < 8; row++)\n      for (col = 0; col < 8; col++)\n      {\n        c = FC(row, col);\n        if ((val = white[row][col] - cblack[c]) > 0)\n          sum[c] += val;\n        sum[c + 4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (load_raw == &LibRaw::nikon_load_sraw)\n    {\n      // Nikon sRAW: camera WB already applied:\n      pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;\n    }\n    else\n#endif\n        if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy(pre_mul, cam_mul, sizeof pre_mul);\n    else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n      fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&\n      cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)\n  {\n    for (c = 0; c < 3; c++)\n      pre_mul[c] /= cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0)\n    pre_mul[1] = 1;\n  if (pre_mul[3] == 0)\n    pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold)\n    wavelet_denoise();\n  maximum -= black;\n  for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)\n  {\n    if (dmin > pre_mul[c])\n      dmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n      dmax = pre_mul[c];\n  }\n  if (!highlight)\n    dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n  {\n    fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf(stderr, \" %f\", pre_mul[c]);\n    fputc('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)\n  {\n    FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight * iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i = 0; i < size * 4; i++)\n  {\n    if (!(val = ((ushort *)image)[i]))\n      continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3)\n  {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c = 0; c < 4; c += 2)\n    {\n      if (aber[c] == 1)\n        continue;\n      img = (ushort *)malloc(size * sizeof *img);\n      merror(img, \"scale_colors()\");\n      for (i = 0; i < size; i++)\n        img[i] = image[i][c];\n      for (row = 0; row < iheight; row++)\n      {\n        ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;\n        if (ur > iheight - 2)\n          continue;\n        fr -= ur;\n        for (col = 0; col < iwidth; col++)\n        {\n          uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;\n          if (uc > iwidth - 2)\n            continue;\n          fc -= uc;\n          pix = img + ur * iwidth + uc;\n          image[row * iwidth + col][c] =\n              (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;\n        }\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort(*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);\n#endif\n  if (shrink)\n  {\n    if (half_size)\n    {\n      height = iheight;\n      width = iwidth;\n      if (filters == 9)\n      {\n        for (row = 0; row < 3; row++)\n          for (col = 1; col < 4; col++)\n            if (!(image[row * width + col][0] | image[row * width + col][2]))\n              goto break2;\n      break2:\n        for (; row < height; row += 3)\n          for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)\n          {\n            img = image + row * width + col;\n            for (c = 0; c < 3; c += 2)\n              img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n          }\n      }\n    }\n    else\n    {\n      img = (ushort(*)[4])calloc(height, width * sizeof *img);\n      merror(img, \"pre_interpolate()\");\n      for (row = 0; row < height; row++)\n        for (col = 0; col < width; col++)\n        {\n          c = fcol(row, col);\n          img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];\n        }\n      free(image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3)\n  {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size)\n      colors++;\n    else\n    {\n      for (row = FC(1, 0) >> 1; row < height; row += 2)\n        for (col = FC(row, 1) & 1; col < width; col += 2)\n          image[row * width + col][1] = image[row * width + col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size)\n    filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);\n#endif\n}\n\nvoid CLASS border_interpolate(int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      if (col == border && row >= border && row < height - border)\n        col = width - border;\n      memset(sum, 0, sizeof sum);\n      for (y = row - 1; y != row + 2; y++)\n        for (x = col - 1; x != col + 2; x++)\n          if (y < height && x < width)\n          {\n            f = fcol(y, x);\n            sum[f] += image[y * width + x][f];\n            sum[f + 4]++;\n          }\n      f = fcol(row, col);\n      FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size = 16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#endif\n\n  if (filters == 9)\n    size = 6;\n  border_interpolate(1);\n  for (row = 0; row < size; row++)\n    for (col = 0; col < size; col++)\n    {\n      ip = code[row][col] + 1;\n      f = fcol(row, col);\n      memset(sum, 0, sizeof sum);\n      for (y = -1; y <= 1; y++)\n        for (x = -1; x <= 1; x++)\n        {\n          shift = (y == 0) + (x == 0);\n          color = fcol(row + y, col + x);\n          if (color == f)\n            continue;\n          *ip++ = (width * y + x) * 4 + color;\n          *ip++ = shift;\n          *ip++ = color;\n          sum[color] += 1 << shift;\n        }\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n      if (c != f)\n      {\n        *ip++ = c;\n        *ip++ = sum[c] > 0 ? 256 / sum[c] : 0;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#endif\n  lin_interpolate_loop(code, size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp,\n      terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,\n                 -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,\n                 -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,\n                 -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,\n                 -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,\n                 -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,\n                 -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,\n                 -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,\n                 -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,\n                 -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,\n                 +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,\n                 +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,\n                 +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,\n                 +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,\n                 +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,\n                 +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},\n      chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};\n  ushort(*brow[5])[4], *pix;\n  int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1)\n    prow = pcol = 16;\n  if (filters == 9)\n    prow = pcol = 6;\n  ip = (int *)calloc(prow * pcol, 1280);\n  merror(ip, \"vng_interpolate()\");\n  for (row = 0; row < prow; row++) /* Precalculate for VNG */\n    for (col = 0; col < pcol; col++)\n    {\n      code[row][col] = ip;\n      for (cp = terms, t = 0; t < 64; t++)\n      {\n        y1 = *cp++;\n        x1 = *cp++;\n        y2 = *cp++;\n        x2 = *cp++;\n        weight = *cp++;\n        grads = *cp++;\n        color = fcol(row + y1, col + x1);\n        if (fcol(row + y2, col + x2) != color)\n          continue;\n        diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;\n        if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)\n          continue;\n        *ip++ = (y1 * width + x1) * 4 + color;\n        *ip++ = (y2 * width + x2) * 4 + color;\n        *ip++ = weight;\n        for (g = 0; g < 8; g++)\n          if (grads & 1 << g)\n            *ip++ = g;\n        *ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp = chood, g = 0; g < 8; g++)\n      {\n        y = *cp++;\n        x = *cp++;\n        *ip++ = (y * width + x) * 4;\n        color = fcol(row, col);\n        if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)\n          *ip++ = (y * width + x) * 8 + color;\n        else\n          *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);\n  merror(brow[4], \"vng_interpolate()\");\n  for (row = 0; row < 3; row++)\n    brow[row] = brow[4] + row * width;\n  for (row = 2; row < height - 2; row++)\n  { /* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!((row - 2) % 256))\n      RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);\n#endif\n    for (col = 2; col < width - 2; col++)\n    {\n      pix = image[row * width + col];\n      ip = code[row % prow][col % pcol];\n      memset(gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX)\n      { /* Calculate gradients */\n        diff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n        gval[ip[3]] += diff;\n        ip += 5;\n        if ((g = ip[-1]) == -1)\n          continue;\n        gval[g] += diff;\n        while ((g = *ip++) != -1)\n          gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0]; /* Choose a threshold */\n      for (g = 1; g < 8; g++)\n      {\n        if (gmin > gval[g])\n          gmin = gval[g];\n        if (gmax < gval[g])\n          gmax = gval[g];\n      }\n      if (gmax == 0)\n      {\n        memcpy(brow[2][col], pix, sizeof *image);\n        continue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset(sum, 0, sizeof sum);\n      color = fcol(row, col);\n      for (num = g = 0; g < 8; g++, ip += 2)\n      { /* Average the neighbors */\n        if (gval[g] <= thold)\n        {\n          FORCC\n          if (c == color && ip[1])\n            sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n          else\n            sum[c] += pix[ip[0] + c];\n          num++;\n        }\n      }\n      FORCC\n      { /* Save to buffer */\n        t = pix[color];\n        if (c != color)\n          t += (sum[c] - sum[color]) / num;\n        brow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3) /* Write buffer to image */\n      memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n    for (g = 0; g < 4; g++)\n      brow[(g - 1) & 3] = brow[g];\n  }\n  memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n  memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);\n  free(brow[4]);\n  free(code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = {1, width, -1, -width, 1};\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort(*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 3; row < height - 3; row++)\n    for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; i++)\n      {\n        guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];\n        diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +\n                  (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)\n        pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)\n      {\n        diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);\n        guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n        pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n        pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab(ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb)\n  {\n#ifndef LIBRAW_NOTHREADS\n    if (cbrt[0] < -1.0f)\n#endif\n      for (i = 0; i < 0x10000; i++)\n      {\n        r = i / 65535.0;\n        cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;\n      }\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (xyz_cam[i][j] = k = 0; k < 3; k++)\n          xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC\n  {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int)xyz[0])];\n  xyz[1] = cbrt[CLIP((int)xyz[1])];\n  xyz[2] = cbrt[CLIP((int)xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512 /* Tile Size */\n#define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate(int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},\n                     dir[4] = {1, TS, TS + 1, TS - 1};\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n        {\n          val = pix[hex[c]][1];\n          if (min > val)\n            min = val;\n          if (max < val)\n            max = val;\n        }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row - sgrow) % 3)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n          row--;\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n          memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n      FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);\n\n      /* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n        {\n          if ((f = fcol(row, col)) == 1)\n            continue;\n          pix = image + row * width + col;\n          hex = allhex[row % 3][col % 3][0];\n          color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n          color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);\n          FORC(2)\n          color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +\n                            33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);\n          FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n        }\n\n      for (pass = 0; pass < passes; pass++)\n      {\n        if (pass == 1)\n          memcpy(rgb += 4, buffer, 4 * sizeof *rgb);\n\n        /* Recalculate green from interpolated values of closer pixels:\t*/\n        if (pass)\n        {\n          for (row = top + 2; row < mrow - 2; row++)\n            for (col = left + 2; col < mcol - 2; col++)\n            {\n              if ((f = fcol(row, col)) == 1)\n                continue;\n              pix = image + row * width + col;\n              hex = allhex[row % 3][col % 3][1];\n              for (d = 3; d < 6; d++)\n              {\n                rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                val =\n                    rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n              }\n            }\n        }\n\n        /* Interpolate red and blue values for solitary green pixels:\t*/\n        for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n          for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n          {\n            rix = &rgb[0][row - top][col - left];\n            h = fcol(row, col + 1);\n            memset(diff, 0, sizeof diff);\n            for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)\n            {\n              for (c = 0; c < 2; c++, h ^= 2)\n              {\n                g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                if (d > 1)\n                  diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);\n              }\n              if (d > 1 && (d & 1))\n                if (diff[d - 1] < diff[d])\n                  FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n              if (d < 2 || (d & 1))\n              {\n                FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                rix += TS * TS;\n              }\n            }\n          }\n\n        /* Interpolate red for blue pixels and vice versa:\t\t*/\n        for (row = top + 3; row < mrow - 3; row++)\n          for (col = left + 3; col < mcol - 3; col++)\n          {\n            if ((f = 2 - fcol(row, col)) == 1)\n              continue;\n            rix = &rgb[0][row - top][col - left];\n            c = (row - sgrow) % 3 ? TS : 1;\n            h = 3 * (c ^ TS ^ 1);\n            for (d = 0; d < 4; d++, rix += TS * TS)\n            {\n              i = d > 1 || ((d ^ c) & 1) || ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <\n                                             2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))\n                      ? c\n                      : h;\n              rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);\n            }\n          }\n\n        /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n        for (row = top + 2; row < mrow - 2; row++)\n          if ((row - sgrow) % 3)\n            for (col = left + 2; col < mcol - 2; col++)\n              if ((col - sgcol) % 3)\n              {\n                rix = &rgb[0][row - top][col - left];\n                hex = allhex[row % 3][col % 3][1];\n                for (d = 0; d < ndir; d += 2, rix += TS * TS)\n                  if (hex[d] + hex[d + 1])\n                  {\n                    g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                  }\n                  else\n                  {\n                    g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                  }\n              }\n      }\n      rgb = (ushort(*)[TS][TS][3])buffer;\n      mrow -= top;\n      mcol -= left;\n\n      /* Convert to CIELab and differentiate in all directions:\t*/\n      for (d = 0; d < ndir; d++)\n      {\n        for (row = 2; row < mrow - 2; row++)\n          for (col = 2; col < mcol - 2; col++)\n            cielab(rgb[d][row][col], lab[row][col]);\n        for (f = dir[d & 3], row = 3; row < mrow - 3; row++)\n          for (col = 3; col < mcol - 3; col++)\n          {\n            lix = &lab[row][col];\n            g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n            drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                               SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n          }\n      }\n\n      /* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir * TS * TS);\n      for (row = 4; row < mrow - 4; row++)\n        for (col = 4; col < mcol - 4; col++)\n        {\n          for (tr = FLT_MAX, d = 0; d < ndir; d++)\n            if (tr > drv[d][row][col])\n              tr = drv[d][row][col];\n          tr *= 8;\n          for (d = 0; d < ndir; d++)\n            for (v = -1; v <= 1; v++)\n              for (h = -1; h <= 1; h++)\n                if (drv[d][row + v][col + h] <= tr)\n                  homo[d][row][col]++;\n        }\n\n      /* Average the most homogenous pixels for the final result:\t*/\n      if (height - top < TS + 4)\n        mrow = height - top + 2;\n      if (width - left < TS + 4)\n        mcol = width - left + 2;\n      for (row = MIN(top, 8); row < mrow - 8; row++)\n        for (col = MIN(left, 8); col < mcol - 8; col++)\n        {\n          for (d = 0; d < ndir; d++)\n            for (hm[d] = 0, v = -2; v <= 2; v++)\n              for (h = -2; h <= 2; h++)\n                hm[d] += homo[d][row + v][col + h];\n          for (d = 0; d < ndir - 4; d++)\n            if (hm[d] < hm[d + 4])\n              hm[d] = 0;\n            else if (hm[d] > hm[d + 4])\n              hm[d + 4] = 0;\n          for (max = hm[0], d = 1; d < ndir; d++)\n            if (max < hm[d])\n              max = hm[d];\n          max -= max >> 3;\n          memset(avg, 0, sizeof avg);\n          for (d = 0; d < ndir; d++)\n            if (hm[d] >= max)\n            {\n              FORC3 avg[c] += rgb[d][row][col][c];\n              avg[3]++;\n            }\n          FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n        }\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + TS, height - 2);\n  const int collimit = MIN(left + TS, width - 2);\n\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n      out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],\n                                                                short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort(*pix)[4];\n  ushort(*rix)[3];\n  short(*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4 * width;\n  const unsigned rowlimit = MIN(top + TS - 1, height - 3);\n  const unsigned collimit = MIN(left + TS - 1, width - 3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top + 1; row < rowlimit; row++)\n  {\n    pix = image + row * width + left;\n    rix = &inout_rgb[row - top][0];\n    lix = &out_lab[row - top][0];\n\n    for (col = left + 1; col < collimit; col++)\n    {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1)\n      {\n        c = FC(row + 1, col);\n        t1 = 2 - c;\n        val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);\n      }\n      else\n      {\n        t1 = -4 + c; /* -4+c: pixel of color c to the left */\n        t2 = 4 + c;  /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -\n                            rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                           2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row, col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0], lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],\n                                                         short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++)\n  {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],\n                                                 char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short(*lix)[3];\n  short(*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = {-1, 1, -TS, TS};\n  const int rowlimit = MIN(top + TS - 2, height - 4);\n  const int collimit = MIN(left + TS - 2, width - 4);\n  int homogeneity;\n  char(*homogeneity_map_p)[2];\n\n  memset(out_homogeneity_map, 0, 2 * TS * TS);\n\n  for (row = top + 2; row < rowlimit; row++)\n  {\n    tr = row - top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction = 0; direction < 2; direction++)\n    {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col = left + 2; col < collimit; col++)\n    {\n      tc = col - left;\n      homogeneity_map_p++;\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        lix = ++lixs[direction];\n        for (i = 0; i < 4; i++)\n        {\n          adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n      for (direction = 0; direction < 2; direction++)\n      {\n        homogeneity = 0;\n        for (i = 0; i < 4; i++)\n        {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)\n          {\n            homogeneity++;\n          }\n        }\n        homogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],\n                                                      char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top + TS - 3, height - 5);\n  const int collimit = MIN(left + TS - 3, width - 5);\n\n  ushort(*pix)[4];\n  ushort(*rix[2])[3];\n\n  for (row = top + 3; row < rowlimit; row++)\n  {\n    tr = row - top;\n    pix = &image[row * width + left + 2];\n    for (direction = 0; direction < 2; direction++)\n    {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col = left + 3; col < collimit; col++)\n    {\n      tc = col - left;\n      pix++;\n      for (direction = 0; direction < 2; direction++)\n      {\n        rix[direction]++;\n      }\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        hm[direction] = 0;\n        for (i = tr - 1; i <= tr + 1; i++)\n        {\n          for (j = tc - 1; j <= tc + 1; j++)\n          {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1])\n      {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      }\n      else\n      {\n        FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4], r;\n  char *buffer;\n  ushort(*rgb)[TS][TS][3];\n  short(*lab)[TS][TS][3];\n  char(*homo)[TS][2];\n  int terminate_flag = 0;\n\n  cielab(0, 0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *)malloc(26 * TS * TS); /* 1664 kB */\n    merror(buffer, \"ahd_interpolate()\");\n    rgb = (ushort(*)[TS][TS][3])buffer;\n    lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n    homo = (char(*)[TS][2])(buffer + 24 * TS * TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top = 2; top < height - 5; top += TS - 6)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n      if (0 == omp_get_thread_num())\n#endif\n        if (callbacks.progress_cb)\n        {\n          int rr =\n              (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);\n          if (rr)\n            terminate_flag = 1;\n        }\n#endif\n      for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)\n      {\n        ahd_interpolate_green_h_and_v(top, left, rgb);\n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free(buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (terminate_flag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = {-1, 1, -TS, TS};\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][TS][3], (*lix)[3];\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab(0, 0);\n  border_interpolate(5);\n  buffer = (char *)malloc(26 * TS * TS);\n  merror(buffer, \"ahd_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n  homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);\n\n  for (top = 2; top < height - 5; top += TS - 6)\n    for (left = 2; left < width - 5; left += TS - 6)\n    {\n\n      /*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top + TS && row < height - 2; row++)\n      {\n        col = left + (FC(row, left) & 1);\n        for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)\n        {\n          pix = image + row * width + col;\n          val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n          rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n          val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n          rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n        }\n      }\n\n      /*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d = 0; d < 2; d++)\n        for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)\n          for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)\n          {\n            pix = image + row * width + col;\n            rix = &rgb[d][row - top][col - left];\n            lix = &lab[d][row - top][col - left];\n            if ((c = 2 - FC(row, col)) == 1)\n            {\n              c = FC(row + 1, col);\n              val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);\n              rix[0][2 - c] = CLIP(val);\n              val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);\n            }\n            else\n              val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -\n                                  rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                                 2);\n            rix[0][c] = CLIP(val);\n            c = FC(row, col);\n            rix[0][c] = pix[0][c];\n            cielab(rix[0], lix[0]);\n          }\n      /*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset(homo, 0, 2 * TS * TS);\n      for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)\n      {\n        tr = row - top;\n        for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n          {\n            lix = &lab[d][tr][tc];\n            for (i = 0; i < 4; i++)\n            {\n              ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);\n              abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);\n            }\n          }\n          leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n          abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n          for (d = 0; d < 2; d++)\n            for (i = 0; i < 4; i++)\n              if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n                homo[d][tr][tc]++;\n        }\n      }\n      /*  Combine the most homogenous pixels for the final result:\t*/\n      for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)\n      {\n        tr = row - top;\n        for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n            for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)\n              for (j = tc - 1; j <= tc + 1; j++)\n                hm[d] += homo[d][i][j];\n          if (hm[0] != hm[1])\n            FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n          else\n            FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n        }\n      }\n    }\n  free(buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = /* Optimal 9-element median search */\n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n                                       {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned)(colors - 3) > 1)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n#endif\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow(2.0, 4 - highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc = 0, c = 1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c])\n      kc = c;\n  high = height / SCALE;\n  wide = width / SCALE;\n  map = (float *)calloc(high, wide * sizeof *map);\n  merror(map, \"recover_highlights()\");\n  FORCC if (c != kc)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);\n#endif\n    memset(map, 0, high * wide * sizeof *map);\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        sum = wgt = count = 0;\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)\n            {\n              sum += pixel[c];\n              wgt += pixel[kc];\n              count++;\n            }\n          }\n        if (count == SCALE * SCALE)\n          map[mrow * wide + mcol] = sum / wgt;\n      }\n    for (spread = 32 / grow; spread--;)\n    {\n      for (mrow = 0; mrow < high; mrow++)\n        for (mcol = 0; mcol < wide; mcol++)\n        {\n          if (map[mrow * wide + mcol])\n            continue;\n          sum = count = 0;\n          for (d = 0; d < 8; d++)\n          {\n            y = mrow + dir[d][0];\n            x = mcol + dir[d][1];\n            if (y < high && x < wide && map[y * wide + x] > 0)\n            {\n              sum += (1 + (d & 1)) * map[y * wide + x];\n              count += 1 + (d & 1);\n            }\n          }\n          if (count > 3)\n            map[mrow * wide + mcol] = -(sum + grow) / (count + grow);\n        }\n      for (change = i = 0; i < high * wide; i++)\n        if (map[i] < 0)\n        {\n          map[i] = -map[i];\n          change = 1;\n        }\n      if (!change)\n        break;\n    }\n    for (i = 0; i < high * wide; i++)\n      if (map[i] == 0)\n        map[i] = 1;\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] > 1)\n            {\n              val = pixel[kc] * map[mrow * wide + mcol];\n              if (pixel[c] < val)\n                pixel[c] = CLIP(val);\n            }\n          }\n      }\n  }\n  free(map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag = get2();\n  *type = get2();\n  *len = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)\n    fseek(ifp, get4() + base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == toff)\n      thumb_offset = get4() + base;\n    if (tag == tlen)\n      thumb_length = get4();\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nint CLASS parse_tiff_ifd(int base);\n\n//@out COMMON\n\nstatic float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }\nstatic float powf64(float a, float b) { return powf_lim(a, b, 64.f); }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x)\n{\n  float t;\n  if (x >= 0.0)\n  {\n    t = ceilf(x);\n    if (t - x > 0.5)\n      t -= 1.0;\n    return t;\n  }\n  else\n  {\n    t = ceilf(-x);\n    if (t + x > 0.5)\n      t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))\n    return 0.0f;\n  return powf64(2.0, in / 64.0);\n}\n\nstatic float _CanonConvertEV(short in)\n{\n  short EV, Sign, Frac;\n  float Frac_f;\n  EV = in;\n  if (EV < 0)\n  {\n    EV = -EV;\n    Sign = -1;\n  }\n  else\n  {\n    Sign = 1;\n  }\n  Frac = EV & 0x1f;\n  EV -= Frac; // remove fraction\n\n  if (Frac == 0x0c)\n  { // convert 1/3 and 2/3 codes\n    Frac_f = 32.0f / 3.0f;\n  }\n  else if (Frac == 0x14)\n  {\n    Frac_f = 64.0f / 3.0f;\n  }\n  else\n    Frac_f = (float)Frac;\n\n  return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x80000001) || // 1D\n      (id == 0x80000174) || // 1D2\n      (id == 0x80000232) || // 1D2N\n      (id == 0x80000169) || // 1D3\n      (id == 0x80000281)    // 1D4\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000167) || // 1Ds\n           (id == 0x80000188) || // 1Ds2\n           (id == 0x80000215) || // 1Ds3\n           (id == 0x80000269) || // 1DX\n           (id == 0x80000328) || // 1DX2\n           (id == 0x80000324) || // 1DC\n           (id == 0x80000213) || // 5D\n           (id == 0x80000218) || // 5D2\n           (id == 0x80000285) || // 5D3\n           (id == 0x80000349) || // 5D4\n           (id == 0x80000382) || // 5DS\n           (id == 0x80000401) || // 5DS R\n           (id == 0x80000302)    // 6D\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000331) || // M\n           (id == 0x80000355) || // M2\n           (id == 0x80000374) || // M3\n           (id == 0x80000384) || // M10\n           (id == 0x80000394)    // M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n  }\n  else if ((id == 0x01140000) || // D30\n           (id == 0x01668000) || // D60\n           (id > 0x80000000))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n  }\n  else\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n  }\n\n  return;\n}\n\nvoid CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,\n         iCanonFocalType = 0;\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id)\n  {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12))\n      iCanonLensID = 151;\n    else\n      iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n  {\n    if (iCanonFocalType >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n    if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'\n      imgdata.lens.makernotes.FocalType = 1;\n  }\n  if (!imgdata.lens.makernotes.CurFocal)\n  {\n    if (iCanonCurFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n  }\n  if (!imgdata.lens.makernotes.LensID)\n  {\n    if (iCanonLensID >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n  }\n  if (!imgdata.lens.makernotes.MinFocal)\n  {\n    if (iCanonMinFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n  }\n  if (!imgdata.lens.makernotes.MaxFocal)\n  {\n    if (iCanonMaxFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n  }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)\n  {\n    if (iCanonLens + 64 >= maxlen)\n      return;                        // broken;\n    if (CameraInfo[iCanonLens] < 65) // non-Canon lens\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2();\n  get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2();\n  get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2();\n  get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n  {\n    imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n  }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets(short WBCTversion)\n{\n  if (WBCTversion == 0)\n    for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if (WBCTversion == 1)\n    for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3\n                                  (unique_id == 0x80000384) || // M10\n                                  (unique_id == 0x80000394) || // M5\n                                  (unique_id == 0x03970000) || // G7 X Mark II\n                                  (unique_id == 0x04100000)))  // G9 X Mark II\n    for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X\n    for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  return;\n}\n\nvoid CLASS processNikonLensData(uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n  {\n    if (imgdata.lens.nikon.NikonLensType & 0x04)\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n    else\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n    imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n  {\n    imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n    imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20)\n  {\n    switch (len)\n    {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n    {\n      if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n        imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n      if (LensData[i + 7])\n        imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n    }\n    imgdata.lens.makernotes.LensID =\n        (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |\n        (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |\n        (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |\n        (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;\n  }\n  else if ((len == 459) || (len == 590))\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n  }\n  else if (len == 509)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n  }\n  else if (len == 879)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n  }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures(unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) || // E-1\n      (id == 0x4434303431ULL) || // E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n    if ((id == 0x4434303430ULL) ||                              // E-1\n        (id == 0x4434303431ULL) ||                              // E-330\n        ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n        (id == 0x5330303233ULL) ||                              // E-620\n        (id == 0x5330303239ULL) ||                              // E-450\n        (id == 0x5330303330ULL) ||                              // E-600\n        (id == 0x5330303333ULL))                                // E-5\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n    }\n    else\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n    }\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)\n{\n\n  if (tag == 0x0001)\n    Canon_CameraSettings();\n  else if (tag == 0x0002) // focal length\n  {\n    imgdata.lens.makernotes.FocalType = get2();\n    imgdata.lens.makernotes.CurFocal = get2();\n    if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  }\n\n  else if (tag == 0x0004) // shot info\n  {\n    short tempAp;\n    fseek(ifp, 30, SEEK_CUR);\n    imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n    fseek(ifp, 8 - 32, SEEK_CUR);\n    if ((tempAp = get2()) != 0x7fff)\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n    if (imgdata.lens.makernotes.CurAp < 0.7f)\n    {\n      fseek(ifp, 32, SEEK_CUR);\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n    }\n    if (!aperture)\n      aperture = imgdata.lens.makernotes.CurAp;\n  }\n\n  else if (tag == 0x0095 && // lens model tag\n           !imgdata.lens.makernotes.Lens[0])\n  {\n    fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens\n      fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n    else\n    {\n      char efs[2];\n      imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n      imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n      fread(efs, 2, 1, ifp);\n      if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n      { // \"EF-S, TS-E, MP-E, EF-M\" lenses\n        imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n        imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n        imgdata.lens.makernotes.Lens[4] = 32;\n        if (efs[1] == 83)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n        }\n        else if (efs[1] == 77)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n        }\n      }\n      else\n      { // \"EF\" lenses\n        imgdata.lens.makernotes.Lens[2] = 32;\n        imgdata.lens.makernotes.Lens[3] = efs[0];\n        imgdata.lens.makernotes.Lens[4] = efs[1];\n      }\n      fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n    }\n  }\n\n  else if (tag == 0x00a9)\n  {\n    long int save1 = ftell(ifp);\n    fseek(ifp, save1 + (0x5 << 1), SEEK_SET);\n    Canon_WBpresets(0, 0);\n    fseek(ifp, save1, SEEK_SET);\n  }\n\n  else if (tag == 0x00e0) // sensor info\n  {\n    imgdata.makernotes.canon.SensorWidth = (get2(), get2());\n    imgdata.makernotes.canon.SensorHeight = get2();\n    imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());\n    imgdata.makernotes.canon.SensorTopBorder = get2();\n    imgdata.makernotes.canon.SensorRightBorder = get2();\n    imgdata.makernotes.canon.SensorBottomBorder = get2();\n    imgdata.makernotes.canon.BlackMaskLeftBorder = get2();\n    imgdata.makernotes.canon.BlackMaskTopBorder = get2();\n    imgdata.makernotes.canon.BlackMaskRightBorder = get2();\n    imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n  }\n\n  else if (tag == 0x4001 && len > 500)\n  {\n    int c;\n    long int save1 = ftell(ifp);\n    switch (len)\n    {\n    case 582:\n      imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D\n      {\n        fseek(ifp, save1 + (0x23 << 1), SEEK_SET);\n        Canon_WBpresets(2, 2);\n        fseek(ifp, save1 + (0x4b << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 653:\n      imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2\n      {\n        fseek(ifp, save1 + (0x27 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 796:\n      imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x4e << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n    // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n    // 7D / 40D / 50D / 60D / 450D / 500D\n    // 550D / 1000D / 1100D\n    case 674:\n    case 692:\n    case 702:\n    case 1227:\n    case 1250:\n    case 1251:\n    case 1337:\n    case 1338:\n    case 1346:\n      imgdata.makernotes.canon.CanonColorDataVer = 4;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x53 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n      {\n        fseek(ifp, save1 + (0x2b9 << 1), SEEK_SET); // offset 697 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n               (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n      {\n        fseek(ifp, save1 + (0x2d0 << 1), SEEK_SET); // offset 720 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n      {\n        fseek(ifp, save1 + (0x2d4 << 1), SEEK_SET); // offset 724 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    case 5120:\n      imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5\n      {\n        fseek(ifp, save1 + (0x56 << 1), SEEK_SET);\n        if ((unique_id == 0x03970000) || // G7 X Mark II\n            (unique_id == 0x04100000) || // G9 X Mark II\n            (unique_id == 0x80000394))   // EOS M5\n        {\n          fseek(ifp, 18, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          Canon_WBpresets(8, 24);\n          fseek(ifp, 168, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n          fseek(ifp, 24, SEEK_CUR);\n          Canon_WBCTpresets(2); // BCADT\n          fseek(ifp, 6, SEEK_CUR);\n        }\n        else\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          get2();\n          Canon_WBpresets(2, 12);\n          fseek(ifp, save1 + (0xba << 1), SEEK_SET);\n          Canon_WBCTpresets(2);                       // BCADT\n          fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short\n        }\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n\n    case 1273:\n    case 1275:\n      imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x67 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xbc << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      fseek(ifp, save1 + (0x1e4 << 1), SEEK_SET); // offset 484 shorts\n      imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      break;\n\n    // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n    case 1312:\n    case 1313:\n    case 1316:\n    case 1506:\n      imgdata.makernotes.canon.CanonColorDataVer = 7;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n      {\n        fseek(ifp, save1 + (0x1fd << 1), SEEK_SET); // offset 509 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n      {\n        fseek(ifp, save1 + (0x2dd << 1), SEEK_SET); // offset 733 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    // 5DS / 5DS R / 80D / 1300D / 5D4\n    case 1560:\n    case 1592:\n    case 1353:\n      imgdata.makernotes.canon.CanonColorDataVer = 8;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x107 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D\n      {\n        fseek(ifp, save1 + (0x231 << 1), SEEK_SET);\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else\n      {\n        fseek(ifp, save1 + (0x30f << 1), SEEK_SET); // offset 783 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n    }\n    fseek(ifp, save1, SEEK_SET);\n  }\n}\n\nvoid CLASS setPentaxBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id)\n  {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n  case 0x1322c:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO(ushort c)\n{\n  int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,   12,   13,  14,  15,  16,  17,  18,  19,\n                20,  21,  22,  23,  24,  25,  26,  27,  28,   29,   30,  31,  32,  33,  34,  35,  36,\n                37,  38,  39,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264,\n                265, 266, 267, 268, 269, 270, 271, 272, 273,  274,  275, 276, 277, 278};\n  double value[] = {50,    64,    80,    100,   125,   160,   200,   250,    320,    400,    500,    640,   800,\n                    1000,  1250,  1600,  2000,  2500,  3200,  4000,  5000,   6400,   8000,   10000,  12800, 16000,\n                    20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50,    100,\n                    200,   400,   800,   1600,  3200,  50,    70,    100,    140,    200,    280,    400,   560,\n                    800,   1100,  1600,  2200,  3200,  4500,  6400,  9000,   12800,  18000,  25600,  36000, 51200};\n#define numel (sizeof(code) / sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++)\n  {\n    if (code[i] == c)\n    {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel)\n    iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207\n{\n  ushort iLensData = 0;\n  uchar *table_buf;\n  table_buf = (uchar *)malloc(MAX(len, 128));\n  fread(table_buf, len, 1, ifp);\n  if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D\n                          (id == 0x12b9d) ||  // K110D\n                          (id == 0x12ba2)) && // K100D Super\n                         ((!table_buf[20] || (table_buf[20] == 0xff)))))\n  {\n    iLensData = 3;\n    if (imgdata.lens.makernotes.LensID == -1)\n      imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];\n  }\n  else\n    switch (len)\n    {\n    case 90: // LensInfo3\n      iLensData = 13;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 91: // LensInfo4\n      iLensData = 12;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 80: // LensInfo5\n    case 128:\n      iLensData = 15;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];\n      break;\n    default:\n      if (id >= 0x12b9c) // LensInfo2\n      {\n        iLensData = 4;\n        if (imgdata.lens.makernotes.LensID == -1)\n          imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];\n      }\n    }\n  if (iLensData)\n  {\n    if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n      imgdata.lens.makernotes.CurFocal =\n          10 * (table_buf[iLensData + 9] >> 2) * powf64(4, (table_buf[iLensData + 9] & 0x03) - 2);\n    if (table_buf[iLensData + 10] & 0xf0)\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);\n    if (table_buf[iLensData + 10] & 0x0f)\n      imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);\n\n    if (iLensData != 12)\n    {\n      switch (table_buf[iLensData] & 0x06)\n      {\n      case 0:\n        imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;\n        break;\n      case 2:\n        imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;\n        break;\n      case 4:\n        imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;\n        break;\n      case 6:\n        imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;\n        break;\n      }\n      if (table_buf[iLensData] & 0x70)\n        imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n      imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);\n      imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);\n\n      if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);\n    }\n    else if ((id != 0x12e76) && // K-5\n             (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n    {\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);\n    }\n  }\n  free(table_buf);\n  return;\n}\n\nvoid CLASS setPhaseOneFeatures(unsigned id)\n{\n\n  ushort i;\n  static const struct\n  {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n      // Phase One section:\n      {1, \"Hasselblad V\"},\n      {10, \"PhaseOne/Mamiya\"},\n      {12, \"Contax 645\"},\n      {16, \"Hasselblad V\"},\n      {17, \"Hasselblad V\"},\n      {18, \"Contax 645\"},\n      {19, \"PhaseOne/Mamiya\"},\n      {20, \"Hasselblad V\"},\n      {21, \"Contax 645\"},\n      {22, \"PhaseOne/Mamiya\"},\n      {23, \"Hasselblad V\"},\n      {24, \"Hasselblad H\"},\n      {25, \"PhaseOne/Mamiya\"},\n      {32, \"Contax 645\"},\n      {34, \"Hasselblad V\"},\n      {35, \"Hasselblad V\"},\n      {36, \"Hasselblad H\"},\n      {37, \"Contax 645\"},\n      {38, \"PhaseOne/Mamiya\"},\n      {39, \"Hasselblad V\"},\n      {40, \"Hasselblad H\"},\n      {41, \"Contax 645\"},\n      {42, \"PhaseOne/Mamiya\"},\n      {44, \"Hasselblad V\"},\n      {45, \"Hasselblad H\"},\n      {46, \"Contax 645\"},\n      {47, \"PhaseOne/Mamiya\"},\n      {48, \"Hasselblad V\"},\n      {49, \"Hasselblad H\"},\n      {50, \"Contax 645\"},\n      {51, \"PhaseOne/Mamiya\"},\n      {52, \"Hasselblad V\"},\n      {53, \"Hasselblad H\"},\n      {54, \"Contax 645\"},\n      {55, \"PhaseOne/Mamiya\"},\n      {67, \"Hasselblad V\"},\n      {68, \"Hasselblad H\"},\n      {69, \"Contax 645\"},\n      {70, \"PhaseOne/Mamiya\"},\n      {71, \"Hasselblad V\"},\n      {72, \"Hasselblad H\"},\n      {73, \"Contax 645\"},\n      {74, \"PhaseOne/Mamiya\"},\n      {76, \"Hasselblad V\"},\n      {77, \"Hasselblad H\"},\n      {78, \"Contax 645\"},\n      {79, \"PhaseOne/Mamiya\"},\n      {80, \"Hasselblad V\"},\n      {81, \"Hasselblad H\"},\n      {82, \"Contax 645\"},\n      {83, \"PhaseOne/Mamiya\"},\n      {84, \"Hasselblad V\"},\n      {85, \"Hasselblad H\"},\n      {86, \"Contax 645\"},\n      {87, \"PhaseOne/Mamiya\"},\n      {99, \"Hasselblad V\"},\n      {100, \"Hasselblad H\"},\n      {101, \"Contax 645\"},\n      {102, \"PhaseOne/Mamiya\"},\n      {103, \"Hasselblad V\"},\n      {104, \"Hasselblad H\"},\n      {105, \"PhaseOne/Mamiya\"},\n      {106, \"Contax 645\"},\n      {112, \"Hasselblad V\"},\n      {113, \"Hasselblad H\"},\n      {114, \"Contax 645\"},\n      {115, \"PhaseOne/Mamiya\"},\n      {131, \"Hasselblad V\"},\n      {132, \"Hasselblad H\"},\n      {133, \"Contax 645\"},\n      {134, \"PhaseOne/Mamiya\"},\n      {135, \"Hasselblad V\"},\n      {136, \"Hasselblad H\"},\n      {137, \"Contax 645\"},\n      {138, \"PhaseOne/Mamiya\"},\n      {140, \"Hasselblad V\"},\n      {141, \"Hasselblad H\"},\n      {142, \"Contax 645\"},\n      {143, \"PhaseOne/Mamiya\"},\n      {148, \"Hasselblad V\"},\n      {149, \"Hasselblad H\"},\n      {150, \"Contax 645\"},\n      {151, \"PhaseOne/Mamiya\"},\n      {160, \"A-250\"},\n      {161, \"A-260\"},\n      {162, \"A-280\"},\n      {167, \"Hasselblad V\"},\n      {168, \"Hasselblad H\"},\n      {169, \"Contax 645\"},\n      {170, \"PhaseOne/Mamiya\"},\n      {172, \"Hasselblad V\"},\n      {173, \"Hasselblad H\"},\n      {174, \"Contax 645\"},\n      {175, \"PhaseOne/Mamiya\"},\n      {176, \"Hasselblad V\"},\n      {177, \"Hasselblad H\"},\n      {178, \"Contax 645\"},\n      {179, \"PhaseOne/Mamiya\"},\n      {180, \"Hasselblad V\"},\n      {181, \"Hasselblad H\"},\n      {182, \"Contax 645\"},\n      {183, \"PhaseOne/Mamiya\"},\n      {208, \"Hasselblad V\"},\n      {211, \"PhaseOne/Mamiya\"},\n      {448, \"Phase One 645AF\"},\n      {457, \"Phase One 645DF\"},\n      {471, \"Phase One 645DF+\"},\n      {704, \"Phase One iXA\"},\n      {705, \"Phase One iXA - R\"},\n      {706, \"Phase One iXU 150\"},\n      {707, \"Phase One iXU 150 - NIR\"},\n      {708, \"Phase One iXU 180\"},\n      {721, \"Phase One iXR\"},\n      // Leaf section:\n      {333, \"Mamiya\"},\n      {329, \"Universal\"},\n      {330, \"Hasselblad H1/H2\"},\n      {332, \"Contax\"},\n      {336, \"AFi\"},\n      {327, \"Mamiya\"},\n      {324, \"Universal\"},\n      {325, \"Hasselblad H1/H2\"},\n      {326, \"Contax\"},\n      {335, \"AFi\"},\n      {340, \"Mamiya\"},\n      {337, \"Universal\"},\n      {338, \"Hasselblad H1/H2\"},\n      {339, \"Contax\"},\n      {323, \"Mamiya\"},\n      {320, \"Universal\"},\n      {322, \"Hasselblad H1/H2\"},\n      {321, \"Contax\"},\n      {334, \"AFi\"},\n      {369, \"Universal\"},\n      {370, \"Mamiya\"},\n      {371, \"Hasselblad H1/H2\"},\n      {372, \"Contax\"},\n      {373, \"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0])\n  {\n    for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id)\n      {\n        strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes(unsigned tag, unsigned type)\n{\n  switch (tag)\n  {\n  case 0x1002:\n    imgdata.makernotes.fuji.WB_Preset = get2();\n    break;\n  case 0x1011:\n    imgdata.other.FlashEC = getreal(type);\n    break;\n  case 0x1020:\n    imgdata.makernotes.fuji.Macro = get2();\n    break;\n  case 0x1021:\n    imgdata.makernotes.fuji.FocusMode = get2();\n    break;\n  case 0x1022:\n    imgdata.makernotes.fuji.AFMode = get2();\n    break;\n  case 0x1023:\n    imgdata.makernotes.fuji.FocusPixel[0] = get2();\n    imgdata.makernotes.fuji.FocusPixel[1] = get2();\n    break;\n  case 0x1034:\n    imgdata.makernotes.fuji.ExrMode = get2();\n    break;\n  case 0x1050:\n    imgdata.makernotes.fuji.ShutterType = get2();\n    break;\n  case 0x1400:\n    imgdata.makernotes.fuji.FujiDynamicRange = get2();\n    break;\n  case 0x1401:\n    imgdata.makernotes.fuji.FujiFilmMode = get2();\n    break;\n  case 0x1402:\n    imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();\n    break;\n  case 0x1403:\n    imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();\n    break;\n  case 0x140b:\n    imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();\n    break;\n  case 0x1404:\n    imgdata.lens.makernotes.MinFocal = getreal(type);\n    break;\n  case 0x1405:\n    imgdata.lens.makernotes.MaxFocal = getreal(type);\n    break;\n  case 0x1406:\n    imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n    break;\n  case 0x1407:\n    imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n    break;\n  case 0x1422:\n    imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n    imgdata.shootinginfo.ImageStabilization =\n        (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];\n    break;\n  case 0x1431:\n    imgdata.makernotes.fuji.Rating = get4();\n    break;\n  case 0x3820:\n    imgdata.makernotes.fuji.FrameRate = get2();\n    break;\n  case 0x3821:\n    imgdata.makernotes.fuji.FrameWidth = get2();\n    break;\n  case 0x3822:\n    imgdata.makernotes.fuji.FrameHeight = get2();\n    break;\n  }\n  return;\n}\n\nvoid CLASS setSonyBodyFeatures(unsigned id)\n{\n\n  imgdata.lens.makernotes.CamID = id;\n  if (               // FF cameras\n      (id == 257) || // a900\n      (id == 269) || // a850\n      (id == 340) || // ILCE-7M2\n      (id == 318) || // ILCE-7S\n      (id == 350) || // ILCE-7SM2\n      (id == 311) || // ILCE-7R\n      (id == 347) || // ILCE-7RM2\n      (id == 306) || // ILCE-7\n      (id == 298) || // DSC-RX1\n      (id == 299) || // NEX-VG900\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 354) || // ILCA-99M2\n      (id == 294)    // SLT-99, Hasselblad HV\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n  }\n  else if ((id == 297) || // DSC-RX100\n           (id == 308) || // DSC-RX100M2\n           (id == 309) || // DSC-RX10\n           (id == 317) || // DSC-RX100M3\n           (id == 341) || // DSC-RX100M4\n           (id == 342) || // DSC-RX10M2\n           (id == 355) || // DSC-RX10M3\n           (id == 356)    // DSC-RX100M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  else if (id != 002) // DSC-R1\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n  }\n\n  if ( // E-mount cameras, ILCE series\n      (id == 302) || (id == 306) || (id == 311) || (id == 312) || (id == 313) || (id == 318) || (id == 339) ||\n      (id == 340) || (id == 346) || (id == 347) || (id == 350) || (id == 360))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n  }\n  else if ( // E-mount cameras, NEX series\n      (id == 278) || (id == 279) || (id == 284) || (id == 288) || (id == 289) || (id == 290) || (id == 293) ||\n      (id == 295) || (id == 296) || (id == 299) || (id == 300) || (id == 305) || (id == 307))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n  }\n\n  else if ( // A-mount cameras, DSLR series\n      (id == 256) || (id == 257) || (id == 258) || (id == 259) || (id == 260) || (id == 261) || (id == 262) ||\n      (id == 263) || (id == 264) || (id == 265) || (id == 266) || (id == 269) || (id == 270) || (id == 273) ||\n      (id == 274) || (id == 275) || (id == 282) || (id == 283))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n  }\n  else if ( // A-mount cameras, SLT series\n      (id == 280) || (id == 281) || (id == 285) || (id == 286) || (id == 287) || (id == 291) || (id == 292) ||\n      (id == 294) || (id == 303))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n  }\n  else if ( // A-mount cameras, ILCA series\n      (id == 319) || (id == 353) || (id == 354))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n  }\n\n  else if (          // DSC\n      (id == 002) || // DSC-R1\n      (id == 297) || // DSC-RX100\n      (id == 298) || // DSC-RX1\n      (id == 308) || // DSC-RX100M2\n      (id == 309) || // DSC-RX10\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 317) || // DSC-RX100M3\n      (id == 341) || // DSC-RX100M4\n      (id == 342) || // DSC-RX10M2\n      (id == 355) || // DSC-RX10M3\n      (id == 356)    // DSC-RX100M5\n      )\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n  }\n  return;\n}\n\nvoid CLASS parseSonyLensType2(uchar a, uchar b)\n{\n  ushort lid2;\n  lid2 = (((ushort)a) << 8) | ((ushort)b);\n  if (!lid2)\n    return;\n  if (lid2 < 0x100)\n  {\n    if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2)\n      {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n      }\n    }\n  }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    imgdata.lens.makernotes.AdapterID = 0x4900;\n  }\n  return;\n}\n\n#define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures(uchar a, uchar b)\n{\n\n  ushort features;\n  features = (((ushort)a) << 8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100))\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n  {\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n    if ((features & 0x0200) && (features & 0x0100))\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0200)\n    {\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0100)\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n    }\n  }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,\n            strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c(uchar *buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0009]]);\n  return;\n}\n\nvoid CLASS process_Sony_0x9050(uchar *buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n  {\n    if (buf[0])\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n\n    if (buf[1])\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n  }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (buf[0x3d] | buf[0x3c])\n    {\n      lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];\n      imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);\n    }\n    if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n        (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n      imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];\n    if (buf[0x106])\n      imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];\n  }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n  {\n    parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0107]]);\n  }\n  if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n  {\n    imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];\n\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n  }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long b88 = SonySubstitution[buf[0x88]];\n    unsigned long b89 = SonySubstitution[buf[0x89]];\n    unsigned long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if (len > 8 && pos + len > 2 * fsize)\n      continue;\n    tag |= uptag << 16;\n    if (len > 100 * 1024 * 1024)\n      goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes(tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x1d) // serial number\n        while ((c = fgetc(ifp)) && c != EOF)\n        {\n          if ((!custom_serial) && (!isdigit(c)))\n          {\n            if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n            {\n              custom_serial = 34;\n            }\n            else\n            {\n              custom_serial = 96;\n            }\n          }\n          serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n        }\n      else if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0097)\n      {\n        for (i = 0; i < 4; i++)\n          ver97 = ver97 * 10 + fgetc(ifp) - '0';\n        if (ver97 == 601) // Coolpix A\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n\n      else if (tag == 0xa7) // shutter count\n      {\n        NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n        if ((NikonLensDataVersion > 200) && lenNikonLensData)\n        {\n          if (custom_serial)\n          {\n            ci = xlat[0][custom_serial];\n          }\n          else\n          {\n            ci = xlat[0][serial & 0xff];\n          }\n          cj = xlat[1][NikonKey];\n          ck = 0x60;\n          for (i = 0; i < lenNikonLensData; i++)\n            table_buf[i] ^= (cj += ci * ck++);\n          processNikonLensData(table_buf, lenNikonLensData);\n          lenNikonLensData = 0;\n          free(table_buf);\n        }\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n\n      else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc, 1, 1, ifp);\n        iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n        break;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&\n                              strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);\n\n      if ((tag == 0x2010) || (tag == 0x2020))\n      {\n        fseek(ifp, save - 4, SEEK_SET);\n        fseek(ifp, base + get4(), SEEK_SET);\n        parse_makernote_0xc634(base, tag, dng_writer);\n      }\n      if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||\n                                 (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n      switch (tag)\n      {\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20100102:\n        stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x20100201:\n        imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |\n                                         (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |\n                                         (unsigned long long)fgetc(ifp);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        if ((!imgdata.lens.LensSerial[0]))\n          stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      case 0x20200401:\n        imgdata.other.FlashEC = getreal(type);\n        break;\n      }\n    skip_Oly_broken_tags:;\n    }\n\n    else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 12, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        imgdata.lens.makernotes.CamID = unique_id = get4();\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n\n                // a450, a500, a550, a560, a580\n                // a33, a35, a55\n                // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n            {\n              if (table_buf[0] | table_buf[3])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n              if (table_buf[2] | table_buf[5])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n              parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            }\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n            {\n              if (table_buf[1] | table_buf[2])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n              if (table_buf[3] | table_buf[4])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n              if (table_buf[5])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n              if (table_buf[6])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n              parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            }\n          }\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 65535) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n        {\n          if (table_buf[1] | table_buf[2])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n          if (table_buf[3] | table_buf[4])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n          if (table_buf[5])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n          if (table_buf[6])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n          parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        }\n        free(table_buf);\n      }\n    }\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */}\n#endif\n\nvoid CLASS parse_makernote(int base, int uptag)\n{\n  unsigned offset = 0, entries, tag, type, len, save, c;\n  unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder = order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n  /*\n     The MakerNote might have its own TIFF header (possibly with\n     its own byte-order!), or it might just be a table.\n   */\n  if (!strncmp(make, \"Nokia\", 5))\n    return;\n  fread(buf, 1, 10, ifp);\n  if (!strncmp(buf, \"KDK\", 3) || /* these aren't TIFF tables */\n      !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))\n    return;\n  if (!strncmp(buf, \"KC\", 2) || /* Konica KD-400Z, KD-510Z */\n      !strncmp(buf, \"MLY\", 3))\n  { /* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i = ftell(ifp)) < data_offset && i < 16384)\n    {\n      wb[0] = wb[2];\n      wb[2] = wb[1];\n      wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n        FORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if (!strncmp(make, \"SAMSUNG\", 7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n  {\n    if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))\n    {\n      base = ftell(ifp) - 8;\n    }\n    else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n    {\n      base = 0;\n    }\n    else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||\n             !strncasecmp(model, \"Leica M Monochrom\", 11))\n    {\n      if (!uptag)\n      {\n        base = ftell(ifp) - 10;\n        fseek(ifp, 8, SEEK_CUR);\n      }\n      else if (uptag == 0x3400)\n      {\n        fseek(ifp, 10, SEEK_CUR);\n        base += 10;\n      }\n    }\n    else if (!strncasecmp(model, \"LEICA T\", 7))\n    {\n      base = ftell(ifp) - 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (!strncasecmp(model, \"LEICA SL\", 8))\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n#endif\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if (len > 8 && _pos + len > 2 * fsize)\n      continue;\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n    {\n      if (tag == 0x0010)\n      {\n        char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n        char *words[4];\n        char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n        int year, nwords, ynum_len;\n        unsigned c;\n        stmread(FujiSerial, len, ifp);\n        nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n        for (int i = 0; i < nwords; i++)\n        {\n          mm[2] = dd[2] = 0;\n          if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)\n            if (i == 0)\n              strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          else\n          {\n            strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);\n            strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);\n            strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);\n            year = (yy[0] - '0') * 10 + (yy[1] - '0');\n            if (year < 70)\n              year += 2000;\n            else\n              year += 1900;\n\n            ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;\n            strncpy(ynum, words[i], ynum_len);\n            ynum[ynum_len] = 0;\n            for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)\n              ystr[j / 2] = c;\n            ystr[ynum_len / 2 + 1] = 0;\n            strcpy(model2, ystr);\n\n            if (i == 0)\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n              if (nwords == 1)\n                snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,\n                         year, mm, dd);\n\n              else\n                snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,\n                       dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          }\n        }\n      }\n      else\n        parseFujiMakernotes(tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0012)\n      {\n        char a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n          imgdata.other.FlashEC = (float)(a * b) / (float)c;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData > 0)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n      else if (tag == 0x00a0)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      switch (tag)\n      {\n      case 0x0404:\n      case 0x101a:\n      case 0x20100101:\n        if (!imgdata.shootinginfo.BodySerial[0])\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n      case 0x20100102:\n        if (!imgdata.shootinginfo.InternalBodySerial[0])\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20401112:\n        imgdata.makernotes.olympus.OlympusCropID = get2();\n        break;\n      case 0x20401113:\n        FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n        break;\n      case 0x20100201:\n      {\n        unsigned long long oly_lensid[3];\n        oly_lensid[0] = fgetc(ifp);\n        fgetc(ifp);\n        oly_lensid[1] = fgetc(ifp);\n        oly_lensid[2] = fgetc(ifp);\n        imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n      }\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        char buffer[17];\n        int count = 0;\n        fread(buffer, 16, 1, ifp);\n        buffer[16] = 0;\n        for (int i = 0; i < 16; i++)\n        {\n          //    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n          if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))\n            count++;\n        }\n        if (count == 16)\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);\n          buffer[8] = 0;\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n        }\n        else\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],\n                  buffer[11]);\n        }\n      }\n      else if ((tag == 0x1001) && (type == 3))\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n        imgdata.lens.makernotes.LensID = -1;\n        imgdata.lens.makernotes.FocalType = 1;\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n    }\n\n    else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))\n    {\n      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n      {\n        char buffer[9];\n        buffer[8] = 0;\n        fread(buffer, 8, 1, ifp);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n\n      else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n      {\n        short ntags, cur_tag;\n        fseek(ifp, 20, SEEK_CUR);\n        ntags = get2();\n        cur_tag = get2();\n        while (cur_tag != 0x002c)\n        {\n          fseek(ifp, 10, SEEK_CUR);\n          cur_tag = get2();\n        }\n        fseek(ifp, 6, SEEK_CUR);\n        fseek(ifp, get4() + 20, SEEK_SET);\n        stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n        get2();\n        imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n        switch (imgdata.lens.makernotes.LensID)\n        {\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n        case 6:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n          break;\n        case 8:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n          imgdata.lens.makernotes.LensID = -1;\n          break;\n        default:\n          imgdata.lens.makernotes.LensID = -1;\n        }\n        fseek(ifp, 17, SEEK_CUR);\n        stread(imgdata.lens.LensSerial, 12, ifp);\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 2, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        unique_id = imgdata.lens.makernotes.CamID = get4();\n      }\n      else if (tag == 0xa002)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n                                 // a450, a500, a550, a560, a580\n                                 // a33, a35, a55\n                                 // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (table_buf[0] | table_buf[3])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n            if (table_buf[2] | table_buf[5])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n            parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n          }\n        }\n        free(table_buf);\n      }\n\n      else if ((tag == 0x0020) && // WBInfoA100, needs 0xb028 processing\n               !strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 0x49dc, SEEK_CUR);\n        stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 256000) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (table_buf[1] | table_buf[2])\n          imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n        if (table_buf[3] | table_buf[4])\n          imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n        if (table_buf[5])\n          imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n        if (table_buf[6])\n          imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n        parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        free(table_buf);\n      }\n    }\n\n    fseek(ifp, _pos, SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)\n      iso_speed = (get2(), get2());\n    if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))\n    {\n      unsigned char cc;\n      fread(&cc, 1, 1, ifp);\n      iso_speed = int(100.0 * powf64(2.0f, float(cc) / 12.0 - 5.0));\n    }\n    if (tag == 4 && len > 26 && len < 35)\n    {\n      if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n        iso_speed = 50 * powf64(2.0, i / 32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i = (get2(), get2())) != 0x7fff && !aperture)\n        aperture = powf64(2.0, i / 64.0);\n#endif\n      if ((i = get2()) != 0xffff && !shutter)\n        shutter = powf64(2.0, (short)i / -32.0);\n      wbi = (get2(), get2());\n      shot_order = (get2(), get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))\n    {\n      fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);\n      switch (get2())\n      {\n      case 72:\n        flip = 0;\n        break;\n      case 76:\n        flip = 6;\n        break;\n      case 82:\n        flip = 5;\n        break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets(model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make, \"Canon\", 5))\n      fread(artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa)\n    {\n#if 0 /* Canon rotation data is handled by EXIF.Orientation */\n      for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)\n        c = c << 8 | fgetc(ifp);\n      while ((i += 4) < len - 5)\n        if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)\n          flip = \"065\"[c] - '0';\n#endif\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n    if (!strncasecmp(make, \"Olympus\", 7))\n    {\n      short nWB, tWB;\n      if ((tag == 0x20300108) || (tag == 0x20310109))\n        imgdata.makernotes.olympus.ColorSpace = get2();\n\n      if ((tag == 0x20400102) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n      {\n        int i;\n        for (i = 0; i < 64; i++)\n          imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n              imgdata.color.WB_Coeffs[i][3] = 0x100;\n        for (i = 64; i < 256; i++)\n          imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n      }\n      if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n      {\n        ushort CT;\n        nWB = tag - 0x20400102;\n        switch (nWB)\n        {\n        case 0:\n          CT = 3000;\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 1:\n          CT = 3300;\n          tWB = 0x100;\n          break;\n        case 2:\n          CT = 3600;\n          tWB = 0x100;\n          break;\n        case 3:\n          CT = 3900;\n          tWB = 0x100;\n          break;\n        case 4:\n          CT = 4000;\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 5:\n          CT = 4300;\n          tWB = 0x100;\n          break;\n        case 6:\n          CT = 4500;\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 7:\n          CT = 4800;\n          tWB = 0x100;\n          break;\n        case 8:\n          CT = 5300;\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          CT = 6000;\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          CT = 6600;\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          CT = 7500;\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          CT = 0;\n          tWB = 0x100;\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n          imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n          if (len == 4)\n          {\n            imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n            imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n          }\n        }\n        if (tWB != 0x100)\n          FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c + 1];\n      }\n      if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400113;\n        imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n        switch (nWB)\n        {\n        case 0:\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 4:\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 6:\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 8:\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          tWB = 0x100;\n        }\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = imgdata.color.WBCT_Coeffs[nWB][2];\n      }\n\n      if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      if (tag == 0x2040011f)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n      }\n      if (tag == 0x30000120)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      if (tag == 0x30000121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      }\n      if (tag == 0x30000122)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n      }\n      if (tag == 0x30000123)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      }\n      if (tag == 0x30000124)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n      }\n      if (tag == 0x30000130)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      }\n      if (tag == 0x30000131)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      }\n      if (tag == 0x30000132)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      }\n      if (tag == 0x30000133)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      }\n\n      if ((tag == 0x20400805) && (len == 2))\n      {\n        imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);\n        imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n      }\n      if (tag == 0x20200401)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n    }\n    fseek(ifp, _pos2, SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n    }\n    if (tag == 0x14 && type == 7)\n    {\n      if (len == 2560)\n      {\n        fseek(ifp, 1248, SEEK_CUR);\n        goto get2_256;\n      }\n      fread(buf, 1, 10, ifp);\n      if (!strncmp(buf, \"NRW \", 4))\n      {\n        fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);\n        cam_mul[0] = get4() << 2;\n        cam_mul[1] = get4() + get4();\n        cam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread(model, 64, 1, ifp);\n    if (strstr(make, \"PENTAX\"))\n    {\n      if (tag == 0x1b)\n        tag = 0x1018;\n      if (tag == 0x1c)\n        tag = 0x1017;\n    }\n    if (tag == 0x1d)\n    {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n        serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1)\n    { // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;\n      fseek(ifp, 8 + c * 32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4)\n    {\n      data_offset = get4();\n      fseek(ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97)\n    {\n      for (i = 0; i < 4; i++)\n        ver97 = ver97 * 10 + fgetc(ifp) - '0';\n      switch (ver97)\n      {\n      case 100:\n        fseek(ifp, 68, SEEK_CUR);\n        FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n        break;\n      case 102:\n        fseek(ifp, 6, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = get2();\n        break;\n      case 103:\n        fseek(ifp, 16, SEEK_CUR);\n        FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200)\n      {\n        if (ver97 != 205)\n          fseek(ifp, 280, SEEK_CUR);\n        fread(buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7)\n    {\n      order = 0x4949;\n      fseek(ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3)\n    {\n      fseek(ifp, wbi * 48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7)\n    { // shutter count\n      NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n      if ((unsigned)(ver97 - 200) < 17)\n      {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601) // Coolpix A\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n#endif\n    }\n\n    if (tag == 0xb001 && type == 3) // Sony ModelID\n    {\n      unique_id = get2();\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(), get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)\n    {\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black += i;\n    }\n#endif\n    if (tag == 0xe01)\n    { /* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n      int loopc = 0;\n#endif\n      order = 0x4949;\n      fseek(ifp, 22, SEEK_CUR);\n      for (offset = 22; offset + 22 < len; offset += 22 + i)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (loopc++ > 1024)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        tag = get4();\n        fseek(ifp, 14, SEEK_CUR);\n        i = get4() - 4;\n        if (tag == 0x76a43207)\n          flip = get2();\n        else\n          fseek(ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7)\n    {\n      fseek(ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7)\n    {\n      if (len == 614)\n        fseek(ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n        fseek(ifp, 148, SEEK_CUR);\n      else\n        goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i = 0; i < 3; i++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!imgdata.makernotes.olympus.ColorSpace)\n        {\n          FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n        }\n        else\n        {\n          FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;\n        }\n#else\n        FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n#endif\n      }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2)\n    {\n    get2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek(ifp, get4() + base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    if (tag == 0x2010)\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, 0x2010);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n\n    if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) && ((type == 7) || (type == 13)) &&\n        !strncasecmp(make, \"Olympus\", 7))\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, tag);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))\n      parse_thumb_note(base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote(base, 0x2040);\n    if (tag == 0xb028)\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_thumb_note(base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000)\n    {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek(ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i += 18; i <= len; i += 10)\n      {\n        get2();\n        FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n        if (sraw_mul[1] == 1170)\n          break;\n      }\n    }\n    if (!strncasecmp(make, \"Samsung\", 7))\n    {\n      if (tag == 0xa020) // get the full Samsung encryption key\n        for (i = 0; i < 11; i++)\n          SamsungKey[i] = get4();\n      if (tag == 0xa021) // get and decode Samsung cam_mul array\n        FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tag == 0xa023)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n        }\n      }\n      if (tag == 0xa024)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n        }\n      }\n      if (tag == 0xa025)\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = get4() - SamsungKey[0];\n      if (tag == 0xa030 && len == 9)\n        for (i = 0; i < 3; i++)\n          FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n#endif\n      if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix\n        for (i = 0; i < 3; i++)\n          FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n\n      if (tag == 0xa028)\n        FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n    }\n    else\n    {\n      // Somebody else use 0xa021 and 0xa028?\n      if (tag == 0xa021)\n        FORC4 cam_mul[c ^ (c >> 1)] = get4();\n      if (tag == 0xa028)\n        FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n    }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp(int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i = 19; i--;)\n      str[i] = fgetc(ifp);\n  else\n    fread(str, 19, 1, ifp);\n  memset(&t, 0, sizeof t);\n  if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif(int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo, ape;\n\n  kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n  entries = get2();\n  if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > fsize * 2)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n    switch (tag)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n    case 33434:\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n      break;\n    case 33437:\n      aperture = getreal(type);\n      break; // 0x829d FNumber\n    case 34855:\n      iso_speed = get2();\n      break;\n    case 34866:\n      if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n        iso_speed = getreal(type);\n      break;\n    case 36867:\n    case 36868:\n      get_timestamp(0);\n      break;\n    case 37377:\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter = powf64(2.0, expo);\n      break;\n    case 37378: // 0x9202 ApertureValue\n      if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n        aperture = powf64(2.0, ape / 2);\n      break;\n    case 37385:\n      flash_used = getreal(type);\n      break;\n    case 37386:\n      focal_len = getreal(type);\n      break;\n    case 37500: // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))\n      {\n        char mn_text[512];\n        char *pos;\n        char ccms[512];\n        ushort l;\n        float num;\n\n        fgets(mn_text, len, ifp);\n        pos = strstr(mn_text, \"gain_r=\");\n        if (pos)\n          cam_mul[0] = atof(pos + 7);\n        pos = strstr(mn_text, \"gain_b=\");\n        if (pos)\n          cam_mul[2] = atof(pos + 7);\n        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n          cam_mul[1] = cam_mul[3] = 1.0f;\n        else\n          cam_mul[0] = cam_mul[2] = 0.0f;\n\n        pos = strstr(mn_text, \"ccm=\") + 4;\n        l = strstr(pos, \" \") - pos;\n        memcpy(ccms, pos, l);\n        ccms[l] = '\\0';\n\n        pos = strtok(ccms, \",\");\n        for (l = 0; l < 4; l++)\n        {\n          num = 0.0;\n          for (c = 0; c < 3; c++)\n          {\n            imgdata.color.ccm[l][c] = (float)atoi(pos);\n            num += imgdata.color.ccm[l][c];\n            pos = strtok(NULL, \",\");\n          }\n          if (num > 0.01)\n            FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n        }\n      }\n      else\n#endif\n        parse_makernote(base, 0);\n      break;\n    case 40962:\n      if (kodak)\n        raw_width = get4();\n      break;\n    case 40963:\n      if (kodak)\n        raw_height = get4();\n      break;\n    case 41730:\n      if (get4() == 0x20002)\n        for (exif_cfa = c = 0; c < 8; c += 2)\n          exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n    return;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n      imgdata.other.parsed_gps.latref = getc(ifp);\n      break;\n    case 3:\n      imgdata.other.parsed_gps.longref = getc(ifp);\n      break;\n    case 5:\n      imgdata.other.parsed_gps.altref = getc(ifp);\n      break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9:\n      imgdata.other.parsed_gps.gpsstatus = getc(ifp);\n      break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n    case 3:\n    case 5:\n      gpsdata[29 + tag / 2] = getc(ifp);\n      break;\n    case 2:\n    case 4:\n    case 7:\n      FORC(6) gpsdata[tag / 3 * 6 + c] = get4();\n      break;\n    case 6:\n      FORC(2) gpsdata[18 + c] = get4();\n      break;\n    case 18:\n    case 29:\n      fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff(float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] = /* ROMM == Kodak ProPhoto */\n      {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      for (cmatrix[i][j] = k = 0; k < 3; k++)\n        cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos(int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes = 0, frot = 0;\n  static const char *mod[] = {\"\",\n                              \"DCB2\",\n                              \"Volare\",\n                              \"Cantare\",\n                              \"CMost\",\n                              \"Valeo 6\",\n                              \"Valeo 11\",\n                              \"Valeo 22\",\n                              \"Valeo 11p\",\n                              \"Valeo 17\",\n                              \"\",\n                              \"Aptus 17\",\n                              \"Aptus 22\",\n                              \"Aptus 75\",\n                              \"Aptus 65\",\n                              \"Aptus 54S\",\n                              \"Aptus 65S\",\n                              \"Aptus 75S\",\n                              \"AFi 5\",\n                              \"AFi 6\",\n                              \"AFi 7\",\n                              \"AFi-II 7\",\n                              \"Aptus-II 7\",\n                              \"\",\n                              \"Aptus-II 6\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10\",\n                              \"Aptus-II 5\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10R\",\n                              \"Aptus-II 8\",\n                              \"\",\n                              \"Aptus-II 12\",\n                              \"\",\n                              \"AFi-II 12\"};\n  float romm_cam[3][3];\n\n  fseek(ifp, offset, SEEK_SET);\n  while (1)\n  {\n    if (get4() != 0x504b5453)\n      break;\n    get4();\n    fread(data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data, \"CameraObj_camera_type\"))\n    {\n      stmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data, \"back_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.BodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));\n      strcpy(imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data, \"CaptProf_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n      strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n    // IB end\n    if (!strcmp(data, \"JPEG_preview_data\"))\n    {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data, \"icc_camera_profile\"))\n    {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data, \"ShootObj_back_type\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      if ((unsigned)i < sizeof mod / sizeof(*mod))\n        strcpy(model, mod[i]);\n    }\n    if (!strcmp(data, \"icc_camera_to_tone_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        ((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_color_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        fscanf(ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_number_of_planes\"))\n      fscanf(ifp, \"%d\", &planes);\n    if (!strcmp(data, \"CaptProf_raw_data_rotation\"))\n      fscanf(ifp, \"%d\", &flip);\n    if (!strcmp(data, \"CaptProf_mosaic_pattern\"))\n      FORC4\n      {\n        fscanf(ifp, \"%d\", &i);\n        if (i == 1)\n          frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data, \"ImgProf_rotation_angle\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])\n    {\n      FORC4 fscanf(ifp, \"%d\", neut + c);\n      FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];\n    }\n    if (!strcmp(data, \"Rows_data\"))\n      load_flags = get4();\n    parse_mos(from);\n    fseek(ifp, skip + from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];\n}\n\nvoid CLASS linear_table(unsigned len)\n{\n  int i;\n  if (len > 0x10000)\n    len = 0x10000;\n  read_shorts(curve, len);\n  for (i = len; i < 0x10000; i++)\n    curve[i] = curve[i - 1];\n  maximum = curve[len < 0x1000 ? 0xfff : len - 1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags(int wb, unsigned type)\n{\n  float mul[3] = {1, 1, 1}, num, mul2;\n  int c;\n  FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n  mul2 = mul[1] * mul[1];\n  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n  return;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n  //  int a_blck = 0;\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  INT64 fsize = ifp->size();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > 2 * fsize)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n    if (tag == 1011)\n      imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());\n      wbi = -2;\n    }\n\n    if ((tag == 0x03ef) && (!strcmp(model, \"EOS D2000C\")))\n      black = get2();\n    if ((tag == 0x03f0) && (!strcmp(model, \"EOS D2000C\")))\n    {\n      if (black) // already set by tag 0x03ef\n        black = (black + get2()) / 2;\n      else\n        black = get2();\n    }\n    if (tag == 0x0848)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93)\n      imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n          imgdata.color.linear_max[3] = get2();\n    if (tag == 0x09ce)\n      stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n    if (tag == 0xfa00)\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n    if (tag == 0xfa27)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n    }\n    if (tag == 0xfa28)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n    }\n    if (tag == 0xfa29)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n    }\n    if (tag == 0xfa2a)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n    }\n\n    if (tag == 2120 + wbi || (wbi < 0 && tag == 2125)) /* use Auto WB if illuminant index is not set */\n    {\n      FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n      FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n    }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 0x903)\n      iso_speed = getreal(type);\n    // if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2, wbtemp = 6500;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());\n      wbi = -2;\n    }\n    if (tag == 2118)\n      wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3\n      {\n        for (num = i = 0; i < 4; i++)\n          num += getreal(type) * pow(wbtemp / 100.0, i);\n        cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));\n      }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 6020)\n      iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n//@end COMMON\n\nvoid CLASS parse_minolta(int base);\nint CLASS parse_tiff(int base);\n\n//@out COMMON\nint CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff(int base)\n{\n  int doff;\n  fseek(ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d)\n    return 0;\n  get2();\n  while ((doff = get4()))\n  {\n    fseek(ifp, doff + base, SEEK_SET);\n    if (parse_tiff_ifd(base))\n      break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp = 0, ties = 0, raw = -1, thm = -1, i;\n  unsigned long long ns, os;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n      {\n        thumb_misc = jh.bits;\n        thumb_width = jh.wide;\n        thumb_height = jh.high;\n      }\n    }\n  }\n  for (i = tiff_nifds; i--;)\n  {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i = 0; i < tiff_nifds; i++)\n  {\n    if (max_samp < tiff_ifd[i].samples)\n      max_samp = tiff_ifd[i].samples;\n    if (max_samp > 3)\n      max_samp = 3;\n    os = raw_width * raw_height;\n    ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;\n    if (tiff_bps)\n    {\n      os *= tiff_bps;\n      ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&\n        (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))\n    {\n      raw_width = tiff_ifd[i].t_width;\n      raw_height = tiff_ifd[i].t_height;\n      tiff_bps = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size = tiff_ifd[i].bytes;\n#endif\n      tiff_flip = tiff_ifd[i].t_flip;\n      tiff_samples = tiff_ifd[i].samples;\n      tile_width = tiff_ifd[i].t_tile_width;\n      tile_length = tiff_ifd[i].t_tile_length;\n      shutter = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties)\n    is_raw = ties;\n  if (!tile_width)\n    tile_width = INT_MAX;\n  if (!tile_length)\n    tile_length = INT_MAX;\n  for (i = tiff_nifds; i--;)\n    if (tiff_ifd[i].t_flip)\n      tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress)\n    {\n    case 32767:\n      if (tiff_ifd[raw].bytes == raw_width * raw_height)\n      {\n        tiff_bps = 12;\n        load_raw = &CLASS sony_arw2_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)\n      {\n        raw_height += 8;\n        load_raw = &CLASS sony_arw_load_raw;\n        break;\n      }\n      load_flags = 79;\n    case 32769:\n      load_flags++;\n    case 32770:\n    case 32773:\n      goto slr;\n    case 0:\n    case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n      // Sony 14-bit uncompressed\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))\n      {\n        load_raw = &CLASS nikon_coolscan_load_raw;\n        raw_color = 1;\n        filters = 0;\n        break;\n      }\n#endif\n      if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)\n        load_flags = 24;\n      if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)\n      {\n        load_flags = 81;\n        tiff_bps = 12;\n      }\n    slr:\n      switch (tiff_bps)\n      {\n      case 8:\n        load_raw = &CLASS eight_bit_load_raw;\n        break;\n      case 12:\n        if (tiff_ifd[raw].phint == 2)\n          load_flags = 6;\n        load_raw = &CLASS packed_load_raw;\n        break;\n      case 14:\n        load_flags = 0;\n      case 16:\n        load_raw = &CLASS unpacked_load_raw;\n        if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)\n          load_raw = &CLASS olympus_load_raw;\n      }\n      break;\n    case 6:\n    case 7:\n    case 99:\n      load_raw = &CLASS lossless_jpeg_load_raw;\n      break;\n    case 262:\n      load_raw = &CLASS kodak_262_load_raw;\n      break;\n    case 34713:\n      if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 1;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        if (model[0] == 'N')\n          load_flags = 80;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS nikon_yuv_load_raw;\n        gamma_curve(1 / 2.4, 12.92, 1, 4095);\n        memset(cblack, 0, sizeof cblack);\n        filters = 0;\n      }\n      else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS unpacked_load_raw;\n        load_flags = 4;\n        order = 0x4d4d;\n      }\n      else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 80;\n      }\n      else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n               tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n      {\n        int fit = 1;\n        for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last\n          if (tiff_ifd[raw].strip_byte_counts[i] * 2 != tiff_ifd[raw].rows_per_strip * raw_width * 3)\n          {\n            fit = 0;\n            break;\n          }\n        if (fit)\n          load_raw = &CLASS nikon_load_striped_packed_raw;\n        else\n          load_raw = &CLASS nikon_load_raw; // fallback\n      }\n      else\n#endif\n        load_raw = &CLASS nikon_load_raw;\n      break;\n    case 65535:\n      load_raw = &CLASS pentax_load_raw;\n      break;\n    case 65000:\n      switch (tiff_ifd[raw].phint)\n      {\n      case 2:\n        load_raw = &CLASS kodak_rgb_load_raw;\n        filters = 0;\n        break;\n      case 6:\n        load_raw = &CLASS kodak_ycbcr_load_raw;\n        filters = 0;\n        break;\n      case 32803:\n        load_raw = &CLASS kodak_65000_load_raw;\n      }\n    case 32867:\n    case 34892:\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      break;\n#endif\n    default:\n      is_raw = 0;\n    }\n  if (!dng_version)\n    if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||\n         (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && !strcasestr(make, \"Kodak\") && !strstr(model2, \"DEBUG RAW\"))) &&\n        strncmp(software, \"Nikon Scan\", 10))\n      is_raw = 0;\n  for (i = 0; i < tiff_nifds; i++)\n    if (i != raw &&\n        (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >\n            thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&\n        tiff_ifd[i].comp != 34892)\n    {\n      thumb_width = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0)\n  {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp)\n    {\n    case 0:\n      write_thumb = &CLASS layer_thumb;\n      break;\n    case 1:\n      if (tiff_ifd[thm].bps <= 8)\n        write_thumb = &CLASS ppm_thumb;\n      else if (!strncmp(make, \"Imacon\", 6))\n        write_thumb = &CLASS ppm16_thumb;\n      else\n        thumb_load_raw = &CLASS kodak_thumb_load_raw;\n      break;\n    case 65000:\n      thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save = ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if (ifp->wfname())\n  {\n    std::wstring rawfile(ifp->wfname());\n    rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");\n    if (!ifp->subfile_open(rawfile.c_str()))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n  if (!ifp->fname())\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n\n  ext = strrchr(ifname, '.');\n  file = strrchr(ifname, '/');\n  if (!file)\n    file = strrchr(ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file)\n    file = ifname - 1;\n#else\n  if (!file)\n    file = (char *)ifname - 1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext - file != 8)\n    return;\n  jname = (char *)malloc(strlen(ifname) + 1);\n  merror(jname, \"parse_external_jpeg()\");\n  strcpy(jname, ifname);\n  jfile = file - ifname + jname;\n  jext = ext - ifname + jname;\n  if (strcasecmp(ext, \".jpg\"))\n  {\n    strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");\n    if (isdigit(*file))\n    {\n      memcpy(jfile, file + 4, 4);\n      memcpy(jfile + 4, file, 4);\n    }\n  }\n  else\n    while (isdigit(*--jext))\n    {\n      if (*jext != '9')\n      {\n        (*jext)++;\n        break;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp(jname, ifname))\n  {\n    if ((ifp = fopen(jname, \"rb\")))\n    {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose(ifp);\n    }\n  }\n#else\n  if (strcmp(jname, ifname))\n  {\n    if (!ifp->subfile_open(jname))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n  }\n#endif\n  if (!timestamp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n  }\n  free(jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = {0x410, 0x45f3};\n  int i, bpp, row, col, vbits = 0;\n  unsigned long bitbuf = 0;\n\n  if ((get2(), get4()) != 0x80008 || !get4())\n    return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12)\n    return;\n  for (i = row = 0; row < 8; row++)\n    for (col = 0; col < 8; col++)\n    {\n      if (vbits < bpp)\n      {\n        bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n        vbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff(int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi = -1;\n  ushort key[] = {0x410, 0x45f3};\n\n  fseek(ifp, offset + length - 4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek(ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127)\n    return;\n  while (nrecs--)\n  {\n    type = get2();\n    len = get4();\n    save = ftell(ifp) + 4;\n    fseek(ifp, offset + get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n    {\n      parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004)\n      parse_ciff(ftell(ifp), len, depth + 1);\n#endif\n    if (type == 0x0810)\n      fread(artist, 64, 1, ifp);\n    if (type == 0x080a)\n    {\n      fread(make, 64, 1, ifp);\n      fseek(ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread(model, 64, 1, ifp);\n    }\n    if (type == 0x1810)\n    {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835) /* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007)\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818)\n    {\n      shutter = powf64(2.0f, -int_to_float((get4(), get4())));\n      aperture = powf64(2.0f, int_to_float(get4()) / 2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a)\n    {\n      //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture = _CanonConvertAperture((get2(), get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture = powf64(2.0, (get2(), (short)get2()) / 64.0);\n#endif\n      shutter = powf64(2.0, -((short)get2()) / 32.0);\n      wbi = (get2(), get2());\n      if (wbi > 17)\n        wbi = 0;\n      fseek(ifp, 32, SEEK_CUR);\n      if (shutter > 1e6)\n        shutter = get2() / 10.0;\n    }\n    if (type == 0x102c)\n    {\n      if (get2() > 512)\n      { /* Pro90, G1 */\n        fseek(ifp, 118, SEEK_CUR);\n        FORC4 cam_mul[c ^ 2] = get2();\n      }\n      else\n      { /* G2, S30, S40 */\n        fseek(ifp, 98, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n    {\n      INT64 o = ftell(ifp);\n      fseek(ifp, (0x5 << 1), SEEK_CUR);\n      Canon_WBpresets(0, 0);\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x102d)\n    {\n      INT64 o = ftell(ifp);\n      Canon_CameraSettings();\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x580b)\n    {\n      if (strcmp(model, \"Canon EOS D30\"))\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n      else\n        sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);\n    }\n#endif\n    if (type == 0x0032)\n    {\n      if (len == 768)\n      { /* EOS D30 */\n        fseek(ifp, 72, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n        if (!wbi)\n          cam_mul[0] = -1; /* use my auto white balance */\n      }\n      else if (!cam_mul[0])\n      {\n        if (get2() == key[0]) /* Pro1, G6, S60, S70 */\n          c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;\n        else\n        { /* G3, G5, S45, S50 */\n          c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';\n          key[0] = key[1] = 0;\n        }\n        fseek(ifp, 78 + c * 8, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n        if (!wbi)\n          cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9)\n    { /* D60, 10D, 300D, and clones */\n      if (len > 66)\n        wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';\n      fseek(ifp, 2 + wbi * 8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))\n      ciff_block_1030(); /* all that don't have 0x10a9 */\n    if (type == 0x1031)\n    {\n      raw_width = (get2(), get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c)\n    {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2)\n      {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n        if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n          imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2)\n        focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813)\n      flash_used = int_to_float(len);\n    if (type == 0x5814)\n      canon_ev = int_to_float(len);\n    if (type == 0x5817)\n      shot_order = len;\n    if (type == 0x5834)\n    {\n      unique_id = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n      setCanonBodyFeatures(unique_id);\n#endif\n    }\n    if (type == 0x580e)\n      timestamp = len;\n    if (type == 0x180e)\n      timestamp = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime(gmtime(&timestamp));\n#endif\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek(ifp, 0, SEEK_SET);\n  memset(&t, 0, sizeof t);\n  do\n  {\n    fgets(line, 128, ifp);\n    if ((val = strchr(line, '=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line, \"DAT\"))\n      sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line, \"TIM\"))\n      sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line, \"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line, \"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line, \"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line, \"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line, \"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line, \"EOHD\", 4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy(make, \"Rollei\");\n  strcpy(model, \"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek(ifp, get4(), SEEK_SET);\n  while (entries--)\n  {\n    off = get4();\n    get4();\n    fread(str, 8, 1, ifp);\n    if (!strcmp(str, \"META\"))\n      meta_offset = off;\n    if (!strcmp(str, \"THUMB\"))\n      thumb_offset = off;\n    if (!strcmp(str, \"RAW0\"))\n      data_offset = off;\n  }\n  fseek(ifp, meta_offset + 20, SEEK_SET);\n  fread(make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make, ' ')))\n  {\n    strcpy(model, cp + 1);\n    *cp = 0;\n  }\n  raw_width = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(), get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one(int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset(&ph1, 0, sizeof ph1);\n  fseek(ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177)\n    return; /* \"Raw\" */\n  fseek(ifp, get4() + base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--)\n  {\n    tag = get4();\n    type = get4();\n    len = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek(ifp, base + data, SEEK_SET);\n    switch (tag)\n    {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      }\n      else\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4)\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (int_to_float(data) / 2.0f));\n      else\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x0403:\n      if (type == 4)\n        imgdata.lens.makernotes.CurFocal = int_to_float(data);\n      else\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n      {\n        imgdata.lens.makernotes.MinFocal = 0.0f;\n      }\n      break;\n    case 0x0417:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n    case 0x100:\n      flip = \"0653\"[data & 3] - '0';\n      break;\n    case 0x106:\n      for (i = 0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.P1_color[0].romm_cam[i] =\n#endif\n            ((float *)romm_cam)[i] = getreal(11);\n      romm_coeff(romm_cam);\n      break;\n    case 0x107:\n      FORC3 cam_mul[c] = getreal(11);\n      break;\n    case 0x108:\n      raw_width = data;\n      break;\n    case 0x109:\n      raw_height = data;\n      break;\n    case 0x10a:\n      left_margin = data;\n      break;\n    case 0x10b:\n      top_margin = data;\n      break;\n    case 0x10c:\n      width = data;\n      break;\n    case 0x10d:\n      height = data;\n      break;\n    case 0x10e:\n      ph1.format = data;\n      break;\n    case 0x10f:\n      data_offset = data + base;\n      break;\n    case 0x110:\n      meta_offset = data + base;\n      meta_length = len;\n      break;\n    case 0x112:\n      ph1.key_off = save - 4;\n      break;\n    case 0x210:\n      ph1.tag_210 = int_to_float(data);\n      break;\n    case 0x21a:\n      ph1.tag_21a = data;\n      break;\n    case 0x21c:\n      strip_offset = data + base;\n      break;\n    case 0x21d:\n      ph1.t_black = data;\n      break;\n    case 0x222:\n      ph1.split_col = data;\n      break;\n    case 0x223:\n      ph1.black_col = data + base;\n      break;\n    case 0x224:\n      ph1.split_row = data;\n      break;\n    case 0x225:\n      ph1.black_row = data + base;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x226:\n      for (i = 0; i < 9; i++)\n        imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n      break;\n#endif\n    case 0x301:\n      model[63] = 0;\n      fread(model, 1, 63, ifp);\n      if ((cp = strstr(model, \" camera\")))\n        *cp = 0;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek(ifp, 6, SEEK_CUR);\n    fseek(ifp, meta_offset + get4(), SEEK_SET);\n    entries = get4();\n    get4();\n    while (entries--)\n    {\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x0407)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        }\n        else\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy(make, \"Phase One\");\n  if (model[0])\n    return;\n  switch (raw_height)\n  {\n  case 2060:\n    strcpy(model, \"LightPhase\");\n    break;\n  case 2682:\n    strcpy(model, \"H 10\");\n    break;\n  case 4128:\n    strcpy(model, \"H 20\");\n    break;\n  case 5488:\n    strcpy(model, \"H 25\");\n    break;\n  }\n}\n\nvoid CLASS parse_fuji(int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek(ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255)\n    return;\n  while (entries--)\n  {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100)\n    {\n      raw_height = get2();\n      raw_width = get2();\n    }\n    else if (tag == 0x121)\n    {\n      height = get2();\n      if ((width = get2()) == 4284)\n        width += 3;\n    }\n    else if (tag == 0x130)\n    {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    }\n    else if (tag == 0x131)\n    {\n      filters = 9;\n      FORC(36) xtrans_abs[0][35 - c] = fgetc(ifp) & 3;\n    }\n    else if (tag == 0x2ff0)\n    {\n      FORC4 cam_mul[c ^ 1] = get2();\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b = fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    }\n    else if (tag == 0x2100)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    }\n    else if (tag == 0x2200)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    }\n    else if (tag == 0x2300)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    }\n    else if (tag == 0x2301)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    }\n    else if (tag == 0x2302)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    }\n    else if (tag == 0x2310)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    }\n    else if (tag == 0x2400)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n#endif\n      // IB end\n    }\n    else if (tag == 0xc000)\n    {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000)\n        tag = get4();\n      if (tag > 10000)\n        tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);\n#endif\n      order = c;\n    }\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width >>= fuji_layout;\n}\n\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  struct tm t;\n\n  order = 0x4949;\n  fread(tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))\n  {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  }\n  else if (!memcmp(tag, \"nctg\", 4))\n  {\n    while (ftell(ifp) + 7 < end)\n    {\n      i = get2();\n      size = get2();\n      if ((i + 1) >> 1 == 10 && size == 20)\n        get_timestamp(0);\n      else\n        fseek(ifp, size, SEEK_CUR);\n    }\n  }\n  else if (!memcmp(tag, \"IDIT\", 4) && size < 64)\n  {\n    fread(date, 64, 1, ifp);\n    date[size] = 0;\n    memset(&t, 0, sizeof t);\n    if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)\n    {\n      for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)\n        ;\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n        timestamp = mktime(&t);\n    }\n  }\n  else\n    fseek(ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"SMaL\");\n  sprintf(model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek(ifp, 52, SEEK_SET);\n  width = get4();\n  height = get4();\n  fseek(ifp, 0, SEEK_END);\n  fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek(ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF)\n    {\n      if (get4() == 0x52454456)\n        if (is_raw++ == shot_select)\n          data_offset = ftello(ifp) - 8;\n      fseek(ifp, len - 8, SEEK_CUR);\n    }\n  }\n  else\n  {\n    rdvo = get4();\n    fseek(ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n//@end COMMON\n\nchar *CLASS foveon_gets(int offset, char *str, int len)\n{\n  int i;\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < len - 1; i++)\n    if ((str[i] = get2()) == 0)\n      break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img = 0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n  order = 0x4949; /* Little-endian */\n  fseek(ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek(ifp, -4, SEEK_END);\n  fseek(ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553)\n    return; /* SECd */\n  entries = (get4(), get4());\n  while (entries--)\n  {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek(ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24)))\n      return;\n    switch (tag)\n    {\n    case 0x47414d49: /* IMAG */\n    case 0x32414d49: /* IMA2 */\n      fseek(ifp, 8, SEEK_CUR);\n      pent = get4();\n      wide = get4();\n      high = get4();\n      if (wide > raw_width && high > raw_height)\n      {\n        switch (pent)\n        {\n        case 5:\n          load_flags = 1;\n        case 6:\n          load_raw = &CLASS foveon_sd_load_raw;\n          break;\n        case 30:\n          load_raw = &CLASS foveon_dp_load_raw;\n          break;\n        default:\n          load_raw = 0;\n        }\n        raw_width = wide;\n        raw_height = high;\n        data_offset = off + 28;\n        is_foveon = 1;\n      }\n      fseek(ifp, off + 28, SEEK_SET);\n      if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8 && thumb_length < len - 28)\n      {\n        thumb_offset = off + 28;\n        thumb_length = len - 28;\n        write_thumb = &CLASS jpeg_thumb;\n      }\n      if (++img == 2 && !thumb_length)\n      {\n        thumb_offset = off + 24;\n        thumb_width = wide;\n        thumb_height = high;\n        write_thumb = &CLASS foveon_thumb;\n      }\n      break;\n    case 0x464d4143: /* CAMF */\n      meta_offset = off + 8;\n      meta_length = len - 28;\n      break;\n    case 0x504f5250: /* PROP */\n      pent = (get4(), get4());\n      fseek(ifp, 12, SEEK_CUR);\n      off += pent * 8 + 24;\n      if ((unsigned)pent > 256)\n        pent = 256;\n      for (i = 0; i < pent * 2; i++)\n        ((int *)poff)[i] = off + get4() * 2;\n      for (i = 0; i < pent; i++)\n      {\n        foveon_gets(poff[i][0], name, 64);\n        foveon_gets(poff[i][1], value, 64);\n        if (!strcmp(name, \"ISO\"))\n          iso_speed = atoi(value);\n        if (!strcmp(name, \"CAMMANUF\"))\n          strcpy(make, value);\n        if (!strcmp(name, \"CAMMODEL\"))\n          strcpy(model, value);\n        if (!strcmp(name, \"WB_DESC\"))\n          strcpy(model2, value);\n        if (!strcmp(name, \"TIME\"))\n          timestamp = atoi(value);\n        if (!strcmp(name, \"EXPTIME\"))\n          shutter = atoi(value) / 1000000.0;\n        if (!strcmp(name, \"APERTURE\"))\n          aperture = atof(value);\n        if (!strcmp(name, \"FLENGTH\"))\n          focal_len = atof(value);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strcmp(name, \"CAMSERIAL\"))\n          strcpy(imgdata.shootinginfo.BodySerial, value);\n        if (!strcmp(name, \"FLEQ35MM\"))\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n        if (!strcmp(name, \"LENSARANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n            if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSFRANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MaxFocal = atof(sp);\n            if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSMODEL\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.LensID = strtol(value, &sp, 16); // atoi(value);\n          if (imgdata.lens.makernotes.LensID)\n            imgdata.lens.makernotes.LensMount = Sigma_X3F;\n        }\n      }\n#endif\n    }\n#ifdef LOCALTIME\n    timestamp = mktime(gmtime(&timestamp));\n#endif\n  }\n  fseek(ifp, save, SEEK_SET);\n}\n}\n\n//@out COMMON\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff(const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n                       ,\n                       int internal_only\n#endif\n                       )\n{\n  // clang-format off\n  static const struct\n  {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X Mark II\", 0, 0, /* temp */\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100F\", 0, 0,\n      {11434,-4948,-1210,-3746,12042,1903,-666,1479,5235}},\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T20\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526}},\n    { \"Fujifilm GFX 50S\", 0, 0,\n      {11940,-4431,-1255,-6766,14428,2542,-994,1165,7421}},\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D5600\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax KP\", 0, 0,  /* temp */\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n\n    { \"Panasonic DC-FZ82\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-FZ80\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0, /* 40,42,45 */\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n\n    { \"Panasonic DC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  // clang-format on\n\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if (colors > 4 || colors < 1)\n    return;\n\n  int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;\n  if (cblack[4] * cblack[5] > 0)\n  {\n    for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n      bl64 += cblack[c + 6];\n    bl64 /= cblack[4] * cblack[5];\n  }\n  int rblack = black + bl4 + bl64;\n\n  sprintf(name, \"%s %s\", t_make, t_model);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))\n    {\n      if (!dng_version)\n      {\n        if (table[i].t_black > 0)\n        {\n          black = (ushort)table[i].t_black;\n          memset(cblack, 0, sizeof(cblack));\n        }\n        else if (table[i].t_black < 0 && rblack == 0)\n        {\n          black = (ushort)(-table[i].t_black);\n          memset(cblack, 0, sizeof(cblack));\n        }\n        if (table[i].t_maximum)\n          maximum = (ushort)table[i].t_maximum;\n      }\n      if (table[i].trans[0])\n      {\n        for (raw_color = j = 0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (internal_only)\n            imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n          else\n            imgdata.color.cam_xyz[0][j] =\n#endif\n                ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!internal_only)\n#endif\n          cam_xyz_coeff(rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff(int index)\n{\n  static const float table[][12] = {/* index 0 -- all Foveon cameras */\n                                    {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},\n                                    /* index 1 -- Kodak DC20 and DC25 */\n                                    {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},\n                                    /* index 2 -- Logitech Fotoman Pixtura */\n                                    {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},\n                                    /* index 3 -- Nikon E880, E900, and E990 */\n                                    {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,\n                                     -1.204965, 1.082304, 2.941367, -1.818705}};\n  int i, c;\n\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i * colors + c];\n}\n\nshort CLASS guess_byte_order(int words)\n{\n  uchar test[4][2];\n  int t = 2, msb;\n  double diff, sum[2] = {0, 0};\n\n  fread(test[0], 2, 2, ifp);\n  for (words -= 2; words--;)\n  {\n    fread(test[t], 2, 1, ifp);\n    for (msb = 0; msb < 2; msb++)\n    {\n      diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);\n      sum[msb] += diff * diff;\n    }\n    t = (t + 1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n\n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  return 100 * log(sum[0] / sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if (len < 1)\n    return; // not needed, b/c sizeof of make/model is 64\n  string[len - 1] = 0;\n  if (len < 3)\n    return; // also not needed\n  len = strnlen(string, len - 1);\n  for (int i = len - 1; i >= 0; i--)\n  {\n    if (isspace(string[i]))\n      string[i] = 0;\n    else\n      break;\n  }\n}\n\nvoid CLASS initdata()\n{\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n  for (int i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n}\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n      {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},\n      {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},\n      {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},\n      {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},\n      {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},\n      {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},\n      {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},\n      {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},\n  };\n  static const ushort canon[][11] = {\n      {1944, 1416, 0, 0, 48, 0},\n      {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},\n      {2224, 1456, 48, 6, 0, 2},\n      {2376, 1728, 12, 6, 52, 2},\n      {2672, 1968, 12, 6, 44, 2},\n      {3152, 2068, 64, 12, 0, 0, 16},\n      {3160, 2344, 44, 12, 4, 4},\n      {3344, 2484, 4, 6, 52, 6},\n      {3516, 2328, 42, 14, 0, 0},\n      {3596, 2360, 74, 12, 0, 0},\n      {3744, 2784, 52, 12, 8, 12},\n      {3944, 2622, 30, 18, 6, 2},\n      {3948, 2622, 42, 18, 0, 2},\n      {3984, 2622, 76, 20, 0, 2, 14},\n      {4104, 3048, 48, 12, 24, 12},\n      {4116, 2178, 4, 2, 0, 0},\n      {4152, 2772, 192, 12, 0, 0},\n      {4160, 3124, 104, 11, 8, 65},\n      {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},\n      {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},\n      {4312, 2876, 22, 18, 0, 2},\n      {4352, 2874, 62, 18, 0, 0},\n      {4476, 2954, 90, 34, 0, 0},\n      {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},\n      {4480, 3366, 80, 50, 0, 0},\n      {4496, 3366, 80, 50, 12, 0},\n      {4768, 3516, 96, 16, 0, 0, 0, 16},\n      {4832, 3204, 62, 26, 0, 0},\n      {4832, 3228, 62, 51, 0, 0},\n      {5108, 3349, 98, 13, 0, 0},\n      {5120, 3318, 142, 45, 62, 0},\n      {5280, 3528, 72, 52, 0, 0}, /* EOS M */\n      {5344, 3516, 142, 51, 0, 0},\n      {5344, 3584, 126, 100, 0, 2},\n      {5360, 3516, 158, 51, 0, 0},\n      {5568, 3708, 72, 38, 0, 0},\n      {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},\n      {5712, 3774, 62, 20, 10, 2},\n      {5792, 3804, 158, 51, 0, 0},\n      {5920, 3950, 122, 80, 2, 0},\n      {6096, 4056, 72, 34, 0, 0},  /* EOS M3 */\n      {6288, 4056, 266, 36, 0, 0}, /* EOS 80D */\n      {6880, 4544, 136, 42, 0, 0}, /* EOS 5D4 */\n      {8896, 5920, 160, 64, 0, 0},\n  };\n  static const struct\n  {\n    ushort id;\n    char t_model[20];\n  } unique[] =\n      {\n          {0x001, \"EOS-1D\"},\n          {0x167, \"EOS-1DS\"},\n          {0x168, \"EOS 10D\"},\n          {0x169, \"EOS-1D Mark III\"},\n          {0x170, \"EOS 300D\"},\n          {0x174, \"EOS-1D Mark II\"},\n          {0x175, \"EOS 20D\"},\n          {0x176, \"EOS 450D\"},\n          {0x188, \"EOS-1Ds Mark II\"},\n          {0x189, \"EOS 350D\"},\n          {0x190, \"EOS 40D\"},\n          {0x213, \"EOS 5D\"},\n          {0x215, \"EOS-1Ds Mark III\"},\n          {0x218, \"EOS 5D Mark II\"},\n          {0x232, \"EOS-1D Mark II N\"},\n          {0x234, \"EOS 30D\"},\n          {0x236, \"EOS 400D\"},\n          {0x250, \"EOS 7D\"},\n          {0x252, \"EOS 500D\"},\n          {0x254, \"EOS 1000D\"},\n          {0x261, \"EOS 50D\"},\n          {0x269, \"EOS-1D X\"},\n          {0x270, \"EOS 550D\"},\n          {0x281, \"EOS-1D Mark IV\"},\n          {0x285, \"EOS 5D Mark III\"},\n          {0x286, \"EOS 600D\"},\n          {0x287, \"EOS 60D\"},\n          {0x288, \"EOS 1100D\"},\n          {0x289, \"EOS 7D Mark II\"},\n          {0x301, \"EOS 650D\"},\n          {0x302, \"EOS 6D\"},\n          {0x324, \"EOS-1D C\"},\n          {0x325, \"EOS 70D\"},\n          {0x326, \"EOS 700D\"},\n          {0x327, \"EOS 1200D\"},\n          {0x328, \"EOS-1D X Mark II\"},\n          {0x331, \"EOS M\"},\n          {0x335, \"EOS M2\"},\n          {0x374, \"EOS M3\"},  /* temp */\n          {0x384, \"EOS M10\"}, /* temp */\n          {0x394, \"EOS M5\"},  /* temp */\n          {0x346, \"EOS 100D\"},\n          {0x347, \"EOS 760D\"},\n          {0x349, \"EOS 5D Mark IV\"},\n          {0x350, \"EOS 80D\"},\n          {0x382, \"EOS 5DS\"},\n          {0x393, \"EOS 750D\"},\n          {0x401, \"EOS 5DS R\"},\n          {0x404, \"EOS 1300D\"},\n      },\n    sonique[] = {\n        {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},\n        {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},\n        {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},\n        {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},\n        {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},\n        {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},\n        {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},\n        {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},\n        {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},\n        {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},\n        {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},\n        {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},\n        {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},\n        {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},\n        {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},\n        {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},\n        {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x168, \"ILCE-6500\"},\n    };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t const_table[]\n#else\n  static const struct\n  {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  } table[]\n#endif\n      = {\n          {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},\n          {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},\n          {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},\n          {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},\n          {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},\n          {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},\n          {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},\n          //   Android Raw dumps id start\n          //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n          {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},\n          {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},\n          {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},\n          {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},\n          {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},\n          {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},\n          {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},\n          {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},\n          {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},\n          {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},\n          {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},\n          {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},\n          {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},\n          {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},\n          {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},\n          {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},\n          {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},\n          {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},\n          {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},\n          {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},\n          {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},\n          {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},\n          {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},\n          {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},\n          {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},\n          {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},\n          {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},\n          {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},\n          {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},\n          {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},\n          //   Android Raw dumps id end\n          {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},\n          {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},\n          {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},\n          {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},\n          {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},\n          {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},\n          {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},\n          {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},\n          {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},\n          {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},\n          {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},\n          {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},\n          {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},\n          {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},\n          {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},\n          {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},\n          {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},\n          {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},\n          {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},\n          {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},\n          {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},\n          {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},\n          {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},\n          {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},\n          {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},\n          {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},\n          {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},\n          {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},\n          {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},\n          {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},\n          {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},\n          {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},\n          {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},\n          {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},\n          {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},\n          {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},\n          {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},\n          {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},\n          {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},\n          {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},\n          {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},\n          {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},\n          {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},\n          {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},\n          {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},\n          {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},\n          {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},\n          {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},\n          {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},\n          {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},\n          {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},\n          {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},\n          {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},\n          {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},\n          {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},\n          {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},\n          {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},\n          {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},\n          {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},\n          {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},\n          {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},\n          {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},\n          {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},\n          {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},\n          {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},\n          {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},\n          {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},\n          {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},\n          {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},\n          {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},\n          {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},\n          {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},\n          {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},\n          {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},\n          {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},\n          {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},\n          {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},\n          {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n          {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n      };\n#ifdef LIBRAW_LIBRARY_BUILD\n  libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",\n                               \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",\n                               \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize = 1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);\n  for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)\n    memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));\n  camera_count += sizeof(const_table) / sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n#ifdef LIBRAW_LIBRARY_BUILD\n  for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n#endif\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n  for (i = 0; i < 4; i++)\n  {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i = 0; i < 0x10000; i++)\n    curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek(ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread(head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread(head, 1, 32, ifp);\n#endif\n  fseek(ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))\n  {\n    parse_phase_one(cp - head);\n    if (cp - head && parse_tiff(0))\n      apply_tiff();\n  }\n  else if (order == 0x4949 || order == 0x4d4d)\n  {\n    if (!memcmp(head + 6, \"HEAPCCDR\", 8))\n    {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(hlen, flen - hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    }\n    else if (parse_tiff(0))\n      apply_tiff();\n  }\n  else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))\n  {\n    fseek(ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek(ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  }\n  else if (!memcmp(head + 25, \"ARECOYK\", 7))\n  {\n    strcpy(make, \"Contax\");\n    strcpy(model, \"N Digital\");\n    fseek(ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek(ifp, 52, SEEK_SET);\n    switch (get4())\n    {\n    case 7:\n      iso_speed = 25;\n      break;\n    case 8:\n      iso_speed = 32;\n      break;\n    case 9:\n      iso_speed = 40;\n      break;\n    case 10:\n      iso_speed = 50;\n      break;\n    case 11:\n      iso_speed = 64;\n      break;\n    case 12:\n      iso_speed = 80;\n      break;\n    case 13:\n      iso_speed = 100;\n      break;\n    case 14:\n      iso_speed = 125;\n      break;\n    case 15:\n      iso_speed = 160;\n      break;\n    case 16:\n      iso_speed = 200;\n      break;\n    case 17:\n      iso_speed = 250;\n      break;\n    case 18:\n      iso_speed = 320;\n      break;\n    case 19:\n      iso_speed = 400;\n      break;\n    }\n    shutter = powf64(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek(ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek(ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  }\n  else if (!strcmp(head, \"PXN\"))\n  {\n    strcpy(make, \"Logitech\");\n    strcpy(model, \"Fotoman Pixtura\");\n  }\n  else if (!strcmp(head, \"qktk\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  }\n  else if (!strcmp(head, \"qktn\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  }\n  else if (!memcmp(head, \"FUJIFILM\", 8))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head + 0x1c);\n    memcpy(model2, head + 0x3c, 4);\n    model2[4] = 0;\n#endif\n    fseek(ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek(ifp, 92, SEEK_SET);\n    parse_fuji(get4());\n    if (thumb_offset > 120)\n    {\n      fseek(ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) ? 1 : 0;\n      if (is_raw == 2 && shot_select)\n        parse_fuji(i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);\n    parse_tiff(data_offset = get4());\n    parse_tiff(thumb_offset + 12);\n    apply_tiff();\n  }\n  else if (!memcmp(head, \"RIFF\", 4))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_riff();\n  }\n  else if (!memcmp(head + 4, \"ftypqt   \", 9))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_qt(fsize);\n    is_raw = 0;\n  }\n  else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))\n  {\n    fseek(ifp, 6, SEEK_SET);\n    fread(make, 1, 8, ifp);\n    fread(model, 1, 8, ifp);\n    fread(model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"NOKIARAW\", 8))\n  {\n    strcpy(make, \"NOKIA\");\n    order = 0x4949;\n    fseek(ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i * 8 / (width * height))\n    {\n    case 8:\n      load_raw = &CLASS eight_bit_load_raw;\n      break;\n    case 10:\n      load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"ARRI\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy(make, \"ARRI\");\n    fseek(ifp, 668, SEEK_SET);\n    fread(model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"XPDS\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 0x800, SEEK_SET);\n    fread(make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width = get2();\n    fseek(ifp, 56, SEEK_CUR);\n    fread(model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve(0, 12.25, 1, 1023);\n  }\n  else if (!memcmp(head + 4, \"RED1\", 4))\n  {\n    strcpy(make, \"Red\");\n    strcpy(model, \"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve(1 / 2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  }\n  else if (!memcmp(head, \"DSC-Image\", 9))\n    parse_rollei();\n  else if (!memcmp(head, \"PWAD\", 4))\n    parse_sinar_ia();\n  else if (!memcmp(head, \"\\0MRM\", 4))\n    parse_minolta(0);\n  else if (!memcmp(head, \"FOVb\", 4))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      parse_foveon();\n    else\n#endif\n      parse_x3f();\n#else\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    parse_foveon();\n#endif\n#endif\n  }\n  else if (!memcmp(head, \"CI\", 2))\n    parse_cine();\n  if (make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize = i = 0; i < camera_count; i++)\n#else\n    for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize)\n      {\n        strcpy(make, table[i].t_make);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\", 5))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n#endif\n        strcpy(model, table[i].t_model);\n        flip = table[i].flags >> 2;\n        zero_is_bad = table[i].flags & 2;\n        if (table[i].flags & 1)\n          parse_external_jpeg();\n        data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;\n        raw_width = table[i].rw;\n        raw_height = table[i].rh;\n        left_margin = table[i].lm;\n        top_margin = table[i].tm;\n        width = raw_width - left_margin - table[i].rm;\n        height = raw_height - top_margin - table[i].bm;\n        filters = 0x1010101 * table[i].cf;\n        colors = 4 - !((filters & filters >> 1) & 0x5555);\n        load_flags = table[i].lf;\n        switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))\n        {\n        case 6:\n          load_raw = &CLASS minolta_rd175_load_raw;\n          break;\n        case 8:\n          load_raw = &CLASS eight_bit_load_raw;\n          break;\n        case 10:\n          if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)\n          {\n            load_raw = &CLASS android_loose_load_raw;\n            break;\n          }\n          else if (load_flags & 1)\n          {\n            load_raw = &CLASS android_tight_load_raw;\n            break;\n          }\n        case 12:\n          load_flags |= 128;\n          load_raw = &CLASS packed_load_raw;\n          break;\n        case 16:\n          order = 0x4949 | 0x404 * (load_flags & 1);\n          tiff_bps -= load_flags >> 4;\n          tiff_bps -= load_flags = load_flags >> 1 & 7;\n          load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;\n        }\n        maximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize)\n    fsize = 0;\n  if (make[0] == 0)\n    parse_smal(0, flen);\n  if (make[0] == 0)\n  {\n    parse_jpeg(0);\n    fseek(ifp, 0, SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&\n        fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      strcpy(model, \"RPi IMX219\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 66;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    }\n    else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&\n             !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      if (!strncmp(model, \"ov5647\", 6))\n        strcpy(model, \"RPi OV5647 v.1\");\n      else\n        strcpy(model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 16;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&\n        fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))\n    {\n      strcpy(make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000 - 32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    }\n    else\n      is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i = 0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr(make, corp[i])) /* Simplify company names */\n      strcpy(make, corp[i]);\n  if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&\n      ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))\n    *cp = 0;\n  if (!strncasecmp(model, \"PENTAX\", 6))\n    strcpy(make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make, sizeof(make));\n  remove_trailing_spaces(model, sizeof(model));\n#else\n  cp = make + strlen(make); /* Remove trailing spaces */\n  while (*--cp == ' ')\n    *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ')\n    *cp = 0;\n#endif\n  i = strbuflen(make); /* Remove make from model */\n  if (!strncasecmp(model, make, i) && model[i++] == ' ')\n    memmove(model, model + i, 64 - i);\n  if (!strncmp(model, \"FinePix \", 8))\n    strcpy(model, model + 8);\n  if (!strncmp(model, \"Digital Camera \", 15))\n    strcpy(model, model + 15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw)\n    goto notraw;\n\n  if (!height)\n    height = raw_height;\n  if (!width)\n    width = raw_width;\n  if (height == 2624 && width == 3936) /* Pentax K10D and Samsung GX10 */\n  {\n    height = 2616;\n    width = 3896;\n  }\n  if (height == 3136 && width == 4864) /* Pentax K20D and Samsung GX20 */\n  {\n    height = 3124;\n    width = 4688;\n    filters = 0x16161616;\n  }\n  if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))\n  {\n    width = 4309;\n    filters = 0x16161616;\n  }\n  if (width >= 4960 && !strncmp(model, \"K-5\", 3))\n  {\n    left_margin = 10;\n    width = 4950;\n    filters = 0x16161616;\n  }\n  if (width == 6080 && !strcmp(model, \"K-70\"))\n  {\n    height = 4016;\n    top_margin = 32;\n    width = 6020;\n    left_margin = 60;\n  }\n  if (width == 4736 && !strcmp(model, \"K-7\"))\n  {\n    height = 3122;\n    width = 4684;\n    filters = 0x16161616;\n    top_margin = 2;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3 II\")) /* moved back */\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3\"))\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 7424 && !strcmp(model, \"645D\"))\n  {\n    height = 5502;\n    width = 7328;\n    filters = 0x61616161;\n    top_margin = 29;\n    left_margin = 48;\n  }\n  if (height == 3014 && width == 4096) /* Ricoh GX200 */\n    width = 4014;\n  if (dng_version)\n  {\n    if (filters == UINT_MAX)\n      filters = 0;\n    if (filters)\n      is_raw *= tiff_samples;\n    else\n      colors = tiff_samples;\n    switch (tiff_compress)\n    {\n    case 0: /* Compression not set, assuming uncompressed */\n    case 1:\n      load_raw = &CLASS packed_dng_load_raw;\n      break;\n    case 7:\n      load_raw = &CLASS lossless_dng_load_raw;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      load_raw = &CLASS deflate_dng_load_raw;\n      break;\n#endif\n    case 34892:\n      load_raw = &CLASS lossy_dng_load_raw;\n      break;\n    default:\n      load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\", 5) && unique_id)\n    {\n      for (i = 0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n        {\n          strcpy(model, unique[i].t_model);\n          break;\n        }\n    }\n    if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n    {\n      for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n        {\n          strcpy(model, sonique[i].t_model);\n          break;\n        }\n    }\n    goto dng_skip;\n  }\n  if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)\n  {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i = 0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1])\n      {\n        width = raw_width - (left_margin = canon[i][2]);\n        height = raw_height - (top_margin = canon[i][3]);\n        width -= canon[i][4];\n        height -= canon[i][5];\n        mask[0][1] = canon[i][6];\n        mask[0][3] = -canon[i][7];\n        mask[1][1] = canon[i][8];\n        mask[1][3] = -canon[i][9];\n        if (canon[i][10])\n          filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000)\n    {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make, \"Canon\", 5) && unique_id)\n  {\n    for (i = 0; i < sizeof unique / sizeof *unique; i++)\n      if (unique_id == 0x80000000 + unique[i].id)\n      {\n        adobe_coeff(\"Canon\", unique[i].t_model);\n        strcpy(model, unique[i].t_model);\n      }\n  }\n\n  if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n  {\n    for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n      if (unique_id == sonique[i].id)\n      {\n        adobe_coeff(\"Sony\", sonique[i].t_model);\n        strcpy(model, sonique[i].t_model);\n      }\n  }\n\n  if (!strncmp(make, \"Nikon\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n  /* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)\n  {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy(model, \"C603\");\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n#else\n  /* Always 512 for arw2_load_raw */\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = (load_raw == &LibRaw::sony_arw2_load_raw) ? 512 : (128 << (tiff_bps - 12));\n#endif\n\n  if (is_foveon)\n  {\n    if (height * 2 < width)\n      pixel_aspect = 0.5;\n    if (height > width)\n      pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if (!strncmp(make, \"Pentax\", 6))\n  {\n    if (!strncmp(model, \"K-1\", 3))\n    {\n      top_margin = 18;\n      height = raw_height - top_margin;\n      if (raw_width == 7392)\n      {\n        left_margin = 6;\n        width = 7376;\n      }\n    }\n  }\n  else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)\n  {\n    switch (width)\n    {\n    case 3344:\n      width -= 66;\n    case 3872:\n      width -= 6;\n    }\n    if (height > width)\n    {\n      SWAP(height, width);\n      SWAP(raw_height, raw_width);\n    }\n    if (width == 7200 && height == 3888)\n    {\n      raw_width = width = 6480;\n      raw_height = height = 4320;\n    }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot 600\"))\n  {\n    height = 613;\n    width = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))\n  {\n    height = 773;\n    width = 960;\n    raw_width = 992;\n    pixel_aspect = 256 / 235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot A50\"))\n  {\n    height = 968;\n    width = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot Pro70\"))\n  {\n    height = 1024;\n    width = 1552;\n    filters = 0x1e4b4e1b;\n  canon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  }\n  else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))\n  {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  }\n  else if (!strcmp(model, \"PowerShot A610\"))\n  {\n    if (canon_s2is())\n      strcpy(model + 10, \"S2 IS\");\n  }\n  else if (!strcmp(model, \"PowerShot SX220 HS\"))\n  {\n    mask[1][3] = -4;\n    top_margin = 16;\n    left_margin = 92;\n  }\n  else if (!strcmp(model, \"PowerShot S120\"))\n  {\n    raw_width = 4192;\n    raw_height = 3062;\n    width = 4022;\n    height = 3016;\n    mask[0][0] = top_margin = 31;\n    mask[0][2] = top_margin + height;\n    left_margin = 120;\n    mask[0][1] = 23;\n    mask[0][3] = 72;\n  }\n  else if (!strcmp(model, \"PowerShot G16\"))\n  {\n    mask[0][0] = 0;\n    mask[0][2] = 80;\n    mask[0][1] = 0;\n    mask[0][3] = 16;\n    top_margin = 29;\n    left_margin = 120;\n    width = raw_width - left_margin - 48;\n    height = raw_height - top_margin - 14;\n  }\n  else if (!strcmp(model, \"PowerShot SX50 HS\"))\n  {\n    top_margin = 17;\n  }\n  else if (!strcmp(model, \"EOS D2000C\"))\n  {\n    filters = 0x61616161;\n    if (!black)\n      black = curve[200];\n  }\n  else if (!strcmp(model, \"D1\"))\n  {\n    cam_mul[0] *= 256 / 527.0;\n    cam_mul[2] *= 256 / 317.0;\n  }\n  else if (!strcmp(model, \"D1X\"))\n  {\n    width -= 4;\n    pixel_aspect = 0.5;\n  }\n  else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))\n  {\n    height -= 3;\n    width -= 4;\n  }\n  else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))\n  {\n    width -= 4;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D3100\"))\n  {\n    width -= 28;\n    left_margin = 6;\n  }\n  else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))\n  {\n    width -= 42;\n  }\n  else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))\n  {\n    width -= 44;\n  }\n  else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))\n  {\n    width -= 46;\n  }\n  else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))\n  {\n    width -= 52;\n    left_margin = 2;\n  }\n  else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))\n  {\n    width--;\n  }\n  else if (!strcmp(model, \"D100\"))\n  {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  }\n  else if (!strcmp(model, \"D200\"))\n  {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  }\n  else if (!strncmp(model, \"D2H\", 3))\n  {\n    left_margin = 6;\n    width -= 14;\n  }\n  else if (!strncmp(model, \"D2X\", 3))\n  {\n    if (width == 3264)\n      width -= 32;\n    else\n      width -= 8;\n  }\n  else if (!strncmp(model, \"D300\", 4))\n  {\n    width -= 32;\n  }\n  else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)\n  {\n    if (!strcmp(model, \"COOLPIX P7700\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7700\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P7800\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7800\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P340\"))\n      load_flags = 0;\n  }\n  else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)\n  {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))\n      black = 255;\n  }\n  else if (!strncmp(model, \"COOLPIX B700\", 12))\n  {\n    load_flags = 24;\n    black = 200;\n  }\n  else if (!strncmp(model, \"1 \", 2))\n  {\n    height -= 2;\n  }\n  else if (fsize == 1581060)\n  {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  }\n  else if (fsize == 3178560)\n  {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  }\n  else if (fsize == 4771840)\n  {\n    if (!timestamp && nikon_e995())\n      strcpy(model, \"E995\");\n    if (strcmp(model, \"E995\"))\n    {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  }\n  else if (fsize == 2940928)\n  {\n    if (!timestamp && !nikon_e2100())\n      strcpy(model, \"E2500\");\n    if (!strcmp(model, \"E2500\"))\n    {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  }\n  else if (fsize == 4775936)\n  {\n    if (!timestamp)\n      nikon_3700();\n    if (model[0] == 'E' && atoi(model + 1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model, \"Optio 33WR\"))\n    {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O')\n    {\n      i = find_green(12, 32, 1188864, 3576832);\n      c = find_green(12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c))\n      {\n        SWAP(i, c);\n        load_flags = 24;\n      }\n      if (i < 0)\n        filters = 0x61616161;\n    }\n  }\n  else if (fsize == 5869568)\n  {\n    if (!timestamp && minolta_z2())\n    {\n      strcpy(make, \"Minolta\");\n      strcpy(model, \"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24 * (make[0] == 'M');\n  }\n  else if (fsize == 6291456)\n  {\n    fseek(ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d)\n    {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy(make, \"ISG\");\n      model[0] = 0;\n    }\n  }\n  else if (!strncmp(make, \"Fujifilm\", 8))\n  {\n    if (!strcmp(model + 7, \"S2Pro\"))\n    {\n      strcpy(model, \"S2Pro\");\n      height = 2144;\n      width = 2880;\n      flip = 6;\n    }\n    else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width) >> 2 << 1;\n    if (width == 2848 || width == 3664)\n      filters = 0x16161616;\n    if (width == 4032 || width == 4952)\n      left_margin = 0;\n    if (width == 3328 && (width -= 66))\n      left_margin = 34;\n    if (width == 4936)\n      left_margin = 4;\n    if (width == 6032)\n      left_margin = 0;\n    if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))\n    {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if (!strcmp(model, \"GFX 50S\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n    }\n    if (!strcmp(model, \"S5500\"))\n    {\n      height -= (top_margin = 6);\n    }\n    if (fuji_layout)\n      raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];\n  }\n  else if (!strcmp(model, \"KD-400Z\"))\n  {\n    height = 1712;\n    width = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  }\n  else if (!strcmp(model, \"KD-510Z\"))\n  {\n    goto konica_510z;\n  }\n  else if (!strncasecmp(make, \"Minolta\", 7))\n  {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model, \"DiMAGE A\", 8))\n    {\n      if (!strcmp(model, \"DiMAGE A200\"))\n        filters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))\n    {\n      sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));\n      adobe_coeff(make, model + 20);\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"DiMAGE G\", 8))\n    {\n      if (model[8] == '4')\n      {\n        height = 1716;\n        width = 2304;\n      }\n      else if (model[8] == '5')\n      {\n      konica_510z:\n        height = 1956;\n        width = 2607;\n        raw_width = 2624;\n      }\n      else if (model[8] == '6')\n      {\n        height = 2136;\n        width = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\n    konica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  }\n  else if (!strcmp(model, \"*ist D\"))\n  {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  }\n  else if (!strcmp(model, \"*ist DS\"))\n  {\n    height -= 2;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)\n  {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))\n  {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)\n  {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)\n  {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12)\n      load_flags = 80;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)\n  {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)\n  {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n      black = 1 << (tiff_bps - 7);\n  }\n  else if (!strcmp(model, \"EX1\"))\n  {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682)\n    {\n      height -= 10;\n      width -= 46;\n      top_margin = 8;\n    }\n  }\n  else if (!strcmp(model, \"WB2000\"))\n  {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718)\n    {\n      height -= 28;\n      width -= 56;\n      top_margin = 8;\n    }\n  }\n  else if (strstr(model, \"WB550\"))\n  {\n    strcpy(model, \"WB550\");\n  }\n  else if (!strcmp(model, \"EX2F\"))\n  {\n    height = 3030;\n    width = 4040;\n    top_margin = 15;\n    left_margin = 24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  else if (!strcmp(model, \"STV680 VGA\"))\n  {\n    black = 16;\n  }\n  else if (!strcmp(model, \"N95\"))\n  {\n    height = raw_height - (top_margin = 2);\n  }\n  else if (!strcmp(model, \"640x480\"))\n  {\n    gamma_curve(0.45, 4.5, 1, 255);\n  }\n  else if (!strncmp(make, \"Hasselblad\", 10))\n  {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262)\n    {\n      height = 5444;\n      width = 7248;\n      top_margin = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if (!strncasecmp(model, \"H3D\", 3))\n      {\n        adobe_coeff(\"Hasselblad\", \"H3DII-39\");\n        strcpy(model, \"H3DII-39\");\n      }\n    }\n    else if (raw_width == 7410 || raw_width == 8282)\n    {\n      height -= 84;\n      width -= 82;\n      top_margin = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\", \"H4D-40\");\n      strcpy(model, \"H4D-40\");\n    }\n    else if (raw_width == 8384) // X1D\n    {\n      top_margin = 96;\n      height -= 96;\n      left_margin = 48;\n      width -= 106;\n      adobe_coeff(\"Hasselblad\", \"X1D\");\n      maximum = 0xffff;\n      tiff_bps = 16;\n    }\n    else if (raw_width == 9044)\n    {\n      if (black > 500)\n      {\n        top_margin = 12;\n        left_margin = 44;\n        width = 8956;\n        height = 6708;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H4D-60\");\n        strcpy(model, \"H4D-60\");\n        black = 512;\n      }\n      else\n      {\n        height = 6716;\n        width = 8964;\n        top_margin = 8;\n        left_margin = 40;\n        black += load_flags = 256;\n        maximum = 0x8101;\n        strcpy(model, \"H3DII-60\");\n      }\n    }\n    else if (raw_width == 4090)\n    {\n      strcpy(model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n    else if (raw_width == 8282 && raw_height == 6240)\n    {\n      if (!strncasecmp(model, \"H5D\", 3))\n      {\n        /* H5D 50*/\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        black = 256;\n        strcpy(model, \"H5D-50\");\n      }\n      else if (!strncasecmp(model, \"H3D\", 3))\n      {\n        black = 0;\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H3D-50\");\n        strcpy(model, \"H3D-50\");\n      }\n    }\n    else if (raw_width == 8374 && raw_height == 6304)\n    {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model, \"H5D-50c\");\n    }\n    if (tiff_samples > 1)\n    {\n      is_raw = tiff_samples + 1;\n      if (!shot_select && !half_size)\n        filters = 0;\n    }\n  }\n  else if (!strncmp(make, \"Sinar\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size)\n      filters = 0;\n    maximum = 0x3fff;\n  }\n  else if (!strncmp(make, \"Leaf\", 4))\n  {\n    maximum = 0x3fff;\n    fseek(ifp, data_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1)\n      filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height)\n    {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048)\n    {\n      if (tiff_samples == 1)\n      {\n        filters = 1;\n        strcpy(cdesc, \"RBTG\");\n        strcpy(model, \"CatchLight\");\n        top_margin = 8;\n        left_margin = 18;\n        height = 2032;\n        width = 2016;\n      }\n      else\n      {\n        strcpy(model, \"DCB2\");\n        top_margin = 10;\n        left_margin = 16;\n        height = 2028;\n        width = 2022;\n      }\n    }\n    else if (width + height == 3144 + 2060)\n    {\n      if (!model[0])\n        strcpy(model, \"Cantare\");\n      if (width > height)\n      {\n        top_margin = 6;\n        left_margin = 32;\n        height = 2048;\n        width = 3072;\n        filters = 0x61616161;\n      }\n      else\n      {\n        left_margin = 6;\n        top_margin = 32;\n        width = 2048;\n        height = 3072;\n        filters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V')\n        filters = 0;\n      else\n        is_raw = tiff_samples;\n    }\n    else if (width == 2116)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    }\n    else if (width == 3171)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  }\n  else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))\n  {\n    if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw)\n    {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height)\n      height = raw_height;\n    for (i = 0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1])\n      {\n        left_margin = pana[i][2];\n        top_margin = pana[i][3];\n        width += pana[i][4];\n        height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  }\n  else if (!strcmp(model, \"C770UZ\"))\n  {\n    height = 1718;\n    width = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  }\n  else if (!strncmp(make, \"Olympus\", 7))\n  {\n    height += height & 1;\n    if (exif_cfa)\n      filters = exif_cfa;\n    if (width == 4100)\n      width -= 4;\n    if (width == 4080)\n      width -= 24;\n    if (width == 9280)\n    {\n      width -= 6;\n      height -= 6;\n    }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))\n    {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw)\n      {\n        maximum = 0xfc3;\n        memset(cblack, 0, sizeof cblack);\n      }\n    }\n    else if (!strcmp(model, \"STYLUS1\"))\n    {\n      width -= 14;\n      maximum = 0xfff;\n    }\n    else if (!strcmp(model, \"E-330\"))\n    {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n        maximum = 0xf79;\n    }\n    else if (!strcmp(model, \"SP550UZ\"))\n    {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width = 640;\n    }\n    else if (!strcmp(model, \"TG-4\"))\n    {\n      width -= 16;\n    }\n  }\n  else if (!strcmp(model, \"N Digital\"))\n  {\n    height = 2047;\n    width = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strcmp(model, \"DSC-F828\"))\n  {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy(cdesc, \"RGBE\");\n  }\n  else if (!strcmp(model, \"DSC-V3\"))\n  {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)\n  {\n    width = 3925;\n    order = 0x4d4d;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(make, \"Sony\") && raw_width == 4600)\n  {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)\n  {\n    if (height < 3280)\n      width -= 8;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)\n  { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)\n  {\n    width -= 24;\n    if (strstr(model, \"RX1\") || strstr(model, \"A99\"))\n      width -= 6;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)\n  {\n    width -= 30;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(model, \"DSLR-A100\"))\n  {\n    if (width == 3880)\n    {\n      height--;\n      width = ++raw_width;\n    }\n    else\n    {\n      height -= 4;\n      width -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strcmp(model, \"PIXL\"))\n  {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve(0, 7, 1, 255);\n  }\n  else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))\n  {\n    order = 0x4949;\n    if (filters && data_offset)\n    {\n      fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts(curve, 256);\n    }\n    else\n      gamma_curve(0, 3.875, 1, 255);\n    load_raw = filters ? &CLASS eight_bit_load_raw\n                       : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  }\n  else if (!strncasecmp(model, \"EasyShare\", 9))\n  {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strncasecmp(make, \"Kodak\", 5))\n  {\n    if (filters == UINT_MAX)\n      filters = 0x61616161;\n    if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))\n    {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ')\n        model[6] = 0;\n      if (!strcmp(model, \"DCS460A\"))\n        goto bw;\n    }\n    else if (!strcmp(model, \"DCS660M\"))\n    {\n      black = 214;\n      goto bw;\n    }\n    else if (!strcmp(model, \"DCS760M\"))\n    {\n    bw:\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model + 4, \"20X\"))\n      strcpy(cdesc, \"MYCY\");\n    if (strstr(model, \"DC25\"))\n    {\n      strcpy(model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model, \"DC2\", 3))\n    {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000)\n      {\n        raw_width = 256;\n        width = 249;\n        pixel_aspect = (4.0 * height) / (3.0 * width);\n      }\n      else\n      {\n        raw_width = 512;\n        width = 501;\n        pixel_aspect = (493.0 * height) / (373.0 * width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    }\n    else if (!strcmp(model, \"40\"))\n    {\n      strcpy(model, \"DC40\");\n      height = 512;\n      width = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    }\n    else if (strstr(model, \"DC50\"))\n    {\n      strcpy(model, \"DC50\");\n      height = 512;\n      width = 768;\n      iso_speed = 84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    }\n    else if (strstr(model, \"DC120\"))\n    {\n      strcpy(model, \"DC120\");\n      raw_height = height = 976;\n      raw_width = width = 848;\n      iso_speed = 160;\n      pixel_aspect = height / 0.75 / width;\n      load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    }\n    else if (!strcmp(model, \"DCS200\"))\n    {\n      thumb_height = 128;\n      thumb_width = 192;\n      thumb_offset = 6144;\n      thumb_misc = 360;\n      iso_speed = 140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  }\n  else if (!strcmp(model, \"Fotoman Pixtura\"))\n  {\n    height = 512;\n    width = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  }\n  else if (!strncmp(model, \"QuickTake\", 9))\n  {\n    if (head[5])\n      strcpy(model + 10, \"200\");\n    fseek(ifp, 544, SEEK_SET);\n    height = get2();\n    width = get2();\n    data_offset = (get4(), get2()) == 30 ? 738 : 736;\n    if (height > width)\n    {\n      SWAP(height, width);\n      fseek(ifp, data_offset - 6, SEEK_SET);\n      flip = ~get2() & 3 ? 5 : 6;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strncmp(make, \"Rollei\", 6) && !load_raw)\n  {\n    switch (raw_width)\n    {\n    case 1316:\n      height = 1030;\n      width = 1300;\n      top_margin = 1;\n      left_margin = 6;\n      break;\n    case 2568:\n      height = 1960;\n      width = 2560;\n      top_margin = 2;\n      left_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model, \"GRAS-50S5C\"))\n  {\n    height = 2048;\n    width = 2440;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x49494949;\n    order = 0x4949;\n    maximum = 0xfffC;\n  }\n  else if (!strcmp(model, \"BB-500CL\"))\n  {\n    height = 2058;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"BB-500GE\"))\n  {\n    height = 2058;\n    width = 2456;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"SVS625CL\"))\n  {\n    height = 2050;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if (!model[0])\n    sprintf(model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX)\n    filters = 0x94949494;\n  if (thumb_offset && !thumb_height)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      thumb_width = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (dng_version) /* Override black level by DNG tags */\n  {\n    /* copy DNG data from per-IFD field to color.dng */\n    int iifd = 0;\n    for (; iifd < tiff_nifds; iifd++)\n      if (tiff_ifd[iifd].offset == data_offset) // found\n        break;\n\n    if (iifd < tiff_nifds)\n    {\n      memmove(&imgdata.color.dng_color[0], &tiff_ifd[iifd].dng_color[0], sizeof(tiff_ifd[iifd].dng_color[0]));\n      memmove(&imgdata.color.dng_color[1], &tiff_ifd[iifd].dng_color[1], sizeof(tiff_ifd[iifd].dng_color[1]));\n      memmove(&imgdata.color.dng_levels, &tiff_ifd[iifd].dng_levels, sizeof(tiff_ifd[iifd].dng_levels));\n      meta_offset = tiff_ifd[iifd].opcode2_offset;\n      if (tiff_ifd[iifd].lineartable_offset && tiff_ifd[iifd].lineartable_len)\n      {\n        INT64 pos = ftell(ifp);\n        fseek(ifp, tiff_ifd[iifd].lineartable_offset, SEEK_SET);\n        linear_table(tiff_ifd[iifd].lineartable_len);\n        fseek(ifp, pos, SEEK_SET);\n      }\n      // Need to add curve too\n    }\n    /* Copy DNG black level to  */\n    maximum = imgdata.color.dng_levels.dng_whitelevel[0];\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),\n                 (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for (int i = 0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)\n  {\n    memcpy(rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color)\n    adobe_coeff(make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if (imgdata.color.cam_xyz[0][0] < 0.01)\n    adobe_coeff(make, model, 1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color)\n      adobe_coeff(\"Apple\", \"Quicktake\");\n\n  if (fuji_width)\n  {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  }\n  else\n  {\n    if (raw_height < height)\n      raw_height = height;\n    if (raw_width < width)\n      raw_width = width;\n  }\n  if (!tiff_bps)\n    tiff_bps = 12;\n  if (!maximum)\n  {\n    maximum = (1 << tiff_bps) - 1;\n    if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)\n      maximum = curve[maximum];\n  }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");\n  if (!raw_height)\n    raw_height = height;\n  if (!raw_width)\n    raw_width = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX)\n    flip = tiff_flip;\n  if (flip == UINT_MAX)\n    flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if (flip > 89 || flip < -89)\n  {\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n      break;\n    }\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n}\n\n//@end COMMON\n\n//@out FILEIO\n#ifndef NO_LCMS\nvoid CLASS apply_profile(const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile = 0, hOutProfile = 0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n  if (strcmp(input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile(input, \"r\");\n  else if (profile_length)\n  {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *)malloc(profile_length);\n    merror(prof, \"apply_profile()\");\n    fseek(ifp, profile_offset, SEEK_SET);\n    fread(prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem(prof, profile_length);\n    free(prof);\n#else\n    hInProfile = cmsOpenProfileFromMem(imgdata.color.profile, profile_length);\n#endif\n  }\n  else\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n  }\n  if (!hInProfile)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n    return;\n  }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen(output, \"rb\")))\n  {\n    fread(&size, 4, 1, fp);\n    fseek(fp, 0, SEEK_SET);\n    oprof = (unsigned *)malloc(size = ntohl(size));\n    merror(oprof, \"apply_profile()\");\n    fread(oprof, 1, size, fp);\n    fclose(fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem(oprof, size)))\n    {\n      free(oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n  else\n    fprintf(stderr, _(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n    goto quit;\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 0, 2);\n#endif\n  hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_16, hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform(hTransform, image, image, width * height);\n  raw_color = 1; /* Don't use rgb_cam with a profile */\n  cmsDeleteTransform(hTransform);\n  cmsCloseProfile(hOutProfile);\nquit:\n  cmsCloseProfile(hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 1, 2);\n#endif\n}\n#endif\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] = {\n      {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};\n  static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  static const double adobe_rgb[3][3] = {\n      {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};\n  static const double wide_rgb[3][3] = {\n      {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};\n  static const double prophoto_rgb[3][3] = {\n      {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};\n  static const double aces_rgb[3][3] = {\n      {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};\n  static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};\n  static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};\n  static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,\n                                   0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,\n                                   0,    0, 0,          0xf6d6,     0x10000,    0xd32d};\n  unsigned pbody[] = {10,         0x63707274, 0,  36, /* cprt */\n                      0x64657363, 0,          40,     /* desc */\n                      0x77747074, 0,          20,     /* wtpt */\n                      0x626b7074, 0,          20,     /* bkpt */\n                      0x72545243, 0,          14,     /* rTRC */\n                      0x67545243, 0,          14,     /* gTRC */\n                      0x62545243, 0,          14,     /* bTRC */\n                      0x7258595a, 0,          20,     /* rXYZ */\n                      0x6758595a, 0,          20,     /* gXYZ */\n                      0x6258595a, 0,          20};    /* bXYZ */\n  static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};\n  unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);\n#endif\n  gamma_curve(gamm[0], gamm[1], 0, 0);\n  memcpy(out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 || output_color < 1 || output_color > 6;\n#endif\n  if (!raw_color)\n  {\n    oprof = (unsigned *)calloc(phead[0], 1);\n    merror(oprof, \"convert_to_rgb()\");\n    memcpy(oprof, phead, sizeof phead);\n    if (output_color == 5)\n      oprof[4] = oprof[5];\n    oprof[0] = 132 + 12 * pbody[0];\n    for (i = 0; i < pbody[0]; i++)\n    {\n      oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i * 3 + 2] = oprof[0];\n      oprof[0] += (pbody[i * 3 + 3] + 3) & -4;\n    }\n    memcpy(oprof + 32, pbody, sizeof pbody);\n    oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;\n    memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;\n    for (i = 4; i < 7; i++)\n      memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);\n    pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n        for (num = k = 0; k < 3; k++)\n          num += xyzd50_srgb[i][k] * inverse[j][k];\n        oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;\n      }\n    for (i = 0; i < phead[0] / 4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");\n    strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (out_cam[i][j] = k = 0; k < 3; k++)\n          out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),\n            name[output_color - 1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset(histogram, 0, sizeof histogram);\n  for (img = image[0], row = 0; row < height; row++)\n    for (col = 0; col < width; col++, img += 4)\n    {\n      if (!raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        FORCC\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        FORC3 img[c] = CLIP((int)out[c]);\n      }\n      else if (document_mode)\n        img[0] = img[fcol(row, col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color)\n    colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters)\n    colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort(*)[4])calloc(high, wide * sizeof *img);\n  merror(img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);\n#endif\n\n  for (row = 0; row < high; row++)\n    for (col = 0; col < wide; col++)\n    {\n      ur = r = fuji_width + (row - col) * step;\n      uc = c = (row + col) * step;\n      if (ur > height - 2 || uc > width - 2)\n        continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur * width + uc;\n      for (i = 0; i < colors; i++)\n        img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +\n                                   (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;\n    }\n\n  free(image);\n  width = wide;\n  height = high;\n  image = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1)\n  {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(width, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c * width];\n      if (c + 1 < height)\n        pix1 += width * 4;\n      for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)\n        FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    height = newdim;\n  }\n  else\n  {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(height, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c + 1 < width)\n        pix1 += 4;\n      for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)\n        FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    width = newdim;\n  }\n  free(image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);\n#endif\n}\n\nint CLASS flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}\n//@end COMMON\n\nstruct tiff_tag\n{\n  ushort tag, type;\n  int count;\n  union {\n    char c[4];\n    short s[2];\n    int i;\n  } val;\n};\n\nstruct tiff_hdr\n{\n  ushort t_order, magic;\n  int ifd;\n  ushort pad, ntag;\n  struct tiff_tag tag[23];\n  int nextifd;\n  ushort pad2, nexif;\n  struct tiff_tag exif[4];\n  ushort pad3, ngps;\n  struct tiff_tag gpst[10];\n  short bps[4];\n  int rat[10];\n  unsigned gps[26];\n  char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];\n};\n\n//@out COMMON\n\nvoid CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag + 1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2)\n  {\n    count = strnlen((char *)th + val, count - 1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val + c];\n  }\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head(struct tiff_hdr *th, int full)\n{\n  int c, psize = 0;\n  struct tm *t;\n\n  memset(th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4 + c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy(th->t_desc, desc, 512);\n  strncpy(th->t_make, make, 64);\n  strncpy(th->t_model, model, 64);\n  strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime(&timestamp);\n  sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,\n          t->tm_min, t->tm_sec);\n  strncpy(th->t_artist, artist, 64);\n  if (full)\n  {\n    tiff_set(th, &th->ntag, 254, 4, 1, 0);\n    tiff_set(th, &th->ntag, 256, 4, 1, width);\n    tiff_set(th, &th->ntag, 257, 4, 1, height);\n    tiff_set(th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag - 1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set(th, &th->ntag, 259, 3, 1, 1);\n    tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full)\n  {\n    if (oprof)\n      psize = ntohl(oprof[0]);\n    tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set(th, &th->ntag, 277, 3, 1, colors);\n    tiff_set(th, &th->ntag, 278, 4, 1, height);\n    tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);\n  }\n  else\n    tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');\n  tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set(th, &th->ntag, 284, 3, 1, 1);\n  tiff_set(th, &th->ntag, 296, 3, 1, 2);\n  tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize)\n    tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1])\n  {\n    tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set(th, &th->ngps, 0, 1, 4, 0x202);\n    tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);\n    tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));\n    tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);\n    tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));\n    tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);\n    tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));\n    tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));\n    tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy(th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc(0xff, tfp);\n  fputc(0xd8, tfp);\n  if (strcmp(t_humb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, tfp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, tfp);\n  }\n  fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp, thumb, thumb_length);\n  free(thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  fputc(0xff, ofp);\n  fputc(0xd8, ofp);\n  if (strcmp(thumb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, ofp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, ofp);\n  }\n  fwrite(thumb + 2, 1, thumb_length - 2, ofp);\n  free(thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white = 0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01; /* 99th percentile white level */\n#endif\n  if (fuji_width)\n    perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white = c = 0; c < colors; c++)\n    {\n      for (val = 0x2000, total = 0; --val > 32;)\n        if ((total += histogram[c][val]) > perc)\n          break;\n      if (t_white < val)\n        t_white = val;\n    }\n  gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);\n  iheight = height;\n  iwidth = width;\n  if (flip & 4)\n    SWAP(height, width);\n  ppm = (uchar *)calloc(width, colors * output_bps / 8);\n  ppm2 = (ushort *)ppm;\n  merror(ppm, \"write_ppm_tiff()\");\n  if (output_tiff)\n  {\n    tiff_head(&th, 1);\n    fwrite(&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite(oprof, ntohl(oprof[0]), 1, ofp);\n  }\n  else if (colors > 3)\n    fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,\n            (1 << output_bps) - 1, cdesc);\n  else\n    fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, width);\n  for (row = 0; row < height; row++, soff += rstep)\n  {\n    for (col = 0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n        FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;\n      else\n        FORCC ppm2[col * colors + c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab((char *)ppm2, (char *)ppm2, width * colors * 2);\n    fwrite(ppm, colors * output_bps / 8, width, ofp);\n  }\n  free(ppm);\n}\n//@end COMMON\n\nint CLASS main(int argc, const char **argv)\n{\n  int arg, status = 0, quality, i, c;\n  int timestamp_only = 0, thumbnail_only = 0, identify_only = 0;\n  int user_qual = -1, user_black = -1, user_sat = -1, user_flip = -1;\n  int use_fuji_rotate = 1, write_to_stdout = 0, read_from_stdin = 0;\n  const char *sp, *bpfile = 0, *dark_frame = 0, *write_ext;\n  char opm, opt, *ofname, *cp;\n  struct utimbuf ut;\n#ifndef NO_LCMS\n  const char *cam_profile = 0, *out_profile = 0;\n#endif\n\n#ifndef LOCALTIME\n  putenv((char *)\"TZ=UTC\");\n#endif\n#ifdef LOCALEDIR\n  setlocale(LC_CTYPE, \"\");\n  setlocale(LC_MESSAGES, \"\");\n  bindtextdomain(\"dcraw\", LOCALEDIR);\n  textdomain(\"dcraw\");\n#endif\n\n  if (argc == 1)\n  {\n    printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\n    puts(_(\"-v        Print verbose messages\"));\n    puts(_(\"-c        Write image data to standard output\"));\n    puts(_(\"-e        Extract embedded thumbnail image\"));\n    puts(_(\"-i        Identify files without decoding them\"));\n    puts(_(\"-i -v     Identify files and show metadata\"));\n    puts(_(\"-z        Change file dates to camera timestamp\"));\n    puts(_(\"-w        Use camera white balance, if possible\"));\n    puts(_(\"-a        Average the whole image for white balance\"));\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\n    puts(_(\"-r <r g b g> Set custom white balance\"));\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\n    puts(_(\"-k <num>  Set the darkness level\"));\n    puts(_(\"-S <num>  Set the saturation level\"));\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\n#ifndef NO_LCMS\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\n#endif\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\n    puts(_(\"-W        Don't automatically brighten the image\"));\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\n    puts(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\n    puts(_(\"-6        Write 16-bit instead of 8-bit\"));\n    puts(_(\"-4        Linear 16-bit, same as \\\"-6 -W -g 1 1\\\"\"));\n    puts(_(\"-T        Write TIFF instead of PPM\"));\n    puts(\"\");\n    return 1;\n  }\n  argv[argc] = \"\";\n  for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)\n  {\n    opt = argv[arg++][1];\n    if ((cp = (char *)strchr(sp = \"nbrkStqmHACg\", opt)))\n      for (i = 0; i < \"114111111422\"[cp - sp] - '0'; i++)\n        if (!isdigit(argv[arg + i][0]))\n        {\n          fprintf(stderr, _(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\n          return 1;\n        }\n    switch (opt)\n    {\n    case 'n':\n      threshold = atof(argv[arg++]);\n      break;\n    case 'b':\n      bright = atof(argv[arg++]);\n      break;\n    case 'r':\n      FORC4 user_mul[c] = atof(argv[arg++]);\n      break;\n    case 'C':\n      aber[0] = 1 / atof(argv[arg++]);\n      aber[2] = 1 / atof(argv[arg++]);\n      break;\n    case 'g':\n      gamm[0] = atof(argv[arg++]);\n      gamm[1] = atof(argv[arg++]);\n      if (gamm[0])\n        gamm[0] = 1 / gamm[0];\n      break;\n    case 'k':\n      user_black = atoi(argv[arg++]);\n      break;\n    case 'S':\n      user_sat = atoi(argv[arg++]);\n      break;\n    case 't':\n      user_flip = atoi(argv[arg++]);\n      break;\n    case 'q':\n      user_qual = atoi(argv[arg++]);\n      break;\n    case 'm':\n      med_passes = atoi(argv[arg++]);\n      break;\n    case 'H':\n      highlight = atoi(argv[arg++]);\n      break;\n    case 's':\n      shot_select = abs(atoi(argv[arg]));\n      multi_out = !strcmp(argv[arg++], \"all\");\n      break;\n    case 'o':\n      if (isdigit(argv[arg][0]) && !argv[arg][1])\n        output_color = atoi(argv[arg++]);\n#ifndef NO_LCMS\n      else\n        out_profile = argv[arg++];\n      break;\n    case 'p':\n      cam_profile = argv[arg++];\n#endif\n      break;\n    case 'P':\n      bpfile = argv[arg++];\n      break;\n    case 'K':\n      dark_frame = argv[arg++];\n      break;\n    case 'z':\n      timestamp_only = 1;\n      break;\n    case 'e':\n      thumbnail_only = 1;\n      break;\n    case 'i':\n      identify_only = 1;\n      break;\n    case 'c':\n      write_to_stdout = 1;\n      break;\n    case 'v':\n      verbose = 1;\n      break;\n    case 'h':\n      half_size = 1;\n      break;\n    case 'f':\n      four_color_rgb = 1;\n      break;\n    case 'A':\n      FORC4 greybox[c] = atoi(argv[arg++]);\n    case 'a':\n      use_auto_wb = 1;\n      break;\n    case 'w':\n      use_camera_wb = 1;\n      break;\n    case 'M':\n      use_camera_matrix = 3 * (opm == '+');\n      break;\n    case 'I':\n      read_from_stdin = 1;\n      break;\n    case 'E':\n      document_mode++;\n    case 'D':\n      document_mode++;\n    case 'd':\n      document_mode++;\n    case 'j':\n      use_fuji_rotate = 0;\n      break;\n    case 'W':\n      no_auto_bright = 1;\n      break;\n    case 'T':\n      output_tiff = 1;\n      break;\n    case '4':\n      gamm[0] = gamm[1] = no_auto_bright = 1;\n    case '6':\n      output_bps = 16;\n      break;\n    default:\n      fprintf(stderr, _(\"Unknown option \\\"-%c\\\".\\n\"), opt);\n      return 1;\n    }\n  }\n  if (arg == argc)\n  {\n    fprintf(stderr, _(\"No files to process.\\n\"));\n    return 1;\n  }\n  if (write_to_stdout)\n  {\n    if (isatty(1))\n    {\n      fprintf(stderr, _(\"Will not write an image to the terminal!\\n\"));\n      return 1;\n    }\n#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)\n    if (setmode(1, O_BINARY) < 0)\n    {\n      perror(\"setmode()\");\n      return 1;\n    }\n#endif\n  }\n  for (; arg < argc; arg++)\n  {\n    status = 1;\n    raw_image = 0;\n    image = 0;\n    oprof = 0;\n    meta_data = ofname = 0;\n    ofp = stdout;\n    if (setjmp(failure))\n    {\n      if (fileno(ifp) > 2)\n        fclose(ifp);\n      if (fileno(ofp) > 2)\n        fclose(ofp);\n      status = 1;\n      goto cleanup;\n    }\n    ifname = argv[arg];\n    if (!(ifp = fopen(ifname, \"rb\")))\n    {\n      perror(ifname);\n      continue;\n    }\n    status = (identify(), !is_raw);\n    if (user_flip >= 0)\n      flip = user_flip;\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n    }\n    if (timestamp_only)\n    {\n      if ((status = !timestamp))\n        fprintf(stderr, _(\"%s has no timestamp.\\n\"), ifname);\n      else if (identify_only)\n        printf(\"%10ld%10d %s\\n\", (long)timestamp, shot_order, ifname);\n      else\n      {\n        if (verbose)\n          fprintf(stderr, _(\"%s time set to %d.\\n\"), ifname, (int)timestamp);\n        ut.actime = ut.modtime = timestamp;\n        utime(ifname, &ut);\n      }\n      goto next;\n    }\n    write_fun = &CLASS write_ppm_tiff;\n    if (thumbnail_only)\n    {\n      if ((status = !thumb_offset))\n      {\n        fprintf(stderr, _(\"%s has no thumbnail.\\n\"), ifname);\n        goto next;\n      }\n      else if (thumb_load_raw)\n      {\n        load_raw = thumb_load_raw;\n        data_offset = thumb_offset;\n        height = thumb_height;\n        width = thumb_width;\n        filters = 0;\n        colors = 3;\n      }\n      else\n      {\n        fseek(ifp, thumb_offset, SEEK_SET);\n        write_fun = write_thumb;\n        goto thumbnail;\n      }\n    }\n    if (load_raw == &CLASS kodak_ycbcr_load_raw)\n    {\n      height += height & 1;\n      width += width & 1;\n    }\n\n    if (identify_only && verbose && make[0])\n    {\n      printf(_(\"\\nFilename: %s\\n\"), ifname);\n      printf(_(\"Timestamp: %s\"), ctime(&timestamp));\n      printf(_(\"Camera: %s %s\\n\"), make, model);\n      if (artist[0])\n        printf(_(\"Owner: %s\\n\"), artist);\n      if (dng_version)\n      {\n        printf(_(\"DNG Version: \"));\n        for (i = 24; i >= 0; i -= 8)\n          printf(\"%d%c\", dng_version >> i & 255, i ? '.' : '\\n');\n      }\n      printf(_(\"ISO speed: %d\\n\"), (int)iso_speed);\n      printf(_(\"Shutter: \"));\n      if (shutter > 0 && shutter < 1)\n        shutter = (printf(\"1/\"), 1 / shutter);\n      printf(_(\"%0.1f sec\\n\"), shutter);\n      printf(_(\"Aperture: f/%0.1f\\n\"), aperture);\n      printf(_(\"Focal length: %0.1f mm\\n\"), focal_len);\n      printf(_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\") : _(\"no\"));\n      printf(_(\"Number of raw images: %d\\n\"), is_raw);\n      if (pixel_aspect != 1)\n        printf(_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);\n      if (thumb_offset)\n        printf(_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);\n      printf(_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);\n    }\n    else if (!is_raw)\n      fprintf(stderr, _(\"Cannot decode file %s\\n\"), ifname);\n    if (!is_raw)\n      goto next;\n    shrink = filters && (half_size || (!identify_only && (threshold || aber[0] != 1 || aber[2] != 1)));\n    iheight = (height + shrink) >> shrink;\n    iwidth = (width + shrink) >> shrink;\n    if (identify_only)\n    {\n      if (verbose)\n      {\n        if (document_mode == 3)\n        {\n          top_margin = left_margin = fuji_width = 0;\n          height = raw_height;\n          width = raw_width;\n        }\n        iheight = (height + shrink) >> shrink;\n        iwidth = (width + shrink) >> shrink;\n        if (use_fuji_rotate)\n        {\n          if (fuji_width)\n          {\n            fuji_width = (fuji_width - 1 + shrink) >> shrink;\n            iwidth = fuji_width / sqrt(0.5);\n            iheight = (iheight - fuji_width) / sqrt(0.5);\n          }\n          else\n          {\n            if (pixel_aspect < 1)\n              iheight = iheight / pixel_aspect + 0.5;\n            if (pixel_aspect > 1)\n              iwidth = iwidth * pixel_aspect + 0.5;\n          }\n        }\n        if (flip & 4)\n          SWAP(iheight, iwidth);\n        printf(_(\"Image size:  %4d x %d\\n\"), width, height);\n        printf(_(\"Output size: %4d x %d\\n\"), iwidth, iheight);\n        printf(_(\"Raw colors: %d\"), colors);\n        if (filters)\n        {\n          int fhigh = 2, fwide = 2;\n          if ((filters ^ (filters >> 8)) & 0xff)\n            fhigh = 4;\n          if ((filters ^ (filters >> 16)) & 0xffff)\n            fhigh = 8;\n          if (filters == 1)\n            fhigh = fwide = 16;\n          if (filters == 9)\n            fhigh = fwide = 6;\n          printf(_(\"\\nFilter pattern: \"));\n          for (i = 0; i < fhigh; i++)\n            for (c = i && putchar('/') && 0; c < fwide; c++)\n              putchar(cdesc[fcol(i, c)]);\n        }\n        printf(_(\"\\nDaylight multipliers:\"));\n        FORCC printf(\" %f\", pre_mul[c]);\n        if (cam_mul[0] > 0)\n        {\n          printf(_(\"\\nCamera multipliers:\"));\n          FORC4 printf(\" %f\", cam_mul[c]);\n        }\n        putchar('\\n');\n      }\n      else\n        printf(_(\"%s is a %s %s image.\\n\"), ifname, make, model);\n    next:\n      fclose(ifp);\n      continue;\n    }\n    if (meta_length)\n    {\n      meta_data = (char *)malloc(meta_length);\n      merror(meta_data, \"main()\");\n    }\n    if (filters || colors == 1)\n    {\n      raw_image = (ushort *)calloc((raw_height + 7), raw_width * 2);\n      merror(raw_image, \"main()\");\n    }\n    else\n    {\n      image = (ushort(*)[4])calloc(iheight, iwidth * sizeof *image);\n      merror(image, \"main()\");\n    }\n    if (verbose)\n      fprintf(stderr, _(\"Loading %s %s image from %s ...\\n\"), make, model, ifname);\n    if (shot_select >= is_raw)\n      fprintf(stderr, _(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"), ifname, shot_select);\n    fseeko(ifp, data_offset, SEEK_SET);\n    if (raw_image && read_from_stdin)\n      fread(raw_image, 2, raw_height * raw_width, stdin);\n    else\n      (*load_raw)();\n    if (document_mode == 3)\n    {\n      top_margin = left_margin = fuji_width = 0;\n      height = raw_height;\n      width = raw_width;\n    }\n    iheight = (height + shrink) >> shrink;\n    iwidth = (width + shrink) >> shrink;\n    if (raw_image)\n    {\n      image = (ushort(*)[4])calloc(iheight, iwidth * sizeof *image);\n      merror(image, \"main()\");\n      crop_masked_pixels();\n      free(raw_image);\n    }\n    if (zero_is_bad)\n      remove_zeroes();\n    bad_pixels(bpfile);\n    if (dark_frame)\n      subtract(dark_frame);\n    quality = 2 + !fuji_width;\n    if (user_qual >= 0)\n      quality = user_qual;\n    i = cblack[3];\n    FORC3 if (i > cblack[c]) i = cblack[c];\n    FORC4 cblack[c] -= i;\n    black += i;\n    i = cblack[6];\n    FORC(cblack[4] * cblack[5])\n    if (i > cblack[6 + c])\n      i = cblack[6 + c];\n    FORC(cblack[4] * cblack[5])\n    cblack[6 + c] -= i;\n    black += i;\n    if (user_black >= 0)\n      black = user_black;\n    FORC4 cblack[c] += black;\n    if (user_sat > 0)\n      maximum = user_sat;\n#ifdef COLORCHECK\n    colorcheck();\n#endif\n    if (is_foveon)\n    {\n      if (document_mode || load_raw == &CLASS foveon_dp_load_raw)\n      {\n        for (i = 0; i < height * width * 4; i++)\n          if ((short)image[0][i] < 0)\n            image[0][i] = 0;\n      }\n      else\n        foveon_interpolate();\n    }\n    else if (document_mode < 2)\n      scale_colors();\n    pre_interpolate();\n    if (filters && !document_mode)\n    {\n      if (quality == 0)\n        lin_interpolate();\n      else if (quality == 1 || colors > 3)\n        vng_interpolate();\n      else if (quality == 2 && filters > 1000)\n        ppg_interpolate();\n      else if (filters == 9)\n        xtrans_interpolate(quality * 2 - 3);\n      else\n        ahd_interpolate();\n    }\n    if (mix_green)\n      for (colors = 3, i = 0; i < height * width; i++)\n        image[i][1] = (image[i][1] + image[i][3]) >> 1;\n    if (!is_foveon && colors == 3)\n      median_filter();\n    if (!is_foveon && highlight == 2)\n      blend_highlights();\n    if (!is_foveon && highlight > 2)\n      recover_highlights();\n    if (use_fuji_rotate)\n      fuji_rotate();\n#ifndef NO_LCMS\n    if (cam_profile)\n      apply_profile(cam_profile, out_profile);\n#endif\n    convert_to_rgb();\n    if (use_fuji_rotate)\n      stretch();\n  thumbnail:\n    if (write_fun == &CLASS jpeg_thumb)\n      write_ext = \".jpg\";\n    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)\n      write_ext = \".tiff\";\n    else\n      write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors * 5 - 5;\n    ofname = (char *)malloc(strlen(ifname) + 64);\n    merror(ofname, \"main()\");\n    if (write_to_stdout)\n      strcpy(ofname, _(\"standard output\"));\n    else\n    {\n      strcpy(ofname, ifname);\n      if ((cp = strrchr(ofname, '.')))\n        *cp = 0;\n      if (multi_out)\n        sprintf(ofname + strlen(ofname), \"_%0*d\", snprintf(0, 0, \"%d\", is_raw - 1), shot_select);\n      if (thumbnail_only)\n        strcat(ofname, \".thumb\");\n      strcat(ofname, write_ext);\n      ofp = fopen(ofname, \"wb\");\n      if (!ofp)\n      {\n        status = 1;\n        perror(ofname);\n        goto cleanup;\n      }\n    }\n    if (verbose)\n      fprintf(stderr, _(\"Writing data to %s ...\\n\"), ofname);\n    (*write_fun)();\n    fclose(ifp);\n    if (ofp != stdout)\n      fclose(ofp);\n  cleanup:\n    if (meta_data)\n      free(meta_data);\n    if (ofname)\n      free(ofname);\n    if (oprof)\n      free(oprof);\n    if (image)\n      free(image);\n    if (multi_out)\n    {\n      if (++shot_select < is_raw)\n        arg--;\n      else\n        shot_select = 0;\n    }\n  }\n  return status;\n}\n#endif\n", "/* \n  Copyright 2008-2016 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\nint CLASS fcol(int row, int col)\n{\n  static const char filter[16][16] = {\n      {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},\n      {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},\n      {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},\n      {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},\n      {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},\n      {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},\n      {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},\n      {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};\n\n  if (filters == 1)\n    return filter[(row + top_margin) & 15][(col + left_margin) & 15];\n  if (filters == 9)\n    return xtrans[(row + 6) % 6][(col + 6) % 6];\n  return FC(row, col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a, b) local_strnlen(a, b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n  int r = fp->read(buf, len, 1);\n  buf[len - 1] = 0;\n  return r;\n}\n#define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp(c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)\n\nushort CLASS sget2(uchar *s)\n{\n  if (order == 0x4949) /* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG 1\n#define AdobeDNG 2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)\n{\n  if ((a >> 4) > 9)\n    return 0;\n  else if ((a & 0x0f) > 9)\n    return 0;\n  else if ((b >> 4) > 9)\n    return 0;\n  else if ((b & 0x0f) > 9)\n    return 0;\n  else if ((c >> 4) > 9)\n    return 0;\n  else if ((c & 0x0f) > 9)\n    return 0;\n  else if ((d >> 4) > 9)\n    return 0;\n  else if ((d & 0x0f) > 9)\n    return 0;\n  else if ((e >> 4) > 9)\n    return 0;\n  else if ((e & 0x0f) > 9)\n    return 0;\n  else if ((f >> 4) > 9)\n    return 0;\n  else if ((f & 0x0f) > 9)\n    return 0;\n  return 1;\n}\n\nstatic ushort bcd2dec(uchar data)\n{\n  if ((data >> 4) > 9)\n    return 0;\n  else if ((data & 0x0f) > 9)\n    return 0;\n  else\n    return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] =\n    \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"\n    \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"\n    \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"\n    \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"\n    \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"\n    \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"\n    \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"\n    \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"\n    \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"\n    \"\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse\n{\n  if (order == 0x4d4d) /* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian... */\n    return s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = {0xff, 0xff};\n  fread(str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4(uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }\n\nfloat CLASS int_to_float(int i)\n{\n  union {\n    int i;\n    float f;\n  } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n\n  switch (type)\n  {\n  case 3:\n    return (unsigned short)get2();\n  case 4:\n    return (unsigned int)get4();\n  case 5:\n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8:\n    return (signed short)get2();\n  case 9:\n    return (signed int)get4();\n  case 10:\n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11:\n    return int_to_float(get4());\n  case 12:\n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts(ushort *pixel, int count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}\n\nvoid CLASS cubic_spline(const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);\n  if (!A)\n    return;\n  A[0] = (float *)(A + 2 * len);\n  for (i = 1; i < 2 * len; i++)\n    A[i] = A[0] + 2 * len * i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));\n  for (i = 0; i < len; i++)\n  {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len - 1; i > 0; i--)\n  {\n    b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);\n    d[i - 1] = x[i] - x[i - 1];\n  }\n  for (i = 1; i < len - 1; i++)\n  {\n    A[i][i] = 2 * (d[i - 1] + d[i]);\n    if (i > 1)\n    {\n      A[i][i - 1] = d[i - 1];\n      A[i - 1][i] = d[i - 1];\n    }\n    A[i][len - 1] = 6 * (b[i + 1] - b[i]);\n  }\n  for (i = 1; i < len - 2; i++)\n  {\n    float v = A[i + 1][i] / A[i][i];\n    for (j = 1; j <= len - 1; j++)\n      A[i + 1][j] -= v * A[i][j];\n  }\n  for (i = len - 2; i > 0; i--)\n  {\n    float acc = 0;\n    for (j = i; j <= len - 2; j++)\n      acc += A[i][j] * c[j];\n    c[i] = (A[i][len - 1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len - 1; j++)\n    {\n      if (x[j] <= x_out && x_out <= x[j + 1])\n      {\n        float v = x_out - x[j];\n        y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +\n                ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));\n  }\n  free(A);\n}\n\nvoid CLASS canon_600_fixed_wb(int temp)\n{\n  static const short mul[4][5] = {\n      {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};\n  int lo, hi, i;\n  float frac = 0;\n\n  for (lo = 4; --lo;)\n    if (*mul[lo] <= temp)\n      break;\n  for (hi = 0; hi < 3; hi++)\n    if (*mul[hi] >= temp)\n      break;\n  if (lo != hi)\n    frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i = 1; i < 5; i++)\n    pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color(int ratio[2], int mar)\n{\n  int clipped = 0, target, miss;\n\n  if (flash_used)\n  {\n    if (ratio[1] < -104)\n    {\n      ratio[1] = -104;\n      clipped = 1;\n    }\n    if (ratio[1] > 12)\n    {\n      ratio[1] = 12;\n      clipped = 1;\n    }\n  }\n  else\n  {\n    if (ratio[1] < -264 || ratio[1] > 461)\n      return 2;\n    if (ratio[1] < -50)\n    {\n      ratio[1] = -50;\n      clipped = 1;\n    }\n    if (ratio[1] > 307)\n    {\n      ratio[1] = 307;\n      clipped = 1;\n    }\n  }\n  target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)\n    return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar * 4)\n    return 2;\n  if (miss < -20)\n    miss = -20;\n  if (miss > mar)\n    miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = {0, 0};\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset(&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if (i < 10)\n    mar = 150;\n  else if (i > 12)\n    mar = 20;\n  else\n    mar = 280 - 20 * i;\n  if (flash_used)\n    mar = 80;\n  for (row = 14; row < height - 14; row += 4)\n    for (col = 10; col < width; col += 2)\n    {\n      for (i = 0; i < 8; i++)\n        test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));\n      for (i = 0; i < 8; i++)\n        if (test[i] < 150 || test[i] > 1500)\n          goto next;\n      for (i = 0; i < 4; i++)\n        if (abs(test[i] - test[i + 4]) > 50)\n          goto next;\n      for (i = 0; i < 2; i++)\n      {\n        for (j = 0; j < 4; j += 2)\n          ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];\n        stat[i] = canon_600_color(ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1)\n        goto next;\n      for (i = 0; i < 2; i++)\n        if (stat[i])\n          for (j = 0; j < 2; j++)\n            test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;\n      for (i = 0; i < 8; i++)\n        total[st][i] += test[i];\n      count[st]++;\n    next:;\n    }\n  if (count[0] | count[1])\n  {\n    st = count[0] * 200 < count[1];\n    for (i = 0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},\n                                     {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},\n                                     {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},\n                                     {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};\n  int t = 0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789)\n    t = 1;\n  if (mc > 1.28 && mc <= 2)\n  {\n    if (yc < 0.8789)\n      t = 3;\n    else if (yc <= 2)\n      t = 4;\n  }\n  if (flash_used)\n    t = 5;\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow = row = 0; irow < height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(data, 1, 1120, ifp) < 1120)\n      derror();\n    pix = raw_image + row * raw_width;\n    for (dp = data; dp < data + 1120; dp += 10, pix += 8)\n    {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6);\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1] & 3);\n      pix[4] = (dp[5] << 2) + (dp[9] & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6);\n    }\n    if ((row += 2) > height)\n      row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n    {\n      if ((val = BAYER(row, col) - black) < 0)\n        val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row, col) = val;\n    }\n  }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row = 0; row < 100; row++)\n  {\n    fseek(ifp, row * 3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15)\n      return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n, 0)\n#define gethuff(h) getbithuff(*h, h + 1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *CLASS make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }\n\nvoid CLASS crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,\n       0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,\n       0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,\n       0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,\n       0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,\n       0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,\n       0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,\n       0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,\n       0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,\n       0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,\n       0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,\n       0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,\n       0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,\n       0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,\n       0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,\n       0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,\n       0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row += 8)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free(huff[c]);\n}\n\nint CLASS ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint CLASS ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *CLASS ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp(failure, 3);\n#endif\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  ljpeg_end(&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n#endif\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n#endif\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))\n#endif\n      for (; rp < ip[0]; rp += 4)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||\n            unique_id == 0x80000287)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select)\n    (*rp)++;\n  if (raw_image)\n  {\n    if (row < raw_height && col < raw_width)\n      RAW(row, col) = curve[**rp];\n    *rp += tiff_samples;\n  }\n  else\n  {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n    image[row * width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select)\n    (*rp)--;\n}\n\nvoid CLASS ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,\n                                   40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,\n                                   29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n                                   47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n    if (!ljpeg_start(&jh, 0))\n      break;\n    jwide = jh.wide;\n    if (filters)\n      jwide *= jh.clrs;\n    jwide /= MIN(is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      switch (jh.algo)\n      {\n      case 0xc1:\n        jh.vpred[0] = 16384;\n        getbits(-1);\n        for (jrow = 0; jrow + 7 < jh.high; jrow += 8)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)\n          {\n            ljpeg_idct(&jh);\n            rp = jh.idct;\n            row = trow + jcol / tile_width + jrow * 2;\n            col = tcol + jcol % tile_width;\n            for (i = 0; i < 16; i += 2)\n              for (j = 0; j < 8; j++)\n                adobe_copy_pixel(row + i, col + j, &rp);\n          }\n        }\n        break;\n      case 0xc3:\n        for (row = col = jrow = 0; jrow < jh.high; jrow++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          rp = ljpeg_row(jrow, &jh);\n          for (jcol = 0; jcol < jwide; jcol++)\n          {\n            adobe_copy_pixel(trow + row, tcol + col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      ljpeg_end(&jh);\n      throw;\n    }\n#endif\n    fseek(ifp, save + 4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end(&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);\n  merror(pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (tiff_bps == 16)\n        read_shorts(pixel, raw_width * tiff_samples);\n      else\n      {\n        getbits(-1);\n        for (col = 0; col < raw_width * tiff_samples; col++)\n          pixel[col] = getbits(tiff_bps);\n      }\n      for (rp = pixel, col = 0; col < raw_width; col++)\n        adobe_copy_pixel(row, col, &rp);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width * 3 * tiff_bps / 8;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for (int row = 0; row < raw_height; row++)\n  {\n    int red = fread(buf, 1, bufsize, ifp);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (tiff_bps <= 8)\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    else\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n  }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0, 0, 0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0, 0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0)\n  {\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n  while (curve[max - 2] == curve[max - 1])\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (min = row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n#endif\n  free(huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = {0x00, 0x55, 0xaa, 0xff};\n\n  memset(histo, 0, sizeof histo);\n  fseek(ifp, -2000, SEEK_END);\n  for (i = 0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i = 0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek(ifp, 0, SEEK_SET);\n  for (i = 0; i < 1024; i++)\n  {\n    fread(t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct\n  {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n      {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};\n\n  fseek(ifp, 3072, SEEK_SET);\n  fread(dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits)\n    {\n      strcpy(make, table[i].t_make);\n      strcpy(model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"ppm_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread(thumb, 1, thumb_length, ifp);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *)calloc(thumb_length, 2);\n  merror(thumb, \"rollei_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts(thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n  {\n    putc(thumb[i] << 3, ofp);\n    putc(thumb[i] >> 5 << 2, ofp);\n    putc(thumb[i] >> 11 << 3, ofp);\n  }\n  free(thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }\n\nvoid CLASS phase_one_flat_field(int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts(head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0)\n    return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *)calloc(nc * wide, sizeof *mrow);\n  merror(mrow, \"phase_one_flat_field()\");\n  for (y = 0; y < high; y++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x = 0; x < wide; x++)\n      for (c = 0; c < nc; c += 2)\n      {\n        num = is_float ? getreal(11) : get2() / 32768.0;\n        if (y == 0)\n          mrow[c * wide + x] = num;\n        else\n          mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];\n      }\n    if (y == 0)\n      continue;\n    rend = head[1] + y * head[5];\n    for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)\n    {\n      for (x = 1; x < wide; x++)\n      {\n        for (c = 0; c < nc; c += 2)\n        {\n          mult[c] = mrow[c * wide + x - 1];\n          mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];\n        }\n        cend = head[0] + x * head[4];\n        for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)\n        {\n          c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;\n          if (!(c & 1))\n          {\n            c = RAW(row, col) * mult[c];\n            RAW(row, col) = LIM(c, 0, 65535);\n          }\n          for (c = 0; c < nc; c += 2)\n            mult[c] += mult[c + 1];\n        }\n      }\n      for (x = 0; x < wide; x++)\n        for (c = 0; c < nc; c += 2)\n          mrow[c * wide + x] += mrow[(c + 1) * wide + x];\n    }\n  }\n  free(mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {{-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n                                               {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n  if (half_size || !meta_length)\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Phase One correction...\\n\"));\n#endif\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    while (entries--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x419)\n      { /* Polynomial curve */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(11);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x41a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(11);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n            for (row = 0; row < raw_height; row++)\n              if (FC(row - top_margin, col - left_margin) == 1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;\n              }\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += raw(row + dir[i][0], col + dir[i][1]);\n            RAW(row, col) = (sum + 4) >> 3;\n          }\n        }\n      }\n      else if (tag == 0x401)\n      { /* All-color flat fields */\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x416 || tag == 0x410)\n      {\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x40b)\n      { /* Red+blue flat field */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x41f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 16; i++)\n              lc[qr][qc][i] = get4();\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x41e && !qmult_applied)\n      { /* Quadrant multipliers */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(11);\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x431 && !qmult_applied)\n      { /* Quadrant combined */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      merror(yval[0], \"phase_one_correct()\");\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(11);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek(ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555 : 0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");\n    if (ph1.black_col)\n    {\n      fseek(ifp, ph1.black_col, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);\n    }\n    if (ph1.black_row)\n    {\n      fseek(ifp, ph1.black_row, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);\n    }\n  }\n#endif\n  fseek(ifp, data_offset, SEEK_SET);\n  read_shorts(raw_image, raw_width * raw_height);\n  if (ph1.format)\n    for (i = 0; i < raw_width * raw_height; i += 2)\n    {\n      a = raw_image[i + 0] ^ akey;\n      b = raw_image[i + 1] ^ bkey;\n      raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n, 0)\n#define ph1_huff(h) ph1_bithuff(*h, h + 1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short(*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);\n  merror(pixel, \"phase_one_load_raw_c()\");\n  offset = (int *)(pixel + raw_width);\n  fseek(ifp, strip_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short(*)[2])(offset + raw_height);\n  fseek(ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n    read_shorts((ushort *)c_black[0], raw_height * 2);\n  r_black = c_black + raw_height;\n  fseek(ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n    read_shorts((ushort *)r_black[0], raw_width * 2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));\n  }\n#endif\n\n  for (i = 0; i < 256; i++)\n    curve[i] = i * i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + offset[row], SEEK_SET);\n      ph1_bits(-1);\n      pred[0] = pred[1] = 0;\n      for (col = 0; col < raw_width; col++)\n      {\n        if (col >= (raw_width & -8))\n          len[0] = len[1] = 14;\n        else if ((col & 7) == 0)\n          for (i = 0; i < 2; i++)\n          {\n            for (j = 0; j < 5 && !ph1_bits(1); j++)\n              ;\n            if (j--)\n              len[i] = length[j * 2 + ph1_bits(1)];\n          }\n        if ((i = len[col & 1]) == 14)\n          pixel[col] = pred[col & 1] = ph1_bits(16);\n        else\n          pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n        if (pred[col & 1] >> 16)\n          derror();\n        if (ph1.format == 5 && pixel[col] < 256)\n          pixel[col] = curve[pixel[col]];\n      }\n#ifndef LIBRAW_LIBRARY_BUILD\n      for (col = 0; col < raw_width; col++)\n      {\n        int shift = ph1.format == 8 ? 0 : 2;\n        i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +\n            r_black[col][row >= ph1.split_row];\n        if (i > 0)\n          RAW(row, col) = i;\n      }\n#else\n    if (ph1.format == 8)\n      memmove(&RAW(row, 0), &pixel[0], raw_width * 2);\n    else\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = pixel[col] << 2;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    back[4] = (int *)calloc(raw_width, 3 * sizeof **back);\n    merror(back[4], \"hasselblad_load_raw()\");\n    FORC3 back[c] = back[4] + c * raw_width;\n    cblack[6] >>= sh = tiff_samples > 1;\n    shot = LIM(shot_select, 1, tiff_samples) - 1;\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      FORC4 back[(c + 3) & 3] = back[c];\n      for (col = 0; col < raw_width; col += 2)\n      {\n        for (s = 0; s < tiff_samples * 2; s += 2)\n        {\n          FORC(2) len[c] = ph1_huff(jh.huff[0]);\n          FORC(2)\n          {\n            diff[s + c] = ph1_bits(len[c]);\n            if ((diff[s + c] & (1 << (len[c] - 1))) == 0)\n              diff[s + c] -= (1 << len[c]) - 1;\n            if (diff[s + c] == 65535)\n              diff[s + c] = -32768;\n          }\n        }\n        for (s = col; s < col + 2; s++)\n        {\n          pred = 0x8000 + load_flags;\n          if (col)\n            pred = back[2][s - 2];\n          if (col && row > 1)\n            switch (jh.psv)\n            {\n            case 11:\n              pred += back[0][s] / 2 - back[0][s - 2] / 2;\n              break;\n            }\n          f = (row & 1) * 3 ^ ((col + s) & 1);\n          FORC(tiff_samples)\n          {\n            pred += diff[(s & 1) * tiff_samples + c];\n            upix = pred >> sh & 0xffff;\n            if (raw_image && c == shot)\n              RAW(row, s) = upix;\n            if (image)\n            {\n              urow = row - top_margin + (c & 1);\n              ucol = col - left_margin - ((c >> 1) & 1);\n              ip = &image[urow * width + ucol][f];\n              if (urow < height && ucol < width)\n                *ip = c < 4 ? upix : (*ip + upix) >> 1;\n            }\n          }\n          back[2][s] = pred;\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(back[4]);\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  free(back[4]);\n  ljpeg_end(&jh);\n  if (image)\n    mix_green = 1;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel = 0;\n  unsigned tile = 0, r, c, row, col;\n\n  if (!filters)\n  {\n    pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n    merror(pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    FORC(tiff_samples)\n    for (r = 0; r < raw_height; r++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (r % tile_length == 0)\n      {\n        fseek(ifp, data_offset + 4 * tile++, SEEK_SET);\n        fseek(ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select)\n        continue;\n      if (filters)\n        pixel = raw_image + r * raw_width;\n      read_shorts(pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n        for (col = 0; col < width; col++)\n          image[row * width + col][c] = pixel[col + left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (!filters)\n      free(pixel);\n    throw;\n  }\n#endif\n  if (!filters)\n  {\n    maximum = 0xffff;\n    raw_color = 1;\n    free(pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  read_shorts(raw_image, raw_width * raw_height);\n  if (maximum < 0xffff)\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < raw_width; col++)\n        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n            (unsigned)(col - left_margin) < width)\n          derror();\n    }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \"imacon_full_load_raw\");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf = 0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height + 1) >> 1;\n  for (irow = 0; irow < raw_height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)\n    {\n      if (vbits = 0, tiff_compress)\n        fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);\n      else\n      {\n        fseek(ifp, 0, SEEK_END);\n        fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col = 0; col < raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n      RAW(row, col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)\n        derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom()\n{\n\n  /* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct\n  {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek(ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread(&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616; /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order)\n  {\n  case 0: /* RGGB */\n    filters = 0x94949494;\n    break;\n  case 1: /* GBRG */\n    filters = 0x49494949;\n    break;\n  case 3: /* GRBG */\n    filters = 0x61616161;\n    break;\n  }\n}\n\nvoid CLASS broadcom_load_raw()\n{\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *)malloc(raw_stride * 2);\n  merror(data, \"broadcom_load_raw()\");\n\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)\n      derror();\n    FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n#endif\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf = 0;\n\n  bwide = (raw_width + 5) / 6 << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_loose_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)\n    {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];\n      FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;\n    }\n  }\n  free(data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n#endif\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#else\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = get4();\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits(int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits)\n    return vbits = 0;\n  if (!vbits)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},\n                                    {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,\n      23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,\n      46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,\n      69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,\n      101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,\n      149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,\n      197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,\n      361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,\n      457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,\n      631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,\n      878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))\n\n#define FORYX                                                                                                          \\\n  for (y = 1; y < 3; y++)                                                                                              \\\n    for (x = col + 1; x >= col; x--)\n\n#define PREDICTOR                                                                                                      \\\n  (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)\n\n#ifdef __GNUC__\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n#pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n#endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }\n  for (i = 0; i < height * width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread(jpeg_buffer, 1, 4096, ifp);\n  swab(jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header(&cinfo, TRUE);\n  jpeg_start_decompress(&cinfo);\n  if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n  {\n    fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress(&cinfo);\n    longjmp(failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines(&cinfo, buf, 1);\n    pixel = (JSAMPLE(*)[3])buf[0];\n    for (col = 0; col < width; col += 2)\n    {\n      RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n      RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n      RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n      RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n    }\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf, \"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);\n  jpeg_create_decompress(&cinfo);\n  merror(pixel_buf, \"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf, data_size, 1, ifp);\n  swab((char *)jpg_buf, (char *)jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf;\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    free(pixel_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  unsigned sorder = order, ntags, opcode, deg, i, j, c;\n  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset)\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--)\n    {\n      opcode = get4();\n      get4();\n      get4();\n      if (opcode != 8)\n      {\n        fseek(ifp, get4(), SEEK_CUR);\n        continue;\n      }\n      fseek(ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2)\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8)\n        break;\n      for (i = 0; i <= deg && i < 9; i++)\n        coeff[i] = getreal(12);\n      for (i = 0; i < 256; i++)\n      {\n        for (tot = j = 0; j <= deg; j++)\n          tot += coeff[j] * pow(i / 255.0, (int)j);\n        cur[c][i] = tot * 0xffff;\n      }\n    }\n    order = sorder;\n  }\n  else\n  {\n    gamma_curve(1 / 2.4, 12.92, 1, 255);\n    FORC3 memcpy(cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  while (trow < raw_height)\n  {\n    fseek(ifp, save += 4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n#else\n    jpeg_stdio_src(&cinfo, ifp);\n#endif\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        jpeg_read_scanlines(&cinfo, buf, 1);\n        pixel = (JSAMPLE(*)[3])buf[0];\n        for (col = 0; col < cinfo.output_width && tcol + col < width; col++)\n        {\n          FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw;\n    }\n#endif\n    jpeg_abort_decompress(&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = {162, 192, 187, 92};\n  static const int add[4] = {0, 636, 424, 212};\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 848, ifp) < 848)\n      derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col = 0; col < width; col++)\n      RAW(row, col) = (ushort)pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, 1, raw_width, ifp) < raw_width)\n        derror();\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = curve[pixel[col]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] = {\n      {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n      {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder(kodak_tree[c]);\n  ns = (raw_height + 63) >> 5;\n  pixel = (uchar *)malloc(raw_width * 32 + ns * 4);\n  merror(pixel, \"kodak_262_load_raw()\");\n  strip = (int *)(pixel + raw_width * 32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if ((row & 31) == 0)\n      {\n        fseek(ifp, strip[row >> 5], SEEK_SET);\n        getbits(-1);\n        pi = 0;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        chess = (row + col) & 1;\n        pi1 = chess ? pi - 2 : pi - raw_width - 1;\n        pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;\n        if (col <= chess)\n          pi1 = -1;\n        if (pi1 < 0)\n          pi1 = pi2;\n        if (pi2 < 0)\n          pi2 = pi1;\n        if (pi1 < 0 && col > 1)\n          pi1 = pi2 = pi - 2;\n        pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n        pixel[pi] = val = pred + ljpeg_diff(huff[chess]);\n        if (val >> 8)\n          derror();\n        val = curve[pixel[pi++]];\n        RAW(row, col) = val;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  FORC(2) free(huff[c]);\n}\n\nint CLASS kodak_65000_decode(short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf = 0;\n  int save, bits = 0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i = 0; i < bsize; i += 2)\n  {\n    c = fgetc(ifp);\n    if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)\n    {\n      fseek(ifp, save, SEEK_SET);\n      for (i = 0; i < bsize; i += 8)\n      {\n        read_shorts(raw, 6);\n        out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n        out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n        for (j = 0; j < 6; j++)\n          out[i + 2 + j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4)\n  {\n    bitbuf = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i = 0; i < bsize; i++)\n  {\n    len = blen[i];\n    if (bits < len)\n    {\n      for (j = 0; j < 32; j += 8)\n        bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16 - len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len - 1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      pred[0] = pred[1] = 0;\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len);\n      for (i = 0; i < len; i++)\n        if ((RAW(row, col + i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])]) >> 12)\n          derror();\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt(unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start)\n  {\n    for (p = 0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;\n    for (p = 4; p < 127; p++)\n      pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;\n    for (p = 0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n  {\n    *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];\n    p++;\n  }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,\n                                 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n#ifdef LIBRAW_LIBRARY_BUILD\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit = 30, i = 0; i < 16; i++)\n        if (i == imax)\n          pix[i] = max;\n        else if (i == imin)\n          pix[i] = min;\n        else\n        {\n          pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n          if (pix[i] > 0x7ff)\n            pix[i] = 0x7ff;\n          bit += 7;\n        }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr\n                                ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)\n                                : 0;\n          }\n        }\n        else\n        {\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        }\n#else\n      for (i = 0; i < 16; i++, col += 2)\n        RAW(row, col) = curve[pix[i] << 1] >> 2;\n#endif\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n#endif\n  free(data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +\n                            (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,\n                                 0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        pred =\n            (pmode == 7 || row < 2)\n                ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment(unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {3, 3, 0, 0, 63, 47, 31, 15, 0}};\n  int low, high = 0xff, carry = 0, nbits = 8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[] = {0, 0};\n  ushort data = 0, range = 0;\n\n  fseek(ifp, seg[0][1] + 1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width * raw_height)\n    seg[1][0] = raw_width * raw_height;\n  for (pix = seg[0][0]; pix < seg[1][0]; pix++)\n  {\n    for (s = 0; s < 3; s++)\n    {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n        carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;\n      while (--nbits >= 0)\n        if ((data >> nbits & 0xff) == 0xff)\n          break;\n      if (nbits > 0)\n        data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |\n               ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0)\n      {\n        data += getbits(1);\n        carry = nbits - 8;\n      }\n      count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin = 0; hist[s][bin + 5] > count; bin++)\n        ;\n      low = hist[s][bin + 5] * (high >> 4) >> 2;\n      if (bin)\n        high = hist[s][bin + 4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits = 0; high << nbits < 128; nbits++)\n        ;\n      range = (range + low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3])\n      {\n        next = (next + 1) & hist[s][0];\n        hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;\n        hist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)\n      {\n        if (bin < hist[s][1])\n          for (i = bin; i < hist[s][1]; i++)\n            hist[s][i + 5]--;\n        else if (next <= bin)\n          for (i = hist[s][1]; i < bin; i++)\n            hist[s][i + 5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (pix >= raw_width * raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width))\n      pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek(ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment(seg, 0);\n}\n\nint CLASS median4(int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i = 1; i < 4; i++)\n  {\n    sum += p[i];\n    if (min > p[i])\n      min = p[i];\n    if (max < p[i])\n      max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes(int holes)\n{\n  int row, col, val[4];\n\n  for (row = 2; row < height - 2; row++)\n  {\n    if (!HOLE(row))\n      continue;\n    for (col = 1; col < width - 1; col += 4)\n    {\n      val[0] = RAW(row - 1, col - 1);\n      val[1] = RAW(row - 1, col + 1);\n      val[2] = RAW(row + 1, col - 1);\n      val[3] = RAW(row + 1, col + 1);\n      RAW(row, col) = median4(val);\n    }\n    for (col = 2; col < width - 2; col += 4)\n      if (HOLE(row - 2) || HOLE(row + 2))\n        RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;\n      else\n      {\n        val[0] = RAW(row, col - 2);\n        val[1] = RAW(row, col + 2);\n        val[2] = RAW(row - 2, col);\n        val[3] = RAW(row + 2, col);\n        RAW(row, col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek(ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar)fgetc(ifp);\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < nseg * 2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);\n  fseek(ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek(ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i = 0; i < nseg; i++)\n    smal_decode_segment(seg + i, holes);\n  if (holes)\n    fill_holes(holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen(ifname, \"rb\");\n#else\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg)\n    longjmp(failure, 3);\n#else\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n#endif\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try\n  {\n#endif\n    FORC4\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n#endif\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n      r,\n      raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;\n#else\n      c,\n      m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width)\n  {\n    for (row = 0; row < raw_height - top_margin * 2; row++)\n    {\n      for (col = 0; col < fuji_width << !fuji_layout; col++)\n      {\n        if (fuji_layout)\n        {\n          r = fuji_width - 1 - col + (row >> 1);\n          c = col + ((row + 1) >> 1);\n        }\n        else\n        {\n          r = fuji_width - 1 + row - (col >> 1);\n          c = row + ((col + 1) >> 1);\n        }\n        if (r < height && c < width)\n          BAYER(r, c) = RAW(row + top_margin, col + left_margin);\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < height; row++)\n      for (col = 0; col < width; col++)\n        BAYER2(row, col) = RAW(row + top_margin, col + left_margin);\n  }\n#endif\n  if (mask[0][3] > 0)\n    goto mask_set;\n  if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)\n  {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||\n      (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||\n      (load_raw == &CLASS packed_load_raw && (load_flags & 32)))\n  {\n  sides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin + height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin + width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset(mblack, 0, sizeof mblack);\n  for (zero = m = 0; m < 8; m++)\n    for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)\n      for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)\n      {\n        c = FC(row - top_margin, col - left_margin);\n        mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];\n        mblack[4 + c]++;\n        zero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width)\n  {\n    black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  }\n  else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n  {\n    FORC4 cblack[c] = mblack[c] / mblack[4 + c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);\n#endif\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      if (BAYER(row, col) == 0)\n      {\n        tot = n = 0;\n        for (r = row - 2; r <= row + 2; r++)\n          for (c = col - 2; c <= col + 2; c++)\n            if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))\n              tot += (n++, BAYER(r, c));\n        if (n)\n          BAYER(row, col) = tot / n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);\n#endif\n}\n\nstatic const uchar xlat[2][256] = {\n    {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,\n     0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,\n     0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,\n     0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,\n     0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,\n     0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,\n     0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,\n     0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,\n     0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,\n     0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,\n     0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,\n     0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,\n     0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,\n     0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},\n    {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,\n     0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,\n     0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,\n     0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,\n     0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,\n     0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,\n     0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,\n     0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,\n     0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,\n     0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,\n     0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,\n     0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,\n     0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,\n     0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};\n\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2] = {0, 0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)\n  {\n    for (i = 0; i < 48; i++)\n    {\n      g[2] = (bnd[0] + bnd[1]) / 2;\n      if (g[0])\n        bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];\n      else\n        bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0])\n      g[4] = g[2] * (1 / g[0] - 1);\n  }\n  if (g[0])\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;\n  else\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;\n  if (!mode--)\n  {\n    memcpy(gamm, g, sizeof gamm);\n    return;\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    curve[i] = 0xffff;\n    if ((r = (double)i / imax) < 1)\n      curve[i] = 0x10000 *\n                 (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))\n                       : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < 6; j++)\n      work[i][j] = j == i + 3;\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < size; k++)\n        work[i][j] += in[k][i] * in[k][j];\n  }\n  for (i = 0; i < 3; i++)\n  {\n    num = work[i][i];\n    for (j = 0; j < 6; j++)\n      work[i][j] /= num;\n    for (k = 0; k < 3; k++)\n    {\n      if (k == i)\n        continue;\n      num = work[k][i];\n      for (j = 0; j < 6; j++)\n        work[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i = 0; i < size; i++)\n    for (j = 0; j < 3; j++)\n      for (out[i][j] = k = 0; k < 3; k++)\n        out[i][j] += work[j][k + 3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i = 0; i < colors; i++) /* Multiply out XYZ colorspace */\n    for (j = 0; j < 3; j++)\n      for (cam_rgb[i][j] = k = 0; k < 3; k++)\n        cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i = 0; i < colors; i++)\n  {                               /* Normalize cam_rgb so that */\n    for (num = j = 0; j < 3; j++) /* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if (num > 0.00001)\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] /= num;\n      pre_mul[i] = 1 / num;\n    }\n    else\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] = 0.0;\n      pre_mul[i] = 1.0;\n    }\n  }\n  pseudoinverse(cam_rgb, inverse, colors);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n  // Coordinates of the GretagMacbeth ColorChecker squares\n  // width, height, 1st_column, 1st_row\n  int cut[NSQ][4];                                             // you must set these\n                                                               // ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin\n                                         {0.377, 0.345, 35.8}, // Light Skin\n                                         {0.247, 0.251, 19.3}, // Blue Sky\n                                         {0.337, 0.422, 13.3}, // Foliage\n                                         {0.265, 0.240, 24.3}, // Blue Flower\n                                         {0.261, 0.343, 43.1}, // Bluish Green\n                                         {0.506, 0.407, 30.1}, // Orange\n                                         {0.211, 0.175, 12.0}, // Purplish Blue\n                                         {0.453, 0.306, 19.8}, // Moderate Red\n                                         {0.285, 0.202, 6.6},  // Purple\n                                         {0.380, 0.489, 44.3}, // Yellow Green\n                                         {0.473, 0.438, 43.1}, // Orange Yellow\n                                         {0.187, 0.129, 6.1},  // Blue\n                                         {0.305, 0.478, 23.4}, // Green\n                                         {0.539, 0.313, 12.0}, // Red\n                                         {0.448, 0.470, 59.1}, // Yellow\n                                         {0.364, 0.233, 19.8}, // Magenta\n                                         {0.196, 0.252, 19.8}, // Cyan\n                                         {0.310, 0.316, 90.0}, // White\n                                         {0.310, 0.316, 59.1}, // Neutral 8\n                                         {0.310, 0.316, 36.2}, // Neutral 6.5\n                                         {0.310, 0.316, 19.8}, // Neutral 5\n                                         {0.310, 0.316, 9.0},  // Neutral 3.5\n                                         {0.310, 0.316, 3.1}}; // Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset(gmb_cam, 0, sizeof gmb_cam);\n  for (sq = 0; sq < NSQ; sq++)\n  {\n    FORCC count[c] = 0;\n    for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)\n      for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)\n      {\n        c = FC(row, col);\n        if (c >= colors)\n          c -= 2;\n        gmb_cam[sq][c] += BAYER2(row, col);\n        BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;\n        count[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse(gmb_xyz, inverse, NSQ);\n  for (pass = 0; pass < 2; pass++)\n  {\n    for (raw_color = i = 0; i < colors; i++)\n      for (j = 0; j < 3; j++)\n        for (cam_xyz[i][j] = k = 0; k < NSQ; k++)\n          cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff(rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq = 0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose)\n  {\n    printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));\n    puts(\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n  FORC(nc)\n  { /* denoise R,G1,B,G3 individually */\n    for (i = 0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass = lev = 0; lev < 5; lev++)\n    {\n      lpass = size * ((lev & 1) + 1);\n      for (row = 0; row < iheight; row++)\n      {\n        hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n        for (col = 0; col < iwidth; col++)\n          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n      }\n      for (col = 0; col < iwidth; col++)\n      {\n        hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n        for (row = 0; row < iheight; row++)\n          fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i = 0; i < size; i++)\n      {\n        fimg[hpass + i] -= fimg[lpass + i];\n        if (fimg[hpass + i] < -thold)\n          fimg[hpass + i] += thold;\n        else if (fimg[hpass + i] > thold)\n          fimg[hpass + i] -= thold;\n        else\n          fimg[hpass + i] = 0;\n        if (hpass)\n          fimg[i] += fimg[hpass + i];\n      }\n      hpass = lpass;\n    }\n    for (i = 0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n  }\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)\n#endif\n  {\n    temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);\n    FORC(nc)\n    { /* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass = lev = 0; lev < 5; lev++)\n      {\n        lpass = size * ((lev & 1) + 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (row = 0; row < iheight; row++)\n        {\n          hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n          for (col = 0; col < iwidth; col++)\n            fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n        }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (col = 0; col < iwidth; col++)\n        {\n          hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n          for (row = 0; row < iheight; row++)\n            fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n        }\n        thold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (i = 0; i < size; i++)\n        {\n          fimg[hpass + i] -= fimg[lpass + i];\n          if (fimg[hpass + i] < -thold)\n            fimg[hpass + i] += thold;\n          else if (fimg[hpass + i] > thold)\n            fimg[hpass + i] -= thold;\n          else\n            fimg[hpass + i] = 0;\n          if (hpass)\n            fimg[i] += fimg[hpass + i];\n        }\n        hpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n  /* the following loops are hard to parallize, no idea yes,\n   * problem is wlast which is carrying dependency\n   * second part should be easyer, but did not yet get it right.\n   */\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i, j;\n  double m1, m2, c1, c2;\n  int o1_1, o1_2, o1_3, o1_4;\n  int o2_1, o2_2, o2_3, o2_4;\n  ushort(*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if (half_size || shrink)\n    return;\n  if (FC(oj, oi) != 3)\n    oj++;\n  if (FC(oj, oi) != 3)\n    oi++;\n  if (FC(oj, oi) != 3)\n    oj--;\n\n  img = (ushort(*)[4])calloc(height * width, sizeof *image);\n  merror(img, \"green_matching()\");\n  memcpy(img, image, height * width * sizeof *image);\n\n  for (j = oj; j < height - margin; j += 2)\n    for (i = oi; i < width - margin; i += 2)\n    {\n      o1_1 = img[(j - 1) * width + i - 1][1];\n      o1_2 = img[(j - 1) * width + i + 1][1];\n      o1_3 = img[(j + 1) * width + i - 1][1];\n      o1_4 = img[(j + 1) * width + i + 1][1];\n      o2_1 = img[(j - 2) * width + i][3];\n      o2_2 = img[(j + 2) * width + i][3];\n      o2_3 = img[j * width + i - 2][3];\n      o2_4 = img[j * width + i + 2][3];\n\n      m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;\n      m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;\n\n      c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +\n            abs(o1_2 - o1_4)) /\n           6.0;\n      c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +\n            abs(o2_2 - o2_4)) /\n           6.0;\n      if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))\n      {\n        f = image[j * width + i][3] * m1 / m2;\n        image[j * width + i][3] = f > 0xffff ? 0xffff : f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img = 0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);\n#endif\n\n  if (user_mul[0])\n    memcpy(pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))\n  {\n    memset(dsum, 0, sizeof dsum);\n    bottom = MIN(greybox[1] + greybox[3], height);\n    right = MIN(greybox[0] + greybox[2], width);\n    for (row = greybox[1]; row < bottom; row += 8)\n      for (col = greybox[0]; col < right; col += 8)\n      {\n        memset(sum, 0, sizeof sum);\n        for (y = row; y < row + 8 && y < bottom; y++)\n          for (x = col; x < col + 8 && x < right; x++)\n            FORC4\n            {\n              if (filters)\n              {\n                c = fcol(y, x);\n                val = BAYER2(y, x);\n              }\n              else\n                val = image[y * width + x][c];\n              if (val > maximum - 25)\n                goto skip_block;\n              if ((val -= cblack[c]) < 0)\n                val = 0;\n              sum[c] += val;\n              sum[c + 4]++;\n              if (filters)\n                break;\n            }\n        FORC(8) dsum[c] += sum[c];\n      skip_block:;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1)\n  {\n    memset(sum, 0, sizeof sum);\n    for (row = 0; row < 8; row++)\n      for (col = 0; col < 8; col++)\n      {\n        c = FC(row, col);\n        if ((val = white[row][col] - cblack[c]) > 0)\n          sum[c] += val;\n        sum[c + 4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (load_raw == &LibRaw::nikon_load_sraw)\n    {\n      // Nikon sRAW: camera WB already applied:\n      pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;\n    }\n    else\n#endif\n        if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy(pre_mul, cam_mul, sizeof pre_mul);\n    else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n      fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&\n      cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)\n  {\n    for (c = 0; c < 3; c++)\n      pre_mul[c] /= cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0)\n    pre_mul[1] = 1;\n  if (pre_mul[3] == 0)\n    pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold)\n    wavelet_denoise();\n  maximum -= black;\n  for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)\n  {\n    if (dmin > pre_mul[c])\n      dmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n      dmax = pre_mul[c];\n  }\n  if (!highlight)\n    dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n  {\n    fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf(stderr, \" %f\", pre_mul[c]);\n    fputc('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)\n  {\n    FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight * iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i = 0; i < size * 4; i++)\n  {\n    if (!(val = ((ushort *)image)[i]))\n      continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3)\n  {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c = 0; c < 4; c += 2)\n    {\n      if (aber[c] == 1)\n        continue;\n      img = (ushort *)malloc(size * sizeof *img);\n      merror(img, \"scale_colors()\");\n      for (i = 0; i < size; i++)\n        img[i] = image[i][c];\n      for (row = 0; row < iheight; row++)\n      {\n        ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;\n        if (ur > iheight - 2)\n          continue;\n        fr -= ur;\n        for (col = 0; col < iwidth; col++)\n        {\n          uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;\n          if (uc > iwidth - 2)\n            continue;\n          fc -= uc;\n          pix = img + ur * iwidth + uc;\n          image[row * iwidth + col][c] =\n              (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;\n        }\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort(*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);\n#endif\n  if (shrink)\n  {\n    if (half_size)\n    {\n      height = iheight;\n      width = iwidth;\n      if (filters == 9)\n      {\n        for (row = 0; row < 3; row++)\n          for (col = 1; col < 4; col++)\n            if (!(image[row * width + col][0] | image[row * width + col][2]))\n              goto break2;\n      break2:\n        for (; row < height; row += 3)\n          for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)\n          {\n            img = image + row * width + col;\n            for (c = 0; c < 3; c += 2)\n              img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n          }\n      }\n    }\n    else\n    {\n      img = (ushort(*)[4])calloc(height, width * sizeof *img);\n      merror(img, \"pre_interpolate()\");\n      for (row = 0; row < height; row++)\n        for (col = 0; col < width; col++)\n        {\n          c = fcol(row, col);\n          img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];\n        }\n      free(image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3)\n  {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size)\n      colors++;\n    else\n    {\n      for (row = FC(1, 0) >> 1; row < height; row += 2)\n        for (col = FC(row, 1) & 1; col < width; col += 2)\n          image[row * width + col][1] = image[row * width + col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size)\n    filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);\n#endif\n}\n\nvoid CLASS border_interpolate(int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      if (col == border && row >= border && row < height - border)\n        col = width - border;\n      memset(sum, 0, sizeof sum);\n      for (y = row - 1; y != row + 2; y++)\n        for (x = col - 1; x != col + 2; x++)\n          if (y < height && x < width)\n          {\n            f = fcol(y, x);\n            sum[f] += image[y * width + x][f];\n            sum[f + 4]++;\n          }\n      f = fcol(row, col);\n      FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size = 16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#endif\n\n  if (filters == 9)\n    size = 6;\n  border_interpolate(1);\n  for (row = 0; row < size; row++)\n    for (col = 0; col < size; col++)\n    {\n      ip = code[row][col] + 1;\n      f = fcol(row, col);\n      memset(sum, 0, sizeof sum);\n      for (y = -1; y <= 1; y++)\n        for (x = -1; x <= 1; x++)\n        {\n          shift = (y == 0) + (x == 0);\n          color = fcol(row + y, col + x);\n          if (color == f)\n            continue;\n          *ip++ = (width * y + x) * 4 + color;\n          *ip++ = shift;\n          *ip++ = color;\n          sum[color] += 1 << shift;\n        }\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n      if (c != f)\n      {\n        *ip++ = c;\n        *ip++ = sum[c] > 0 ? 256 / sum[c] : 0;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#endif\n  lin_interpolate_loop(code, size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp,\n      terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,\n                 -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,\n                 -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,\n                 -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,\n                 -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,\n                 -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,\n                 -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,\n                 -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,\n                 -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,\n                 -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,\n                 +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,\n                 +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,\n                 +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,\n                 +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,\n                 +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,\n                 +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},\n      chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};\n  ushort(*brow[5])[4], *pix;\n  int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1)\n    prow = pcol = 16;\n  if (filters == 9)\n    prow = pcol = 6;\n  ip = (int *)calloc(prow * pcol, 1280);\n  merror(ip, \"vng_interpolate()\");\n  for (row = 0; row < prow; row++) /* Precalculate for VNG */\n    for (col = 0; col < pcol; col++)\n    {\n      code[row][col] = ip;\n      for (cp = terms, t = 0; t < 64; t++)\n      {\n        y1 = *cp++;\n        x1 = *cp++;\n        y2 = *cp++;\n        x2 = *cp++;\n        weight = *cp++;\n        grads = *cp++;\n        color = fcol(row + y1, col + x1);\n        if (fcol(row + y2, col + x2) != color)\n          continue;\n        diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;\n        if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)\n          continue;\n        *ip++ = (y1 * width + x1) * 4 + color;\n        *ip++ = (y2 * width + x2) * 4 + color;\n        *ip++ = weight;\n        for (g = 0; g < 8; g++)\n          if (grads & 1 << g)\n            *ip++ = g;\n        *ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp = chood, g = 0; g < 8; g++)\n      {\n        y = *cp++;\n        x = *cp++;\n        *ip++ = (y * width + x) * 4;\n        color = fcol(row, col);\n        if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)\n          *ip++ = (y * width + x) * 8 + color;\n        else\n          *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);\n  merror(brow[4], \"vng_interpolate()\");\n  for (row = 0; row < 3; row++)\n    brow[row] = brow[4] + row * width;\n  for (row = 2; row < height - 2; row++)\n  { /* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!((row - 2) % 256))\n      RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);\n#endif\n    for (col = 2; col < width - 2; col++)\n    {\n      pix = image[row * width + col];\n      ip = code[row % prow][col % pcol];\n      memset(gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX)\n      { /* Calculate gradients */\n        diff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n        gval[ip[3]] += diff;\n        ip += 5;\n        if ((g = ip[-1]) == -1)\n          continue;\n        gval[g] += diff;\n        while ((g = *ip++) != -1)\n          gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0]; /* Choose a threshold */\n      for (g = 1; g < 8; g++)\n      {\n        if (gmin > gval[g])\n          gmin = gval[g];\n        if (gmax < gval[g])\n          gmax = gval[g];\n      }\n      if (gmax == 0)\n      {\n        memcpy(brow[2][col], pix, sizeof *image);\n        continue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset(sum, 0, sizeof sum);\n      color = fcol(row, col);\n      for (num = g = 0; g < 8; g++, ip += 2)\n      { /* Average the neighbors */\n        if (gval[g] <= thold)\n        {\n          FORCC\n          if (c == color && ip[1])\n            sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n          else\n            sum[c] += pix[ip[0] + c];\n          num++;\n        }\n      }\n      FORCC\n      { /* Save to buffer */\n        t = pix[color];\n        if (c != color)\n          t += (sum[c] - sum[color]) / num;\n        brow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3) /* Write buffer to image */\n      memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n    for (g = 0; g < 4; g++)\n      brow[(g - 1) & 3] = brow[g];\n  }\n  memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n  memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);\n  free(brow[4]);\n  free(code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = {1, width, -1, -width, 1};\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort(*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 3; row < height - 3; row++)\n    for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; i++)\n      {\n        guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];\n        diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +\n                  (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)\n        pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)\n      {\n        diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);\n        guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n        pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n        pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab(ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb)\n  {\n#ifndef LIBRAW_NOTHREADS\n    if (cbrt[0] < -1.0f)\n#endif\n      for (i = 0; i < 0x10000; i++)\n      {\n        r = i / 65535.0;\n        cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;\n      }\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (xyz_cam[i][j] = k = 0; k < 3; k++)\n          xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC\n  {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int)xyz[0])];\n  xyz[1] = cbrt[CLIP((int)xyz[1])];\n  xyz[2] = cbrt[CLIP((int)xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512 /* Tile Size */\n#define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate(int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},\n                     dir[4] = {1, TS, TS + 1, TS - 1};\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n        {\n          val = pix[hex[c]][1];\n          if (min > val)\n            min = val;\n          if (max < val)\n            max = val;\n        }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row - sgrow) % 3)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n          row--;\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n          memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n      FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);\n\n      /* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n        {\n          if ((f = fcol(row, col)) == 1)\n            continue;\n          pix = image + row * width + col;\n          hex = allhex[row % 3][col % 3][0];\n          color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n          color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);\n          FORC(2)\n          color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +\n                            33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);\n          FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n        }\n\n      for (pass = 0; pass < passes; pass++)\n      {\n        if (pass == 1)\n          memcpy(rgb += 4, buffer, 4 * sizeof *rgb);\n\n        /* Recalculate green from interpolated values of closer pixels:\t*/\n        if (pass)\n        {\n          for (row = top + 2; row < mrow - 2; row++)\n            for (col = left + 2; col < mcol - 2; col++)\n            {\n              if ((f = fcol(row, col)) == 1)\n                continue;\n              pix = image + row * width + col;\n              hex = allhex[row % 3][col % 3][1];\n              for (d = 3; d < 6; d++)\n              {\n                rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                val =\n                    rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n              }\n            }\n        }\n\n        /* Interpolate red and blue values for solitary green pixels:\t*/\n        for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n          for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n          {\n            rix = &rgb[0][row - top][col - left];\n            h = fcol(row, col + 1);\n            memset(diff, 0, sizeof diff);\n            for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)\n            {\n              for (c = 0; c < 2; c++, h ^= 2)\n              {\n                g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                if (d > 1)\n                  diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);\n              }\n              if (d > 1 && (d & 1))\n                if (diff[d - 1] < diff[d])\n                  FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n              if (d < 2 || (d & 1))\n              {\n                FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                rix += TS * TS;\n              }\n            }\n          }\n\n        /* Interpolate red for blue pixels and vice versa:\t\t*/\n        for (row = top + 3; row < mrow - 3; row++)\n          for (col = left + 3; col < mcol - 3; col++)\n          {\n            if ((f = 2 - fcol(row, col)) == 1)\n              continue;\n            rix = &rgb[0][row - top][col - left];\n            c = (row - sgrow) % 3 ? TS : 1;\n            h = 3 * (c ^ TS ^ 1);\n            for (d = 0; d < 4; d++, rix += TS * TS)\n            {\n              i = d > 1 || ((d ^ c) & 1) || ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <\n                                             2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))\n                      ? c\n                      : h;\n              rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);\n            }\n          }\n\n        /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n        for (row = top + 2; row < mrow - 2; row++)\n          if ((row - sgrow) % 3)\n            for (col = left + 2; col < mcol - 2; col++)\n              if ((col - sgcol) % 3)\n              {\n                rix = &rgb[0][row - top][col - left];\n                hex = allhex[row % 3][col % 3][1];\n                for (d = 0; d < ndir; d += 2, rix += TS * TS)\n                  if (hex[d] + hex[d + 1])\n                  {\n                    g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                  }\n                  else\n                  {\n                    g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                  }\n              }\n      }\n      rgb = (ushort(*)[TS][TS][3])buffer;\n      mrow -= top;\n      mcol -= left;\n\n      /* Convert to CIELab and differentiate in all directions:\t*/\n      for (d = 0; d < ndir; d++)\n      {\n        for (row = 2; row < mrow - 2; row++)\n          for (col = 2; col < mcol - 2; col++)\n            cielab(rgb[d][row][col], lab[row][col]);\n        for (f = dir[d & 3], row = 3; row < mrow - 3; row++)\n          for (col = 3; col < mcol - 3; col++)\n          {\n            lix = &lab[row][col];\n            g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n            drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                               SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n          }\n      }\n\n      /* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir * TS * TS);\n      for (row = 4; row < mrow - 4; row++)\n        for (col = 4; col < mcol - 4; col++)\n        {\n          for (tr = FLT_MAX, d = 0; d < ndir; d++)\n            if (tr > drv[d][row][col])\n              tr = drv[d][row][col];\n          tr *= 8;\n          for (d = 0; d < ndir; d++)\n            for (v = -1; v <= 1; v++)\n              for (h = -1; h <= 1; h++)\n                if (drv[d][row + v][col + h] <= tr)\n                  homo[d][row][col]++;\n        }\n\n      /* Average the most homogenous pixels for the final result:\t*/\n      if (height - top < TS + 4)\n        mrow = height - top + 2;\n      if (width - left < TS + 4)\n        mcol = width - left + 2;\n      for (row = MIN(top, 8); row < mrow - 8; row++)\n        for (col = MIN(left, 8); col < mcol - 8; col++)\n        {\n          for (d = 0; d < ndir; d++)\n            for (hm[d] = 0, v = -2; v <= 2; v++)\n              for (h = -2; h <= 2; h++)\n                hm[d] += homo[d][row + v][col + h];\n          for (d = 0; d < ndir - 4; d++)\n            if (hm[d] < hm[d + 4])\n              hm[d] = 0;\n            else if (hm[d] > hm[d + 4])\n              hm[d + 4] = 0;\n          for (max = hm[0], d = 1; d < ndir; d++)\n            if (max < hm[d])\n              max = hm[d];\n          max -= max >> 3;\n          memset(avg, 0, sizeof avg);\n          for (d = 0; d < ndir; d++)\n            if (hm[d] >= max)\n            {\n              FORC3 avg[c] += rgb[d][row][col][c];\n              avg[3]++;\n            }\n          FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n        }\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + TS, height - 2);\n  const int collimit = MIN(left + TS, width - 2);\n\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n      out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],\n                                                                short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort(*pix)[4];\n  ushort(*rix)[3];\n  short(*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4 * width;\n  const unsigned rowlimit = MIN(top + TS - 1, height - 3);\n  const unsigned collimit = MIN(left + TS - 1, width - 3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top + 1; row < rowlimit; row++)\n  {\n    pix = image + row * width + left;\n    rix = &inout_rgb[row - top][0];\n    lix = &out_lab[row - top][0];\n\n    for (col = left + 1; col < collimit; col++)\n    {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1)\n      {\n        c = FC(row + 1, col);\n        t1 = 2 - c;\n        val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);\n      }\n      else\n      {\n        t1 = -4 + c; /* -4+c: pixel of color c to the left */\n        t2 = 4 + c;  /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -\n                            rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                           2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row, col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0], lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],\n                                                         short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++)\n  {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],\n                                                 char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short(*lix)[3];\n  short(*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = {-1, 1, -TS, TS};\n  const int rowlimit = MIN(top + TS - 2, height - 4);\n  const int collimit = MIN(left + TS - 2, width - 4);\n  int homogeneity;\n  char(*homogeneity_map_p)[2];\n\n  memset(out_homogeneity_map, 0, 2 * TS * TS);\n\n  for (row = top + 2; row < rowlimit; row++)\n  {\n    tr = row - top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction = 0; direction < 2; direction++)\n    {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col = left + 2; col < collimit; col++)\n    {\n      tc = col - left;\n      homogeneity_map_p++;\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        lix = ++lixs[direction];\n        for (i = 0; i < 4; i++)\n        {\n          adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n      for (direction = 0; direction < 2; direction++)\n      {\n        homogeneity = 0;\n        for (i = 0; i < 4; i++)\n        {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)\n          {\n            homogeneity++;\n          }\n        }\n        homogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],\n                                                      char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top + TS - 3, height - 5);\n  const int collimit = MIN(left + TS - 3, width - 5);\n\n  ushort(*pix)[4];\n  ushort(*rix[2])[3];\n\n  for (row = top + 3; row < rowlimit; row++)\n  {\n    tr = row - top;\n    pix = &image[row * width + left + 2];\n    for (direction = 0; direction < 2; direction++)\n    {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col = left + 3; col < collimit; col++)\n    {\n      tc = col - left;\n      pix++;\n      for (direction = 0; direction < 2; direction++)\n      {\n        rix[direction]++;\n      }\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        hm[direction] = 0;\n        for (i = tr - 1; i <= tr + 1; i++)\n        {\n          for (j = tc - 1; j <= tc + 1; j++)\n          {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1])\n      {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      }\n      else\n      {\n        FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4], r;\n  char *buffer;\n  ushort(*rgb)[TS][TS][3];\n  short(*lab)[TS][TS][3];\n  char(*homo)[TS][2];\n  int terminate_flag = 0;\n\n  cielab(0, 0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *)malloc(26 * TS * TS); /* 1664 kB */\n    merror(buffer, \"ahd_interpolate()\");\n    rgb = (ushort(*)[TS][TS][3])buffer;\n    lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n    homo = (char(*)[TS][2])(buffer + 24 * TS * TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top = 2; top < height - 5; top += TS - 6)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n      if (0 == omp_get_thread_num())\n#endif\n        if (callbacks.progress_cb)\n        {\n          int rr =\n              (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);\n          if (rr)\n            terminate_flag = 1;\n        }\n#endif\n      for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)\n      {\n        ahd_interpolate_green_h_and_v(top, left, rgb);\n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free(buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (terminate_flag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = {-1, 1, -TS, TS};\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][TS][3], (*lix)[3];\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab(0, 0);\n  border_interpolate(5);\n  buffer = (char *)malloc(26 * TS * TS);\n  merror(buffer, \"ahd_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n  homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);\n\n  for (top = 2; top < height - 5; top += TS - 6)\n    for (left = 2; left < width - 5; left += TS - 6)\n    {\n\n      /*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top + TS && row < height - 2; row++)\n      {\n        col = left + (FC(row, left) & 1);\n        for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)\n        {\n          pix = image + row * width + col;\n          val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n          rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n          val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n          rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n        }\n      }\n\n      /*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d = 0; d < 2; d++)\n        for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)\n          for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)\n          {\n            pix = image + row * width + col;\n            rix = &rgb[d][row - top][col - left];\n            lix = &lab[d][row - top][col - left];\n            if ((c = 2 - FC(row, col)) == 1)\n            {\n              c = FC(row + 1, col);\n              val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);\n              rix[0][2 - c] = CLIP(val);\n              val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);\n            }\n            else\n              val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -\n                                  rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                                 2);\n            rix[0][c] = CLIP(val);\n            c = FC(row, col);\n            rix[0][c] = pix[0][c];\n            cielab(rix[0], lix[0]);\n          }\n      /*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset(homo, 0, 2 * TS * TS);\n      for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)\n      {\n        tr = row - top;\n        for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n          {\n            lix = &lab[d][tr][tc];\n            for (i = 0; i < 4; i++)\n            {\n              ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);\n              abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);\n            }\n          }\n          leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n          abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n          for (d = 0; d < 2; d++)\n            for (i = 0; i < 4; i++)\n              if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n                homo[d][tr][tc]++;\n        }\n      }\n      /*  Combine the most homogenous pixels for the final result:\t*/\n      for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)\n      {\n        tr = row - top;\n        for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n            for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)\n              for (j = tc - 1; j <= tc + 1; j++)\n                hm[d] += homo[d][i][j];\n          if (hm[0] != hm[1])\n            FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n          else\n            FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n        }\n      }\n    }\n  free(buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = /* Optimal 9-element median search */\n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n                                       {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned)(colors - 3) > 1)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n#endif\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow(2.0, 4 - highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc = 0, c = 1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c])\n      kc = c;\n  high = height / SCALE;\n  wide = width / SCALE;\n  map = (float *)calloc(high, wide * sizeof *map);\n  merror(map, \"recover_highlights()\");\n  FORCC if (c != kc)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);\n#endif\n    memset(map, 0, high * wide * sizeof *map);\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        sum = wgt = count = 0;\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)\n            {\n              sum += pixel[c];\n              wgt += pixel[kc];\n              count++;\n            }\n          }\n        if (count == SCALE * SCALE)\n          map[mrow * wide + mcol] = sum / wgt;\n      }\n    for (spread = 32 / grow; spread--;)\n    {\n      for (mrow = 0; mrow < high; mrow++)\n        for (mcol = 0; mcol < wide; mcol++)\n        {\n          if (map[mrow * wide + mcol])\n            continue;\n          sum = count = 0;\n          for (d = 0; d < 8; d++)\n          {\n            y = mrow + dir[d][0];\n            x = mcol + dir[d][1];\n            if (y < high && x < wide && map[y * wide + x] > 0)\n            {\n              sum += (1 + (d & 1)) * map[y * wide + x];\n              count += 1 + (d & 1);\n            }\n          }\n          if (count > 3)\n            map[mrow * wide + mcol] = -(sum + grow) / (count + grow);\n        }\n      for (change = i = 0; i < high * wide; i++)\n        if (map[i] < 0)\n        {\n          map[i] = -map[i];\n          change = 1;\n        }\n      if (!change)\n        break;\n    }\n    for (i = 0; i < high * wide; i++)\n      if (map[i] == 0)\n        map[i] = 1;\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] > 1)\n            {\n              val = pixel[kc] * map[mrow * wide + mcol];\n              if (pixel[c] < val)\n                pixel[c] = CLIP(val);\n            }\n          }\n      }\n  }\n  free(map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag = get2();\n  *type = get2();\n  *len = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)\n    fseek(ifp, get4() + base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == toff)\n      thumb_offset = get4() + base;\n    if (tag == tlen)\n      thumb_length = get4();\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nstatic float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }\nstatic float powf64(float a, float b) { return powf_lim(a, b, 64.f); }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x)\n{\n  float t;\n  if (x >= 0.0)\n  {\n    t = ceilf(x);\n    if (t - x > 0.5)\n      t -= 1.0;\n    return t;\n  }\n  else\n  {\n    t = ceilf(-x);\n    if (t + x > 0.5)\n      t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))\n    return 0.0f;\n  return powf64(2.0, in / 64.0);\n}\n\nstatic float _CanonConvertEV(short in)\n{\n  short EV, Sign, Frac;\n  float Frac_f;\n  EV = in;\n  if (EV < 0)\n  {\n    EV = -EV;\n    Sign = -1;\n  }\n  else\n  {\n    Sign = 1;\n  }\n  Frac = EV & 0x1f;\n  EV -= Frac; // remove fraction\n\n  if (Frac == 0x0c)\n  { // convert 1/3 and 2/3 codes\n    Frac_f = 32.0f / 3.0f;\n  }\n  else if (Frac == 0x14)\n  {\n    Frac_f = 64.0f / 3.0f;\n  }\n  else\n    Frac_f = (float)Frac;\n\n  return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x80000001) || // 1D\n      (id == 0x80000174) || // 1D2\n      (id == 0x80000232) || // 1D2N\n      (id == 0x80000169) || // 1D3\n      (id == 0x80000281)    // 1D4\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000167) || // 1Ds\n           (id == 0x80000188) || // 1Ds2\n           (id == 0x80000215) || // 1Ds3\n           (id == 0x80000269) || // 1DX\n           (id == 0x80000328) || // 1DX2\n           (id == 0x80000324) || // 1DC\n           (id == 0x80000213) || // 5D\n           (id == 0x80000218) || // 5D2\n           (id == 0x80000285) || // 5D3\n           (id == 0x80000349) || // 5D4\n           (id == 0x80000382) || // 5DS\n           (id == 0x80000401) || // 5DS R\n           (id == 0x80000302)    // 6D\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000331) || // M\n           (id == 0x80000355) || // M2\n           (id == 0x80000374) || // M3\n           (id == 0x80000384) || // M10\n           (id == 0x80000394)    // M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n  }\n  else if ((id == 0x01140000) || // D30\n           (id == 0x01668000) || // D60\n           (id > 0x80000000))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n  }\n  else\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n  }\n\n  return;\n}\n\nvoid CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,\n         iCanonFocalType = 0;\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id)\n  {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12))\n      iCanonLensID = 151;\n    else\n      iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n  {\n    if (iCanonFocalType >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n    if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'\n      imgdata.lens.makernotes.FocalType = 1;\n  }\n  if (!imgdata.lens.makernotes.CurFocal)\n  {\n    if (iCanonCurFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n  }\n  if (!imgdata.lens.makernotes.LensID)\n  {\n    if (iCanonLensID >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n  }\n  if (!imgdata.lens.makernotes.MinFocal)\n  {\n    if (iCanonMinFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n  }\n  if (!imgdata.lens.makernotes.MaxFocal)\n  {\n    if (iCanonMaxFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n  }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)\n  {\n    if (iCanonLens + 64 >= maxlen)\n      return;                        // broken;\n    if (CameraInfo[iCanonLens] < 65) // non-Canon lens\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2();\n  get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2();\n  get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2();\n  get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n  {\n    imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n  }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets(short WBCTversion)\n{\n  if (WBCTversion == 0)\n    for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if (WBCTversion == 1)\n    for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3\n                                  (unique_id == 0x80000384) || // M10\n                                  (unique_id == 0x80000394) || // M5\n                                  (unique_id == 0x03970000) || // G7 X Mark II\n                                  (unique_id == 0x04100000)))  // G9 X Mark II\n    for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X\n    for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  return;\n}\n\nvoid CLASS processNikonLensData(uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n  {\n    if (imgdata.lens.nikon.NikonLensType & 0x04)\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n    else\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n    imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n  {\n    imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n    imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20)\n  {\n    switch (len)\n    {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n    {\n      if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n        imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n      if (LensData[i + 7])\n        imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n    }\n    imgdata.lens.makernotes.LensID =\n        (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |\n        (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |\n        (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |\n        (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;\n  }\n  else if ((len == 459) || (len == 590))\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n  }\n  else if (len == 509)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n  }\n  else if (len == 879)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n  }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures(unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) || // E-1\n      (id == 0x4434303431ULL) || // E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n    if ((id == 0x4434303430ULL) ||                              // E-1\n        (id == 0x4434303431ULL) ||                              // E-330\n        ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n        (id == 0x5330303233ULL) ||                              // E-620\n        (id == 0x5330303239ULL) ||                              // E-450\n        (id == 0x5330303330ULL) ||                              // E-600\n        (id == 0x5330303333ULL))                                // E-5\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n    }\n    else\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n    }\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)\n{\n\n  if (tag == 0x0001)\n    Canon_CameraSettings();\n  else if (tag == 0x0002) // focal length\n  {\n    imgdata.lens.makernotes.FocalType = get2();\n    imgdata.lens.makernotes.CurFocal = get2();\n    if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  }\n\n  else if (tag == 0x0004) // shot info\n  {\n    short tempAp;\n    fseek(ifp, 30, SEEK_CUR);\n    imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n    fseek(ifp, 8 - 32, SEEK_CUR);\n    if ((tempAp = get2()) != 0x7fff)\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n    if (imgdata.lens.makernotes.CurAp < 0.7f)\n    {\n      fseek(ifp, 32, SEEK_CUR);\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n    }\n    if (!aperture)\n      aperture = imgdata.lens.makernotes.CurAp;\n  }\n\n  else if (tag == 0x0095 && // lens model tag\n           !imgdata.lens.makernotes.Lens[0])\n  {\n    fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens\n      fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n    else\n    {\n      char efs[2];\n      imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n      imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n      fread(efs, 2, 1, ifp);\n      if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n      { // \"EF-S, TS-E, MP-E, EF-M\" lenses\n        imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n        imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n        imgdata.lens.makernotes.Lens[4] = 32;\n        if (efs[1] == 83)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n        }\n        else if (efs[1] == 77)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n        }\n      }\n      else\n      { // \"EF\" lenses\n        imgdata.lens.makernotes.Lens[2] = 32;\n        imgdata.lens.makernotes.Lens[3] = efs[0];\n        imgdata.lens.makernotes.Lens[4] = efs[1];\n      }\n      fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n    }\n  }\n\n  else if (tag == 0x00a9)\n  {\n    long int save1 = ftell(ifp);\n    fseek(ifp, save1 + (0x5 << 1), SEEK_SET);\n    Canon_WBpresets(0, 0);\n    fseek(ifp, save1, SEEK_SET);\n  }\n\n  else if (tag == 0x00e0) // sensor info\n  {\n    imgdata.makernotes.canon.SensorWidth = (get2(), get2());\n    imgdata.makernotes.canon.SensorHeight = get2();\n    imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());\n    imgdata.makernotes.canon.SensorTopBorder = get2();\n    imgdata.makernotes.canon.SensorRightBorder = get2();\n    imgdata.makernotes.canon.SensorBottomBorder = get2();\n    imgdata.makernotes.canon.BlackMaskLeftBorder = get2();\n    imgdata.makernotes.canon.BlackMaskTopBorder = get2();\n    imgdata.makernotes.canon.BlackMaskRightBorder = get2();\n    imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n  }\n\n  else if (tag == 0x4001 && len > 500)\n  {\n    int c;\n    long int save1 = ftell(ifp);\n    switch (len)\n    {\n    case 582:\n      imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D\n      {\n        fseek(ifp, save1 + (0x23 << 1), SEEK_SET);\n        Canon_WBpresets(2, 2);\n        fseek(ifp, save1 + (0x4b << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 653:\n      imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2\n      {\n        fseek(ifp, save1 + (0x27 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 796:\n      imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x4e << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n    // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n    // 7D / 40D / 50D / 60D / 450D / 500D\n    // 550D / 1000D / 1100D\n    case 674:\n    case 692:\n    case 702:\n    case 1227:\n    case 1250:\n    case 1251:\n    case 1337:\n    case 1338:\n    case 1346:\n      imgdata.makernotes.canon.CanonColorDataVer = 4;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x53 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n      {\n        fseek(ifp, save1 + (0x2b9 << 1), SEEK_SET); // offset 697 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n               (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n      {\n        fseek(ifp, save1 + (0x2d0 << 1), SEEK_SET); // offset 720 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n      {\n        fseek(ifp, save1 + (0x2d4 << 1), SEEK_SET); // offset 724 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    case 5120:\n      imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5\n      {\n        fseek(ifp, save1 + (0x56 << 1), SEEK_SET);\n        if ((unique_id == 0x03970000) || // G7 X Mark II\n            (unique_id == 0x04100000) || // G9 X Mark II\n            (unique_id == 0x80000394))   // EOS M5\n        {\n          fseek(ifp, 18, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          Canon_WBpresets(8, 24);\n          fseek(ifp, 168, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n          fseek(ifp, 24, SEEK_CUR);\n          Canon_WBCTpresets(2); // BCADT\n          fseek(ifp, 6, SEEK_CUR);\n        }\n        else\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          get2();\n          Canon_WBpresets(2, 12);\n          fseek(ifp, save1 + (0xba << 1), SEEK_SET);\n          Canon_WBCTpresets(2);                       // BCADT\n          fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short\n        }\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n\n    case 1273:\n    case 1275:\n      imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x67 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xbc << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      fseek(ifp, save1 + (0x1e4 << 1), SEEK_SET); // offset 484 shorts\n      imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      break;\n\n    // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n    case 1312:\n    case 1313:\n    case 1316:\n    case 1506:\n      imgdata.makernotes.canon.CanonColorDataVer = 7;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n      {\n        fseek(ifp, save1 + (0x1fd << 1), SEEK_SET); // offset 509 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n      {\n        fseek(ifp, save1 + (0x2dd << 1), SEEK_SET); // offset 733 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    // 5DS / 5DS R / 80D / 1300D / 5D4\n    case 1560:\n    case 1592:\n    case 1353:\n      imgdata.makernotes.canon.CanonColorDataVer = 8;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x107 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D\n      {\n        fseek(ifp, save1 + (0x231 << 1), SEEK_SET);\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else\n      {\n        fseek(ifp, save1 + (0x30f << 1), SEEK_SET); // offset 783 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n    }\n    fseek(ifp, save1, SEEK_SET);\n  }\n}\n\nvoid CLASS setPentaxBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id)\n  {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n  case 0x1322c:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO(ushort c)\n{\n  int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,   12,   13,  14,  15,  16,  17,  18,  19,\n                20,  21,  22,  23,  24,  25,  26,  27,  28,   29,   30,  31,  32,  33,  34,  35,  36,\n                37,  38,  39,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264,\n                265, 266, 267, 268, 269, 270, 271, 272, 273,  274,  275, 276, 277, 278};\n  double value[] = {50,    64,    80,    100,   125,   160,   200,   250,    320,    400,    500,    640,   800,\n                    1000,  1250,  1600,  2000,  2500,  3200,  4000,  5000,   6400,   8000,   10000,  12800, 16000,\n                    20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50,    100,\n                    200,   400,   800,   1600,  3200,  50,    70,    100,    140,    200,    280,    400,   560,\n                    800,   1100,  1600,  2200,  3200,  4500,  6400,  9000,   12800,  18000,  25600,  36000, 51200};\n#define numel (sizeof(code) / sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++)\n  {\n    if (code[i] == c)\n    {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel)\n    iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207\n{\n  ushort iLensData = 0;\n  uchar *table_buf;\n  table_buf = (uchar *)malloc(MAX(len, 128));\n  fread(table_buf, len, 1, ifp);\n  if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D\n                          (id == 0x12b9d) ||  // K110D\n                          (id == 0x12ba2)) && // K100D Super\n                         ((!table_buf[20] || (table_buf[20] == 0xff)))))\n  {\n    iLensData = 3;\n    if (imgdata.lens.makernotes.LensID == -1)\n      imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];\n  }\n  else\n    switch (len)\n    {\n    case 90: // LensInfo3\n      iLensData = 13;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 91: // LensInfo4\n      iLensData = 12;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 80: // LensInfo5\n    case 128:\n      iLensData = 15;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];\n      break;\n    default:\n      if (id >= 0x12b9c) // LensInfo2\n      {\n        iLensData = 4;\n        if (imgdata.lens.makernotes.LensID == -1)\n          imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];\n      }\n    }\n  if (iLensData)\n  {\n    if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n      imgdata.lens.makernotes.CurFocal =\n          10 * (table_buf[iLensData + 9] >> 2) * powf64(4, (table_buf[iLensData + 9] & 0x03) - 2);\n    if (table_buf[iLensData + 10] & 0xf0)\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);\n    if (table_buf[iLensData + 10] & 0x0f)\n      imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);\n\n    if (iLensData != 12)\n    {\n      switch (table_buf[iLensData] & 0x06)\n      {\n      case 0:\n        imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;\n        break;\n      case 2:\n        imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;\n        break;\n      case 4:\n        imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;\n        break;\n      case 6:\n        imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;\n        break;\n      }\n      if (table_buf[iLensData] & 0x70)\n        imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n      imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);\n      imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);\n\n      if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);\n    }\n    else if ((id != 0x12e76) && // K-5\n             (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n    {\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);\n    }\n  }\n  free(table_buf);\n  return;\n}\n\nvoid CLASS setPhaseOneFeatures(unsigned id)\n{\n\n  ushort i;\n  static const struct\n  {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n      // Phase One section:\n      {1, \"Hasselblad V\"},\n      {10, \"PhaseOne/Mamiya\"},\n      {12, \"Contax 645\"},\n      {16, \"Hasselblad V\"},\n      {17, \"Hasselblad V\"},\n      {18, \"Contax 645\"},\n      {19, \"PhaseOne/Mamiya\"},\n      {20, \"Hasselblad V\"},\n      {21, \"Contax 645\"},\n      {22, \"PhaseOne/Mamiya\"},\n      {23, \"Hasselblad V\"},\n      {24, \"Hasselblad H\"},\n      {25, \"PhaseOne/Mamiya\"},\n      {32, \"Contax 645\"},\n      {34, \"Hasselblad V\"},\n      {35, \"Hasselblad V\"},\n      {36, \"Hasselblad H\"},\n      {37, \"Contax 645\"},\n      {38, \"PhaseOne/Mamiya\"},\n      {39, \"Hasselblad V\"},\n      {40, \"Hasselblad H\"},\n      {41, \"Contax 645\"},\n      {42, \"PhaseOne/Mamiya\"},\n      {44, \"Hasselblad V\"},\n      {45, \"Hasselblad H\"},\n      {46, \"Contax 645\"},\n      {47, \"PhaseOne/Mamiya\"},\n      {48, \"Hasselblad V\"},\n      {49, \"Hasselblad H\"},\n      {50, \"Contax 645\"},\n      {51, \"PhaseOne/Mamiya\"},\n      {52, \"Hasselblad V\"},\n      {53, \"Hasselblad H\"},\n      {54, \"Contax 645\"},\n      {55, \"PhaseOne/Mamiya\"},\n      {67, \"Hasselblad V\"},\n      {68, \"Hasselblad H\"},\n      {69, \"Contax 645\"},\n      {70, \"PhaseOne/Mamiya\"},\n      {71, \"Hasselblad V\"},\n      {72, \"Hasselblad H\"},\n      {73, \"Contax 645\"},\n      {74, \"PhaseOne/Mamiya\"},\n      {76, \"Hasselblad V\"},\n      {77, \"Hasselblad H\"},\n      {78, \"Contax 645\"},\n      {79, \"PhaseOne/Mamiya\"},\n      {80, \"Hasselblad V\"},\n      {81, \"Hasselblad H\"},\n      {82, \"Contax 645\"},\n      {83, \"PhaseOne/Mamiya\"},\n      {84, \"Hasselblad V\"},\n      {85, \"Hasselblad H\"},\n      {86, \"Contax 645\"},\n      {87, \"PhaseOne/Mamiya\"},\n      {99, \"Hasselblad V\"},\n      {100, \"Hasselblad H\"},\n      {101, \"Contax 645\"},\n      {102, \"PhaseOne/Mamiya\"},\n      {103, \"Hasselblad V\"},\n      {104, \"Hasselblad H\"},\n      {105, \"PhaseOne/Mamiya\"},\n      {106, \"Contax 645\"},\n      {112, \"Hasselblad V\"},\n      {113, \"Hasselblad H\"},\n      {114, \"Contax 645\"},\n      {115, \"PhaseOne/Mamiya\"},\n      {131, \"Hasselblad V\"},\n      {132, \"Hasselblad H\"},\n      {133, \"Contax 645\"},\n      {134, \"PhaseOne/Mamiya\"},\n      {135, \"Hasselblad V\"},\n      {136, \"Hasselblad H\"},\n      {137, \"Contax 645\"},\n      {138, \"PhaseOne/Mamiya\"},\n      {140, \"Hasselblad V\"},\n      {141, \"Hasselblad H\"},\n      {142, \"Contax 645\"},\n      {143, \"PhaseOne/Mamiya\"},\n      {148, \"Hasselblad V\"},\n      {149, \"Hasselblad H\"},\n      {150, \"Contax 645\"},\n      {151, \"PhaseOne/Mamiya\"},\n      {160, \"A-250\"},\n      {161, \"A-260\"},\n      {162, \"A-280\"},\n      {167, \"Hasselblad V\"},\n      {168, \"Hasselblad H\"},\n      {169, \"Contax 645\"},\n      {170, \"PhaseOne/Mamiya\"},\n      {172, \"Hasselblad V\"},\n      {173, \"Hasselblad H\"},\n      {174, \"Contax 645\"},\n      {175, \"PhaseOne/Mamiya\"},\n      {176, \"Hasselblad V\"},\n      {177, \"Hasselblad H\"},\n      {178, \"Contax 645\"},\n      {179, \"PhaseOne/Mamiya\"},\n      {180, \"Hasselblad V\"},\n      {181, \"Hasselblad H\"},\n      {182, \"Contax 645\"},\n      {183, \"PhaseOne/Mamiya\"},\n      {208, \"Hasselblad V\"},\n      {211, \"PhaseOne/Mamiya\"},\n      {448, \"Phase One 645AF\"},\n      {457, \"Phase One 645DF\"},\n      {471, \"Phase One 645DF+\"},\n      {704, \"Phase One iXA\"},\n      {705, \"Phase One iXA - R\"},\n      {706, \"Phase One iXU 150\"},\n      {707, \"Phase One iXU 150 - NIR\"},\n      {708, \"Phase One iXU 180\"},\n      {721, \"Phase One iXR\"},\n      // Leaf section:\n      {333, \"Mamiya\"},\n      {329, \"Universal\"},\n      {330, \"Hasselblad H1/H2\"},\n      {332, \"Contax\"},\n      {336, \"AFi\"},\n      {327, \"Mamiya\"},\n      {324, \"Universal\"},\n      {325, \"Hasselblad H1/H2\"},\n      {326, \"Contax\"},\n      {335, \"AFi\"},\n      {340, \"Mamiya\"},\n      {337, \"Universal\"},\n      {338, \"Hasselblad H1/H2\"},\n      {339, \"Contax\"},\n      {323, \"Mamiya\"},\n      {320, \"Universal\"},\n      {322, \"Hasselblad H1/H2\"},\n      {321, \"Contax\"},\n      {334, \"AFi\"},\n      {369, \"Universal\"},\n      {370, \"Mamiya\"},\n      {371, \"Hasselblad H1/H2\"},\n      {372, \"Contax\"},\n      {373, \"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0])\n  {\n    for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id)\n      {\n        strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes(unsigned tag, unsigned type)\n{\n  switch (tag)\n  {\n  case 0x1002:\n    imgdata.makernotes.fuji.WB_Preset = get2();\n    break;\n  case 0x1011:\n    imgdata.other.FlashEC = getreal(type);\n    break;\n  case 0x1020:\n    imgdata.makernotes.fuji.Macro = get2();\n    break;\n  case 0x1021:\n    imgdata.makernotes.fuji.FocusMode = get2();\n    break;\n  case 0x1022:\n    imgdata.makernotes.fuji.AFMode = get2();\n    break;\n  case 0x1023:\n    imgdata.makernotes.fuji.FocusPixel[0] = get2();\n    imgdata.makernotes.fuji.FocusPixel[1] = get2();\n    break;\n  case 0x1034:\n    imgdata.makernotes.fuji.ExrMode = get2();\n    break;\n  case 0x1050:\n    imgdata.makernotes.fuji.ShutterType = get2();\n    break;\n  case 0x1400:\n    imgdata.makernotes.fuji.FujiDynamicRange = get2();\n    break;\n  case 0x1401:\n    imgdata.makernotes.fuji.FujiFilmMode = get2();\n    break;\n  case 0x1402:\n    imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();\n    break;\n  case 0x1403:\n    imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();\n    break;\n  case 0x140b:\n    imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();\n    break;\n  case 0x1404:\n    imgdata.lens.makernotes.MinFocal = getreal(type);\n    break;\n  case 0x1405:\n    imgdata.lens.makernotes.MaxFocal = getreal(type);\n    break;\n  case 0x1406:\n    imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n    break;\n  case 0x1407:\n    imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n    break;\n  case 0x1422:\n    imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n    imgdata.shootinginfo.ImageStabilization =\n        (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];\n    break;\n  case 0x1431:\n    imgdata.makernotes.fuji.Rating = get4();\n    break;\n  case 0x3820:\n    imgdata.makernotes.fuji.FrameRate = get2();\n    break;\n  case 0x3821:\n    imgdata.makernotes.fuji.FrameWidth = get2();\n    break;\n  case 0x3822:\n    imgdata.makernotes.fuji.FrameHeight = get2();\n    break;\n  }\n  return;\n}\n\nvoid CLASS setSonyBodyFeatures(unsigned id)\n{\n\n  imgdata.lens.makernotes.CamID = id;\n  if (               // FF cameras\n      (id == 257) || // a900\n      (id == 269) || // a850\n      (id == 340) || // ILCE-7M2\n      (id == 318) || // ILCE-7S\n      (id == 350) || // ILCE-7SM2\n      (id == 311) || // ILCE-7R\n      (id == 347) || // ILCE-7RM2\n      (id == 306) || // ILCE-7\n      (id == 298) || // DSC-RX1\n      (id == 299) || // NEX-VG900\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 354) || // ILCA-99M2\n      (id == 294)    // SLT-99, Hasselblad HV\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n  }\n  else if ((id == 297) || // DSC-RX100\n           (id == 308) || // DSC-RX100M2\n           (id == 309) || // DSC-RX10\n           (id == 317) || // DSC-RX100M3\n           (id == 341) || // DSC-RX100M4\n           (id == 342) || // DSC-RX10M2\n           (id == 355) || // DSC-RX10M3\n           (id == 356)    // DSC-RX100M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  else if (id != 002) // DSC-R1\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n  }\n\n  if ( // E-mount cameras, ILCE series\n      (id == 302) || (id == 306) || (id == 311) || (id == 312) || (id == 313) || (id == 318) || (id == 339) ||\n      (id == 340) || (id == 346) || (id == 347) || (id == 350) || (id == 360))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n  }\n  else if ( // E-mount cameras, NEX series\n      (id == 278) || (id == 279) || (id == 284) || (id == 288) || (id == 289) || (id == 290) || (id == 293) ||\n      (id == 295) || (id == 296) || (id == 299) || (id == 300) || (id == 305) || (id == 307))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n  }\n\n  else if ( // A-mount cameras, DSLR series\n      (id == 256) || (id == 257) || (id == 258) || (id == 259) || (id == 260) || (id == 261) || (id == 262) ||\n      (id == 263) || (id == 264) || (id == 265) || (id == 266) || (id == 269) || (id == 270) || (id == 273) ||\n      (id == 274) || (id == 275) || (id == 282) || (id == 283))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n  }\n  else if ( // A-mount cameras, SLT series\n      (id == 280) || (id == 281) || (id == 285) || (id == 286) || (id == 287) || (id == 291) || (id == 292) ||\n      (id == 294) || (id == 303))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n  }\n  else if ( // A-mount cameras, ILCA series\n      (id == 319) || (id == 353) || (id == 354))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n  }\n\n  else if (          // DSC\n      (id == 002) || // DSC-R1\n      (id == 297) || // DSC-RX100\n      (id == 298) || // DSC-RX1\n      (id == 308) || // DSC-RX100M2\n      (id == 309) || // DSC-RX10\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 317) || // DSC-RX100M3\n      (id == 341) || // DSC-RX100M4\n      (id == 342) || // DSC-RX10M2\n      (id == 355) || // DSC-RX10M3\n      (id == 356)    // DSC-RX100M5\n      )\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n  }\n  return;\n}\n\nvoid CLASS parseSonyLensType2(uchar a, uchar b)\n{\n  ushort lid2;\n  lid2 = (((ushort)a) << 8) | ((ushort)b);\n  if (!lid2)\n    return;\n  if (lid2 < 0x100)\n  {\n    if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2)\n      {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n      }\n    }\n  }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    imgdata.lens.makernotes.AdapterID = 0x4900;\n  }\n  return;\n}\n\n#define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures(uchar a, uchar b)\n{\n\n  ushort features;\n  features = (((ushort)a) << 8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100))\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n  {\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n    if ((features & 0x0200) && (features & 0x0100))\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0200)\n    {\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0100)\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n    }\n  }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,\n            strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c(uchar *buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0009]]);\n  return;\n}\n\nvoid CLASS process_Sony_0x9050(uchar *buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n  {\n    if (buf[0])\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n\n    if (buf[1])\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n  }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (buf[0x3d] | buf[0x3c])\n    {\n      lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];\n      imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);\n    }\n    if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n        (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n      imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];\n    if (buf[0x106])\n      imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];\n  }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n  {\n    parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0107]]);\n  }\n  if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n  {\n    imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];\n\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n  }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long b88 = SonySubstitution[buf[0x88]];\n    unsigned long b89 = SonySubstitution[buf[0x89]];\n    unsigned long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if (len > 8 && pos + len > 2 * fsize)\n      continue;\n    tag |= uptag << 16;\n    if (len > 100 * 1024 * 1024)\n      goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes(tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x1d) // serial number\n        while ((c = fgetc(ifp)) && c != EOF)\n        {\n          if ((!custom_serial) && (!isdigit(c)))\n          {\n            if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n            {\n              custom_serial = 34;\n            }\n            else\n            {\n              custom_serial = 96;\n            }\n          }\n          serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n        }\n      else if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0097)\n      {\n        for (i = 0; i < 4; i++)\n          ver97 = ver97 * 10 + fgetc(ifp) - '0';\n        if (ver97 == 601) // Coolpix A\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n\n      else if (tag == 0xa7) // shutter count\n      {\n        NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n        if ((NikonLensDataVersion > 200) && lenNikonLensData)\n        {\n          if (custom_serial)\n          {\n            ci = xlat[0][custom_serial];\n          }\n          else\n          {\n            ci = xlat[0][serial & 0xff];\n          }\n          cj = xlat[1][NikonKey];\n          ck = 0x60;\n          for (i = 0; i < lenNikonLensData; i++)\n            table_buf[i] ^= (cj += ci * ck++);\n          processNikonLensData(table_buf, lenNikonLensData);\n          lenNikonLensData = 0;\n          free(table_buf);\n        }\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n\n      else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc, 1, 1, ifp);\n        iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n        break;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&\n                              strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);\n\n      if ((tag == 0x2010) || (tag == 0x2020))\n      {\n        fseek(ifp, save - 4, SEEK_SET);\n        fseek(ifp, base + get4(), SEEK_SET);\n        parse_makernote_0xc634(base, tag, dng_writer);\n      }\n      if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||\n                                 (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n      switch (tag)\n      {\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20100102:\n        stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x20100201:\n        imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |\n                                         (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |\n                                         (unsigned long long)fgetc(ifp);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        if ((!imgdata.lens.LensSerial[0]))\n          stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      case 0x20200401:\n        imgdata.other.FlashEC = getreal(type);\n        break;\n      }\n    skip_Oly_broken_tags:;\n    }\n\n    else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 12, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        imgdata.lens.makernotes.CamID = unique_id = get4();\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n\n                // a450, a500, a550, a560, a580\n                // a33, a35, a55\n                // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n            {\n              if (table_buf[0] | table_buf[3])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n              if (table_buf[2] | table_buf[5])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n              parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            }\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n            {\n              if (table_buf[1] | table_buf[2])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n              if (table_buf[3] | table_buf[4])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n              if (table_buf[5])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n              if (table_buf[6])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n              parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            }\n          }\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 65535) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n        {\n          if (table_buf[1] | table_buf[2])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n          if (table_buf[3] | table_buf[4])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n          if (table_buf[5])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n          if (table_buf[6])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n          parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        }\n        free(table_buf);\n      }\n    }\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */}\n#endif\n\nvoid CLASS parse_makernote(int base, int uptag)\n{\n  unsigned offset = 0, entries, tag, type, len, save, c;\n  unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder = order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n  /*\n     The MakerNote might have its own TIFF header (possibly with\n     its own byte-order!), or it might just be a table.\n   */\n  if (!strncmp(make, \"Nokia\", 5))\n    return;\n  fread(buf, 1, 10, ifp);\n  if (!strncmp(buf, \"KDK\", 3) || /* these aren't TIFF tables */\n      !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))\n    return;\n  if (!strncmp(buf, \"KC\", 2) || /* Konica KD-400Z, KD-510Z */\n      !strncmp(buf, \"MLY\", 3))\n  { /* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i = ftell(ifp)) < data_offset && i < 16384)\n    {\n      wb[0] = wb[2];\n      wb[2] = wb[1];\n      wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n        FORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if (!strncmp(make, \"SAMSUNG\", 7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n  {\n    if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))\n    {\n      base = ftell(ifp) - 8;\n    }\n    else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n    {\n      base = 0;\n    }\n    else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||\n             !strncasecmp(model, \"Leica M Monochrom\", 11))\n    {\n      if (!uptag)\n      {\n        base = ftell(ifp) - 10;\n        fseek(ifp, 8, SEEK_CUR);\n      }\n      else if (uptag == 0x3400)\n      {\n        fseek(ifp, 10, SEEK_CUR);\n        base += 10;\n      }\n    }\n    else if (!strncasecmp(model, \"LEICA T\", 7))\n    {\n      base = ftell(ifp) - 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (!strncasecmp(model, \"LEICA SL\", 8))\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n#endif\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if (len > 8 && _pos + len > 2 * fsize)\n      continue;\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n    {\n      if (tag == 0x0010)\n      {\n        char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n        char *words[4];\n        char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n        int year, nwords, ynum_len;\n        unsigned c;\n        stmread(FujiSerial, len, ifp);\n        nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n        for (int i = 0; i < nwords; i++)\n        {\n          mm[2] = dd[2] = 0;\n          if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)\n            if (i == 0)\n              strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          else\n          {\n            strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);\n            strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);\n            strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);\n            year = (yy[0] - '0') * 10 + (yy[1] - '0');\n            if (year < 70)\n              year += 2000;\n            else\n              year += 1900;\n\n            ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;\n            strncpy(ynum, words[i], ynum_len);\n            ynum[ynum_len] = 0;\n            for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)\n              ystr[j / 2] = c;\n            ystr[ynum_len / 2 + 1] = 0;\n            strcpy(model2, ystr);\n\n            if (i == 0)\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n              if (nwords == 1)\n                snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,\n                         year, mm, dd);\n\n              else\n                snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,\n                       dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          }\n        }\n      }\n      else\n        parseFujiMakernotes(tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0012)\n      {\n        char a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n          imgdata.other.FlashEC = (float)(a * b) / (float)c;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData > 0)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n      else if (tag == 0x00a0)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      switch (tag)\n      {\n      case 0x0404:\n      case 0x101a:\n      case 0x20100101:\n        if (!imgdata.shootinginfo.BodySerial[0])\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n      case 0x20100102:\n        if (!imgdata.shootinginfo.InternalBodySerial[0])\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20401112:\n        imgdata.makernotes.olympus.OlympusCropID = get2();\n        break;\n      case 0x20401113:\n        FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n        break;\n      case 0x20100201:\n      {\n        unsigned long long oly_lensid[3];\n        oly_lensid[0] = fgetc(ifp);\n        fgetc(ifp);\n        oly_lensid[1] = fgetc(ifp);\n        oly_lensid[2] = fgetc(ifp);\n        imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n      }\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        char buffer[17];\n        int count = 0;\n        fread(buffer, 16, 1, ifp);\n        buffer[16] = 0;\n        for (int i = 0; i < 16; i++)\n        {\n          //    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n          if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))\n            count++;\n        }\n        if (count == 16)\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);\n          buffer[8] = 0;\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n        }\n        else\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],\n                  buffer[11]);\n        }\n      }\n      else if ((tag == 0x1001) && (type == 3))\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n        imgdata.lens.makernotes.LensID = -1;\n        imgdata.lens.makernotes.FocalType = 1;\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n    }\n\n    else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))\n    {\n      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n      {\n        char buffer[9];\n        buffer[8] = 0;\n        fread(buffer, 8, 1, ifp);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n\n      else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n      {\n        short ntags, cur_tag;\n        fseek(ifp, 20, SEEK_CUR);\n        ntags = get2();\n        cur_tag = get2();\n        while (cur_tag != 0x002c)\n        {\n          fseek(ifp, 10, SEEK_CUR);\n          cur_tag = get2();\n        }\n        fseek(ifp, 6, SEEK_CUR);\n        fseek(ifp, get4() + 20, SEEK_SET);\n        stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n        get2();\n        imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n        switch (imgdata.lens.makernotes.LensID)\n        {\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n        case 6:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n          break;\n        case 8:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n          imgdata.lens.makernotes.LensID = -1;\n          break;\n        default:\n          imgdata.lens.makernotes.LensID = -1;\n        }\n        fseek(ifp, 17, SEEK_CUR);\n        stread(imgdata.lens.LensSerial, 12, ifp);\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 2, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        unique_id = imgdata.lens.makernotes.CamID = get4();\n      }\n      else if (tag == 0xa002)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n                                 // a450, a500, a550, a560, a580\n                                 // a33, a35, a55\n                                 // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (table_buf[0] | table_buf[3])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n            if (table_buf[2] | table_buf[5])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n            parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n          }\n        }\n        free(table_buf);\n      }\n\n      else if ((tag == 0x0020) && // WBInfoA100, needs 0xb028 processing\n               !strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 0x49dc, SEEK_CUR);\n        stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 256000) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (table_buf[1] | table_buf[2])\n          imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n        if (table_buf[3] | table_buf[4])\n          imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n        if (table_buf[5])\n          imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n        if (table_buf[6])\n          imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n        parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        free(table_buf);\n      }\n    }\n\n    fseek(ifp, _pos, SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)\n      iso_speed = (get2(), get2());\n    if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))\n    {\n      unsigned char cc;\n      fread(&cc, 1, 1, ifp);\n      iso_speed = int(100.0 * powf64(2.0f, float(cc) / 12.0 - 5.0));\n    }\n    if (tag == 4 && len > 26 && len < 35)\n    {\n      if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n        iso_speed = 50 * powf64(2.0, i / 32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i = (get2(), get2())) != 0x7fff && !aperture)\n        aperture = powf64(2.0, i / 64.0);\n#endif\n      if ((i = get2()) != 0xffff && !shutter)\n        shutter = powf64(2.0, (short)i / -32.0);\n      wbi = (get2(), get2());\n      shot_order = (get2(), get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))\n    {\n      fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);\n      switch (get2())\n      {\n      case 72:\n        flip = 0;\n        break;\n      case 76:\n        flip = 6;\n        break;\n      case 82:\n        flip = 5;\n        break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets(model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make, \"Canon\", 5))\n      fread(artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa)\n    {\n#if 0 /* Canon rotation data is handled by EXIF.Orientation */\n      for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)\n        c = c << 8 | fgetc(ifp);\n      while ((i += 4) < len - 5)\n        if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)\n          flip = \"065\"[c] - '0';\n#endif\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n    if (!strncasecmp(make, \"Olympus\", 7))\n    {\n      short nWB, tWB;\n      if ((tag == 0x20300108) || (tag == 0x20310109))\n        imgdata.makernotes.olympus.ColorSpace = get2();\n\n      if ((tag == 0x20400102) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n      {\n        int i;\n        for (i = 0; i < 64; i++)\n          imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n              imgdata.color.WB_Coeffs[i][3] = 0x100;\n        for (i = 64; i < 256; i++)\n          imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n      }\n      if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n      {\n        ushort CT;\n        nWB = tag - 0x20400102;\n        switch (nWB)\n        {\n        case 0:\n          CT = 3000;\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 1:\n          CT = 3300;\n          tWB = 0x100;\n          break;\n        case 2:\n          CT = 3600;\n          tWB = 0x100;\n          break;\n        case 3:\n          CT = 3900;\n          tWB = 0x100;\n          break;\n        case 4:\n          CT = 4000;\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 5:\n          CT = 4300;\n          tWB = 0x100;\n          break;\n        case 6:\n          CT = 4500;\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 7:\n          CT = 4800;\n          tWB = 0x100;\n          break;\n        case 8:\n          CT = 5300;\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          CT = 6000;\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          CT = 6600;\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          CT = 7500;\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          CT = 0;\n          tWB = 0x100;\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n          imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n          if (len == 4)\n          {\n            imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n            imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n          }\n        }\n        if (tWB != 0x100)\n          FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c + 1];\n      }\n      if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400113;\n        imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n        switch (nWB)\n        {\n        case 0:\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 4:\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 6:\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 8:\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          tWB = 0x100;\n        }\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = imgdata.color.WBCT_Coeffs[nWB][2];\n      }\n\n      if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      if (tag == 0x2040011f)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n      }\n      if (tag == 0x30000120)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      if (tag == 0x30000121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      }\n      if (tag == 0x30000122)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n      }\n      if (tag == 0x30000123)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      }\n      if (tag == 0x30000124)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n      }\n      if (tag == 0x30000130)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      }\n      if (tag == 0x30000131)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      }\n      if (tag == 0x30000132)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      }\n      if (tag == 0x30000133)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      }\n\n      if ((tag == 0x20400805) && (len == 2))\n      {\n        imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);\n        imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n      }\n      if (tag == 0x20200401)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n    }\n    fseek(ifp, _pos2, SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n    }\n    if (tag == 0x14 && type == 7)\n    {\n      if (len == 2560)\n      {\n        fseek(ifp, 1248, SEEK_CUR);\n        goto get2_256;\n      }\n      fread(buf, 1, 10, ifp);\n      if (!strncmp(buf, \"NRW \", 4))\n      {\n        fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);\n        cam_mul[0] = get4() << 2;\n        cam_mul[1] = get4() + get4();\n        cam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread(model, 64, 1, ifp);\n    if (strstr(make, \"PENTAX\"))\n    {\n      if (tag == 0x1b)\n        tag = 0x1018;\n      if (tag == 0x1c)\n        tag = 0x1017;\n    }\n    if (tag == 0x1d)\n    {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n        serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1)\n    { // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;\n      fseek(ifp, 8 + c * 32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4)\n    {\n      data_offset = get4();\n      fseek(ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97)\n    {\n      for (i = 0; i < 4; i++)\n        ver97 = ver97 * 10 + fgetc(ifp) - '0';\n      switch (ver97)\n      {\n      case 100:\n        fseek(ifp, 68, SEEK_CUR);\n        FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n        break;\n      case 102:\n        fseek(ifp, 6, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = get2();\n        break;\n      case 103:\n        fseek(ifp, 16, SEEK_CUR);\n        FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200)\n      {\n        if (ver97 != 205)\n          fseek(ifp, 280, SEEK_CUR);\n        fread(buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7)\n    {\n      order = 0x4949;\n      fseek(ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3)\n    {\n      fseek(ifp, wbi * 48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7)\n    { // shutter count\n      NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n      if ((unsigned)(ver97 - 200) < 17)\n      {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601) // Coolpix A\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n#endif\n    }\n\n    if (tag == 0xb001 && type == 3) // Sony ModelID\n    {\n      unique_id = get2();\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(), get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)\n    {\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black += i;\n    }\n#endif\n    if (tag == 0xe01)\n    { /* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n      int loopc = 0;\n#endif\n      order = 0x4949;\n      fseek(ifp, 22, SEEK_CUR);\n      for (offset = 22; offset + 22 < len; offset += 22 + i)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (loopc++ > 1024)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        tag = get4();\n        fseek(ifp, 14, SEEK_CUR);\n        i = get4() - 4;\n        if (tag == 0x76a43207)\n          flip = get2();\n        else\n          fseek(ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7)\n    {\n      fseek(ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7)\n    {\n      if (len == 614)\n        fseek(ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n        fseek(ifp, 148, SEEK_CUR);\n      else\n        goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i = 0; i < 3; i++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!imgdata.makernotes.olympus.ColorSpace)\n        {\n          FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n        }\n        else\n        {\n          FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;\n        }\n#else\n        FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n#endif\n      }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2)\n    {\n    get2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek(ifp, get4() + base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    if (tag == 0x2010)\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, 0x2010);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n\n    if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) && ((type == 7) || (type == 13)) &&\n        !strncasecmp(make, \"Olympus\", 7))\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, tag);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))\n      parse_thumb_note(base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote(base, 0x2040);\n    if (tag == 0xb028)\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_thumb_note(base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000)\n    {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek(ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i += 18; i <= len; i += 10)\n      {\n        get2();\n        FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n        if (sraw_mul[1] == 1170)\n          break;\n      }\n    }\n    if (!strncasecmp(make, \"Samsung\", 7))\n    {\n      if (tag == 0xa020) // get the full Samsung encryption key\n        for (i = 0; i < 11; i++)\n          SamsungKey[i] = get4();\n      if (tag == 0xa021) // get and decode Samsung cam_mul array\n        FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tag == 0xa023)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n        }\n      }\n      if (tag == 0xa024)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n        }\n      }\n      if (tag == 0xa025)\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = get4() - SamsungKey[0];\n      if (tag == 0xa030 && len == 9)\n        for (i = 0; i < 3; i++)\n          FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n#endif\n      if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix\n        for (i = 0; i < 3; i++)\n          FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n\n      if (tag == 0xa028)\n        FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n    }\n    else\n    {\n      // Somebody else use 0xa021 and 0xa028?\n      if (tag == 0xa021)\n        FORC4 cam_mul[c ^ (c >> 1)] = get4();\n      if (tag == 0xa028)\n        FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n    }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp(int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i = 19; i--;)\n      str[i] = fgetc(ifp);\n  else\n    fread(str, 19, 1, ifp);\n  memset(&t, 0, sizeof t);\n  if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif(int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo, ape;\n\n  kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n  entries = get2();\n  if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > fsize * 2)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n    switch (tag)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n    case 33434:\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n      break;\n    case 33437:\n      aperture = getreal(type);\n      break; // 0x829d FNumber\n    case 34855:\n      iso_speed = get2();\n      break;\n    case 34866:\n      if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n        iso_speed = getreal(type);\n      break;\n    case 36867:\n    case 36868:\n      get_timestamp(0);\n      break;\n    case 37377:\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter = powf64(2.0, expo);\n      break;\n    case 37378: // 0x9202 ApertureValue\n      if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n        aperture = powf64(2.0, ape / 2);\n      break;\n    case 37385:\n      flash_used = getreal(type);\n      break;\n    case 37386:\n      focal_len = getreal(type);\n      break;\n    case 37500: // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))\n      {\n        char mn_text[512];\n        char *pos;\n        char ccms[512];\n        ushort l;\n        float num;\n\n        fgets(mn_text, len, ifp);\n        pos = strstr(mn_text, \"gain_r=\");\n        if (pos)\n          cam_mul[0] = atof(pos + 7);\n        pos = strstr(mn_text, \"gain_b=\");\n        if (pos)\n          cam_mul[2] = atof(pos + 7);\n        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n          cam_mul[1] = cam_mul[3] = 1.0f;\n        else\n          cam_mul[0] = cam_mul[2] = 0.0f;\n\n        pos = strstr(mn_text, \"ccm=\") + 4;\n        l = strstr(pos, \" \") - pos;\n        memcpy(ccms, pos, l);\n        ccms[l] = '\\0';\n\n        pos = strtok(ccms, \",\");\n        for (l = 0; l < 4; l++)\n        {\n          num = 0.0;\n          for (c = 0; c < 3; c++)\n          {\n            imgdata.color.ccm[l][c] = (float)atoi(pos);\n            num += imgdata.color.ccm[l][c];\n            pos = strtok(NULL, \",\");\n          }\n          if (num > 0.01)\n            FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n        }\n      }\n      else\n#endif\n        parse_makernote(base, 0);\n      break;\n    case 40962:\n      if (kodak)\n        raw_width = get4();\n      break;\n    case 40963:\n      if (kodak)\n        raw_height = get4();\n      break;\n    case 41730:\n      if (get4() == 0x20002)\n        for (exif_cfa = c = 0; c < 8; c += 2)\n          exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n    return;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n      imgdata.other.parsed_gps.latref = getc(ifp);\n      break;\n    case 3:\n      imgdata.other.parsed_gps.longref = getc(ifp);\n      break;\n    case 5:\n      imgdata.other.parsed_gps.altref = getc(ifp);\n      break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9:\n      imgdata.other.parsed_gps.gpsstatus = getc(ifp);\n      break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n    case 3:\n    case 5:\n      gpsdata[29 + tag / 2] = getc(ifp);\n      break;\n    case 2:\n    case 4:\n    case 7:\n      FORC(6) gpsdata[tag / 3 * 6 + c] = get4();\n      break;\n    case 6:\n      FORC(2) gpsdata[18 + c] = get4();\n      break;\n    case 18:\n    case 29:\n      fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff(float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] = /* ROMM == Kodak ProPhoto */\n      {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      for (cmatrix[i][j] = k = 0; k < 3; k++)\n        cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos(int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes = 0, frot = 0;\n  static const char *mod[] = {\"\",\n                              \"DCB2\",\n                              \"Volare\",\n                              \"Cantare\",\n                              \"CMost\",\n                              \"Valeo 6\",\n                              \"Valeo 11\",\n                              \"Valeo 22\",\n                              \"Valeo 11p\",\n                              \"Valeo 17\",\n                              \"\",\n                              \"Aptus 17\",\n                              \"Aptus 22\",\n                              \"Aptus 75\",\n                              \"Aptus 65\",\n                              \"Aptus 54S\",\n                              \"Aptus 65S\",\n                              \"Aptus 75S\",\n                              \"AFi 5\",\n                              \"AFi 6\",\n                              \"AFi 7\",\n                              \"AFi-II 7\",\n                              \"Aptus-II 7\",\n                              \"\",\n                              \"Aptus-II 6\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10\",\n                              \"Aptus-II 5\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10R\",\n                              \"Aptus-II 8\",\n                              \"\",\n                              \"Aptus-II 12\",\n                              \"\",\n                              \"AFi-II 12\"};\n  float romm_cam[3][3];\n\n  fseek(ifp, offset, SEEK_SET);\n  while (1)\n  {\n    if (get4() != 0x504b5453)\n      break;\n    get4();\n    fread(data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data, \"CameraObj_camera_type\"))\n    {\n      stmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data, \"back_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.BodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));\n      strcpy(imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data, \"CaptProf_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n      strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n    // IB end\n    if (!strcmp(data, \"JPEG_preview_data\"))\n    {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data, \"icc_camera_profile\"))\n    {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data, \"ShootObj_back_type\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      if ((unsigned)i < sizeof mod / sizeof(*mod))\n        strcpy(model, mod[i]);\n    }\n    if (!strcmp(data, \"icc_camera_to_tone_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        ((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_color_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        fscanf(ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_number_of_planes\"))\n      fscanf(ifp, \"%d\", &planes);\n    if (!strcmp(data, \"CaptProf_raw_data_rotation\"))\n      fscanf(ifp, \"%d\", &flip);\n    if (!strcmp(data, \"CaptProf_mosaic_pattern\"))\n      FORC4\n      {\n        fscanf(ifp, \"%d\", &i);\n        if (i == 1)\n          frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data, \"ImgProf_rotation_angle\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])\n    {\n      FORC4 fscanf(ifp, \"%d\", neut + c);\n      FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];\n    }\n    if (!strcmp(data, \"Rows_data\"))\n      load_flags = get4();\n    parse_mos(from);\n    fseek(ifp, skip + from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];\n}\n\nvoid CLASS linear_table(unsigned len)\n{\n  int i;\n  if (len > 0x10000)\n    len = 0x10000;\n  read_shorts(curve, len);\n  for (i = len; i < 0x10000; i++)\n    curve[i] = curve[i - 1];\n  maximum = curve[len < 0x1000 ? 0xfff : len - 1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags(int wb, unsigned type)\n{\n  float mul[3] = {1, 1, 1}, num, mul2;\n  int c;\n  FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n  mul2 = mul[1] * mul[1];\n  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n  return;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n  //  int a_blck = 0;\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  INT64 fsize = ifp->size();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > 2 * fsize)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n    if (tag == 1011)\n      imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());\n      wbi = -2;\n    }\n\n    if ((tag == 0x03ef) && (!strcmp(model, \"EOS D2000C\")))\n      black = get2();\n    if ((tag == 0x03f0) && (!strcmp(model, \"EOS D2000C\")))\n    {\n      if (black) // already set by tag 0x03ef\n        black = (black + get2()) / 2;\n      else\n        black = get2();\n    }\n    if (tag == 0x0848)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93)\n      imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n          imgdata.color.linear_max[3] = get2();\n    if (tag == 0x09ce)\n      stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n    if (tag == 0xfa00)\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n    if (tag == 0xfa27)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n    }\n    if (tag == 0xfa28)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n    }\n    if (tag == 0xfa29)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n    }\n    if (tag == 0xfa2a)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n    }\n\n    if (tag == 2120 + wbi || (wbi < 0 && tag == 2125)) /* use Auto WB if illuminant index is not set */\n    {\n      FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n      FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n    }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 0x903)\n      iso_speed = getreal(type);\n    // if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2, wbtemp = 6500;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());\n      wbi = -2;\n    }\n    if (tag == 2118)\n      wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3\n      {\n        for (num = i = 0; i < 4; i++)\n          num += getreal(type) * pow(wbtemp / 100.0, i);\n        cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));\n      }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 6020)\n      iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\nint CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff(int base)\n{\n  int doff;\n  fseek(ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d)\n    return 0;\n  get2();\n  while ((doff = get4()))\n  {\n    fseek(ifp, doff + base, SEEK_SET);\n    if (parse_tiff_ifd(base))\n      break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp = 0, ties = 0, raw = -1, thm = -1, i;\n  unsigned long long ns, os;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n      {\n        thumb_misc = jh.bits;\n        thumb_width = jh.wide;\n        thumb_height = jh.high;\n      }\n    }\n  }\n  for (i = tiff_nifds; i--;)\n  {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i = 0; i < tiff_nifds; i++)\n  {\n    if (max_samp < tiff_ifd[i].samples)\n      max_samp = tiff_ifd[i].samples;\n    if (max_samp > 3)\n      max_samp = 3;\n    os = raw_width * raw_height;\n    ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;\n    if (tiff_bps)\n    {\n      os *= tiff_bps;\n      ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&\n        (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))\n    {\n      raw_width = tiff_ifd[i].t_width;\n      raw_height = tiff_ifd[i].t_height;\n      tiff_bps = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size = tiff_ifd[i].bytes;\n#endif\n      tiff_flip = tiff_ifd[i].t_flip;\n      tiff_samples = tiff_ifd[i].samples;\n      tile_width = tiff_ifd[i].t_tile_width;\n      tile_length = tiff_ifd[i].t_tile_length;\n      shutter = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties)\n    is_raw = ties;\n  if (!tile_width)\n    tile_width = INT_MAX;\n  if (!tile_length)\n    tile_length = INT_MAX;\n  for (i = tiff_nifds; i--;)\n    if (tiff_ifd[i].t_flip)\n      tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress)\n    {\n    case 32767:\n      if (tiff_ifd[raw].bytes == raw_width * raw_height)\n      {\n        tiff_bps = 12;\n        load_raw = &CLASS sony_arw2_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)\n      {\n        raw_height += 8;\n        load_raw = &CLASS sony_arw_load_raw;\n        break;\n      }\n      load_flags = 79;\n    case 32769:\n      load_flags++;\n    case 32770:\n    case 32773:\n      goto slr;\n    case 0:\n    case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n      // Sony 14-bit uncompressed\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))\n      {\n        load_raw = &CLASS nikon_coolscan_load_raw;\n        raw_color = 1;\n        filters = 0;\n        break;\n      }\n#endif\n      if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)\n        load_flags = 24;\n      if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)\n      {\n        load_flags = 81;\n        tiff_bps = 12;\n      }\n    slr:\n      switch (tiff_bps)\n      {\n      case 8:\n        load_raw = &CLASS eight_bit_load_raw;\n        break;\n      case 12:\n        if (tiff_ifd[raw].phint == 2)\n          load_flags = 6;\n        load_raw = &CLASS packed_load_raw;\n        break;\n      case 14:\n        load_flags = 0;\n      case 16:\n        load_raw = &CLASS unpacked_load_raw;\n        if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)\n          load_raw = &CLASS olympus_load_raw;\n      }\n      break;\n    case 6:\n    case 7:\n    case 99:\n      load_raw = &CLASS lossless_jpeg_load_raw;\n      break;\n    case 262:\n      load_raw = &CLASS kodak_262_load_raw;\n      break;\n    case 34713:\n      if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 1;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        if (model[0] == 'N')\n          load_flags = 80;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS nikon_yuv_load_raw;\n        gamma_curve(1 / 2.4, 12.92, 1, 4095);\n        memset(cblack, 0, sizeof cblack);\n        filters = 0;\n      }\n      else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS unpacked_load_raw;\n        load_flags = 4;\n        order = 0x4d4d;\n      }\n      else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 80;\n      }\n      else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n               tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n      {\n        int fit = 1;\n        for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last\n          if (tiff_ifd[raw].strip_byte_counts[i] * 2 != tiff_ifd[raw].rows_per_strip * raw_width * 3)\n          {\n            fit = 0;\n            break;\n          }\n        if (fit)\n          load_raw = &CLASS nikon_load_striped_packed_raw;\n        else\n          load_raw = &CLASS nikon_load_raw; // fallback\n      }\n      else\n#endif\n        load_raw = &CLASS nikon_load_raw;\n      break;\n    case 65535:\n      load_raw = &CLASS pentax_load_raw;\n      break;\n    case 65000:\n      switch (tiff_ifd[raw].phint)\n      {\n      case 2:\n        load_raw = &CLASS kodak_rgb_load_raw;\n        filters = 0;\n        break;\n      case 6:\n        load_raw = &CLASS kodak_ycbcr_load_raw;\n        filters = 0;\n        break;\n      case 32803:\n        load_raw = &CLASS kodak_65000_load_raw;\n      }\n    case 32867:\n    case 34892:\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      break;\n#endif\n    default:\n      is_raw = 0;\n    }\n  if (!dng_version)\n    if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||\n         (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && !strcasestr(make, \"Kodak\") && !strstr(model2, \"DEBUG RAW\"))) &&\n        strncmp(software, \"Nikon Scan\", 10))\n      is_raw = 0;\n  for (i = 0; i < tiff_nifds; i++)\n    if (i != raw &&\n        (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >\n            thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&\n        tiff_ifd[i].comp != 34892)\n    {\n      thumb_width = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0)\n  {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp)\n    {\n    case 0:\n      write_thumb = &CLASS layer_thumb;\n      break;\n    case 1:\n      if (tiff_ifd[thm].bps <= 8)\n        write_thumb = &CLASS ppm_thumb;\n      else if (!strncmp(make, \"Imacon\", 6))\n        write_thumb = &CLASS ppm16_thumb;\n      else\n        thumb_load_raw = &CLASS kodak_thumb_load_raw;\n      break;\n    case 65000:\n      thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save = ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if (ifp->wfname())\n  {\n    std::wstring rawfile(ifp->wfname());\n    rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");\n    if (!ifp->subfile_open(rawfile.c_str()))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n  if (!ifp->fname())\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n\n  ext = strrchr(ifname, '.');\n  file = strrchr(ifname, '/');\n  if (!file)\n    file = strrchr(ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file)\n    file = ifname - 1;\n#else\n  if (!file)\n    file = (char *)ifname - 1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext - file != 8)\n    return;\n  jname = (char *)malloc(strlen(ifname) + 1);\n  merror(jname, \"parse_external_jpeg()\");\n  strcpy(jname, ifname);\n  jfile = file - ifname + jname;\n  jext = ext - ifname + jname;\n  if (strcasecmp(ext, \".jpg\"))\n  {\n    strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");\n    if (isdigit(*file))\n    {\n      memcpy(jfile, file + 4, 4);\n      memcpy(jfile + 4, file, 4);\n    }\n  }\n  else\n    while (isdigit(*--jext))\n    {\n      if (*jext != '9')\n      {\n        (*jext)++;\n        break;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp(jname, ifname))\n  {\n    if ((ifp = fopen(jname, \"rb\")))\n    {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose(ifp);\n    }\n  }\n#else\n  if (strcmp(jname, ifname))\n  {\n    if (!ifp->subfile_open(jname))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n  }\n#endif\n  if (!timestamp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n  }\n  free(jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = {0x410, 0x45f3};\n  int i, bpp, row, col, vbits = 0;\n  unsigned long bitbuf = 0;\n\n  if ((get2(), get4()) != 0x80008 || !get4())\n    return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12)\n    return;\n  for (i = row = 0; row < 8; row++)\n    for (col = 0; col < 8; col++)\n    {\n      if (vbits < bpp)\n      {\n        bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n        vbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff(int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi = -1;\n  ushort key[] = {0x410, 0x45f3};\n\n  fseek(ifp, offset + length - 4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek(ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127)\n    return;\n  while (nrecs--)\n  {\n    type = get2();\n    len = get4();\n    save = ftell(ifp) + 4;\n    fseek(ifp, offset + get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n    {\n      parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004)\n      parse_ciff(ftell(ifp), len, depth + 1);\n#endif\n    if (type == 0x0810)\n      fread(artist, 64, 1, ifp);\n    if (type == 0x080a)\n    {\n      fread(make, 64, 1, ifp);\n      fseek(ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread(model, 64, 1, ifp);\n    }\n    if (type == 0x1810)\n    {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835) /* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007)\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818)\n    {\n      shutter = powf64(2.0f, -int_to_float((get4(), get4())));\n      aperture = powf64(2.0f, int_to_float(get4()) / 2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a)\n    {\n      //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture = _CanonConvertAperture((get2(), get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture = powf64(2.0, (get2(), (short)get2()) / 64.0);\n#endif\n      shutter = powf64(2.0, -((short)get2()) / 32.0);\n      wbi = (get2(), get2());\n      if (wbi > 17)\n        wbi = 0;\n      fseek(ifp, 32, SEEK_CUR);\n      if (shutter > 1e6)\n        shutter = get2() / 10.0;\n    }\n    if (type == 0x102c)\n    {\n      if (get2() > 512)\n      { /* Pro90, G1 */\n        fseek(ifp, 118, SEEK_CUR);\n        FORC4 cam_mul[c ^ 2] = get2();\n      }\n      else\n      { /* G2, S30, S40 */\n        fseek(ifp, 98, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n    {\n      INT64 o = ftell(ifp);\n      fseek(ifp, (0x5 << 1), SEEK_CUR);\n      Canon_WBpresets(0, 0);\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x102d)\n    {\n      INT64 o = ftell(ifp);\n      Canon_CameraSettings();\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x580b)\n    {\n      if (strcmp(model, \"Canon EOS D30\"))\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n      else\n        sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);\n    }\n#endif\n    if (type == 0x0032)\n    {\n      if (len == 768)\n      { /* EOS D30 */\n        fseek(ifp, 72, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n        if (!wbi)\n          cam_mul[0] = -1; /* use my auto white balance */\n      }\n      else if (!cam_mul[0])\n      {\n        if (get2() == key[0]) /* Pro1, G6, S60, S70 */\n          c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;\n        else\n        { /* G3, G5, S45, S50 */\n          c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';\n          key[0] = key[1] = 0;\n        }\n        fseek(ifp, 78 + c * 8, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n        if (!wbi)\n          cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9)\n    { /* D60, 10D, 300D, and clones */\n      if (len > 66)\n        wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';\n      fseek(ifp, 2 + wbi * 8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))\n      ciff_block_1030(); /* all that don't have 0x10a9 */\n    if (type == 0x1031)\n    {\n      raw_width = (get2(), get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c)\n    {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2)\n      {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n        if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n          imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2)\n        focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813)\n      flash_used = int_to_float(len);\n    if (type == 0x5814)\n      canon_ev = int_to_float(len);\n    if (type == 0x5817)\n      shot_order = len;\n    if (type == 0x5834)\n    {\n      unique_id = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n      setCanonBodyFeatures(unique_id);\n#endif\n    }\n    if (type == 0x580e)\n      timestamp = len;\n    if (type == 0x180e)\n      timestamp = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime(gmtime(&timestamp));\n#endif\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek(ifp, 0, SEEK_SET);\n  memset(&t, 0, sizeof t);\n  do\n  {\n    fgets(line, 128, ifp);\n    if ((val = strchr(line, '=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line, \"DAT\"))\n      sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line, \"TIM\"))\n      sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line, \"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line, \"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line, \"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line, \"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line, \"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line, \"EOHD\", 4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy(make, \"Rollei\");\n  strcpy(model, \"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek(ifp, get4(), SEEK_SET);\n  while (entries--)\n  {\n    off = get4();\n    get4();\n    fread(str, 8, 1, ifp);\n    if (!strcmp(str, \"META\"))\n      meta_offset = off;\n    if (!strcmp(str, \"THUMB\"))\n      thumb_offset = off;\n    if (!strcmp(str, \"RAW0\"))\n      data_offset = off;\n  }\n  fseek(ifp, meta_offset + 20, SEEK_SET);\n  fread(make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make, ' ')))\n  {\n    strcpy(model, cp + 1);\n    *cp = 0;\n  }\n  raw_width = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(), get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one(int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset(&ph1, 0, sizeof ph1);\n  fseek(ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177)\n    return; /* \"Raw\" */\n  fseek(ifp, get4() + base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--)\n  {\n    tag = get4();\n    type = get4();\n    len = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek(ifp, base + data, SEEK_SET);\n    switch (tag)\n    {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      }\n      else\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4)\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (int_to_float(data) / 2.0f));\n      else\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x0403:\n      if (type == 4)\n        imgdata.lens.makernotes.CurFocal = int_to_float(data);\n      else\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n      {\n        imgdata.lens.makernotes.MinFocal = 0.0f;\n      }\n      break;\n    case 0x0417:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n    case 0x100:\n      flip = \"0653\"[data & 3] - '0';\n      break;\n    case 0x106:\n      for (i = 0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.P1_color[0].romm_cam[i] =\n#endif\n            ((float *)romm_cam)[i] = getreal(11);\n      romm_coeff(romm_cam);\n      break;\n    case 0x107:\n      FORC3 cam_mul[c] = getreal(11);\n      break;\n    case 0x108:\n      raw_width = data;\n      break;\n    case 0x109:\n      raw_height = data;\n      break;\n    case 0x10a:\n      left_margin = data;\n      break;\n    case 0x10b:\n      top_margin = data;\n      break;\n    case 0x10c:\n      width = data;\n      break;\n    case 0x10d:\n      height = data;\n      break;\n    case 0x10e:\n      ph1.format = data;\n      break;\n    case 0x10f:\n      data_offset = data + base;\n      break;\n    case 0x110:\n      meta_offset = data + base;\n      meta_length = len;\n      break;\n    case 0x112:\n      ph1.key_off = save - 4;\n      break;\n    case 0x210:\n      ph1.tag_210 = int_to_float(data);\n      break;\n    case 0x21a:\n      ph1.tag_21a = data;\n      break;\n    case 0x21c:\n      strip_offset = data + base;\n      break;\n    case 0x21d:\n      ph1.t_black = data;\n      break;\n    case 0x222:\n      ph1.split_col = data;\n      break;\n    case 0x223:\n      ph1.black_col = data + base;\n      break;\n    case 0x224:\n      ph1.split_row = data;\n      break;\n    case 0x225:\n      ph1.black_row = data + base;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x226:\n      for (i = 0; i < 9; i++)\n        imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n      break;\n#endif\n    case 0x301:\n      model[63] = 0;\n      fread(model, 1, 63, ifp);\n      if ((cp = strstr(model, \" camera\")))\n        *cp = 0;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek(ifp, 6, SEEK_CUR);\n    fseek(ifp, meta_offset + get4(), SEEK_SET);\n    entries = get4();\n    get4();\n    while (entries--)\n    {\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x0407)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        }\n        else\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy(make, \"Phase One\");\n  if (model[0])\n    return;\n  switch (raw_height)\n  {\n  case 2060:\n    strcpy(model, \"LightPhase\");\n    break;\n  case 2682:\n    strcpy(model, \"H 10\");\n    break;\n  case 4128:\n    strcpy(model, \"H 20\");\n    break;\n  case 5488:\n    strcpy(model, \"H 25\");\n    break;\n  }\n}\n\nvoid CLASS parse_fuji(int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek(ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255)\n    return;\n  while (entries--)\n  {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100)\n    {\n      raw_height = get2();\n      raw_width = get2();\n    }\n    else if (tag == 0x121)\n    {\n      height = get2();\n      if ((width = get2()) == 4284)\n        width += 3;\n    }\n    else if (tag == 0x130)\n    {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    }\n    else if (tag == 0x131)\n    {\n      filters = 9;\n      FORC(36) xtrans_abs[0][35 - c] = fgetc(ifp) & 3;\n    }\n    else if (tag == 0x2ff0)\n    {\n      FORC4 cam_mul[c ^ 1] = get2();\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b = fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    }\n    else if (tag == 0x2100)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    }\n    else if (tag == 0x2200)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    }\n    else if (tag == 0x2300)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    }\n    else if (tag == 0x2301)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    }\n    else if (tag == 0x2302)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    }\n    else if (tag == 0x2310)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    }\n    else if (tag == 0x2400)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n#endif\n      // IB end\n    }\n    else if (tag == 0xc000)\n    {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000)\n        tag = get4();\n      if (tag > 10000)\n        tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);\n#endif\n      order = c;\n    }\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width >>= fuji_layout;\n}\n\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  struct tm t;\n\n  order = 0x4949;\n  fread(tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))\n  {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  }\n  else if (!memcmp(tag, \"nctg\", 4))\n  {\n    while (ftell(ifp) + 7 < end)\n    {\n      i = get2();\n      size = get2();\n      if ((i + 1) >> 1 == 10 && size == 20)\n        get_timestamp(0);\n      else\n        fseek(ifp, size, SEEK_CUR);\n    }\n  }\n  else if (!memcmp(tag, \"IDIT\", 4) && size < 64)\n  {\n    fread(date, 64, 1, ifp);\n    date[size] = 0;\n    memset(&t, 0, sizeof t);\n    if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)\n    {\n      for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)\n        ;\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n        timestamp = mktime(&t);\n    }\n  }\n  else\n    fseek(ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"SMaL\");\n  sprintf(model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek(ifp, 52, SEEK_SET);\n  width = get4();\n  height = get4();\n  fseek(ifp, 0, SEEK_END);\n  fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek(ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF)\n    {\n      if (get4() == 0x52454456)\n        if (is_raw++ == shot_select)\n          data_offset = ftello(ifp) - 8;\n      fseek(ifp, len - 8, SEEK_CUR);\n    }\n  }\n  else\n  {\n    rdvo = get4();\n    fseek(ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff(const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n                       ,\n                       int internal_only\n#endif\n                       )\n{\n  // clang-format off\n  static const struct\n  {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X Mark II\", 0, 0, /* temp */\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100F\", 0, 0,\n      {11434,-4948,-1210,-3746,12042,1903,-666,1479,5235}},\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T20\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526}},\n    { \"Fujifilm GFX 50S\", 0, 0,\n      {11940,-4431,-1255,-6766,14428,2542,-994,1165,7421}},\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D5600\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax KP\", 0, 0,  /* temp */\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n\n    { \"Panasonic DC-FZ82\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-FZ80\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0, /* 40,42,45 */\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n\n    { \"Panasonic DC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  // clang-format on\n\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if (colors > 4 || colors < 1)\n    return;\n\n  int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;\n  if (cblack[4] * cblack[5] > 0)\n  {\n    for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n      bl64 += cblack[c + 6];\n    bl64 /= cblack[4] * cblack[5];\n  }\n  int rblack = black + bl4 + bl64;\n\n  sprintf(name, \"%s %s\", t_make, t_model);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))\n    {\n      if (!dng_version)\n      {\n        if (table[i].t_black > 0)\n        {\n          black = (ushort)table[i].t_black;\n          memset(cblack, 0, sizeof(cblack));\n        }\n        else if (table[i].t_black < 0 && rblack == 0)\n        {\n          black = (ushort)(-table[i].t_black);\n          memset(cblack, 0, sizeof(cblack));\n        }\n        if (table[i].t_maximum)\n          maximum = (ushort)table[i].t_maximum;\n      }\n      if (table[i].trans[0])\n      {\n        for (raw_color = j = 0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (internal_only)\n            imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n          else\n            imgdata.color.cam_xyz[0][j] =\n#endif\n                ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!internal_only)\n#endif\n          cam_xyz_coeff(rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff(int index)\n{\n  static const float table[][12] = {/* index 0 -- all Foveon cameras */\n                                    {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},\n                                    /* index 1 -- Kodak DC20 and DC25 */\n                                    {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},\n                                    /* index 2 -- Logitech Fotoman Pixtura */\n                                    {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},\n                                    /* index 3 -- Nikon E880, E900, and E990 */\n                                    {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,\n                                     -1.204965, 1.082304, 2.941367, -1.818705}};\n  int i, c;\n\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i * colors + c];\n}\n\nshort CLASS guess_byte_order(int words)\n{\n  uchar test[4][2];\n  int t = 2, msb;\n  double diff, sum[2] = {0, 0};\n\n  fread(test[0], 2, 2, ifp);\n  for (words -= 2; words--;)\n  {\n    fread(test[t], 2, 1, ifp);\n    for (msb = 0; msb < 2; msb++)\n    {\n      diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);\n      sum[msb] += diff * diff;\n    }\n    t = (t + 1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n\n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  return 100 * log(sum[0] / sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if (len < 1)\n    return; // not needed, b/c sizeof of make/model is 64\n  string[len - 1] = 0;\n  if (len < 3)\n    return; // also not needed\n  len = strnlen(string, len - 1);\n  for (int i = len - 1; i >= 0; i--)\n  {\n    if (isspace(string[i]))\n      string[i] = 0;\n    else\n      break;\n  }\n}\n\nvoid CLASS initdata()\n{\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n  for (int i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n}\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n      {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},\n      {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},\n      {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},\n      {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},\n      {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},\n      {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},\n      {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},\n      {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},\n  };\n  static const ushort canon[][11] = {\n      {1944, 1416, 0, 0, 48, 0},\n      {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},\n      {2224, 1456, 48, 6, 0, 2},\n      {2376, 1728, 12, 6, 52, 2},\n      {2672, 1968, 12, 6, 44, 2},\n      {3152, 2068, 64, 12, 0, 0, 16},\n      {3160, 2344, 44, 12, 4, 4},\n      {3344, 2484, 4, 6, 52, 6},\n      {3516, 2328, 42, 14, 0, 0},\n      {3596, 2360, 74, 12, 0, 0},\n      {3744, 2784, 52, 12, 8, 12},\n      {3944, 2622, 30, 18, 6, 2},\n      {3948, 2622, 42, 18, 0, 2},\n      {3984, 2622, 76, 20, 0, 2, 14},\n      {4104, 3048, 48, 12, 24, 12},\n      {4116, 2178, 4, 2, 0, 0},\n      {4152, 2772, 192, 12, 0, 0},\n      {4160, 3124, 104, 11, 8, 65},\n      {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},\n      {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},\n      {4312, 2876, 22, 18, 0, 2},\n      {4352, 2874, 62, 18, 0, 0},\n      {4476, 2954, 90, 34, 0, 0},\n      {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},\n      {4480, 3366, 80, 50, 0, 0},\n      {4496, 3366, 80, 50, 12, 0},\n      {4768, 3516, 96, 16, 0, 0, 0, 16},\n      {4832, 3204, 62, 26, 0, 0},\n      {4832, 3228, 62, 51, 0, 0},\n      {5108, 3349, 98, 13, 0, 0},\n      {5120, 3318, 142, 45, 62, 0},\n      {5280, 3528, 72, 52, 0, 0}, /* EOS M */\n      {5344, 3516, 142, 51, 0, 0},\n      {5344, 3584, 126, 100, 0, 2},\n      {5360, 3516, 158, 51, 0, 0},\n      {5568, 3708, 72, 38, 0, 0},\n      {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},\n      {5712, 3774, 62, 20, 10, 2},\n      {5792, 3804, 158, 51, 0, 0},\n      {5920, 3950, 122, 80, 2, 0},\n      {6096, 4056, 72, 34, 0, 0},  /* EOS M3 */\n      {6288, 4056, 266, 36, 0, 0}, /* EOS 80D */\n      {6880, 4544, 136, 42, 0, 0}, /* EOS 5D4 */\n      {8896, 5920, 160, 64, 0, 0},\n  };\n  static const struct\n  {\n    ushort id;\n    char t_model[20];\n  } unique[] =\n      {\n          {0x001, \"EOS-1D\"},\n          {0x167, \"EOS-1DS\"},\n          {0x168, \"EOS 10D\"},\n          {0x169, \"EOS-1D Mark III\"},\n          {0x170, \"EOS 300D\"},\n          {0x174, \"EOS-1D Mark II\"},\n          {0x175, \"EOS 20D\"},\n          {0x176, \"EOS 450D\"},\n          {0x188, \"EOS-1Ds Mark II\"},\n          {0x189, \"EOS 350D\"},\n          {0x190, \"EOS 40D\"},\n          {0x213, \"EOS 5D\"},\n          {0x215, \"EOS-1Ds Mark III\"},\n          {0x218, \"EOS 5D Mark II\"},\n          {0x232, \"EOS-1D Mark II N\"},\n          {0x234, \"EOS 30D\"},\n          {0x236, \"EOS 400D\"},\n          {0x250, \"EOS 7D\"},\n          {0x252, \"EOS 500D\"},\n          {0x254, \"EOS 1000D\"},\n          {0x261, \"EOS 50D\"},\n          {0x269, \"EOS-1D X\"},\n          {0x270, \"EOS 550D\"},\n          {0x281, \"EOS-1D Mark IV\"},\n          {0x285, \"EOS 5D Mark III\"},\n          {0x286, \"EOS 600D\"},\n          {0x287, \"EOS 60D\"},\n          {0x288, \"EOS 1100D\"},\n          {0x289, \"EOS 7D Mark II\"},\n          {0x301, \"EOS 650D\"},\n          {0x302, \"EOS 6D\"},\n          {0x324, \"EOS-1D C\"},\n          {0x325, \"EOS 70D\"},\n          {0x326, \"EOS 700D\"},\n          {0x327, \"EOS 1200D\"},\n          {0x328, \"EOS-1D X Mark II\"},\n          {0x331, \"EOS M\"},\n          {0x335, \"EOS M2\"},\n          {0x374, \"EOS M3\"},  /* temp */\n          {0x384, \"EOS M10\"}, /* temp */\n          {0x394, \"EOS M5\"},  /* temp */\n          {0x346, \"EOS 100D\"},\n          {0x347, \"EOS 760D\"},\n          {0x349, \"EOS 5D Mark IV\"},\n          {0x350, \"EOS 80D\"},\n          {0x382, \"EOS 5DS\"},\n          {0x393, \"EOS 750D\"},\n          {0x401, \"EOS 5DS R\"},\n          {0x404, \"EOS 1300D\"},\n      },\n    sonique[] = {\n        {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},\n        {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},\n        {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},\n        {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},\n        {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},\n        {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},\n        {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},\n        {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},\n        {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},\n        {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},\n        {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},\n        {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},\n        {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},\n        {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},\n        {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},\n        {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},\n        {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x168, \"ILCE-6500\"},\n    };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t const_table[]\n#else\n  static const struct\n  {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  } table[]\n#endif\n      = {\n          {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},\n          {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},\n          {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},\n          {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},\n          {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},\n          {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},\n          {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},\n          //   Android Raw dumps id start\n          //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n          {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},\n          {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},\n          {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},\n          {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},\n          {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},\n          {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},\n          {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},\n          {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},\n          {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},\n          {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},\n          {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},\n          {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},\n          {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},\n          {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},\n          {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},\n          {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},\n          {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},\n          {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},\n          {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},\n          {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},\n          {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},\n          {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},\n          {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},\n          {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},\n          {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},\n          {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},\n          {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},\n          {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},\n          {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},\n          {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},\n          //   Android Raw dumps id end\n          {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},\n          {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},\n          {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},\n          {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},\n          {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},\n          {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},\n          {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},\n          {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},\n          {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},\n          {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},\n          {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},\n          {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},\n          {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},\n          {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},\n          {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},\n          {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},\n          {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},\n          {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},\n          {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},\n          {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},\n          {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},\n          {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},\n          {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},\n          {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},\n          {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},\n          {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},\n          {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},\n          {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},\n          {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},\n          {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},\n          {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},\n          {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},\n          {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},\n          {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},\n          {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},\n          {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},\n          {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},\n          {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},\n          {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},\n          {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},\n          {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},\n          {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},\n          {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},\n          {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},\n          {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},\n          {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},\n          {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},\n          {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},\n          {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},\n          {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},\n          {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},\n          {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},\n          {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},\n          {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},\n          {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},\n          {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},\n          {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},\n          {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},\n          {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},\n          {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},\n          {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},\n          {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},\n          {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},\n          {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},\n          {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},\n          {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},\n          {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},\n          {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},\n          {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},\n          {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},\n          {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},\n          {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},\n          {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},\n          {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},\n          {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},\n          {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},\n          {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},\n          {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n          {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n      };\n#ifdef LIBRAW_LIBRARY_BUILD\n  libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",\n                               \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",\n                               \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize = 1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);\n  for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)\n    memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));\n  camera_count += sizeof(const_table) / sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n#ifdef LIBRAW_LIBRARY_BUILD\n  for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n#endif\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n  for (i = 0; i < 4; i++)\n  {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i = 0; i < 0x10000; i++)\n    curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek(ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread(head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread(head, 1, 32, ifp);\n#endif\n  fseek(ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))\n  {\n    parse_phase_one(cp - head);\n    if (cp - head && parse_tiff(0))\n      apply_tiff();\n  }\n  else if (order == 0x4949 || order == 0x4d4d)\n  {\n    if (!memcmp(head + 6, \"HEAPCCDR\", 8))\n    {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(hlen, flen - hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    }\n    else if (parse_tiff(0))\n      apply_tiff();\n  }\n  else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))\n  {\n    fseek(ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek(ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  }\n  else if (!memcmp(head + 25, \"ARECOYK\", 7))\n  {\n    strcpy(make, \"Contax\");\n    strcpy(model, \"N Digital\");\n    fseek(ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek(ifp, 52, SEEK_SET);\n    switch (get4())\n    {\n    case 7:\n      iso_speed = 25;\n      break;\n    case 8:\n      iso_speed = 32;\n      break;\n    case 9:\n      iso_speed = 40;\n      break;\n    case 10:\n      iso_speed = 50;\n      break;\n    case 11:\n      iso_speed = 64;\n      break;\n    case 12:\n      iso_speed = 80;\n      break;\n    case 13:\n      iso_speed = 100;\n      break;\n    case 14:\n      iso_speed = 125;\n      break;\n    case 15:\n      iso_speed = 160;\n      break;\n    case 16:\n      iso_speed = 200;\n      break;\n    case 17:\n      iso_speed = 250;\n      break;\n    case 18:\n      iso_speed = 320;\n      break;\n    case 19:\n      iso_speed = 400;\n      break;\n    }\n    shutter = powf64(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek(ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek(ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  }\n  else if (!strcmp(head, \"PXN\"))\n  {\n    strcpy(make, \"Logitech\");\n    strcpy(model, \"Fotoman Pixtura\");\n  }\n  else if (!strcmp(head, \"qktk\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  }\n  else if (!strcmp(head, \"qktn\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  }\n  else if (!memcmp(head, \"FUJIFILM\", 8))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head + 0x1c);\n    memcpy(model2, head + 0x3c, 4);\n    model2[4] = 0;\n#endif\n    fseek(ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek(ifp, 92, SEEK_SET);\n    parse_fuji(get4());\n    if (thumb_offset > 120)\n    {\n      fseek(ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) ? 1 : 0;\n      if (is_raw == 2 && shot_select)\n        parse_fuji(i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);\n    parse_tiff(data_offset = get4());\n    parse_tiff(thumb_offset + 12);\n    apply_tiff();\n  }\n  else if (!memcmp(head, \"RIFF\", 4))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_riff();\n  }\n  else if (!memcmp(head + 4, \"ftypqt   \", 9))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_qt(fsize);\n    is_raw = 0;\n  }\n  else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))\n  {\n    fseek(ifp, 6, SEEK_SET);\n    fread(make, 1, 8, ifp);\n    fread(model, 1, 8, ifp);\n    fread(model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"NOKIARAW\", 8))\n  {\n    strcpy(make, \"NOKIA\");\n    order = 0x4949;\n    fseek(ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i * 8 / (width * height))\n    {\n    case 8:\n      load_raw = &CLASS eight_bit_load_raw;\n      break;\n    case 10:\n      load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"ARRI\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy(make, \"ARRI\");\n    fseek(ifp, 668, SEEK_SET);\n    fread(model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"XPDS\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 0x800, SEEK_SET);\n    fread(make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width = get2();\n    fseek(ifp, 56, SEEK_CUR);\n    fread(model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve(0, 12.25, 1, 1023);\n  }\n  else if (!memcmp(head + 4, \"RED1\", 4))\n  {\n    strcpy(make, \"Red\");\n    strcpy(model, \"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve(1 / 2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  }\n  else if (!memcmp(head, \"DSC-Image\", 9))\n    parse_rollei();\n  else if (!memcmp(head, \"PWAD\", 4))\n    parse_sinar_ia();\n  else if (!memcmp(head, \"\\0MRM\", 4))\n    parse_minolta(0);\n  else if (!memcmp(head, \"FOVb\", 4))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      parse_foveon();\n    else\n#endif\n      parse_x3f();\n#else\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    parse_foveon();\n#endif\n#endif\n  }\n  else if (!memcmp(head, \"CI\", 2))\n    parse_cine();\n  if (make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize = i = 0; i < camera_count; i++)\n#else\n    for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize)\n      {\n        strcpy(make, table[i].t_make);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\", 5))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n#endif\n        strcpy(model, table[i].t_model);\n        flip = table[i].flags >> 2;\n        zero_is_bad = table[i].flags & 2;\n        if (table[i].flags & 1)\n          parse_external_jpeg();\n        data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;\n        raw_width = table[i].rw;\n        raw_height = table[i].rh;\n        left_margin = table[i].lm;\n        top_margin = table[i].tm;\n        width = raw_width - left_margin - table[i].rm;\n        height = raw_height - top_margin - table[i].bm;\n        filters = 0x1010101 * table[i].cf;\n        colors = 4 - !((filters & filters >> 1) & 0x5555);\n        load_flags = table[i].lf;\n        switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))\n        {\n        case 6:\n          load_raw = &CLASS minolta_rd175_load_raw;\n          break;\n        case 8:\n          load_raw = &CLASS eight_bit_load_raw;\n          break;\n        case 10:\n          if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)\n          {\n            load_raw = &CLASS android_loose_load_raw;\n            break;\n          }\n          else if (load_flags & 1)\n          {\n            load_raw = &CLASS android_tight_load_raw;\n            break;\n          }\n        case 12:\n          load_flags |= 128;\n          load_raw = &CLASS packed_load_raw;\n          break;\n        case 16:\n          order = 0x4949 | 0x404 * (load_flags & 1);\n          tiff_bps -= load_flags >> 4;\n          tiff_bps -= load_flags = load_flags >> 1 & 7;\n          load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;\n        }\n        maximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize)\n    fsize = 0;\n  if (make[0] == 0)\n    parse_smal(0, flen);\n  if (make[0] == 0)\n  {\n    parse_jpeg(0);\n    fseek(ifp, 0, SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&\n        fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      strcpy(model, \"RPi IMX219\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 66;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    }\n    else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&\n             !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      if (!strncmp(model, \"ov5647\", 6))\n        strcpy(model, \"RPi OV5647 v.1\");\n      else\n        strcpy(model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 16;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&\n        fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))\n    {\n      strcpy(make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000 - 32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    }\n    else\n      is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i = 0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr(make, corp[i])) /* Simplify company names */\n      strcpy(make, corp[i]);\n  if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&\n      ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))\n    *cp = 0;\n  if (!strncasecmp(model, \"PENTAX\", 6))\n    strcpy(make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make, sizeof(make));\n  remove_trailing_spaces(model, sizeof(model));\n#else\n  cp = make + strlen(make); /* Remove trailing spaces */\n  while (*--cp == ' ')\n    *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ')\n    *cp = 0;\n#endif\n  i = strbuflen(make); /* Remove make from model */\n  if (!strncasecmp(model, make, i) && model[i++] == ' ')\n    memmove(model, model + i, 64 - i);\n  if (!strncmp(model, \"FinePix \", 8))\n    strcpy(model, model + 8);\n  if (!strncmp(model, \"Digital Camera \", 15))\n    strcpy(model, model + 15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw)\n    goto notraw;\n\n  if (!height)\n    height = raw_height;\n  if (!width)\n    width = raw_width;\n  if (height == 2624 && width == 3936) /* Pentax K10D and Samsung GX10 */\n  {\n    height = 2616;\n    width = 3896;\n  }\n  if (height == 3136 && width == 4864) /* Pentax K20D and Samsung GX20 */\n  {\n    height = 3124;\n    width = 4688;\n    filters = 0x16161616;\n  }\n  if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))\n  {\n    width = 4309;\n    filters = 0x16161616;\n  }\n  if (width >= 4960 && !strncmp(model, \"K-5\", 3))\n  {\n    left_margin = 10;\n    width = 4950;\n    filters = 0x16161616;\n  }\n  if (width == 6080 && !strcmp(model, \"K-70\"))\n  {\n    height = 4016;\n    top_margin = 32;\n    width = 6020;\n    left_margin = 60;\n  }\n  if (width == 4736 && !strcmp(model, \"K-7\"))\n  {\n    height = 3122;\n    width = 4684;\n    filters = 0x16161616;\n    top_margin = 2;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3 II\")) /* moved back */\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3\"))\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 7424 && !strcmp(model, \"645D\"))\n  {\n    height = 5502;\n    width = 7328;\n    filters = 0x61616161;\n    top_margin = 29;\n    left_margin = 48;\n  }\n  if (height == 3014 && width == 4096) /* Ricoh GX200 */\n    width = 4014;\n  if (dng_version)\n  {\n    if (filters == UINT_MAX)\n      filters = 0;\n    if (filters)\n      is_raw *= tiff_samples;\n    else\n      colors = tiff_samples;\n    switch (tiff_compress)\n    {\n    case 0: /* Compression not set, assuming uncompressed */\n    case 1:\n      load_raw = &CLASS packed_dng_load_raw;\n      break;\n    case 7:\n      load_raw = &CLASS lossless_dng_load_raw;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      load_raw = &CLASS deflate_dng_load_raw;\n      break;\n#endif\n    case 34892:\n      load_raw = &CLASS lossy_dng_load_raw;\n      break;\n    default:\n      load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\", 5) && unique_id)\n    {\n      for (i = 0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n        {\n          strcpy(model, unique[i].t_model);\n          break;\n        }\n    }\n    if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n    {\n      for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n        {\n          strcpy(model, sonique[i].t_model);\n          break;\n        }\n    }\n    goto dng_skip;\n  }\n  if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)\n  {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i = 0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1])\n      {\n        width = raw_width - (left_margin = canon[i][2]);\n        height = raw_height - (top_margin = canon[i][3]);\n        width -= canon[i][4];\n        height -= canon[i][5];\n        mask[0][1] = canon[i][6];\n        mask[0][3] = -canon[i][7];\n        mask[1][1] = canon[i][8];\n        mask[1][3] = -canon[i][9];\n        if (canon[i][10])\n          filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000)\n    {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make, \"Canon\", 5) && unique_id)\n  {\n    for (i = 0; i < sizeof unique / sizeof *unique; i++)\n      if (unique_id == 0x80000000 + unique[i].id)\n      {\n        adobe_coeff(\"Canon\", unique[i].t_model);\n        strcpy(model, unique[i].t_model);\n      }\n  }\n\n  if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n  {\n    for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n      if (unique_id == sonique[i].id)\n      {\n        adobe_coeff(\"Sony\", sonique[i].t_model);\n        strcpy(model, sonique[i].t_model);\n      }\n  }\n\n  if (!strncmp(make, \"Nikon\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n  /* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)\n  {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy(model, \"C603\");\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n#else\n  /* Always 512 for arw2_load_raw */\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = (load_raw == &LibRaw::sony_arw2_load_raw) ? 512 : (128 << (tiff_bps - 12));\n#endif\n\n  if (is_foveon)\n  {\n    if (height * 2 < width)\n      pixel_aspect = 0.5;\n    if (height > width)\n      pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if (!strncmp(make, \"Pentax\", 6))\n  {\n    if (!strncmp(model, \"K-1\", 3))\n    {\n      top_margin = 18;\n      height = raw_height - top_margin;\n      if (raw_width == 7392)\n      {\n        left_margin = 6;\n        width = 7376;\n      }\n    }\n  }\n  else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)\n  {\n    switch (width)\n    {\n    case 3344:\n      width -= 66;\n    case 3872:\n      width -= 6;\n    }\n    if (height > width)\n    {\n      SWAP(height, width);\n      SWAP(raw_height, raw_width);\n    }\n    if (width == 7200 && height == 3888)\n    {\n      raw_width = width = 6480;\n      raw_height = height = 4320;\n    }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot 600\"))\n  {\n    height = 613;\n    width = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))\n  {\n    height = 773;\n    width = 960;\n    raw_width = 992;\n    pixel_aspect = 256 / 235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot A50\"))\n  {\n    height = 968;\n    width = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot Pro70\"))\n  {\n    height = 1024;\n    width = 1552;\n    filters = 0x1e4b4e1b;\n  canon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  }\n  else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))\n  {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  }\n  else if (!strcmp(model, \"PowerShot A610\"))\n  {\n    if (canon_s2is())\n      strcpy(model + 10, \"S2 IS\");\n  }\n  else if (!strcmp(model, \"PowerShot SX220 HS\"))\n  {\n    mask[1][3] = -4;\n    top_margin = 16;\n    left_margin = 92;\n  }\n  else if (!strcmp(model, \"PowerShot S120\"))\n  {\n    raw_width = 4192;\n    raw_height = 3062;\n    width = 4022;\n    height = 3016;\n    mask[0][0] = top_margin = 31;\n    mask[0][2] = top_margin + height;\n    left_margin = 120;\n    mask[0][1] = 23;\n    mask[0][3] = 72;\n  }\n  else if (!strcmp(model, \"PowerShot G16\"))\n  {\n    mask[0][0] = 0;\n    mask[0][2] = 80;\n    mask[0][1] = 0;\n    mask[0][3] = 16;\n    top_margin = 29;\n    left_margin = 120;\n    width = raw_width - left_margin - 48;\n    height = raw_height - top_margin - 14;\n  }\n  else if (!strcmp(model, \"PowerShot SX50 HS\"))\n  {\n    top_margin = 17;\n  }\n  else if (!strcmp(model, \"EOS D2000C\"))\n  {\n    filters = 0x61616161;\n    if (!black)\n      black = curve[200];\n  }\n  else if (!strcmp(model, \"D1\"))\n  {\n    cam_mul[0] *= 256 / 527.0;\n    cam_mul[2] *= 256 / 317.0;\n  }\n  else if (!strcmp(model, \"D1X\"))\n  {\n    width -= 4;\n    pixel_aspect = 0.5;\n  }\n  else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))\n  {\n    height -= 3;\n    width -= 4;\n  }\n  else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))\n  {\n    width -= 4;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D3100\"))\n  {\n    width -= 28;\n    left_margin = 6;\n  }\n  else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))\n  {\n    width -= 42;\n  }\n  else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))\n  {\n    width -= 44;\n  }\n  else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))\n  {\n    width -= 46;\n  }\n  else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))\n  {\n    width -= 52;\n    left_margin = 2;\n  }\n  else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))\n  {\n    width--;\n  }\n  else if (!strcmp(model, \"D100\"))\n  {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  }\n  else if (!strcmp(model, \"D200\"))\n  {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  }\n  else if (!strncmp(model, \"D2H\", 3))\n  {\n    left_margin = 6;\n    width -= 14;\n  }\n  else if (!strncmp(model, \"D2X\", 3))\n  {\n    if (width == 3264)\n      width -= 32;\n    else\n      width -= 8;\n  }\n  else if (!strncmp(model, \"D300\", 4))\n  {\n    width -= 32;\n  }\n  else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)\n  {\n    if (!strcmp(model, \"COOLPIX P7700\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7700\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P7800\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7800\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P340\"))\n      load_flags = 0;\n  }\n  else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)\n  {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))\n      black = 255;\n  }\n  else if (!strncmp(model, \"COOLPIX B700\", 12))\n  {\n    load_flags = 24;\n    black = 200;\n  }\n  else if (!strncmp(model, \"1 \", 2))\n  {\n    height -= 2;\n  }\n  else if (fsize == 1581060)\n  {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  }\n  else if (fsize == 3178560)\n  {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  }\n  else if (fsize == 4771840)\n  {\n    if (!timestamp && nikon_e995())\n      strcpy(model, \"E995\");\n    if (strcmp(model, \"E995\"))\n    {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  }\n  else if (fsize == 2940928)\n  {\n    if (!timestamp && !nikon_e2100())\n      strcpy(model, \"E2500\");\n    if (!strcmp(model, \"E2500\"))\n    {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  }\n  else if (fsize == 4775936)\n  {\n    if (!timestamp)\n      nikon_3700();\n    if (model[0] == 'E' && atoi(model + 1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model, \"Optio 33WR\"))\n    {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O')\n    {\n      i = find_green(12, 32, 1188864, 3576832);\n      c = find_green(12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c))\n      {\n        SWAP(i, c);\n        load_flags = 24;\n      }\n      if (i < 0)\n        filters = 0x61616161;\n    }\n  }\n  else if (fsize == 5869568)\n  {\n    if (!timestamp && minolta_z2())\n    {\n      strcpy(make, \"Minolta\");\n      strcpy(model, \"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24 * (make[0] == 'M');\n  }\n  else if (fsize == 6291456)\n  {\n    fseek(ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d)\n    {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy(make, \"ISG\");\n      model[0] = 0;\n    }\n  }\n  else if (!strncmp(make, \"Fujifilm\", 8))\n  {\n    if (!strcmp(model + 7, \"S2Pro\"))\n    {\n      strcpy(model, \"S2Pro\");\n      height = 2144;\n      width = 2880;\n      flip = 6;\n    }\n    else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width) >> 2 << 1;\n    if (width == 2848 || width == 3664)\n      filters = 0x16161616;\n    if (width == 4032 || width == 4952)\n      left_margin = 0;\n    if (width == 3328 && (width -= 66))\n      left_margin = 34;\n    if (width == 4936)\n      left_margin = 4;\n    if (width == 6032)\n      left_margin = 0;\n    if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))\n    {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if (!strcmp(model, \"GFX 50S\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n    }\n    if (!strcmp(model, \"S5500\"))\n    {\n      height -= (top_margin = 6);\n    }\n    if (fuji_layout)\n      raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];\n  }\n  else if (!strcmp(model, \"KD-400Z\"))\n  {\n    height = 1712;\n    width = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  }\n  else if (!strcmp(model, \"KD-510Z\"))\n  {\n    goto konica_510z;\n  }\n  else if (!strncasecmp(make, \"Minolta\", 7))\n  {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model, \"DiMAGE A\", 8))\n    {\n      if (!strcmp(model, \"DiMAGE A200\"))\n        filters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))\n    {\n      sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));\n      adobe_coeff(make, model + 20);\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"DiMAGE G\", 8))\n    {\n      if (model[8] == '4')\n      {\n        height = 1716;\n        width = 2304;\n      }\n      else if (model[8] == '5')\n      {\n      konica_510z:\n        height = 1956;\n        width = 2607;\n        raw_width = 2624;\n      }\n      else if (model[8] == '6')\n      {\n        height = 2136;\n        width = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\n    konica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  }\n  else if (!strcmp(model, \"*ist D\"))\n  {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  }\n  else if (!strcmp(model, \"*ist DS\"))\n  {\n    height -= 2;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)\n  {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))\n  {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)\n  {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)\n  {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12)\n      load_flags = 80;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)\n  {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)\n  {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n      black = 1 << (tiff_bps - 7);\n  }\n  else if (!strcmp(model, \"EX1\"))\n  {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682)\n    {\n      height -= 10;\n      width -= 46;\n      top_margin = 8;\n    }\n  }\n  else if (!strcmp(model, \"WB2000\"))\n  {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718)\n    {\n      height -= 28;\n      width -= 56;\n      top_margin = 8;\n    }\n  }\n  else if (strstr(model, \"WB550\"))\n  {\n    strcpy(model, \"WB550\");\n  }\n  else if (!strcmp(model, \"EX2F\"))\n  {\n    height = 3030;\n    width = 4040;\n    top_margin = 15;\n    left_margin = 24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  else if (!strcmp(model, \"STV680 VGA\"))\n  {\n    black = 16;\n  }\n  else if (!strcmp(model, \"N95\"))\n  {\n    height = raw_height - (top_margin = 2);\n  }\n  else if (!strcmp(model, \"640x480\"))\n  {\n    gamma_curve(0.45, 4.5, 1, 255);\n  }\n  else if (!strncmp(make, \"Hasselblad\", 10))\n  {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262)\n    {\n      height = 5444;\n      width = 7248;\n      top_margin = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if (!strncasecmp(model, \"H3D\", 3))\n      {\n        adobe_coeff(\"Hasselblad\", \"H3DII-39\");\n        strcpy(model, \"H3DII-39\");\n      }\n    }\n    else if (raw_width == 7410 || raw_width == 8282)\n    {\n      height -= 84;\n      width -= 82;\n      top_margin = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\", \"H4D-40\");\n      strcpy(model, \"H4D-40\");\n    }\n    else if (raw_width == 8384) // X1D\n    {\n      top_margin = 96;\n      height -= 96;\n      left_margin = 48;\n      width -= 106;\n      adobe_coeff(\"Hasselblad\", \"X1D\");\n      maximum = 0xffff;\n      tiff_bps = 16;\n    }\n    else if (raw_width == 9044)\n    {\n      if (black > 500)\n      {\n        top_margin = 12;\n        left_margin = 44;\n        width = 8956;\n        height = 6708;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H4D-60\");\n        strcpy(model, \"H4D-60\");\n        black = 512;\n      }\n      else\n      {\n        height = 6716;\n        width = 8964;\n        top_margin = 8;\n        left_margin = 40;\n        black += load_flags = 256;\n        maximum = 0x8101;\n        strcpy(model, \"H3DII-60\");\n      }\n    }\n    else if (raw_width == 4090)\n    {\n      strcpy(model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n    else if (raw_width == 8282 && raw_height == 6240)\n    {\n      if (!strncasecmp(model, \"H5D\", 3))\n      {\n        /* H5D 50*/\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        black = 256;\n        strcpy(model, \"H5D-50\");\n      }\n      else if (!strncasecmp(model, \"H3D\", 3))\n      {\n        black = 0;\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H3D-50\");\n        strcpy(model, \"H3D-50\");\n      }\n    }\n    else if (raw_width == 8374 && raw_height == 6304)\n    {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model, \"H5D-50c\");\n    }\n    if (tiff_samples > 1)\n    {\n      is_raw = tiff_samples + 1;\n      if (!shot_select && !half_size)\n        filters = 0;\n    }\n  }\n  else if (!strncmp(make, \"Sinar\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size)\n      filters = 0;\n    maximum = 0x3fff;\n  }\n  else if (!strncmp(make, \"Leaf\", 4))\n  {\n    maximum = 0x3fff;\n    fseek(ifp, data_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1)\n      filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height)\n    {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048)\n    {\n      if (tiff_samples == 1)\n      {\n        filters = 1;\n        strcpy(cdesc, \"RBTG\");\n        strcpy(model, \"CatchLight\");\n        top_margin = 8;\n        left_margin = 18;\n        height = 2032;\n        width = 2016;\n      }\n      else\n      {\n        strcpy(model, \"DCB2\");\n        top_margin = 10;\n        left_margin = 16;\n        height = 2028;\n        width = 2022;\n      }\n    }\n    else if (width + height == 3144 + 2060)\n    {\n      if (!model[0])\n        strcpy(model, \"Cantare\");\n      if (width > height)\n      {\n        top_margin = 6;\n        left_margin = 32;\n        height = 2048;\n        width = 3072;\n        filters = 0x61616161;\n      }\n      else\n      {\n        left_margin = 6;\n        top_margin = 32;\n        width = 2048;\n        height = 3072;\n        filters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V')\n        filters = 0;\n      else\n        is_raw = tiff_samples;\n    }\n    else if (width == 2116)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    }\n    else if (width == 3171)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  }\n  else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))\n  {\n    if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw)\n    {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height)\n      height = raw_height;\n    for (i = 0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1])\n      {\n        left_margin = pana[i][2];\n        top_margin = pana[i][3];\n        width += pana[i][4];\n        height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  }\n  else if (!strcmp(model, \"C770UZ\"))\n  {\n    height = 1718;\n    width = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  }\n  else if (!strncmp(make, \"Olympus\", 7))\n  {\n    height += height & 1;\n    if (exif_cfa)\n      filters = exif_cfa;\n    if (width == 4100)\n      width -= 4;\n    if (width == 4080)\n      width -= 24;\n    if (width == 9280)\n    {\n      width -= 6;\n      height -= 6;\n    }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))\n    {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw)\n      {\n        maximum = 0xfc3;\n        memset(cblack, 0, sizeof cblack);\n      }\n    }\n    else if (!strcmp(model, \"STYLUS1\"))\n    {\n      width -= 14;\n      maximum = 0xfff;\n    }\n    else if (!strcmp(model, \"E-330\"))\n    {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n        maximum = 0xf79;\n    }\n    else if (!strcmp(model, \"SP550UZ\"))\n    {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width = 640;\n    }\n    else if (!strcmp(model, \"TG-4\"))\n    {\n      width -= 16;\n    }\n  }\n  else if (!strcmp(model, \"N Digital\"))\n  {\n    height = 2047;\n    width = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strcmp(model, \"DSC-F828\"))\n  {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy(cdesc, \"RGBE\");\n  }\n  else if (!strcmp(model, \"DSC-V3\"))\n  {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)\n  {\n    width = 3925;\n    order = 0x4d4d;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(make, \"Sony\") && raw_width == 4600)\n  {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)\n  {\n    if (height < 3280)\n      width -= 8;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)\n  { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)\n  {\n    width -= 24;\n    if (strstr(model, \"RX1\") || strstr(model, \"A99\"))\n      width -= 6;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)\n  {\n    width -= 30;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(model, \"DSLR-A100\"))\n  {\n    if (width == 3880)\n    {\n      height--;\n      width = ++raw_width;\n    }\n    else\n    {\n      height -= 4;\n      width -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strcmp(model, \"PIXL\"))\n  {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve(0, 7, 1, 255);\n  }\n  else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))\n  {\n    order = 0x4949;\n    if (filters && data_offset)\n    {\n      fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts(curve, 256);\n    }\n    else\n      gamma_curve(0, 3.875, 1, 255);\n    load_raw = filters ? &CLASS eight_bit_load_raw\n                       : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  }\n  else if (!strncasecmp(model, \"EasyShare\", 9))\n  {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strncasecmp(make, \"Kodak\", 5))\n  {\n    if (filters == UINT_MAX)\n      filters = 0x61616161;\n    if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))\n    {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ')\n        model[6] = 0;\n      if (!strcmp(model, \"DCS460A\"))\n        goto bw;\n    }\n    else if (!strcmp(model, \"DCS660M\"))\n    {\n      black = 214;\n      goto bw;\n    }\n    else if (!strcmp(model, \"DCS760M\"))\n    {\n    bw:\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model + 4, \"20X\"))\n      strcpy(cdesc, \"MYCY\");\n    if (strstr(model, \"DC25\"))\n    {\n      strcpy(model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model, \"DC2\", 3))\n    {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000)\n      {\n        raw_width = 256;\n        width = 249;\n        pixel_aspect = (4.0 * height) / (3.0 * width);\n      }\n      else\n      {\n        raw_width = 512;\n        width = 501;\n        pixel_aspect = (493.0 * height) / (373.0 * width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    }\n    else if (!strcmp(model, \"40\"))\n    {\n      strcpy(model, \"DC40\");\n      height = 512;\n      width = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    }\n    else if (strstr(model, \"DC50\"))\n    {\n      strcpy(model, \"DC50\");\n      height = 512;\n      width = 768;\n      iso_speed = 84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    }\n    else if (strstr(model, \"DC120\"))\n    {\n      strcpy(model, \"DC120\");\n      raw_height = height = 976;\n      raw_width = width = 848;\n      iso_speed = 160;\n      pixel_aspect = height / 0.75 / width;\n      load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    }\n    else if (!strcmp(model, \"DCS200\"))\n    {\n      thumb_height = 128;\n      thumb_width = 192;\n      thumb_offset = 6144;\n      thumb_misc = 360;\n      iso_speed = 140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  }\n  else if (!strcmp(model, \"Fotoman Pixtura\"))\n  {\n    height = 512;\n    width = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  }\n  else if (!strncmp(model, \"QuickTake\", 9))\n  {\n    if (head[5])\n      strcpy(model + 10, \"200\");\n    fseek(ifp, 544, SEEK_SET);\n    height = get2();\n    width = get2();\n    data_offset = (get4(), get2()) == 30 ? 738 : 736;\n    if (height > width)\n    {\n      SWAP(height, width);\n      fseek(ifp, data_offset - 6, SEEK_SET);\n      flip = ~get2() & 3 ? 5 : 6;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strncmp(make, \"Rollei\", 6) && !load_raw)\n  {\n    switch (raw_width)\n    {\n    case 1316:\n      height = 1030;\n      width = 1300;\n      top_margin = 1;\n      left_margin = 6;\n      break;\n    case 2568:\n      height = 1960;\n      width = 2560;\n      top_margin = 2;\n      left_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model, \"GRAS-50S5C\"))\n  {\n    height = 2048;\n    width = 2440;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x49494949;\n    order = 0x4949;\n    maximum = 0xfffC;\n  }\n  else if (!strcmp(model, \"BB-500CL\"))\n  {\n    height = 2058;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"BB-500GE\"))\n  {\n    height = 2058;\n    width = 2456;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"SVS625CL\"))\n  {\n    height = 2050;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if (!model[0])\n    sprintf(model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX)\n    filters = 0x94949494;\n  if (thumb_offset && !thumb_height)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      thumb_width = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (dng_version) /* Override black level by DNG tags */\n  {\n    /* copy DNG data from per-IFD field to color.dng */\n    int iifd = 0;\n    for (; iifd < tiff_nifds; iifd++)\n      if (tiff_ifd[iifd].offset == data_offset) // found\n        break;\n\n    if (iifd < tiff_nifds)\n    {\n      memmove(&imgdata.color.dng_color[0], &tiff_ifd[iifd].dng_color[0], sizeof(tiff_ifd[iifd].dng_color[0]));\n      memmove(&imgdata.color.dng_color[1], &tiff_ifd[iifd].dng_color[1], sizeof(tiff_ifd[iifd].dng_color[1]));\n      memmove(&imgdata.color.dng_levels, &tiff_ifd[iifd].dng_levels, sizeof(tiff_ifd[iifd].dng_levels));\n      meta_offset = tiff_ifd[iifd].opcode2_offset;\n      if (tiff_ifd[iifd].lineartable_offset && tiff_ifd[iifd].lineartable_len)\n      {\n        INT64 pos = ftell(ifp);\n        fseek(ifp, tiff_ifd[iifd].lineartable_offset, SEEK_SET);\n        linear_table(tiff_ifd[iifd].lineartable_len);\n        fseek(ifp, pos, SEEK_SET);\n      }\n      // Need to add curve too\n    }\n    /* Copy DNG black level to  */\n    maximum = imgdata.color.dng_levels.dng_whitelevel[0];\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),\n                 (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for (int i = 0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)\n  {\n    memcpy(rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color)\n    adobe_coeff(make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if (imgdata.color.cam_xyz[0][0] < 0.01)\n    adobe_coeff(make, model, 1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color)\n      adobe_coeff(\"Apple\", \"Quicktake\");\n\n  if (fuji_width)\n  {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  }\n  else\n  {\n    if (raw_height < height)\n      raw_height = height;\n    if (raw_width < width)\n      raw_width = width;\n  }\n  if (!tiff_bps)\n    tiff_bps = 12;\n  if (!maximum)\n  {\n    maximum = (1 << tiff_bps) - 1;\n    if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)\n      maximum = curve[maximum];\n  }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");\n  if (!raw_height)\n    raw_height = height;\n  if (!raw_width)\n    raw_width = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX)\n    flip = tiff_flip;\n  if (flip == UINT_MAX)\n    flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if (flip > 89 || flip < -89)\n  {\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n      break;\n    }\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n}\n\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] = {\n      {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};\n  static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  static const double adobe_rgb[3][3] = {\n      {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};\n  static const double wide_rgb[3][3] = {\n      {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};\n  static const double prophoto_rgb[3][3] = {\n      {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};\n  static const double aces_rgb[3][3] = {\n      {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};\n  static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};\n  static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};\n  static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,\n                                   0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,\n                                   0,    0, 0,          0xf6d6,     0x10000,    0xd32d};\n  unsigned pbody[] = {10,         0x63707274, 0,  36, /* cprt */\n                      0x64657363, 0,          40,     /* desc */\n                      0x77747074, 0,          20,     /* wtpt */\n                      0x626b7074, 0,          20,     /* bkpt */\n                      0x72545243, 0,          14,     /* rTRC */\n                      0x67545243, 0,          14,     /* gTRC */\n                      0x62545243, 0,          14,     /* bTRC */\n                      0x7258595a, 0,          20,     /* rXYZ */\n                      0x6758595a, 0,          20,     /* gXYZ */\n                      0x6258595a, 0,          20};    /* bXYZ */\n  static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};\n  unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);\n#endif\n  gamma_curve(gamm[0], gamm[1], 0, 0);\n  memcpy(out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 || output_color < 1 || output_color > 6;\n#endif\n  if (!raw_color)\n  {\n    oprof = (unsigned *)calloc(phead[0], 1);\n    merror(oprof, \"convert_to_rgb()\");\n    memcpy(oprof, phead, sizeof phead);\n    if (output_color == 5)\n      oprof[4] = oprof[5];\n    oprof[0] = 132 + 12 * pbody[0];\n    for (i = 0; i < pbody[0]; i++)\n    {\n      oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i * 3 + 2] = oprof[0];\n      oprof[0] += (pbody[i * 3 + 3] + 3) & -4;\n    }\n    memcpy(oprof + 32, pbody, sizeof pbody);\n    oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;\n    memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;\n    for (i = 4; i < 7; i++)\n      memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);\n    pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n        for (num = k = 0; k < 3; k++)\n          num += xyzd50_srgb[i][k] * inverse[j][k];\n        oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;\n      }\n    for (i = 0; i < phead[0] / 4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");\n    strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (out_cam[i][j] = k = 0; k < 3; k++)\n          out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),\n            name[output_color - 1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset(histogram, 0, sizeof histogram);\n  for (img = image[0], row = 0; row < height; row++)\n    for (col = 0; col < width; col++, img += 4)\n    {\n      if (!raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        FORCC\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        FORC3 img[c] = CLIP((int)out[c]);\n      }\n      else if (document_mode)\n        img[0] = img[fcol(row, col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color)\n    colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters)\n    colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort(*)[4])calloc(high, wide * sizeof *img);\n  merror(img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);\n#endif\n\n  for (row = 0; row < high; row++)\n    for (col = 0; col < wide; col++)\n    {\n      ur = r = fuji_width + (row - col) * step;\n      uc = c = (row + col) * step;\n      if (ur > height - 2 || uc > width - 2)\n        continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur * width + uc;\n      for (i = 0; i < colors; i++)\n        img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +\n                                   (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;\n    }\n\n  free(image);\n  width = wide;\n  height = high;\n  image = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1)\n  {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(width, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c * width];\n      if (c + 1 < height)\n        pix1 += width * 4;\n      for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)\n        FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    height = newdim;\n  }\n  else\n  {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(height, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c + 1 < width)\n        pix1 += 4;\n      for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)\n        FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    width = newdim;\n  }\n  free(image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);\n#endif\n}\n\nint CLASS flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}\n\nvoid CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag + 1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2)\n  {\n    count = strnlen((char *)th + val, count - 1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val + c];\n  }\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head(struct tiff_hdr *th, int full)\n{\n  int c, psize = 0;\n  struct tm *t;\n\n  memset(th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4 + c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy(th->t_desc, desc, 512);\n  strncpy(th->t_make, make, 64);\n  strncpy(th->t_model, model, 64);\n  strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime(&timestamp);\n  sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,\n          t->tm_min, t->tm_sec);\n  strncpy(th->t_artist, artist, 64);\n  if (full)\n  {\n    tiff_set(th, &th->ntag, 254, 4, 1, 0);\n    tiff_set(th, &th->ntag, 256, 4, 1, width);\n    tiff_set(th, &th->ntag, 257, 4, 1, height);\n    tiff_set(th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag - 1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set(th, &th->ntag, 259, 3, 1, 1);\n    tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full)\n  {\n    if (oprof)\n      psize = ntohl(oprof[0]);\n    tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set(th, &th->ntag, 277, 3, 1, colors);\n    tiff_set(th, &th->ntag, 278, 4, 1, height);\n    tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);\n  }\n  else\n    tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');\n  tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set(th, &th->ntag, 284, 3, 1, 1);\n  tiff_set(th, &th->ntag, 296, 3, 1, 2);\n  tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize)\n    tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1])\n  {\n    tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set(th, &th->ngps, 0, 1, 4, 0x202);\n    tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);\n    tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));\n    tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);\n    tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));\n    tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);\n    tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));\n    tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));\n    tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy(th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc(0xff, tfp);\n  fputc(0xd8, tfp);\n  if (strcmp(t_humb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, tfp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, tfp);\n  }\n  fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp, thumb, thumb_length);\n  free(thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  fputc(0xff, ofp);\n  fputc(0xd8, ofp);\n  if (strcmp(thumb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, ofp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, ofp);\n  }\n  fwrite(thumb + 2, 1, thumb_length - 2, ofp);\n  free(thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white = 0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01; /* 99th percentile white level */\n#endif\n  if (fuji_width)\n    perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white = c = 0; c < colors; c++)\n    {\n      for (val = 0x2000, total = 0; --val > 32;)\n        if ((total += histogram[c][val]) > perc)\n          break;\n      if (t_white < val)\n        t_white = val;\n    }\n  gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);\n  iheight = height;\n  iwidth = width;\n  if (flip & 4)\n    SWAP(height, width);\n  ppm = (uchar *)calloc(width, colors * output_bps / 8);\n  ppm2 = (ushort *)ppm;\n  merror(ppm, \"write_ppm_tiff()\");\n  if (output_tiff)\n  {\n    tiff_head(&th, 1);\n    fwrite(&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite(oprof, ntohl(oprof[0]), 1, ofp);\n  }\n  else if (colors > 3)\n    fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,\n            (1 << output_bps) - 1, cdesc);\n  else\n    fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, width);\n  for (row = 0; row < height; row++, soff += rstep)\n  {\n    for (col = 0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n        FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;\n      else\n        FORCC ppm2[col * colors + c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab((char *)ppm2, (char *)ppm2, width * colors * 2);\n    fwrite(ppm, colors * output_bps / 8, width, ofp);\n  }\n  free(ppm);\n}\n"], "fixing_code": ["#ifndef IGNOREALL\n/*\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2015 by Dave Coffin, dcoffin a cybercom o net\n\n   This is a command-line ANSI C program to convert raw photos from\n   any digital camera on any computer running any operating system.\n\n   No license is required to download and use dcraw.c.  However,\n   to lawfully redistribute dcraw, you must either (a) offer, at\n   no extra charge, full source code* for all executable files\n   containing RESTRICTED functions, (b) distribute this code under\n   the GPL Version 2 or later, (c) remove all RESTRICTED functions,\n   re-implement them, or copy them from an earlier, unrestricted\n   Revision of dcraw.c, or (d) purchase a license from the author.\n\n   The functions that process Foveon images have been RESTRICTED\n   since Revision 1.237.  All other code remains free for all uses.\n\n   *If you have not modified dcraw.c in any way, a link to my\n   homepage qualifies as \"full source code\".\n\n   $Revision: 1.476 $\n   $Date: 2015/05/25 02:29:14 $\n */\n/*@out DEFINES\n#ifndef USE_JPEG\n#define NO_JPEG\n#endif\n#ifndef USE_JASPER\n#define NO_JASPER\n#endif\n@end DEFINES */\n\n#define NO_LCMS\n#define DCRAW_VERBOSE\n//@out DEFINES\n#define DCRAW_VERSION \"9.26\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define _USE_MATH_DEFINES\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/types.h>\n//@end DEFINES\n\n#if defined(DJGPP) || defined(__MINGW32__)\n#define fseeko fseek\n#define ftello ftell\n#else\n#define fgetc getc_unlocked\n#endif\n//@out DEFINES\n#ifdef __CYGWIN__\n#include <io.h>\n#endif\n#if defined WIN32 || defined(__MINGW32__)\n#include <sys/utime.h>\n#include <winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define snprintf _snprintf\n#define strcasecmp stricmp\n#define strncasecmp strnicmp\n//@end DEFINES\ntypedef __int64 INT64;\ntypedef unsigned __int64 UINT64;\n//@out DEFINES\n#else\n#include <unistd.h>\n#include <utime.h>\n#include <netinet/in.h>\ntypedef long long INT64;\ntypedef unsigned long long UINT64;\n#endif\n\n#ifdef NODEPS\n#define NO_JASPER\n#define NO_JPEG\n#define NO_LCMS\n#endif\n#ifndef NO_JASPER\n#include <jasper/jasper.h> /* Decode Red camera movies */\n#endif\n#ifndef NO_JPEG\n#include <jpeglib.h> /* Decode compressed Kodak DC120 photos */\n#endif               /* and Adobe Lossy DNGs */\n#ifndef NO_LCMS\n#ifdef USE_LCMS\n#include <lcms.h> /* Support color profiles */\n#else\n#include <lcms2.h> /* Support color profiles */\n#endif\n#endif\n#ifdef LOCALEDIR\n#include <libintl.h>\n#define _(String) gettext(String)\n#else\n#define _(String) (String)\n#endif\n\n#ifdef LJPEG_DECODE\n#error Please compile dcraw.c by itself.\n#error Do not link it with ljpeg_decode.\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * sizeof(long))\n#endif\n//@end DEFINES\n\n#if !defined(uchar)\n#define uchar unsigned char\n#endif\n#if !defined(ushort)\n#define ushort unsigned short\n#endif\n\n/*\n   All global variables are defined here, and all functions that\n   access them are prefixed with \"CLASS\".  Note that a thread-safe\n   C++ class cannot have non-const static local variables.\n */\nFILE *ifp, *ofp;\nshort order;\nconst char *ifname;\nchar *meta_data, xtrans[6][6], xtrans_abs[6][6];\nchar cdesc[5], desc[512], make[64], model[64], model2[64], artist[64], software[64];\nfloat flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;\ntime_t timestamp;\noff_t strip_offset, data_offset;\noff_t thumb_offset, meta_offset, profile_offset;\nunsigned shot_order, kodak_cbpp, exif_cfa, unique_id;\nunsigned thumb_length, meta_length, profile_length;\nunsigned thumb_misc, *oprof, fuji_layout, shot_select = 0, multi_out = 0;\nunsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;\nunsigned black, maximum, mix_green, raw_color, zero_is_bad;\nunsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;\nunsigned tile_width, tile_length, gpsdata[32], load_flags;\nunsigned flip, tiff_flip, filters, colors;\nushort raw_height, raw_width, height, width, top_margin, left_margin;\nushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;\nushort *raw_image, (*image)[4], cblack[4102];\nushort white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];\ndouble pixel_aspect, aber[4] = {1, 1, 1, 1}, gamm[6] = {0.45, 4.5, 0, 0, 0, 0};\nfloat bright = 1, user_mul[4] = {0, 0, 0, 0}, threshold = 0;\nint mask[8][4];\nint half_size = 0, four_color_rgb = 0, document_mode = 0, highlight = 0;\nint verbose = 0, use_auto_wb = 0, use_camera_wb = 0, use_camera_matrix = 1;\nint output_color = 1, output_bps = 8, output_tiff = 0, med_passes = 0;\nint no_auto_bright = 0;\nunsigned greybox[4] = {0, 0, UINT_MAX, UINT_MAX};\nfloat cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];\nconst double xyz_rgb[3][3] = {/* XYZ from RGB */\n                              {0.412453, 0.357580, 0.180423},\n                              {0.212671, 0.715160, 0.072169},\n                              {0.019334, 0.119193, 0.950227}};\nconst float d65_white[3] = {0.950456, 1, 1.088754};\nint histogram[4][0x2000];\nvoid (*write_thumb)(), (*write_fun)();\nvoid (*load_raw)(), (*thumb_load_raw)();\njmp_buf failure;\n\nstruct decode\n{\n  struct decode *branch[2];\n  int leaf;\n} first_decode[2048], *second_decode, *free_decode;\n\nstruct tiff_ifd\n{\n  int t_width, t_height, bps, comp, phint, offset, t_flip, samples, bytes;\n  int t_tile_width, t_tile_length, sample_format, predictor;\n  float t_shutter;\n} tiff_ifd[10];\n\nstruct ph1\n{\n  int format, key_off, tag_21a;\n  int t_black, split_col, black_col, split_row, black_row;\n  float tag_210;\n} ph1;\n\n#define CLASS\n\n//@out DEFINES\n#define FORC(cnt) for (c = 0; c < cnt; c++)\n#define FORC3 FORC(3)\n#define FORC4 FORC(4)\n#define FORCC for (c = 0; c < colors && c < 4; c++)\n\n#define SQR(x) ((x) * (x))\n#define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define LIM(x, min, max) MAX(min, MIN(x, max))\n#define ULIM(x, y, z) ((y) < (z) ? LIM(x, y, z) : LIM(x, z, y))\n#define CLIP(x) LIM((int)(x), 0, 65535)\n#define SWAP(a, b)                                                                                                     \\\n  {                                                                                                                    \\\n    a = a + b;                                                                                                         \\\n    b = a - b;                                                                                                         \\\n    a = a - b;                                                                                                         \\\n  }\n\n#define my_swap(type, i, j)                                                                                            \\\n  {                                                                                                                    \\\n    type t = i;                                                                                                        \\\n    i = j;                                                                                                             \\\n    j = t;                                                                                                             \\\n  }\n\nstatic float fMAX(float a, float b) { return MAX(a, b); }\n\n/*\n   In order to inline this calculation, I make the risky\n   assumption that all filter patterns can be described\n   by a repeating pattern of eight rows and two columns\n\n   Do not use the FC or BAYER macros with the Leaf CatchLight,\n   because its pattern is 16x16, not 2x8.\n\n   Return values are either 0/1/2/3 = G/M/C/Y or 0/1/2/3 = R/G1/B/G2\n\n        PowerShot 600\tPowerShot A50\tPowerShot Pro70\tPro90 & G1\n        0xe1e4e1e4:\t0x1b4e4b1e:\t0x1e4b4e1b:\t0xb4b4b4b4:\n\n          0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n        0 G M G M G M\t0 C Y C Y C Y\t0 Y C Y C Y C\t0 G M G M G M\n        1 C Y C Y C Y\t1 M G M G M G\t1 M G M G M G\t1 Y C Y C Y C\n        2 M G M G M G\t2 Y C Y C Y C\t2 C Y C Y C Y\n        3 C Y C Y C Y\t3 G M G M G M\t3 G M G M G M\n                        4 C Y C Y C Y\t4 Y C Y C Y C\n        PowerShot A5\t5 G M G M G M\t5 G M G M G M\n        0x1e4e1e4e:\t6 Y C Y C Y C\t6 C Y C Y C Y\n                        7 M G M G M G\t7 M G M G M G\n          0 1 2 3 4 5\n        0 C Y C Y C Y\n        1 G M G M G M\n        2 C Y C Y C Y\n        3 M G M G M G\n\n   All RGB cameras use one of these Bayer grids:\n\n        0x16161616:\t0x61616161:\t0x49494949:\t0x94949494:\n\n          0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\t  0 1 2 3 4 5\n        0 B G B G B G\t0 G R G R G R\t0 G B G B G B\t0 R G R G R G\n        1 G R G R G R\t1 B G B G B G\t1 R G R G R G\t1 G B G B G B\n        2 B G B G B G\t2 G R G R G R\t2 G B G B G B\t2 R G R G R G\n        3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n */\n\n#define RAW(row, col) raw_image[(row)*raw_width + (col)]\n//@end DEFINES\n\n#define FC(row, col) (filters >> ((((row) << 1 & 14) + ((col)&1)) << 1) & 3)\n\n//@out DEFINES\n#define BAYER(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][FC(row, col)]\n\n#define BAYER2(row, col) image[((row) >> shrink) * iwidth + ((col) >> shrink)][fcol(row, col)]\n//@end DEFINES\n\n/* @out COMMON\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end COMMON */\n\n//@out COMMON\nint CLASS fcol(int row, int col)\n{\n  static const char filter[16][16] = {\n      {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},\n      {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},\n      {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},\n      {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},\n      {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},\n      {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},\n      {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},\n      {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};\n\n  if (filters == 1)\n    return filter[(row + top_margin) & 15][(col + left_margin) & 15];\n  if (filters == 9)\n    return xtrans[(row + 6) % 6][(col + 6) % 6];\n  return FC(row, col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a, b) local_strnlen(a, b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n  int r = fp->read(buf, len, 1);\n  buf[len - 1] = 0;\n  return r;\n}\n#define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp(c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)\n\n//@end COMMON\n\nvoid CLASS merror(void *ptr, const char *where)\n{\n  if (ptr)\n    return;\n  fprintf(stderr, _(\"%s: Out of memory in %s\\n\"), ifname, where);\n  longjmp(failure, 1);\n}\n\nvoid CLASS derror()\n{\n  if (!data_error)\n  {\n    fprintf(stderr, \"%s: \", ifname);\n    if (feof(ifp))\n      fprintf(stderr, _(\"Unexpected end of file\\n\"));\n    else\n      fprintf(stderr, _(\"Corrupt data near 0x%llx\\n\"), (INT64)ftello(ifp));\n  }\n  data_error++;\n}\n\n//@out COMMON\nushort CLASS sget2(uchar *s)\n{\n  if (order == 0x4949) /* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG 1\n#define AdobeDNG 2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)\n{\n  if ((a >> 4) > 9)\n    return 0;\n  else if ((a & 0x0f) > 9)\n    return 0;\n  else if ((b >> 4) > 9)\n    return 0;\n  else if ((b & 0x0f) > 9)\n    return 0;\n  else if ((c >> 4) > 9)\n    return 0;\n  else if ((c & 0x0f) > 9)\n    return 0;\n  else if ((d >> 4) > 9)\n    return 0;\n  else if ((d & 0x0f) > 9)\n    return 0;\n  else if ((e >> 4) > 9)\n    return 0;\n  else if ((e & 0x0f) > 9)\n    return 0;\n  else if ((f >> 4) > 9)\n    return 0;\n  else if ((f & 0x0f) > 9)\n    return 0;\n  return 1;\n}\n\nstatic ushort bcd2dec(uchar data)\n{\n  if ((data >> 4) > 9)\n    return 0;\n  else if ((data & 0x0f) > 9)\n    return 0;\n  else\n    return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] =\n    \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"\n    \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"\n    \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"\n    \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"\n    \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"\n    \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"\n    \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"\n    \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"\n    \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"\n    \"\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse\n{\n  if (order == 0x4d4d) /* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian... */\n    return s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = {0xff, 0xff};\n  fread(str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4(uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }\n\nfloat CLASS int_to_float(int i)\n{\n  union {\n    int i;\n    float f;\n  } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n\n  switch (type)\n  {\n  case 3:\n    return (unsigned short)get2();\n  case 4:\n    return (unsigned int)get4();\n  case 5:\n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8:\n    return (signed short)get2();\n  case 9:\n    return (signed int)get4();\n  case 10:\n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11:\n    return int_to_float(get4());\n  case 12:\n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts(ushort *pixel, int count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}\n\nvoid CLASS cubic_spline(const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);\n  if (!A)\n    return;\n  A[0] = (float *)(A + 2 * len);\n  for (i = 1; i < 2 * len; i++)\n    A[i] = A[0] + 2 * len * i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));\n  for (i = 0; i < len; i++)\n  {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len - 1; i > 0; i--)\n  {\n    b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);\n    d[i - 1] = x[i] - x[i - 1];\n  }\n  for (i = 1; i < len - 1; i++)\n  {\n    A[i][i] = 2 * (d[i - 1] + d[i]);\n    if (i > 1)\n    {\n      A[i][i - 1] = d[i - 1];\n      A[i - 1][i] = d[i - 1];\n    }\n    A[i][len - 1] = 6 * (b[i + 1] - b[i]);\n  }\n  for (i = 1; i < len - 2; i++)\n  {\n    float v = A[i + 1][i] / A[i][i];\n    for (j = 1; j <= len - 1; j++)\n      A[i + 1][j] -= v * A[i][j];\n  }\n  for (i = len - 2; i > 0; i--)\n  {\n    float acc = 0;\n    for (j = i; j <= len - 2; j++)\n      acc += A[i][j] * c[j];\n    c[i] = (A[i][len - 1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len - 1; j++)\n    {\n      if (x[j] <= x_out && x_out <= x[j + 1])\n      {\n        float v = x_out - x[j];\n        y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +\n                ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));\n  }\n  free(A);\n}\n\nvoid CLASS canon_600_fixed_wb(int temp)\n{\n  static const short mul[4][5] = {\n      {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};\n  int lo, hi, i;\n  float frac = 0;\n\n  for (lo = 4; --lo;)\n    if (*mul[lo] <= temp)\n      break;\n  for (hi = 0; hi < 3; hi++)\n    if (*mul[hi] >= temp)\n      break;\n  if (lo != hi)\n    frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i = 1; i < 5; i++)\n    pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color(int ratio[2], int mar)\n{\n  int clipped = 0, target, miss;\n\n  if (flash_used)\n  {\n    if (ratio[1] < -104)\n    {\n      ratio[1] = -104;\n      clipped = 1;\n    }\n    if (ratio[1] > 12)\n    {\n      ratio[1] = 12;\n      clipped = 1;\n    }\n  }\n  else\n  {\n    if (ratio[1] < -264 || ratio[1] > 461)\n      return 2;\n    if (ratio[1] < -50)\n    {\n      ratio[1] = -50;\n      clipped = 1;\n    }\n    if (ratio[1] > 307)\n    {\n      ratio[1] = 307;\n      clipped = 1;\n    }\n  }\n  target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)\n    return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar * 4)\n    return 2;\n  if (miss < -20)\n    miss = -20;\n  if (miss > mar)\n    miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = {0, 0};\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset(&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if (i < 10)\n    mar = 150;\n  else if (i > 12)\n    mar = 20;\n  else\n    mar = 280 - 20 * i;\n  if (flash_used)\n    mar = 80;\n  for (row = 14; row < height - 14; row += 4)\n    for (col = 10; col < width; col += 2)\n    {\n      for (i = 0; i < 8; i++)\n        test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));\n      for (i = 0; i < 8; i++)\n        if (test[i] < 150 || test[i] > 1500)\n          goto next;\n      for (i = 0; i < 4; i++)\n        if (abs(test[i] - test[i + 4]) > 50)\n          goto next;\n      for (i = 0; i < 2; i++)\n      {\n        for (j = 0; j < 4; j += 2)\n          ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];\n        stat[i] = canon_600_color(ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1)\n        goto next;\n      for (i = 0; i < 2; i++)\n        if (stat[i])\n          for (j = 0; j < 2; j++)\n            test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;\n      for (i = 0; i < 8; i++)\n        total[st][i] += test[i];\n      count[st]++;\n    next:;\n    }\n  if (count[0] | count[1])\n  {\n    st = count[0] * 200 < count[1];\n    for (i = 0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},\n                                     {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},\n                                     {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},\n                                     {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};\n  int t = 0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789)\n    t = 1;\n  if (mc > 1.28 && mc <= 2)\n  {\n    if (yc < 0.8789)\n      t = 3;\n    else if (yc <= 2)\n      t = 4;\n  }\n  if (flash_used)\n    t = 5;\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow = row = 0; irow < height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(data, 1, 1120, ifp) < 1120)\n      derror();\n    pix = raw_image + row * raw_width;\n    for (dp = data; dp < data + 1120; dp += 10, pix += 8)\n    {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6);\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1] & 3);\n      pix[4] = (dp[5] << 2) + (dp[9] & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6);\n    }\n    if ((row += 2) > height)\n      row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n    {\n      if ((val = BAYER(row, col) - black) < 0)\n        val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row, col) = val;\n    }\n  }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row = 0; row < 100; row++)\n  {\n    fseek(ifp, row * 3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15)\n      return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n, 0)\n#define gethuff(h) getbithuff(*h, h + 1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *CLASS make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }\n\nvoid CLASS crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,\n       0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,\n       0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,\n       0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,\n       0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,\n       0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,\n       0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,\n       0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,\n       0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,\n       0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,\n       0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,\n       0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,\n       0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,\n       0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,\n       0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,\n       0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,\n       0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row += 8)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free(huff[c]);\n}\n//@end COMMON\n\nstruct jhead\n{\n  int algo, bits, high, wide, clrs, sraw, psv, restart, vpred[6];\n  ushort quant[64], idct[64], *huff[20], *free[20], *row;\n};\n\n//@out COMMON\n\nint CLASS ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint CLASS ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *CLASS ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp(failure, 3);\n#endif\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  ljpeg_end(&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n#endif\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n#endif\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))\n#endif\n      for (; rp < ip[0]; rp += 4)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||\n            unique_id == 0x80000287)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select)\n    (*rp)++;\n  if (raw_image)\n  {\n    if (row < raw_height && col < raw_width)\n      RAW(row, col) = curve[**rp];\n    *rp += tiff_samples;\n  }\n  else\n  {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n    image[row * width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select)\n    (*rp)--;\n}\n\nvoid CLASS ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,\n                                   40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,\n                                   29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n                                   47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n    if (!ljpeg_start(&jh, 0))\n      break;\n    jwide = jh.wide;\n    if (filters)\n      jwide *= jh.clrs;\n    jwide /= MIN(is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      switch (jh.algo)\n      {\n      case 0xc1:\n        jh.vpred[0] = 16384;\n        getbits(-1);\n        for (jrow = 0; jrow + 7 < jh.high; jrow += 8)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)\n          {\n            ljpeg_idct(&jh);\n            rp = jh.idct;\n            row = trow + jcol / tile_width + jrow * 2;\n            col = tcol + jcol % tile_width;\n            for (i = 0; i < 16; i += 2)\n              for (j = 0; j < 8; j++)\n                adobe_copy_pixel(row + i, col + j, &rp);\n          }\n        }\n        break;\n      case 0xc3:\n        for (row = col = jrow = 0; jrow < jh.high; jrow++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          rp = ljpeg_row(jrow, &jh);\n          for (jcol = 0; jcol < jwide; jcol++)\n          {\n            adobe_copy_pixel(trow + row, tcol + col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      ljpeg_end(&jh);\n      throw;\n    }\n#endif\n    fseek(ifp, save + 4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end(&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);\n  merror(pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (tiff_bps == 16)\n        read_shorts(pixel, raw_width * tiff_samples);\n      else\n      {\n        getbits(-1);\n        for (col = 0; col < raw_width * tiff_samples; col++)\n          pixel[col] = getbits(tiff_bps);\n      }\n      for (rp = pixel, col = 0; col < raw_width; col++)\n        adobe_copy_pixel(row, col, &rp);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width * 3 * tiff_bps / 8;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for (int row = 0; row < raw_height; row++)\n  {\n    int red = fread(buf, 1, bufsize, ifp);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (tiff_bps <= 8)\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    else\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n  }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0, 0, 0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0, 0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0)\n  {\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n  while (curve[max - 2] == curve[max - 1])\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (min = row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n#endif\n  free(huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = {0x00, 0x55, 0xaa, 0xff};\n\n  memset(histo, 0, sizeof histo);\n  fseek(ifp, -2000, SEEK_END);\n  for (i = 0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i = 0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek(ifp, 0, SEEK_SET);\n  for (i = 0; i < 1024; i++)\n  {\n    fread(t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct\n  {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n      {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};\n\n  fseek(ifp, 3072, SEEK_SET);\n  fread(dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits)\n    {\n      strcpy(make, table[i].t_make);\n      strcpy(model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}\n//@end COMMON\n\nvoid CLASS jpeg_thumb();\n\n//@out COMMON\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"ppm_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread(thumb, 1, thumb_length, ifp);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *)calloc(thumb_length, 2);\n  merror(thumb, \"rollei_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts(thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n  {\n    putc(thumb[i] << 3, ofp);\n    putc(thumb[i] >> 5 << 2, ofp);\n    putc(thumb[i] >> 11 << 3, ofp);\n  }\n  free(thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }\n\nvoid CLASS phase_one_flat_field(int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts(head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0)\n    return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *)calloc(nc * wide, sizeof *mrow);\n  merror(mrow, \"phase_one_flat_field()\");\n  for (y = 0; y < high; y++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x = 0; x < wide; x++)\n      for (c = 0; c < nc; c += 2)\n      {\n        num = is_float ? getreal(11) : get2() / 32768.0;\n        if (y == 0)\n          mrow[c * wide + x] = num;\n        else\n          mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];\n      }\n    if (y == 0)\n      continue;\n    rend = head[1] + y * head[5];\n    for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)\n    {\n      for (x = 1; x < wide; x++)\n      {\n        for (c = 0; c < nc; c += 2)\n        {\n          mult[c] = mrow[c * wide + x - 1];\n          mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];\n        }\n        cend = head[0] + x * head[4];\n        for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)\n        {\n          c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;\n          if (!(c & 1))\n          {\n            c = RAW(row, col) * mult[c];\n            RAW(row, col) = LIM(c, 0, 65535);\n          }\n          for (c = 0; c < nc; c += 2)\n            mult[c] += mult[c + 1];\n        }\n      }\n      for (x = 0; x < wide; x++)\n        for (c = 0; c < nc; c += 2)\n          mrow[c * wide + x] += mrow[(c + 1) * wide + x];\n    }\n  }\n  free(mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {{-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n                                               {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n  if (half_size || !meta_length)\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Phase One correction...\\n\"));\n#endif\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    while (entries--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x419)\n      { /* Polynomial curve */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(11);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x41a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(11);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n            for (row = 0; row < raw_height; row++)\n              if (FC(row - top_margin, col - left_margin) == 1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;\n              }\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += raw(row + dir[i][0], col + dir[i][1]);\n            RAW(row, col) = (sum + 4) >> 3;\n          }\n        }\n      }\n      else if (tag == 0x401)\n      { /* All-color flat fields */\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x416 || tag == 0x410)\n      {\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x40b)\n      { /* Red+blue flat field */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x41f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 16; i++)\n              lc[qr][qc][i] = get4();\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x41e && !qmult_applied)\n      { /* Quadrant multipliers */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(11);\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x431 && !qmult_applied)\n      { /* Quadrant combined */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      merror(yval[0], \"phase_one_correct()\");\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(11);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek(ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555 : 0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");\n    if (ph1.black_col)\n    {\n      fseek(ifp, ph1.black_col, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);\n    }\n    if (ph1.black_row)\n    {\n      fseek(ifp, ph1.black_row, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);\n    }\n  }\n#endif\n  fseek(ifp, data_offset, SEEK_SET);\n  read_shorts(raw_image, raw_width * raw_height);\n  if (ph1.format)\n    for (i = 0; i < raw_width * raw_height; i += 2)\n    {\n      a = raw_image[i + 0] ^ akey;\n      b = raw_image[i + 1] ^ bkey;\n      raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n, 0)\n#define ph1_huff(h) ph1_bithuff(*h, h + 1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short(*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);\n  merror(pixel, \"phase_one_load_raw_c()\");\n  offset = (int *)(pixel + raw_width);\n  fseek(ifp, strip_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short(*)[2])(offset + raw_height);\n  fseek(ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n    read_shorts((ushort *)c_black[0], raw_height * 2);\n  r_black = c_black + raw_height;\n  fseek(ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n    read_shorts((ushort *)r_black[0], raw_width * 2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));\n  }\n#endif\n\n  for (i = 0; i < 256; i++)\n    curve[i] = i * i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + offset[row], SEEK_SET);\n      ph1_bits(-1);\n      pred[0] = pred[1] = 0;\n      for (col = 0; col < raw_width; col++)\n      {\n        if (col >= (raw_width & -8))\n          len[0] = len[1] = 14;\n        else if ((col & 7) == 0)\n          for (i = 0; i < 2; i++)\n          {\n            for (j = 0; j < 5 && !ph1_bits(1); j++)\n              ;\n            if (j--)\n              len[i] = length[j * 2 + ph1_bits(1)];\n          }\n        if ((i = len[col & 1]) == 14)\n          pixel[col] = pred[col & 1] = ph1_bits(16);\n        else\n          pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n        if (pred[col & 1] >> 16)\n          derror();\n        if (ph1.format == 5 && pixel[col] < 256)\n          pixel[col] = curve[pixel[col]];\n      }\n#ifndef LIBRAW_LIBRARY_BUILD\n      for (col = 0; col < raw_width; col++)\n      {\n        int shift = ph1.format == 8 ? 0 : 2;\n        i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +\n            r_black[col][row >= ph1.split_row];\n        if (i > 0)\n          RAW(row, col) = i;\n      }\n#else\n    if (ph1.format == 8)\n      memmove(&RAW(row, 0), &pixel[0], raw_width * 2);\n    else\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = pixel[col] << 2;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    back[4] = (int *)calloc(raw_width, 3 * sizeof **back);\n    merror(back[4], \"hasselblad_load_raw()\");\n    FORC3 back[c] = back[4] + c * raw_width;\n    cblack[6] >>= sh = tiff_samples > 1;\n    shot = LIM(shot_select, 1, tiff_samples) - 1;\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      FORC4 back[(c + 3) & 3] = back[c];\n      for (col = 0; col < raw_width; col += 2)\n      {\n        for (s = 0; s < tiff_samples * 2; s += 2)\n        {\n          FORC(2) len[c] = ph1_huff(jh.huff[0]);\n          FORC(2)\n          {\n            diff[s + c] = ph1_bits(len[c]);\n            if ((diff[s + c] & (1 << (len[c] - 1))) == 0)\n              diff[s + c] -= (1 << len[c]) - 1;\n            if (diff[s + c] == 65535)\n              diff[s + c] = -32768;\n          }\n        }\n        for (s = col; s < col + 2; s++)\n        {\n          pred = 0x8000 + load_flags;\n          if (col)\n            pred = back[2][s - 2];\n          if (col && row > 1)\n            switch (jh.psv)\n            {\n            case 11:\n              pred += back[0][s] / 2 - back[0][s - 2] / 2;\n              break;\n            }\n          f = (row & 1) * 3 ^ ((col + s) & 1);\n          FORC(tiff_samples)\n          {\n            pred += diff[(s & 1) * tiff_samples + c];\n            upix = pred >> sh & 0xffff;\n            if (raw_image && c == shot)\n              RAW(row, s) = upix;\n            if (image)\n            {\n              urow = row - top_margin + (c & 1);\n              ucol = col - left_margin - ((c >> 1) & 1);\n              ip = &image[urow * width + ucol][f];\n              if (urow < height && ucol < width)\n                *ip = c < 4 ? upix : (*ip + upix) >> 1;\n            }\n          }\n          back[2][s] = pred;\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(back[4]);\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  free(back[4]);\n  ljpeg_end(&jh);\n  if (image)\n    mix_green = 1;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel = 0;\n  unsigned tile = 0, r, c, row, col;\n\n  if (!filters)\n  {\n    pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n    merror(pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    FORC(tiff_samples)\n    for (r = 0; r < raw_height; r++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (r % tile_length == 0)\n      {\n        fseek(ifp, data_offset + 4 * tile++, SEEK_SET);\n        fseek(ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select)\n        continue;\n      if (filters)\n        pixel = raw_image + r * raw_width;\n      read_shorts(pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n        for (col = 0; col < width; col++)\n          image[row * width + col][c] = pixel[col + left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (!filters)\n      free(pixel);\n    throw;\n  }\n#endif\n  if (!filters)\n  {\n    maximum = 0xffff;\n    raw_color = 1;\n    free(pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  read_shorts(raw_image, raw_width * raw_height);\n  if (maximum < 0xffff)\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < raw_width; col++)\n        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n            (unsigned)(col - left_margin) < width)\n          derror();\n    }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \"imacon_full_load_raw\");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf = 0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height + 1) >> 1;\n  for (irow = 0; irow < raw_height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)\n    {\n      if (vbits = 0, tiff_compress)\n        fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);\n      else\n      {\n        fseek(ifp, 0, SEEK_END);\n        fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col = 0; col < raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n      RAW(row, col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)\n        derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom()\n{\n\n  /* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct\n  {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek(ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread(&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616; /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order)\n  {\n  case 0: /* RGGB */\n    filters = 0x94949494;\n    break;\n  case 1: /* GBRG */\n    filters = 0x49494949;\n    break;\n  case 3: /* GRBG */\n    filters = 0x61616161;\n    break;\n  }\n}\n\nvoid CLASS broadcom_load_raw()\n{\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *)malloc(raw_stride * 2);\n  merror(data, \"broadcom_load_raw()\");\n\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)\n      derror();\n    FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n#endif\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf = 0;\n\n  bwide = (raw_width + 5) / 6 << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_loose_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)\n    {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];\n      FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;\n    }\n  }\n  free(data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n#endif\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#else\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = get4();\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits(int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits)\n    return vbits = 0;\n  if (!vbits)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},\n                                    {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,\n      23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,\n      46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,\n      69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,\n      101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,\n      149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,\n      197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,\n      361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,\n      457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,\n      631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,\n      878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))\n\n#define FORYX                                                                                                          \\\n  for (y = 1; y < 3; y++)                                                                                              \\\n    for (x = col + 1; x >= col; x--)\n\n#define PREDICTOR                                                                                                      \\\n  (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)\n\n#ifdef __GNUC__\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n#pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n#endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }\n  for (i = 0; i < height * width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread(jpeg_buffer, 1, 4096, ifp);\n  swab(jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header(&cinfo, TRUE);\n  jpeg_start_decompress(&cinfo);\n  if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n  {\n    fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress(&cinfo);\n    longjmp(failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines(&cinfo, buf, 1);\n    pixel = (JSAMPLE(*)[3])buf[0];\n    for (col = 0; col < width; col += 2)\n    {\n      RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n      RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n      RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n      RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n    }\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf, \"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);\n  jpeg_create_decompress(&cinfo);\n  merror(pixel_buf, \"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf, data_size, 1, ifp);\n  swab((char *)jpg_buf, (char *)jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf;\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    free(pixel_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  unsigned sorder = order, ntags, opcode, deg, i, j, c;\n  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset)\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--)\n    {\n      opcode = get4();\n      get4();\n      get4();\n      if (opcode != 8)\n      {\n        fseek(ifp, get4(), SEEK_CUR);\n        continue;\n      }\n      fseek(ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2)\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8)\n        break;\n      for (i = 0; i <= deg && i < 9; i++)\n        coeff[i] = getreal(12);\n      for (i = 0; i < 256; i++)\n      {\n        for (tot = j = 0; j <= deg; j++)\n          tot += coeff[j] * pow(i / 255.0, (int)j);\n        cur[c][i] = tot * 0xffff;\n      }\n    }\n    order = sorder;\n  }\n  else\n  {\n    gamma_curve(1 / 2.4, 12.92, 1, 255);\n    FORC3 memcpy(cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  while (trow < raw_height)\n  {\n    fseek(ifp, save += 4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n#else\n    jpeg_stdio_src(&cinfo, ifp);\n#endif\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        jpeg_read_scanlines(&cinfo, buf, 1);\n        pixel = (JSAMPLE(*)[3])buf[0];\n        for (col = 0; col < cinfo.output_width && tcol + col < width; col++)\n        {\n          FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw;\n    }\n#endif\n    jpeg_abort_decompress(&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = {162, 192, 187, 92};\n  static const int add[4] = {0, 636, 424, 212};\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 848, ifp) < 848)\n      derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col = 0; col < width; col++)\n      RAW(row, col) = (ushort)pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, 1, raw_width, ifp) < raw_width)\n        derror();\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = curve[pixel[col]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] = {\n      {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n      {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder(kodak_tree[c]);\n  ns = (raw_height + 63) >> 5;\n  pixel = (uchar *)malloc(raw_width * 32 + ns * 4);\n  merror(pixel, \"kodak_262_load_raw()\");\n  strip = (int *)(pixel + raw_width * 32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if ((row & 31) == 0)\n      {\n        fseek(ifp, strip[row >> 5], SEEK_SET);\n        getbits(-1);\n        pi = 0;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        chess = (row + col) & 1;\n        pi1 = chess ? pi - 2 : pi - raw_width - 1;\n        pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;\n        if (col <= chess)\n          pi1 = -1;\n        if (pi1 < 0)\n          pi1 = pi2;\n        if (pi2 < 0)\n          pi2 = pi1;\n        if (pi1 < 0 && col > 1)\n          pi1 = pi2 = pi - 2;\n        pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n        pixel[pi] = val = pred + ljpeg_diff(huff[chess]);\n        if (val >> 8)\n          derror();\n        val = curve[pixel[pi++]];\n        RAW(row, col) = val;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  FORC(2) free(huff[c]);\n}\n\nint CLASS kodak_65000_decode(short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf = 0;\n  int save, bits = 0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i = 0; i < bsize; i += 2)\n  {\n    c = fgetc(ifp);\n    if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)\n    {\n      fseek(ifp, save, SEEK_SET);\n      for (i = 0; i < bsize; i += 8)\n      {\n        read_shorts(raw, 6);\n        out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n        out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n        for (j = 0; j < 6; j++)\n          out[i + 2 + j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4)\n  {\n    bitbuf = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i = 0; i < bsize; i++)\n  {\n    len = blen[i];\n    if (bits < len)\n    {\n      for (j = 0; j < 32; j += 8)\n        bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16 - len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len - 1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      pred[0] = pred[1] = 0;\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len);\n      for (i = 0; i < len; i++)\n        if ((RAW(row, col + i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])]) >> 12)\n          derror();\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt(unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start)\n  {\n    for (p = 0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;\n    for (p = 4; p < 127; p++)\n      pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;\n    for (p = 0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n  {\n    *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];\n    p++;\n  }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,\n                                 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n#ifdef LIBRAW_LIBRARY_BUILD\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit = 30, i = 0; i < 16; i++)\n        if (i == imax)\n          pix[i] = max;\n        else if (i == imin)\n          pix[i] = min;\n        else\n        {\n          pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n          if (pix[i] > 0x7ff)\n            pix[i] = 0x7ff;\n          bit += 7;\n        }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr\n                                ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)\n                                : 0;\n          }\n        }\n        else\n        {\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        }\n#else\n      for (i = 0; i < 16; i++, col += 2)\n        RAW(row, col) = curve[pix[i] << 1] >> 2;\n#endif\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n#endif\n  free(data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +\n                            (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,\n                                 0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        pred =\n            (pmode == 7 || row < 2)\n                ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment(unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {3, 3, 0, 0, 63, 47, 31, 15, 0}};\n  int low, high = 0xff, carry = 0, nbits = 8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[] = {0, 0};\n  ushort data = 0, range = 0;\n\n  fseek(ifp, seg[0][1] + 1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width * raw_height)\n    seg[1][0] = raw_width * raw_height;\n  for (pix = seg[0][0]; pix < seg[1][0]; pix++)\n  {\n    for (s = 0; s < 3; s++)\n    {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n        carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;\n      while (--nbits >= 0)\n        if ((data >> nbits & 0xff) == 0xff)\n          break;\n      if (nbits > 0)\n        data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |\n               ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0)\n      {\n        data += getbits(1);\n        carry = nbits - 8;\n      }\n      count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin = 0; hist[s][bin + 5] > count; bin++)\n        ;\n      low = hist[s][bin + 5] * (high >> 4) >> 2;\n      if (bin)\n        high = hist[s][bin + 4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits = 0; high << nbits < 128; nbits++)\n        ;\n      range = (range + low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3])\n      {\n        next = (next + 1) & hist[s][0];\n        hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;\n        hist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)\n      {\n        if (bin < hist[s][1])\n          for (i = bin; i < hist[s][1]; i++)\n            hist[s][i + 5]--;\n        else if (next <= bin)\n          for (i = hist[s][1]; i < bin; i++)\n            hist[s][i + 5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (pix >= raw_width * raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width))\n      pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek(ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment(seg, 0);\n}\n\nint CLASS median4(int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i = 1; i < 4; i++)\n  {\n    sum += p[i];\n    if (min > p[i])\n      min = p[i];\n    if (max < p[i])\n      max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes(int holes)\n{\n  int row, col, val[4];\n\n  for (row = 2; row < height - 2; row++)\n  {\n    if (!HOLE(row))\n      continue;\n    for (col = 1; col < width - 1; col += 4)\n    {\n      val[0] = RAW(row - 1, col - 1);\n      val[1] = RAW(row - 1, col + 1);\n      val[2] = RAW(row + 1, col - 1);\n      val[3] = RAW(row + 1, col + 1);\n      RAW(row, col) = median4(val);\n    }\n    for (col = 2; col < width - 2; col += 4)\n      if (HOLE(row - 2) || HOLE(row + 2))\n        RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;\n      else\n      {\n        val[0] = RAW(row, col - 2);\n        val[1] = RAW(row, col + 2);\n        val[2] = RAW(row - 2, col);\n        val[3] = RAW(row + 2, col);\n        RAW(row, col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek(ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar)fgetc(ifp);\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < nseg * 2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);\n  fseek(ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek(ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i = 0; i < nseg; i++)\n    smal_decode_segment(seg + i, holes);\n  if (holes)\n    fill_holes(holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen(ifname, \"rb\");\n#else\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg)\n    longjmp(failure, 3);\n#else\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n#endif\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try\n  {\n#endif\n    FORC4\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n#endif\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\n//@end COMMON\n\n/* RESTRICTED code starts here */\n\nvoid CLASS foveon_decoder(unsigned size, unsigned code)\n{\n  static unsigned huff[1024];\n  struct decode *cur;\n  int i, len;\n\n  if (!code)\n  {\n    for (i = 0; i < size; i++)\n      huff[i] = get4();\n    memset(first_decode, 0, sizeof first_decode);\n    free_decode = first_decode;\n  }\n  cur = free_decode++;\n  if (free_decode > first_decode + 2048)\n  {\n    fprintf(stderr, _(\"%s: decoder table overflow\\n\"), ifname);\n    longjmp(failure, 2);\n  }\n  if (code)\n    for (i = 0; i < size; i++)\n      if (huff[i] == code)\n      {\n        cur->leaf = i;\n        return;\n      }\n  if ((len = code >> 27) > 26)\n    return;\n  code = (len + 1) << 27 | (code & 0x3ffffff) << 1;\n\n  cur->branch[0] = free_decode;\n  foveon_decoder(size, code);\n  cur->branch[1] = free_decode;\n  foveon_decoder(size, code + 1);\n}\n\nvoid CLASS foveon_thumb()\n{\n  unsigned bwide, row, col, bitbuf = 0, bit = 1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0)\n  {\n    if (bwide < thumb_width * 3)\n      return;\n    buf = (char *)malloc(bwide);\n    merror(buf, \"foveon_thumb()\");\n    for (row = 0; row < thumb_height; row++)\n    {\n      fread(buf, 1, bwide, ifp);\n      fwrite(buf, 3, thumb_width, ofp);\n    }\n    free(buf);\n    return;\n  }\n  foveon_decoder(256, 0);\n\n  for (row = 0; row < thumb_height; row++)\n  {\n    memset(pred, 0, sizeof pred);\n    if (!bit)\n      get4();\n    for (bit = col = 0; col < thumb_width; col++)\n      FORC3\n      {\n        for (dindex = first_decode; dindex->branch[0];)\n        {\n          if ((bit = (bit - 1) & 31) == 31)\n            for (i = 0; i < 4; i++)\n              bitbuf = (bitbuf << 8) + fgetc(ifp);\n          dindex = dindex->branch[bitbuf >> bit & 1];\n        }\n        pred[c] += dindex->leaf;\n        fputc(pred[c], ofp);\n      }\n  }\n}\n\nvoid CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf = 0;\n  int pred[3], row, col, bit = -1, c, i;\n\n  read_shorts((ushort *)diff, 1024);\n  if (!load_flags)\n    foveon_decoder(1024, 0);\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model + 2) < 14)\n      get4();\n    for (col = bit = 0; col < width; col++)\n    {\n      if (load_flags)\n      {\n        bitbuf = get4();\n        FORC3 pred[2 - c] += diff[bitbuf >> c * 10 & 0x3ff];\n      }\n      else\n        FORC3\n        {\n          for (dindex = first_decode; dindex->branch[0];)\n          {\n            if ((bit = (bit - 1) & 31) == 31)\n              for (i = 0; i < 4; i++)\n                bitbuf = (bitbuf << 8) + fgetc(ifp);\n            dindex = dindex->branch[bitbuf >> bit & 1];\n          }\n          pred[c] += diff[dindex->leaf];\n          if (pred[c] >> 16 && ~pred[c] >> 16)\n            derror();\n        }\n      FORC3 image[row * width + col][c] = pred[c];\n    }\n  }\n}\n\nvoid CLASS foveon_huff(ushort *huff)\n{\n  int i, j, clen, code;\n\n  huff[0] = 8;\n  for (i = 0; i < 13; i++)\n  {\n    clen = getc(ifp);\n    code = getc(ifp);\n    for (j = 0; j<256>> clen;)\n      huff[code + ++j] = clen << 8 | i;\n  }\n  get2();\n}\n\nvoid CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek(ifp, 8, SEEK_CUR);\n  foveon_huff(huff);\n  roff[0] = 48;\n  FORC3 roff[c + 1] = -(-(roff[c] + get4()) & -16);\n  FORC3\n  {\n    fseek(ifp, data_offset + roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        image[row * width + col][c] = hpred[col & 1];\n      }\n    }\n  }\n}\n\nvoid CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512, 512}, {512, 512}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  type = get4();\n  get4();\n  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2)\n  {\n    fread(meta_data, 1, meta_length, ifp);\n    for (i = 0; i < meta_length; i++)\n    {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64)301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  }\n  else if (type == 4)\n  {\n    free(meta_data);\n    meta_data = (char *)malloc(meta_length = wide * high * 3 / 2);\n    merror(meta_data, \"foveon_load_camf()\");\n    foveon_huff(huff);\n    get4();\n    getbits(-1);\n    for (j = row = 0; row < high; row++)\n    {\n      for (col = 0; col < wide; col++)\n      {\n        diff = ljpeg_diff(huff);\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if (col & 1)\n        {\n          meta_data[j++] = hpred[0] >> 4;\n          meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n          meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  }\n#ifdef DCRAW_VERBOSE\n  else\n    fprintf(stderr, _(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n#endif\n}\n\nconst char *CLASS foveon_camf_param(const char *block, const char *param)\n{\n  unsigned idx, num;\n  char *pos, *cp, *dp;\n\n  for (idx = 0; idx < meta_length; idx += sget4(pos + 8))\n  {\n    pos = meta_data + idx;\n    if (strncmp(pos, \"CMb\", 3))\n      break;\n    if (pos[3] != 'P')\n      continue;\n    if (strcmp(block, pos + sget4(pos + 12)))\n      continue;\n    cp = pos + sget4(pos + 16);\n    num = sget4(cp);\n    dp = pos + sget4(cp + 4);\n    while (num--)\n    {\n      cp += 8;\n      if (!strcmp(param, dp + sget4(cp)))\n        return dp + sget4(cp + 4);\n    }\n  }\n  return 0;\n}\n\nvoid *CLASS foveon_camf_matrix(unsigned dim[3], const char *name)\n{\n  unsigned i, idx, type, ndim, size, *mat;\n  char *pos, *cp, *dp;\n  double dsize;\n\n  for (idx = 0; idx < meta_length; idx += sget4(pos + 8))\n  {\n    pos = meta_data + idx;\n    if (strncmp(pos, \"CMb\", 3))\n      break;\n    if (pos[3] != 'M')\n      continue;\n    if (strcmp(name, pos + sget4(pos + 12)))\n      continue;\n    dim[0] = dim[1] = dim[2] = 1;\n    cp = pos + sget4(pos + 16);\n    type = sget4(cp);\n    if ((ndim = sget4(cp + 4)) > 3)\n      break;\n    dp = pos + sget4(cp + 8);\n    for (i = ndim; i--;)\n    {\n      cp += 12;\n      dim[i] = sget4(cp);\n    }\n    if ((dsize = (double)dim[0] * dim[1] * dim[2]) > meta_length / 4)\n      break;\n    mat = (unsigned *)malloc((size = dsize) * 4);\n    merror(mat, \"foveon_camf_matrix()\");\n    for (i = 0; i < size; i++)\n      if (type && type != 6)\n        mat[i] = sget4(dp + i * 4);\n      else\n        mat[i] = sget4(dp + i * 2) & 0xffff;\n    return mat;\n  }\n#ifdef DCRAW_VERBOSE\n  fprintf(stderr, _(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);\n#endif\n  return 0;\n}\n\nint CLASS foveon_fixed(void *ptr, int size, const char *name)\n{\n  void *dp;\n  unsigned dim[3];\n\n  if (!name)\n    return 0;\n  dp = foveon_camf_matrix(dim, name);\n  if (!dp)\n    return 0;\n  memcpy(ptr, dp, size * 4);\n  free(dp);\n  return 1;\n}\n\nfloat CLASS foveon_avg(short *pix, int range[2], float cfilt)\n{\n  int i;\n  float val, min = FLT_MAX, max = -FLT_MAX, sum = 0;\n\n  for (i = range[0]; i <= range[1]; i++)\n  {\n    sum += val = pix[i * 4] + (pix[i * 4] - pix[(i - 1) * 4]) * cfilt;\n    if (min > val)\n      min = val;\n    if (max < val)\n      max = val;\n  }\n  if (range[1] - range[0] == 1)\n    return sum / 2;\n  return (sum - min - max) / (range[1] - range[0] - 1);\n}\n\nshort *CLASS foveon_make_curve(double max, double mul, double filt)\n{\n  short *curve;\n  unsigned i, size;\n  double x;\n\n  if (!filt)\n    filt = 0.8;\n  size = 4 * M_PI * max / filt;\n  if (size == UINT_MAX)\n    size--;\n  curve = (short *)calloc(size + 1, sizeof *curve);\n  merror(curve, \"foveon_make_curve()\");\n  curve[0] = size;\n  for (i = 0; i < size; i++)\n  {\n    x = i * filt / max / 4;\n    curve[i + 1] = (cos(x) + 1) / 2 * tanh(i * filt / mul) * mul + 0.5;\n  }\n  return curve;\n}\n\nvoid CLASS foveon_make_curves(short **curvep, float dq[3], float div[3], float filt)\n{\n  double mul[3], max = 0;\n  int c;\n\n  FORC3 mul[c] = dq[c] / div[c];\n  FORC3 if (max < mul[c]) max = mul[c];\n  FORC3 curvep[c] = foveon_make_curve(max, mul[c], filt);\n}\n\nint CLASS foveon_apply_curve(short *curve, int i)\n{\n  if (abs(i) >= curve[0])\n    return 0;\n  return i < 0 ? -curve[1 - i] : curve[1 + i];\n}\n\n#define image ((short(*)[4])image)\n\nvoid CLASS foveon_interpolate()\n{\n  static const short hood[] = {-1, -1, -1, 0, -1, 1, 0, -1, 0, 1, 1, -1, 1, 0, 1, 1};\n  short *pix, prev[3], *curve[8], (*shrink)[3];\n  float cfilt = 0, ddft[3][3][2], ppm[3][3][3];\n  float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];\n  float chroma_dq[3], color_dq[3], diag[3][3], div[3];\n  float(*black)[3], (*sgain)[3], (*sgrow)[3];\n  float fsum[3], val, frow, num;\n  int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;\n  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];\n  int work[3][3], smlast, smred, smred_p = 0, dev[3];\n  int satlev[3], keep[4], active[4];\n  unsigned dim[3], *badpix;\n  double dsum = 0, trsum[3];\n  char str[128];\n  const char *cp;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Foveon interpolation...\\n\"));\n#endif\n\n  foveon_load_camf();\n  foveon_fixed(dscr, 4, \"DarkShieldColRange\");\n  foveon_fixed(ppm[0][0], 27, \"PostPolyMatrix\");\n  foveon_fixed(satlev, 3, \"SaturationLevel\");\n  foveon_fixed(keep, 4, \"KeepImageArea\");\n  foveon_fixed(active, 4, \"ActiveImageArea\");\n  foveon_fixed(chroma_dq, 3, \"ChromaDQ\");\n  foveon_fixed(color_dq, 3, foveon_camf_param(\"IncludeBlocks\", \"ColorDQ\") ? \"ColorDQ\" : \"ColorDQCamRGB\");\n  if (foveon_camf_param(\"IncludeBlocks\", \"ColumnFilter\"))\n    foveon_fixed(&cfilt, 1, \"ColumnFilter\");\n\n  memset(ddft, 0, sizeof ddft);\n  if (!foveon_camf_param(\"IncludeBlocks\", \"DarkDrift\") || !foveon_fixed(ddft[1][0], 12, \"DarkDrift\"))\n    for (i = 0; i < 2; i++)\n    {\n      foveon_fixed(dstb, 4, i ? \"DarkShieldBottom\" : \"DarkShieldTop\");\n      for (row = dstb[1]; row <= dstb[3]; row++)\n        for (col = dstb[0]; col <= dstb[2]; col++)\n          FORC3 ddft[i + 1][c][1] += (short)image[row * width + col][c];\n      FORC3 ddft[i + 1][c][1] /= (dstb[3] - dstb[1] + 1) * (dstb[2] - dstb[0] + 1);\n    }\n\n  if (!(cp = foveon_camf_param(\"WhiteBalanceIlluminants\", model2)))\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);\n#endif\n    return;\n  }\n  foveon_fixed(cam_xyz, 9, cp);\n  foveon_fixed(correct, 9, foveon_camf_param(\"WhiteBalanceCorrections\", model2));\n  memset(last, 0, sizeof last);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];\n\n#define LAST(x, y) last[(i + x) % 3][(c + y) % 3]\n  for (i = 0; i < 3; i++)\n    FORC3 diag[c][i] = LAST(1, 1) * LAST(2, 2) - LAST(1, 2) * LAST(2, 1);\n#undef LAST\n  FORC3 div[c] = diag[c][0] * 0.3127 + diag[c][1] * 0.329 + diag[c][2] * 0.3583;\n  sprintf(str, \"%sRGBNeutral\", model2);\n  if (foveon_camf_param(\"IncludeBlocks\", str))\n    foveon_fixed(div, 3, str);\n  num = 0;\n  FORC3 if (num < div[c]) num = div[c];\n  FORC3 div[c] /= num;\n\n  memset(trans, 0, sizeof trans);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];\n  FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];\n  dsum = (6 * trsum[0] + 11 * trsum[1] + 3 * trsum[2]) / 20;\n  for (i = 0; i < 3; i++)\n    FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];\n  memset(trans, 0, sizeof trans);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      FORC3 trans[i][j] += (i == c ? 32 : -1) * last[c][j] / 30;\n\n  foveon_make_curves(curve, color_dq, div, cfilt);\n  FORC3 chroma_dq[c] /= 3;\n  foveon_make_curves(curve + 3, chroma_dq, div, cfilt);\n  FORC3 dsum += chroma_dq[c] / div[c];\n  curve[6] = foveon_make_curve(dsum, dsum, cfilt);\n  curve[7] = foveon_make_curve(dsum * 2, dsum * 2, cfilt);\n\n  sgain = (float(*)[3])foveon_camf_matrix(dim, \"SpatialGain\");\n  if (!sgain)\n    return;\n  sgrow = (float(*)[3])calloc(dim[1], sizeof *sgrow);\n  sgx = (width + dim[1] - 2) / (dim[1] - 1);\n\n  black = (float(*)[3])calloc(height, sizeof *black);\n  for (row = 0; row < height; row++)\n  {\n    for (i = 0; i < 6; i++)\n      ((float *)ddft[0])[i] =\n          ((float *)ddft[1])[i] + row / (height - 1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    FORC3 black[row][c] = (foveon_avg(image[row * width] + c, dscr[0], cfilt) +\n                           foveon_avg(image[row * width] + c, dscr[1], cfilt) * 3 - ddft[0][c][0]) /\n                              4 -\n                          ddft[0][c][1];\n  }\n  memcpy(black, black + 8, sizeof *black * 8);\n  memcpy(black + height - 11, black + height - 22, 11 * sizeof *black);\n  memcpy(last, black, sizeof last);\n\n  for (row = 1; row < height - 1; row++)\n  {\n    FORC3 if (last[1][c] > last[0][c])\n    {\n      if (last[1][c] > last[2][c])\n        black[row][c] = (last[0][c] > last[2][c]) ? last[0][c] : last[2][c];\n    }\n    else if (last[1][c] < last[2][c]) black[row][c] = (last[0][c] < last[2][c]) ? last[0][c] : last[2][c];\n    memmove(last, last + 1, 2 * sizeof last[0]);\n    memcpy(last[2], black[row + 1], sizeof last[2]);\n  }\n  FORC3 black[row][c] = (last[0][c] + last[1][c]) / 2;\n  FORC3 black[0][c] = (black[1][c] + black[3][c]) / 2;\n\n  val = 1 - exp(-1 / 24.0);\n  memcpy(fsum, black, sizeof fsum);\n  for (row = 1; row < height; row++)\n    FORC3 fsum[c] += black[row][c] = (black[row][c] - black[row - 1][c]) * val + black[row - 1][c];\n  memcpy(last[0], black[height - 1], sizeof last[0]);\n  FORC3 fsum[c] /= height;\n  for (row = height; row--;)\n    FORC3 last[0][c] = black[row][c] = (black[row][c] - fsum[c] - last[0][c]) * val + last[0][c];\n\n  memset(total, 0, sizeof total);\n  for (row = 2; row < height; row += 4)\n    for (col = 2; col < width; col += 4)\n    {\n      FORC3 total[c] += (short)image[row * width + col][c];\n      total[3]++;\n    }\n  for (row = 0; row < height; row++)\n    FORC3 black[row][c] += fsum[c] / 2 + total[c] / (total[3] * 100.0);\n\n  for (row = 0; row < height; row++)\n  {\n    for (i = 0; i < 6; i++)\n      ((float *)ddft[0])[i] =\n          ((float *)ddft[1])[i] + row / (height - 1.0) * (((float *)ddft[2])[i] - ((float *)ddft[1])[i]);\n    pix = image[row * width];\n    memcpy(prev, pix, sizeof prev);\n    frow = row / (height - 1.0) * (dim[2] - 1);\n    if ((irow = frow) == dim[2] - 1)\n      irow--;\n    frow -= irow;\n    for (i = 0; i < dim[1]; i++)\n      FORC3 sgrow[i][c] = sgain[irow * dim[1] + i][c] * (1 - frow) + sgain[(irow + 1) * dim[1] + i][c] * frow;\n    for (col = 0; col < width; col++)\n    {\n      FORC3\n      {\n        diff = pix[c] - prev[c];\n        prev[c] = pix[c];\n        ipix[c] = pix[c] + floor((diff + (diff * diff >> 14)) * cfilt - ddft[0][c][1] -\n                                 ddft[0][c][0] * ((float)col / width - 0.5) - black[row][c]);\n      }\n      FORC3\n      {\n        work[0][c] = ipix[c] * ipix[c] >> 14;\n        work[2][c] = ipix[c] * work[0][c] >> 14;\n        work[1][2 - c] = ipix[(c + 1) % 3] * ipix[(c + 2) % 3] >> 14;\n      }\n      FORC3\n      {\n        for (val = i = 0; i < 3; i++)\n          for (j = 0; j < 3; j++)\n            val += ppm[c][i][j] * work[i][j];\n        ipix[c] =\n            floor((ipix[c] + floor(val)) *\n                  (sgrow[col / sgx][c] * (sgx - col % sgx) + sgrow[col / sgx + 1][c] * (col % sgx)) / sgx / div[c]);\n        if (ipix[c] > 32000)\n          ipix[c] = 32000;\n        pix[c] = ipix[c];\n      }\n      pix += 4;\n    }\n  }\n  free(black);\n  free(sgrow);\n  free(sgain);\n\n  if ((badpix = (unsigned *)foveon_camf_matrix(dim, \"BadPixels\")))\n  {\n    for (i = 0; i < dim[0]; i++)\n    {\n      col = (badpix[i] >> 8 & 0xfff) - keep[0];\n      row = (badpix[i] >> 20) - keep[1];\n      if ((unsigned)(row - 1) > height - 3 || (unsigned)(col - 1) > width - 3)\n        continue;\n      memset(fsum, 0, sizeof fsum);\n      for (sum = j = 0; j < 8; j++)\n        if (badpix[i] & (1 << j))\n        {\n          FORC3 fsum[c] += (short)image[(row + hood[j * 2]) * width + col + hood[j * 2 + 1]][c];\n          sum++;\n        }\n      if (sum)\n        FORC3 image[row * width + col][c] = fsum[c] / sum;\n    }\n    free(badpix);\n  }\n\n  /* Array for 5x5 Gaussian averaging of red values */\n  smrow[6] = (int(*)[3])calloc(width * 5, sizeof **smrow);\n  merror(smrow[6], \"foveon_interpolate()\");\n  for (i = 0; i < 5; i++)\n    smrow[i] = smrow[6] + i * width;\n\n  /* Sharpen the reds against these Gaussian averages */\n  for (smlast = -1, row = 2; row < height - 2; row++)\n  {\n    while (smlast < row + 2)\n    {\n      for (i = 0; i < 6; i++)\n        smrow[(i + 5) % 6] = smrow[i];\n      pix = image[++smlast * width + 2];\n      for (col = 2; col < width - 2; col++)\n      {\n        smrow[4][col][0] = (pix[0] * 6 + (pix[-4] + pix[4]) * 4 + pix[-8] + pix[8] + 8) >> 4;\n        pix += 4;\n      }\n    }\n    pix = image[row * width + 2];\n    for (col = 2; col < width - 2; col++)\n    {\n      smred = (6 * smrow[2][col][0] + 4 * (smrow[1][col][0] + smrow[3][col][0]) + smrow[0][col][0] + smrow[4][col][0] +\n               8) >>\n              4;\n      if (col == 2)\n        smred_p = smred;\n      i = pix[0] + ((pix[0] - ((smred * 7 + smred_p) >> 3)) >> 3);\n      if (i > 32000)\n        i = 32000;\n      pix[0] = i;\n      smred_p = smred;\n      pix += 4;\n    }\n  }\n\n  /* Adjust the brighter pixels for better linearity */\n  min = 0xffff;\n  FORC3\n  {\n    i = satlev[c] / div[c];\n    if (min > i)\n      min = i;\n  }\n  limit = min * 9 >> 4;\n  for (pix = image[0]; pix < image[height * width]; pix += 4)\n  {\n    if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)\n      continue;\n    min = max = pix[0];\n    for (c = 1; c < 3; c++)\n    {\n      if (min > pix[c])\n        min = pix[c];\n      if (max < pix[c])\n        max = pix[c];\n    }\n    if (min >= limit * 2)\n    {\n      pix[0] = pix[1] = pix[2] = max;\n    }\n    else\n    {\n      i = 0x4000 - ((min - limit) << 14) / limit;\n      i = 0x4000 - (i * i >> 14);\n      i = i * i >> 14;\n      FORC3 pix[c] += (max - pix[c]) * i >> 14;\n    }\n  }\n  /*\n     Because photons that miss one detector often hit another,\n     the sum R+G+B is much less noisy than the individual colors.\n     So smooth the hues without smoothing the total.\n   */\n  for (smlast = -1, row = 2; row < height - 2; row++)\n  {\n    while (smlast < row + 2)\n    {\n      for (i = 0; i < 6; i++)\n        smrow[(i + 5) % 6] = smrow[i];\n      pix = image[++smlast * width + 2];\n      for (col = 2; col < width - 2; col++)\n      {\n        FORC3 smrow[4][col][c] = (pix[c - 4] + 2 * pix[c] + pix[c + 4] + 2) >> 2;\n        pix += 4;\n      }\n    }\n    pix = image[row * width + 2];\n    for (col = 2; col < width - 2; col++)\n    {\n      FORC3 dev[c] =\n          -foveon_apply_curve(curve[7], pix[c] - ((smrow[1][col][c] + 2 * smrow[2][col][c] + smrow[3][col][c]) >> 2));\n      sum = (dev[0] + dev[1] + dev[2]) >> 3;\n      FORC3 pix[c] += dev[c] - sum;\n      pix += 4;\n    }\n  }\n  for (smlast = -1, row = 2; row < height - 2; row++)\n  {\n    while (smlast < row + 2)\n    {\n      for (i = 0; i < 6; i++)\n        smrow[(i + 5) % 6] = smrow[i];\n      pix = image[++smlast * width + 2];\n      for (col = 2; col < width - 2; col++)\n      {\n        FORC3 smrow[4][col][c] = (pix[c - 8] + pix[c - 4] + pix[c] + pix[c + 4] + pix[c + 8] + 2) >> 2;\n        pix += 4;\n      }\n    }\n    pix = image[row * width + 2];\n    for (col = 2; col < width - 2; col++)\n    {\n      for (total[3] = 375, sum = 60, c = 0; c < 3; c++)\n      {\n        for (total[c] = i = 0; i < 5; i++)\n          total[c] += smrow[i][col][c];\n        total[3] += total[c];\n        sum += pix[c];\n      }\n      if (sum < 0)\n        sum = 0;\n      j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;\n      FORC3 pix[c] += foveon_apply_curve(curve[6], ((j * total[c] + 0x8000) >> 16) - pix[c]);\n      pix += 4;\n    }\n  }\n\n  /* Transform the image to a different colorspace */\n  for (pix = image[0]; pix < image[height * width]; pix += 4)\n  {\n    FORC3 pix[c] -= foveon_apply_curve(curve[c], pix[c]);\n    sum = (pix[0] + pix[1] + pix[1] + pix[2]) >> 2;\n    FORC3 pix[c] -= foveon_apply_curve(curve[c], pix[c] - sum);\n    FORC3\n    {\n      for (dsum = i = 0; i < 3; i++)\n        dsum += trans[c][i] * pix[i];\n      if (dsum < 0)\n        dsum = 0;\n      if (dsum > 24000)\n        dsum = 24000;\n      ipix[c] = dsum + 0.5;\n    }\n    FORC3 pix[c] = ipix[c];\n  }\n\n  /* Smooth the image bottom-to-top and save at 1/4 scale */\n  shrink = (short(*)[3])calloc((height / 4), (width / 4) * sizeof *shrink);\n  merror(shrink, \"foveon_interpolate()\");\n  for (row = height / 4; row--;)\n    for (col = 0; col < width / 4; col++)\n    {\n      ipix[0] = ipix[1] = ipix[2] = 0;\n      for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n          FORC3 ipix[c] += image[(row * 4 + i) * width + col * 4 + j][c];\n      FORC3\n      if (row + 2 > height / 4)\n        shrink[row * (width / 4) + col][c] = ipix[c] >> 4;\n      else\n        shrink[row * (width / 4) + col][c] =\n            (shrink[(row + 1) * (width / 4) + col][c] * 1840 + ipix[c] * 141 + 2048) >> 12;\n    }\n  /* From the 1/4-scale image, smooth right-to-left */\n  for (row = 0; row < (height & ~3); row++)\n  {\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    if ((row & 3) == 0)\n      for (col = width & ~3; col--;)\n        FORC3 smrow[0][col][c] = ipix[c] =\n            (shrink[(row / 4) * (width / 4) + col / 4][c] * 1485 + ipix[c] * 6707 + 4096) >> 13;\n\n    /* Then smooth left-to-right */\n    ipix[0] = ipix[1] = ipix[2] = 0;\n    for (col = 0; col < (width & ~3); col++)\n      FORC3 smrow[1][col][c] = ipix[c] = (smrow[0][col][c] * 1485 + ipix[c] * 6707 + 4096) >> 13;\n\n    /* Smooth top-to-bottom */\n    if (row == 0)\n      memcpy(smrow[2], smrow[1], sizeof **smrow * width);\n    else\n      for (col = 0; col < (width & ~3); col++)\n        FORC3 smrow[2][col][c] = (smrow[2][col][c] * 6707 + smrow[1][col][c] * 1485 + 4096) >> 13;\n\n    /* Adjust the chroma toward the smooth values */\n    for (col = 0; col < (width & ~3); col++)\n    {\n      for (i = j = 30, c = 0; c < 3; c++)\n      {\n        i += smrow[2][col][c];\n        j += image[row * width + col][c];\n      }\n      j = (j << 16) / i;\n      for (sum = c = 0; c < 3; c++)\n      {\n        ipix[c] =\n            foveon_apply_curve(curve[c + 3], ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row * width + col][c]);\n        sum += ipix[c];\n      }\n      sum >>= 3;\n      FORC3\n      {\n        i = image[row * width + col][c] + ipix[c] - sum;\n        if (i < 0)\n          i = 0;\n        image[row * width + col][c] = i;\n      }\n    }\n  }\n  free(shrink);\n  free(smrow[6]);\n  for (i = 0; i < 8; i++)\n    free(curve[i]);\n\n  /* Trim off the black border */\n  active[1] -= keep[1];\n  active[3] -= 2;\n  i = active[2] - active[0];\n  for (row = 0; row < active[3] - active[1]; row++)\n    memcpy(image[row * i], image[(row + active[1]) * width + active[0]], i * sizeof *image);\n  width = i;\n  height = row;\n}\n#undef image\n\n/* RESTRICTED code ends here */\n\n//@out COMMON\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n      r,\n      raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;\n#else\n      c,\n      m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width)\n  {\n    for (row = 0; row < raw_height - top_margin * 2; row++)\n    {\n      for (col = 0; col < fuji_width << !fuji_layout; col++)\n      {\n        if (fuji_layout)\n        {\n          r = fuji_width - 1 - col + (row >> 1);\n          c = col + ((row + 1) >> 1);\n        }\n        else\n        {\n          r = fuji_width - 1 + row - (col >> 1);\n          c = row + ((col + 1) >> 1);\n        }\n        if (r < height && c < width)\n          BAYER(r, c) = RAW(row + top_margin, col + left_margin);\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < height; row++)\n      for (col = 0; col < width; col++)\n        BAYER2(row, col) = RAW(row + top_margin, col + left_margin);\n  }\n#endif\n  if (mask[0][3] > 0)\n    goto mask_set;\n  if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)\n  {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||\n      (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||\n      (load_raw == &CLASS packed_load_raw && (load_flags & 32)))\n  {\n  sides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin + height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin + width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset(mblack, 0, sizeof mblack);\n  for (zero = m = 0; m < 8; m++)\n    for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)\n      for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)\n      {\n        c = FC(row - top_margin, col - left_margin);\n        mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];\n        mblack[4 + c]++;\n        zero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width)\n  {\n    black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  }\n  else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n  {\n    FORC4 cblack[c] = mblack[c] / mblack[4 + c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);\n#endif\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      if (BAYER(row, col) == 0)\n      {\n        tot = n = 0;\n        for (r = row - 2; r <= row + 2; r++)\n          for (c = col - 2; c <= col + 2; c++)\n            if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))\n              tot += (n++, BAYER(r, c));\n        if (n)\n          BAYER(row, col) = tot / n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);\n#endif\n}\n//@end COMMON\n\n/* @out FILEIO\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\n@end FILEIO */\n\n// @out FILEIO\n/*\n   Seach from the current directory up to the root looking for\n   a \".badpixels\" file, and fix those pixels now.\n */\nvoid CLASS bad_pixels(const char *cfname)\n{\n  FILE *fp = NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed = 0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 0, 2);\n#endif\n  if (cfname)\n    fp = fopen(cfname, \"r\");\n  // @end FILEIO\n  else\n  {\n    for (len = 32;; len *= 2)\n    {\n      fname = (char *)malloc(len);\n      if (!fname)\n        return;\n      if (getcwd(fname, len - 16))\n        break;\n      free(fname);\n      if (errno != ERANGE)\n        return;\n    }\n#if defined(WIN32) || defined(DJGPP)\n    if (fname[1] == ':')\n      memmove(fname, fname + 2, len - 2);\n    for (cp = fname; *cp; cp++)\n      if (*cp == '\\\\')\n        *cp = '/';\n#endif\n    cp = fname + strlen(fname);\n    if (cp[-1] == '/')\n      cp--;\n    while (*fname == '/')\n    {\n      strcpy(cp, \"/.badpixels\");\n      if ((fp = fopen(fname, \"r\")))\n        break;\n      if (cp == fname)\n        break;\n      while (*--cp != '/')\n        ;\n    }\n    free(fname);\n  }\n  // @out FILEIO\n  if (!fp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n    return;\n  }\n  while (fgets(line, 128, fp))\n  {\n    cp = strchr(line, '#');\n    if (cp)\n      *cp = 0;\n    if (sscanf(line, \"%d %d %d\", &col, &row, &time) != 3)\n      continue;\n    if ((unsigned)col >= width || (unsigned)row >= height)\n      continue;\n    if (time > timestamp)\n      continue;\n    for (tot = n = 0, rad = 1; rad < 3 && n == 0; rad++)\n      for (r = row - rad; r <= row + rad; r++)\n        for (c = col - rad; c <= col + rad; c++)\n          if ((unsigned)r < height && (unsigned)c < width && (r != row || c != col) && fcol(r, c) == fcol(row, col))\n          {\n            tot += BAYER2(r, c);\n            n++;\n          }\n    BAYER2(row, col) = tot / n;\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n    {\n      if (!fixed++)\n        fprintf(stderr, _(\"Fixed dead pixels at:\"));\n      fprintf(stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed)\n    fputc('\\n', stderr);\n#endif\n  fclose(fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS, 1, 2);\n#endif\n}\n\nvoid CLASS subtract(const char *fname)\n{\n  FILE *fp;\n  int dim[3] = {0, 0, 0}, comment = 0, number = 0, error = 0, nd = 0, c, row, col;\n  ushort *pixel;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 0, 2);\n#endif\n\n  if (!(fp = fopen(fname, \"rb\")))\n  {\n#ifdef DCRAW_VERBOSE\n    perror(fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_FILE;\n#endif\n    return;\n  }\n  if (fgetc(fp) != 'P' || fgetc(fp) != '5')\n    error = 1;\n  while (!error && nd < 3 && (c = fgetc(fp)) != EOF)\n  {\n    if (c == '#')\n      comment = 1;\n    if (c == '\\n')\n      comment = 0;\n    if (comment)\n      continue;\n    if (isdigit(c))\n      number = 1;\n    if (number)\n    {\n      if (isdigit(c))\n        dim[nd] = dim[nd] * 10 + c - '0';\n      else if (isspace(c))\n      {\n        number = 0;\n        nd++;\n      }\n      else\n        error = 1;\n    }\n  }\n  if (error || nd < 3)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s is not a valid PGM file!\\n\"), fname);\n#endif\n    fclose(fp);\n    return;\n  }\n  else if (dim[0] != width || dim[1] != height || dim[2] != 65535)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s has the wrong dimensions!\\n\"), fname);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_DARKFRAME_DIM;\n#endif\n    fclose(fp);\n    return;\n  }\n  pixel = (ushort *)calloc(width, sizeof *pixel);\n  merror(pixel, \"subtract()\");\n  for (row = 0; row < height; row++)\n  {\n    fread(pixel, 2, width, fp);\n    for (col = 0; col < width; col++)\n      BAYER(row, col) = MAX(BAYER(row, col) - ntohs(pixel[col]), 0);\n  }\n  free(pixel);\n  fclose(fp);\n  memset(cblack, 0, sizeof cblack);\n  black = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME, 1, 2);\n#endif\n}\n//@end FILEIO\n\n//@out COMMON\n\nstatic const uchar xlat[2][256] = {\n    {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,\n     0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,\n     0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,\n     0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,\n     0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,\n     0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,\n     0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,\n     0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,\n     0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,\n     0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,\n     0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,\n     0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,\n     0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,\n     0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},\n    {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,\n     0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,\n     0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,\n     0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,\n     0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,\n     0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,\n     0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,\n     0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,\n     0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,\n     0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,\n     0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,\n     0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,\n     0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,\n     0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};\n\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2] = {0, 0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)\n  {\n    for (i = 0; i < 48; i++)\n    {\n      g[2] = (bnd[0] + bnd[1]) / 2;\n      if (g[0])\n        bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];\n      else\n        bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0])\n      g[4] = g[2] * (1 / g[0] - 1);\n  }\n  if (g[0])\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;\n  else\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;\n  if (!mode--)\n  {\n    memcpy(gamm, g, sizeof gamm);\n    return;\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    curve[i] = 0xffff;\n    if ((r = (double)i / imax) < 1)\n      curve[i] = 0x10000 *\n                 (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))\n                       : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < 6; j++)\n      work[i][j] = j == i + 3;\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < size; k++)\n        work[i][j] += in[k][i] * in[k][j];\n  }\n  for (i = 0; i < 3; i++)\n  {\n    num = work[i][i];\n    for (j = 0; j < 6; j++)\n      work[i][j] /= num;\n    for (k = 0; k < 3; k++)\n    {\n      if (k == i)\n        continue;\n      num = work[k][i];\n      for (j = 0; j < 6; j++)\n        work[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i = 0; i < size; i++)\n    for (j = 0; j < 3; j++)\n      for (out[i][j] = k = 0; k < 3; k++)\n        out[i][j] += work[j][k + 3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i = 0; i < colors; i++) /* Multiply out XYZ colorspace */\n    for (j = 0; j < 3; j++)\n      for (cam_rgb[i][j] = k = 0; k < 3; k++)\n        cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i = 0; i < colors; i++)\n  {                               /* Normalize cam_rgb so that */\n    for (num = j = 0; j < 3; j++) /* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if (num > 0.00001)\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] /= num;\n      pre_mul[i] = 1 / num;\n    }\n    else\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] = 0.0;\n      pre_mul[i] = 1.0;\n    }\n  }\n  pseudoinverse(cam_rgb, inverse, colors);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n  // Coordinates of the GretagMacbeth ColorChecker squares\n  // width, height, 1st_column, 1st_row\n  int cut[NSQ][4];                                             // you must set these\n                                                               // ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin\n                                         {0.377, 0.345, 35.8}, // Light Skin\n                                         {0.247, 0.251, 19.3}, // Blue Sky\n                                         {0.337, 0.422, 13.3}, // Foliage\n                                         {0.265, 0.240, 24.3}, // Blue Flower\n                                         {0.261, 0.343, 43.1}, // Bluish Green\n                                         {0.506, 0.407, 30.1}, // Orange\n                                         {0.211, 0.175, 12.0}, // Purplish Blue\n                                         {0.453, 0.306, 19.8}, // Moderate Red\n                                         {0.285, 0.202, 6.6},  // Purple\n                                         {0.380, 0.489, 44.3}, // Yellow Green\n                                         {0.473, 0.438, 43.1}, // Orange Yellow\n                                         {0.187, 0.129, 6.1},  // Blue\n                                         {0.305, 0.478, 23.4}, // Green\n                                         {0.539, 0.313, 12.0}, // Red\n                                         {0.448, 0.470, 59.1}, // Yellow\n                                         {0.364, 0.233, 19.8}, // Magenta\n                                         {0.196, 0.252, 19.8}, // Cyan\n                                         {0.310, 0.316, 90.0}, // White\n                                         {0.310, 0.316, 59.1}, // Neutral 8\n                                         {0.310, 0.316, 36.2}, // Neutral 6.5\n                                         {0.310, 0.316, 19.8}, // Neutral 5\n                                         {0.310, 0.316, 9.0},  // Neutral 3.5\n                                         {0.310, 0.316, 3.1}}; // Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset(gmb_cam, 0, sizeof gmb_cam);\n  for (sq = 0; sq < NSQ; sq++)\n  {\n    FORCC count[c] = 0;\n    for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)\n      for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)\n      {\n        c = FC(row, col);\n        if (c >= colors)\n          c -= 2;\n        gmb_cam[sq][c] += BAYER2(row, col);\n        BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;\n        count[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse(gmb_xyz, inverse, NSQ);\n  for (pass = 0; pass < 2; pass++)\n  {\n    for (raw_color = i = 0; i < colors; i++)\n      for (j = 0; j < 3; j++)\n        for (cam_xyz[i][j] = k = 0; k < NSQ; k++)\n          cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff(rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq = 0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose)\n  {\n    printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));\n    puts(\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n  FORC(nc)\n  { /* denoise R,G1,B,G3 individually */\n    for (i = 0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass = lev = 0; lev < 5; lev++)\n    {\n      lpass = size * ((lev & 1) + 1);\n      for (row = 0; row < iheight; row++)\n      {\n        hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n        for (col = 0; col < iwidth; col++)\n          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n      }\n      for (col = 0; col < iwidth; col++)\n      {\n        hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n        for (row = 0; row < iheight; row++)\n          fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i = 0; i < size; i++)\n      {\n        fimg[hpass + i] -= fimg[lpass + i];\n        if (fimg[hpass + i] < -thold)\n          fimg[hpass + i] += thold;\n        else if (fimg[hpass + i] > thold)\n          fimg[hpass + i] -= thold;\n        else\n          fimg[hpass + i] = 0;\n        if (hpass)\n          fimg[i] += fimg[hpass + i];\n      }\n      hpass = lpass;\n    }\n    for (i = 0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n  }\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)\n#endif\n  {\n    temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);\n    FORC(nc)\n    { /* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass = lev = 0; lev < 5; lev++)\n      {\n        lpass = size * ((lev & 1) + 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (row = 0; row < iheight; row++)\n        {\n          hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n          for (col = 0; col < iwidth; col++)\n            fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n        }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (col = 0; col < iwidth; col++)\n        {\n          hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n          for (row = 0; row < iheight; row++)\n            fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n        }\n        thold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (i = 0; i < size; i++)\n        {\n          fimg[hpass + i] -= fimg[lpass + i];\n          if (fimg[hpass + i] < -thold)\n            fimg[hpass + i] += thold;\n          else if (fimg[hpass + i] > thold)\n            fimg[hpass + i] -= thold;\n          else\n            fimg[hpass + i] = 0;\n          if (hpass)\n            fimg[i] += fimg[hpass + i];\n        }\n        hpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n  /* the following loops are hard to parallize, no idea yes,\n   * problem is wlast which is carrying dependency\n   * second part should be easyer, but did not yet get it right.\n   */\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i, j;\n  double m1, m2, c1, c2;\n  int o1_1, o1_2, o1_3, o1_4;\n  int o2_1, o2_2, o2_3, o2_4;\n  ushort(*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if (half_size || shrink)\n    return;\n  if (FC(oj, oi) != 3)\n    oj++;\n  if (FC(oj, oi) != 3)\n    oi++;\n  if (FC(oj, oi) != 3)\n    oj--;\n\n  img = (ushort(*)[4])calloc(height * width, sizeof *image);\n  merror(img, \"green_matching()\");\n  memcpy(img, image, height * width * sizeof *image);\n\n  for (j = oj; j < height - margin; j += 2)\n    for (i = oi; i < width - margin; i += 2)\n    {\n      o1_1 = img[(j - 1) * width + i - 1][1];\n      o1_2 = img[(j - 1) * width + i + 1][1];\n      o1_3 = img[(j + 1) * width + i - 1][1];\n      o1_4 = img[(j + 1) * width + i + 1][1];\n      o2_1 = img[(j - 2) * width + i][3];\n      o2_2 = img[(j + 2) * width + i][3];\n      o2_3 = img[j * width + i - 2][3];\n      o2_4 = img[j * width + i + 2][3];\n\n      m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;\n      m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;\n\n      c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +\n            abs(o1_2 - o1_4)) /\n           6.0;\n      c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +\n            abs(o2_2 - o2_4)) /\n           6.0;\n      if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))\n      {\n        f = image[j * width + i][3] * m1 / m2;\n        image[j * width + i][3] = f > 0xffff ? 0xffff : f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img = 0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);\n#endif\n\n  if (user_mul[0])\n    memcpy(pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))\n  {\n    memset(dsum, 0, sizeof dsum);\n    bottom = MIN(greybox[1] + greybox[3], height);\n    right = MIN(greybox[0] + greybox[2], width);\n    for (row = greybox[1]; row < bottom; row += 8)\n      for (col = greybox[0]; col < right; col += 8)\n      {\n        memset(sum, 0, sizeof sum);\n        for (y = row; y < row + 8 && y < bottom; y++)\n          for (x = col; x < col + 8 && x < right; x++)\n            FORC4\n            {\n              if (filters)\n              {\n                c = fcol(y, x);\n                val = BAYER2(y, x);\n              }\n              else\n                val = image[y * width + x][c];\n              if (val > maximum - 25)\n                goto skip_block;\n              if ((val -= cblack[c]) < 0)\n                val = 0;\n              sum[c] += val;\n              sum[c + 4]++;\n              if (filters)\n                break;\n            }\n        FORC(8) dsum[c] += sum[c];\n      skip_block:;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1)\n  {\n    memset(sum, 0, sizeof sum);\n    for (row = 0; row < 8; row++)\n      for (col = 0; col < 8; col++)\n      {\n        c = FC(row, col);\n        if ((val = white[row][col] - cblack[c]) > 0)\n          sum[c] += val;\n        sum[c + 4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (load_raw == &LibRaw::nikon_load_sraw)\n    {\n      // Nikon sRAW: camera WB already applied:\n      pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;\n    }\n    else\n#endif\n        if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy(pre_mul, cam_mul, sizeof pre_mul);\n    else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n      fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&\n      cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)\n  {\n    for (c = 0; c < 3; c++)\n      pre_mul[c] /= cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0)\n    pre_mul[1] = 1;\n  if (pre_mul[3] == 0)\n    pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold)\n    wavelet_denoise();\n  maximum -= black;\n  for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)\n  {\n    if (dmin > pre_mul[c])\n      dmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n      dmax = pre_mul[c];\n  }\n  if (!highlight)\n    dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n  {\n    fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf(stderr, \" %f\", pre_mul[c]);\n    fputc('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)\n  {\n    FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight * iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i = 0; i < size * 4; i++)\n  {\n    if (!(val = ((ushort *)image)[i]))\n      continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3)\n  {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c = 0; c < 4; c += 2)\n    {\n      if (aber[c] == 1)\n        continue;\n      img = (ushort *)malloc(size * sizeof *img);\n      merror(img, \"scale_colors()\");\n      for (i = 0; i < size; i++)\n        img[i] = image[i][c];\n      for (row = 0; row < iheight; row++)\n      {\n        ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;\n        if (ur > iheight - 2)\n          continue;\n        fr -= ur;\n        for (col = 0; col < iwidth; col++)\n        {\n          uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;\n          if (uc > iwidth - 2)\n            continue;\n          fc -= uc;\n          pix = img + ur * iwidth + uc;\n          image[row * iwidth + col][c] =\n              (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;\n        }\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort(*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);\n#endif\n  if (shrink)\n  {\n    if (half_size)\n    {\n      height = iheight;\n      width = iwidth;\n      if (filters == 9)\n      {\n        for (row = 0; row < 3; row++)\n          for (col = 1; col < 4; col++)\n            if (!(image[row * width + col][0] | image[row * width + col][2]))\n              goto break2;\n      break2:\n        for (; row < height; row += 3)\n          for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)\n          {\n            img = image + row * width + col;\n            for (c = 0; c < 3; c += 2)\n              img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n          }\n      }\n    }\n    else\n    {\n      img = (ushort(*)[4])calloc(height, width * sizeof *img);\n      merror(img, \"pre_interpolate()\");\n      for (row = 0; row < height; row++)\n        for (col = 0; col < width; col++)\n        {\n          c = fcol(row, col);\n          img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];\n        }\n      free(image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3)\n  {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size)\n      colors++;\n    else\n    {\n      for (row = FC(1, 0) >> 1; row < height; row += 2)\n        for (col = FC(row, 1) & 1; col < width; col += 2)\n          image[row * width + col][1] = image[row * width + col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size)\n    filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);\n#endif\n}\n\nvoid CLASS border_interpolate(int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      if (col == border && row >= border && row < height - border)\n        col = width - border;\n      memset(sum, 0, sizeof sum);\n      for (y = row - 1; y != row + 2; y++)\n        for (x = col - 1; x != col + 2; x++)\n          if (y < height && x < width)\n          {\n            f = fcol(y, x);\n            sum[f] += image[y * width + x][f];\n            sum[f + 4]++;\n          }\n      f = fcol(row, col);\n      FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size = 16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#endif\n\n  if (filters == 9)\n    size = 6;\n  border_interpolate(1);\n  for (row = 0; row < size; row++)\n    for (col = 0; col < size; col++)\n    {\n      ip = code[row][col] + 1;\n      f = fcol(row, col);\n      memset(sum, 0, sizeof sum);\n      for (y = -1; y <= 1; y++)\n        for (x = -1; x <= 1; x++)\n        {\n          shift = (y == 0) + (x == 0);\n          color = fcol(row + y, col + x);\n          if (color == f)\n            continue;\n          *ip++ = (width * y + x) * 4 + color;\n          *ip++ = shift;\n          *ip++ = color;\n          sum[color] += 1 << shift;\n        }\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n      if (c != f)\n      {\n        *ip++ = c;\n        *ip++ = sum[c] > 0 ? 256 / sum[c] : 0;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#endif\n  lin_interpolate_loop(code, size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp,\n      terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,\n                 -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,\n                 -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,\n                 -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,\n                 -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,\n                 -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,\n                 -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,\n                 -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,\n                 -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,\n                 -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,\n                 +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,\n                 +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,\n                 +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,\n                 +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,\n                 +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,\n                 +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},\n      chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};\n  ushort(*brow[5])[4], *pix;\n  int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1)\n    prow = pcol = 16;\n  if (filters == 9)\n    prow = pcol = 6;\n  ip = (int *)calloc(prow * pcol, 1280);\n  merror(ip, \"vng_interpolate()\");\n  for (row = 0; row < prow; row++) /* Precalculate for VNG */\n    for (col = 0; col < pcol; col++)\n    {\n      code[row][col] = ip;\n      for (cp = terms, t = 0; t < 64; t++)\n      {\n        y1 = *cp++;\n        x1 = *cp++;\n        y2 = *cp++;\n        x2 = *cp++;\n        weight = *cp++;\n        grads = *cp++;\n        color = fcol(row + y1, col + x1);\n        if (fcol(row + y2, col + x2) != color)\n          continue;\n        diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;\n        if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)\n          continue;\n        *ip++ = (y1 * width + x1) * 4 + color;\n        *ip++ = (y2 * width + x2) * 4 + color;\n        *ip++ = weight;\n        for (g = 0; g < 8; g++)\n          if (grads & 1 << g)\n            *ip++ = g;\n        *ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp = chood, g = 0; g < 8; g++)\n      {\n        y = *cp++;\n        x = *cp++;\n        *ip++ = (y * width + x) * 4;\n        color = fcol(row, col);\n        if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)\n          *ip++ = (y * width + x) * 8 + color;\n        else\n          *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);\n  merror(brow[4], \"vng_interpolate()\");\n  for (row = 0; row < 3; row++)\n    brow[row] = brow[4] + row * width;\n  for (row = 2; row < height - 2; row++)\n  { /* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!((row - 2) % 256))\n      RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);\n#endif\n    for (col = 2; col < width - 2; col++)\n    {\n      pix = image[row * width + col];\n      ip = code[row % prow][col % pcol];\n      memset(gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX)\n      { /* Calculate gradients */\n        diff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n        gval[ip[3]] += diff;\n        ip += 5;\n        if ((g = ip[-1]) == -1)\n          continue;\n        gval[g] += diff;\n        while ((g = *ip++) != -1)\n          gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0]; /* Choose a threshold */\n      for (g = 1; g < 8; g++)\n      {\n        if (gmin > gval[g])\n          gmin = gval[g];\n        if (gmax < gval[g])\n          gmax = gval[g];\n      }\n      if (gmax == 0)\n      {\n        memcpy(brow[2][col], pix, sizeof *image);\n        continue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset(sum, 0, sizeof sum);\n      color = fcol(row, col);\n      for (num = g = 0; g < 8; g++, ip += 2)\n      { /* Average the neighbors */\n        if (gval[g] <= thold)\n        {\n          FORCC\n          if (c == color && ip[1])\n            sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n          else\n            sum[c] += pix[ip[0] + c];\n          num++;\n        }\n      }\n      FORCC\n      { /* Save to buffer */\n        t = pix[color];\n        if (c != color)\n          t += (sum[c] - sum[color]) / num;\n        brow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3) /* Write buffer to image */\n      memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n    for (g = 0; g < 4; g++)\n      brow[(g - 1) & 3] = brow[g];\n  }\n  memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n  memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);\n  free(brow[4]);\n  free(code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = {1, width, -1, -width, 1};\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort(*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 3; row < height - 3; row++)\n    for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; i++)\n      {\n        guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];\n        diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +\n                  (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)\n        pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)\n      {\n        diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);\n        guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n        pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n        pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab(ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb)\n  {\n#ifndef LIBRAW_NOTHREADS\n    if (cbrt[0] < -1.0f)\n#endif\n      for (i = 0; i < 0x10000; i++)\n      {\n        r = i / 65535.0;\n        cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;\n      }\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (xyz_cam[i][j] = k = 0; k < 3; k++)\n          xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC\n  {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int)xyz[0])];\n  xyz[1] = cbrt[CLIP((int)xyz[1])];\n  xyz[2] = cbrt[CLIP((int)xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512 /* Tile Size */\n#define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate(int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},\n                     dir[4] = {1, TS, TS + 1, TS - 1};\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n        {\n          val = pix[hex[c]][1];\n          if (min > val)\n            min = val;\n          if (max < val)\n            max = val;\n        }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row - sgrow) % 3)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n          row--;\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n          memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n      FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);\n\n      /* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n        {\n          if ((f = fcol(row, col)) == 1)\n            continue;\n          pix = image + row * width + col;\n          hex = allhex[row % 3][col % 3][0];\n          color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n          color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);\n          FORC(2)\n          color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +\n                            33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);\n          FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n        }\n\n      for (pass = 0; pass < passes; pass++)\n      {\n        if (pass == 1)\n          memcpy(rgb += 4, buffer, 4 * sizeof *rgb);\n\n        /* Recalculate green from interpolated values of closer pixels:\t*/\n        if (pass)\n        {\n          for (row = top + 2; row < mrow - 2; row++)\n            for (col = left + 2; col < mcol - 2; col++)\n            {\n              if ((f = fcol(row, col)) == 1)\n                continue;\n              pix = image + row * width + col;\n              hex = allhex[row % 3][col % 3][1];\n              for (d = 3; d < 6; d++)\n              {\n                rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                val =\n                    rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n              }\n            }\n        }\n\n        /* Interpolate red and blue values for solitary green pixels:\t*/\n        for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n          for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n          {\n            rix = &rgb[0][row - top][col - left];\n            h = fcol(row, col + 1);\n            memset(diff, 0, sizeof diff);\n            for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)\n            {\n              for (c = 0; c < 2; c++, h ^= 2)\n              {\n                g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                if (d > 1)\n                  diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);\n              }\n              if (d > 1 && (d & 1))\n                if (diff[d - 1] < diff[d])\n                  FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n              if (d < 2 || (d & 1))\n              {\n                FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                rix += TS * TS;\n              }\n            }\n          }\n\n        /* Interpolate red for blue pixels and vice versa:\t\t*/\n        for (row = top + 3; row < mrow - 3; row++)\n          for (col = left + 3; col < mcol - 3; col++)\n          {\n            if ((f = 2 - fcol(row, col)) == 1)\n              continue;\n            rix = &rgb[0][row - top][col - left];\n            c = (row - sgrow) % 3 ? TS : 1;\n            h = 3 * (c ^ TS ^ 1);\n            for (d = 0; d < 4; d++, rix += TS * TS)\n            {\n              i = d > 1 || ((d ^ c) & 1) || ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <\n                                             2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))\n                      ? c\n                      : h;\n              rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);\n            }\n          }\n\n        /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n        for (row = top + 2; row < mrow - 2; row++)\n          if ((row - sgrow) % 3)\n            for (col = left + 2; col < mcol - 2; col++)\n              if ((col - sgcol) % 3)\n              {\n                rix = &rgb[0][row - top][col - left];\n                hex = allhex[row % 3][col % 3][1];\n                for (d = 0; d < ndir; d += 2, rix += TS * TS)\n                  if (hex[d] + hex[d + 1])\n                  {\n                    g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                  }\n                  else\n                  {\n                    g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                  }\n              }\n      }\n      rgb = (ushort(*)[TS][TS][3])buffer;\n      mrow -= top;\n      mcol -= left;\n\n      /* Convert to CIELab and differentiate in all directions:\t*/\n      for (d = 0; d < ndir; d++)\n      {\n        for (row = 2; row < mrow - 2; row++)\n          for (col = 2; col < mcol - 2; col++)\n            cielab(rgb[d][row][col], lab[row][col]);\n        for (f = dir[d & 3], row = 3; row < mrow - 3; row++)\n          for (col = 3; col < mcol - 3; col++)\n          {\n            lix = &lab[row][col];\n            g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n            drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                               SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n          }\n      }\n\n      /* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir * TS * TS);\n      for (row = 4; row < mrow - 4; row++)\n        for (col = 4; col < mcol - 4; col++)\n        {\n          for (tr = FLT_MAX, d = 0; d < ndir; d++)\n            if (tr > drv[d][row][col])\n              tr = drv[d][row][col];\n          tr *= 8;\n          for (d = 0; d < ndir; d++)\n            for (v = -1; v <= 1; v++)\n              for (h = -1; h <= 1; h++)\n                if (drv[d][row + v][col + h] <= tr)\n                  homo[d][row][col]++;\n        }\n\n      /* Average the most homogenous pixels for the final result:\t*/\n      if (height - top < TS + 4)\n        mrow = height - top + 2;\n      if (width - left < TS + 4)\n        mcol = width - left + 2;\n      for (row = MIN(top, 8); row < mrow - 8; row++)\n        for (col = MIN(left, 8); col < mcol - 8; col++)\n        {\n          for (d = 0; d < ndir; d++)\n            for (hm[d] = 0, v = -2; v <= 2; v++)\n              for (h = -2; h <= 2; h++)\n                hm[d] += homo[d][row + v][col + h];\n          for (d = 0; d < ndir - 4; d++)\n            if (hm[d] < hm[d + 4])\n              hm[d] = 0;\n            else if (hm[d] > hm[d + 4])\n              hm[d + 4] = 0;\n          for (max = hm[0], d = 1; d < ndir; d++)\n            if (max < hm[d])\n              max = hm[d];\n          max -= max >> 3;\n          memset(avg, 0, sizeof avg);\n          for (d = 0; d < ndir; d++)\n            if (hm[d] >= max)\n            {\n              FORC3 avg[c] += rgb[d][row][col][c];\n              avg[3]++;\n            }\n          FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n        }\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + TS, height - 2);\n  const int collimit = MIN(left + TS, width - 2);\n\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n      out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],\n                                                                short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort(*pix)[4];\n  ushort(*rix)[3];\n  short(*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4 * width;\n  const unsigned rowlimit = MIN(top + TS - 1, height - 3);\n  const unsigned collimit = MIN(left + TS - 1, width - 3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top + 1; row < rowlimit; row++)\n  {\n    pix = image + row * width + left;\n    rix = &inout_rgb[row - top][0];\n    lix = &out_lab[row - top][0];\n\n    for (col = left + 1; col < collimit; col++)\n    {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1)\n      {\n        c = FC(row + 1, col);\n        t1 = 2 - c;\n        val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);\n      }\n      else\n      {\n        t1 = -4 + c; /* -4+c: pixel of color c to the left */\n        t2 = 4 + c;  /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -\n                            rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                           2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row, col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0], lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],\n                                                         short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++)\n  {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],\n                                                 char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short(*lix)[3];\n  short(*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = {-1, 1, -TS, TS};\n  const int rowlimit = MIN(top + TS - 2, height - 4);\n  const int collimit = MIN(left + TS - 2, width - 4);\n  int homogeneity;\n  char(*homogeneity_map_p)[2];\n\n  memset(out_homogeneity_map, 0, 2 * TS * TS);\n\n  for (row = top + 2; row < rowlimit; row++)\n  {\n    tr = row - top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction = 0; direction < 2; direction++)\n    {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col = left + 2; col < collimit; col++)\n    {\n      tc = col - left;\n      homogeneity_map_p++;\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        lix = ++lixs[direction];\n        for (i = 0; i < 4; i++)\n        {\n          adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n      for (direction = 0; direction < 2; direction++)\n      {\n        homogeneity = 0;\n        for (i = 0; i < 4; i++)\n        {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)\n          {\n            homogeneity++;\n          }\n        }\n        homogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],\n                                                      char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top + TS - 3, height - 5);\n  const int collimit = MIN(left + TS - 3, width - 5);\n\n  ushort(*pix)[4];\n  ushort(*rix[2])[3];\n\n  for (row = top + 3; row < rowlimit; row++)\n  {\n    tr = row - top;\n    pix = &image[row * width + left + 2];\n    for (direction = 0; direction < 2; direction++)\n    {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col = left + 3; col < collimit; col++)\n    {\n      tc = col - left;\n      pix++;\n      for (direction = 0; direction < 2; direction++)\n      {\n        rix[direction]++;\n      }\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        hm[direction] = 0;\n        for (i = tr - 1; i <= tr + 1; i++)\n        {\n          for (j = tc - 1; j <= tc + 1; j++)\n          {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1])\n      {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      }\n      else\n      {\n        FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4], r;\n  char *buffer;\n  ushort(*rgb)[TS][TS][3];\n  short(*lab)[TS][TS][3];\n  char(*homo)[TS][2];\n  int terminate_flag = 0;\n\n  cielab(0, 0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *)malloc(26 * TS * TS); /* 1664 kB */\n    merror(buffer, \"ahd_interpolate()\");\n    rgb = (ushort(*)[TS][TS][3])buffer;\n    lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n    homo = (char(*)[TS][2])(buffer + 24 * TS * TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top = 2; top < height - 5; top += TS - 6)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n      if (0 == omp_get_thread_num())\n#endif\n        if (callbacks.progress_cb)\n        {\n          int rr =\n              (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);\n          if (rr)\n            terminate_flag = 1;\n        }\n#endif\n      for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)\n      {\n        ahd_interpolate_green_h_and_v(top, left, rgb);\n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free(buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (terminate_flag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = {-1, 1, -TS, TS};\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][TS][3], (*lix)[3];\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab(0, 0);\n  border_interpolate(5);\n  buffer = (char *)malloc(26 * TS * TS);\n  merror(buffer, \"ahd_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n  homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);\n\n  for (top = 2; top < height - 5; top += TS - 6)\n    for (left = 2; left < width - 5; left += TS - 6)\n    {\n\n      /*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top + TS && row < height - 2; row++)\n      {\n        col = left + (FC(row, left) & 1);\n        for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)\n        {\n          pix = image + row * width + col;\n          val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n          rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n          val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n          rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n        }\n      }\n\n      /*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d = 0; d < 2; d++)\n        for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)\n          for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)\n          {\n            pix = image + row * width + col;\n            rix = &rgb[d][row - top][col - left];\n            lix = &lab[d][row - top][col - left];\n            if ((c = 2 - FC(row, col)) == 1)\n            {\n              c = FC(row + 1, col);\n              val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);\n              rix[0][2 - c] = CLIP(val);\n              val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);\n            }\n            else\n              val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -\n                                  rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                                 2);\n            rix[0][c] = CLIP(val);\n            c = FC(row, col);\n            rix[0][c] = pix[0][c];\n            cielab(rix[0], lix[0]);\n          }\n      /*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset(homo, 0, 2 * TS * TS);\n      for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)\n      {\n        tr = row - top;\n        for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n          {\n            lix = &lab[d][tr][tc];\n            for (i = 0; i < 4; i++)\n            {\n              ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);\n              abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);\n            }\n          }\n          leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n          abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n          for (d = 0; d < 2; d++)\n            for (i = 0; i < 4; i++)\n              if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n                homo[d][tr][tc]++;\n        }\n      }\n      /*  Combine the most homogenous pixels for the final result:\t*/\n      for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)\n      {\n        tr = row - top;\n        for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n            for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)\n              for (j = tc - 1; j <= tc + 1; j++)\n                hm[d] += homo[d][i][j];\n          if (hm[0] != hm[1])\n            FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n          else\n            FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n        }\n      }\n    }\n  free(buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = /* Optimal 9-element median search */\n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n                                       {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned)(colors - 3) > 1)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n#endif\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow(2.0, 4 - highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc = 0, c = 1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c])\n      kc = c;\n  high = height / SCALE;\n  wide = width / SCALE;\n  map = (float *)calloc(high, wide * sizeof *map);\n  merror(map, \"recover_highlights()\");\n  FORCC if (c != kc)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);\n#endif\n    memset(map, 0, high * wide * sizeof *map);\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        sum = wgt = count = 0;\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)\n            {\n              sum += pixel[c];\n              wgt += pixel[kc];\n              count++;\n            }\n          }\n        if (count == SCALE * SCALE)\n          map[mrow * wide + mcol] = sum / wgt;\n      }\n    for (spread = 32 / grow; spread--;)\n    {\n      for (mrow = 0; mrow < high; mrow++)\n        for (mcol = 0; mcol < wide; mcol++)\n        {\n          if (map[mrow * wide + mcol])\n            continue;\n          sum = count = 0;\n          for (d = 0; d < 8; d++)\n          {\n            y = mrow + dir[d][0];\n            x = mcol + dir[d][1];\n            if (y < high && x < wide && map[y * wide + x] > 0)\n            {\n              sum += (1 + (d & 1)) * map[y * wide + x];\n              count += 1 + (d & 1);\n            }\n          }\n          if (count > 3)\n            map[mrow * wide + mcol] = -(sum + grow) / (count + grow);\n        }\n      for (change = i = 0; i < high * wide; i++)\n        if (map[i] < 0)\n        {\n          map[i] = -map[i];\n          change = 1;\n        }\n      if (!change)\n        break;\n    }\n    for (i = 0; i < high * wide; i++)\n      if (map[i] == 0)\n        map[i] = 1;\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] > 1)\n            {\n              val = pixel[kc] * map[mrow * wide + mcol];\n              if (pixel[c] < val)\n                pixel[c] = CLIP(val);\n            }\n          }\n      }\n  }\n  free(map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag = get2();\n  *type = get2();\n  *len = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)\n    fseek(ifp, get4() + base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == toff)\n      thumb_offset = get4() + base;\n    if (tag == tlen)\n      thumb_length = get4();\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n//@end COMMON\n\nint CLASS parse_tiff_ifd(int base);\n\n//@out COMMON\n\nstatic float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }\nstatic float powf64(float a, float b) { return powf_lim(a, b, 64.f); }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x)\n{\n  float t;\n  if (x >= 0.0)\n  {\n    t = ceilf(x);\n    if (t - x > 0.5)\n      t -= 1.0;\n    return t;\n  }\n  else\n  {\n    t = ceilf(-x);\n    if (t + x > 0.5)\n      t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))\n    return 0.0f;\n  return powf64(2.0, in / 64.0);\n}\n\nstatic float _CanonConvertEV(short in)\n{\n  short EV, Sign, Frac;\n  float Frac_f;\n  EV = in;\n  if (EV < 0)\n  {\n    EV = -EV;\n    Sign = -1;\n  }\n  else\n  {\n    Sign = 1;\n  }\n  Frac = EV & 0x1f;\n  EV -= Frac; // remove fraction\n\n  if (Frac == 0x0c)\n  { // convert 1/3 and 2/3 codes\n    Frac_f = 32.0f / 3.0f;\n  }\n  else if (Frac == 0x14)\n  {\n    Frac_f = 64.0f / 3.0f;\n  }\n  else\n    Frac_f = (float)Frac;\n\n  return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x80000001) || // 1D\n      (id == 0x80000174) || // 1D2\n      (id == 0x80000232) || // 1D2N\n      (id == 0x80000169) || // 1D3\n      (id == 0x80000281)    // 1D4\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000167) || // 1Ds\n           (id == 0x80000188) || // 1Ds2\n           (id == 0x80000215) || // 1Ds3\n           (id == 0x80000269) || // 1DX\n           (id == 0x80000328) || // 1DX2\n           (id == 0x80000324) || // 1DC\n           (id == 0x80000213) || // 5D\n           (id == 0x80000218) || // 5D2\n           (id == 0x80000285) || // 5D3\n           (id == 0x80000349) || // 5D4\n           (id == 0x80000382) || // 5DS\n           (id == 0x80000401) || // 5DS R\n           (id == 0x80000302)    // 6D\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000331) || // M\n           (id == 0x80000355) || // M2\n           (id == 0x80000374) || // M3\n           (id == 0x80000384) || // M10\n           (id == 0x80000394)    // M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n  }\n  else if ((id == 0x01140000) || // D30\n           (id == 0x01668000) || // D60\n           (id > 0x80000000))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n  }\n  else\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n  }\n\n  return;\n}\n\nvoid CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,\n         iCanonFocalType = 0;\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id)\n  {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12))\n      iCanonLensID = 151;\n    else\n      iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n  {\n    if (iCanonFocalType >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n    if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'\n      imgdata.lens.makernotes.FocalType = 1;\n  }\n  if (!imgdata.lens.makernotes.CurFocal)\n  {\n    if (iCanonCurFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n  }\n  if (!imgdata.lens.makernotes.LensID)\n  {\n    if (iCanonLensID >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n  }\n  if (!imgdata.lens.makernotes.MinFocal)\n  {\n    if (iCanonMinFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n  }\n  if (!imgdata.lens.makernotes.MaxFocal)\n  {\n    if (iCanonMaxFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n  }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)\n  {\n    if (iCanonLens + 64 >= maxlen)\n      return;                        // broken;\n    if (CameraInfo[iCanonLens] < 65) // non-Canon lens\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2();\n  get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2();\n  get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2();\n  get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n  {\n    imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n  }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets(short WBCTversion)\n{\n  if (WBCTversion == 0)\n    for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if (WBCTversion == 1)\n    for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3\n                                  (unique_id == 0x80000384) || // M10\n                                  (unique_id == 0x80000394) || // M5\n                                  (unique_id == 0x03970000) || // G7 X Mark II\n                                  (unique_id == 0x04100000)))  // G9 X Mark II\n    for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X\n    for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  return;\n}\n\nvoid CLASS processNikonLensData(uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n  {\n    if (imgdata.lens.nikon.NikonLensType & 0x04)\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n    else\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n    imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n  {\n    imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n    imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20)\n  {\n    switch (len)\n    {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n    {\n      if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n        imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n      if (LensData[i + 7])\n        imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n    }\n    imgdata.lens.makernotes.LensID =\n        (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |\n        (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |\n        (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |\n        (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;\n  }\n  else if ((len == 459) || (len == 590))\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n  }\n  else if (len == 509)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n  }\n  else if (len == 879)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n  }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures(unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) || // E-1\n      (id == 0x4434303431ULL) || // E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n    if ((id == 0x4434303430ULL) ||                              // E-1\n        (id == 0x4434303431ULL) ||                              // E-330\n        ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n        (id == 0x5330303233ULL) ||                              // E-620\n        (id == 0x5330303239ULL) ||                              // E-450\n        (id == 0x5330303330ULL) ||                              // E-600\n        (id == 0x5330303333ULL))                                // E-5\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n    }\n    else\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n    }\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)\n{\n\n  if (tag == 0x0001)\n    Canon_CameraSettings();\n  else if (tag == 0x0002) // focal length\n  {\n    imgdata.lens.makernotes.FocalType = get2();\n    imgdata.lens.makernotes.CurFocal = get2();\n    if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  }\n\n  else if (tag == 0x0004) // shot info\n  {\n    short tempAp;\n    fseek(ifp, 30, SEEK_CUR);\n    imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n    fseek(ifp, 8 - 32, SEEK_CUR);\n    if ((tempAp = get2()) != 0x7fff)\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n    if (imgdata.lens.makernotes.CurAp < 0.7f)\n    {\n      fseek(ifp, 32, SEEK_CUR);\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n    }\n    if (!aperture)\n      aperture = imgdata.lens.makernotes.CurAp;\n  }\n\n  else if (tag == 0x0095 && // lens model tag\n           !imgdata.lens.makernotes.Lens[0])\n  {\n    fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens\n      fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n    else\n    {\n      char efs[2];\n      imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n      imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n      fread(efs, 2, 1, ifp);\n      if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n      { // \"EF-S, TS-E, MP-E, EF-M\" lenses\n        imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n        imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n        imgdata.lens.makernotes.Lens[4] = 32;\n        if (efs[1] == 83)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n        }\n        else if (efs[1] == 77)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n        }\n      }\n      else\n      { // \"EF\" lenses\n        imgdata.lens.makernotes.Lens[2] = 32;\n        imgdata.lens.makernotes.Lens[3] = efs[0];\n        imgdata.lens.makernotes.Lens[4] = efs[1];\n      }\n      fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n    }\n  }\n\n  else if (tag == 0x00a9)\n  {\n    long int save1 = ftell(ifp);\n    fseek(ifp, save1 + (0x5 << 1), SEEK_SET);\n    Canon_WBpresets(0, 0);\n    fseek(ifp, save1, SEEK_SET);\n  }\n\n  else if (tag == 0x00e0) // sensor info\n  {\n    imgdata.makernotes.canon.SensorWidth = (get2(), get2());\n    imgdata.makernotes.canon.SensorHeight = get2();\n    imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());\n    imgdata.makernotes.canon.SensorTopBorder = get2();\n    imgdata.makernotes.canon.SensorRightBorder = get2();\n    imgdata.makernotes.canon.SensorBottomBorder = get2();\n    imgdata.makernotes.canon.BlackMaskLeftBorder = get2();\n    imgdata.makernotes.canon.BlackMaskTopBorder = get2();\n    imgdata.makernotes.canon.BlackMaskRightBorder = get2();\n    imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n  }\n\n  else if (tag == 0x4001 && len > 500)\n  {\n    int c;\n    long int save1 = ftell(ifp);\n    switch (len)\n    {\n    case 582:\n      imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D\n      {\n        fseek(ifp, save1 + (0x23 << 1), SEEK_SET);\n        Canon_WBpresets(2, 2);\n        fseek(ifp, save1 + (0x4b << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 653:\n      imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2\n      {\n        fseek(ifp, save1 + (0x27 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 796:\n      imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x4e << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n    // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n    // 7D / 40D / 50D / 60D / 450D / 500D\n    // 550D / 1000D / 1100D\n    case 674:\n    case 692:\n    case 702:\n    case 1227:\n    case 1250:\n    case 1251:\n    case 1337:\n    case 1338:\n    case 1346:\n      imgdata.makernotes.canon.CanonColorDataVer = 4;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x53 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n      {\n        fseek(ifp, save1 + (0x2b9 << 1), SEEK_SET); // offset 697 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n               (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n      {\n        fseek(ifp, save1 + (0x2d0 << 1), SEEK_SET); // offset 720 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n      {\n        fseek(ifp, save1 + (0x2d4 << 1), SEEK_SET); // offset 724 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    case 5120:\n      imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5\n      {\n        fseek(ifp, save1 + (0x56 << 1), SEEK_SET);\n        if ((unique_id == 0x03970000) || // G7 X Mark II\n            (unique_id == 0x04100000) || // G9 X Mark II\n            (unique_id == 0x80000394))   // EOS M5\n        {\n          fseek(ifp, 18, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          Canon_WBpresets(8, 24);\n          fseek(ifp, 168, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n          fseek(ifp, 24, SEEK_CUR);\n          Canon_WBCTpresets(2); // BCADT\n          fseek(ifp, 6, SEEK_CUR);\n        }\n        else\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          get2();\n          Canon_WBpresets(2, 12);\n          fseek(ifp, save1 + (0xba << 1), SEEK_SET);\n          Canon_WBCTpresets(2);                       // BCADT\n          fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short\n        }\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n\n    case 1273:\n    case 1275:\n      imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x67 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xbc << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      fseek(ifp, save1 + (0x1e4 << 1), SEEK_SET); // offset 484 shorts\n      imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      break;\n\n    // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n    case 1312:\n    case 1313:\n    case 1316:\n    case 1506:\n      imgdata.makernotes.canon.CanonColorDataVer = 7;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n      {\n        fseek(ifp, save1 + (0x1fd << 1), SEEK_SET); // offset 509 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n      {\n        fseek(ifp, save1 + (0x2dd << 1), SEEK_SET); // offset 733 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    // 5DS / 5DS R / 80D / 1300D / 5D4\n    case 1560:\n    case 1592:\n    case 1353:\n      imgdata.makernotes.canon.CanonColorDataVer = 8;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x107 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D\n      {\n        fseek(ifp, save1 + (0x231 << 1), SEEK_SET);\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else\n      {\n        fseek(ifp, save1 + (0x30f << 1), SEEK_SET); // offset 783 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n    }\n    fseek(ifp, save1, SEEK_SET);\n  }\n}\n\nvoid CLASS setPentaxBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id)\n  {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n  case 0x1322c:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO(ushort c)\n{\n  int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,   12,   13,  14,  15,  16,  17,  18,  19,\n                20,  21,  22,  23,  24,  25,  26,  27,  28,   29,   30,  31,  32,  33,  34,  35,  36,\n                37,  38,  39,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264,\n                265, 266, 267, 268, 269, 270, 271, 272, 273,  274,  275, 276, 277, 278};\n  double value[] = {50,    64,    80,    100,   125,   160,   200,   250,    320,    400,    500,    640,   800,\n                    1000,  1250,  1600,  2000,  2500,  3200,  4000,  5000,   6400,   8000,   10000,  12800, 16000,\n                    20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50,    100,\n                    200,   400,   800,   1600,  3200,  50,    70,    100,    140,    200,    280,    400,   560,\n                    800,   1100,  1600,  2200,  3200,  4500,  6400,  9000,   12800,  18000,  25600,  36000, 51200};\n#define numel (sizeof(code) / sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++)\n  {\n    if (code[i] == c)\n    {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel)\n    iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207\n{\n  ushort iLensData = 0;\n  uchar *table_buf;\n  table_buf = (uchar *)malloc(MAX(len, 128));\n  fread(table_buf, len, 1, ifp);\n  if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D\n                          (id == 0x12b9d) ||  // K110D\n                          (id == 0x12ba2)) && // K100D Super\n                         ((!table_buf[20] || (table_buf[20] == 0xff)))))\n  {\n    iLensData = 3;\n    if (imgdata.lens.makernotes.LensID == -1)\n      imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];\n  }\n  else\n    switch (len)\n    {\n    case 90: // LensInfo3\n      iLensData = 13;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 91: // LensInfo4\n      iLensData = 12;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 80: // LensInfo5\n    case 128:\n      iLensData = 15;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];\n      break;\n    default:\n      if (id >= 0x12b9c) // LensInfo2\n      {\n        iLensData = 4;\n        if (imgdata.lens.makernotes.LensID == -1)\n          imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];\n      }\n    }\n  if (iLensData)\n  {\n    if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n      imgdata.lens.makernotes.CurFocal =\n          10 * (table_buf[iLensData + 9] >> 2) * powf64(4, (table_buf[iLensData + 9] & 0x03) - 2);\n    if (table_buf[iLensData + 10] & 0xf0)\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);\n    if (table_buf[iLensData + 10] & 0x0f)\n      imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);\n\n    if (iLensData != 12)\n    {\n      switch (table_buf[iLensData] & 0x06)\n      {\n      case 0:\n        imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;\n        break;\n      case 2:\n        imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;\n        break;\n      case 4:\n        imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;\n        break;\n      case 6:\n        imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;\n        break;\n      }\n      if (table_buf[iLensData] & 0x70)\n        imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n      imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);\n      imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);\n\n      if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);\n    }\n    else if ((id != 0x12e76) && // K-5\n             (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n    {\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);\n    }\n  }\n  free(table_buf);\n  return;\n}\n\nvoid CLASS setPhaseOneFeatures(unsigned id)\n{\n\n  ushort i;\n  static const struct\n  {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n      // Phase One section:\n      {1, \"Hasselblad V\"},\n      {10, \"PhaseOne/Mamiya\"},\n      {12, \"Contax 645\"},\n      {16, \"Hasselblad V\"},\n      {17, \"Hasselblad V\"},\n      {18, \"Contax 645\"},\n      {19, \"PhaseOne/Mamiya\"},\n      {20, \"Hasselblad V\"},\n      {21, \"Contax 645\"},\n      {22, \"PhaseOne/Mamiya\"},\n      {23, \"Hasselblad V\"},\n      {24, \"Hasselblad H\"},\n      {25, \"PhaseOne/Mamiya\"},\n      {32, \"Contax 645\"},\n      {34, \"Hasselblad V\"},\n      {35, \"Hasselblad V\"},\n      {36, \"Hasselblad H\"},\n      {37, \"Contax 645\"},\n      {38, \"PhaseOne/Mamiya\"},\n      {39, \"Hasselblad V\"},\n      {40, \"Hasselblad H\"},\n      {41, \"Contax 645\"},\n      {42, \"PhaseOne/Mamiya\"},\n      {44, \"Hasselblad V\"},\n      {45, \"Hasselblad H\"},\n      {46, \"Contax 645\"},\n      {47, \"PhaseOne/Mamiya\"},\n      {48, \"Hasselblad V\"},\n      {49, \"Hasselblad H\"},\n      {50, \"Contax 645\"},\n      {51, \"PhaseOne/Mamiya\"},\n      {52, \"Hasselblad V\"},\n      {53, \"Hasselblad H\"},\n      {54, \"Contax 645\"},\n      {55, \"PhaseOne/Mamiya\"},\n      {67, \"Hasselblad V\"},\n      {68, \"Hasselblad H\"},\n      {69, \"Contax 645\"},\n      {70, \"PhaseOne/Mamiya\"},\n      {71, \"Hasselblad V\"},\n      {72, \"Hasselblad H\"},\n      {73, \"Contax 645\"},\n      {74, \"PhaseOne/Mamiya\"},\n      {76, \"Hasselblad V\"},\n      {77, \"Hasselblad H\"},\n      {78, \"Contax 645\"},\n      {79, \"PhaseOne/Mamiya\"},\n      {80, \"Hasselblad V\"},\n      {81, \"Hasselblad H\"},\n      {82, \"Contax 645\"},\n      {83, \"PhaseOne/Mamiya\"},\n      {84, \"Hasselblad V\"},\n      {85, \"Hasselblad H\"},\n      {86, \"Contax 645\"},\n      {87, \"PhaseOne/Mamiya\"},\n      {99, \"Hasselblad V\"},\n      {100, \"Hasselblad H\"},\n      {101, \"Contax 645\"},\n      {102, \"PhaseOne/Mamiya\"},\n      {103, \"Hasselblad V\"},\n      {104, \"Hasselblad H\"},\n      {105, \"PhaseOne/Mamiya\"},\n      {106, \"Contax 645\"},\n      {112, \"Hasselblad V\"},\n      {113, \"Hasselblad H\"},\n      {114, \"Contax 645\"},\n      {115, \"PhaseOne/Mamiya\"},\n      {131, \"Hasselblad V\"},\n      {132, \"Hasselblad H\"},\n      {133, \"Contax 645\"},\n      {134, \"PhaseOne/Mamiya\"},\n      {135, \"Hasselblad V\"},\n      {136, \"Hasselblad H\"},\n      {137, \"Contax 645\"},\n      {138, \"PhaseOne/Mamiya\"},\n      {140, \"Hasselblad V\"},\n      {141, \"Hasselblad H\"},\n      {142, \"Contax 645\"},\n      {143, \"PhaseOne/Mamiya\"},\n      {148, \"Hasselblad V\"},\n      {149, \"Hasselblad H\"},\n      {150, \"Contax 645\"},\n      {151, \"PhaseOne/Mamiya\"},\n      {160, \"A-250\"},\n      {161, \"A-260\"},\n      {162, \"A-280\"},\n      {167, \"Hasselblad V\"},\n      {168, \"Hasselblad H\"},\n      {169, \"Contax 645\"},\n      {170, \"PhaseOne/Mamiya\"},\n      {172, \"Hasselblad V\"},\n      {173, \"Hasselblad H\"},\n      {174, \"Contax 645\"},\n      {175, \"PhaseOne/Mamiya\"},\n      {176, \"Hasselblad V\"},\n      {177, \"Hasselblad H\"},\n      {178, \"Contax 645\"},\n      {179, \"PhaseOne/Mamiya\"},\n      {180, \"Hasselblad V\"},\n      {181, \"Hasselblad H\"},\n      {182, \"Contax 645\"},\n      {183, \"PhaseOne/Mamiya\"},\n      {208, \"Hasselblad V\"},\n      {211, \"PhaseOne/Mamiya\"},\n      {448, \"Phase One 645AF\"},\n      {457, \"Phase One 645DF\"},\n      {471, \"Phase One 645DF+\"},\n      {704, \"Phase One iXA\"},\n      {705, \"Phase One iXA - R\"},\n      {706, \"Phase One iXU 150\"},\n      {707, \"Phase One iXU 150 - NIR\"},\n      {708, \"Phase One iXU 180\"},\n      {721, \"Phase One iXR\"},\n      // Leaf section:\n      {333, \"Mamiya\"},\n      {329, \"Universal\"},\n      {330, \"Hasselblad H1/H2\"},\n      {332, \"Contax\"},\n      {336, \"AFi\"},\n      {327, \"Mamiya\"},\n      {324, \"Universal\"},\n      {325, \"Hasselblad H1/H2\"},\n      {326, \"Contax\"},\n      {335, \"AFi\"},\n      {340, \"Mamiya\"},\n      {337, \"Universal\"},\n      {338, \"Hasselblad H1/H2\"},\n      {339, \"Contax\"},\n      {323, \"Mamiya\"},\n      {320, \"Universal\"},\n      {322, \"Hasselblad H1/H2\"},\n      {321, \"Contax\"},\n      {334, \"AFi\"},\n      {369, \"Universal\"},\n      {370, \"Mamiya\"},\n      {371, \"Hasselblad H1/H2\"},\n      {372, \"Contax\"},\n      {373, \"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0])\n  {\n    for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id)\n      {\n        strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes(unsigned tag, unsigned type)\n{\n  switch (tag)\n  {\n  case 0x1002:\n    imgdata.makernotes.fuji.WB_Preset = get2();\n    break;\n  case 0x1011:\n    imgdata.other.FlashEC = getreal(type);\n    break;\n  case 0x1020:\n    imgdata.makernotes.fuji.Macro = get2();\n    break;\n  case 0x1021:\n    imgdata.makernotes.fuji.FocusMode = get2();\n    break;\n  case 0x1022:\n    imgdata.makernotes.fuji.AFMode = get2();\n    break;\n  case 0x1023:\n    imgdata.makernotes.fuji.FocusPixel[0] = get2();\n    imgdata.makernotes.fuji.FocusPixel[1] = get2();\n    break;\n  case 0x1034:\n    imgdata.makernotes.fuji.ExrMode = get2();\n    break;\n  case 0x1050:\n    imgdata.makernotes.fuji.ShutterType = get2();\n    break;\n  case 0x1400:\n    imgdata.makernotes.fuji.FujiDynamicRange = get2();\n    break;\n  case 0x1401:\n    imgdata.makernotes.fuji.FujiFilmMode = get2();\n    break;\n  case 0x1402:\n    imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();\n    break;\n  case 0x1403:\n    imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();\n    break;\n  case 0x140b:\n    imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();\n    break;\n  case 0x1404:\n    imgdata.lens.makernotes.MinFocal = getreal(type);\n    break;\n  case 0x1405:\n    imgdata.lens.makernotes.MaxFocal = getreal(type);\n    break;\n  case 0x1406:\n    imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n    break;\n  case 0x1407:\n    imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n    break;\n  case 0x1422:\n    imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n    imgdata.shootinginfo.ImageStabilization =\n        (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];\n    break;\n  case 0x1431:\n    imgdata.makernotes.fuji.Rating = get4();\n    break;\n  case 0x3820:\n    imgdata.makernotes.fuji.FrameRate = get2();\n    break;\n  case 0x3821:\n    imgdata.makernotes.fuji.FrameWidth = get2();\n    break;\n  case 0x3822:\n    imgdata.makernotes.fuji.FrameHeight = get2();\n    break;\n  }\n  return;\n}\n\nvoid CLASS setSonyBodyFeatures(unsigned id)\n{\n\n  imgdata.lens.makernotes.CamID = id;\n  if (               // FF cameras\n      (id == 257) || // a900\n      (id == 269) || // a850\n      (id == 340) || // ILCE-7M2\n      (id == 318) || // ILCE-7S\n      (id == 350) || // ILCE-7SM2\n      (id == 311) || // ILCE-7R\n      (id == 347) || // ILCE-7RM2\n      (id == 306) || // ILCE-7\n      (id == 298) || // DSC-RX1\n      (id == 299) || // NEX-VG900\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 354) || // ILCA-99M2\n      (id == 294)    // SLT-99, Hasselblad HV\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n  }\n  else if ((id == 297) || // DSC-RX100\n           (id == 308) || // DSC-RX100M2\n           (id == 309) || // DSC-RX10\n           (id == 317) || // DSC-RX100M3\n           (id == 341) || // DSC-RX100M4\n           (id == 342) || // DSC-RX10M2\n           (id == 355) || // DSC-RX10M3\n           (id == 356)    // DSC-RX100M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  else if (id != 002) // DSC-R1\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n  }\n\n  if ( // E-mount cameras, ILCE series\n      (id == 302) || (id == 306) || (id == 311) || (id == 312) || (id == 313) || (id == 318) || (id == 339) ||\n      (id == 340) || (id == 346) || (id == 347) || (id == 350) || (id == 360))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n  }\n  else if ( // E-mount cameras, NEX series\n      (id == 278) || (id == 279) || (id == 284) || (id == 288) || (id == 289) || (id == 290) || (id == 293) ||\n      (id == 295) || (id == 296) || (id == 299) || (id == 300) || (id == 305) || (id == 307))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n  }\n\n  else if ( // A-mount cameras, DSLR series\n      (id == 256) || (id == 257) || (id == 258) || (id == 259) || (id == 260) || (id == 261) || (id == 262) ||\n      (id == 263) || (id == 264) || (id == 265) || (id == 266) || (id == 269) || (id == 270) || (id == 273) ||\n      (id == 274) || (id == 275) || (id == 282) || (id == 283))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n  }\n  else if ( // A-mount cameras, SLT series\n      (id == 280) || (id == 281) || (id == 285) || (id == 286) || (id == 287) || (id == 291) || (id == 292) ||\n      (id == 294) || (id == 303))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n  }\n  else if ( // A-mount cameras, ILCA series\n      (id == 319) || (id == 353) || (id == 354))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n  }\n\n  else if (          // DSC\n      (id == 002) || // DSC-R1\n      (id == 297) || // DSC-RX100\n      (id == 298) || // DSC-RX1\n      (id == 308) || // DSC-RX100M2\n      (id == 309) || // DSC-RX10\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 317) || // DSC-RX100M3\n      (id == 341) || // DSC-RX100M4\n      (id == 342) || // DSC-RX10M2\n      (id == 355) || // DSC-RX10M3\n      (id == 356)    // DSC-RX100M5\n      )\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n  }\n  return;\n}\n\nvoid CLASS parseSonyLensType2(uchar a, uchar b)\n{\n  ushort lid2;\n  lid2 = (((ushort)a) << 8) | ((ushort)b);\n  if (!lid2)\n    return;\n  if (lid2 < 0x100)\n  {\n    if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2)\n      {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n      }\n    }\n  }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    imgdata.lens.makernotes.AdapterID = 0x4900;\n  }\n  return;\n}\n\n#define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures(uchar a, uchar b)\n{\n\n  ushort features;\n  features = (((ushort)a) << 8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100))\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n  {\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n    if ((features & 0x0200) && (features & 0x0100))\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0200)\n    {\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0100)\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n    }\n  }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,\n            strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c(uchar *buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0009]]);\n  return;\n}\n\nvoid CLASS process_Sony_0x9050(uchar *buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n  {\n    if (buf[0])\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n\n    if (buf[1])\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n  }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (buf[0x3d] | buf[0x3c])\n    {\n      lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];\n      imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);\n    }\n    if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n        (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n      imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];\n    if (buf[0x106])\n      imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];\n  }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n  {\n    parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0107]]);\n  }\n  if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n  {\n    imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];\n\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n  }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long b88 = SonySubstitution[buf[0x88]];\n    unsigned long b89 = SonySubstitution[buf[0x89]];\n    unsigned long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if (len > 8 && pos + len > 2 * fsize)\n      continue;\n    tag |= uptag << 16;\n    if (len > 100 * 1024 * 1024)\n      goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes(tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x1d) // serial number\n        while ((c = fgetc(ifp)) && c != EOF)\n        {\n          if ((!custom_serial) && (!isdigit(c)))\n          {\n            if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n            {\n              custom_serial = 34;\n            }\n            else\n            {\n              custom_serial = 96;\n            }\n          }\n          serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n        }\n      else if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0097)\n      {\n        for (i = 0; i < 4; i++)\n          ver97 = ver97 * 10 + fgetc(ifp) - '0';\n        if (ver97 == 601) // Coolpix A\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n\n      else if (tag == 0xa7) // shutter count\n      {\n        NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n        if ((NikonLensDataVersion > 200) && lenNikonLensData)\n        {\n          if (custom_serial)\n          {\n            ci = xlat[0][custom_serial];\n          }\n          else\n          {\n            ci = xlat[0][serial & 0xff];\n          }\n          cj = xlat[1][NikonKey];\n          ck = 0x60;\n          for (i = 0; i < lenNikonLensData; i++)\n            table_buf[i] ^= (cj += ci * ck++);\n          processNikonLensData(table_buf, lenNikonLensData);\n          lenNikonLensData = 0;\n          free(table_buf);\n        }\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n\n      else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc, 1, 1, ifp);\n        iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n        break;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&\n                              strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);\n\n      if ((tag == 0x2010) || (tag == 0x2020))\n      {\n        fseek(ifp, save - 4, SEEK_SET);\n        fseek(ifp, base + get4(), SEEK_SET);\n        parse_makernote_0xc634(base, tag, dng_writer);\n      }\n      if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||\n                                 (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n      switch (tag)\n      {\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20100102:\n        stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x20100201:\n        imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |\n                                         (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |\n                                         (unsigned long long)fgetc(ifp);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        if ((!imgdata.lens.LensSerial[0]))\n          stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      case 0x20200401:\n        imgdata.other.FlashEC = getreal(type);\n        break;\n      }\n    skip_Oly_broken_tags:;\n    }\n\n    else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 12, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        imgdata.lens.makernotes.CamID = unique_id = get4();\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n\n                // a450, a500, a550, a560, a580\n                // a33, a35, a55\n                // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n            {\n              if (table_buf[0] | table_buf[3])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n              if (table_buf[2] | table_buf[5])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n              parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            }\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n            {\n              if (table_buf[1] | table_buf[2])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n              if (table_buf[3] | table_buf[4])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n              if (table_buf[5])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n              if (table_buf[6])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n              parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            }\n          }\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 65535) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n        {\n          if (table_buf[1] | table_buf[2])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n          if (table_buf[3] | table_buf[4])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n          if (table_buf[5])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n          if (table_buf[6])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n          parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        }\n        free(table_buf);\n      }\n    }\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */}\n#endif\n\nvoid CLASS parse_makernote(int base, int uptag)\n{\n  unsigned offset = 0, entries, tag, type, len, save, c;\n  unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder = order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n  /*\n     The MakerNote might have its own TIFF header (possibly with\n     its own byte-order!), or it might just be a table.\n   */\n  if (!strncmp(make, \"Nokia\", 5))\n    return;\n  fread(buf, 1, 10, ifp);\n  if (!strncmp(buf, \"KDK\", 3) || /* these aren't TIFF tables */\n      !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))\n    return;\n  if (!strncmp(buf, \"KC\", 2) || /* Konica KD-400Z, KD-510Z */\n      !strncmp(buf, \"MLY\", 3))\n  { /* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i = ftell(ifp)) < data_offset && i < 16384)\n    {\n      wb[0] = wb[2];\n      wb[2] = wb[1];\n      wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n        FORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if (!strncmp(make, \"SAMSUNG\", 7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n  {\n    if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))\n    {\n      base = ftell(ifp) - 8;\n    }\n    else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n    {\n      base = 0;\n    }\n    else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||\n             !strncasecmp(model, \"Leica M Monochrom\", 11))\n    {\n      if (!uptag)\n      {\n        base = ftell(ifp) - 10;\n        fseek(ifp, 8, SEEK_CUR);\n      }\n      else if (uptag == 0x3400)\n      {\n        fseek(ifp, 10, SEEK_CUR);\n        base += 10;\n      }\n    }\n    else if (!strncasecmp(model, \"LEICA T\", 7))\n    {\n      base = ftell(ifp) - 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (!strncasecmp(model, \"LEICA SL\", 8))\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n#endif\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if (len > 8 && _pos + len > 2 * fsize)\n      continue;\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n    {\n      if (tag == 0x0010)\n      {\n        char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n        char *words[4];\n        char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n        int year, nwords, ynum_len;\n        unsigned c;\n        stmread(FujiSerial, len, ifp);\n        nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n        for (int i = 0; i < nwords; i++)\n        {\n          mm[2] = dd[2] = 0;\n          if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)\n            if (i == 0)\n              strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          else\n          {\n            strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);\n            strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);\n            strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);\n            year = (yy[0] - '0') * 10 + (yy[1] - '0');\n            if (year < 70)\n              year += 2000;\n            else\n              year += 1900;\n\n            ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;\n            strncpy(ynum, words[i], ynum_len);\n            ynum[ynum_len] = 0;\n            for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)\n              ystr[j / 2] = c;\n            ystr[ynum_len / 2 + 1] = 0;\n            strcpy(model2, ystr);\n\n            if (i == 0)\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n              if (nwords == 1)\n                snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,\n                         year, mm, dd);\n\n              else\n                snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,\n                       dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          }\n        }\n      }\n      else\n        parseFujiMakernotes(tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0012)\n      {\n        char a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n          imgdata.other.FlashEC = (float)(a * b) / (float)c;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData > 0)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n      else if (tag == 0x00a0)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      switch (tag)\n      {\n      case 0x0404:\n      case 0x101a:\n      case 0x20100101:\n        if (!imgdata.shootinginfo.BodySerial[0])\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n      case 0x20100102:\n        if (!imgdata.shootinginfo.InternalBodySerial[0])\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20401112:\n        imgdata.makernotes.olympus.OlympusCropID = get2();\n        break;\n      case 0x20401113:\n        FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n        break;\n      case 0x20100201:\n      {\n        unsigned long long oly_lensid[3];\n        oly_lensid[0] = fgetc(ifp);\n        fgetc(ifp);\n        oly_lensid[1] = fgetc(ifp);\n        oly_lensid[2] = fgetc(ifp);\n        imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n      }\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        char buffer[17];\n        int count = 0;\n        fread(buffer, 16, 1, ifp);\n        buffer[16] = 0;\n        for (int i = 0; i < 16; i++)\n        {\n          //    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n          if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))\n            count++;\n        }\n        if (count == 16)\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);\n          buffer[8] = 0;\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n        }\n        else\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],\n                  buffer[11]);\n        }\n      }\n      else if ((tag == 0x1001) && (type == 3))\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n        imgdata.lens.makernotes.LensID = -1;\n        imgdata.lens.makernotes.FocalType = 1;\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n    }\n\n    else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))\n    {\n      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n      {\n        char buffer[9];\n        buffer[8] = 0;\n        fread(buffer, 8, 1, ifp);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n\n      else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n      {\n        short ntags, cur_tag;\n        fseek(ifp, 20, SEEK_CUR);\n        ntags = get2();\n        cur_tag = get2();\n        while (cur_tag != 0x002c)\n        {\n          fseek(ifp, 10, SEEK_CUR);\n          cur_tag = get2();\n        }\n        fseek(ifp, 6, SEEK_CUR);\n        fseek(ifp, get4() + 20, SEEK_SET);\n        stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n        get2();\n        imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n        switch (imgdata.lens.makernotes.LensID)\n        {\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n        case 6:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n          break;\n        case 8:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n          imgdata.lens.makernotes.LensID = -1;\n          break;\n        default:\n          imgdata.lens.makernotes.LensID = -1;\n        }\n        fseek(ifp, 17, SEEK_CUR);\n        stread(imgdata.lens.LensSerial, 12, ifp);\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 2, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        unique_id = imgdata.lens.makernotes.CamID = get4();\n      }\n      else if (tag == 0xa002)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n                                 // a450, a500, a550, a560, a580\n                                 // a33, a35, a55\n                                 // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (table_buf[0] | table_buf[3])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n            if (table_buf[2] | table_buf[5])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n            parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n          }\n        }\n        free(table_buf);\n      }\n\n      else if ((tag == 0x0020) && // WBInfoA100, needs 0xb028 processing\n               !strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 0x49dc, SEEK_CUR);\n        stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 256000) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (table_buf[1] | table_buf[2])\n          imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n        if (table_buf[3] | table_buf[4])\n          imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n        if (table_buf[5])\n          imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n        if (table_buf[6])\n          imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n        parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        free(table_buf);\n      }\n    }\n\n    fseek(ifp, _pos, SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)\n      iso_speed = (get2(), get2());\n    if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))\n    {\n      unsigned char cc;\n      fread(&cc, 1, 1, ifp);\n      iso_speed = int(100.0 * powf64(2.0f, float(cc) / 12.0 - 5.0));\n    }\n    if (tag == 4 && len > 26 && len < 35)\n    {\n      if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n        iso_speed = 50 * powf64(2.0, i / 32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i = (get2(), get2())) != 0x7fff && !aperture)\n        aperture = powf64(2.0, i / 64.0);\n#endif\n      if ((i = get2()) != 0xffff && !shutter)\n        shutter = powf64(2.0, (short)i / -32.0);\n      wbi = (get2(), get2());\n      shot_order = (get2(), get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))\n    {\n      fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);\n      switch (get2())\n      {\n      case 72:\n        flip = 0;\n        break;\n      case 76:\n        flip = 6;\n        break;\n      case 82:\n        flip = 5;\n        break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets(model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make, \"Canon\", 5))\n      fread(artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa)\n    {\n#if 0 /* Canon rotation data is handled by EXIF.Orientation */\n      for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)\n        c = c << 8 | fgetc(ifp);\n      while ((i += 4) < len - 5)\n        if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)\n          flip = \"065\"[c] - '0';\n#endif\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n    if (!strncasecmp(make, \"Olympus\", 7))\n    {\n      short nWB, tWB;\n      if ((tag == 0x20300108) || (tag == 0x20310109))\n        imgdata.makernotes.olympus.ColorSpace = get2();\n\n      if ((tag == 0x20400102) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n      {\n        int i;\n        for (i = 0; i < 64; i++)\n          imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n              imgdata.color.WB_Coeffs[i][3] = 0x100;\n        for (i = 64; i < 256; i++)\n          imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n      }\n      if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n      {\n        ushort CT;\n        nWB = tag - 0x20400102;\n        switch (nWB)\n        {\n        case 0:\n          CT = 3000;\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 1:\n          CT = 3300;\n          tWB = 0x100;\n          break;\n        case 2:\n          CT = 3600;\n          tWB = 0x100;\n          break;\n        case 3:\n          CT = 3900;\n          tWB = 0x100;\n          break;\n        case 4:\n          CT = 4000;\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 5:\n          CT = 4300;\n          tWB = 0x100;\n          break;\n        case 6:\n          CT = 4500;\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 7:\n          CT = 4800;\n          tWB = 0x100;\n          break;\n        case 8:\n          CT = 5300;\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          CT = 6000;\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          CT = 6600;\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          CT = 7500;\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          CT = 0;\n          tWB = 0x100;\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n          imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n          if (len == 4)\n          {\n            imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n            imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n          }\n        }\n        if (tWB != 0x100)\n          FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c + 1];\n      }\n      if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400113;\n        imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n        switch (nWB)\n        {\n        case 0:\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 4:\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 6:\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 8:\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          tWB = 0x100;\n        }\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = imgdata.color.WBCT_Coeffs[nWB][2];\n      }\n\n      if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      if (tag == 0x2040011f)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n      }\n      if (tag == 0x30000120)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      if (tag == 0x30000121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      }\n      if (tag == 0x30000122)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n      }\n      if (tag == 0x30000123)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      }\n      if (tag == 0x30000124)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n      }\n      if (tag == 0x30000130)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      }\n      if (tag == 0x30000131)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      }\n      if (tag == 0x30000132)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      }\n      if (tag == 0x30000133)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      }\n\n      if ((tag == 0x20400805) && (len == 2))\n      {\n        imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);\n        imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n      }\n      if (tag == 0x20200401)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n    }\n    fseek(ifp, _pos2, SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n    }\n    if (tag == 0x14 && type == 7)\n    {\n      if (len == 2560)\n      {\n        fseek(ifp, 1248, SEEK_CUR);\n        goto get2_256;\n      }\n      fread(buf, 1, 10, ifp);\n      if (!strncmp(buf, \"NRW \", 4))\n      {\n        fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);\n        cam_mul[0] = get4() << 2;\n        cam_mul[1] = get4() + get4();\n        cam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread(model, 64, 1, ifp);\n    if (strstr(make, \"PENTAX\"))\n    {\n      if (tag == 0x1b)\n        tag = 0x1018;\n      if (tag == 0x1c)\n        tag = 0x1017;\n    }\n    if (tag == 0x1d)\n    {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n        serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1)\n    { // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;\n      fseek(ifp, 8 + c * 32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4)\n    {\n      data_offset = get4();\n      fseek(ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97)\n    {\n      for (i = 0; i < 4; i++)\n        ver97 = ver97 * 10 + fgetc(ifp) - '0';\n      switch (ver97)\n      {\n      case 100:\n        fseek(ifp, 68, SEEK_CUR);\n        FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n        break;\n      case 102:\n        fseek(ifp, 6, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = get2();\n        break;\n      case 103:\n        fseek(ifp, 16, SEEK_CUR);\n        FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200)\n      {\n        if (ver97 != 205)\n          fseek(ifp, 280, SEEK_CUR);\n        fread(buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7)\n    {\n      order = 0x4949;\n      fseek(ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3)\n    {\n      fseek(ifp, wbi * 48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7)\n    { // shutter count\n      NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n      if ((unsigned)(ver97 - 200) < 17)\n      {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601) // Coolpix A\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n#endif\n    }\n\n    if (tag == 0xb001 && type == 3) // Sony ModelID\n    {\n      unique_id = get2();\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(), get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)\n    {\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black += i;\n    }\n#endif\n    if (tag == 0xe01)\n    { /* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n      int loopc = 0;\n#endif\n      order = 0x4949;\n      fseek(ifp, 22, SEEK_CUR);\n      for (offset = 22; offset + 22 < len; offset += 22 + i)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (loopc++ > 1024)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        tag = get4();\n        fseek(ifp, 14, SEEK_CUR);\n        i = get4() - 4;\n        if (tag == 0x76a43207)\n          flip = get2();\n        else\n          fseek(ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7)\n    {\n      fseek(ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7)\n    {\n      if (len == 614)\n        fseek(ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n        fseek(ifp, 148, SEEK_CUR);\n      else\n        goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i = 0; i < 3; i++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!imgdata.makernotes.olympus.ColorSpace)\n        {\n          FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n        }\n        else\n        {\n          FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;\n        }\n#else\n        FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n#endif\n      }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2)\n    {\n    get2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek(ifp, get4() + base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    if (tag == 0x2010)\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, 0x2010);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n\n    if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) && ((type == 7) || (type == 13)) &&\n        !strncasecmp(make, \"Olympus\", 7))\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, tag);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))\n      parse_thumb_note(base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote(base, 0x2040);\n    if (tag == 0xb028)\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_thumb_note(base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000)\n    {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek(ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i += 18; i <= len; i += 10)\n      {\n        get2();\n        FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n        if (sraw_mul[1] == 1170)\n          break;\n      }\n    }\n    if (!strncasecmp(make, \"Samsung\", 7))\n    {\n      if (tag == 0xa020) // get the full Samsung encryption key\n        for (i = 0; i < 11; i++)\n          SamsungKey[i] = get4();\n      if (tag == 0xa021) // get and decode Samsung cam_mul array\n        FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tag == 0xa023)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n        }\n      }\n      if (tag == 0xa024)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n        }\n      }\n      if (tag == 0xa025)\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = get4() - SamsungKey[0];\n      if (tag == 0xa030 && len == 9)\n        for (i = 0; i < 3; i++)\n          FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n#endif\n      if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix\n        for (i = 0; i < 3; i++)\n          FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n\n      if (tag == 0xa028)\n        FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n    }\n    else\n    {\n      // Somebody else use 0xa021 and 0xa028?\n      if (tag == 0xa021)\n        FORC4 cam_mul[c ^ (c >> 1)] = get4();\n      if (tag == 0xa028)\n        FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n    }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp(int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i = 19; i--;)\n      str[i] = fgetc(ifp);\n  else\n    fread(str, 19, 1, ifp);\n  memset(&t, 0, sizeof t);\n  if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif(int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo, ape;\n\n  kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n  entries = get2();\n  if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > fsize * 2)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n    switch (tag)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n    case 33434:\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n      break;\n    case 33437:\n      aperture = getreal(type);\n      break; // 0x829d FNumber\n    case 34855:\n      iso_speed = get2();\n      break;\n    case 34866:\n      if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n        iso_speed = getreal(type);\n      break;\n    case 36867:\n    case 36868:\n      get_timestamp(0);\n      break;\n    case 37377:\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter = powf64(2.0, expo);\n      break;\n    case 37378: // 0x9202 ApertureValue\n      if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n        aperture = powf64(2.0, ape / 2);\n      break;\n    case 37385:\n      flash_used = getreal(type);\n      break;\n    case 37386:\n      focal_len = getreal(type);\n      break;\n    case 37500: // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))\n      {\n        char mn_text[512];\n        char *pos;\n        char ccms[512];\n        ushort l;\n        float num;\n\n        fgets(mn_text, len, ifp);\n        pos = strstr(mn_text, \"gain_r=\");\n        if (pos)\n          cam_mul[0] = atof(pos + 7);\n        pos = strstr(mn_text, \"gain_b=\");\n        if (pos)\n          cam_mul[2] = atof(pos + 7);\n        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n          cam_mul[1] = cam_mul[3] = 1.0f;\n        else\n          cam_mul[0] = cam_mul[2] = 0.0f;\n\n        pos = strstr(mn_text, \"ccm=\") + 4;\n        l = strstr(pos, \" \") - pos;\n        memcpy(ccms, pos, l);\n        ccms[l] = '\\0';\n\n        pos = strtok(ccms, \",\");\n        for (l = 0; l < 4; l++)\n        {\n          num = 0.0;\n          for (c = 0; c < 3; c++)\n          {\n            imgdata.color.ccm[l][c] = (float)atoi(pos);\n            num += imgdata.color.ccm[l][c];\n            pos = strtok(NULL, \",\");\n          }\n          if (num > 0.01)\n            FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n        }\n      }\n      else\n#endif\n        parse_makernote(base, 0);\n      break;\n    case 40962:\n      if (kodak)\n        raw_width = get4();\n      break;\n    case 40963:\n      if (kodak)\n        raw_height = get4();\n      break;\n    case 41730:\n      if (get4() == 0x20002)\n        for (exif_cfa = c = 0; c < 8; c += 2)\n          exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n    return;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n      imgdata.other.parsed_gps.latref = getc(ifp);\n      break;\n    case 3:\n      imgdata.other.parsed_gps.longref = getc(ifp);\n      break;\n    case 5:\n      imgdata.other.parsed_gps.altref = getc(ifp);\n      break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9:\n      imgdata.other.parsed_gps.gpsstatus = getc(ifp);\n      break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n    case 3:\n    case 5:\n      gpsdata[29 + tag / 2] = getc(ifp);\n      break;\n    case 2:\n    case 4:\n    case 7:\n      FORC(6) gpsdata[tag / 3 * 6 + c] = get4();\n      break;\n    case 6:\n      FORC(2) gpsdata[18 + c] = get4();\n      break;\n    case 18:\n    case 29:\n      fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff(float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] = /* ROMM == Kodak ProPhoto */\n      {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      for (cmatrix[i][j] = k = 0; k < 3; k++)\n        cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos(int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes = 0, frot = 0;\n  static const char *mod[] = {\"\",\n                              \"DCB2\",\n                              \"Volare\",\n                              \"Cantare\",\n                              \"CMost\",\n                              \"Valeo 6\",\n                              \"Valeo 11\",\n                              \"Valeo 22\",\n                              \"Valeo 11p\",\n                              \"Valeo 17\",\n                              \"\",\n                              \"Aptus 17\",\n                              \"Aptus 22\",\n                              \"Aptus 75\",\n                              \"Aptus 65\",\n                              \"Aptus 54S\",\n                              \"Aptus 65S\",\n                              \"Aptus 75S\",\n                              \"AFi 5\",\n                              \"AFi 6\",\n                              \"AFi 7\",\n                              \"AFi-II 7\",\n                              \"Aptus-II 7\",\n                              \"\",\n                              \"Aptus-II 6\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10\",\n                              \"Aptus-II 5\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10R\",\n                              \"Aptus-II 8\",\n                              \"\",\n                              \"Aptus-II 12\",\n                              \"\",\n                              \"AFi-II 12\"};\n  float romm_cam[3][3];\n\n  fseek(ifp, offset, SEEK_SET);\n  while (1)\n  {\n    if (get4() != 0x504b5453)\n      break;\n    get4();\n    fread(data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data, \"CameraObj_camera_type\"))\n    {\n      stmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data, \"back_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.BodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));\n      strcpy(imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data, \"CaptProf_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n      strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n    // IB end\n    if (!strcmp(data, \"JPEG_preview_data\"))\n    {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data, \"icc_camera_profile\"))\n    {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data, \"ShootObj_back_type\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      if ((unsigned)i < sizeof mod / sizeof(*mod))\n        strcpy(model, mod[i]);\n    }\n    if (!strcmp(data, \"icc_camera_to_tone_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        ((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_color_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        fscanf(ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_number_of_planes\"))\n      fscanf(ifp, \"%d\", &planes);\n    if (!strcmp(data, \"CaptProf_raw_data_rotation\"))\n      fscanf(ifp, \"%d\", &flip);\n    if (!strcmp(data, \"CaptProf_mosaic_pattern\"))\n      FORC4\n      {\n        fscanf(ifp, \"%d\", &i);\n        if (i == 1)\n          frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data, \"ImgProf_rotation_angle\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])\n    {\n      FORC4 fscanf(ifp, \"%d\", neut + c);\n      FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];\n    }\n    if (!strcmp(data, \"Rows_data\"))\n      load_flags = get4();\n    parse_mos(from);\n    fseek(ifp, skip + from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];\n}\n\nvoid CLASS linear_table(unsigned len)\n{\n  int i;\n  if (len > 0x10000)\n    len = 0x10000;\n  read_shorts(curve, len);\n  for (i = len; i < 0x10000; i++)\n    curve[i] = curve[i - 1];\n  maximum = curve[len < 0x1000 ? 0xfff : len - 1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags(int wb, unsigned type)\n{\n  float mul[3] = {1, 1, 1}, num, mul2;\n  int c;\n  FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n  mul2 = mul[1] * mul[1];\n  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n  return;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n  //  int a_blck = 0;\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  INT64 fsize = ifp->size();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > 2 * fsize)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n    if (tag == 1011)\n      imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());\n      wbi = -2;\n    }\n\n    if ((tag == 0x03ef) && (!strcmp(model, \"EOS D2000C\")))\n      black = get2();\n    if ((tag == 0x03f0) && (!strcmp(model, \"EOS D2000C\")))\n    {\n      if (black) // already set by tag 0x03ef\n        black = (black + get2()) / 2;\n      else\n        black = get2();\n    }\n    if (tag == 0x0848)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93)\n      imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n          imgdata.color.linear_max[3] = get2();\n    if (tag == 0x09ce)\n      stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n    if (tag == 0xfa00)\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n    if (tag == 0xfa27)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n    }\n    if (tag == 0xfa28)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n    }\n    if (tag == 0xfa29)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n    }\n    if (tag == 0xfa2a)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n    }\n\n    if (tag == 2120 + wbi || (wbi < 0 && tag == 2125)) /* use Auto WB if illuminant index is not set */\n    {\n      FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n      FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n    }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 0x903)\n      iso_speed = getreal(type);\n    // if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2, wbtemp = 6500;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());\n      wbi = -2;\n    }\n    if (tag == 2118)\n      wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3\n      {\n        for (num = i = 0; i < 4; i++)\n          num += getreal(type) * pow(wbtemp / 100.0, i);\n        cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));\n      }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 6020)\n      iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n//@end COMMON\n\nvoid CLASS parse_minolta(int base);\nint CLASS parse_tiff(int base);\n\n//@out COMMON\nint CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif    \n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff(int base)\n{\n  int doff;\n  fseek(ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d)\n    return 0;\n  get2();\n  while ((doff = get4()))\n  {\n    fseek(ifp, doff + base, SEEK_SET);\n    if (parse_tiff_ifd(base))\n      break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp = 0, ties = 0, raw = -1, thm = -1, i;\n  unsigned long long ns, os;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n      {\n        thumb_misc = jh.bits;\n        thumb_width = jh.wide;\n        thumb_height = jh.high;\n      }\n    }\n  }\n  for (i = tiff_nifds; i--;)\n  {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i = 0; i < tiff_nifds; i++)\n  {\n    if (max_samp < tiff_ifd[i].samples)\n      max_samp = tiff_ifd[i].samples;\n    if (max_samp > 3)\n      max_samp = 3;\n    os = raw_width * raw_height;\n    ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;\n    if (tiff_bps)\n    {\n      os *= tiff_bps;\n      ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&\n        (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))\n    {\n      raw_width = tiff_ifd[i].t_width;\n      raw_height = tiff_ifd[i].t_height;\n      tiff_bps = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size = tiff_ifd[i].bytes;\n#endif\n      tiff_flip = tiff_ifd[i].t_flip;\n      tiff_samples = tiff_ifd[i].samples;\n      tile_width = tiff_ifd[i].t_tile_width;\n      tile_length = tiff_ifd[i].t_tile_length;\n      shutter = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties)\n    is_raw = ties;\n  if (!tile_width)\n    tile_width = INT_MAX;\n  if (!tile_length)\n    tile_length = INT_MAX;\n  for (i = tiff_nifds; i--;)\n    if (tiff_ifd[i].t_flip)\n      tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress)\n    {\n    case 32767:\n      if (tiff_ifd[raw].bytes == raw_width * raw_height)\n      {\n        tiff_bps = 12;\n        load_raw = &CLASS sony_arw2_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)\n      {\n        raw_height += 8;\n        load_raw = &CLASS sony_arw_load_raw;\n        break;\n      }\n      load_flags = 79;\n    case 32769:\n      load_flags++;\n    case 32770:\n    case 32773:\n      goto slr;\n    case 0:\n    case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n      // Sony 14-bit uncompressed\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))\n      {\n        load_raw = &CLASS nikon_coolscan_load_raw;\n        raw_color = 1;\n        filters = 0;\n        break;\n      }\n#endif\n      if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)\n        load_flags = 24;\n      if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)\n      {\n        load_flags = 81;\n        tiff_bps = 12;\n      }\n    slr:\n      switch (tiff_bps)\n      {\n      case 8:\n        load_raw = &CLASS eight_bit_load_raw;\n        break;\n      case 12:\n        if (tiff_ifd[raw].phint == 2)\n          load_flags = 6;\n        load_raw = &CLASS packed_load_raw;\n        break;\n      case 14:\n        load_flags = 0;\n      case 16:\n        load_raw = &CLASS unpacked_load_raw;\n        if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)\n          load_raw = &CLASS olympus_load_raw;\n      }\n      break;\n    case 6:\n    case 7:\n    case 99:\n      load_raw = &CLASS lossless_jpeg_load_raw;\n      break;\n    case 262:\n      load_raw = &CLASS kodak_262_load_raw;\n      break;\n    case 34713:\n      if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 1;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        if (model[0] == 'N')\n          load_flags = 80;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS nikon_yuv_load_raw;\n        gamma_curve(1 / 2.4, 12.92, 1, 4095);\n        memset(cblack, 0, sizeof cblack);\n        filters = 0;\n      }\n      else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS unpacked_load_raw;\n        load_flags = 4;\n        order = 0x4d4d;\n      }\n      else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 80;\n      }\n      else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n               tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n      {\n        int fit = 1;\n        for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last\n          if (tiff_ifd[raw].strip_byte_counts[i] * 2 != tiff_ifd[raw].rows_per_strip * raw_width * 3)\n          {\n            fit = 0;\n            break;\n          }\n        if (fit)\n          load_raw = &CLASS nikon_load_striped_packed_raw;\n        else\n          load_raw = &CLASS nikon_load_raw; // fallback\n      }\n      else\n#endif\n        load_raw = &CLASS nikon_load_raw;\n      break;\n    case 65535:\n      load_raw = &CLASS pentax_load_raw;\n      break;\n    case 65000:\n      switch (tiff_ifd[raw].phint)\n      {\n      case 2:\n        load_raw = &CLASS kodak_rgb_load_raw;\n        filters = 0;\n        break;\n      case 6:\n        load_raw = &CLASS kodak_ycbcr_load_raw;\n        filters = 0;\n        break;\n      case 32803:\n        load_raw = &CLASS kodak_65000_load_raw;\n      }\n    case 32867:\n    case 34892:\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      break;\n#endif\n    default:\n      is_raw = 0;\n    }\n  if (!dng_version)\n    if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||\n         (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && !strcasestr(make, \"Kodak\") && !strstr(model2, \"DEBUG RAW\"))) &&\n        strncmp(software, \"Nikon Scan\", 10))\n      is_raw = 0;\n  for (i = 0; i < tiff_nifds; i++)\n    if (i != raw &&\n        (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >\n            thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&\n        tiff_ifd[i].comp != 34892)\n    {\n      thumb_width = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0)\n  {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp)\n    {\n    case 0:\n      write_thumb = &CLASS layer_thumb;\n      break;\n    case 1:\n      if (tiff_ifd[thm].bps <= 8)\n        write_thumb = &CLASS ppm_thumb;\n      else if (!strncmp(make, \"Imacon\", 6))\n        write_thumb = &CLASS ppm16_thumb;\n      else\n        thumb_load_raw = &CLASS kodak_thumb_load_raw;\n      break;\n    case 65000:\n      thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save = ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if (ifp->wfname())\n  {\n    std::wstring rawfile(ifp->wfname());\n    rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");\n    if (!ifp->subfile_open(rawfile.c_str()))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n  if (!ifp->fname())\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n\n  ext = strrchr(ifname, '.');\n  file = strrchr(ifname, '/');\n  if (!file)\n    file = strrchr(ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file)\n    file = ifname - 1;\n#else\n  if (!file)\n    file = (char *)ifname - 1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext - file != 8)\n    return;\n  jname = (char *)malloc(strlen(ifname) + 1);\n  merror(jname, \"parse_external_jpeg()\");\n  strcpy(jname, ifname);\n  jfile = file - ifname + jname;\n  jext = ext - ifname + jname;\n  if (strcasecmp(ext, \".jpg\"))\n  {\n    strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");\n    if (isdigit(*file))\n    {\n      memcpy(jfile, file + 4, 4);\n      memcpy(jfile + 4, file, 4);\n    }\n  }\n  else\n    while (isdigit(*--jext))\n    {\n      if (*jext != '9')\n      {\n        (*jext)++;\n        break;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp(jname, ifname))\n  {\n    if ((ifp = fopen(jname, \"rb\")))\n    {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose(ifp);\n    }\n  }\n#else\n  if (strcmp(jname, ifname))\n  {\n    if (!ifp->subfile_open(jname))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n  }\n#endif\n  if (!timestamp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n  }\n  free(jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = {0x410, 0x45f3};\n  int i, bpp, row, col, vbits = 0;\n  unsigned long bitbuf = 0;\n\n  if ((get2(), get4()) != 0x80008 || !get4())\n    return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12)\n    return;\n  for (i = row = 0; row < 8; row++)\n    for (col = 0; col < 8; col++)\n    {\n      if (vbits < bpp)\n      {\n        bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n        vbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff(int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi = -1;\n  ushort key[] = {0x410, 0x45f3};\n\n  fseek(ifp, offset + length - 4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek(ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127)\n    return;\n  while (nrecs--)\n  {\n    type = get2();\n    len = get4();\n    save = ftell(ifp) + 4;\n    fseek(ifp, offset + get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n    {\n      parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004)\n      parse_ciff(ftell(ifp), len, depth + 1);\n#endif\n    if (type == 0x0810)\n      fread(artist, 64, 1, ifp);\n    if (type == 0x080a)\n    {\n      fread(make, 64, 1, ifp);\n      fseek(ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread(model, 64, 1, ifp);\n    }\n    if (type == 0x1810)\n    {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835) /* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007)\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818)\n    {\n      shutter = powf64(2.0f, -int_to_float((get4(), get4())));\n      aperture = powf64(2.0f, int_to_float(get4()) / 2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a)\n    {\n      //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture = _CanonConvertAperture((get2(), get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture = powf64(2.0, (get2(), (short)get2()) / 64.0);\n#endif\n      shutter = powf64(2.0, -((short)get2()) / 32.0);\n      wbi = (get2(), get2());\n      if (wbi > 17)\n        wbi = 0;\n      fseek(ifp, 32, SEEK_CUR);\n      if (shutter > 1e6)\n        shutter = get2() / 10.0;\n    }\n    if (type == 0x102c)\n    {\n      if (get2() > 512)\n      { /* Pro90, G1 */\n        fseek(ifp, 118, SEEK_CUR);\n        FORC4 cam_mul[c ^ 2] = get2();\n      }\n      else\n      { /* G2, S30, S40 */\n        fseek(ifp, 98, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n    {\n      INT64 o = ftell(ifp);\n      fseek(ifp, (0x5 << 1), SEEK_CUR);\n      Canon_WBpresets(0, 0);\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x102d)\n    {\n      INT64 o = ftell(ifp);\n      Canon_CameraSettings();\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x580b)\n    {\n      if (strcmp(model, \"Canon EOS D30\"))\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n      else\n        sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);\n    }\n#endif\n    if (type == 0x0032)\n    {\n      if (len == 768)\n      { /* EOS D30 */\n        fseek(ifp, 72, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n        if (!wbi)\n          cam_mul[0] = -1; /* use my auto white balance */\n      }\n      else if (!cam_mul[0])\n      {\n        if (get2() == key[0]) /* Pro1, G6, S60, S70 */\n          c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;\n        else\n        { /* G3, G5, S45, S50 */\n          c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';\n          key[0] = key[1] = 0;\n        }\n        fseek(ifp, 78 + c * 8, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n        if (!wbi)\n          cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9)\n    { /* D60, 10D, 300D, and clones */\n      if (len > 66)\n        wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';\n      fseek(ifp, 2 + wbi * 8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))\n      ciff_block_1030(); /* all that don't have 0x10a9 */\n    if (type == 0x1031)\n    {\n      raw_width = (get2(), get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c)\n    {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2)\n      {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n        if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n          imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2)\n        focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813)\n      flash_used = int_to_float(len);\n    if (type == 0x5814)\n      canon_ev = int_to_float(len);\n    if (type == 0x5817)\n      shot_order = len;\n    if (type == 0x5834)\n    {\n      unique_id = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n      setCanonBodyFeatures(unique_id);\n#endif\n    }\n    if (type == 0x580e)\n      timestamp = len;\n    if (type == 0x180e)\n      timestamp = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime(gmtime(&timestamp));\n#endif\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek(ifp, 0, SEEK_SET);\n  memset(&t, 0, sizeof t);\n  do\n  {\n    fgets(line, 128, ifp);\n    if ((val = strchr(line, '=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line, \"DAT\"))\n      sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line, \"TIM\"))\n      sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line, \"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line, \"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line, \"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line, \"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line, \"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line, \"EOHD\", 4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy(make, \"Rollei\");\n  strcpy(model, \"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek(ifp, get4(), SEEK_SET);\n  while (entries--)\n  {\n    off = get4();\n    get4();\n    fread(str, 8, 1, ifp);\n    if (!strcmp(str, \"META\"))\n      meta_offset = off;\n    if (!strcmp(str, \"THUMB\"))\n      thumb_offset = off;\n    if (!strcmp(str, \"RAW0\"))\n      data_offset = off;\n  }\n  fseek(ifp, meta_offset + 20, SEEK_SET);\n  fread(make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make, ' ')))\n  {\n    strcpy(model, cp + 1);\n    *cp = 0;\n  }\n  raw_width = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(), get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one(int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset(&ph1, 0, sizeof ph1);\n  fseek(ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177)\n    return; /* \"Raw\" */\n  fseek(ifp, get4() + base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--)\n  {\n    tag = get4();\n    type = get4();\n    len = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek(ifp, base + data, SEEK_SET);\n    switch (tag)\n    {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      }\n      else\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4)\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (int_to_float(data) / 2.0f));\n      else\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x0403:\n      if (type == 4)\n        imgdata.lens.makernotes.CurFocal = int_to_float(data);\n      else\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n      {\n        imgdata.lens.makernotes.MinFocal = 0.0f;\n      }\n      break;\n    case 0x0417:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n    case 0x100:\n      flip = \"0653\"[data & 3] - '0';\n      break;\n    case 0x106:\n      for (i = 0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.P1_color[0].romm_cam[i] =\n#endif\n            ((float *)romm_cam)[i] = getreal(11);\n      romm_coeff(romm_cam);\n      break;\n    case 0x107:\n      FORC3 cam_mul[c] = getreal(11);\n      break;\n    case 0x108:\n      raw_width = data;\n      break;\n    case 0x109:\n      raw_height = data;\n      break;\n    case 0x10a:\n      left_margin = data;\n      break;\n    case 0x10b:\n      top_margin = data;\n      break;\n    case 0x10c:\n      width = data;\n      break;\n    case 0x10d:\n      height = data;\n      break;\n    case 0x10e:\n      ph1.format = data;\n      break;\n    case 0x10f:\n      data_offset = data + base;\n      break;\n    case 0x110:\n      meta_offset = data + base;\n      meta_length = len;\n      break;\n    case 0x112:\n      ph1.key_off = save - 4;\n      break;\n    case 0x210:\n      ph1.tag_210 = int_to_float(data);\n      break;\n    case 0x21a:\n      ph1.tag_21a = data;\n      break;\n    case 0x21c:\n      strip_offset = data + base;\n      break;\n    case 0x21d:\n      ph1.t_black = data;\n      break;\n    case 0x222:\n      ph1.split_col = data;\n      break;\n    case 0x223:\n      ph1.black_col = data + base;\n      break;\n    case 0x224:\n      ph1.split_row = data;\n      break;\n    case 0x225:\n      ph1.black_row = data + base;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x226:\n      for (i = 0; i < 9; i++)\n        imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n      break;\n#endif\n    case 0x301:\n      model[63] = 0;\n      fread(model, 1, 63, ifp);\n      if ((cp = strstr(model, \" camera\")))\n        *cp = 0;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek(ifp, 6, SEEK_CUR);\n    fseek(ifp, meta_offset + get4(), SEEK_SET);\n    entries = get4();\n    get4();\n    while (entries--)\n    {\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x0407)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        }\n        else\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy(make, \"Phase One\");\n  if (model[0])\n    return;\n  switch (raw_height)\n  {\n  case 2060:\n    strcpy(model, \"LightPhase\");\n    break;\n  case 2682:\n    strcpy(model, \"H 10\");\n    break;\n  case 4128:\n    strcpy(model, \"H 20\");\n    break;\n  case 5488:\n    strcpy(model, \"H 25\");\n    break;\n  }\n}\n\nvoid CLASS parse_fuji(int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek(ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255)\n    return;\n  while (entries--)\n  {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100)\n    {\n      raw_height = get2();\n      raw_width = get2();\n    }\n    else if (tag == 0x121)\n    {\n      height = get2();\n      if ((width = get2()) == 4284)\n        width += 3;\n    }\n    else if (tag == 0x130)\n    {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    }\n    else if (tag == 0x131)\n    {\n      filters = 9;\n      FORC(36) xtrans_abs[0][35 - c] = fgetc(ifp) & 3;\n    }\n    else if (tag == 0x2ff0)\n    {\n      FORC4 cam_mul[c ^ 1] = get2();\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b = fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    }\n    else if (tag == 0x2100)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    }\n    else if (tag == 0x2200)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    }\n    else if (tag == 0x2300)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    }\n    else if (tag == 0x2301)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    }\n    else if (tag == 0x2302)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    }\n    else if (tag == 0x2310)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    }\n    else if (tag == 0x2400)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n#endif\n      // IB end\n    }\n    else if (tag == 0xc000)\n    {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000)\n        tag = get4();\n      if (tag > 10000)\n        tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);\n#endif\n      order = c;\n    }\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width >>= fuji_layout;\n}\n\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n\t&& (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n\t) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  struct tm t;\n\n  order = 0x4949;\n  fread(tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))\n  {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  }\n  else if (!memcmp(tag, \"nctg\", 4))\n  {\n    while (ftell(ifp) + 7 < end)\n    {\n      i = get2();\n      size = get2();\n      if ((i + 1) >> 1 == 10 && size == 20)\n        get_timestamp(0);\n      else\n        fseek(ifp, size, SEEK_CUR);\n    }\n  }\n  else if (!memcmp(tag, \"IDIT\", 4) && size < 64)\n  {\n    fread(date, 64, 1, ifp);\n    date[size] = 0;\n    memset(&t, 0, sizeof t);\n    if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)\n    {\n      for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)\n        ;\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n        timestamp = mktime(&t);\n    }\n  }\n  else\n    fseek(ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"SMaL\");\n  sprintf(model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek(ifp, 52, SEEK_SET);\n  width = get4();\n  height = get4();\n  fseek(ifp, 0, SEEK_END);\n  fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek(ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF)\n    {\n      if (get4() == 0x52454456)\n        if (is_raw++ == shot_select)\n          data_offset = ftello(ifp) - 8;\n      fseek(ifp, len - 8, SEEK_CUR);\n    }\n  }\n  else\n  {\n    rdvo = get4();\n    fseek(ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n//@end COMMON\n\nchar *CLASS foveon_gets(int offset, char *str, int len)\n{\n  int i;\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < len - 1; i++)\n    if ((str[i] = get2()) == 0)\n      break;\n  str[i] = 0;\n  return str;\n}\n\nvoid CLASS parse_foveon()\n{\n  int entries, img = 0, off, len, tag, save, i, wide, high, pent, poff[256][2];\n  char name[64], value[64];\n  order = 0x4949; /* Little-endian */\n  fseek(ifp, 36, SEEK_SET);\n  flip = get4();\n  fseek(ifp, -4, SEEK_END);\n  fseek(ifp, get4(), SEEK_SET);\n  if (get4() != 0x64434553)\n    return; /* SECd */\n  entries = (get4(), get4());\n  while (entries--)\n  {\n    off = get4();\n    len = get4();\n    tag = get4();\n    save = ftell(ifp);\n    fseek(ifp, off, SEEK_SET);\n    if (get4() != (0x20434553 | (tag << 24)))\n      return;\n    switch (tag)\n    {\n    case 0x47414d49: /* IMAG */\n    case 0x32414d49: /* IMA2 */\n      fseek(ifp, 8, SEEK_CUR);\n      pent = get4();\n      wide = get4();\n      high = get4();\n      if (wide > raw_width && high > raw_height)\n      {\n        switch (pent)\n        {\n        case 5:\n          load_flags = 1;\n        case 6:\n          load_raw = &CLASS foveon_sd_load_raw;\n          break;\n        case 30:\n          load_raw = &CLASS foveon_dp_load_raw;\n          break;\n        default:\n          load_raw = 0;\n        }\n        raw_width = wide;\n        raw_height = high;\n        data_offset = off + 28;\n        is_foveon = 1;\n      }\n      fseek(ifp, off + 28, SEEK_SET);\n      if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8 && thumb_length < len - 28)\n      {\n        thumb_offset = off + 28;\n        thumb_length = len - 28;\n        write_thumb = &CLASS jpeg_thumb;\n      }\n      if (++img == 2 && !thumb_length)\n      {\n        thumb_offset = off + 24;\n        thumb_width = wide;\n        thumb_height = high;\n        write_thumb = &CLASS foveon_thumb;\n      }\n      break;\n    case 0x464d4143: /* CAMF */\n      meta_offset = off + 8;\n      meta_length = len - 28;\n      break;\n    case 0x504f5250: /* PROP */\n      pent = (get4(), get4());\n      fseek(ifp, 12, SEEK_CUR);\n      off += pent * 8 + 24;\n      if ((unsigned)pent > 256)\n        pent = 256;\n      for (i = 0; i < pent * 2; i++)\n        ((int *)poff)[i] = off + get4() * 2;\n      for (i = 0; i < pent; i++)\n      {\n        foveon_gets(poff[i][0], name, 64);\n        foveon_gets(poff[i][1], value, 64);\n        if (!strcmp(name, \"ISO\"))\n          iso_speed = atoi(value);\n        if (!strcmp(name, \"CAMMANUF\"))\n          strcpy(make, value);\n        if (!strcmp(name, \"CAMMODEL\"))\n          strcpy(model, value);\n        if (!strcmp(name, \"WB_DESC\"))\n          strcpy(model2, value);\n        if (!strcmp(name, \"TIME\"))\n          timestamp = atoi(value);\n        if (!strcmp(name, \"EXPTIME\"))\n          shutter = atoi(value) / 1000000.0;\n        if (!strcmp(name, \"APERTURE\"))\n          aperture = atof(value);\n        if (!strcmp(name, \"FLENGTH\"))\n          focal_len = atof(value);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strcmp(name, \"CAMSERIAL\"))\n          strcpy(imgdata.shootinginfo.BodySerial, value);\n        if (!strcmp(name, \"FLEQ35MM\"))\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n        if (!strcmp(name, \"LENSARANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n            if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSFRANGE\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n          sp = strrchr(value, ' ');\n          if (sp)\n          {\n            imgdata.lens.makernotes.MaxFocal = atof(sp);\n            if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n              my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n          }\n        }\n        if (!strcmp(name, \"LENSMODEL\"))\n        {\n          char *sp;\n          imgdata.lens.makernotes.LensID = strtol(value, &sp, 16); // atoi(value);\n          if (imgdata.lens.makernotes.LensID)\n            imgdata.lens.makernotes.LensMount = Sigma_X3F;\n        }\n      }\n#endif\n    }\n#ifdef LOCALTIME\n    timestamp = mktime(gmtime(&timestamp));\n#endif\n  }\n  fseek(ifp, save, SEEK_SET);\n}\n}\n\n//@out COMMON\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff(const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n                       ,\n                       int internal_only\n#endif\n                       )\n{\n  // clang-format off\n  static const struct\n  {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X Mark II\", 0, 0, /* temp */\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100F\", 0, 0,\n      {11434,-4948,-1210,-3746,12042,1903,-666,1479,5235}},\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T20\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526}},\n    { \"Fujifilm GFX 50S\", 0, 0,\n      {11940,-4431,-1255,-6766,14428,2542,-994,1165,7421}},\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D5600\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax KP\", 0, 0,  /* temp */\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n\n    { \"Panasonic DC-FZ82\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-FZ80\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0, /* 40,42,45 */\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n\n    { \"Panasonic DC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  // clang-format on\n\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if (colors > 4 || colors < 1)\n    return;\n\n  int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;\n  if (cblack[4] * cblack[5] > 0)\n  {\n    for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n      bl64 += cblack[c + 6];\n    bl64 /= cblack[4] * cblack[5];\n  }\n  int rblack = black + bl4 + bl64;\n\n  sprintf(name, \"%s %s\", t_make, t_model);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))\n    {\n      if (!dng_version)\n      {\n        if (table[i].t_black > 0)\n        {\n          black = (ushort)table[i].t_black;\n          memset(cblack, 0, sizeof(cblack));\n        }\n        else if (table[i].t_black < 0 && rblack == 0)\n        {\n          black = (ushort)(-table[i].t_black);\n          memset(cblack, 0, sizeof(cblack));\n        }\n        if (table[i].t_maximum)\n          maximum = (ushort)table[i].t_maximum;\n      }\n      if (table[i].trans[0])\n      {\n        for (raw_color = j = 0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (internal_only)\n            imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n          else\n            imgdata.color.cam_xyz[0][j] =\n#endif\n                ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!internal_only)\n#endif\n          cam_xyz_coeff(rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff(int index)\n{\n  static const float table[][12] = {/* index 0 -- all Foveon cameras */\n                                    {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},\n                                    /* index 1 -- Kodak DC20 and DC25 */\n                                    {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},\n                                    /* index 2 -- Logitech Fotoman Pixtura */\n                                    {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},\n                                    /* index 3 -- Nikon E880, E900, and E990 */\n                                    {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,\n                                     -1.204965, 1.082304, 2.941367, -1.818705}};\n  int i, c;\n\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i * colors + c];\n}\n\nshort CLASS guess_byte_order(int words)\n{\n  uchar test[4][2];\n  int t = 2, msb;\n  double diff, sum[2] = {0, 0};\n\n  fread(test[0], 2, 2, ifp);\n  for (words -= 2; words--;)\n  {\n    fread(test[t], 2, 1, ifp);\n    for (msb = 0; msb < 2; msb++)\n    {\n      diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);\n      sum[msb] += diff * diff;\n    }\n    t = (t + 1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n\n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  return 100 * log(sum[0] / sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if (len < 1)\n    return; // not needed, b/c sizeof of make/model is 64\n  string[len - 1] = 0;\n  if (len < 3)\n    return; // also not needed\n  len = strnlen(string, len - 1);\n  for (int i = len - 1; i >= 0; i--)\n  {\n    if (isspace(string[i]))\n      string[i] = 0;\n    else\n      break;\n  }\n}\n\nvoid CLASS initdata()\n{\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n  for (int i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n}\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n      {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},\n      {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},\n      {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},\n      {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},\n      {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},\n      {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},\n      {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},\n      {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},\n  };\n  static const ushort canon[][11] = {\n      {1944, 1416, 0, 0, 48, 0},\n      {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},\n      {2224, 1456, 48, 6, 0, 2},\n      {2376, 1728, 12, 6, 52, 2},\n      {2672, 1968, 12, 6, 44, 2},\n      {3152, 2068, 64, 12, 0, 0, 16},\n      {3160, 2344, 44, 12, 4, 4},\n      {3344, 2484, 4, 6, 52, 6},\n      {3516, 2328, 42, 14, 0, 0},\n      {3596, 2360, 74, 12, 0, 0},\n      {3744, 2784, 52, 12, 8, 12},\n      {3944, 2622, 30, 18, 6, 2},\n      {3948, 2622, 42, 18, 0, 2},\n      {3984, 2622, 76, 20, 0, 2, 14},\n      {4104, 3048, 48, 12, 24, 12},\n      {4116, 2178, 4, 2, 0, 0},\n      {4152, 2772, 192, 12, 0, 0},\n      {4160, 3124, 104, 11, 8, 65},\n      {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},\n      {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},\n      {4312, 2876, 22, 18, 0, 2},\n      {4352, 2874, 62, 18, 0, 0},\n      {4476, 2954, 90, 34, 0, 0},\n      {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},\n      {4480, 3366, 80, 50, 0, 0},\n      {4496, 3366, 80, 50, 12, 0},\n      {4768, 3516, 96, 16, 0, 0, 0, 16},\n      {4832, 3204, 62, 26, 0, 0},\n      {4832, 3228, 62, 51, 0, 0},\n      {5108, 3349, 98, 13, 0, 0},\n      {5120, 3318, 142, 45, 62, 0},\n      {5280, 3528, 72, 52, 0, 0}, /* EOS M */\n      {5344, 3516, 142, 51, 0, 0},\n      {5344, 3584, 126, 100, 0, 2},\n      {5360, 3516, 158, 51, 0, 0},\n      {5568, 3708, 72, 38, 0, 0},\n      {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},\n      {5712, 3774, 62, 20, 10, 2},\n      {5792, 3804, 158, 51, 0, 0},\n      {5920, 3950, 122, 80, 2, 0},\n      {6096, 4056, 72, 34, 0, 0},  /* EOS M3 */\n      {6288, 4056, 266, 36, 0, 0}, /* EOS 80D */\n      {6880, 4544, 136, 42, 0, 0}, /* EOS 5D4 */\n      {8896, 5920, 160, 64, 0, 0},\n  };\n  static const struct\n  {\n    ushort id;\n    char t_model[20];\n  } unique[] =\n      {\n          {0x001, \"EOS-1D\"},\n          {0x167, \"EOS-1DS\"},\n          {0x168, \"EOS 10D\"},\n          {0x169, \"EOS-1D Mark III\"},\n          {0x170, \"EOS 300D\"},\n          {0x174, \"EOS-1D Mark II\"},\n          {0x175, \"EOS 20D\"},\n          {0x176, \"EOS 450D\"},\n          {0x188, \"EOS-1Ds Mark II\"},\n          {0x189, \"EOS 350D\"},\n          {0x190, \"EOS 40D\"},\n          {0x213, \"EOS 5D\"},\n          {0x215, \"EOS-1Ds Mark III\"},\n          {0x218, \"EOS 5D Mark II\"},\n          {0x232, \"EOS-1D Mark II N\"},\n          {0x234, \"EOS 30D\"},\n          {0x236, \"EOS 400D\"},\n          {0x250, \"EOS 7D\"},\n          {0x252, \"EOS 500D\"},\n          {0x254, \"EOS 1000D\"},\n          {0x261, \"EOS 50D\"},\n          {0x269, \"EOS-1D X\"},\n          {0x270, \"EOS 550D\"},\n          {0x281, \"EOS-1D Mark IV\"},\n          {0x285, \"EOS 5D Mark III\"},\n          {0x286, \"EOS 600D\"},\n          {0x287, \"EOS 60D\"},\n          {0x288, \"EOS 1100D\"},\n          {0x289, \"EOS 7D Mark II\"},\n          {0x301, \"EOS 650D\"},\n          {0x302, \"EOS 6D\"},\n          {0x324, \"EOS-1D C\"},\n          {0x325, \"EOS 70D\"},\n          {0x326, \"EOS 700D\"},\n          {0x327, \"EOS 1200D\"},\n          {0x328, \"EOS-1D X Mark II\"},\n          {0x331, \"EOS M\"},\n          {0x335, \"EOS M2\"},\n          {0x374, \"EOS M3\"},  /* temp */\n          {0x384, \"EOS M10\"}, /* temp */\n          {0x394, \"EOS M5\"},  /* temp */\n          {0x346, \"EOS 100D\"},\n          {0x347, \"EOS 760D\"},\n          {0x349, \"EOS 5D Mark IV\"},\n          {0x350, \"EOS 80D\"},\n          {0x382, \"EOS 5DS\"},\n          {0x393, \"EOS 750D\"},\n          {0x401, \"EOS 5DS R\"},\n          {0x404, \"EOS 1300D\"},\n      },\n    sonique[] = {\n        {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},\n        {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},\n        {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},\n        {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},\n        {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},\n        {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},\n        {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},\n        {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},\n        {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},\n        {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},\n        {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},\n        {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},\n        {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},\n        {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},\n        {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},\n        {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},\n        {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x168, \"ILCE-6500\"},\n    };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t const_table[]\n#else\n  static const struct\n  {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  } table[]\n#endif\n      = {\n          {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},\n          {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},\n          {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},\n          {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},\n          {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},\n          {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},\n          {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},\n          //   Android Raw dumps id start\n          //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n          {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},\n          {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},\n          {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},\n          {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},\n          {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},\n          {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},\n          {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},\n          {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},\n          {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},\n          {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},\n          {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},\n          {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},\n          {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},\n          {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},\n          {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},\n          {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},\n          {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},\n          {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},\n          {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},\n          {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},\n          {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},\n          {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},\n          {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},\n          {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},\n          {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},\n          {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},\n          {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},\n          {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},\n          {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},\n          {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},\n          //   Android Raw dumps id end\n          {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},\n          {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},\n          {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},\n          {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},\n          {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},\n          {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},\n          {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},\n          {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},\n          {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},\n          {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},\n          {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},\n          {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},\n          {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},\n          {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},\n          {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},\n          {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},\n          {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},\n          {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},\n          {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},\n          {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},\n          {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},\n          {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},\n          {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},\n          {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},\n          {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},\n          {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},\n          {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},\n          {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},\n          {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},\n          {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},\n          {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},\n          {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},\n          {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},\n          {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},\n          {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},\n          {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},\n          {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},\n          {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},\n          {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},\n          {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},\n          {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},\n          {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},\n          {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},\n          {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},\n          {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},\n          {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},\n          {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},\n          {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},\n          {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},\n          {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},\n          {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},\n          {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},\n          {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},\n          {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},\n          {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},\n          {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},\n          {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},\n          {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},\n          {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},\n          {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},\n          {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},\n          {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},\n          {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},\n          {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},\n          {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},\n          {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},\n          {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},\n          {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},\n          {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},\n          {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},\n          {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},\n          {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},\n          {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},\n          {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},\n          {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},\n          {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},\n          {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},\n          {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n          {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n      };\n#ifdef LIBRAW_LIBRARY_BUILD\n  libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",\n                               \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",\n                               \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize = 1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);\n  for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)\n    memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));\n  camera_count += sizeof(const_table) / sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n#ifdef LIBRAW_LIBRARY_BUILD\n  for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n#endif\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n  for (i = 0; i < 4; i++)\n  {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i = 0; i < 0x10000; i++)\n    curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek(ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread(head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread(head, 1, 32, ifp);\n#endif\n  fseek(ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))\n  {\n    parse_phase_one(cp - head);\n    if (cp - head && parse_tiff(0))\n      apply_tiff();\n  }\n  else if (order == 0x4949 || order == 0x4d4d)\n  {\n    if (!memcmp(head + 6, \"HEAPCCDR\", 8))\n    {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(hlen, flen - hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    }\n    else if (parse_tiff(0))\n      apply_tiff();\n  }\n  else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))\n  {\n    fseek(ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek(ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  }\n  else if (!memcmp(head + 25, \"ARECOYK\", 7))\n  {\n    strcpy(make, \"Contax\");\n    strcpy(model, \"N Digital\");\n    fseek(ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek(ifp, 52, SEEK_SET);\n    switch (get4())\n    {\n    case 7:\n      iso_speed = 25;\n      break;\n    case 8:\n      iso_speed = 32;\n      break;\n    case 9:\n      iso_speed = 40;\n      break;\n    case 10:\n      iso_speed = 50;\n      break;\n    case 11:\n      iso_speed = 64;\n      break;\n    case 12:\n      iso_speed = 80;\n      break;\n    case 13:\n      iso_speed = 100;\n      break;\n    case 14:\n      iso_speed = 125;\n      break;\n    case 15:\n      iso_speed = 160;\n      break;\n    case 16:\n      iso_speed = 200;\n      break;\n    case 17:\n      iso_speed = 250;\n      break;\n    case 18:\n      iso_speed = 320;\n      break;\n    case 19:\n      iso_speed = 400;\n      break;\n    }\n    shutter = powf64(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek(ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek(ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  }\n  else if (!strcmp(head, \"PXN\"))\n  {\n    strcpy(make, \"Logitech\");\n    strcpy(model, \"Fotoman Pixtura\");\n  }\n  else if (!strcmp(head, \"qktk\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  }\n  else if (!strcmp(head, \"qktn\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  }\n  else if (!memcmp(head, \"FUJIFILM\", 8))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head + 0x1c);\n    memcpy(model2, head + 0x3c, 4);\n    model2[4] = 0;\n#endif\n    fseek(ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek(ifp, 92, SEEK_SET);\n    parse_fuji(get4());\n    if (thumb_offset > 120)\n    {\n      fseek(ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) ? 1 : 0;\n      if (is_raw == 2 && shot_select)\n        parse_fuji(i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);\n    parse_tiff(data_offset = get4());\n    parse_tiff(thumb_offset + 12);\n    apply_tiff();\n  }\n  else if (!memcmp(head, \"RIFF\", 4))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_riff();\n  }\n  else if (!memcmp(head + 4, \"ftypqt   \", 9))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_qt(fsize);\n    is_raw = 0;\n  }\n  else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))\n  {\n    fseek(ifp, 6, SEEK_SET);\n    fread(make, 1, 8, ifp);\n    fread(model, 1, 8, ifp);\n    fread(model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"NOKIARAW\", 8))\n  {\n    strcpy(make, \"NOKIA\");\n    order = 0x4949;\n    fseek(ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i * 8 / (width * height))\n    {\n    case 8:\n      load_raw = &CLASS eight_bit_load_raw;\n      break;\n    case 10:\n      load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"ARRI\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy(make, \"ARRI\");\n    fseek(ifp, 668, SEEK_SET);\n    fread(model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"XPDS\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 0x800, SEEK_SET);\n    fread(make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width = get2();\n    fseek(ifp, 56, SEEK_CUR);\n    fread(model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve(0, 12.25, 1, 1023);\n  }\n  else if (!memcmp(head + 4, \"RED1\", 4))\n  {\n    strcpy(make, \"Red\");\n    strcpy(model, \"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve(1 / 2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  }\n  else if (!memcmp(head, \"DSC-Image\", 9))\n    parse_rollei();\n  else if (!memcmp(head, \"PWAD\", 4))\n    parse_sinar_ia();\n  else if (!memcmp(head, \"\\0MRM\", 4))\n    parse_minolta(0);\n  else if (!memcmp(head, \"FOVb\", 4))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      parse_foveon();\n    else\n#endif\n      parse_x3f();\n#else\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    parse_foveon();\n#endif\n#endif\n  }\n  else if (!memcmp(head, \"CI\", 2))\n    parse_cine();\n  if (make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize = i = 0; i < camera_count; i++)\n#else\n    for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize)\n      {\n        strcpy(make, table[i].t_make);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\", 5))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n#endif\n        strcpy(model, table[i].t_model);\n        flip = table[i].flags >> 2;\n        zero_is_bad = table[i].flags & 2;\n        if (table[i].flags & 1)\n          parse_external_jpeg();\n        data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;\n        raw_width = table[i].rw;\n        raw_height = table[i].rh;\n        left_margin = table[i].lm;\n        top_margin = table[i].tm;\n        width = raw_width - left_margin - table[i].rm;\n        height = raw_height - top_margin - table[i].bm;\n        filters = 0x1010101 * table[i].cf;\n        colors = 4 - !((filters & filters >> 1) & 0x5555);\n        load_flags = table[i].lf;\n        switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))\n        {\n        case 6:\n          load_raw = &CLASS minolta_rd175_load_raw;\n          break;\n        case 8:\n          load_raw = &CLASS eight_bit_load_raw;\n          break;\n        case 10:\n          if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)\n          {\n            load_raw = &CLASS android_loose_load_raw;\n            break;\n          }\n          else if (load_flags & 1)\n          {\n            load_raw = &CLASS android_tight_load_raw;\n            break;\n          }\n        case 12:\n          load_flags |= 128;\n          load_raw = &CLASS packed_load_raw;\n          break;\n        case 16:\n          order = 0x4949 | 0x404 * (load_flags & 1);\n          tiff_bps -= load_flags >> 4;\n          tiff_bps -= load_flags = load_flags >> 1 & 7;\n          load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;\n        }\n        maximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize)\n    fsize = 0;\n  if (make[0] == 0)\n    parse_smal(0, flen);\n  if (make[0] == 0)\n  {\n    parse_jpeg(0);\n    fseek(ifp, 0, SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&\n        fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      strcpy(model, \"RPi IMX219\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 66;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    }\n    else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&\n             !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      if (!strncmp(model, \"ov5647\", 6))\n        strcpy(model, \"RPi OV5647 v.1\");\n      else\n        strcpy(model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 16;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&\n        fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))\n    {\n      strcpy(make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000 - 32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    }\n    else\n      is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i = 0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr(make, corp[i])) /* Simplify company names */\n      strcpy(make, corp[i]);\n  if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&\n      ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))\n    *cp = 0;\n  if (!strncasecmp(model, \"PENTAX\", 6))\n    strcpy(make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make, sizeof(make));\n  remove_trailing_spaces(model, sizeof(model));\n#else\n  cp = make + strlen(make); /* Remove trailing spaces */\n  while (*--cp == ' ')\n    *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ')\n    *cp = 0;\n#endif\n  i = strbuflen(make); /* Remove make from model */\n  if (!strncasecmp(model, make, i) && model[i++] == ' ')\n    memmove(model, model + i, 64 - i);\n  if (!strncmp(model, \"FinePix \", 8))\n    strcpy(model, model + 8);\n  if (!strncmp(model, \"Digital Camera \", 15))\n    strcpy(model, model + 15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw)\n    goto notraw;\n\n  if (!height)\n    height = raw_height;\n  if (!width)\n    width = raw_width;\n  if (height == 2624 && width == 3936) /* Pentax K10D and Samsung GX10 */\n  {\n    height = 2616;\n    width = 3896;\n  }\n  if (height == 3136 && width == 4864) /* Pentax K20D and Samsung GX20 */\n  {\n    height = 3124;\n    width = 4688;\n    filters = 0x16161616;\n  }\n  if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))\n  {\n    width = 4309;\n    filters = 0x16161616;\n  }\n  if (width >= 4960 && !strncmp(model, \"K-5\", 3))\n  {\n    left_margin = 10;\n    width = 4950;\n    filters = 0x16161616;\n  }\n  if (width == 6080 && !strcmp(model, \"K-70\"))\n  {\n    height = 4016;\n    top_margin = 32;\n    width = 6020;\n    left_margin = 60;\n  }\n  if (width == 4736 && !strcmp(model, \"K-7\"))\n  {\n    height = 3122;\n    width = 4684;\n    filters = 0x16161616;\n    top_margin = 2;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3 II\")) /* moved back */\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3\"))\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 7424 && !strcmp(model, \"645D\"))\n  {\n    height = 5502;\n    width = 7328;\n    filters = 0x61616161;\n    top_margin = 29;\n    left_margin = 48;\n  }\n  if (height == 3014 && width == 4096) /* Ricoh GX200 */\n    width = 4014;\n  if (dng_version)\n  {\n    if (filters == UINT_MAX)\n      filters = 0;\n    if (filters)\n      is_raw *= tiff_samples;\n    else\n      colors = tiff_samples;\n    switch (tiff_compress)\n    {\n    case 0: /* Compression not set, assuming uncompressed */\n    case 1:\n      load_raw = &CLASS packed_dng_load_raw;\n      break;\n    case 7:\n      load_raw = &CLASS lossless_dng_load_raw;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      load_raw = &CLASS deflate_dng_load_raw;\n      break;\n#endif\n    case 34892:\n      load_raw = &CLASS lossy_dng_load_raw;\n      break;\n    default:\n      load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\", 5) && unique_id)\n    {\n      for (i = 0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n        {\n          strcpy(model, unique[i].t_model);\n          break;\n        }\n    }\n    if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n    {\n      for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n        {\n          strcpy(model, sonique[i].t_model);\n          break;\n        }\n    }\n    goto dng_skip;\n  }\n  if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)\n  {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i = 0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1])\n      {\n        width = raw_width - (left_margin = canon[i][2]);\n        height = raw_height - (top_margin = canon[i][3]);\n        width -= canon[i][4];\n        height -= canon[i][5];\n        mask[0][1] = canon[i][6];\n        mask[0][3] = -canon[i][7];\n        mask[1][1] = canon[i][8];\n        mask[1][3] = -canon[i][9];\n        if (canon[i][10])\n          filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000)\n    {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make, \"Canon\", 5) && unique_id)\n  {\n    for (i = 0; i < sizeof unique / sizeof *unique; i++)\n      if (unique_id == 0x80000000 + unique[i].id)\n      {\n        adobe_coeff(\"Canon\", unique[i].t_model);\n        strcpy(model, unique[i].t_model);\n      }\n  }\n\n  if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n  {\n    for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n      if (unique_id == sonique[i].id)\n      {\n        adobe_coeff(\"Sony\", sonique[i].t_model);\n        strcpy(model, sonique[i].t_model);\n      }\n  }\n\n  if (!strncmp(make, \"Nikon\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n  /* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)\n  {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy(model, \"C603\");\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n#else\n  /* Always 512 for arw2_load_raw */\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = (load_raw == &LibRaw::sony_arw2_load_raw) ? 512 : (128 << (tiff_bps - 12));\n#endif\n\n  if (is_foveon)\n  {\n    if (height * 2 < width)\n      pixel_aspect = 0.5;\n    if (height > width)\n      pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if (!strncmp(make, \"Pentax\", 6))\n  {\n    if (!strncmp(model, \"K-1\", 3))\n    {\n      top_margin = 18;\n      height = raw_height - top_margin;\n      if (raw_width == 7392)\n      {\n        left_margin = 6;\n        width = 7376;\n      }\n    }\n  }\n  else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)\n  {\n    switch (width)\n    {\n    case 3344:\n      width -= 66;\n    case 3872:\n      width -= 6;\n    }\n    if (height > width)\n    {\n      SWAP(height, width);\n      SWAP(raw_height, raw_width);\n    }\n    if (width == 7200 && height == 3888)\n    {\n      raw_width = width = 6480;\n      raw_height = height = 4320;\n    }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot 600\"))\n  {\n    height = 613;\n    width = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))\n  {\n    height = 773;\n    width = 960;\n    raw_width = 992;\n    pixel_aspect = 256 / 235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot A50\"))\n  {\n    height = 968;\n    width = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot Pro70\"))\n  {\n    height = 1024;\n    width = 1552;\n    filters = 0x1e4b4e1b;\n  canon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  }\n  else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))\n  {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  }\n  else if (!strcmp(model, \"PowerShot A610\"))\n  {\n    if (canon_s2is())\n      strcpy(model + 10, \"S2 IS\");\n  }\n  else if (!strcmp(model, \"PowerShot SX220 HS\"))\n  {\n    mask[1][3] = -4;\n    top_margin = 16;\n    left_margin = 92;\n  }\n  else if (!strcmp(model, \"PowerShot S120\"))\n  {\n    raw_width = 4192;\n    raw_height = 3062;\n    width = 4022;\n    height = 3016;\n    mask[0][0] = top_margin = 31;\n    mask[0][2] = top_margin + height;\n    left_margin = 120;\n    mask[0][1] = 23;\n    mask[0][3] = 72;\n  }\n  else if (!strcmp(model, \"PowerShot G16\"))\n  {\n    mask[0][0] = 0;\n    mask[0][2] = 80;\n    mask[0][1] = 0;\n    mask[0][3] = 16;\n    top_margin = 29;\n    left_margin = 120;\n    width = raw_width - left_margin - 48;\n    height = raw_height - top_margin - 14;\n  }\n  else if (!strcmp(model, \"PowerShot SX50 HS\"))\n  {\n    top_margin = 17;\n  }\n  else if (!strcmp(model, \"EOS D2000C\"))\n  {\n    filters = 0x61616161;\n    if (!black)\n      black = curve[200];\n  }\n  else if (!strcmp(model, \"D1\"))\n  {\n    cam_mul[0] *= 256 / 527.0;\n    cam_mul[2] *= 256 / 317.0;\n  }\n  else if (!strcmp(model, \"D1X\"))\n  {\n    width -= 4;\n    pixel_aspect = 0.5;\n  }\n  else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))\n  {\n    height -= 3;\n    width -= 4;\n  }\n  else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))\n  {\n    width -= 4;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D3100\"))\n  {\n    width -= 28;\n    left_margin = 6;\n  }\n  else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))\n  {\n    width -= 42;\n  }\n  else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))\n  {\n    width -= 44;\n  }\n  else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))\n  {\n    width -= 46;\n  }\n  else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))\n  {\n    width -= 52;\n    left_margin = 2;\n  }\n  else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))\n  {\n    width--;\n  }\n  else if (!strcmp(model, \"D100\"))\n  {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  }\n  else if (!strcmp(model, \"D200\"))\n  {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  }\n  else if (!strncmp(model, \"D2H\", 3))\n  {\n    left_margin = 6;\n    width -= 14;\n  }\n  else if (!strncmp(model, \"D2X\", 3))\n  {\n    if (width == 3264)\n      width -= 32;\n    else\n      width -= 8;\n  }\n  else if (!strncmp(model, \"D300\", 4))\n  {\n    width -= 32;\n  }\n  else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)\n  {\n    if (!strcmp(model, \"COOLPIX P7700\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7700\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P7800\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7800\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P340\"))\n      load_flags = 0;\n  }\n  else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)\n  {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))\n      black = 255;\n  }\n  else if (!strncmp(model, \"COOLPIX B700\", 12))\n  {\n    load_flags = 24;\n    black = 200;\n  }\n  else if (!strncmp(model, \"1 \", 2))\n  {\n    height -= 2;\n  }\n  else if (fsize == 1581060)\n  {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  }\n  else if (fsize == 3178560)\n  {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  }\n  else if (fsize == 4771840)\n  {\n    if (!timestamp && nikon_e995())\n      strcpy(model, \"E995\");\n    if (strcmp(model, \"E995\"))\n    {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  }\n  else if (fsize == 2940928)\n  {\n    if (!timestamp && !nikon_e2100())\n      strcpy(model, \"E2500\");\n    if (!strcmp(model, \"E2500\"))\n    {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  }\n  else if (fsize == 4775936)\n  {\n    if (!timestamp)\n      nikon_3700();\n    if (model[0] == 'E' && atoi(model + 1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model, \"Optio 33WR\"))\n    {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O')\n    {\n      i = find_green(12, 32, 1188864, 3576832);\n      c = find_green(12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c))\n      {\n        SWAP(i, c);\n        load_flags = 24;\n      }\n      if (i < 0)\n        filters = 0x61616161;\n    }\n  }\n  else if (fsize == 5869568)\n  {\n    if (!timestamp && minolta_z2())\n    {\n      strcpy(make, \"Minolta\");\n      strcpy(model, \"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24 * (make[0] == 'M');\n  }\n  else if (fsize == 6291456)\n  {\n    fseek(ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d)\n    {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy(make, \"ISG\");\n      model[0] = 0;\n    }\n  }\n  else if (!strncmp(make, \"Fujifilm\", 8))\n  {\n    if (!strcmp(model + 7, \"S2Pro\"))\n    {\n      strcpy(model, \"S2Pro\");\n      height = 2144;\n      width = 2880;\n      flip = 6;\n    }\n    else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width) >> 2 << 1;\n    if (width == 2848 || width == 3664)\n      filters = 0x16161616;\n    if (width == 4032 || width == 4952)\n      left_margin = 0;\n    if (width == 3328 && (width -= 66))\n      left_margin = 34;\n    if (width == 4936)\n      left_margin = 4;\n    if (width == 6032)\n      left_margin = 0;\n    if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))\n    {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if (!strcmp(model, \"GFX 50S\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n    }\n    if (!strcmp(model, \"S5500\"))\n    {\n      height -= (top_margin = 6);\n    }\n    if (fuji_layout)\n      raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];\n  }\n  else if (!strcmp(model, \"KD-400Z\"))\n  {\n    height = 1712;\n    width = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  }\n  else if (!strcmp(model, \"KD-510Z\"))\n  {\n    goto konica_510z;\n  }\n  else if (!strncasecmp(make, \"Minolta\", 7))\n  {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model, \"DiMAGE A\", 8))\n    {\n      if (!strcmp(model, \"DiMAGE A200\"))\n        filters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))\n    {\n      sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));\n      adobe_coeff(make, model + 20);\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"DiMAGE G\", 8))\n    {\n      if (model[8] == '4')\n      {\n        height = 1716;\n        width = 2304;\n      }\n      else if (model[8] == '5')\n      {\n      konica_510z:\n        height = 1956;\n        width = 2607;\n        raw_width = 2624;\n      }\n      else if (model[8] == '6')\n      {\n        height = 2136;\n        width = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\n    konica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  }\n  else if (!strcmp(model, \"*ist D\"))\n  {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  }\n  else if (!strcmp(model, \"*ist DS\"))\n  {\n    height -= 2;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)\n  {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))\n  {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)\n  {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)\n  {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12)\n      load_flags = 80;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)\n  {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)\n  {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n      black = 1 << (tiff_bps - 7);\n  }\n  else if (!strcmp(model, \"EX1\"))\n  {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682)\n    {\n      height -= 10;\n      width -= 46;\n      top_margin = 8;\n    }\n  }\n  else if (!strcmp(model, \"WB2000\"))\n  {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718)\n    {\n      height -= 28;\n      width -= 56;\n      top_margin = 8;\n    }\n  }\n  else if (strstr(model, \"WB550\"))\n  {\n    strcpy(model, \"WB550\");\n  }\n  else if (!strcmp(model, \"EX2F\"))\n  {\n    height = 3030;\n    width = 4040;\n    top_margin = 15;\n    left_margin = 24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  else if (!strcmp(model, \"STV680 VGA\"))\n  {\n    black = 16;\n  }\n  else if (!strcmp(model, \"N95\"))\n  {\n    height = raw_height - (top_margin = 2);\n  }\n  else if (!strcmp(model, \"640x480\"))\n  {\n    gamma_curve(0.45, 4.5, 1, 255);\n  }\n  else if (!strncmp(make, \"Hasselblad\", 10))\n  {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262)\n    {\n      height = 5444;\n      width = 7248;\n      top_margin = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if (!strncasecmp(model, \"H3D\", 3))\n      {\n        adobe_coeff(\"Hasselblad\", \"H3DII-39\");\n        strcpy(model, \"H3DII-39\");\n      }\n    }\n    else if (raw_width == 7410 || raw_width == 8282)\n    {\n      height -= 84;\n      width -= 82;\n      top_margin = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\", \"H4D-40\");\n      strcpy(model, \"H4D-40\");\n    }\n    else if (raw_width == 8384) // X1D\n    {\n      top_margin = 96;\n      height -= 96;\n      left_margin = 48;\n      width -= 106;\n      adobe_coeff(\"Hasselblad\", \"X1D\");\n      maximum = 0xffff;\n      tiff_bps = 16;\n    }\n    else if (raw_width == 9044)\n    {\n      if (black > 500)\n      {\n        top_margin = 12;\n        left_margin = 44;\n        width = 8956;\n        height = 6708;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H4D-60\");\n        strcpy(model, \"H4D-60\");\n        black = 512;\n      }\n      else\n      {\n        height = 6716;\n        width = 8964;\n        top_margin = 8;\n        left_margin = 40;\n        black += load_flags = 256;\n        maximum = 0x8101;\n        strcpy(model, \"H3DII-60\");\n      }\n    }\n    else if (raw_width == 4090)\n    {\n      strcpy(model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n    else if (raw_width == 8282 && raw_height == 6240)\n    {\n      if (!strncasecmp(model, \"H5D\", 3))\n      {\n        /* H5D 50*/\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        black = 256;\n        strcpy(model, \"H5D-50\");\n      }\n      else if (!strncasecmp(model, \"H3D\", 3))\n      {\n        black = 0;\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H3D-50\");\n        strcpy(model, \"H3D-50\");\n      }\n    }\n    else if (raw_width == 8374 && raw_height == 6304)\n    {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model, \"H5D-50c\");\n    }\n    if (tiff_samples > 1)\n    {\n      is_raw = tiff_samples + 1;\n      if (!shot_select && !half_size)\n        filters = 0;\n    }\n  }\n  else if (!strncmp(make, \"Sinar\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size)\n      filters = 0;\n    maximum = 0x3fff;\n  }\n  else if (!strncmp(make, \"Leaf\", 4))\n  {\n    maximum = 0x3fff;\n    fseek(ifp, data_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1)\n      filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height)\n    {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048)\n    {\n      if (tiff_samples == 1)\n      {\n        filters = 1;\n        strcpy(cdesc, \"RBTG\");\n        strcpy(model, \"CatchLight\");\n        top_margin = 8;\n        left_margin = 18;\n        height = 2032;\n        width = 2016;\n      }\n      else\n      {\n        strcpy(model, \"DCB2\");\n        top_margin = 10;\n        left_margin = 16;\n        height = 2028;\n        width = 2022;\n      }\n    }\n    else if (width + height == 3144 + 2060)\n    {\n      if (!model[0])\n        strcpy(model, \"Cantare\");\n      if (width > height)\n      {\n        top_margin = 6;\n        left_margin = 32;\n        height = 2048;\n        width = 3072;\n        filters = 0x61616161;\n      }\n      else\n      {\n        left_margin = 6;\n        top_margin = 32;\n        width = 2048;\n        height = 3072;\n        filters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V')\n        filters = 0;\n      else\n        is_raw = tiff_samples;\n    }\n    else if (width == 2116)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    }\n    else if (width == 3171)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  }\n  else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))\n  {\n    if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw)\n    {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height)\n      height = raw_height;\n    for (i = 0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1])\n      {\n        left_margin = pana[i][2];\n        top_margin = pana[i][3];\n        width += pana[i][4];\n        height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  }\n  else if (!strcmp(model, \"C770UZ\"))\n  {\n    height = 1718;\n    width = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  }\n  else if (!strncmp(make, \"Olympus\", 7))\n  {\n    height += height & 1;\n    if (exif_cfa)\n      filters = exif_cfa;\n    if (width == 4100)\n      width -= 4;\n    if (width == 4080)\n      width -= 24;\n    if (width == 9280)\n    {\n      width -= 6;\n      height -= 6;\n    }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))\n    {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw)\n      {\n        maximum = 0xfc3;\n        memset(cblack, 0, sizeof cblack);\n      }\n    }\n    else if (!strcmp(model, \"STYLUS1\"))\n    {\n      width -= 14;\n      maximum = 0xfff;\n    }\n    else if (!strcmp(model, \"E-330\"))\n    {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n        maximum = 0xf79;\n    }\n    else if (!strcmp(model, \"SP550UZ\"))\n    {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width = 640;\n    }\n    else if (!strcmp(model, \"TG-4\"))\n    {\n      width -= 16;\n    }\n  }\n  else if (!strcmp(model, \"N Digital\"))\n  {\n    height = 2047;\n    width = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strcmp(model, \"DSC-F828\"))\n  {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy(cdesc, \"RGBE\");\n  }\n  else if (!strcmp(model, \"DSC-V3\"))\n  {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)\n  {\n    width = 3925;\n    order = 0x4d4d;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(make, \"Sony\") && raw_width == 4600)\n  {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)\n  {\n    if (height < 3280)\n      width -= 8;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)\n  { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)\n  {\n    width -= 24;\n    if (strstr(model, \"RX1\") || strstr(model, \"A99\"))\n      width -= 6;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)\n  {\n    width -= 30;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(model, \"DSLR-A100\"))\n  {\n    if (width == 3880)\n    {\n      height--;\n      width = ++raw_width;\n    }\n    else\n    {\n      height -= 4;\n      width -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strcmp(model, \"PIXL\"))\n  {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve(0, 7, 1, 255);\n  }\n  else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))\n  {\n    order = 0x4949;\n    if (filters && data_offset)\n    {\n      fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts(curve, 256);\n    }\n    else\n      gamma_curve(0, 3.875, 1, 255);\n    load_raw = filters ? &CLASS eight_bit_load_raw\n                       : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  }\n  else if (!strncasecmp(model, \"EasyShare\", 9))\n  {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strncasecmp(make, \"Kodak\", 5))\n  {\n    if (filters == UINT_MAX)\n      filters = 0x61616161;\n    if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))\n    {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ')\n        model[6] = 0;\n      if (!strcmp(model, \"DCS460A\"))\n        goto bw;\n    }\n    else if (!strcmp(model, \"DCS660M\"))\n    {\n      black = 214;\n      goto bw;\n    }\n    else if (!strcmp(model, \"DCS760M\"))\n    {\n    bw:\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model + 4, \"20X\"))\n      strcpy(cdesc, \"MYCY\");\n    if (strstr(model, \"DC25\"))\n    {\n      strcpy(model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model, \"DC2\", 3))\n    {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000)\n      {\n        raw_width = 256;\n        width = 249;\n        pixel_aspect = (4.0 * height) / (3.0 * width);\n      }\n      else\n      {\n        raw_width = 512;\n        width = 501;\n        pixel_aspect = (493.0 * height) / (373.0 * width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    }\n    else if (!strcmp(model, \"40\"))\n    {\n      strcpy(model, \"DC40\");\n      height = 512;\n      width = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    }\n    else if (strstr(model, \"DC50\"))\n    {\n      strcpy(model, \"DC50\");\n      height = 512;\n      width = 768;\n      iso_speed = 84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    }\n    else if (strstr(model, \"DC120\"))\n    {\n      strcpy(model, \"DC120\");\n      raw_height = height = 976;\n      raw_width = width = 848;\n      iso_speed = 160;\n      pixel_aspect = height / 0.75 / width;\n      load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    }\n    else if (!strcmp(model, \"DCS200\"))\n    {\n      thumb_height = 128;\n      thumb_width = 192;\n      thumb_offset = 6144;\n      thumb_misc = 360;\n      iso_speed = 140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  }\n  else if (!strcmp(model, \"Fotoman Pixtura\"))\n  {\n    height = 512;\n    width = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  }\n  else if (!strncmp(model, \"QuickTake\", 9))\n  {\n    if (head[5])\n      strcpy(model + 10, \"200\");\n    fseek(ifp, 544, SEEK_SET);\n    height = get2();\n    width = get2();\n    data_offset = (get4(), get2()) == 30 ? 738 : 736;\n    if (height > width)\n    {\n      SWAP(height, width);\n      fseek(ifp, data_offset - 6, SEEK_SET);\n      flip = ~get2() & 3 ? 5 : 6;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strncmp(make, \"Rollei\", 6) && !load_raw)\n  {\n    switch (raw_width)\n    {\n    case 1316:\n      height = 1030;\n      width = 1300;\n      top_margin = 1;\n      left_margin = 6;\n      break;\n    case 2568:\n      height = 1960;\n      width = 2560;\n      top_margin = 2;\n      left_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model, \"GRAS-50S5C\"))\n  {\n    height = 2048;\n    width = 2440;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x49494949;\n    order = 0x4949;\n    maximum = 0xfffC;\n  }\n  else if (!strcmp(model, \"BB-500CL\"))\n  {\n    height = 2058;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"BB-500GE\"))\n  {\n    height = 2058;\n    width = 2456;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"SVS625CL\"))\n  {\n    height = 2050;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if (!model[0])\n    sprintf(model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX)\n    filters = 0x94949494;\n  if (thumb_offset && !thumb_height)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      thumb_width = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (dng_version) /* Override black level by DNG tags */\n  {\n    /* copy DNG data from per-IFD field to color.dng */\n    int iifd = 0;\n    for (; iifd < tiff_nifds; iifd++)\n      if (tiff_ifd[iifd].offset == data_offset) // found\n        break;\n\n    if (iifd < tiff_nifds)\n    {\n      memmove(&imgdata.color.dng_color[0], &tiff_ifd[iifd].dng_color[0], sizeof(tiff_ifd[iifd].dng_color[0]));\n      memmove(&imgdata.color.dng_color[1], &tiff_ifd[iifd].dng_color[1], sizeof(tiff_ifd[iifd].dng_color[1]));\n      memmove(&imgdata.color.dng_levels, &tiff_ifd[iifd].dng_levels, sizeof(tiff_ifd[iifd].dng_levels));\n      meta_offset = tiff_ifd[iifd].opcode2_offset;\n      if (tiff_ifd[iifd].lineartable_offset && tiff_ifd[iifd].lineartable_len)\n      {\n        INT64 pos = ftell(ifp);\n        fseek(ifp, tiff_ifd[iifd].lineartable_offset, SEEK_SET);\n        linear_table(tiff_ifd[iifd].lineartable_len);\n        fseek(ifp, pos, SEEK_SET);\n      }\n      // Need to add curve too\n    }\n    /* Copy DNG black level to  */\n    maximum = imgdata.color.dng_levels.dng_whitelevel[0];\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),\n                 (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for (int i = 0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)\n  {\n    memcpy(rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color)\n    adobe_coeff(make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if (imgdata.color.cam_xyz[0][0] < 0.01)\n    adobe_coeff(make, model, 1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color)\n      adobe_coeff(\"Apple\", \"Quicktake\");\n\n  if (fuji_width)\n  {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  }\n  else\n  {\n    if (raw_height < height)\n      raw_height = height;\n    if (raw_width < width)\n      raw_width = width;\n  }\n  if (!tiff_bps)\n    tiff_bps = 12;\n  if (!maximum)\n  {\n    maximum = (1 << tiff_bps) - 1;\n    if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)\n      maximum = curve[maximum];\n  }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");\n  if (!raw_height)\n    raw_height = height;\n  if (!raw_width)\n    raw_width = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX)\n    flip = tiff_flip;\n  if (flip == UINT_MAX)\n    flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if (flip > 89 || flip < -89)\n  {\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n      break;\n    }\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n}\n\n//@end COMMON\n\n//@out FILEIO\n#ifndef NO_LCMS\nvoid CLASS apply_profile(const char *input, const char *output)\n{\n  char *prof;\n  cmsHPROFILE hInProfile = 0, hOutProfile = 0;\n  cmsHTRANSFORM hTransform;\n  FILE *fp;\n  unsigned size;\n\n  if (strcmp(input, \"embed\"))\n    hInProfile = cmsOpenProfileFromFile(input, \"r\");\n  else if (profile_length)\n  {\n#ifndef LIBRAW_LIBRARY_BUILD\n    prof = (char *)malloc(profile_length);\n    merror(prof, \"apply_profile()\");\n    fseek(ifp, profile_offset, SEEK_SET);\n    fread(prof, 1, profile_length, ifp);\n    hInProfile = cmsOpenProfileFromMem(prof, profile_length);\n    free(prof);\n#else\n    hInProfile = cmsOpenProfileFromMem(imgdata.color.profile, profile_length);\n#endif\n  }\n  else\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_EMBEDDED_PROFILE;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s has no embedded profile.\\n\"), ifname);\n#endif\n  }\n  if (!hInProfile)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_INPUT_PROFILE;\n#endif\n    return;\n  }\n  if (!output)\n    hOutProfile = cmsCreate_sRGBProfile();\n  else if ((fp = fopen(output, \"rb\")))\n  {\n    fread(&size, 4, 1, fp);\n    fseek(fp, 0, SEEK_SET);\n    oprof = (unsigned *)malloc(size = ntohl(size));\n    merror(oprof, \"apply_profile()\");\n    fread(oprof, 1, size, fp);\n    fclose(fp);\n    if (!(hOutProfile = cmsOpenProfileFromMem(oprof, size)))\n    {\n      free(oprof);\n      oprof = 0;\n    }\n  }\n#ifdef DCRAW_VERBOSE\n  else\n    fprintf(stderr, _(\"Cannot open file %s!\\n\"), output);\n#endif\n  if (!hOutProfile)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_BAD_OUTPUT_PROFILE;\n#endif\n    goto quit;\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Applying color profile...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 0, 2);\n#endif\n  hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_16, hOutProfile, TYPE_RGBA_16, INTENT_PERCEPTUAL, 0);\n  cmsDoTransform(hTransform, image, image, width * height);\n  raw_color = 1; /* Don't use rgb_cam with a profile */\n  cmsDeleteTransform(hTransform);\n  cmsCloseProfile(hOutProfile);\nquit:\n  cmsCloseProfile(hInProfile);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_APPLY_PROFILE, 1, 2);\n#endif\n}\n#endif\n//@end FILEIO\n\n//@out COMMON\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] = {\n      {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};\n  static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  static const double adobe_rgb[3][3] = {\n      {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};\n  static const double wide_rgb[3][3] = {\n      {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};\n  static const double prophoto_rgb[3][3] = {\n      {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};\n  static const double aces_rgb[3][3] = {\n      {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};\n  static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};\n  static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};\n  static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,\n                                   0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,\n                                   0,    0, 0,          0xf6d6,     0x10000,    0xd32d};\n  unsigned pbody[] = {10,         0x63707274, 0,  36, /* cprt */\n                      0x64657363, 0,          40,     /* desc */\n                      0x77747074, 0,          20,     /* wtpt */\n                      0x626b7074, 0,          20,     /* bkpt */\n                      0x72545243, 0,          14,     /* rTRC */\n                      0x67545243, 0,          14,     /* gTRC */\n                      0x62545243, 0,          14,     /* bTRC */\n                      0x7258595a, 0,          20,     /* rXYZ */\n                      0x6758595a, 0,          20,     /* gXYZ */\n                      0x6258595a, 0,          20};    /* bXYZ */\n  static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};\n  unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);\n#endif\n  gamma_curve(gamm[0], gamm[1], 0, 0);\n  memcpy(out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 || output_color < 1 || output_color > 6;\n#endif\n  if (!raw_color)\n  {\n    oprof = (unsigned *)calloc(phead[0], 1);\n    merror(oprof, \"convert_to_rgb()\");\n    memcpy(oprof, phead, sizeof phead);\n    if (output_color == 5)\n      oprof[4] = oprof[5];\n    oprof[0] = 132 + 12 * pbody[0];\n    for (i = 0; i < pbody[0]; i++)\n    {\n      oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i * 3 + 2] = oprof[0];\n      oprof[0] += (pbody[i * 3 + 3] + 3) & -4;\n    }\n    memcpy(oprof + 32, pbody, sizeof pbody);\n    oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;\n    memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;\n    for (i = 4; i < 7; i++)\n      memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);\n    pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n        for (num = k = 0; k < 3; k++)\n          num += xyzd50_srgb[i][k] * inverse[j][k];\n        oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;\n      }\n    for (i = 0; i < phead[0] / 4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");\n    strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (out_cam[i][j] = k = 0; k < 3; k++)\n          out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),\n            name[output_color - 1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset(histogram, 0, sizeof histogram);\n  for (img = image[0], row = 0; row < height; row++)\n    for (col = 0; col < width; col++, img += 4)\n    {\n      if (!raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        FORCC\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        FORC3 img[c] = CLIP((int)out[c]);\n      }\n      else if (document_mode)\n        img[0] = img[fcol(row, col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color)\n    colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters)\n    colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort(*)[4])calloc(high, wide * sizeof *img);\n  merror(img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);\n#endif\n\n  for (row = 0; row < high; row++)\n    for (col = 0; col < wide; col++)\n    {\n      ur = r = fuji_width + (row - col) * step;\n      uc = c = (row + col) * step;\n      if (ur > height - 2 || uc > width - 2)\n        continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur * width + uc;\n      for (i = 0; i < colors; i++)\n        img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +\n                                   (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;\n    }\n\n  free(image);\n  width = wide;\n  height = high;\n  image = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1)\n  {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(width, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c * width];\n      if (c + 1 < height)\n        pix1 += width * 4;\n      for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)\n        FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    height = newdim;\n  }\n  else\n  {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(height, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c + 1 < width)\n        pix1 += 4;\n      for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)\n        FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    width = newdim;\n  }\n  free(image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);\n#endif\n}\n\nint CLASS flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}\n//@end COMMON\n\nstruct tiff_tag\n{\n  ushort tag, type;\n  int count;\n  union {\n    char c[4];\n    short s[2];\n    int i;\n  } val;\n};\n\nstruct tiff_hdr\n{\n  ushort t_order, magic;\n  int ifd;\n  ushort pad, ntag;\n  struct tiff_tag tag[23];\n  int nextifd;\n  ushort pad2, nexif;\n  struct tiff_tag exif[4];\n  ushort pad3, ngps;\n  struct tiff_tag gpst[10];\n  short bps[4];\n  int rat[10];\n  unsigned gps[26];\n  char t_desc[512], t_make[64], t_model[64], soft[32], date[20], t_artist[64];\n};\n\n//@out COMMON\n\nvoid CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag + 1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2)\n  {\n    count = strnlen((char *)th + val, count - 1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val + c];\n  }\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head(struct tiff_hdr *th, int full)\n{\n  int c, psize = 0;\n  struct tm *t;\n\n  memset(th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4 + c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy(th->t_desc, desc, 512);\n  strncpy(th->t_make, make, 64);\n  strncpy(th->t_model, model, 64);\n  strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime(&timestamp);\n  sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,\n          t->tm_min, t->tm_sec);\n  strncpy(th->t_artist, artist, 64);\n  if (full)\n  {\n    tiff_set(th, &th->ntag, 254, 4, 1, 0);\n    tiff_set(th, &th->ntag, 256, 4, 1, width);\n    tiff_set(th, &th->ntag, 257, 4, 1, height);\n    tiff_set(th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag - 1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set(th, &th->ntag, 259, 3, 1, 1);\n    tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full)\n  {\n    if (oprof)\n      psize = ntohl(oprof[0]);\n    tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set(th, &th->ntag, 277, 3, 1, colors);\n    tiff_set(th, &th->ntag, 278, 4, 1, height);\n    tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);\n  }\n  else\n    tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');\n  tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set(th, &th->ntag, 284, 3, 1, 1);\n  tiff_set(th, &th->ntag, 296, 3, 1, 2);\n  tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize)\n    tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1])\n  {\n    tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set(th, &th->ngps, 0, 1, 4, 0x202);\n    tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);\n    tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));\n    tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);\n    tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));\n    tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);\n    tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));\n    tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));\n    tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy(th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc(0xff, tfp);\n  fputc(0xd8, tfp);\n  if (strcmp(t_humb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, tfp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, tfp);\n  }\n  fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp, thumb, thumb_length);\n  free(thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  fputc(0xff, ofp);\n  fputc(0xd8, ofp);\n  if (strcmp(thumb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, ofp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, ofp);\n  }\n  fwrite(thumb + 2, 1, thumb_length - 2, ofp);\n  free(thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white = 0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01; /* 99th percentile white level */\n#endif\n  if (fuji_width)\n    perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white = c = 0; c < colors; c++)\n    {\n      for (val = 0x2000, total = 0; --val > 32;)\n        if ((total += histogram[c][val]) > perc)\n          break;\n      if (t_white < val)\n        t_white = val;\n    }\n  gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);\n  iheight = height;\n  iwidth = width;\n  if (flip & 4)\n    SWAP(height, width);\n  ppm = (uchar *)calloc(width, colors * output_bps / 8);\n  ppm2 = (ushort *)ppm;\n  merror(ppm, \"write_ppm_tiff()\");\n  if (output_tiff)\n  {\n    tiff_head(&th, 1);\n    fwrite(&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite(oprof, ntohl(oprof[0]), 1, ofp);\n  }\n  else if (colors > 3)\n    fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,\n            (1 << output_bps) - 1, cdesc);\n  else\n    fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, width);\n  for (row = 0; row < height; row++, soff += rstep)\n  {\n    for (col = 0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n        FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;\n      else\n        FORCC ppm2[col * colors + c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab((char *)ppm2, (char *)ppm2, width * colors * 2);\n    fwrite(ppm, colors * output_bps / 8, width, ofp);\n  }\n  free(ppm);\n}\n//@end COMMON\n\nint CLASS main(int argc, const char **argv)\n{\n  int arg, status = 0, quality, i, c;\n  int timestamp_only = 0, thumbnail_only = 0, identify_only = 0;\n  int user_qual = -1, user_black = -1, user_sat = -1, user_flip = -1;\n  int use_fuji_rotate = 1, write_to_stdout = 0, read_from_stdin = 0;\n  const char *sp, *bpfile = 0, *dark_frame = 0, *write_ext;\n  char opm, opt, *ofname, *cp;\n  struct utimbuf ut;\n#ifndef NO_LCMS\n  const char *cam_profile = 0, *out_profile = 0;\n#endif\n\n#ifndef LOCALTIME\n  putenv((char *)\"TZ=UTC\");\n#endif\n#ifdef LOCALEDIR\n  setlocale(LC_CTYPE, \"\");\n  setlocale(LC_MESSAGES, \"\");\n  bindtextdomain(\"dcraw\", LOCALEDIR);\n  textdomain(\"dcraw\");\n#endif\n\n  if (argc == 1)\n  {\n    printf(_(\"\\nRaw photo decoder \\\"dcraw\\\" v%s\"), DCRAW_VERSION);\n    printf(_(\"\\nby Dave Coffin, dcoffin a cybercom o net\\n\"));\n    printf(_(\"\\nUsage:  %s [OPTION]... [FILE]...\\n\\n\"), argv[0]);\n    puts(_(\"-v        Print verbose messages\"));\n    puts(_(\"-c        Write image data to standard output\"));\n    puts(_(\"-e        Extract embedded thumbnail image\"));\n    puts(_(\"-i        Identify files without decoding them\"));\n    puts(_(\"-i -v     Identify files and show metadata\"));\n    puts(_(\"-z        Change file dates to camera timestamp\"));\n    puts(_(\"-w        Use camera white balance, if possible\"));\n    puts(_(\"-a        Average the whole image for white balance\"));\n    puts(_(\"-A <x y w h> Average a grey box for white balance\"));\n    puts(_(\"-r <r g b g> Set custom white balance\"));\n    puts(_(\"+M/-M     Use/don't use an embedded color matrix\"));\n    puts(_(\"-C <r b>  Correct chromatic aberration\"));\n    puts(_(\"-P <file> Fix the dead pixels listed in this file\"));\n    puts(_(\"-K <file> Subtract dark frame (16-bit raw PGM)\"));\n    puts(_(\"-k <num>  Set the darkness level\"));\n    puts(_(\"-S <num>  Set the saturation level\"));\n    puts(_(\"-n <num>  Set threshold for wavelet denoising\"));\n    puts(_(\"-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)\"));\n    puts(_(\"-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)\"));\n    puts(_(\"-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)\"));\n#ifndef NO_LCMS\n    puts(_(\"-o <file> Apply output ICC profile from file\"));\n    puts(_(\"-p <file> Apply camera ICC profile from file or \\\"embed\\\"\"));\n#endif\n    puts(_(\"-d        Document mode (no color, no interpolation)\"));\n    puts(_(\"-D        Document mode without scaling (totally raw)\"));\n    puts(_(\"-j        Don't stretch or rotate raw pixels\"));\n    puts(_(\"-W        Don't automatically brighten the image\"));\n    puts(_(\"-b <num>  Adjust brightness (default = 1.0)\"));\n    puts(_(\"-g <p ts> Set custom gamma curve (default = 2.222 4.5)\"));\n    puts(_(\"-q [0-3]  Set the interpolation quality\"));\n    puts(_(\"-h        Half-size color image (twice as fast as \\\"-q 0\\\")\"));\n    puts(_(\"-f        Interpolate RGGB as four colors\"));\n    puts(_(\"-m <num>  Apply a 3x3 median filter to R-G and B-G\"));\n    puts(_(\"-s [0..N-1] Select one raw image or \\\"all\\\" from each file\"));\n    puts(_(\"-6        Write 16-bit instead of 8-bit\"));\n    puts(_(\"-4        Linear 16-bit, same as \\\"-6 -W -g 1 1\\\"\"));\n    puts(_(\"-T        Write TIFF instead of PPM\"));\n    puts(\"\");\n    return 1;\n  }\n  argv[argc] = \"\";\n  for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)\n  {\n    opt = argv[arg++][1];\n    if ((cp = (char *)strchr(sp = \"nbrkStqmHACg\", opt)))\n      for (i = 0; i < \"114111111422\"[cp - sp] - '0'; i++)\n        if (!isdigit(argv[arg + i][0]))\n        {\n          fprintf(stderr, _(\"Non-numeric argument to \\\"-%c\\\"\\n\"), opt);\n          return 1;\n        }\n    switch (opt)\n    {\n    case 'n':\n      threshold = atof(argv[arg++]);\n      break;\n    case 'b':\n      bright = atof(argv[arg++]);\n      break;\n    case 'r':\n      FORC4 user_mul[c] = atof(argv[arg++]);\n      break;\n    case 'C':\n      aber[0] = 1 / atof(argv[arg++]);\n      aber[2] = 1 / atof(argv[arg++]);\n      break;\n    case 'g':\n      gamm[0] = atof(argv[arg++]);\n      gamm[1] = atof(argv[arg++]);\n      if (gamm[0])\n        gamm[0] = 1 / gamm[0];\n      break;\n    case 'k':\n      user_black = atoi(argv[arg++]);\n      break;\n    case 'S':\n      user_sat = atoi(argv[arg++]);\n      break;\n    case 't':\n      user_flip = atoi(argv[arg++]);\n      break;\n    case 'q':\n      user_qual = atoi(argv[arg++]);\n      break;\n    case 'm':\n      med_passes = atoi(argv[arg++]);\n      break;\n    case 'H':\n      highlight = atoi(argv[arg++]);\n      break;\n    case 's':\n      shot_select = abs(atoi(argv[arg]));\n      multi_out = !strcmp(argv[arg++], \"all\");\n      break;\n    case 'o':\n      if (isdigit(argv[arg][0]) && !argv[arg][1])\n        output_color = atoi(argv[arg++]);\n#ifndef NO_LCMS\n      else\n        out_profile = argv[arg++];\n      break;\n    case 'p':\n      cam_profile = argv[arg++];\n#endif\n      break;\n    case 'P':\n      bpfile = argv[arg++];\n      break;\n    case 'K':\n      dark_frame = argv[arg++];\n      break;\n    case 'z':\n      timestamp_only = 1;\n      break;\n    case 'e':\n      thumbnail_only = 1;\n      break;\n    case 'i':\n      identify_only = 1;\n      break;\n    case 'c':\n      write_to_stdout = 1;\n      break;\n    case 'v':\n      verbose = 1;\n      break;\n    case 'h':\n      half_size = 1;\n      break;\n    case 'f':\n      four_color_rgb = 1;\n      break;\n    case 'A':\n      FORC4 greybox[c] = atoi(argv[arg++]);\n    case 'a':\n      use_auto_wb = 1;\n      break;\n    case 'w':\n      use_camera_wb = 1;\n      break;\n    case 'M':\n      use_camera_matrix = 3 * (opm == '+');\n      break;\n    case 'I':\n      read_from_stdin = 1;\n      break;\n    case 'E':\n      document_mode++;\n    case 'D':\n      document_mode++;\n    case 'd':\n      document_mode++;\n    case 'j':\n      use_fuji_rotate = 0;\n      break;\n    case 'W':\n      no_auto_bright = 1;\n      break;\n    case 'T':\n      output_tiff = 1;\n      break;\n    case '4':\n      gamm[0] = gamm[1] = no_auto_bright = 1;\n    case '6':\n      output_bps = 16;\n      break;\n    default:\n      fprintf(stderr, _(\"Unknown option \\\"-%c\\\".\\n\"), opt);\n      return 1;\n    }\n  }\n  if (arg == argc)\n  {\n    fprintf(stderr, _(\"No files to process.\\n\"));\n    return 1;\n  }\n  if (write_to_stdout)\n  {\n    if (isatty(1))\n    {\n      fprintf(stderr, _(\"Will not write an image to the terminal!\\n\"));\n      return 1;\n    }\n#if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)\n    if (setmode(1, O_BINARY) < 0)\n    {\n      perror(\"setmode()\");\n      return 1;\n    }\n#endif\n  }\n  for (; arg < argc; arg++)\n  {\n    status = 1;\n    raw_image = 0;\n    image = 0;\n    oprof = 0;\n    meta_data = ofname = 0;\n    ofp = stdout;\n    if (setjmp(failure))\n    {\n      if (fileno(ifp) > 2)\n        fclose(ifp);\n      if (fileno(ofp) > 2)\n        fclose(ofp);\n      status = 1;\n      goto cleanup;\n    }\n    ifname = argv[arg];\n    if (!(ifp = fopen(ifname, \"rb\")))\n    {\n      perror(ifname);\n      continue;\n    }\n    status = (identify(), !is_raw);\n    if (user_flip >= 0)\n      flip = user_flip;\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n    }\n    if (timestamp_only)\n    {\n      if ((status = !timestamp))\n        fprintf(stderr, _(\"%s has no timestamp.\\n\"), ifname);\n      else if (identify_only)\n        printf(\"%10ld%10d %s\\n\", (long)timestamp, shot_order, ifname);\n      else\n      {\n        if (verbose)\n          fprintf(stderr, _(\"%s time set to %d.\\n\"), ifname, (int)timestamp);\n        ut.actime = ut.modtime = timestamp;\n        utime(ifname, &ut);\n      }\n      goto next;\n    }\n    write_fun = &CLASS write_ppm_tiff;\n    if (thumbnail_only)\n    {\n      if ((status = !thumb_offset))\n      {\n        fprintf(stderr, _(\"%s has no thumbnail.\\n\"), ifname);\n        goto next;\n      }\n      else if (thumb_load_raw)\n      {\n        load_raw = thumb_load_raw;\n        data_offset = thumb_offset;\n        height = thumb_height;\n        width = thumb_width;\n        filters = 0;\n        colors = 3;\n      }\n      else\n      {\n        fseek(ifp, thumb_offset, SEEK_SET);\n        write_fun = write_thumb;\n        goto thumbnail;\n      }\n    }\n    if (load_raw == &CLASS kodak_ycbcr_load_raw)\n    {\n      height += height & 1;\n      width += width & 1;\n    }\n\n    if (identify_only && verbose && make[0])\n    {\n      printf(_(\"\\nFilename: %s\\n\"), ifname);\n      printf(_(\"Timestamp: %s\"), ctime(&timestamp));\n      printf(_(\"Camera: %s %s\\n\"), make, model);\n      if (artist[0])\n        printf(_(\"Owner: %s\\n\"), artist);\n      if (dng_version)\n      {\n        printf(_(\"DNG Version: \"));\n        for (i = 24; i >= 0; i -= 8)\n          printf(\"%d%c\", dng_version >> i & 255, i ? '.' : '\\n');\n      }\n      printf(_(\"ISO speed: %d\\n\"), (int)iso_speed);\n      printf(_(\"Shutter: \"));\n      if (shutter > 0 && shutter < 1)\n        shutter = (printf(\"1/\"), 1 / shutter);\n      printf(_(\"%0.1f sec\\n\"), shutter);\n      printf(_(\"Aperture: f/%0.1f\\n\"), aperture);\n      printf(_(\"Focal length: %0.1f mm\\n\"), focal_len);\n      printf(_(\"Embedded ICC profile: %s\\n\"), profile_length ? _(\"yes\") : _(\"no\"));\n      printf(_(\"Number of raw images: %d\\n\"), is_raw);\n      if (pixel_aspect != 1)\n        printf(_(\"Pixel Aspect Ratio: %0.6f\\n\"), pixel_aspect);\n      if (thumb_offset)\n        printf(_(\"Thumb size:  %4d x %d\\n\"), thumb_width, thumb_height);\n      printf(_(\"Full size:   %4d x %d\\n\"), raw_width, raw_height);\n    }\n    else if (!is_raw)\n      fprintf(stderr, _(\"Cannot decode file %s\\n\"), ifname);\n    if (!is_raw)\n      goto next;\n    shrink = filters && (half_size || (!identify_only && (threshold || aber[0] != 1 || aber[2] != 1)));\n    iheight = (height + shrink) >> shrink;\n    iwidth = (width + shrink) >> shrink;\n    if (identify_only)\n    {\n      if (verbose)\n      {\n        if (document_mode == 3)\n        {\n          top_margin = left_margin = fuji_width = 0;\n          height = raw_height;\n          width = raw_width;\n        }\n        iheight = (height + shrink) >> shrink;\n        iwidth = (width + shrink) >> shrink;\n        if (use_fuji_rotate)\n        {\n          if (fuji_width)\n          {\n            fuji_width = (fuji_width - 1 + shrink) >> shrink;\n            iwidth = fuji_width / sqrt(0.5);\n            iheight = (iheight - fuji_width) / sqrt(0.5);\n          }\n          else\n          {\n            if (pixel_aspect < 1)\n              iheight = iheight / pixel_aspect + 0.5;\n            if (pixel_aspect > 1)\n              iwidth = iwidth * pixel_aspect + 0.5;\n          }\n        }\n        if (flip & 4)\n          SWAP(iheight, iwidth);\n        printf(_(\"Image size:  %4d x %d\\n\"), width, height);\n        printf(_(\"Output size: %4d x %d\\n\"), iwidth, iheight);\n        printf(_(\"Raw colors: %d\"), colors);\n        if (filters)\n        {\n          int fhigh = 2, fwide = 2;\n          if ((filters ^ (filters >> 8)) & 0xff)\n            fhigh = 4;\n          if ((filters ^ (filters >> 16)) & 0xffff)\n            fhigh = 8;\n          if (filters == 1)\n            fhigh = fwide = 16;\n          if (filters == 9)\n            fhigh = fwide = 6;\n          printf(_(\"\\nFilter pattern: \"));\n          for (i = 0; i < fhigh; i++)\n            for (c = i && putchar('/') && 0; c < fwide; c++)\n              putchar(cdesc[fcol(i, c)]);\n        }\n        printf(_(\"\\nDaylight multipliers:\"));\n        FORCC printf(\" %f\", pre_mul[c]);\n        if (cam_mul[0] > 0)\n        {\n          printf(_(\"\\nCamera multipliers:\"));\n          FORC4 printf(\" %f\", cam_mul[c]);\n        }\n        putchar('\\n');\n      }\n      else\n        printf(_(\"%s is a %s %s image.\\n\"), ifname, make, model);\n    next:\n      fclose(ifp);\n      continue;\n    }\n    if (meta_length)\n    {\n      meta_data = (char *)malloc(meta_length);\n      merror(meta_data, \"main()\");\n    }\n    if (filters || colors == 1)\n    {\n      raw_image = (ushort *)calloc((raw_height + 7), raw_width * 2);\n      merror(raw_image, \"main()\");\n    }\n    else\n    {\n      image = (ushort(*)[4])calloc(iheight, iwidth * sizeof *image);\n      merror(image, \"main()\");\n    }\n    if (verbose)\n      fprintf(stderr, _(\"Loading %s %s image from %s ...\\n\"), make, model, ifname);\n    if (shot_select >= is_raw)\n      fprintf(stderr, _(\"%s: \\\"-s %d\\\" requests a nonexistent image!\\n\"), ifname, shot_select);\n    fseeko(ifp, data_offset, SEEK_SET);\n    if (raw_image && read_from_stdin)\n      fread(raw_image, 2, raw_height * raw_width, stdin);\n    else\n      (*load_raw)();\n    if (document_mode == 3)\n    {\n      top_margin = left_margin = fuji_width = 0;\n      height = raw_height;\n      width = raw_width;\n    }\n    iheight = (height + shrink) >> shrink;\n    iwidth = (width + shrink) >> shrink;\n    if (raw_image)\n    {\n      image = (ushort(*)[4])calloc(iheight, iwidth * sizeof *image);\n      merror(image, \"main()\");\n      crop_masked_pixels();\n      free(raw_image);\n    }\n    if (zero_is_bad)\n      remove_zeroes();\n    bad_pixels(bpfile);\n    if (dark_frame)\n      subtract(dark_frame);\n    quality = 2 + !fuji_width;\n    if (user_qual >= 0)\n      quality = user_qual;\n    i = cblack[3];\n    FORC3 if (i > cblack[c]) i = cblack[c];\n    FORC4 cblack[c] -= i;\n    black += i;\n    i = cblack[6];\n    FORC(cblack[4] * cblack[5])\n    if (i > cblack[6 + c])\n      i = cblack[6 + c];\n    FORC(cblack[4] * cblack[5])\n    cblack[6 + c] -= i;\n    black += i;\n    if (user_black >= 0)\n      black = user_black;\n    FORC4 cblack[c] += black;\n    if (user_sat > 0)\n      maximum = user_sat;\n#ifdef COLORCHECK\n    colorcheck();\n#endif\n    if (is_foveon)\n    {\n      if (document_mode || load_raw == &CLASS foveon_dp_load_raw)\n      {\n        for (i = 0; i < height * width * 4; i++)\n          if ((short)image[0][i] < 0)\n            image[0][i] = 0;\n      }\n      else\n        foveon_interpolate();\n    }\n    else if (document_mode < 2)\n      scale_colors();\n    pre_interpolate();\n    if (filters && !document_mode)\n    {\n      if (quality == 0)\n        lin_interpolate();\n      else if (quality == 1 || colors > 3)\n        vng_interpolate();\n      else if (quality == 2 && filters > 1000)\n        ppg_interpolate();\n      else if (filters == 9)\n        xtrans_interpolate(quality * 2 - 3);\n      else\n        ahd_interpolate();\n    }\n    if (mix_green)\n      for (colors = 3, i = 0; i < height * width; i++)\n        image[i][1] = (image[i][1] + image[i][3]) >> 1;\n    if (!is_foveon && colors == 3)\n      median_filter();\n    if (!is_foveon && highlight == 2)\n      blend_highlights();\n    if (!is_foveon && highlight > 2)\n      recover_highlights();\n    if (use_fuji_rotate)\n      fuji_rotate();\n#ifndef NO_LCMS\n    if (cam_profile)\n      apply_profile(cam_profile, out_profile);\n#endif\n    convert_to_rgb();\n    if (use_fuji_rotate)\n      stretch();\n  thumbnail:\n    if (write_fun == &CLASS jpeg_thumb)\n      write_ext = \".jpg\";\n    else if (output_tiff && write_fun == &CLASS write_ppm_tiff)\n      write_ext = \".tiff\";\n    else\n      write_ext = \".pgm\\0.ppm\\0.ppm\\0.pam\" + colors * 5 - 5;\n    ofname = (char *)malloc(strlen(ifname) + 64);\n    merror(ofname, \"main()\");\n    if (write_to_stdout)\n      strcpy(ofname, _(\"standard output\"));\n    else\n    {\n      strcpy(ofname, ifname);\n      if ((cp = strrchr(ofname, '.')))\n        *cp = 0;\n      if (multi_out)\n        sprintf(ofname + strlen(ofname), \"_%0*d\", snprintf(0, 0, \"%d\", is_raw - 1), shot_select);\n      if (thumbnail_only)\n        strcat(ofname, \".thumb\");\n      strcat(ofname, write_ext);\n      ofp = fopen(ofname, \"wb\");\n      if (!ofp)\n      {\n        status = 1;\n        perror(ofname);\n        goto cleanup;\n      }\n    }\n    if (verbose)\n      fprintf(stderr, _(\"Writing data to %s ...\\n\"), ofname);\n    (*write_fun)();\n    fclose(ifp);\n    if (ofp != stdout)\n      fclose(ofp);\n  cleanup:\n    if (meta_data)\n      free(meta_data);\n    if (ofname)\n      free(ofname);\n    if (oprof)\n      free(oprof);\n    if (image)\n      free(image);\n    if (multi_out)\n    {\n      if (++shot_select < is_raw)\n        arg--;\n      else\n        shot_select = 0;\n    }\n  }\n  return status;\n}\n#endif\n", "/* \n  Copyright 2008-2016 LibRaw LLC (info@libraw.org)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n   This file is generated from Dave Coffin's dcraw.c\n   dcraw.c -- Dave Coffin's raw photo decoder\n   Copyright 1997-2010 by Dave Coffin, dcoffin a cybercom o net\n\n   Look into dcraw homepage (probably http://cybercom.net/~dcoffin/dcraw/)\n   for more information\n*/\n\n\n#include <math.h>\n#define CLASS LibRaw::\n#include \"libraw/libraw_types.h\"\n#define LIBRAW_LIBRARY_BUILD\n#define LIBRAW_IO_REDEFINED\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#include \"internal/var_defines.h\"\nint CLASS fcol(int row, int col)\n{\n  static const char filter[16][16] = {\n      {2, 1, 1, 3, 2, 3, 2, 0, 3, 2, 3, 0, 1, 2, 1, 0}, {0, 3, 0, 2, 0, 1, 3, 1, 0, 1, 1, 2, 0, 3, 3, 2},\n      {2, 3, 3, 2, 3, 1, 1, 3, 3, 1, 2, 1, 2, 0, 0, 3}, {0, 1, 0, 1, 0, 2, 0, 2, 2, 0, 3, 0, 1, 3, 2, 1},\n      {3, 1, 1, 2, 0, 1, 0, 2, 1, 3, 1, 3, 0, 1, 3, 0}, {2, 0, 0, 3, 3, 2, 3, 1, 2, 0, 2, 0, 3, 2, 2, 1},\n      {2, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 0, 0, 1}, {1, 0, 0, 2, 3, 0, 0, 3, 0, 3, 0, 3, 2, 1, 2, 3},\n      {2, 3, 3, 1, 1, 2, 1, 0, 3, 2, 3, 0, 2, 3, 1, 3}, {1, 0, 2, 0, 3, 0, 3, 2, 0, 1, 1, 2, 0, 1, 0, 2},\n      {0, 1, 1, 3, 3, 2, 2, 1, 1, 3, 3, 0, 2, 1, 3, 2}, {2, 3, 2, 0, 0, 1, 3, 0, 2, 0, 1, 2, 3, 0, 1, 0},\n      {1, 3, 1, 2, 3, 2, 3, 2, 0, 2, 0, 1, 1, 0, 3, 0}, {0, 2, 0, 3, 1, 0, 0, 1, 1, 3, 3, 2, 3, 2, 2, 1},\n      {2, 1, 3, 2, 3, 1, 2, 1, 0, 3, 0, 2, 0, 2, 0, 2}, {0, 3, 1, 0, 0, 2, 0, 3, 2, 1, 3, 1, 1, 3, 1, 3}};\n\n  if (filters == 1)\n    return filter[(row + top_margin) & 15][(col + left_margin) & 15];\n  if (filters == 9)\n    return xtrans[(row + 6) % 6][(col + 6) % 6];\n  return FC(row, col);\n}\nstatic size_t local_strnlen(const char *s, size_t n)\n{\n  const char *p = (const char *)memchr(s, 0, n);\n  return (p ? p - s : n);\n}\n/* add OS X version check here ?? */\n#define strnlen(a, b) local_strnlen(a, b)\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp)\n{\n  int r = fp->read(buf, len, 1);\n  buf[len - 1] = 0;\n  return r;\n}\n#define stmread(buf, maxlen, fp) stread(buf, MIN(maxlen, sizeof(buf)), fp)\n#endif\n\n#ifndef __GLIBC__\nchar *my_memmem(char *haystack, size_t haystacklen, char *needle, size_t needlelen)\n{\n  char *c;\n  for (c = haystack; c <= haystack + haystacklen - needlelen; c++)\n    if (!memcmp(c, needle, needlelen))\n      return c;\n  return 0;\n}\n#define memmem my_memmem\nchar *my_strcasestr(char *haystack, const char *needle)\n{\n  char *c;\n  for (c = haystack; *c; c++)\n    if (!strncasecmp(c, needle, strlen(needle)))\n      return c;\n  return 0;\n}\n#define strcasestr my_strcasestr\n#endif\n\n#define strbuflen(buf) strnlen(buf, sizeof(buf) - 1)\n\nushort CLASS sget2(uchar *s)\n{\n  if (order == 0x4949) /* \"II\" means little-endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian */\n    return s[0] << 8 | s[1];\n}\n\n// DNG was written by:\n#define CameraDNG 1\n#define AdobeDNG 2\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic int getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}\n\nstatic ushort saneSonyCameraInfo(uchar a, uchar b, uchar c, uchar d, uchar e, uchar f)\n{\n  if ((a >> 4) > 9)\n    return 0;\n  else if ((a & 0x0f) > 9)\n    return 0;\n  else if ((b >> 4) > 9)\n    return 0;\n  else if ((b & 0x0f) > 9)\n    return 0;\n  else if ((c >> 4) > 9)\n    return 0;\n  else if ((c & 0x0f) > 9)\n    return 0;\n  else if ((d >> 4) > 9)\n    return 0;\n  else if ((d & 0x0f) > 9)\n    return 0;\n  else if ((e >> 4) > 9)\n    return 0;\n  else if ((e & 0x0f) > 9)\n    return 0;\n  else if ((f >> 4) > 9)\n    return 0;\n  else if ((f & 0x0f) > 9)\n    return 0;\n  return 1;\n}\n\nstatic ushort bcd2dec(uchar data)\n{\n  if ((data >> 4) > 9)\n    return 0;\n  else if ((data & 0x0f) > 9)\n    return 0;\n  else\n    return (data >> 4) * 10 + (data & 0x0f);\n}\n\nstatic uchar SonySubstitution[257] =\n    \"\\x00\\x01\\x32\\xb1\\x0a\\x0e\\x87\\x28\\x02\\xcc\\xca\\xad\\x1b\\xdc\\x08\\xed\\x64\\x86\\xf0\\x4f\\x8c\\x6c\\xb8\\xcb\\x69\\xc4\\x2c\\x03\"\n    \"\\x97\\xb6\\x93\\x7c\\x14\\xf3\\xe2\\x3e\\x30\\x8e\\xd7\\x60\\x1c\\xa1\\xab\\x37\\xec\\x75\\xbe\\x23\\x15\\x6a\\x59\\x3f\\xd0\\xb9\\x96\\xb5\"\n    \"\\x50\\x27\\x88\\xe3\\x81\\x94\\xe0\\xc0\\x04\\x5c\\xc6\\xe8\\x5f\\x4b\\x70\\x38\\x9f\\x82\\x80\\x51\\x2b\\xc5\\x45\\x49\\x9b\\x21\\x52\\x53\"\n    \"\\x54\\x85\\x0b\\x5d\\x61\\xda\\x7b\\x55\\x26\\x24\\x07\\x6e\\x36\\x5b\\x47\\xb7\\xd9\\x4a\\xa2\\xdf\\xbf\\x12\\x25\\xbc\\x1e\\x7f\\x56\\xea\"\n    \"\\x10\\xe6\\xcf\\x67\\x4d\\x3c\\x91\\x83\\xe1\\x31\\xb3\\x6f\\xf4\\x05\\x8a\\x46\\xc8\\x18\\x76\\x68\\xbd\\xac\\x92\\x2a\\x13\\xe9\\x0f\\xa3\"\n    \"\\x7a\\xdb\\x3d\\xd4\\xe7\\x3a\\x1a\\x57\\xaf\\x20\\x42\\xb2\\x9e\\xc3\\x8b\\xf2\\xd5\\xd3\\xa4\\x7e\\x1f\\x98\\x9c\\xee\\x74\\xa5\\xa6\\xa7\"\n    \"\\xd8\\x5e\\xb0\\xb4\\x34\\xce\\xa8\\x79\\x77\\x5a\\xc1\\x89\\xae\\x9a\\x11\\x33\\x9d\\xf5\\x39\\x19\\x65\\x78\\x16\\x71\\xd2\\xa9\\x44\\x63\"\n    \"\\x40\\x29\\xba\\xa0\\x8f\\xe4\\xd6\\x3b\\x84\\x0d\\xc2\\x4e\\x58\\xdd\\x99\\x22\\x6b\\xc9\\xbb\\x17\\x06\\xe5\\x7d\\x66\\x43\\x62\\xf6\\xcd\"\n    \"\\x35\\x90\\x2e\\x41\\x8d\\x6d\\xaa\\x09\\x73\\x95\\x0c\\xf1\\x1d\\xde\\x4c\\x2f\\x2d\\xf7\\xd1\\x72\\xeb\\xef\\x48\\xc7\\xf8\\xf9\\xfa\\xfb\"\n    \"\\xfc\\xfd\\xfe\\xff\";\n\nushort CLASS sget2Rev(uchar *s) // specific to some Canon Makernotes fields, where they have endian in reverse\n{\n  if (order == 0x4d4d) /* \"II\" means little-endian, and we reverse to \"MM\" - big endian */\n    return s[0] | s[1] << 8;\n  else /* \"MM\" means big-endian... */\n    return s[0] << 8 | s[1];\n}\n#endif\n\nushort CLASS get2()\n{\n  uchar str[2] = {0xff, 0xff};\n  fread(str, 1, 2, ifp);\n  return sget2(str);\n}\n\nunsigned CLASS sget4(uchar *s)\n{\n  if (order == 0x4949)\n    return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;\n  else\n    return s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];\n}\n#define sget4(s) sget4((uchar *)s)\n\nunsigned CLASS get4()\n{\n  uchar str[4] = {0xff, 0xff, 0xff, 0xff};\n  fread(str, 1, 4, ifp);\n  return sget4(str);\n}\n\nunsigned CLASS getint(int type) { return type == 3 ? get2() : get4(); }\n\nfloat CLASS int_to_float(int i)\n{\n  union {\n    int i;\n    float f;\n  } u;\n  u.i = i;\n  return u.f;\n}\n\ndouble CLASS getreal(int type)\n{\n  union {\n    char c[8];\n    double d;\n  } u, v;\n  int i, rev;\n\n  switch (type)\n  {\n  case 3:\n    return (unsigned short)get2();\n  case 4:\n    return (unsigned int)get4();\n  case 5:\n    u.d = (unsigned int)get4();\n    v.d = (unsigned int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 8:\n    return (signed short)get2();\n  case 9:\n    return (signed int)get4();\n  case 10:\n    u.d = (signed int)get4();\n    v.d = (signed int)get4();\n    return u.d / (v.d ? v.d : 1);\n  case 11:\n    return int_to_float(get4());\n  case 12:\n    rev = 7 * ((order == 0x4949) == (ntohs(0x1234) == 0x1234));\n    for (i = 0; i < 8; i++)\n      u.c[i ^ rev] = fgetc(ifp);\n    return u.d;\n  default:\n    return fgetc(ifp);\n  }\n}\n\nvoid CLASS read_shorts(ushort *pixel, int count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}\n\nvoid CLASS cubic_spline(const int *x_, const int *y_, const int len)\n{\n  float **A, *b, *c, *d, *x, *y;\n  int i, j;\n\n  A = (float **)calloc(((2 * len + 4) * sizeof **A + sizeof *A), 2 * len);\n  if (!A)\n    return;\n  A[0] = (float *)(A + 2 * len);\n  for (i = 1; i < 2 * len; i++)\n    A[i] = A[0] + 2 * len * i;\n  y = len + (x = i + (d = i + (c = i + (b = A[0] + i * i))));\n  for (i = 0; i < len; i++)\n  {\n    x[i] = x_[i] / 65535.0;\n    y[i] = y_[i] / 65535.0;\n  }\n  for (i = len - 1; i > 0; i--)\n  {\n    b[i] = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);\n    d[i - 1] = x[i] - x[i - 1];\n  }\n  for (i = 1; i < len - 1; i++)\n  {\n    A[i][i] = 2 * (d[i - 1] + d[i]);\n    if (i > 1)\n    {\n      A[i][i - 1] = d[i - 1];\n      A[i - 1][i] = d[i - 1];\n    }\n    A[i][len - 1] = 6 * (b[i + 1] - b[i]);\n  }\n  for (i = 1; i < len - 2; i++)\n  {\n    float v = A[i + 1][i] / A[i][i];\n    for (j = 1; j <= len - 1; j++)\n      A[i + 1][j] -= v * A[i][j];\n  }\n  for (i = len - 2; i > 0; i--)\n  {\n    float acc = 0;\n    for (j = i; j <= len - 2; j++)\n      acc += A[i][j] * c[j];\n    c[i] = (A[i][len - 1] - acc) / A[i][i];\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    float x_out = (float)(i / 65535.0);\n    float y_out = 0;\n    for (j = 0; j < len - 1; j++)\n    {\n      if (x[j] <= x_out && x_out <= x[j + 1])\n      {\n        float v = x_out - x[j];\n        y_out = y[j] + ((y[j + 1] - y[j]) / d[j] - (2 * d[j] * c[j] + c[j + 1] * d[j]) / 6) * v + (c[j] * 0.5) * v * v +\n                ((c[j + 1] - c[j]) / (6 * d[j])) * v * v * v;\n      }\n    }\n    curve[i] = y_out < 0.0 ? 0 : (y_out >= 1.0 ? 65535 : (ushort)(y_out * 65535.0 + 0.5));\n  }\n  free(A);\n}\n\nvoid CLASS canon_600_fixed_wb(int temp)\n{\n  static const short mul[4][5] = {\n      {667, 358, 397, 565, 452}, {731, 390, 367, 499, 517}, {1119, 396, 348, 448, 537}, {1399, 485, 431, 508, 688}};\n  int lo, hi, i;\n  float frac = 0;\n\n  for (lo = 4; --lo;)\n    if (*mul[lo] <= temp)\n      break;\n  for (hi = 0; hi < 3; hi++)\n    if (*mul[hi] >= temp)\n      break;\n  if (lo != hi)\n    frac = (float)(temp - *mul[lo]) / (*mul[hi] - *mul[lo]);\n  for (i = 1; i < 5; i++)\n    pre_mul[i - 1] = 1 / (frac * mul[hi][i] + (1 - frac) * mul[lo][i]);\n}\n\n/* Return values:  0 = white  1 = near white  2 = not white */\nint CLASS canon_600_color(int ratio[2], int mar)\n{\n  int clipped = 0, target, miss;\n\n  if (flash_used)\n  {\n    if (ratio[1] < -104)\n    {\n      ratio[1] = -104;\n      clipped = 1;\n    }\n    if (ratio[1] > 12)\n    {\n      ratio[1] = 12;\n      clipped = 1;\n    }\n  }\n  else\n  {\n    if (ratio[1] < -264 || ratio[1] > 461)\n      return 2;\n    if (ratio[1] < -50)\n    {\n      ratio[1] = -50;\n      clipped = 1;\n    }\n    if (ratio[1] > 307)\n    {\n      ratio[1] = 307;\n      clipped = 1;\n    }\n  }\n  target = flash_used || ratio[1] < 197 ? -38 - (398 * ratio[1] >> 10) : -123 + (48 * ratio[1] >> 10);\n  if (target - mar <= ratio[0] && target + 20 >= ratio[0] && !clipped)\n    return 0;\n  miss = target - ratio[0];\n  if (abs(miss) >= mar * 4)\n    return 2;\n  if (miss < -20)\n    miss = -20;\n  if (miss > mar)\n    miss = mar;\n  ratio[0] = target - miss;\n  return 1;\n}\n\nvoid CLASS canon_600_auto_wb()\n{\n  int mar, row, col, i, j, st, count[] = {0, 0};\n  int test[8], total[2][8], ratio[2][2], stat[2];\n\n  memset(&total, 0, sizeof total);\n  i = canon_ev + 0.5;\n  if (i < 10)\n    mar = 150;\n  else if (i > 12)\n    mar = 20;\n  else\n    mar = 280 - 20 * i;\n  if (flash_used)\n    mar = 80;\n  for (row = 14; row < height - 14; row += 4)\n    for (col = 10; col < width; col += 2)\n    {\n      for (i = 0; i < 8; i++)\n        test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] = BAYER(row + (i >> 1), col + (i & 1));\n      for (i = 0; i < 8; i++)\n        if (test[i] < 150 || test[i] > 1500)\n          goto next;\n      for (i = 0; i < 4; i++)\n        if (abs(test[i] - test[i + 4]) > 50)\n          goto next;\n      for (i = 0; i < 2; i++)\n      {\n        for (j = 0; j < 4; j += 2)\n          ratio[i][j >> 1] = ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];\n        stat[i] = canon_600_color(ratio[i], mar);\n      }\n      if ((st = stat[0] | stat[1]) > 1)\n        goto next;\n      for (i = 0; i < 2; i++)\n        if (stat[i])\n          for (j = 0; j < 2; j++)\n            test[i * 4 + j * 2 + 1] = test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;\n      for (i = 0; i < 8; i++)\n        total[st][i] += test[i];\n      count[st]++;\n    next:;\n    }\n  if (count[0] | count[1])\n  {\n    st = count[0] * 200 < count[1];\n    for (i = 0; i < 4; i++)\n      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);\n  }\n}\n\nvoid CLASS canon_600_coeff()\n{\n  static const short table[6][12] = {{-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921, -3409},\n                                     {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},\n                                     {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},\n                                     {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},\n                                     {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};\n  int t = 0, i, c;\n  float mc, yc;\n\n  mc = pre_mul[1] / pre_mul[2];\n  yc = pre_mul[3] / pre_mul[2];\n  if (mc > 1 && mc <= 1.28 && yc < 0.8789)\n    t = 1;\n  if (mc > 1.28 && mc <= 2)\n  {\n    if (yc < 0.8789)\n      t = 3;\n    else if (yc <= 2)\n      t = 4;\n  }\n  if (flash_used)\n    t = 5;\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;\n}\n\nvoid CLASS canon_600_load_raw()\n{\n  uchar data[1120], *dp;\n  ushort *pix;\n  int irow, row;\n\n  for (irow = row = 0; irow < height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(data, 1, 1120, ifp) < 1120)\n      derror();\n    pix = raw_image + row * raw_width;\n    for (dp = data; dp < data + 1120; dp += 10, pix += 8)\n    {\n      pix[0] = (dp[0] << 2) + (dp[1] >> 6);\n      pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);\n      pix[2] = (dp[3] << 2) + (dp[1] >> 2 & 3);\n      pix[3] = (dp[4] << 2) + (dp[1] & 3);\n      pix[4] = (dp[5] << 2) + (dp[9] & 3);\n      pix[5] = (dp[6] << 2) + (dp[9] >> 2 & 3);\n      pix[6] = (dp[7] << 2) + (dp[9] >> 4 & 3);\n      pix[7] = (dp[8] << 2) + (dp[9] >> 6);\n    }\n    if ((row += 2) > height)\n      row = 1;\n  }\n}\n\nvoid CLASS canon_600_correct()\n{\n  int row, col, val;\n  static const short mul[4][2] = {{1141, 1145}, {1128, 1109}, {1178, 1149}, {1128, 1109}};\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n    {\n      if ((val = BAYER(row, col) - black) < 0)\n        val = 0;\n      val = val * mul[row & 3][col & 1] >> 9;\n      BAYER(row, col) = val;\n    }\n  }\n  canon_600_fixed_wb(1311);\n  canon_600_auto_wb();\n  canon_600_coeff();\n  maximum = (0x3ff - black) * 1109 >> 9;\n  black = 0;\n}\n\nint CLASS canon_s2is()\n{\n  unsigned row;\n\n  for (row = 0; row < 100; row++)\n  {\n    fseek(ifp, row * 3340 + 3284, SEEK_SET);\n    if (getc(ifp) > 15)\n      return 1;\n  }\n  return 0;\n}\n\nunsigned CLASS getbithuff(int nbits, ushort *huff)\n{\n#ifdef LIBRAW_NOTHREADS\n  static unsigned bitbuf = 0;\n  static int vbits = 0, reset = 0;\n#else\n#define bitbuf tls->getbits.bitbuf\n#define vbits tls->getbits.vbits\n#define reset tls->getbits.reset\n#endif\n  unsigned c;\n\n  if (nbits > 25)\n    return 0;\n  if (nbits < 0)\n    return bitbuf = vbits = reset = 0;\n  if (nbits == 0 || vbits < 0)\n    return 0;\n  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF && !(reset = zero_after_ff && c == 0xff && fgetc(ifp)))\n  {\n    bitbuf = (bitbuf << 8) + (uchar)c;\n    vbits += 8;\n  }\n  c = bitbuf << (32 - vbits) >> (32 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    c = (uchar)huff[c];\n  }\n  else\n    vbits -= nbits;\n  if (vbits < 0)\n    derror();\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#undef reset\n#endif\n}\n\n#define getbits(n) getbithuff(n, 0)\n#define gethuff(h) getbithuff(*h, h + 1)\n\n/*\n   Construct a decode tree according the specification in *source.\n   The first 16 bytes specify how many codes should be 1-bit, 2-bit\n   3-bit, etc.  Bytes after that are the leaf values.\n\n   For example, if the source is\n\n    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,\n      0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },\n\n   then the code is\n\n        00\t\t0x04\n        010\t\t0x03\n        011\t\t0x05\n        100\t\t0x06\n        101\t\t0x02\n        1100\t\t0x07\n        1101\t\t0x01\n        11100\t\t0x08\n        11101\t\t0x09\n        11110\t\t0x00\n        111110\t\t0x0a\n        1111110\t\t0x0b\n        1111111\t\t0xff\n */\nushort *CLASS make_decoder_ref(const uchar **source)\n{\n  int max, len, h, i, j;\n  const uchar *count;\n  ushort *huff;\n\n  count = (*source += 16) - 17;\n  for (max = 16; max && !count[max]; max--)\n    ;\n  huff = (ushort *)calloc(1 + (1 << max), sizeof *huff);\n  merror(huff, \"make_decoder()\");\n  huff[0] = max;\n  for (h = len = 1; len <= max; len++)\n    for (i = 0; i < count[len]; i++, ++*source)\n      for (j = 0; j < 1 << (max - len); j++)\n        if (h <= 1 << max)\n          huff[h++] = len << 8 | **source;\n  return huff;\n}\n\nushort *CLASS make_decoder(const uchar *source) { return make_decoder_ref(&source); }\n\nvoid CLASS crw_init_tables(unsigned table, ushort *huff[2])\n{\n  static const uchar first_tree[3][29] = {\n      {0, 1,    4,    2,    3,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x04, 0x03, 0x05, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x00, 0x0a, 0x0b, 0xff},\n      {0, 2,    2,    3,    1,    1,    1,    1,    2,    0,    0,    0,    0,    0,   0,\n       0, 0x03, 0x02, 0x04, 0x01, 0x05, 0x00, 0x06, 0x07, 0x09, 0x08, 0x0a, 0x0b, 0xff},\n      {0, 0,    6,    3,    1,    1,    2,    0,    0,    0,    0,    0,    0,    0,   0,\n       0, 0x06, 0x05, 0x07, 0x04, 0x08, 0x03, 0x09, 0x02, 0x00, 0x0a, 0x01, 0x0b, 0xff},\n  };\n  static const uchar second_tree[3][180] = {\n      {0,    2,    2,    2,    1,    4,    2,    1,    2,    5,    1,    1,    0,    0,    0,    139,  0x03, 0x04,\n       0x02, 0x05, 0x01, 0x06, 0x07, 0x08, 0x12, 0x13, 0x11, 0x14, 0x09, 0x15, 0x22, 0x00, 0x21, 0x16, 0x0a, 0xf0,\n       0x23, 0x17, 0x24, 0x31, 0x32, 0x18, 0x19, 0x33, 0x25, 0x41, 0x34, 0x42, 0x35, 0x51, 0x36, 0x37, 0x38, 0x29,\n       0x79, 0x26, 0x1a, 0x39, 0x56, 0x57, 0x28, 0x27, 0x52, 0x55, 0x58, 0x43, 0x76, 0x59, 0x77, 0x54, 0x61, 0xf9,\n       0x71, 0x78, 0x75, 0x96, 0x97, 0x49, 0xb7, 0x53, 0xd7, 0x74, 0xb6, 0x98, 0x47, 0x48, 0x95, 0x69, 0x99, 0x91,\n       0xfa, 0xb8, 0x68, 0xb5, 0xb9, 0xd6, 0xf7, 0xd8, 0x67, 0x46, 0x45, 0x94, 0x89, 0xf8, 0x81, 0xd5, 0xf6, 0xb4,\n       0x88, 0xb1, 0x2a, 0x44, 0x72, 0xd9, 0x87, 0x66, 0xd4, 0xf5, 0x3a, 0xa7, 0x73, 0xa9, 0xa8, 0x86, 0x62, 0xc7,\n       0x65, 0xc8, 0xc9, 0xa1, 0xf4, 0xd1, 0xe9, 0x5a, 0x92, 0x85, 0xa6, 0xe7, 0x93, 0xe8, 0xc1, 0xc6, 0x7a, 0x64,\n       0xe1, 0x4a, 0x6a, 0xe6, 0xb3, 0xf1, 0xd3, 0xa5, 0x8a, 0xb2, 0x9a, 0xba, 0x84, 0xa4, 0x63, 0xe5, 0xc5, 0xf3,\n       0xd2, 0xc4, 0x82, 0xaa, 0xda, 0xe4, 0xf2, 0xca, 0x83, 0xa3, 0xa2, 0xc3, 0xea, 0xc2, 0xe2, 0xe3, 0xff, 0xff},\n      {0,    2,    2,    1,    4,    1,    4,    1,    3,    3,    1,    0,    0,    0,    0,    140,  0x02, 0x03,\n       0x01, 0x04, 0x05, 0x12, 0x11, 0x06, 0x13, 0x07, 0x08, 0x14, 0x22, 0x09, 0x21, 0x00, 0x23, 0x15, 0x31, 0x32,\n       0x0a, 0x16, 0xf0, 0x24, 0x33, 0x41, 0x42, 0x19, 0x17, 0x25, 0x18, 0x51, 0x34, 0x43, 0x52, 0x29, 0x35, 0x61,\n       0x39, 0x71, 0x62, 0x36, 0x53, 0x26, 0x38, 0x1a, 0x37, 0x81, 0x27, 0x91, 0x79, 0x55, 0x45, 0x28, 0x72, 0x59,\n       0xa1, 0xb1, 0x44, 0x69, 0x54, 0x58, 0xd1, 0xfa, 0x57, 0xe1, 0xf1, 0xb9, 0x49, 0x47, 0x63, 0x6a, 0xf9, 0x56,\n       0x46, 0xa8, 0x2a, 0x4a, 0x78, 0x99, 0x3a, 0x75, 0x74, 0x86, 0x65, 0xc1, 0x76, 0xb6, 0x96, 0xd6, 0x89, 0x85,\n       0xc9, 0xf5, 0x95, 0xb4, 0xc7, 0xf7, 0x8a, 0x97, 0xb8, 0x73, 0xb7, 0xd8, 0xd9, 0x87, 0xa7, 0x7a, 0x48, 0x82,\n       0x84, 0xea, 0xf4, 0xa6, 0xc5, 0x5a, 0x94, 0xa4, 0xc6, 0x92, 0xc3, 0x68, 0xb5, 0xc8, 0xe4, 0xe5, 0xe6, 0xe9,\n       0xa2, 0xa3, 0xe3, 0xc2, 0x66, 0x67, 0x93, 0xaa, 0xd4, 0xd5, 0xe7, 0xf8, 0x88, 0x9a, 0xd7, 0x77, 0xc4, 0x64,\n       0xe2, 0x98, 0xa5, 0xca, 0xda, 0xe8, 0xf3, 0xf6, 0xa9, 0xb2, 0xb3, 0xf2, 0xd2, 0x83, 0xba, 0xd3, 0xff, 0xff},\n      {0,    0,    6,    2,    1,    3,    3,    2,    5,    1,    2,    2,    8,    10,   0,    117,  0x04, 0x05,\n       0x03, 0x06, 0x02, 0x07, 0x01, 0x08, 0x09, 0x12, 0x13, 0x14, 0x11, 0x15, 0x0a, 0x16, 0x17, 0xf0, 0x00, 0x22,\n       0x21, 0x18, 0x23, 0x19, 0x24, 0x32, 0x31, 0x25, 0x33, 0x38, 0x37, 0x34, 0x35, 0x36, 0x39, 0x79, 0x57, 0x58,\n       0x59, 0x28, 0x56, 0x78, 0x27, 0x41, 0x29, 0x77, 0x26, 0x42, 0x76, 0x99, 0x1a, 0x55, 0x98, 0x97, 0xf9, 0x48,\n       0x54, 0x96, 0x89, 0x47, 0xb7, 0x49, 0xfa, 0x75, 0x68, 0xb6, 0x67, 0x69, 0xb9, 0xb8, 0xd8, 0x52, 0xd7, 0x88,\n       0xb5, 0x74, 0x51, 0x46, 0xd9, 0xf8, 0x3a, 0xd6, 0x87, 0x45, 0x7a, 0x95, 0xd5, 0xf6, 0x86, 0xb4, 0xa9, 0x94,\n       0x53, 0x2a, 0xa8, 0x43, 0xf5, 0xf7, 0xd4, 0x66, 0xa7, 0x5a, 0x44, 0x8a, 0xc9, 0xe8, 0xc8, 0xe7, 0x9a, 0x6a,\n       0x73, 0x4a, 0x61, 0xc7, 0xf4, 0xc6, 0x65, 0xe9, 0x72, 0xe6, 0x71, 0x91, 0x93, 0xa6, 0xda, 0x92, 0x85, 0x62,\n       0xf3, 0xc5, 0xb2, 0xa4, 0x84, 0xba, 0x64, 0xa5, 0xb3, 0xd2, 0x81, 0xe5, 0xd3, 0xaa, 0xc4, 0xca, 0xf2, 0xb1,\n       0xe4, 0xd1, 0x83, 0x63, 0xea, 0xc3, 0xe2, 0x82, 0xf1, 0xa3, 0xc2, 0xa1, 0xc1, 0xe3, 0xa2, 0xe1, 0xff, 0xff}};\n  if (table > 2)\n    table = 2;\n  huff[0] = make_decoder(first_tree[table]);\n  huff[1] = make_decoder(second_tree[table]);\n}\n\n/*\n   Return 0 if the image starts with compressed data,\n   1 if it starts with uncompressed low-order bits.\n\n   In Canon compressed data, 0xff is always followed by 0x00.\n */\nint CLASS canon_has_lowbits()\n{\n  uchar test[0x4000];\n  int ret = 1, i;\n\n  fseek(ifp, 0, SEEK_SET);\n  fread(test, 1, sizeof test, ifp);\n  for (i = 540; i < sizeof test - 1; i++)\n    if (test[i] == 0xff)\n    {\n      if (test[i + 1])\n        return 1;\n      ret = 0;\n    }\n  return ret;\n}\n\nvoid CLASS canon_load_raw()\n{\n  ushort *pixel, *prow, *huff[2];\n  int nblocks, lowbits, i, c, row, r, save, val;\n  int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];\n\n  crw_init_tables(tiff_compress, huff);\n  lowbits = canon_has_lowbits();\n  if (!lowbits)\n    maximum = 0x3ff;\n  fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);\n  zero_after_ff = 1;\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row += 8)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pixel = raw_image + row * raw_width;\n      nblocks = MIN(8, raw_height - row) * raw_width >> 6;\n      for (block = 0; block < nblocks; block++)\n      {\n        memset(diffbuf, 0, sizeof diffbuf);\n        for (i = 0; i < 64; i++)\n        {\n          leaf = gethuff(huff[i > 0]);\n          if (leaf == 0 && i)\n            break;\n          if (leaf == 0xff)\n            continue;\n          i += leaf >> 4;\n          len = leaf & 15;\n          if (len == 0)\n            continue;\n          diff = getbits(len);\n          if ((diff & (1 << (len - 1))) == 0)\n            diff -= (1 << len) - 1;\n          if (i < 64)\n            diffbuf[i] = diff;\n        }\n        diffbuf[0] += carry;\n        carry = diffbuf[0];\n        for (i = 0; i < 64; i++)\n        {\n          if (pnum++ % raw_width == 0)\n            base[0] = base[1] = 512;\n          if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)\n            derror();\n        }\n      }\n      if (lowbits)\n      {\n        save = ftell(ifp);\n        fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);\n        for (prow = pixel, i = 0; i < raw_width * 2; i++)\n        {\n          c = fgetc(ifp);\n          for (r = 0; r < 8; r += 2, prow++)\n          {\n            val = (*prow << 2) + ((c >> r) & 3);\n            if (raw_width == 2672 && val < 512)\n              val += 2;\n            *prow = val;\n          }\n        }\n        fseek(ifp, save, SEEK_SET);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    FORC(2) free(huff[c]);\n    throw;\n  }\n#endif\n  FORC(2) free(huff[c]);\n}\n\nint CLASS ljpeg_start(struct jhead *jh, int info_only)\n{\n  ushort c, tag, len;\n  int cnt = 0;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset(jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n    return 0;\n  do\n  {\n    if (feof(ifp))\n      return 0;\n    if (cnt++ > 1024)\n      return 0; // 1024 tags limit\n    if (!fread(data, 2, 2, ifp))\n      return 0;\n    tag = data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00)\n      return 0;\n    fread(data, 1, len, ifp);\n    switch (tag)\n    {\n    case 0xffc3: // start of frame; lossless, Huffman\n      jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n    case 0xffc1:\n    case 0xffc0:\n      jh->algo = tag & 0xff;\n      jh->bits = data[0];\n      jh->high = data[1] << 8 | data[2];\n      jh->wide = data[3] << 8 | data[4];\n      jh->clrs = data[5] + jh->sraw;\n      if (len == 9 && !dng_version)\n        getc(ifp);\n      break;\n    case 0xffc4: // define Huffman tables\n      if (info_only)\n        break;\n      for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n        jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n      break;\n    case 0xffda: // start of scan\n      jh->psv = data[1 + data[0] * 2];\n      jh->bits -= data[3 + data[0] * 2] & 15;\n      break;\n    case 0xffdb:\n      FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n      break;\n    case 0xffdd:\n      jh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs)\n    return 0;\n  if (info_only)\n    return 1;\n  if (!jh->huff[0])\n    return 0;\n  FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n  if (jh->sraw)\n  {\n    FORC(4) jh->huff[2 + c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n  }\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n  merror(jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}\n\nvoid CLASS ljpeg_end(struct jhead *jh)\n{\n  int c;\n  FORC4 if (jh->free[c]) free(jh->free[c]);\n  free(jh->row);\n}\n\nint CLASS ljpeg_diff(ushort *huff)\n{\n  int len, diff;\n  if (!huff)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len - 1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}\n\nushort *CLASS ljpeg_row(int jrow, struct jhead *jh)\n{\n  int col, c, diff, pred, spred = 0;\n  ushort mark = 0, *row[3];\n\n  if (jrow * jh->wide % jh->restart == 0)\n  {\n    FORC(6) jh->vpred[c] = 1 << (jh->bits - 1);\n    if (jrow)\n    {\n      fseek(ifp, -2, SEEK_CUR);\n      do\n        mark = (mark << 8) + (c = fgetc(ifp));\n      while (c != EOF && mark >> 4 != 0xffd);\n    }\n    getbits(-1);\n  }\n  FORC3 row[c] = jh->row + jh->wide * jh->clrs * ((jrow + c) & 1);\n  for (col = 0; col < jh->wide; col++)\n    FORC(jh->clrs)\n    {\n      diff = ljpeg_diff(jh->huff[c]);\n      if (jh->sraw && c <= jh->sraw && (col | c))\n        pred = spred;\n      else if (col)\n        pred = row[0][-jh->clrs];\n      else\n        pred = (jh->vpred[c] += diff) - diff;\n      if (jrow && col)\n        switch (jh->psv)\n        {\n        case 1:\n          break;\n        case 2:\n          pred = row[1][0];\n          break;\n        case 3:\n          pred = row[1][-jh->clrs];\n          break;\n        case 4:\n          pred = pred + row[1][0] - row[1][-jh->clrs];\n          break;\n        case 5:\n          pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);\n          break;\n        case 6:\n          pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);\n          break;\n        case 7:\n          pred = (pred + row[1][0]) >> 1;\n          break;\n        default:\n          pred = 0;\n        }\n      if ((**row = pred + diff) >> jh->bits)\n        derror();\n      if (c <= jh->sraw)\n        spred = **row;\n      row[0]++;\n      row[1]++;\n    }\n  return row[2];\n}\n\nvoid CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jhigh, jrow, jcol, val, jidx, i, j, row = 0, col = 0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n\n  if (jh.wide < 1 || jh.high < 1 || jh.clrs < 1 || jh.bits < 1)\n#ifdef LIBRAW_LIBRARY_BUILD\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n    longjmp(failure, 2);\n#endif\n  jwide = jh.wide * jh.clrs;\n  jhigh = jh.high;\n  if (jh.clrs == 4 && jwide >= raw_width * 2)\n    jhigh *= 2;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (jrow = 0; jrow < jh.high; jrow++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      rp = ljpeg_row(jrow, &jh);\n      if (load_flags & 1)\n        row = jrow & 1 ? height - 1 - jrow / 2 : jrow / 2;\n      for (jcol = 0; jcol < jwide; jcol++)\n      {\n        val = curve[*rp++];\n        if (cr2_slice[0])\n        {\n          jidx = jrow * jwide + jcol;\n          i = jidx / (cr2_slice[1] * raw_height);\n          if ((j = i >= cr2_slice[0]))\n            i = cr2_slice[0];\n          jidx -= i * (cr2_slice[1] * raw_height);\n          row = jidx / cr2_slice[1 + j];\n          col = jidx % cr2_slice[1 + j] + i * cr2_slice[1];\n        }\n        if (raw_width == 3984 && (col -= 2) < 0)\n          col += (row--, raw_width);\n        if (row > raw_height)\n#ifdef LIBRAW_LIBRARY_BUILD\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#else\n        longjmp(failure, 3);\n#endif\n        if ((unsigned)row < raw_height)\n          RAW(row, col) = val;\n        if (++col >= raw_width)\n          col = (row++, 0);\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  ljpeg_end(&jh);\n}\n\nvoid CLASS canon_sraw_load_raw()\n{\n  struct jhead jh;\n  short *rp = 0, (*ip)[4];\n  int jwide, slice, scol, ecol, row, col, jrow = 0, jcol = 0, pix[3], c;\n  int v[3] = {0, 0, 0}, ver, hue;\n#ifdef LIBRAW_LIBRARY_BUILD\n  int saved_w = width, saved_h = height;\n#endif\n  char *cp;\n\n  if (!ljpeg_start(&jh, 0) || jh.clrs < 4)\n    return;\n  jwide = (jh.wide >>= 1) * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_flags & 256)\n  {\n    width = raw_width;\n    height = raw_height;\n  }\n\n  try\n  {\n#endif\n    for (ecol = slice = 0; slice <= cr2_slice[0]; slice++)\n    {\n      scol = ecol;\n      ecol += cr2_slice[1] * 2 / jh.clrs;\n      if (!cr2_slice[0] || ecol > raw_width - 1)\n        ecol = raw_width & -2;\n      for (row = 0; row < height; row += (jh.clrs >> 1) - 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        ip = (short(*)[4])image + row * width;\n        for (col = scol; col < ecol; col += 2, jcol += jh.clrs)\n        {\n          if ((jcol %= jwide) == 0)\n            rp = (short *)ljpeg_row(jrow++, &jh);\n          if (col >= width)\n            continue;\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n          {\n            FORC(jh.clrs - 2)\n            {\n              ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n              ip[col + (c >> 1) * width + (c & 1)][1] = ip[col + (c >> 1) * width + (c & 1)][2] = 8192;\n            }\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 8192;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 8192;\n          }\n          else\n#endif\n          {\n            FORC(jh.clrs - 2)\n            ip[col + (c >> 1) * width + (c & 1)][0] = rp[jcol + c];\n            ip[col][1] = rp[jcol + jh.clrs - 2] - 16384;\n            ip[col][2] = rp[jcol + jh.clrs - 1] - 16384;\n          }\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n  {\n    ljpeg_end(&jh);\n    maximum = 0x3fff;\n    height = saved_h;\n    width = saved_w;\n    return;\n  }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (cp = model2; *cp && !isdigit(*cp); cp++)\n      ;\n    sscanf(cp, \"%d.%d.%d\", v, v + 1, v + 2);\n    ver = (v[0] * 1000 + v[1]) * 1000 + v[2];\n    hue = (jh.sraw + 1) << 2;\n    if (unique_id >= 0x80000281 || (unique_id == 0x80000218 && ver > 1000006))\n      hue = jh.sraw << 1;\n    ip = (short(*)[4])image;\n    rp = ip[0];\n    for (row = 0; row < height; row++, ip += width)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (row & (jh.sraw >> 1))\n      {\n        for (col = 0; col < width; col += 2)\n          for (c = 1; c < 3; c++)\n            if (row == height - 1)\n            {\n              ip[col][c] = ip[col - width][c];\n            }\n            else\n            {\n              ip[col][c] = (ip[col - width][c] + ip[col + width][c] + 1) >> 1;\n            }\n      }\n      for (col = 1; col < width; col += 2)\n        for (c = 1; c < 3; c++)\n          if (col == width - 1)\n            ip[col][c] = ip[col - 1][c];\n          else\n            ip[col][c] = (ip[col - 1][c] + ip[col + 1][c] + 1) >> 1;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB))\n#endif\n      for (; rp < ip[0]; rp += 4)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        if (unique_id == 0x80000218 || unique_id == 0x80000250 || unique_id == 0x80000261 || unique_id == 0x80000281 ||\n            unique_id == 0x80000287)\n        {\n          rp[1] = (rp[1] << 2) + hue;\n          rp[2] = (rp[2] << 2) + hue;\n          pix[0] = rp[0] + ((50 * rp[1] + 22929 * rp[2]) >> 14);\n          pix[1] = rp[0] + ((-5640 * rp[1] - 11751 * rp[2]) >> 14);\n          pix[2] = rp[0] + ((29040 * rp[1] - 101 * rp[2]) >> 14);\n        }\n        else\n        {\n          if (unique_id < 0x80000218)\n            rp[0] -= 512;\n          pix[0] = rp[0] + rp[2];\n          pix[2] = rp[0] + rp[1];\n          pix[1] = rp[0] + ((-778 * rp[1] - (rp[2] << 11)) >> 12);\n        }\n        FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    ljpeg_end(&jh);\n    throw;\n  }\n  height = saved_h;\n  width = saved_w;\n#endif\n  ljpeg_end(&jh);\n  maximum = 0x3fff;\n}\n\nvoid CLASS adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)\n{\n  int c;\n\n  if (tiff_samples == 2 && shot_select)\n    (*rp)++;\n  if (raw_image)\n  {\n    if (row < raw_height && col < raw_width)\n      RAW(row, col) = curve[**rp];\n    *rp += tiff_samples;\n  }\n  else\n  {\n    if (row < height && col < width)\n      FORC(tiff_samples)\n    image[row * width + col][c] = curve[(*rp)[c]];\n    *rp += tiff_samples;\n  }\n  if (tiff_samples == 2 && shot_select)\n    (*rp)--;\n}\n\nvoid CLASS ljpeg_idct(struct jhead *jh)\n{\n  int c, i, j, len, skip, coef;\n  float work[3][8][8];\n  static float cs[106] = {0};\n  static const uchar zigzag[80] = {0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33,\n                                   40, 48, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36,\n                                   29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n                                   47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63};\n\n  if (!cs[0])\n    FORC(106) cs[c] = cos((c & 31) * M_PI / 16) / 2;\n  memset(work, 0, sizeof work);\n  work[0][0][0] = jh->vpred[0] += ljpeg_diff(jh->huff[0]) * jh->quant[0];\n  for (i = 1; i < 64; i++)\n  {\n    len = gethuff(jh->huff[16]);\n    i += skip = len >> 4;\n    if (!(len &= 15) && skip < 15)\n      break;\n    coef = getbits(len);\n    if ((coef & (1 << (len - 1))) == 0)\n      coef -= (1 << len) - 1;\n    ((float *)work)[zigzag[i]] = coef * jh->quant[i];\n  }\n  FORC(8) work[0][0][c] *= M_SQRT1_2;\n  FORC(8) work[0][c][0] *= M_SQRT1_2;\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[1][i][j] += work[0][i][c] * cs[(j * 2 + 1) * c];\n  for (i = 0; i < 8; i++)\n    for (j = 0; j < 8; j++)\n      FORC(8) work[2][i][j] += work[1][c][j] * cs[(i * 2 + 1) * c];\n\n  FORC(64) jh->idct[c] = CLIP(((float *)work[2])[c] + 0.5);\n}\n\nvoid CLASS lossless_dng_load_raw()\n{\n  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;\n  struct jhead jh;\n  ushort *rp;\n\n  while (trow < raw_height)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    save = ftell(ifp);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n    if (!ljpeg_start(&jh, 0))\n      break;\n    jwide = jh.wide;\n    if (filters)\n      jwide *= jh.clrs;\n    jwide /= MIN(is_raw, tiff_samples);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      switch (jh.algo)\n      {\n      case 0xc1:\n        jh.vpred[0] = 16384;\n        getbits(-1);\n        for (jrow = 0; jrow + 7 < jh.high; jrow += 8)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (jcol = 0; jcol + 7 < jh.wide; jcol += 8)\n          {\n            ljpeg_idct(&jh);\n            rp = jh.idct;\n            row = trow + jcol / tile_width + jrow * 2;\n            col = tcol + jcol % tile_width;\n            for (i = 0; i < 16; i += 2)\n              for (j = 0; j < 8; j++)\n                adobe_copy_pixel(row + i, col + j, &rp);\n          }\n        }\n        break;\n      case 0xc3:\n        for (row = col = jrow = 0; jrow < jh.high; jrow++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          rp = ljpeg_row(jrow, &jh);\n          for (jcol = 0; jcol < jwide; jcol++)\n          {\n            adobe_copy_pixel(trow + row, tcol + col, &rp);\n            if (++col >= tile_width || col >= raw_width)\n              row += 1 + (col = 0);\n          }\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      ljpeg_end(&jh);\n      throw;\n    }\n#endif\n    fseek(ifp, save + 4, SEEK_SET);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n    ljpeg_end(&jh);\n  }\n}\n\nvoid CLASS packed_dng_load_raw()\n{\n  ushort *pixel, *rp;\n  int row, col;\n\n  pixel = (ushort *)calloc(raw_width, tiff_samples * sizeof *pixel);\n  merror(pixel, \"packed_dng_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (tiff_bps == 16)\n        read_shorts(pixel, raw_width * tiff_samples);\n      else\n      {\n        getbits(-1);\n        for (col = 0; col < raw_width * tiff_samples; col++)\n          pixel[col] = getbits(tiff_bps);\n      }\n      for (rp = pixel, col = 0; col < raw_width; col++)\n        adobe_copy_pixel(row, col, &rp);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n}\n\nvoid CLASS pentax_load_raw()\n{\n  ushort bit[2][15], huff[4097];\n  int dep, row, col, diff, c, i;\n  ushort vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  dep = (get2() + 12) & 15;\n  fseek(ifp, 12, SEEK_CUR);\n  FORC(dep) bit[0][c] = get2();\n  FORC(dep) bit[1][c] = fgetc(ifp);\n  FORC(dep)\n  for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)\n    huff[++i] = bit[1][c] << 8 | c;\n  huff[0] = 12;\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS nikon_coolscan_load_raw()\n{\n  int bufsize = width * 3 * tiff_bps / 8;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  for (int row = 0; row < raw_height; row++)\n  {\n    int red = fread(buf, 1, bufsize, ifp);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (tiff_bps <= 8)\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    else\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n  }\n  free(buf);\n}\n#endif\n\nvoid CLASS nikon_load_raw()\n{\n  static const uchar nikon_tree[][32] = {\n      {0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0,  0,  0, 0, 0, 0, /* 12-bit lossy */\n       5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12},\n      {0,    1,    5,    1,    1,    1, 1, 1, 1, 2, 0, 0,  0,  0, 0, 0, /* 12-bit lossy after split */\n       0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12},\n      {0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0,  0,  0, 0, 0, 0, /* 12-bit lossless */\n       5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12},\n      {0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0,  0,  0,  0,  0, 0, /* 14-bit lossy */\n       5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14},\n      {0, 1,    5,    1,    1,    1, 1, 1, 1, 1, 2, 0, 0, 0,  0, 0, /* 14-bit lossy after split */\n       8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14},\n      {0, 1, 4, 2, 2, 3, 1,  2, 0,  0,  0, 0, 0, 0,  0, 0, /* 14-bit lossless */\n       7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14}};\n  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;\n  int i, min, max, step = 0, tree = 0, split = 0, row, col, len, shl, diff;\n\n  fseek(ifp, meta_offset, SEEK_SET);\n  ver0 = fgetc(ifp);\n  ver1 = fgetc(ifp);\n  if (ver0 == 0x49 || ver1 == 0x58)\n    fseek(ifp, 2110, SEEK_CUR);\n  if (ver0 == 0x46)\n    tree = 2;\n  if (tiff_bps == 14)\n    tree += 3;\n  read_shorts(vpred[0], 4);\n  max = 1 << tiff_bps & 0x7fff;\n  if ((csize = get2()) > 1)\n    step = max / (csize - 1);\n  if (ver0 == 0x44 && ver1 == 0x20 && step > 0)\n  {\n    for (i = 0; i < csize; i++)\n      curve[i * step] = get2();\n    for (i = 0; i < max; i++)\n      curve[i] = (curve[i - i % step] * (step - i % step) + curve[i - i % step + step] * (i % step)) / step;\n    fseek(ifp, meta_offset + 562, SEEK_SET);\n    split = get2();\n  }\n  else if (ver0 != 0x46 && csize <= 0x4001)\n    read_shorts(curve, max = csize);\n  while (curve[max - 2] == curve[max - 1])\n    max--;\n  huff = make_decoder(nikon_tree[tree]);\n  fseek(ifp, data_offset, SEEK_SET);\n  getbits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (min = row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (split && row == split)\n      {\n        free(huff);\n        huff = make_decoder(nikon_tree[tree + 1]);\n        max += (min = 16) << 1;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        i = gethuff(huff);\n        len = i & 15;\n        shl = i >> 4;\n        diff = ((getbits(len - shl) << 1) + 1) << shl >> 1;\n        if ((diff & (1 << (len - 1))) == 0)\n          diff -= (1 << len) - !shl;\n        if (col < 2)\n          hpred[col] = vpred[row & 1][col] += diff;\n        else\n          hpred[col & 1] += diff;\n        if ((ushort)(hpred[col & 1] + min) >= max)\n          derror();\n        RAW(row, col) = curve[LIM((short)hpred[col & 1], 0, 0x3fff)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(huff);\n    throw;\n  }\n#endif\n  free(huff);\n}\n\nvoid CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf = 0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n\n    for (col = 0; col < raw_width; col++)\n    {\n      if (!(b = col & 1))\n      {\n        bitbuf = 0;\n        FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;\n        FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);\n      }\n      rgb[0] = yuv[b] + 1.370705 * yuv[3];\n      rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];\n      rgb[2] = yuv[b] + 1.732446 * yuv[2];\n      FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];\n    }\n  }\n}\n\n/*\n   Returns 1 for a Coolpix 995, 0 for anything else.\n */\nint CLASS nikon_e995()\n{\n  int i, histo[256];\n  const uchar often[] = {0x00, 0x55, 0xaa, 0xff};\n\n  memset(histo, 0, sizeof histo);\n  fseek(ifp, -2000, SEEK_END);\n  for (i = 0; i < 2000; i++)\n    histo[fgetc(ifp)]++;\n  for (i = 0; i < 4; i++)\n    if (histo[often[i]] < 200)\n      return 0;\n  return 1;\n}\n\n/*\n   Returns 1 for a Coolpix 2100, 0 for anything else.\n */\nint CLASS nikon_e2100()\n{\n  uchar t[12];\n  int i;\n\n  fseek(ifp, 0, SEEK_SET);\n  for (i = 0; i < 1024; i++)\n  {\n    fread(t, 1, 12, ifp);\n    if (((t[2] & t[4] & t[7] & t[9]) >> 4 & t[1] & t[6] & t[8] & t[11] & 3) != 3)\n      return 0;\n  }\n  return 1;\n}\n\nvoid CLASS nikon_3700()\n{\n  int bits, i;\n  uchar dp[24];\n  static const struct\n  {\n    int bits;\n    char t_make[12], t_model[15];\n  } table[] = {\n      {0x00, \"Pentax\", \"Optio 33WR\"}, {0x03, \"Nikon\", \"E3200\"}, {0x32, \"Nikon\", \"E3700\"}, {0x33, \"Olympus\", \"C740UZ\"}};\n\n  fseek(ifp, 3072, SEEK_SET);\n  fread(dp, 1, 24, ifp);\n  bits = (dp[8] & 3) << 4 | (dp[20] & 3);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (bits == table[i].bits)\n    {\n      strcpy(make, table[i].t_make);\n      strcpy(model, table[i].t_model);\n    }\n}\n\n/*\n   Separates a Minolta DiMAGE Z2 from a Nikon E4300.\n */\nint CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}\nvoid CLASS ppm_thumb()\n{\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"ppm_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fread(thumb, 1, thumb_length, ifp);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}\n\nvoid CLASS layer_thumb()\n{\n  int i, c;\n  char *thumb, map[][4] = {\"012\", \"102\"};\n\n  colors = thumb_misc >> 5 & 7;\n  thumb_length = thumb_width * thumb_height;\n  thumb = (char *)calloc(colors, thumb_length);\n  merror(thumb, \"layer_thumb()\");\n  fprintf(ofp, \"P%d\\n%d %d\\n255\\n\", 5 + (colors >> 1), thumb_width, thumb_height);\n  fread(thumb, thumb_length, colors, ifp);\n  for (i = 0; i < thumb_length; i++)\n    FORCC putc(thumb[i + thumb_length * (map[thumb_misc >> 8][c] - '0')], ofp);\n  free(thumb);\n}\n\nvoid CLASS rollei_thumb()\n{\n  unsigned i;\n  ushort *thumb;\n\n  thumb_length = thumb_width * thumb_height;\n  thumb = (ushort *)calloc(thumb_length, 2);\n  merror(thumb, \"rollei_thumb()\");\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  read_shorts(thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n  {\n    putc(thumb[i] << 3, ofp);\n    putc(thumb[i] >> 5 << 2, ofp);\n    putc(thumb[i] >> 11 << 3, ofp);\n  }\n  free(thumb);\n}\n\nvoid CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n\n  isix = raw_width * raw_height * 5 / 8;\n  while (fread(pixel, 1, 10, ifp) == 10)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i = 0; i < 10; i += 2)\n    {\n      todo[i] = iten++;\n      todo[i + 1] = pixel[i] << 8 | pixel[i + 1];\n      buffer = pixel[i] >> 2 | buffer << 6;\n    }\n    for (; i < 16; i += 2)\n    {\n      todo[i] = isix++;\n      todo[i + 1] = buffer >> (14 - i) * 5;\n    }\n    for (i = 0; i < 16; i += 2)\n      raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n  }\n  maximum = 0x3ff;\n}\n\nint CLASS raw(unsigned row, unsigned col) { return (row < raw_height && col < raw_width) ? RAW(row, col) : 0; }\n\nvoid CLASS phase_one_flat_field(int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, high, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts(head, 8);\n  if (head[2] * head[3] * head[4] * head[5] == 0)\n    return;\n  wide = head[2] / head[4] + (head[2] % head[4] != 0);\n  high = head[3] / head[5] + (head[3] % head[5] != 0);\n  mrow = (float *)calloc(nc * wide, sizeof *mrow);\n  merror(mrow, \"phase_one_flat_field()\");\n  for (y = 0; y < high; y++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (x = 0; x < wide; x++)\n      for (c = 0; c < nc; c += 2)\n      {\n        num = is_float ? getreal(11) : get2() / 32768.0;\n        if (y == 0)\n          mrow[c * wide + x] = num;\n        else\n          mrow[(c + 1) * wide + x] = (num - mrow[c * wide + x]) / head[5];\n      }\n    if (y == 0)\n      continue;\n    rend = head[1] + y * head[5];\n    for (row = rend - head[5]; row < raw_height && row < rend && row < head[1] + head[3] - head[5]; row++)\n    {\n      for (x = 1; x < wide; x++)\n      {\n        for (c = 0; c < nc; c += 2)\n        {\n          mult[c] = mrow[c * wide + x - 1];\n          mult[c + 1] = (mrow[c * wide + x] - mult[c]) / head[4];\n        }\n        cend = head[0] + x * head[4];\n        for (col = cend - head[4]; col < raw_width && col < cend && col < head[0] + head[2] - head[4]; col++)\n        {\n          c = nc > 2 ? FC(row - top_margin, col - left_margin) : 0;\n          if (!(c & 1))\n          {\n            c = RAW(row, col) * mult[c];\n            RAW(row, col) = LIM(c, 0, 65535);\n          }\n          for (c = 0; c < nc; c += 2)\n            mult[c] += mult[c + 1];\n        }\n      }\n      for (x = 0; x < wide; x++)\n        for (c = 0; c < nc; c += 2)\n          mrow[c * wide + x] += mrow[(c + 1) * wide + x];\n    }\n  }\n  free(mrow);\n}\n\nint CLASS phase_one_correct()\n{\n  unsigned entries, tag, data, save, col, row, type;\n  int len, i, j, k, cip, val[4], dev[4], sum, max;\n  int head[9], diff, mindiff = INT_MAX, off_412 = 0;\n  /* static */ const signed char dir[12][2] = {{-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},\n                                               {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};\n  float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};\n  ushort *xval[2];\n  int qmult_applied = 0, qlin_applied = 0;\n\n  if (half_size || !meta_length)\n    return 0;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Phase One correction...\\n\"));\n#endif\n  fseek(ifp, meta_offset, SEEK_SET);\n  order = get2();\n  fseek(ifp, 6, SEEK_CUR);\n  fseek(ifp, meta_offset + get4(), SEEK_SET);\n  entries = get4();\n  get4();\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    while (entries--)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x419)\n      { /* Polynomial curve */\n        for (get4(), i = 0; i < 8; i++)\n          poly[i] = getreal(11);\n        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;\n        for (i = 0; i < 0x10000; i++)\n        {\n          num = (poly[5] * i + poly[3]) * i + poly[1];\n          curve[i] = LIM(num, 0, 65535);\n        }\n        goto apply; /* apply to right half */\n      }\n      else if (tag == 0x41a)\n      { /* Polynomial curve */\n        for (i = 0; i < 4; i++)\n          poly[i] = getreal(11);\n        for (i = 0; i < 0x10000; i++)\n        {\n          for (num = 0, j = 4; j--;)\n            num = num * i + poly[j];\n          curve[i] = LIM(num + i, 0, 65535);\n        }\n      apply: /* apply to whole image */\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)\n            RAW(row, col) = curve[RAW(row, col)];\n        }\n      }\n      else if (tag == 0x400)\n      { /* Sensor defects */\n        while ((len -= 8) >= 0)\n        {\n          col = get2();\n          row = get2();\n          type = get2();\n          get2();\n          if (col >= raw_width)\n            continue;\n          if (type == 131 || type == 137) /* Bad column */\n            for (row = 0; row < raw_height; row++)\n              if (FC(row - top_margin, col - left_margin) == 1)\n              {\n                for (sum = i = 0; i < 4; i++)\n                  sum += val[i] = raw(row + dir[i][0], col + dir[i][1]);\n                for (max = i = 0; i < 4; i++)\n                {\n                  dev[i] = abs((val[i] << 2) - sum);\n                  if (dev[max] < dev[i])\n                    max = i;\n                }\n                RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;\n              }\n              else\n              {\n                for (sum = 0, i = 8; i < 12; i++)\n                  sum += raw(row + dir[i][0], col + dir[i][1]);\n                RAW(row, col) = 0.5 + sum * 0.0732233 + (raw(row, col - 2) + raw(row, col + 2)) * 0.3535534;\n              }\n          else if (type == 129)\n          { /* Bad pixel */\n            if (row >= raw_height)\n              continue;\n            j = (FC(row - top_margin, col - left_margin) != 1) * 4;\n            for (sum = 0, i = j; i < j + 8; i++)\n              sum += raw(row + dir[i][0], col + dir[i][1]);\n            RAW(row, col) = (sum + 4) >> 3;\n          }\n        }\n      }\n      else if (tag == 0x401)\n      { /* All-color flat fields */\n        phase_one_flat_field(1, 2);\n      }\n      else if (tag == 0x416 || tag == 0x410)\n      {\n        phase_one_flat_field(0, 2);\n      }\n      else if (tag == 0x40b)\n      { /* Red+blue flat field */\n        phase_one_flat_field(0, 4);\n      }\n      else if (tag == 0x412)\n      {\n        fseek(ifp, 36, SEEK_CUR);\n        diff = abs(get2() - ph1.tag_21a);\n        if (mindiff > diff)\n        {\n          mindiff = diff;\n          off_412 = ftell(ifp) - 38;\n        }\n      }\n      else if (tag == 0x41f && !qlin_applied)\n      { /* Quadrant linearization */\n        ushort lc[2][2][16], ref[16];\n        int qr, qc;\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 16; i++)\n              lc[qr][qc][i] = get4();\n        for (i = 0; i < 16; i++)\n        {\n          int v = 0;\n          for (qr = 0; qr < 2; qr++)\n            for (qc = 0; qc < 2; qc++)\n              v += lc[qr][qc][i];\n          ref[i] = (v + 2) >> 2;\n        }\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[19], cf[19];\n            for (i = 0; i < 16; i++)\n            {\n              cx[1 + i] = lc[qr][qc][i];\n              cf[1 + i] = ref[i];\n            }\n            cx[0] = cf[0] = 0;\n            cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];\n            cf[18] = cx[18] = 65535;\n            cubic_spline(cx, cf, 19);\n\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qlin_applied = 1;\n      }\n      else if (tag == 0x41e && !qmult_applied)\n      { /* Quadrant multipliers */\n        float qmult[2][2] = {{1, 1}, {1, 1}};\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        get4();\n        get4();\n        qmult[0][1] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][0] = 1.0 + getreal(11);\n        get4();\n        get4();\n        get4();\n        qmult[1][1] = 1.0 + getreal(11);\n        for (row = 0; row < raw_height; row++)\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          checkCancel();\n#endif\n          for (col = 0; col < raw_width; col++)\n          {\n            i = qmult[row >= ph1.split_row][col >= ph1.split_col] * RAW(row, col);\n            RAW(row, col) = LIM(i, 0, 65535);\n          }\n        }\n        qmult_applied = 1;\n      }\n      else if (tag == 0x431 && !qmult_applied)\n      { /* Quadrant combined */\n        ushort lc[2][2][7], ref[7];\n        int qr, qc;\n        for (i = 0; i < 7; i++)\n          ref[i] = get4();\n        for (qr = 0; qr < 2; qr++)\n          for (qc = 0; qc < 2; qc++)\n            for (i = 0; i < 7; i++)\n              lc[qr][qc][i] = get4();\n        for (qr = 0; qr < 2; qr++)\n        {\n          for (qc = 0; qc < 2; qc++)\n          {\n            int cx[9], cf[9];\n            for (i = 0; i < 7; i++)\n            {\n              cx[1 + i] = ref[i];\n              cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;\n            }\n            cx[0] = cf[0] = 0;\n            cx[8] = cf[8] = 65535;\n            cubic_spline(cx, cf, 9);\n            for (row = (qr ? ph1.split_row : 0); row < (qr ? raw_height : ph1.split_row); row++)\n            {\n#ifdef LIBRAW_LIBRARY_BUILD\n              checkCancel();\n#endif\n              for (col = (qc ? ph1.split_col : 0); col < (qc ? raw_width : ph1.split_col); col++)\n                RAW(row, col) = curve[RAW(row, col)];\n            }\n          }\n        }\n        qmult_applied = 1;\n        qlin_applied = 1;\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n    if (off_412)\n    {\n      fseek(ifp, off_412, SEEK_SET);\n      for (i = 0; i < 9; i++)\n        head[i] = get4() & 0x7fff;\n      yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);\n      merror(yval[0], \"phase_one_correct()\");\n      yval[1] = (float *)(yval[0] + head[1] * head[3]);\n      xval[0] = (ushort *)(yval[1] + head[2] * head[4]);\n      xval[1] = (ushort *)(xval[0] + head[1] * head[3]);\n      get2();\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          yval[i][j] = getreal(11);\n      for (i = 0; i < 2; i++)\n        for (j = 0; j < head[i + 1] * head[i + 3]; j++)\n          xval[i][j] = get2();\n      for (row = 0; row < raw_height; row++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        for (col = 0; col < raw_width; col++)\n        {\n          cfrac = (float)col * head[3] / raw_width;\n          cfrac -= cip = cfrac;\n          num = RAW(row, col) * 0.5;\n          for (i = cip; i < cip + 2; i++)\n          {\n            for (k = j = 0; j < head[1]; j++)\n              if (num < xval[0][k = head[1] * i + j])\n                break;\n            frac = (j == 0 || j == head[1]) ? 0 : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);\n            mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);\n          }\n          i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;\n          RAW(row, col) = LIM(i, 0, 65535);\n        }\n      }\n      free(yval[0]);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (yval[0])\n      free(yval[0]);\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n#endif\n  return 0;\n}\n\nvoid CLASS phase_one_load_raw()\n{\n  int a, b, i;\n  ushort akey, bkey, t_mask;\n\n  fseek(ifp, ph1.key_off, SEEK_SET);\n  akey = get2();\n  bkey = get2();\n  t_mask = ph1.format == 1 ? 0x5555 : 0x1354;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw()\");\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw()\");\n    if (ph1.black_col)\n    {\n      fseek(ifp, ph1.black_col, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_cblack[0], raw_height * 2);\n    }\n    if (ph1.black_row)\n    {\n      fseek(ifp, ph1.black_row, SEEK_SET);\n      read_shorts((ushort *)imgdata.rawdata.ph1_rblack[0], raw_width * 2);\n    }\n  }\n#endif\n  fseek(ifp, data_offset, SEEK_SET);\n  read_shorts(raw_image, raw_width * raw_height);\n  if (ph1.format)\n    for (i = 0; i < raw_width * raw_height; i += 2)\n    {\n      a = raw_image[i + 0] ^ akey;\n      b = raw_image[i + 1] ^ bkey;\n      raw_image[i + 0] = (a & t_mask) | (b & ~t_mask);\n      raw_image[i + 1] = (b & t_mask) | (a & ~t_mask);\n    }\n}\n\nunsigned CLASS ph1_bithuff(int nbits, ushort *huff)\n{\n#ifndef LIBRAW_NOTHREADS\n#define bitbuf tls->ph1_bits.bitbuf\n#define vbits tls->ph1_bits.vbits\n#else\n  static UINT64 bitbuf = 0;\n  static int vbits = 0;\n#endif\n  unsigned c;\n\n  if (nbits == -1)\n    return bitbuf = vbits = 0;\n  if (nbits == 0)\n    return 0;\n  if (vbits < nbits)\n  {\n    bitbuf = bitbuf << 32 | get4();\n    vbits += 32;\n  }\n  c = bitbuf << (64 - vbits) >> (64 - nbits);\n  if (huff)\n  {\n    vbits -= huff[c] >> 8;\n    return (uchar)huff[c];\n  }\n  vbits -= nbits;\n  return c;\n#ifndef LIBRAW_NOTHREADS\n#undef bitbuf\n#undef vbits\n#endif\n}\n#define ph1_bits(n) ph1_bithuff(n, 0)\n#define ph1_huff(h) ph1_bithuff(*h, h + 1)\n\nvoid CLASS phase_one_load_raw_c()\n{\n  static const int length[] = {8, 7, 6, 9, 11, 10, 5, 12, 14, 13};\n  int *offset, len[2], pred[2], row, col, i, j;\n  ushort *pixel;\n  short(*c_black)[2], (*r_black)[2];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (ph1.format == 6)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\n  pixel = (ushort *)calloc(raw_width * 3 + raw_height * 4, 2);\n  merror(pixel, \"phase_one_load_raw_c()\");\n  offset = (int *)(pixel + raw_width);\n  fseek(ifp, strip_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n    offset[row] = get4();\n  c_black = (short(*)[2])(offset + raw_height);\n  fseek(ifp, ph1.black_col, SEEK_SET);\n  if (ph1.black_col)\n    read_shorts((ushort *)c_black[0], raw_height * 2);\n  r_black = c_black + raw_height;\n  fseek(ifp, ph1.black_row, SEEK_SET);\n  if (ph1.black_row)\n    read_shorts((ushort *)r_black[0], raw_width * 2);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Copy data to internal copy (ever if not read)\n  if (ph1.black_col || ph1.black_row)\n  {\n    imgdata.rawdata.ph1_cblack = (short(*)[2])calloc(raw_height * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_cblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_cblack, (ushort *)c_black[0], raw_height * 2 * sizeof(ushort));\n    imgdata.rawdata.ph1_rblack = (short(*)[2])calloc(raw_width * 2, sizeof(ushort));\n    merror(imgdata.rawdata.ph1_rblack, \"phase_one_load_raw_c()\");\n    memmove(imgdata.rawdata.ph1_rblack, (ushort *)r_black[0], raw_width * 2 * sizeof(ushort));\n  }\n#endif\n\n  for (i = 0; i < 256; i++)\n    curve[i] = i * i / 3.969 + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + offset[row], SEEK_SET);\n      ph1_bits(-1);\n      pred[0] = pred[1] = 0;\n      for (col = 0; col < raw_width; col++)\n      {\n        if (col >= (raw_width & -8))\n          len[0] = len[1] = 14;\n        else if ((col & 7) == 0)\n          for (i = 0; i < 2; i++)\n          {\n            for (j = 0; j < 5 && !ph1_bits(1); j++)\n              ;\n            if (j--)\n              len[i] = length[j * 2 + ph1_bits(1)];\n          }\n        if ((i = len[col & 1]) == 14)\n          pixel[col] = pred[col & 1] = ph1_bits(16);\n        else\n          pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));\n        if (pred[col & 1] >> 16)\n          derror();\n        if (ph1.format == 5 && pixel[col] < 256)\n          pixel[col] = curve[pixel[col]];\n      }\n#ifndef LIBRAW_LIBRARY_BUILD\n      for (col = 0; col < raw_width; col++)\n      {\n        int shift = ph1.format == 8 ? 0 : 2;\n        i = (pixel[col] << shift) - ph1.t_black + c_black[row][col >= ph1.split_col] +\n            r_black[col][row >= ph1.split_row];\n        if (i > 0)\n          RAW(row, col) = i;\n      }\n#else\n    if (ph1.format == 8)\n      memmove(&RAW(row, 0), &pixel[0], raw_width * 2);\n    else\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = pixel[col] << 2;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = 0xfffc - ph1.t_black;\n}\n\nvoid CLASS hasselblad_load_raw()\n{\n  struct jhead jh;\n  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, s, c;\n  unsigned upix, urow, ucol;\n  ushort *ip;\n\n  if (!ljpeg_start(&jh, 0))\n    return;\n  order = 0x4949;\n  ph1_bits(-1);\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    back[4] = (int *)calloc(raw_width, 3 * sizeof **back);\n    merror(back[4], \"hasselblad_load_raw()\");\n    FORC3 back[c] = back[4] + c * raw_width;\n    cblack[6] >>= sh = tiff_samples > 1;\n    shot = LIM(shot_select, 1, tiff_samples) - 1;\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      FORC4 back[(c + 3) & 3] = back[c];\n      for (col = 0; col < raw_width; col += 2)\n      {\n        for (s = 0; s < tiff_samples * 2; s += 2)\n        {\n          FORC(2) len[c] = ph1_huff(jh.huff[0]);\n          FORC(2)\n          {\n            diff[s + c] = ph1_bits(len[c]);\n            if ((diff[s + c] & (1 << (len[c] - 1))) == 0)\n              diff[s + c] -= (1 << len[c]) - 1;\n            if (diff[s + c] == 65535)\n              diff[s + c] = -32768;\n          }\n        }\n        for (s = col; s < col + 2; s++)\n        {\n          pred = 0x8000 + load_flags;\n          if (col)\n            pred = back[2][s - 2];\n          if (col && row > 1)\n            switch (jh.psv)\n            {\n            case 11:\n              pred += back[0][s] / 2 - back[0][s - 2] / 2;\n              break;\n            }\n          f = (row & 1) * 3 ^ ((col + s) & 1);\n          FORC(tiff_samples)\n          {\n            pred += diff[(s & 1) * tiff_samples + c];\n            upix = pred >> sh & 0xffff;\n            if (raw_image && c == shot)\n              RAW(row, s) = upix;\n            if (image)\n            {\n              urow = row - top_margin + (c & 1);\n              ucol = col - left_margin - ((c >> 1) & 1);\n              ip = &image[urow * width + ucol][f];\n              if (urow < height && ucol < width)\n                *ip = c < 4 ? upix : (*ip + upix) >> 1;\n            }\n          }\n          back[2][s] = pred;\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(back[4]);\n    ljpeg_end(&jh);\n    throw;\n  }\n#endif\n  free(back[4]);\n  ljpeg_end(&jh);\n  if (image)\n    mix_green = 1;\n}\n\nvoid CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel = 0;\n  unsigned tile = 0, r, c, row, col;\n\n  if (!filters)\n  {\n    pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n    merror(pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    FORC(tiff_samples)\n    for (r = 0; r < raw_height; r++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (r % tile_length == 0)\n      {\n        fseek(ifp, data_offset + 4 * tile++, SEEK_SET);\n        fseek(ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select)\n        continue;\n      if (filters)\n        pixel = raw_image + r * raw_width;\n      read_shorts(pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n        for (col = 0; col < width; col++)\n          image[row * width + col][c] = pixel[col + left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    if (!filters)\n      free(pixel);\n    throw;\n  }\n#endif\n  if (!filters)\n  {\n    maximum = 0xffff;\n    raw_color = 1;\n    free(pixel);\n  }\n}\n\nvoid CLASS unpacked_load_raw()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  read_shorts(raw_image, raw_width * raw_height);\n  if (maximum < 0xffff)\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < raw_width; col++)\n        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n            (unsigned)(col - left_margin) < width)\n          derror();\n    }\n}\n\nvoid CLASS unpacked_load_raw_reversed()\n{\n  int row, col, bits = 0;\n  while (1 << ++bits < maximum)\n    ;\n  for (row = raw_height - 1; row >= 0; row--)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    read_shorts(&raw_image[row * raw_width], raw_width);\n    for (col = 0; col < raw_width; col++)\n      if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&\n          (unsigned)(col - left_margin) < width)\n        derror();\n  }\n}\n\nvoid CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (shot = 0; shot < 4; shot++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  mix_green = 1;\n}\n\nvoid CLASS imacon_full_load_raw()\n{\n  int row, col;\n\n  if (!image)\n    return;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n  merror(buf, \"imacon_full_load_raw\");\n#endif\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    read_shorts(buf, width * 3);\n    unsigned short(*rowp)[4] = &image[row * width];\n    for (col = 0; col < width; col++)\n    {\n      rowp[col][0] = buf[col * 3];\n      rowp[col][1] = buf[col * 3 + 1];\n      rowp[col][2] = buf[col * 3 + 2];\n      rowp[col][3] = 0;\n    }\n#else\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], 3);\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(buf);\n#endif\n}\n\nvoid CLASS packed_load_raw()\n{\n  int vbits = 0, bwide, rbits, bite, half, irow, row, col, val, i;\n  UINT64 bitbuf = 0;\n\n  bwide = raw_width * tiff_bps / 8;\n  bwide += bwide & load_flags >> 7;\n  rbits = bwide * 8 - raw_width * tiff_bps;\n  if (load_flags & 1)\n    bwide = bwide * 16 / 15;\n  bite = 8 + (load_flags & 24);\n  half = (raw_height + 1) >> 1;\n  for (irow = 0; irow < raw_height; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    row = irow;\n    if (load_flags & 2 && (row = irow % half * 2 + irow / half) == 1 && load_flags & 4)\n    {\n      if (vbits = 0, tiff_compress)\n        fseek(ifp, data_offset - (-half * bwide & -2048), SEEK_SET);\n      else\n      {\n        fseek(ifp, 0, SEEK_END);\n        fseek(ifp, ftell(ifp) >> 3 << 2, SEEK_SET);\n      }\n    }\n    for (col = 0; col < raw_width; col++)\n    {\n      for (vbits -= tiff_bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      val = bitbuf << (64 - tiff_bps - vbits) >> (64 - tiff_bps);\n      RAW(row, col ^ (load_flags >> 6 & 1)) = val;\n      if (load_flags & 1 && (col % 10) == 9 && fgetc(ifp) && row < height + top_margin && col < width + left_margin)\n        derror();\n    }\n    vbits -= rbits;\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nushort raw_stride;\n\nvoid CLASS parse_broadcom()\n{\n\n  /* This structure is at offset 0xb0 from the 'BRCM' ident. */\n  struct\n  {\n    uint8_t umode[32];\n    uint16_t uwidth;\n    uint16_t uheight;\n    uint16_t padding_right;\n    uint16_t padding_down;\n    uint32_t unknown_block[6];\n    uint16_t transform;\n    uint16_t format;\n    uint8_t bayer_order;\n    uint8_t bayer_format;\n  } header;\n\n  header.bayer_order = 0;\n  fseek(ifp, 0xb0 - 0x20, SEEK_CUR);\n  fread(&header, 1, sizeof(header), ifp);\n  raw_stride = ((((((header.uwidth + header.padding_right) * 5) + 3) >> 2) + 0x1f) & (~0x1f));\n  raw_width = width = header.uwidth;\n  raw_height = height = header.uheight;\n  filters = 0x16161616; /* default Bayer order is 2, BGGR */\n\n  switch (header.bayer_order)\n  {\n  case 0: /* RGGB */\n    filters = 0x94949494;\n    break;\n  case 1: /* GBRG */\n    filters = 0x49494949;\n    break;\n  case 3: /* GRBG */\n    filters = 0x61616161;\n    break;\n  }\n}\n\nvoid CLASS broadcom_load_raw()\n{\n\n  uchar *data, *dp;\n  int rev, row, col, c;\n\n  rev = 3 * (order == 0x4949);\n  data = (uchar *)malloc(raw_stride * 2);\n  merror(data, \"broadcom_load_raw()\");\n\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data + raw_stride, 1, raw_stride, ifp) < raw_stride)\n      derror();\n    FORC(raw_stride) data[c] = data[raw_stride + (c ^ rev)];\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n#endif\n\nvoid CLASS nokia_load_raw()\n{\n  uchar *data, *dp;\n  int rev, dwide, row, col, c;\n  double sum[] = {0, 0};\n\n  rev = 3 * (order == 0x4949);\n  dwide = (raw_width * 5 + 1) / 4;\n  data = (uchar *)malloc(dwide * 2);\n  merror(data, \"nokia_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(data + dwide, 1, dwide, ifp) < dwide)\n        derror();\n      FORC(dwide) data[c] = data[dwide + (c ^ rev)];\n      for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n        FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n#endif\n  free(data);\n  maximum = 0x3ff;\n  if (strncmp(make, \"OmniVision\", 10))\n    return;\n  row = raw_height / 2;\n  FORC(width - 1)\n  {\n    sum[c & 1] += SQR(RAW(row, c) - RAW(row + 1, c + 1));\n    sum[~c & 1] += SQR(RAW(row + 1, c) - RAW(row, c + 1));\n  }\n  if (sum[1] > sum[0])\n    filters = 0x4b4b4b4b;\n}\n\nvoid CLASS android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}\n\nvoid CLASS android_loose_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  UINT64 bitbuf = 0;\n\n  bwide = (raw_width + 5) / 6 << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_loose_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 8, col += 6)\n    {\n      FORC(8) bitbuf = (bitbuf << 8) | dp[c ^ 7];\n      FORC(6) RAW(row, col + c) = (bitbuf >> c * 10) & 0x3ff;\n    }\n  }\n  free(data);\n}\n\nvoid CLASS canon_rmf_load_raw()\n{\n  int row, col, bits, orow, ocol, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  int *words = (int *)malloc(sizeof(int) * (raw_width / 3 + 1));\n  merror(words, \"canon_rmf_load_raw\");\n#endif\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n    fread(words, sizeof(int), raw_width / 3, ifp);\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = words[col / 3];\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#else\n    for (col = 0; col < raw_width - 2; col += 3)\n    {\n      bits = get4();\n      FORC3\n      {\n        orow = row;\n        if ((ocol = col + c - 4) < 0)\n        {\n          ocol += raw_width;\n          if ((orow -= 2) < 0)\n            orow += raw_height;\n        }\n        RAW(orow, ocol) = curve[bits >> (10 * c + 2) & 0x3ff];\n      }\n    }\n#endif\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  free(words);\n#endif\n  maximum = curve[0x3ff];\n}\n\nunsigned CLASS pana_bits(int nbits)\n{\n#ifndef LIBRAW_NOTHREADS\n#define buf tls->pana_bits.buf\n#define vbits tls->pana_bits.vbits\n#else\n  static uchar buf[0x4000];\n  static int vbits;\n#endif\n  int byte;\n\n  if (!nbits)\n    return vbits = 0;\n  if (!vbits)\n  {\n    fread(buf + load_flags, 1, 0x4000 - load_flags, ifp);\n    fread(buf, 1, load_flags, ifp);\n  }\n  vbits = (vbits - nbits) & 0x1ffff;\n  byte = vbits >> 3 ^ 0x3ff0;\n  return (buf[byte] | buf[byte + 1] << 8) >> (vbits & 7) & ~((~0u) << nbits);\n#ifndef LIBRAW_NOTHREADS\n#undef buf\n#undef vbits\n#endif\n}\n\nvoid CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}\n\nvoid CLASS olympus_load_raw()\n{\n  ushort huff[4096];\n  int row, col, nbits, sign, low, high, i, c, w, n, nw;\n  int acarry[2][3], *carry, pred, diff;\n\n  huff[n = 0] = 0xc0c;\n  for (i = 12; i--;)\n    FORC(2048 >> i) huff[++n] = (i + 1) << 8 | i;\n  fseek(ifp, 7, SEEK_CUR);\n  getbits(-1);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset(acarry, 0, sizeof acarry);\n    for (col = 0; col < raw_width; col++)\n    {\n      carry = acarry[col & 1];\n      i = 2 * (carry[2] < 3);\n      for (nbits = 2 + i; (ushort)carry[0] >> (nbits + i); nbits++)\n        ;\n      low = (sign = getbits(3)) & 3;\n      sign = sign << 29 >> 31;\n      if ((high = getbithuff(12, huff)) == 12)\n        high = getbits(16 - nbits) >> 1;\n      carry[0] = (high << nbits) | getbits(nbits);\n      diff = (carry[0] ^ sign) + carry[1];\n      carry[1] = (diff * 3 + carry[1]) >> 5;\n      carry[2] = carry[0] > 16 ? 0 : carry[2] + 1;\n      if (col >= width)\n        continue;\n      if (row < 2 && col < 2)\n        pred = 0;\n      else if (row < 2)\n        pred = RAW(row, col - 2);\n      else if (col < 2)\n        pred = RAW(row - 2, col);\n      else\n      {\n        w = RAW(row, col - 2);\n        n = RAW(row - 2, col);\n        nw = RAW(row - 2, col - 2);\n        if ((w < nw && nw < n) || (n < nw && nw < w))\n        {\n          if (ABS(w - nw) > 32 || ABS(n - nw) > 32)\n            pred = w + n - nw;\n          else\n            pred = (w + n) >> 1;\n        }\n        else\n          pred = ABS(w - nw) > ABS(n - nw) ? w : n;\n      }\n      if ((RAW(row, col) = pred + ((diff << 2) | low)) >> 12)\n        derror();\n    }\n  }\n}\n\nvoid CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow = 0; irow < 1481; irow++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 768, ifp) < 768)\n      derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box - 12) * 2);\n    switch (irow)\n    {\n    case 1477:\n    case 1479:\n      continue;\n    case 1476:\n      row = 984;\n      break;\n    case 1480:\n      row = 985;\n      break;\n    case 1478:\n      row = 985;\n      box = 1;\n    }\n    if ((box < 12) && (box & 1))\n    {\n      for (col = 0; col < 1533; col++, row ^= 1)\n        if (col != 1)\n          RAW(row, col) = (col + 1) & 2 ? pixel[col / 2 - 1] + pixel[col / 2 + 1] : pixel[col / 2] << 1;\n      RAW(row, 1) = pixel[1] << 1;\n      RAW(row, 1533) = pixel[765] << 1;\n    }\n    else\n      for (col = row & 1; col < 1534; col += 2)\n        RAW(row, col) = pixel[col / 2] << 1;\n  }\n  maximum = 0xff << 1;\n}\n\nvoid CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] = {-89, -60, -44, -32, -22, -15, -8, -2, 2, 8, 15, 22, 32, 44, 60, 89};\n  static const short rstep[6][4] = {{-3, -1, 1, 3},   {-5, -1, 1, 5},   {-8, -2, 2, 8},\n                                    {-13, -3, 3, 13}, {-19, -4, 4, 19}, {-28, -6, 6, 28}};\n  static const short t_curve[256] = {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   11,  12,   13,   14,  15,  16,  17,  18,  19,  20,  21,  22,\n      23,  24,  25,  26,  27,  28,  29,  30,  32,  33,  34,  35,   36,   37,  38,  39,  40,  41,  42,  43,  44,  45,\n      46,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,   59,   60,  61,  62,  63,  64,  65,  66,  67,  68,\n      69,  70,  71,  72,  74,  75,  76,  77,  78,  79,  80,  81,   82,   83,  84,  86,  88,  90,  92,  94,  97,  99,\n      101, 103, 105, 107, 110, 112, 114, 116, 118, 120, 123, 125,  127,  129, 131, 134, 136, 138, 140, 142, 144, 147,\n      149, 151, 153, 155, 158, 160, 162, 164, 166, 168, 171, 173,  175,  177, 179, 181, 184, 186, 188, 190, 192, 195,\n      197, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 221,  223,  226, 230, 235, 239, 244, 248, 252, 257, 261,\n      265, 270, 274, 278, 283, 287, 291, 296, 300, 305, 309, 313,  318,  322, 326, 331, 335, 339, 344, 348, 352, 357,\n      361, 365, 370, 374, 379, 383, 387, 392, 396, 400, 405, 409,  413,  418, 422, 426, 431, 435, 440, 444, 448, 453,\n      457, 461, 466, 470, 474, 479, 483, 487, 492, 496, 500, 508,  519,  531, 542, 553, 564, 575, 587, 598, 609, 620,\n      631, 643, 654, 665, 676, 687, 698, 710, 721, 732, 743, 754,  766,  777, 788, 799, 810, 822, 833, 844, 855, 866,\n      878, 889, 900, 911, 922, 933, 945, 956, 967, 978, 989, 1001, 1012, 1023};\n  int rb, row, col, sharp, val = 0;\n\n  getbits(-1);\n  memset(pixel, 0x80, sizeof pixel);\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 2 + (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row - 1][col - 1] + 2 * pixel[row - 1][col + 1] + pixel[row][col - 2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val, 0, 255);\n      if (col < 4)\n        pixel[row][col - 2] = pixel[row + 1][~row & 1] = val;\n      if (row == 2)\n        pixel[row - 1][col + 1] = pixel[row - 1][col + 3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb = 0; rb < 2; rb++)\n    for (row = 2 + rb; row < height + 2; row += 2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 3 - (row & 1); col < width + 2; col += 2)\n      {\n        if (row < 4 || col < 4)\n          sharp = 2;\n        else\n        {\n          val = ABS(pixel[row - 2][col] - pixel[row][col - 2]) + ABS(pixel[row - 2][col] - pixel[row - 2][col - 2]) +\n                ABS(pixel[row][col - 2] - pixel[row - 2][col - 2]);\n          sharp = val < 4 ? 0 : val < 8 ? 1 : val < 16 ? 2 : val < 32 ? 3 : val < 48 ? 4 : 5;\n        }\n        val = ((pixel[row - 2][col] + pixel[row][col - 2]) >> 1) + rstep[sharp][getbits(2)];\n        pixel[row][col] = val = LIM(val, 0, 255);\n        if (row < 4)\n          pixel[row - 2][col + 2] = val;\n        if (col < 4)\n          pixel[row + 2][col - 2] = val;\n      }\n    }\n  for (row = 2; row < height + 2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 3 - (row & 1); col < width + 2; col += 2)\n    {\n      val = ((pixel[row][col - 1] + (pixel[row][col] << 2) + pixel[row][col + 1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val, 0, 255);\n    }\n  }\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col++)\n      RAW(row, col) = t_curve[pixel[row + 2][col + 2]];\n  }\n  maximum = 0x3ff;\n}\n\n#define radc_token(tree) ((signed char)getbithuff(8, huff[tree]))\n\n#define FORYX                                                                                                          \\\n  for (y = 1; y < 3; y++)                                                                                              \\\n    for (x = col + 1; x >= col; x--)\n\n#define PREDICTOR                                                                                                      \\\n  (c ? (buf[c][y - 1][x] + buf[c][y][x + 1]) / 2 : (buf[c][y - 1][x + 1] + 2 * buf[c][y - 1][x] + buf[c][y][x + 1]) / 4)\n\n#ifdef __GNUC__\n#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n#pragma GCC optimize(\"no-aggressive-loop-optimizations\")\n#endif\n#endif\n\nvoid CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n      1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n      8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n      4, 4,   5, 6,   6, 7,   7, 5,   7, 8,   2, 1,   2, 4,  3, 0,   3, 2,   3, 3,  4, 7,  5, 5,  6, 6,   6, 8,   2, 3,\n      3, 1,   3, 2,   3, 4,   3, 5,   3, 6,   4, 7,   5, 0,  5, 8,   2, 3,   2, 6,  3, 0,  3, 1,  4, 4,   4, 5,   4, 7,\n      5, 2,   5, 8,   2, 4,   2, 7,   3, 3,   3, 6,   4, 1,  4, 2,   4, 5,   5, 0,  5, 8,  2, 6,  3, 1,   3, 3,   3, 5,\n      3, 7,   3, 8,   4, 0,   5, 2,   5, 4,   2, 0,   2, 1,  3, 2,   3, 3,   4, 4,  4, 5,  5, 6,  5, 7,   4, 8,   1, 0,\n      2, 2,   2, -2,  1, -3,  1, 3,   2, -17, 2, -5,  2, 5,  2, 17,  2, -7,  2, 2,  2, 9,  2, 18, 2, -18, 2, -9,  2, -2,\n      2, 7,   2, -28, 2, 28,  3, -49, 3, -9,  3, 9,   4, 49, 5, -79, 5, 79,  2, -1, 2, 13, 2, 26, 3, 39,  4, -16, 5, 55,\n      6, -37, 6, 76,  2, -26, 2, -13, 2, 1,   3, -39, 4, 16, 5, -55, 6, -76, 6, 37};\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = {16, 16, 16}, mul[3], buf[3][3][386];\n  static const ushort pt[] = {0, 0, 1280, 1344, 2320, 3616, 3328, 8000, 4095, 16383, 65535, 16383};\n\n  for (i = 2; i < 12; i += 2)\n    for (c = pt[i - 2]; c <= pt[i]; c++)\n      curve[c] = (float)(c - pt[i - 2]) / (pt[i] - pt[i - 2]) * (pt[i + 1] - pt[i - 1]) + pt[i - 1] + 0.5;\n  for (s = i = 0; i < sizeof src; i += 2)\n    FORC(256 >> src[i])\n  ((ushort *)huff)[s++] = src[i] << 8 | (uchar)src[i + 1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8 - s) << 8 | c >> s << s | 1 << (s - 1);\n  getbits(-1);\n  for (i = 0; i < sizeof(buf) / sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row = 0; row < height; row += 4)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n    FORC3\n    {\n      val = ((0x1000000 / last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10 : 12;\n      x = ~((~0u) << (s - 1));\n      val <<= 12 - s;\n      for (i = 0; i < sizeof(buf[0]) / sizeof(short); i++)\n        ((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r = 0; r <= !c; r++)\n      {\n        buf[c][1][width / 2] = buf[c][2][width / 2] = mul[c] << 7;\n        for (tree = 1, col = width / 2; col > 0;)\n        {\n          if ((tree = radc_token(tree)))\n          {\n            col -= 2;\n            if (tree == 8)\n              FORYX buf[c][y][x] = (uchar)radc_token(18) * mul[c];\n            else\n              FORYX buf[c][y][x] = radc_token(tree + 10) * 16 + PREDICTOR;\n          }\n          else\n            do\n            {\n              nreps = (col > 2) ? radc_token(9) + 1 : 1;\n              for (rep = 0; rep < 8 && rep < nreps && col > 0; rep++)\n              {\n                col -= 2;\n                FORYX buf[c][y][x] = PREDICTOR;\n                if (rep & 1)\n                {\n                  step = radc_token(10) << 4;\n                  FORYX buf[c][y][x] += step;\n                }\n              }\n            } while (nreps == 9);\n        }\n        for (y = 0; y < 2; y++)\n          for (x = 0; x < width / 2; x++)\n          {\n            val = (buf[c][y + 1][x] << 4) / mul[c];\n            if (val < 0)\n              val = 0;\n            if (c)\n              RAW(row + y * 2 + c - 1, x * 2 + 2 - c) = val;\n            else\n              RAW(row + r * 2 + y, x * 2 + y) = val;\n          }\n        memcpy(buf[c][0] + !c, buf[c][2], sizeof buf[c][0] - 2 * !c);\n      }\n    }\n    for (y = row; y < row + 4; y++)\n      for (x = 0; x < width; x++)\n        if ((x + y) & 1)\n        {\n          r = x ? x - 1 : x + 1;\n          s = x + 1 < width ? x + 1 : x - 1;\n          val = (RAW(y, x) - 2048) * 2 + (RAW(y, r) + RAW(y, s)) / 2;\n          if (val < 0)\n            val = 0;\n          RAW(y, x) = val;\n        }\n  }\n  for (i = 0; i < height * width; i++)\n    raw_image[i] = curve[raw_image[i]];\n  maximum = 0x3fff;\n}\n\n#undef FORYX\n#undef PREDICTOR\n\n#ifdef NO_JPEG\nvoid CLASS kodak_jpeg_load_raw() {}\nvoid CLASS lossy_dng_load_raw() {}\n#else\n\n#ifndef LIBRAW_LIBRARY_BUILD\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  static uchar jpeg_buffer[4096];\n  size_t nbytes;\n\n  nbytes = fread(jpeg_buffer, 1, 4096, ifp);\n  swab(jpeg_buffer, jpeg_buffer, nbytes);\n  cinfo->src->next_input_byte = jpeg_buffer;\n  cinfo->src->bytes_in_buffer = nbytes;\n  return TRUE;\n}\nvoid CLASS kodak_jpeg_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  int row, col;\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, ifp);\n  cinfo.src->fill_input_buffer = fill_input_buffer;\n  jpeg_read_header(&cinfo, TRUE);\n  jpeg_start_decompress(&cinfo);\n  if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n  {\n    fprintf(stderr, _(\"%s: incorrect JPEG dimensions\\n\"), ifname);\n    jpeg_destroy_decompress(&cinfo);\n    longjmp(failure, 3);\n  }\n  buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, width * 3, 1);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = cinfo.output_scanline * 2;\n    jpeg_read_scanlines(&cinfo, buf, 1);\n    pixel = (JSAMPLE(*)[3])buf[0];\n    for (col = 0; col < width; col += 2)\n    {\n      RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n      RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n      RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n      RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n    }\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xff << 1;\n}\n#else\n\nstruct jpegErrorManager\n{\n  struct jpeg_error_mgr pub;\n};\n\nstatic void jpegErrorExit(j_common_ptr cinfo)\n{\n  jpegErrorManager *myerr = (jpegErrorManager *)cinfo->err;\n  throw LIBRAW_EXCEPTION_DECODE_JPEG;\n}\n\n// LibRaw's Kodak_jpeg_load_raw\nvoid CLASS kodak_jpeg_load_raw()\n{\n  if (data_size < 1)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n  int row, col;\n  jpegErrorManager jerr;\n  struct jpeg_decompress_struct cinfo;\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = jpegErrorExit;\n\n  unsigned char *jpg_buf = (unsigned char *)malloc(data_size);\n  merror(jpg_buf, \"kodak_jpeg_load_raw\");\n  unsigned char *pixel_buf = (unsigned char *)malloc(width * 3);\n  jpeg_create_decompress(&cinfo);\n  merror(pixel_buf, \"kodak_jpeg_load_raw\");\n\n  fread(jpg_buf, data_size, 1, ifp);\n  swab((char *)jpg_buf, (char *)jpg_buf, data_size);\n  try\n  {\n    jpeg_mem_src(&cinfo, jpg_buf, data_size);\n    int rc = jpeg_read_header(&cinfo, TRUE);\n    if (rc != 1)\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n\n    jpeg_start_decompress(&cinfo);\n    if ((cinfo.output_width != width) || (cinfo.output_height * 2 != height) || (cinfo.output_components != 3))\n    {\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n\n    unsigned char *buf[1];\n    buf[0] = pixel_buf;\n\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n      checkCancel();\n      row = cinfo.output_scanline * 2;\n      jpeg_read_scanlines(&cinfo, buf, 1);\n      unsigned char(*pixel)[3] = (unsigned char(*)[3])buf[0];\n      for (col = 0; col < width; col += 2)\n      {\n        RAW(row + 0, col + 0) = pixel[col + 0][1] << 1;\n        RAW(row + 1, col + 1) = pixel[col + 1][1] << 1;\n        RAW(row + 0, col + 1) = pixel[col][0] + pixel[col + 1][0];\n        RAW(row + 1, col + 0) = pixel[col][2] + pixel[col + 1][2];\n      }\n    }\n  }\n  catch (...)\n  {\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    free(jpg_buf);\n    free(pixel_buf);\n    throw;\n  }\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n  free(jpg_buf);\n  free(pixel_buf);\n  maximum = 0xff << 1;\n}\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n#endif\n\nvoid CLASS lossy_dng_load_raw()\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  JSAMPARRAY buf;\n  JSAMPLE(*pixel)[3];\n  unsigned sorder = order, ntags, opcode, deg, i, j, c;\n  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;\n  ushort cur[3][256];\n  double coeff[9], tot;\n\n  if (meta_offset)\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = 0x4d4d;\n    ntags = get4();\n    while (ntags--)\n    {\n      opcode = get4();\n      get4();\n      get4();\n      if (opcode != 8)\n      {\n        fseek(ifp, get4(), SEEK_CUR);\n        continue;\n      }\n      fseek(ifp, 20, SEEK_CUR);\n      if ((c = get4()) > 2)\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      if ((deg = get4()) > 8)\n        break;\n      for (i = 0; i <= deg && i < 9; i++)\n        coeff[i] = getreal(12);\n      for (i = 0; i < 256; i++)\n      {\n        for (tot = j = 0; j <= deg; j++)\n          tot += coeff[j] * pow(i / 255.0, (int)j);\n        cur[c][i] = tot * 0xffff;\n      }\n    }\n    order = sorder;\n  }\n  else\n  {\n    gamma_curve(1 / 2.4, 12.92, 1, 255);\n    FORC3 memcpy(cur[c], curve, sizeof cur[0]);\n  }\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  while (trow < raw_height)\n  {\n    fseek(ifp, save += 4, SEEK_SET);\n    if (tile_length < INT_MAX)\n      fseek(ifp, get4(), SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw LIBRAW_EXCEPTION_DECODE_JPEG;\n    }\n#else\n    jpeg_stdio_src(&cinfo, ifp);\n#endif\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, cinfo.output_width * 3, 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n    try\n    {\n#endif\n      while (cinfo.output_scanline < cinfo.output_height && (row = trow + cinfo.output_scanline) < height)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        checkCancel();\n#endif\n        jpeg_read_scanlines(&cinfo, buf, 1);\n        pixel = (JSAMPLE(*)[3])buf[0];\n        for (col = 0; col < cinfo.output_width && tcol + col < width; col++)\n        {\n          FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];\n        }\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    catch (...)\n    {\n      jpeg_destroy_decompress(&cinfo);\n      throw;\n    }\n#endif\n    jpeg_abort_decompress(&cinfo);\n    if ((tcol += tile_width) >= raw_width)\n      trow += tile_length + (tcol = 0);\n  }\n  jpeg_destroy_decompress(&cinfo);\n  maximum = 0xffff;\n}\n#endif\n\nvoid CLASS kodak_dc120_load_raw()\n{\n  static const int mul[4] = {162, 192, 187, 92};\n  static const int add[4] = {0, 636, 424, 212};\n  uchar pixel[848];\n  int row, shift, col;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread(pixel, 1, 848, ifp) < 848)\n      derror();\n    shift = row * mul[row & 3] + add[row & 3];\n    for (col = 0; col < width; col++)\n      RAW(row, col) = (ushort)pixel[(col + shift) % 848];\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS eight_bit_load_raw()\n{\n  uchar *pixel;\n  unsigned row, col;\n\n  pixel = (uchar *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"eight_bit_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, 1, raw_width, ifp) < raw_width)\n        derror();\n      for (col = 0; col < raw_width; col++)\n        RAW(row, col) = curve[pixel[col]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 2 * sizeof *pixel);\n  merror(pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (fread(pixel, raw_width, 2, ifp) < 2)\n        derror();\n      if (load_flags && (row & 31) == 31)\n        fseek(ifp, raw_width * 32, SEEK_CUR);\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[col * 2];\n        cb = pixel[(col * 2 & -4) | 1] - 128;\n        cr = pixel[(col * 2 & -4) | 3] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *)calloc(raw_width, 3 * sizeof *pixel);\n  merror(pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if (~row & 1)\n        if (fread(pixel, raw_width, 3, ifp) < 3)\n          derror();\n      for (col = 0; col < width; col++)\n      {\n        y = pixel[width * 2 * (row & 1) + col];\n        cb = pixel[width + (col & -2)] - 128;\n        cr = pixel[width + (col & -2) + 1] - 128;\n        rgb[1] = y - ((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        FORC3 image[row * width + col][c] = curve[LIM(rgb[c], 0, 255)];\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  maximum = curve[0xff];\n}\n\nvoid CLASS kodak_262_load_raw()\n{\n  static const uchar kodak_tree[2][26] = {\n      {0, 1, 5, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n      {0, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}};\n  ushort *huff[2];\n  uchar *pixel;\n  int *strip, ns, c, row, col, chess, pi = 0, pi1, pi2, pred, val;\n\n  FORC(2) huff[c] = make_decoder(kodak_tree[c]);\n  ns = (raw_height + 63) >> 5;\n  pixel = (uchar *)malloc(raw_width * 32 + ns * 4);\n  merror(pixel, \"kodak_262_load_raw()\");\n  strip = (int *)(pixel + raw_width * 32);\n  order = 0x4d4d;\n  FORC(ns) strip[c] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < raw_height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      if ((row & 31) == 0)\n      {\n        fseek(ifp, strip[row >> 5], SEEK_SET);\n        getbits(-1);\n        pi = 0;\n      }\n      for (col = 0; col < raw_width; col++)\n      {\n        chess = (row + col) & 1;\n        pi1 = chess ? pi - 2 : pi - raw_width - 1;\n        pi2 = chess ? pi - 2 * raw_width : pi - raw_width + 1;\n        if (col <= chess)\n          pi1 = -1;\n        if (pi1 < 0)\n          pi1 = pi2;\n        if (pi2 < 0)\n          pi2 = pi1;\n        if (pi1 < 0 && col > 1)\n          pi1 = pi2 = pi - 2;\n        pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;\n        pixel[pi] = val = pred + ljpeg_diff(huff[chess]);\n        if (val >> 8)\n          derror();\n        val = curve[pixel[pi++]];\n        RAW(row, col) = val;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n#endif\n  free(pixel);\n  FORC(2) free(huff[c]);\n}\n\nint CLASS kodak_65000_decode(short *out, int bsize)\n{\n  uchar c, blen[768];\n  ushort raw[6];\n  INT64 bitbuf = 0;\n  int save, bits = 0, i, j, len, diff;\n\n  save = ftell(ifp);\n  bsize = (bsize + 3) & -4;\n  for (i = 0; i < bsize; i += 2)\n  {\n    c = fgetc(ifp);\n    if ((blen[i] = c & 15) > 12 || (blen[i + 1] = c >> 4) > 12)\n    {\n      fseek(ifp, save, SEEK_SET);\n      for (i = 0; i < bsize; i += 8)\n      {\n        read_shorts(raw, 6);\n        out[i] = raw[0] >> 12 << 8 | raw[2] >> 12 << 4 | raw[4] >> 12;\n        out[i + 1] = raw[1] >> 12 << 8 | raw[3] >> 12 << 4 | raw[5] >> 12;\n        for (j = 0; j < 6; j++)\n          out[i + 2 + j] = raw[j] & 0xfff;\n      }\n      return 1;\n    }\n  }\n  if ((bsize & 7) == 4)\n  {\n    bitbuf = fgetc(ifp) << 8;\n    bitbuf += fgetc(ifp);\n    bits = 16;\n  }\n  for (i = 0; i < bsize; i++)\n  {\n    len = blen[i];\n    if (bits < len)\n    {\n      for (j = 0; j < 32; j += 8)\n        bitbuf += (INT64)fgetc(ifp) << (bits + (j ^ 8));\n      bits += 32;\n    }\n    diff = bitbuf & (0xffff >> (16 - len));\n    bitbuf >>= len;\n    bits -= len;\n    if ((diff & (1 << (len - 1))) == 0)\n      diff -= (1 << len) - 1;\n    out[i] = diff;\n  }\n  return 0;\n}\n\nvoid CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      pred[0] = pred[1] = 0;\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len);\n      for (i = 0; i < len; i++)\n        if ((RAW(row, col + i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])]) >> 12)\n          derror();\n    }\n  }\n}\n\nvoid CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image)\n    return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17) ? load_flags : 10;\n  for (row = 0; row < height; row += 2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 128)\n    {\n      len = MIN(128, width - col);\n      kodak_65000_decode(buf, len * 3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp = buf, i = 0; i < len; i += 2, bp += 2)\n      {\n        cb += bp[4];\n        cr += bp[5];\n        rgb[1] = -((cb + cr + 2) >> 2);\n        rgb[2] = rgb[1] + cb;\n        rgb[0] = rgb[1] + cr;\n        for (j = 0; j < 2; j++)\n          for (k = 0; k < 2; k++)\n          {\n            if ((y[j][k] = y[j][k ^ 1] + *bp++) >> bits)\n              derror();\n            ip = image[(row + j) * width + col + i + k];\n            FORC3 ip[c] = curve[LIM(y[j][k] + rgb[c], 0, 0xfff)];\n          }\n      }\n    }\n  }\n}\n\nvoid CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3], ret;\n  ushort *ip = image[0];\n\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < width; col += 256)\n    {\n      len = MIN(256, width - col);\n      ret = kodak_65000_decode(buf, len * 3);\n      memset(rgb, 0, sizeof rgb);\n      for (bp = buf, i = 0; i < len; i++, ip += 4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (load_flags == 12)\n        {\n          FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n        }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}\n\nvoid CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      read_shorts(image[row * width + col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}\n\nvoid CLASS sony_decrypt(unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start)\n  {\n    for (p = 0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;\n    for (p = 4; p < 127; p++)\n      pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;\n    for (p = 0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n  {\n    *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];\n    p++;\n  }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}\n\nvoid CLASS sony_load_raw()\n{\n  uchar head[40];\n  ushort *pixel;\n  unsigned i, key, row, col;\n\n  fseek(ifp, 200896, SEEK_SET);\n  fseek(ifp, (unsigned)fgetc(ifp) * 4 - 1, SEEK_CUR);\n  order = 0x4d4d;\n  key = get4();\n  fseek(ifp, 164600, SEEK_SET);\n  fread(head, 1, 40, ifp);\n  sony_decrypt((unsigned *)head, 10, 1, key);\n  for (i = 26; i-- > 22;)\n    key = key << 8 | head[i];\n  fseek(ifp, data_offset, SEEK_SET);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    pixel = raw_image + row * raw_width;\n    if (fread(pixel, 2, raw_width, ifp) < raw_width)\n      derror();\n    sony_decrypt((unsigned *)pixel, raw_width / 2, !row, key);\n    for (col = 0; col < raw_width; col++)\n      if ((pixel[col] = ntohs(pixel[col])) >> 14)\n        derror();\n  }\n  maximum = 0x3ff0;\n}\n\nvoid CLASS sony_arw_load_raw()\n{\n  ushort huff[32770];\n  static const ushort tab[18] = {0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809,\n                                 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201};\n  int i, c, n, col, row, sum = 0;\n\n  huff[0] = 15;\n  for (n = i = 0; i < 18; i++)\n    FORC(32768 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (col = raw_width; col--;)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (row = 0; row < raw_height + 1; row += 2)\n    {\n      if (row == raw_height)\n        row = 1;\n      if ((sum += ljpeg_diff(huff)) >> 12)\n        derror();\n      if (row < height)\n        RAW(row, col) = sum;\n    }\n  }\n}\n\nvoid CLASS sony_arw2_load_raw()\n{\n  uchar *data, *dp;\n  ushort pix[16];\n  int row, col, val, max, min, imax, imin, sh, bit, i;\n\n  data = (uchar *)malloc(raw_width + 1);\n  merror(data, \"sony_arw2_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try\n  {\n#endif\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      fread(data, 1, raw_width, ifp);\n      for (dp = data, col = 0; col < raw_width - 30; dp += 16)\n      {\n        max = 0x7ff & (val = sget4(dp));\n        min = 0x7ff & val >> 11;\n        imax = 0x0f & val >> 22;\n        imin = 0x0f & val >> 26;\n        for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++)\n          ;\n#ifdef LIBRAW_LIBRARY_BUILD\n        /* flag checks if outside of loop */\n        if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_ALLFLAGS) // no flag set\n            || (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE))\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_BASEONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = max;\n            else if (i == imin)\n              pix[i] = min;\n            else\n              pix[i] = 0;\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAONLY)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n        else if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE)\n        {\n          for (bit = 30, i = 0; i < 16; i++)\n            if (i == imax)\n              pix[i] = 0;\n            else if (i == imin)\n              pix[i] = 0;\n            else\n            {\n              pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh);\n              if (pix[i] > 0x7ff)\n                pix[i] = 0x7ff;\n              bit += 7;\n            }\n        }\n#else\n      /* unaltered dcraw processing */\n      for (bit = 30, i = 0; i < 16; i++)\n        if (i == imax)\n          pix[i] = max;\n        else if (i == imin)\n          pix[i] = min;\n        else\n        {\n          pix[i] = ((sget2(dp + (bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;\n          if (pix[i] > 0x7ff)\n            pix[i] = 0x7ff;\n          bit += 7;\n        }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n        {\n          for (i = 0; i < 16; i++, col += 2)\n          {\n            unsigned slope = pix[i] < 1001 ? 2 : curve[pix[i] << 1] - curve[(pix[i] << 1) - 2];\n            unsigned step = 1 << sh;\n            RAW(row, col) = curve[pix[i] << 1] > black + imgdata.params.sony_arw2_posterization_thr\n                                ? LIM(((slope * step * 1000) / (curve[pix[i] << 1] - black)), 0, 10000)\n                                : 0;\n          }\n        }\n        else\n        {\n          for (i = 0; i < 16; i++, col += 2)\n            RAW(row, col) = curve[pix[i] << 1];\n        }\n#else\n      for (i = 0; i < 16; i++, col += 2)\n        RAW(row, col) = curve[pix[i] << 1] >> 2;\n#endif\n        col -= col & 1 ? 1 : 31;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    free(data);\n    throw;\n  }\n  if (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE)\n    maximum = 10000;\n#endif\n  free(data);\n}\n\nvoid CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n\n  order = 0x4949;\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, strip_offset + row * 4, SEEK_SET);\n    fseek(ifp, data_offset + get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7 : 4;\n    for (col = 0; col < raw_width; col += 16)\n    {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c])\n      {\n      case 3:\n        len[c] = ph1_bits(4);\n        break;\n      case 2:\n        len[c]--;\n        break;\n      case 1:\n        len[c]++;\n      }\n      for (c = 0; c < 16; c += 2)\n      {\n        i = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) +\n                            (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n        if (c == 14)\n          c = -1;\n      }\n    }\n  }\n  for (row = 0; row < raw_height - 1; row += 2)\n    for (col = 0; col < raw_width - 1; col += 2)\n      SWAP(RAW(row, col + 1), RAW(row + 1, col));\n}\n\nvoid CLASS samsung2_load_raw()\n{\n  static const ushort tab[14] = {0x304, 0x307, 0x206, 0x205, 0x403, 0x600, 0x709,\n                                 0x80a, 0x90b, 0xa0c, 0xa0d, 0x501, 0x408, 0x402};\n  ushort huff[1026], vpred[2][2] = {{0, 0}, {0, 0}}, hpred[2];\n  int i, c, n, row, col, diff;\n\n  huff[0] = 10;\n  for (n = i = 0; i < 14; i++)\n    FORC(1024 >> (tab[i] >> 8)) huff[++n] = tab[i];\n  getbits(-1);\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      diff = ljpeg_diff(huff);\n      if (col < 2)\n        hpred[col] = vpred[row & 1][col] += diff;\n      else\n        hpred[col & 1] += diff;\n      RAW(row, col) = hpred[col & 1];\n      if (hpred[col & 1] >> tiff_bps)\n        derror();\n    }\n  }\n}\n\nvoid CLASS samsung3_load_raw()\n{\n  int opt, init, mag, pmode, row, tab, col, pred, diff, i, c;\n  ushort lent[3][2], len[4], *prow[2];\n\n  order = 0x4949;\n  fseek(ifp, 9, SEEK_CUR);\n  opt = fgetc(ifp);\n  init = (get2(), get2());\n  for (row = 0; row < raw_height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek(ifp, (data_offset - ftell(ifp)) & 15, SEEK_CUR);\n    ph1_bits(-1);\n    mag = 0;\n    pmode = 7;\n    FORC(6)((ushort *)lent)[c] = row < 2 ? 7 : 4;\n    prow[row & 1] = &RAW(row - 1, 1 - ((row & 1) << 1)); // green\n    prow[~row & 1] = &RAW(row - 2, 0);                   // red and blue\n    for (tab = 0; tab + 15 < raw_width; tab += 16)\n    {\n      if (~opt & 4 && !(tab & 63))\n      {\n        i = ph1_bits(2);\n        mag = i < 3 ? mag - '2' + \"204\"[i] : ph1_bits(12);\n      }\n      if (opt & 2)\n        pmode = 7 - 4 * ph1_bits(1);\n      else if (!ph1_bits(1))\n        pmode = ph1_bits(3);\n      if (opt & 1 || !ph1_bits(1))\n      {\n        FORC4 len[c] = ph1_bits(2);\n        FORC4\n        {\n          i = ((row & 1) << 1 | (c & 1)) % 3;\n          len[c] = len[c] < 3 ? lent[i][0] - '1' + \"120\"[len[c]] : ph1_bits(4);\n          lent[i][0] = lent[i][1];\n          lent[i][1] = len[c];\n        }\n      }\n      FORC(16)\n      {\n        col = tab + (((c & 7) << 1) ^ (c >> 3) ^ (row & 1));\n        pred =\n            (pmode == 7 || row < 2)\n                ? (tab ? RAW(row, tab - 2 + (col & 1)) : init)\n                : (prow[col & 1][col - '4' + \"0224468\"[pmode]] + prow[col & 1][col - '4' + \"0244668\"[pmode]] + 1) >> 1;\n        diff = ph1_bits(i = len[c >> 2]);\n        if (diff >> (i - 1))\n          diff -= 1 << i;\n        diff = diff * (mag * 2 + 1) + mag;\n        RAW(row, col) = pred + diff;\n      }\n    }\n  }\n}\n\n#define HOLE(row) ((holes >> (((row)-raw_height) & 7)) & 1)\n\n/* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */\nvoid CLASS smal_decode_segment(unsigned seg[2][2], int holes)\n{\n  uchar hist[3][13] = {{7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {7, 7, 0, 0, 63, 55, 47, 39, 31, 23, 15, 7, 0},\n                       {3, 3, 0, 0, 63, 47, 31, 15, 0}};\n  int low, high = 0xff, carry = 0, nbits = 8;\n  int pix, s, count, bin, next, i, sym[3];\n  uchar diff, pred[] = {0, 0};\n  ushort data = 0, range = 0;\n\n  fseek(ifp, seg[0][1] + 1, SEEK_SET);\n  getbits(-1);\n  if (seg[1][0] > raw_width * raw_height)\n    seg[1][0] = raw_width * raw_height;\n  for (pix = seg[0][0]; pix < seg[1][0]; pix++)\n  {\n    for (s = 0; s < 3; s++)\n    {\n      data = data << nbits | getbits(nbits);\n      if (carry < 0)\n        carry = (nbits += carry + 1) < 1 ? nbits - 1 : 0;\n      while (--nbits >= 0)\n        if ((data >> nbits & 0xff) == 0xff)\n          break;\n      if (nbits > 0)\n        data = ((data & ((1 << (nbits - 1)) - 1)) << 1) |\n               ((data + (((data & (1 << (nbits - 1)))) << 1)) & ((~0u) << nbits));\n      if (nbits >= 0)\n      {\n        data += getbits(1);\n        carry = nbits - 8;\n      }\n      count = ((((data - range + 1) & 0xffff) << 2) - 1) / (high >> 4);\n      for (bin = 0; hist[s][bin + 5] > count; bin++)\n        ;\n      low = hist[s][bin + 5] * (high >> 4) >> 2;\n      if (bin)\n        high = hist[s][bin + 4] * (high >> 4) >> 2;\n      high -= low;\n      for (nbits = 0; high << nbits < 128; nbits++)\n        ;\n      range = (range + low) << nbits;\n      high <<= nbits;\n      next = hist[s][1];\n      if (++hist[s][2] > hist[s][3])\n      {\n        next = (next + 1) & hist[s][0];\n        hist[s][3] = (hist[s][next + 4] - hist[s][next + 5]) >> 2;\n        hist[s][2] = 1;\n      }\n      if (hist[s][hist[s][1] + 4] - hist[s][hist[s][1] + 5] > 1)\n      {\n        if (bin < hist[s][1])\n          for (i = bin; i < hist[s][1]; i++)\n            hist[s][i + 5]--;\n        else if (next <= bin)\n          for (i = hist[s][1]; i < bin; i++)\n            hist[s][i + 5]++;\n      }\n      hist[s][1] = next;\n      sym[s] = bin;\n    }\n    diff = sym[2] << 5 | sym[1] << 2 | (sym[0] & 3);\n    if (sym[0] & 4)\n      diff = diff ? -diff : 0x80;\n    if (ftell(ifp) + 12 >= seg[1][1])\n      diff = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (pix >= raw_width * raw_height)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    raw_image[pix] = pred[pix & 1] += diff;\n    if (!(pix & 1) && HOLE(pix / raw_width))\n      pix += 2;\n  }\n  maximum = 0xff;\n}\n\nvoid CLASS smal_v6_load_raw()\n{\n  unsigned seg[2][2];\n\n  fseek(ifp, 16, SEEK_SET);\n  seg[0][0] = 0;\n  seg[0][1] = get2();\n  seg[1][0] = raw_width * raw_height;\n  seg[1][1] = INT_MAX;\n  smal_decode_segment(seg, 0);\n}\n\nint CLASS median4(int *p)\n{\n  int min, max, sum, i;\n\n  min = max = sum = p[0];\n  for (i = 1; i < 4; i++)\n  {\n    sum += p[i];\n    if (min > p[i])\n      min = p[i];\n    if (max < p[i])\n      max = p[i];\n  }\n  return (sum - min - max) >> 1;\n}\n\nvoid CLASS fill_holes(int holes)\n{\n  int row, col, val[4];\n\n  for (row = 2; row < height - 2; row++)\n  {\n    if (!HOLE(row))\n      continue;\n    for (col = 1; col < width - 1; col += 4)\n    {\n      val[0] = RAW(row - 1, col - 1);\n      val[1] = RAW(row - 1, col + 1);\n      val[2] = RAW(row + 1, col - 1);\n      val[3] = RAW(row + 1, col + 1);\n      RAW(row, col) = median4(val);\n    }\n    for (col = 2; col < width - 2; col += 4)\n      if (HOLE(row - 2) || HOLE(row + 2))\n        RAW(row, col) = (RAW(row, col - 2) + RAW(row, col + 2)) >> 1;\n      else\n      {\n        val[0] = RAW(row, col - 2);\n        val[1] = RAW(row, col + 2);\n        val[2] = RAW(row - 2, col);\n        val[3] = RAW(row + 2, col);\n        RAW(row, col) = median4(val);\n      }\n  }\n}\n\nvoid CLASS smal_v9_load_raw()\n{\n  unsigned seg[256][2], offset, nseg, holes, i;\n\n  fseek(ifp, 67, SEEK_SET);\n  offset = get4();\n  nseg = (uchar)fgetc(ifp);\n  fseek(ifp, offset, SEEK_SET);\n  for (i = 0; i < nseg * 2; i++)\n    ((unsigned *)seg)[i] = get4() + data_offset * (i & 1);\n  fseek(ifp, 78, SEEK_SET);\n  holes = fgetc(ifp);\n  fseek(ifp, 88, SEEK_SET);\n  seg[nseg][0] = raw_height * raw_width;\n  seg[nseg][1] = get4() + data_offset;\n  for (i = 0; i < nseg; i++)\n    smal_decode_segment(seg + i, holes);\n  if (holes)\n    fill_holes(holes);\n}\n\nvoid CLASS redcine_load_raw()\n{\n#ifndef NO_JASPER\n  int c, row, col;\n  jas_stream_t *in;\n  jas_image_t *jimg;\n  jas_matrix_t *jmat;\n  jas_seqent_t *data;\n  ushort *img, *pix;\n\n  jas_init();\n#ifndef LIBRAW_LIBRARY_BUILD\n  in = jas_stream_fopen(ifname, \"rb\");\n#else\n  in = (jas_stream_t *)ifp->make_jas_stream();\n  if (!in)\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n#endif\n  jas_stream_seek(in, data_offset + 20, SEEK_SET);\n  jimg = jas_image_decode(in, -1, 0);\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!jimg)\n    longjmp(failure, 3);\n#else\n  if (!jimg)\n  {\n    jas_stream_close(in);\n    throw LIBRAW_EXCEPTION_DECODE_JPEG2000;\n  }\n#endif\n  jmat = jas_matrix_create(height / 2, width / 2);\n  merror(jmat, \"redcine_load_raw()\");\n  img = (ushort *)calloc((height + 2), (width + 2) * 2);\n  merror(img, \"redcine_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  bool fastexitflag = false;\n  try\n  {\n#endif\n    FORC4\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      jas_image_readcmpt(jimg, c, 0, 0, width / 2, height / 2, jmat);\n      data = jas_matrix_getref(jmat, 0, 0);\n      for (row = c >> 1; row < height; row += 2)\n        for (col = c & 1; col < width; col += 2)\n          img[(row + 1) * (width + 2) + col + 1] = data[(row / 2) * (width / 2) + col / 2];\n    }\n    for (col = 1; col <= width; col++)\n    {\n      img[col] = img[2 * (width + 2) + col];\n      img[(height + 1) * (width + 2) + col] = img[(height - 1) * (width + 2) + col];\n    }\n    for (row = 0; row < height + 2; row++)\n    {\n      img[row * (width + 2)] = img[row * (width + 2) + 2];\n      img[(row + 1) * (width + 2) - 1] = img[(row + 1) * (width + 2) - 3];\n    }\n    for (row = 1; row <= height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      pix = img + row * (width + 2) + (col = 1 + (FC(row, 1) & 1));\n      for (; col <= width; col += 2, pix += 2)\n      {\n        c = (((pix[0] - 0x800) << 3) + pix[-(width + 2)] + pix[width + 2] + pix[-1] + pix[1]) >> 2;\n        pix[0] = LIM(c, 0, 4095);\n      }\n    }\n    for (row = 0; row < height; row++)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      checkCancel();\n#endif\n      for (col = 0; col < width; col++)\n        RAW(row, col) = curve[img[(row + 1) * (width + 2) + col + 1]];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  }\n  catch (...)\n  {\n    fastexitflag = true;\n  }\n#endif\n  free(img);\n  jas_matrix_destroy(jmat);\n  jas_image_destroy(jimg);\n  jas_stream_close(in);\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (fastexitflag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n#endif\n}\nvoid CLASS crop_masked_pixels()\n{\n  int row, col;\n  unsigned\n#ifndef LIBRAW_LIBRARY_BUILD\n      r,\n      raw_pitch = raw_width * 2, c, m, mblack[8], zero, val;\n#else\n      c,\n      m, zero, val;\n#define mblack imgdata.color.black_stat\n#endif\n\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS phase_one_load_raw || load_raw == &CLASS phase_one_load_raw_c)\n    phase_one_correct();\n  if (fuji_width)\n  {\n    for (row = 0; row < raw_height - top_margin * 2; row++)\n    {\n      for (col = 0; col < fuji_width << !fuji_layout; col++)\n      {\n        if (fuji_layout)\n        {\n          r = fuji_width - 1 - col + (row >> 1);\n          c = col + ((row + 1) >> 1);\n        }\n        else\n        {\n          r = fuji_width - 1 + row - (col >> 1);\n          c = row + ((col + 1) >> 1);\n        }\n        if (r < height && c < width)\n          BAYER(r, c) = RAW(row + top_margin, col + left_margin);\n      }\n    }\n  }\n  else\n  {\n    for (row = 0; row < height; row++)\n      for (col = 0; col < width; col++)\n        BAYER2(row, col) = RAW(row + top_margin, col + left_margin);\n  }\n#endif\n  if (mask[0][3] > 0)\n    goto mask_set;\n  if (load_raw == &CLASS canon_load_raw || load_raw == &CLASS lossless_jpeg_load_raw)\n  {\n    mask[0][1] = mask[1][1] += 2;\n    mask[0][3] -= 2;\n    goto sides;\n  }\n  if (load_raw == &CLASS canon_600_load_raw || load_raw == &CLASS sony_load_raw ||\n      (load_raw == &CLASS eight_bit_load_raw && strncmp(model, \"DC2\", 3)) || load_raw == &CLASS kodak_262_load_raw ||\n      (load_raw == &CLASS packed_load_raw && (load_flags & 32)))\n  {\n  sides:\n    mask[0][0] = mask[1][0] = top_margin;\n    mask[0][2] = mask[1][2] = top_margin + height;\n    mask[0][3] += left_margin;\n    mask[1][1] += left_margin + width;\n    mask[1][3] += raw_width;\n  }\n  if (load_raw == &CLASS nokia_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (load_raw == &CLASS broadcom_load_raw)\n  {\n    mask[0][2] = top_margin;\n    mask[0][3] = width;\n  }\n#endif\nmask_set:\n  memset(mblack, 0, sizeof mblack);\n  for (zero = m = 0; m < 8; m++)\n    for (row = MAX(mask[m][0], 0); row < MIN(mask[m][2], raw_height); row++)\n      for (col = MAX(mask[m][1], 0); col < MIN(mask[m][3], raw_width); col++)\n      {\n        c = FC(row - top_margin, col - left_margin);\n        mblack[c] += val = raw_image[(row)*raw_pitch / 2 + (col)];\n        mblack[4 + c]++;\n        zero += !val;\n      }\n  if (load_raw == &CLASS canon_600_load_raw && width < raw_width)\n  {\n    black = (mblack[0] + mblack[1] + mblack[2] + mblack[3]) / (mblack[4] + mblack[5] + mblack[6] + mblack[7]) - 4;\n#ifndef LIBRAW_LIBRARY_BUILD\n    canon_600_correct();\n#endif\n  }\n  else if (zero < mblack[4] && mblack[5] && mblack[6] && mblack[7])\n  {\n    FORC4 cblack[c] = mblack[c] / mblack[4 + c];\n    black = cblack[4] = cblack[5] = cblack[6] = 0;\n  }\n}\n#ifdef LIBRAW_LIBRARY_BUILD\n#undef mblack\n#endif\n\nvoid CLASS remove_zeroes()\n{\n  unsigned row, col, tot, n, r, c;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 0, 2);\n#endif\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n      if (BAYER(row, col) == 0)\n      {\n        tot = n = 0;\n        for (r = row - 2; r <= row + 2; r++)\n          for (c = col - 2; c <= col + 2; c++)\n            if (r < height && c < width && FC(r, c) == FC(row, col) && BAYER(r, c))\n              tot += (n++, BAYER(r, c));\n        if (n)\n          BAYER(row, col) = tot / n;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES, 1, 2);\n#endif\n}\n\nstatic const uchar xlat[2][256] = {\n    {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f, 0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3,\n     0xc7, 0xe9, 0x2f, 0x95, 0xa7, 0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71, 0x89, 0x3d,\n     0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f, 0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b,\n     0x47, 0x7f, 0x95, 0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61, 0xf1, 0x3d, 0xb3, 0x2b,\n     0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65, 0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95,\n     0x17, 0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7, 0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b,\n     0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5, 0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65, 0x1d,\n     0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b, 0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43,\n     0x2b, 0x07, 0x1d, 0x95, 0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17, 0x7f, 0xef, 0x7f,\n     0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad, 0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad,\n     0xe9, 0x2f, 0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47, 0x3b, 0x9d, 0xef, 0x35, 0xa3,\n     0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53, 0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,\n     0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5, 0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07,\n     0x6b, 0x25, 0x49, 0x95, 0x25, 0x49, 0x6d, 0x71, 0xc7},\n    {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17, 0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9,\n     0x25, 0x68, 0x11, 0x86, 0xb3, 0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46, 0x14, 0x68,\n     0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad, 0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95,\n     0x9c, 0x66, 0xdc, 0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f, 0x82, 0x4c, 0xc0, 0x68,\n     0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a, 0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42,\n     0x9d, 0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34, 0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca,\n     0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5, 0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8, 0x87,\n     0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc, 0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45,\n     0xf1, 0xf0, 0xa3, 0x94, 0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65, 0x57, 0x16, 0x94,\n     0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2, 0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26,\n     0xbb, 0xd6, 0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e, 0xe0, 0x2f, 0xdc, 0x7c, 0xbe,\n     0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8, 0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,\n     0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb, 0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65,\n     0x7e, 0xb0, 0xdf, 0xaf, 0x4e, 0xb3, 0x61, 0x7f, 0x2f}};\n\nvoid CLASS gamma_curve(double pwr, double ts, int mode, int imax)\n{\n  int i;\n  double g[6], bnd[2] = {0, 0}, r;\n\n  g[0] = pwr;\n  g[1] = ts;\n  g[2] = g[3] = g[4] = 0;\n  bnd[g[1] >= 1] = 1;\n  if (g[1] && (g[1] - 1) * (g[0] - 1) <= 0)\n  {\n    for (i = 0; i < 48; i++)\n    {\n      g[2] = (bnd[0] + bnd[1]) / 2;\n      if (g[0])\n        bnd[(pow(g[2] / g[1], -g[0]) - 1) / g[0] - 1 / g[2] > -1] = g[2];\n      else\n        bnd[g[2] / exp(1 - 1 / g[2]) < g[1]] = g[2];\n    }\n    g[3] = g[2] / g[1];\n    if (g[0])\n      g[4] = g[2] * (1 / g[0] - 1);\n  }\n  if (g[0])\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 - g[4] * (1 - g[3]) + (1 - pow(g[3], 1 + g[0])) * (1 + g[4]) / (1 + g[0])) - 1;\n  else\n    g[5] = 1 / (g[1] * SQR(g[3]) / 2 + 1 - g[2] - g[3] - g[2] * g[3] * (log(g[3]) - 1)) - 1;\n  if (!mode--)\n  {\n    memcpy(gamm, g, sizeof gamm);\n    return;\n  }\n  for (i = 0; i < 0x10000; i++)\n  {\n    curve[i] = 0xffff;\n    if ((r = (double)i / imax) < 1)\n      curve[i] = 0x10000 *\n                 (mode ? (r < g[3] ? r * g[1] : (g[0] ? pow(r, g[0]) * (1 + g[4]) - g[4] : log(r) * g[2] + 1))\n                       : (r < g[2] ? r / g[1] : (g[0] ? pow((r + g[4]) / (1 + g[4]), 1 / g[0]) : exp((r - 1) / g[2]))));\n  }\n}\n\nvoid CLASS pseudoinverse(double (*in)[3], double (*out)[3], int size)\n{\n  double work[3][6], num;\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < 6; j++)\n      work[i][j] = j == i + 3;\n    for (j = 0; j < 3; j++)\n      for (k = 0; k < size; k++)\n        work[i][j] += in[k][i] * in[k][j];\n  }\n  for (i = 0; i < 3; i++)\n  {\n    num = work[i][i];\n    for (j = 0; j < 6; j++)\n      work[i][j] /= num;\n    for (k = 0; k < 3; k++)\n    {\n      if (k == i)\n        continue;\n      num = work[k][i];\n      for (j = 0; j < 6; j++)\n        work[k][j] -= work[i][j] * num;\n    }\n  }\n  for (i = 0; i < size; i++)\n    for (j = 0; j < 3; j++)\n      for (out[i][j] = k = 0; k < 3; k++)\n        out[i][j] += work[j][k + 3] * in[i][k];\n}\n\nvoid CLASS cam_xyz_coeff(float _rgb_cam[3][4], double cam_xyz[4][3])\n{\n  double cam_rgb[4][3], inverse[4][3], num;\n  int i, j, k;\n\n  for (i = 0; i < colors; i++) /* Multiply out XYZ colorspace */\n    for (j = 0; j < 3; j++)\n      for (cam_rgb[i][j] = k = 0; k < 3; k++)\n        cam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\n  for (i = 0; i < colors; i++)\n  {                               /* Normalize cam_rgb so that */\n    for (num = j = 0; j < 3; j++) /* cam_rgb * (1,1,1) is (1,1,1,1) */\n      num += cam_rgb[i][j];\n    if (num > 0.00001)\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] /= num;\n      pre_mul[i] = 1 / num;\n    }\n    else\n    {\n      for (j = 0; j < 3; j++)\n        cam_rgb[i][j] = 0.0;\n      pre_mul[i] = 1.0;\n    }\n  }\n  pseudoinverse(cam_rgb, inverse, colors);\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < colors; j++)\n      _rgb_cam[i][j] = inverse[j][i];\n}\n\n#ifdef COLORCHECK\nvoid CLASS colorcheck()\n{\n#define NSQ 24\n  // Coordinates of the GretagMacbeth ColorChecker squares\n  // width, height, 1st_column, 1st_row\n  int cut[NSQ][4];                                             // you must set these\n                                                               // ColorChecker Chart under 6500-kelvin illumination\n  static const double gmb_xyY[NSQ][3] = {{0.400, 0.350, 10.1}, // Dark Skin\n                                         {0.377, 0.345, 35.8}, // Light Skin\n                                         {0.247, 0.251, 19.3}, // Blue Sky\n                                         {0.337, 0.422, 13.3}, // Foliage\n                                         {0.265, 0.240, 24.3}, // Blue Flower\n                                         {0.261, 0.343, 43.1}, // Bluish Green\n                                         {0.506, 0.407, 30.1}, // Orange\n                                         {0.211, 0.175, 12.0}, // Purplish Blue\n                                         {0.453, 0.306, 19.8}, // Moderate Red\n                                         {0.285, 0.202, 6.6},  // Purple\n                                         {0.380, 0.489, 44.3}, // Yellow Green\n                                         {0.473, 0.438, 43.1}, // Orange Yellow\n                                         {0.187, 0.129, 6.1},  // Blue\n                                         {0.305, 0.478, 23.4}, // Green\n                                         {0.539, 0.313, 12.0}, // Red\n                                         {0.448, 0.470, 59.1}, // Yellow\n                                         {0.364, 0.233, 19.8}, // Magenta\n                                         {0.196, 0.252, 19.8}, // Cyan\n                                         {0.310, 0.316, 90.0}, // White\n                                         {0.310, 0.316, 59.1}, // Neutral 8\n                                         {0.310, 0.316, 36.2}, // Neutral 6.5\n                                         {0.310, 0.316, 19.8}, // Neutral 5\n                                         {0.310, 0.316, 9.0},  // Neutral 3.5\n                                         {0.310, 0.316, 3.1}}; // Black\n  double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];\n  double inverse[NSQ][3], cam_xyz[4][3], balance[4], num;\n  int c, i, j, k, sq, row, col, pass, count[4];\n\n  memset(gmb_cam, 0, sizeof gmb_cam);\n  for (sq = 0; sq < NSQ; sq++)\n  {\n    FORCC count[c] = 0;\n    for (row = cut[sq][3]; row < cut[sq][3] + cut[sq][1]; row++)\n      for (col = cut[sq][2]; col < cut[sq][2] + cut[sq][0]; col++)\n      {\n        c = FC(row, col);\n        if (c >= colors)\n          c -= 2;\n        gmb_cam[sq][c] += BAYER2(row, col);\n        BAYER2(row, col) = black + (BAYER2(row, col) - black) / 2;\n        count[c]++;\n      }\n    FORCC gmb_cam[sq][c] = gmb_cam[sq][c] / count[c] - black;\n    gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];\n    gmb_xyz[sq][1] = gmb_xyY[sq][2];\n    gmb_xyz[sq][2] = gmb_xyY[sq][2] * (1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];\n  }\n  pseudoinverse(gmb_xyz, inverse, NSQ);\n  for (pass = 0; pass < 2; pass++)\n  {\n    for (raw_color = i = 0; i < colors; i++)\n      for (j = 0; j < 3; j++)\n        for (cam_xyz[i][j] = k = 0; k < NSQ; k++)\n          cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];\n    cam_xyz_coeff(rgb_cam, cam_xyz);\n    FORCC balance[c] = pre_mul[c] * gmb_cam[20][c];\n    for (sq = 0; sq < NSQ; sq++)\n      FORCC gmb_cam[sq][c] *= balance[c];\n  }\n  if (verbose)\n  {\n    printf(\"    { \\\"%s %s\\\", %d,\\n\\t{\", make, model, black);\n    num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);\n    FORCC for (j = 0; j < 3; j++) printf(\"%c%d\", (c | j) ? ',' : ' ', (int)(cam_xyz[c][j] * num + 0.5));\n    puts(\" } },\");\n  }\n#undef NSQ\n}\n#endif\n\nvoid CLASS hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (2 * size - 2 - (i + sc))];\n}\n\n#if !defined(LIBRAW_USE_OPENMP)\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n  FORC(nc)\n  { /* denoise R,G1,B,G3 individually */\n    for (i = 0; i < size; i++)\n      fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n    for (hpass = lev = 0; lev < 5; lev++)\n    {\n      lpass = size * ((lev & 1) + 1);\n      for (row = 0; row < iheight; row++)\n      {\n        hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n        for (col = 0; col < iwidth; col++)\n          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n      }\n      for (col = 0; col < iwidth; col++)\n      {\n        hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n        for (row = 0; row < iheight; row++)\n          fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n      }\n      thold = threshold * noise[lev];\n      for (i = 0; i < size; i++)\n      {\n        fimg[hpass + i] -= fimg[lpass + i];\n        if (fimg[hpass + i] < -thold)\n          fimg[hpass + i] += thold;\n        else if (fimg[hpass + i] > thold)\n          fimg[hpass + i] -= thold;\n        else\n          fimg[hpass + i] = 0;\n        if (hpass)\n          fimg[i] += fimg[hpass + i];\n      }\n      hpass = lpass;\n    }\n    for (i = 0; i < size; i++)\n      image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n  }\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n#else /* LIBRAW_USE_OPENMP */\nvoid CLASS wavelet_denoise()\n{\n  float *fimg = 0, *temp, thold, mul[2], avg, diff;\n  int scale = 1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];\n  ushort *window[4];\n  static const float noise[] = {0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Wavelet denoising...\\n\"));\n#endif\n\n  while (maximum << scale < 0x10000)\n    scale++;\n  maximum <<= --scale;\n  black <<= scale;\n  FORC4 cblack[c] <<= scale;\n  if ((size = iheight * iwidth) < 0x15550000)\n    fimg = (float *)malloc((size * 3 + iheight + iwidth) * sizeof *fimg);\n  merror(fimg, \"wavelet_denoise()\");\n  temp = fimg + size * 3;\n  if ((nc = colors) == 3 && filters)\n    nc++;\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp parallel default(shared) private(i, col, row, thold, lev, lpass, hpass, temp, c) firstprivate(scale, size)\n#endif\n  {\n    temp = (float *)malloc((iheight + iwidth) * sizeof *fimg);\n    FORC(nc)\n    { /* denoise R,G1,B,G3 individually */\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        fimg[i] = 256 * sqrt((double)(image[i][c] << scale));\n      for (hpass = lev = 0; lev < 5; lev++)\n      {\n        lpass = size * ((lev & 1) + 1);\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (row = 0; row < iheight; row++)\n        {\n          hat_transform(temp, fimg + hpass + row * iwidth, 1, iwidth, 1 << lev);\n          for (col = 0; col < iwidth; col++)\n            fimg[lpass + row * iwidth + col] = temp[col] * 0.25;\n        }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (col = 0; col < iwidth; col++)\n        {\n          hat_transform(temp, fimg + lpass + col, iwidth, iheight, 1 << lev);\n          for (row = 0; row < iheight; row++)\n            fimg[lpass + row * iwidth + col] = temp[row] * 0.25;\n        }\n        thold = threshold * noise[lev];\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n        for (i = 0; i < size; i++)\n        {\n          fimg[hpass + i] -= fimg[lpass + i];\n          if (fimg[hpass + i] < -thold)\n            fimg[hpass + i] += thold;\n          else if (fimg[hpass + i] > thold)\n            fimg[hpass + i] -= thold;\n          else\n            fimg[hpass + i] = 0;\n          if (hpass)\n            fimg[i] += fimg[hpass + i];\n        }\n        hpass = lpass;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n#pragma omp for\n#endif\n      for (i = 0; i < size; i++)\n        image[i][c] = CLIP(SQR(fimg[i] + fimg[lpass + i]) / 0x10000);\n    }\n    free(temp);\n  } /* end omp parallel */\n  /* the following loops are hard to parallize, no idea yes,\n   * problem is wlast which is carrying dependency\n   * second part should be easyer, but did not yet get it right.\n   */\n  if (filters && colors == 3)\n  { /* pull G1 and G3 closer together */\n    for (row = 0; row < 2; row++)\n    {\n      mul[row] = 0.125 * pre_mul[FC(row + 1, 0) | 1] / pre_mul[FC(row, 0) | 1];\n      blk[row] = cblack[FC(row, 0) | 1];\n    }\n    for (i = 0; i < 4; i++)\n      window[i] = (ushort *)fimg + width * i;\n    for (wlast = -1, row = 1; row < height - 1; row++)\n    {\n      while (wlast < row + 1)\n      {\n        for (wlast++, i = 0; i < 4; i++)\n          window[(i + 3) & 3] = window[i];\n        for (col = FC(wlast, 1) & 1; col < width; col += 2)\n          window[2][col] = BAYER(wlast, col);\n      }\n      thold = threshold / 512;\n      for (col = (FC(row, 0) & 1) + 1; col < width - 1; col += 2)\n      {\n        avg = (window[0][col - 1] + window[0][col + 1] + window[2][col - 1] + window[2][col + 1] - blk[~row & 1] * 4) *\n                  mul[row & 1] +\n              (window[1][col] + blk[row & 1]) * 0.5;\n        avg = avg < 0 ? 0 : sqrt(avg);\n        diff = sqrt((double)BAYER(row, col)) - avg;\n        if (diff < -thold)\n          diff += thold;\n        else if (diff > thold)\n          diff -= thold;\n        else\n          diff = 0;\n        BAYER(row, col) = CLIP(SQR(avg + diff) + 0.5);\n      }\n    }\n  }\n  free(fimg);\n}\n\n#endif\n\n// green equilibration\nvoid CLASS green_matching()\n{\n  int i, j;\n  double m1, m2, c1, c2;\n  int o1_1, o1_2, o1_3, o1_4;\n  int o2_1, o2_2, o2_3, o2_4;\n  ushort(*img)[4];\n  const int margin = 3;\n  int oj = 2, oi = 2;\n  float f;\n  const float thr = 0.01f;\n  if (half_size || shrink)\n    return;\n  if (FC(oj, oi) != 3)\n    oj++;\n  if (FC(oj, oi) != 3)\n    oi++;\n  if (FC(oj, oi) != 3)\n    oj--;\n\n  img = (ushort(*)[4])calloc(height * width, sizeof *image);\n  merror(img, \"green_matching()\");\n  memcpy(img, image, height * width * sizeof *image);\n\n  for (j = oj; j < height - margin; j += 2)\n    for (i = oi; i < width - margin; i += 2)\n    {\n      o1_1 = img[(j - 1) * width + i - 1][1];\n      o1_2 = img[(j - 1) * width + i + 1][1];\n      o1_3 = img[(j + 1) * width + i - 1][1];\n      o1_4 = img[(j + 1) * width + i + 1][1];\n      o2_1 = img[(j - 2) * width + i][3];\n      o2_2 = img[(j + 2) * width + i][3];\n      o2_3 = img[j * width + i - 2][3];\n      o2_4 = img[j * width + i + 2][3];\n\n      m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0;\n      m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0;\n\n      c1 = (abs(o1_1 - o1_2) + abs(o1_1 - o1_3) + abs(o1_1 - o1_4) + abs(o1_2 - o1_3) + abs(o1_3 - o1_4) +\n            abs(o1_2 - o1_4)) /\n           6.0;\n      c2 = (abs(o2_1 - o2_2) + abs(o2_1 - o2_3) + abs(o2_1 - o2_4) + abs(o2_2 - o2_3) + abs(o2_3 - o2_4) +\n            abs(o2_2 - o2_4)) /\n           6.0;\n      if ((img[j * width + i][3] < maximum * 0.95) && (c1 < maximum * thr) && (c2 < maximum * thr))\n      {\n        f = image[j * width + i][3] * m1 / m2;\n        image[j * width + i][3] = f > 0xffff ? 0xffff : f;\n      }\n    }\n  free(img);\n}\n\nvoid CLASS scale_colors()\n{\n  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];\n  int val, dark, sat;\n  double dsum[8], dmin, dmax;\n  float scale_mul[4], fr, fc;\n  ushort *img = 0, *pix;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 0, 2);\n#endif\n\n  if (user_mul[0])\n    memcpy(pre_mul, user_mul, sizeof pre_mul);\n  if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1))\n  {\n    memset(dsum, 0, sizeof dsum);\n    bottom = MIN(greybox[1] + greybox[3], height);\n    right = MIN(greybox[0] + greybox[2], width);\n    for (row = greybox[1]; row < bottom; row += 8)\n      for (col = greybox[0]; col < right; col += 8)\n      {\n        memset(sum, 0, sizeof sum);\n        for (y = row; y < row + 8 && y < bottom; y++)\n          for (x = col; x < col + 8 && x < right; x++)\n            FORC4\n            {\n              if (filters)\n              {\n                c = fcol(y, x);\n                val = BAYER2(y, x);\n              }\n              else\n                val = image[y * width + x][c];\n              if (val > maximum - 25)\n                goto skip_block;\n              if ((val -= cblack[c]) < 0)\n                val = 0;\n              sum[c] += val;\n              sum[c + 4]++;\n              if (filters)\n                break;\n            }\n        FORC(8) dsum[c] += sum[c];\n      skip_block:;\n      }\n    FORC4 if (dsum[c]) pre_mul[c] = dsum[c + 4] / dsum[c];\n  }\n  if (use_camera_wb && cam_mul[0] != -1)\n  {\n    memset(sum, 0, sizeof sum);\n    for (row = 0; row < 8; row++)\n      for (col = 0; col < 8; col++)\n      {\n        c = FC(row, col);\n        if ((val = white[row][col] - cblack[c]) > 0)\n          sum[c] += val;\n        sum[c + 4]++;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (load_raw == &LibRaw::nikon_load_sraw)\n    {\n      // Nikon sRAW: camera WB already applied:\n      pre_mul[0] = pre_mul[1] = pre_mul[2] = pre_mul[3] = 1.0;\n    }\n    else\n#endif\n        if (sum[0] && sum[1] && sum[2] && sum[3])\n      FORC4 pre_mul[c] = (float)sum[c + 4] / sum[c];\n    else if (cam_mul[0] && cam_mul[2])\n      memcpy(pre_mul, cam_mul, sizeof pre_mul);\n    else\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.process_warnings |= LIBRAW_WARN_BAD_CAMERA_WB;\n#endif\n#ifdef DCRAW_VERBOSE\n      fprintf(stderr, _(\"%s: Cannot use camera white balance.\\n\"), ifname);\n#endif\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // Nikon sRAW, daylight\n  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && !use_auto_wb && cam_mul[0] > 0.001f &&\n      cam_mul[1] > 0.001f && cam_mul[2] > 0.001f)\n  {\n    for (c = 0; c < 3; c++)\n      pre_mul[c] /= cam_mul[c];\n  }\n#endif\n  if (pre_mul[1] == 0)\n    pre_mul[1] = 1;\n  if (pre_mul[3] == 0)\n    pre_mul[3] = colors < 4 ? pre_mul[1] : 1;\n  dark = black;\n  sat = maximum;\n  if (threshold)\n    wavelet_denoise();\n  maximum -= black;\n  for (dmin = DBL_MAX, dmax = c = 0; c < 4; c++)\n  {\n    if (dmin > pre_mul[c])\n      dmin = pre_mul[c];\n    if (dmax < pre_mul[c])\n      dmax = pre_mul[c];\n  }\n  if (!highlight)\n    dmax = dmin;\n  FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n  {\n    fprintf(stderr, _(\"Scaling with darkness %d, saturation %d, and\\nmultipliers\"), dark, sat);\n    FORC4 fprintf(stderr, \" %f\", pre_mul[c]);\n    fputc('\\n', stderr);\n  }\n#endif\n  if (filters > 1000 && (cblack[4] + 1) / 2 == 1 && (cblack[5] + 1) / 2 == 1)\n  {\n    FORC4 cblack[FC(c / 2, c % 2)] += cblack[6 + c / 2 % cblack[4] * cblack[5] + c % 2 % cblack[5]];\n    cblack[4] = cblack[5] = 0;\n  }\n  size = iheight * iwidth;\n#ifdef LIBRAW_LIBRARY_BUILD\n  scale_colors_loop(scale_mul);\n#else\n  for (i = 0; i < size * 4; i++)\n  {\n    if (!(val = ((ushort *)image)[i]))\n      continue;\n    if (cblack[4] && cblack[5])\n      val -= cblack[6 + i / 4 / iwidth % cblack[4] * cblack[5] + i / 4 % iwidth % cblack[5]];\n    val -= cblack[i & 3];\n    val *= scale_mul[i & 3];\n    ((ushort *)image)[i] = CLIP(val);\n  }\n#endif\n  if ((aber[0] != 1 || aber[2] != 1) && colors == 3)\n  {\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Correcting chromatic aberration...\\n\"));\n#endif\n    for (c = 0; c < 4; c += 2)\n    {\n      if (aber[c] == 1)\n        continue;\n      img = (ushort *)malloc(size * sizeof *img);\n      merror(img, \"scale_colors()\");\n      for (i = 0; i < size; i++)\n        img[i] = image[i][c];\n      for (row = 0; row < iheight; row++)\n      {\n        ur = fr = (row - iheight * 0.5) * aber[c] + iheight * 0.5;\n        if (ur > iheight - 2)\n          continue;\n        fr -= ur;\n        for (col = 0; col < iwidth; col++)\n        {\n          uc = fc = (col - iwidth * 0.5) * aber[c] + iwidth * 0.5;\n          if (uc > iwidth - 2)\n            continue;\n          fc -= uc;\n          pix = img + ur * iwidth + uc;\n          image[row * iwidth + col][c] =\n              (pix[0] * (1 - fc) + pix[1] * fc) * (1 - fr) + (pix[iwidth] * (1 - fc) + pix[iwidth + 1] * fc) * fr;\n        }\n      }\n      free(img);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_SCALE_COLORS, 1, 2);\n#endif\n}\n\nvoid CLASS pre_interpolate()\n{\n  ushort(*img)[4];\n  int row, col, c;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 0, 2);\n#endif\n  if (shrink)\n  {\n    if (half_size)\n    {\n      height = iheight;\n      width = iwidth;\n      if (filters == 9)\n      {\n        for (row = 0; row < 3; row++)\n          for (col = 1; col < 4; col++)\n            if (!(image[row * width + col][0] | image[row * width + col][2]))\n              goto break2;\n      break2:\n        for (; row < height; row += 3)\n          for (col = (col - 1) % 3 + 1; col < width - 1; col += 3)\n          {\n            img = image + row * width + col;\n            for (c = 0; c < 3; c += 2)\n              img[0][c] = (img[-1][c] + img[1][c]) >> 1;\n          }\n      }\n    }\n    else\n    {\n      img = (ushort(*)[4])calloc(height, width * sizeof *img);\n      merror(img, \"pre_interpolate()\");\n      for (row = 0; row < height; row++)\n        for (col = 0; col < width; col++)\n        {\n          c = fcol(row, col);\n          img[row * width + col][c] = image[(row >> 1) * iwidth + (col >> 1)][c];\n        }\n      free(image);\n      image = img;\n      shrink = 0;\n    }\n  }\n  if (filters > 1000 && colors == 3)\n  {\n    mix_green = four_color_rgb ^ half_size;\n    if (four_color_rgb | half_size)\n      colors++;\n    else\n    {\n      for (row = FC(1, 0) >> 1; row < height; row += 2)\n        for (col = FC(row, 1) & 1; col < width; col += 2)\n          image[row * width + col][1] = image[row * width + col][3];\n      filters &= ~((filters & 0x55555555) << 1);\n    }\n  }\n  if (half_size)\n    filters = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_PRE_INTERPOLATE, 1, 2);\n#endif\n}\n\nvoid CLASS border_interpolate(int border)\n{\n  unsigned row, col, y, x, f, c, sum[8];\n\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      if (col == border && row >= border && row < height - border)\n        col = width - border;\n      memset(sum, 0, sizeof sum);\n      for (y = row - 1; y != row + 2; y++)\n        for (x = col - 1; x != col + 2; x++)\n          if (y < height && x < width)\n          {\n            f = fcol(y, x);\n            sum[f] += image[y * width + x][f];\n            sum[f + 4]++;\n          }\n      f = fcol(row, col);\n      FORCC if (c != f && sum[c + 4]) image[row * width + col][c] = sum[c] / sum[c + 4];\n    }\n}\n\nvoid CLASS lin_interpolate_loop(int code[16][16][32], int size)\n{\n  int row;\n  for (row = 1; row < height - 1; row++)\n  {\n    int col, *ip;\n    ushort *pix;\n    for (col = 1; col < width - 1; col++)\n    {\n      int i;\n      int sum[4];\n      pix = image[row * width + col];\n      ip = code[row % size][col % size];\n      memset(sum, 0, sizeof sum);\n      for (i = *ip++; i--; ip += 3)\n        sum[ip[2]] += pix[ip[0]] << ip[1];\n      for (i = colors; --i; ip += 2)\n        pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;\n    }\n  }\n}\n\nvoid CLASS lin_interpolate()\n{\n  int code[16][16][32], size = 16, *ip, sum[4];\n  int f, c, x, y, row, col, shift, color;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Bilinear interpolation...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#endif\n\n  if (filters == 9)\n    size = 6;\n  border_interpolate(1);\n  for (row = 0; row < size; row++)\n    for (col = 0; col < size; col++)\n    {\n      ip = code[row][col] + 1;\n      f = fcol(row, col);\n      memset(sum, 0, sizeof sum);\n      for (y = -1; y <= 1; y++)\n        for (x = -1; x <= 1; x++)\n        {\n          shift = (y == 0) + (x == 0);\n          color = fcol(row + y, col + x);\n          if (color == f)\n            continue;\n          *ip++ = (width * y + x) * 4 + color;\n          *ip++ = shift;\n          *ip++ = color;\n          sum[color] += 1 << shift;\n        }\n      code[row][col][0] = (ip - code[row][col]) / 3;\n      FORCC\n      if (c != f)\n      {\n        *ip++ = c;\n        *ip++ = sum[c] > 0 ? 256 / sum[c] : 0;\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#endif\n  lin_interpolate_loop(code, size);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#endif\n}\n\n/*\n   This algorithm is officially called:\n\n   \"Interpolation using a Threshold-based variable number of gradients\"\n\n   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html\n\n   I've extended the basic idea to work with non-Bayer filter arrays.\n   Gradients are numbered clockwise from NW=0 to W=7.\n */\nvoid CLASS vng_interpolate()\n{\n  static const signed char *cp,\n      terms[] = {-2, -2, +0, -1, 0, 0x01, -2, -2, +0, +0, 1, 0x01, -2, -1, -1, +0, 0, 0x01, -2, -1, +0, -1, 0, 0x02,\n                 -2, -1, +0, +0, 0, 0x03, -2, -1, +0, +1, 1, 0x01, -2, +0, +0, -1, 0, 0x06, -2, +0, +0, +0, 1, 0x02,\n                 -2, +0, +0, +1, 0, 0x03, -2, +1, -1, +0, 0, 0x04, -2, +1, +0, -1, 1, 0x04, -2, +1, +0, +0, 0, 0x06,\n                 -2, +1, +0, +1, 0, 0x02, -2, +2, +0, +0, 1, 0x04, -2, +2, +0, +1, 0, 0x04, -1, -2, -1, +0, 0, -128,\n                 -1, -2, +0, -1, 0, 0x01, -1, -2, +1, -1, 0, 0x01, -1, -2, +1, +0, 1, 0x01, -1, -1, -1, +1, 0, -120,\n                 -1, -1, +1, -2, 0, 0x40, -1, -1, +1, -1, 0, 0x22, -1, -1, +1, +0, 0, 0x33, -1, -1, +1, +1, 1, 0x11,\n                 -1, +0, -1, +2, 0, 0x08, -1, +0, +0, -1, 0, 0x44, -1, +0, +0, +1, 0, 0x11, -1, +0, +1, -2, 1, 0x40,\n                 -1, +0, +1, -1, 0, 0x66, -1, +0, +1, +0, 1, 0x22, -1, +0, +1, +1, 0, 0x33, -1, +0, +1, +2, 1, 0x10,\n                 -1, +1, +1, -1, 1, 0x44, -1, +1, +1, +0, 0, 0x66, -1, +1, +1, +1, 0, 0x22, -1, +1, +1, +2, 0, 0x10,\n                 -1, +2, +0, +1, 0, 0x04, -1, +2, +1, +0, 1, 0x04, -1, +2, +1, +1, 0, 0x04, +0, -2, +0, +0, 1, -128,\n                 +0, -1, +0, +1, 1, -120, +0, -1, +1, -2, 0, 0x40, +0, -1, +1, +0, 0, 0x11, +0, -1, +2, -2, 0, 0x40,\n                 +0, -1, +2, -1, 0, 0x20, +0, -1, +2, +0, 0, 0x30, +0, -1, +2, +1, 1, 0x10, +0, +0, +0, +2, 1, 0x08,\n                 +0, +0, +2, -2, 1, 0x40, +0, +0, +2, -1, 0, 0x60, +0, +0, +2, +0, 1, 0x20, +0, +0, +2, +1, 0, 0x30,\n                 +0, +0, +2, +2, 1, 0x10, +0, +1, +1, +0, 0, 0x44, +0, +1, +1, +2, 0, 0x10, +0, +1, +2, -1, 1, 0x40,\n                 +0, +1, +2, +0, 0, 0x60, +0, +1, +2, +1, 0, 0x20, +0, +1, +2, +2, 0, 0x10, +1, -2, +1, +0, 0, -128,\n                 +1, -1, +1, +1, 0, -120, +1, +0, +1, +2, 0, 0x08, +1, +0, +2, -1, 0, 0x40, +1, +0, +2, +1, 0, 0x10},\n      chood[] = {-1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1};\n  ushort(*brow[5])[4], *pix;\n  int prow = 8, pcol = 2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];\n  int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;\n  int g, diff, thold, num, c;\n\n  lin_interpolate();\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"VNG interpolation...\\n\"));\n#endif\n\n  if (filters == 1)\n    prow = pcol = 16;\n  if (filters == 9)\n    prow = pcol = 6;\n  ip = (int *)calloc(prow * pcol, 1280);\n  merror(ip, \"vng_interpolate()\");\n  for (row = 0; row < prow; row++) /* Precalculate for VNG */\n    for (col = 0; col < pcol; col++)\n    {\n      code[row][col] = ip;\n      for (cp = terms, t = 0; t < 64; t++)\n      {\n        y1 = *cp++;\n        x1 = *cp++;\n        y2 = *cp++;\n        x2 = *cp++;\n        weight = *cp++;\n        grads = *cp++;\n        color = fcol(row + y1, col + x1);\n        if (fcol(row + y2, col + x2) != color)\n          continue;\n        diag = (fcol(row, col + 1) == color && fcol(row + 1, col) == color) ? 2 : 1;\n        if (abs(y1 - y2) == diag && abs(x1 - x2) == diag)\n          continue;\n        *ip++ = (y1 * width + x1) * 4 + color;\n        *ip++ = (y2 * width + x2) * 4 + color;\n        *ip++ = weight;\n        for (g = 0; g < 8; g++)\n          if (grads & 1 << g)\n            *ip++ = g;\n        *ip++ = -1;\n      }\n      *ip++ = INT_MAX;\n      for (cp = chood, g = 0; g < 8; g++)\n      {\n        y = *cp++;\n        x = *cp++;\n        *ip++ = (y * width + x) * 4;\n        color = fcol(row, col);\n        if (fcol(row + y, col + x) != color && fcol(row + y * 2, col + x * 2) == color)\n          *ip++ = (y * width + x) * 8 + color;\n        else\n          *ip++ = 0;\n      }\n    }\n  brow[4] = (ushort(*)[4])calloc(width * 3, sizeof **brow);\n  merror(brow[4], \"vng_interpolate()\");\n  for (row = 0; row < 3; row++)\n    brow[row] = brow[4] + row * width;\n  for (row = 2; row < height - 2; row++)\n  { /* Do VNG interpolation */\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!((row - 2) % 256))\n      RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, (row - 2) / 256 + 1, ((height - 3) / 256) + 1);\n#endif\n    for (col = 2; col < width - 2; col++)\n    {\n      pix = image[row * width + col];\n      ip = code[row % prow][col % pcol];\n      memset(gval, 0, sizeof gval);\n      while ((g = ip[0]) != INT_MAX)\n      { /* Calculate gradients */\n        diff = ABS(pix[g] - pix[ip[1]]) << ip[2];\n        gval[ip[3]] += diff;\n        ip += 5;\n        if ((g = ip[-1]) == -1)\n          continue;\n        gval[g] += diff;\n        while ((g = *ip++) != -1)\n          gval[g] += diff;\n      }\n      ip++;\n      gmin = gmax = gval[0]; /* Choose a threshold */\n      for (g = 1; g < 8; g++)\n      {\n        if (gmin > gval[g])\n          gmin = gval[g];\n        if (gmax < gval[g])\n          gmax = gval[g];\n      }\n      if (gmax == 0)\n      {\n        memcpy(brow[2][col], pix, sizeof *image);\n        continue;\n      }\n      thold = gmin + (gmax >> 1);\n      memset(sum, 0, sizeof sum);\n      color = fcol(row, col);\n      for (num = g = 0; g < 8; g++, ip += 2)\n      { /* Average the neighbors */\n        if (gval[g] <= thold)\n        {\n          FORCC\n          if (c == color && ip[1])\n            sum[c] += (pix[c] + pix[ip[1]]) >> 1;\n          else\n            sum[c] += pix[ip[0] + c];\n          num++;\n        }\n      }\n      FORCC\n      { /* Save to buffer */\n        t = pix[color];\n        if (c != color)\n          t += (sum[c] - sum[color]) / num;\n        brow[2][col][c] = CLIP(t);\n      }\n    }\n    if (row > 3) /* Write buffer to image */\n      memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n    for (g = 0; g < 4; g++)\n      brow[(g - 1) & 3] = brow[g];\n  }\n  memcpy(image[(row - 2) * width + 2], brow[0] + 2, (width - 4) * sizeof *image);\n  memcpy(image[(row - 1) * width + 2], brow[1] + 2, (width - 4) * sizeof *image);\n  free(brow[4]);\n  free(code[0][0]);\n}\n\n/*\n   Patterned Pixel Grouping Interpolation by Alain Desbiolles\n*/\nvoid CLASS ppg_interpolate()\n{\n  int dir[5] = {1, width, -1, -width, 1};\n  int row, col, diff[2], guess[2], c, d, i;\n  ushort(*pix)[4];\n\n  border_interpolate(3);\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"PPG interpolation...\\n\"));\n#endif\n\n/*  Fill in the green layer with gradients and pattern recognition: */\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 0, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 3; row < height - 3; row++)\n    for (col = 3 + (FC(row, 3) & 1), c = FC(row, col); col < width - 3; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; i++)\n      {\n        guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2 - pix[-2 * d][c] - pix[2 * d][c];\n        diff[i] = (ABS(pix[-2 * d][c] - pix[0][c]) + ABS(pix[2 * d][c] - pix[0][c]) + ABS(pix[-d][1] - pix[d][1])) * 3 +\n                  (ABS(pix[3 * d][1] - pix[d][1]) + ABS(pix[-3 * d][1] - pix[-d][1])) * 2;\n      }\n      d = dir[i = diff[0] > diff[1]];\n      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);\n    }\n/*  Calculate red and blue for each green pixel:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 1, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 2) & 1), c = FC(row, col + 1); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i]) > 0; c = 2 - c, i++)\n        pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1]) >> 1);\n    }\n/*  Calculate blue for red pixels and vice versa:\t\t*/\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_INTERPOLATE, 2, 3);\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel for default(shared) private(guess, diff, row, col, d, c, i, pix) schedule(static)\n#endif\n#endif\n  for (row = 1; row < height - 1; row++)\n    for (col = 1 + (FC(row, 1) & 1), c = 2 - FC(row, col); col < width - 1; col += 2)\n    {\n      pix = image + row * width + col;\n      for (i = 0; (d = dir[i] + dir[i + 1]) > 0; i++)\n      {\n        diff[i] = ABS(pix[-d][c] - pix[d][c]) + ABS(pix[-d][1] - pix[0][1]) + ABS(pix[d][1] - pix[0][1]);\n        guess[i] = pix[-d][c] + pix[d][c] + 2 * pix[0][1] - pix[-d][1] - pix[d][1];\n      }\n      if (diff[0] != diff[1])\n        pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);\n      else\n        pix[0][c] = CLIP((guess[0] + guess[1]) >> 2);\n    }\n}\n\nvoid CLASS cielab(ushort rgb[3], short lab[3])\n{\n  int c, i, j, k;\n  float r, xyz[3];\n#ifdef LIBRAW_NOTHREADS\n  static float cbrt[0x10000], xyz_cam[3][4];\n#else\n#define cbrt tls->ahd_data.cbrt\n#define xyz_cam tls->ahd_data.xyz_cam\n#endif\n\n  if (!rgb)\n  {\n#ifndef LIBRAW_NOTHREADS\n    if (cbrt[0] < -1.0f)\n#endif\n      for (i = 0; i < 0x10000; i++)\n      {\n        r = i / 65535.0;\n        cbrt[i] = r > 0.008856 ? pow(r, 1.f / 3.0f) : 7.787f * r + 16.f / 116.0f;\n      }\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (xyz_cam[i][j] = k = 0; k < 3; k++)\n          xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];\n    return;\n  }\n  xyz[0] = xyz[1] = xyz[2] = 0.5;\n  FORCC\n  {\n    xyz[0] += xyz_cam[0][c] * rgb[c];\n    xyz[1] += xyz_cam[1][c] * rgb[c];\n    xyz[2] += xyz_cam[2][c] * rgb[c];\n  }\n  xyz[0] = cbrt[CLIP((int)xyz[0])];\n  xyz[1] = cbrt[CLIP((int)xyz[1])];\n  xyz[2] = cbrt[CLIP((int)xyz[2])];\n  lab[0] = 64 * (116 * xyz[1] - 16);\n  lab[1] = 64 * 500 * (xyz[0] - xyz[1]);\n  lab[2] = 64 * 200 * (xyz[1] - xyz[2]);\n#ifndef LIBRAW_NOTHREADS\n#undef cbrt\n#undef xyz_cam\n#endif\n}\n\n#define TS 512 /* Tile Size */\n#define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]\n\n/*\n   Frank Markesteijn's algorithm for Fuji X-Trans sensors\n */\nvoid CLASS xtrans_interpolate(int passes)\n{\n  int c, d, f, g, h, i, v, ng, row, col, top, left, mrow, mcol;\n  int val, ndir, pass, hm[8], avg[4], color[3][8];\n  static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},\n                     patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0},\n                                    {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1}},\n                     dir[4] = {1, TS, TS + 1, TS - 1};\n  short allhex[3][3][2][8], *hex;\n  ushort min, max, sgrow, sgcol;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n        {\n          val = pix[hex[c]][1];\n          if (min > val)\n            min = val;\n          if (max < val)\n            max = val;\n        }\n      pix[0][1] = min;\n      pix[0][3] = max;\n      switch ((row - sgrow) % 3)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n          row--;\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n          memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);\n      FORC3 memcpy(rgb[c + 1], rgb[0], sizeof *rgb);\n\n      /* Interpolate green horizontally, vertically, and along both diagonals: */\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)\n        {\n          if ((f = fcol(row, col)) == 1)\n            continue;\n          pix = image + row * width + col;\n          hex = allhex[row % 3][col % 3][0];\n          color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) - 46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);\n          color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 + 92 * (pix[0][f] - pix[-hex[2]][f]);\n          FORC(2)\n          color[1][2 + c] = 164 * pix[hex[4 + c]][1] + 92 * pix[-2 * hex[4 + c]][1] +\n                            33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);\n          FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] = LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);\n        }\n\n      for (pass = 0; pass < passes; pass++)\n      {\n        if (pass == 1)\n          memcpy(rgb += 4, buffer, 4 * sizeof *rgb);\n\n        /* Recalculate green from interpolated values of closer pixels:\t*/\n        if (pass)\n        {\n          for (row = top + 2; row < mrow - 2; row++)\n            for (col = left + 2; col < mcol - 2; col++)\n            {\n              if ((f = fcol(row, col)) == 1)\n                continue;\n              pix = image + row * width + col;\n              hex = allhex[row % 3][col % 3][1];\n              for (d = 3; d < 6; d++)\n              {\n                rix = &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];\n                val =\n                    rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] - rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];\n                rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);\n              }\n            }\n        }\n\n        /* Interpolate red and blue values for solitary green pixels:\t*/\n        for (row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)\n          for (col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)\n          {\n            rix = &rgb[0][row - top][col - left];\n            h = fcol(row, col + 1);\n            memset(diff, 0, sizeof diff);\n            for (i = 1, d = 0; d < 6; d++, i ^= TS ^ 1, h ^= 2)\n            {\n              for (c = 0; c < 2; c++, h ^= 2)\n              {\n                g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];\n                color[h][d] = g + rix[i << c][h] + rix[-i << c][h];\n                if (d > 1)\n                  diff[d] += SQR(rix[i << c][1] - rix[-i << c][1] - rix[i << c][h] + rix[-i << c][h]) + SQR(g);\n              }\n              if (d > 1 && (d & 1))\n                if (diff[d - 1] < diff[d])\n                  FORC(2) color[c * 2][d] = color[c * 2][d - 1];\n              if (d < 2 || (d & 1))\n              {\n                FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);\n                rix += TS * TS;\n              }\n            }\n          }\n\n        /* Interpolate red for blue pixels and vice versa:\t\t*/\n        for (row = top + 3; row < mrow - 3; row++)\n          for (col = left + 3; col < mcol - 3; col++)\n          {\n            if ((f = 2 - fcol(row, col)) == 1)\n              continue;\n            rix = &rgb[0][row - top][col - left];\n            c = (row - sgrow) % 3 ? TS : 1;\n            h = 3 * (c ^ TS ^ 1);\n            for (d = 0; d < 4; d++, rix += TS * TS)\n            {\n              i = d > 1 || ((d ^ c) & 1) || ((ABS(rix[0][1] - rix[c][1]) + ABS(rix[0][1] - rix[-c][1])) <\n                                             2 * (ABS(rix[0][1] - rix[h][1]) + ABS(rix[0][1] - rix[-h][1])))\n                      ? c\n                      : h;\n              rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] - rix[i][1] - rix[-i][1]) / 2);\n            }\n          }\n\n        /* Fill in red and blue for 2x2 blocks of green:\t\t*/\n        for (row = top + 2; row < mrow - 2; row++)\n          if ((row - sgrow) % 3)\n            for (col = left + 2; col < mcol - 2; col++)\n              if ((col - sgcol) % 3)\n              {\n                rix = &rgb[0][row - top][col - left];\n                hex = allhex[row % 3][col % 3][1];\n                for (d = 0; d < ndir; d += 2, rix += TS * TS)\n                  if (hex[d] + hex[d + 1])\n                  {\n                    g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);\n                  }\n                  else\n                  {\n                    g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];\n                    for (c = 0; c < 4; c += 2)\n                      rix[0][c] = CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);\n                  }\n              }\n      }\n      rgb = (ushort(*)[TS][TS][3])buffer;\n      mrow -= top;\n      mcol -= left;\n\n      /* Convert to CIELab and differentiate in all directions:\t*/\n      for (d = 0; d < ndir; d++)\n      {\n        for (row = 2; row < mrow - 2; row++)\n          for (col = 2; col < mcol - 2; col++)\n            cielab(rgb[d][row][col], lab[row][col]);\n        for (f = dir[d & 3], row = 3; row < mrow - 3; row++)\n          for (col = 3; col < mcol - 3; col++)\n          {\n            lix = &lab[row][col];\n            g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];\n            drv[d][row][col] = SQR(g) + SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +\n                               SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));\n          }\n      }\n\n      /* Build homogeneity maps from the derivatives:\t\t\t*/\n      memset(homo, 0, ndir * TS * TS);\n      for (row = 4; row < mrow - 4; row++)\n        for (col = 4; col < mcol - 4; col++)\n        {\n          for (tr = FLT_MAX, d = 0; d < ndir; d++)\n            if (tr > drv[d][row][col])\n              tr = drv[d][row][col];\n          tr *= 8;\n          for (d = 0; d < ndir; d++)\n            for (v = -1; v <= 1; v++)\n              for (h = -1; h <= 1; h++)\n                if (drv[d][row + v][col + h] <= tr)\n                  homo[d][row][col]++;\n        }\n\n      /* Average the most homogenous pixels for the final result:\t*/\n      if (height - top < TS + 4)\n        mrow = height - top + 2;\n      if (width - left < TS + 4)\n        mcol = width - left + 2;\n      for (row = MIN(top, 8); row < mrow - 8; row++)\n        for (col = MIN(left, 8); col < mcol - 8; col++)\n        {\n          for (d = 0; d < ndir; d++)\n            for (hm[d] = 0, v = -2; v <= 2; v++)\n              for (h = -2; h <= 2; h++)\n                hm[d] += homo[d][row + v][col + h];\n          for (d = 0; d < ndir - 4; d++)\n            if (hm[d] < hm[d + 4])\n              hm[d] = 0;\n            else if (hm[d] > hm[d + 4])\n              hm[d + 4] = 0;\n          for (max = hm[0], d = 1; d < ndir; d++)\n            if (max < hm[d])\n              max = hm[d];\n          max -= max >> 3;\n          memset(avg, 0, sizeof avg);\n          for (d = 0; d < ndir; d++)\n            if (hm[d] >= max)\n            {\n              FORC3 avg[c] += rgb[d][row][col][c];\n              avg[3]++;\n            }\n          FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];\n        }\n    }\n  free(buffer);\n  border_interpolate(8);\n}\n#undef fcol\n\n/*\n   Adaptive Homogeneity-Directed interpolation is based on\n   the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.\n */\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + TS, height - 2);\n  const int collimit = MIN(left + TS, width - 2);\n\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n      out_rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3],\n                                                                short (*out_lab)[TS][3])\n{\n  unsigned row, col;\n  int c, val;\n  ushort(*pix)[4];\n  ushort(*rix)[3];\n  short(*lix)[3];\n  float xyz[3];\n  const unsigned num_pix_per_row = 4 * width;\n  const unsigned rowlimit = MIN(top + TS - 1, height - 3);\n  const unsigned collimit = MIN(left + TS - 1, width - 3);\n  ushort *pix_above;\n  ushort *pix_below;\n  int t1, t2;\n\n  for (row = top + 1; row < rowlimit; row++)\n  {\n    pix = image + row * width + left;\n    rix = &inout_rgb[row - top][0];\n    lix = &out_lab[row - top][0];\n\n    for (col = left + 1; col < collimit; col++)\n    {\n      pix++;\n      pix_above = &pix[0][0] - num_pix_per_row;\n      pix_below = &pix[0][0] + num_pix_per_row;\n      rix++;\n      lix++;\n\n      c = 2 - FC(row, col);\n\n      if (c == 1)\n      {\n        c = FC(row + 1, col);\n        t1 = 2 - c;\n        val = pix[0][1] + ((pix[-1][t1] + pix[1][t1] - rix[-1][1] - rix[1][1]) >> 1);\n        rix[0][t1] = CLIP(val);\n        val = pix[0][1] + ((pix_above[c] + pix_below[c] - rix[-TS][1] - rix[TS][1]) >> 1);\n      }\n      else\n      {\n        t1 = -4 + c; /* -4+c: pixel of color c to the left */\n        t2 = 4 + c;  /* 4+c: pixel of color c to the right */\n        val = rix[0][1] + ((pix_above[t1] + pix_above[t2] + pix_below[t1] + pix_below[t2] - rix[-TS - 1][1] -\n                            rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                           2);\n      }\n      rix[0][c] = CLIP(val);\n      c = FC(row, col);\n      rix[0][c] = pix[0][c];\n      cielab(rix[0], lix[0]);\n    }\n  }\n}\nvoid CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3],\n                                                         short (*out_lab)[TS][TS][3])\n{\n  int direction;\n  for (direction = 0; direction < 2; direction++)\n  {\n    ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction]);\n  }\n}\n\nvoid CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3],\n                                                 char (*out_homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int direction;\n  int i;\n  short(*lix)[3];\n  short(*lixs[2])[3];\n  short *adjacent_lix;\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  static const int dir[4] = {-1, 1, -TS, TS};\n  const int rowlimit = MIN(top + TS - 2, height - 4);\n  const int collimit = MIN(left + TS - 2, width - 4);\n  int homogeneity;\n  char(*homogeneity_map_p)[2];\n\n  memset(out_homogeneity_map, 0, 2 * TS * TS);\n\n  for (row = top + 2; row < rowlimit; row++)\n  {\n    tr = row - top;\n    homogeneity_map_p = &out_homogeneity_map[tr][1];\n    for (direction = 0; direction < 2; direction++)\n    {\n      lixs[direction] = &lab[direction][tr][1];\n    }\n\n    for (col = left + 2; col < collimit; col++)\n    {\n      tc = col - left;\n      homogeneity_map_p++;\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        lix = ++lixs[direction];\n        for (i = 0; i < 4; i++)\n        {\n          adjacent_lix = lix[dir[i]];\n          ldiff[direction][i] = ABS(lix[0][0] - adjacent_lix[0]);\n          abdiff[direction][i] = SQR(lix[0][1] - adjacent_lix[1]) + SQR(lix[0][2] - adjacent_lix[2]);\n        }\n      }\n      leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n      abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n      for (direction = 0; direction < 2; direction++)\n      {\n        homogeneity = 0;\n        for (i = 0; i < 4; i++)\n        {\n          if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps)\n          {\n            homogeneity++;\n          }\n        }\n        homogeneity_map_p[0][direction] = homogeneity;\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3],\n                                                      char (*homogeneity_map)[TS][2])\n{\n  int row, col;\n  int tr, tc;\n  int i, j;\n  int direction;\n  int hm[2];\n  int c;\n  const int rowlimit = MIN(top + TS - 3, height - 5);\n  const int collimit = MIN(left + TS - 3, width - 5);\n\n  ushort(*pix)[4];\n  ushort(*rix[2])[3];\n\n  for (row = top + 3; row < rowlimit; row++)\n  {\n    tr = row - top;\n    pix = &image[row * width + left + 2];\n    for (direction = 0; direction < 2; direction++)\n    {\n      rix[direction] = &rgb[direction][tr][2];\n    }\n\n    for (col = left + 3; col < collimit; col++)\n    {\n      tc = col - left;\n      pix++;\n      for (direction = 0; direction < 2; direction++)\n      {\n        rix[direction]++;\n      }\n\n      for (direction = 0; direction < 2; direction++)\n      {\n        hm[direction] = 0;\n        for (i = tr - 1; i <= tr + 1; i++)\n        {\n          for (j = tc - 1; j <= tc + 1; j++)\n          {\n            hm[direction] += homogeneity_map[i][j][direction];\n          }\n        }\n      }\n      if (hm[0] != hm[1])\n      {\n        memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));\n      }\n      else\n      {\n        FORC3 { pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1; }\n      }\n    }\n  }\n}\nvoid CLASS ahd_interpolate()\n{\n  int i, j, k, top, left;\n  float xyz_cam[3][4], r;\n  char *buffer;\n  ushort(*rgb)[TS][TS][3];\n  short(*lab)[TS][TS][3];\n  char(*homo)[TS][2];\n  int terminate_flag = 0;\n\n  cielab(0, 0);\n  border_interpolate(5);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp parallel private(buffer, rgb, lab, homo, top, left, i, j, k) shared(xyz_cam, terminate_flag)\n#endif\n#endif\n  {\n    buffer = (char *)malloc(26 * TS * TS); /* 1664 kB */\n    merror(buffer, \"ahd_interpolate()\");\n    rgb = (ushort(*)[TS][TS][3])buffer;\n    lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n    homo = (char(*)[TS][2])(buffer + 24 * TS * TS);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n#pragma omp for schedule(dynamic)\n#endif\n#endif\n    for (top = 2; top < height - 5; top += TS - 6)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_USE_OPENMP\n      if (0 == omp_get_thread_num())\n#endif\n        if (callbacks.progress_cb)\n        {\n          int rr =\n              (*callbacks.progress_cb)(callbacks.progresscb_data, LIBRAW_PROGRESS_INTERPOLATE, top - 2, height - 7);\n          if (rr)\n            terminate_flag = 1;\n        }\n#endif\n      for (left = 2; !terminate_flag && (left < width - 5); left += TS - 6)\n      {\n        ahd_interpolate_green_h_and_v(top, left, rgb);\n        ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab);\n        ahd_interpolate_build_homogeneity_map(top, left, lab, homo);\n        ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);\n      }\n    }\n    free(buffer);\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (terminate_flag)\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\n#else\nvoid CLASS ahd_interpolate()\n{\n  int i, j, top, left, row, col, tr, tc, c, d, val, hm[2];\n  static const int dir[4] = {-1, 1, -TS, TS};\n  unsigned ldiff[2][4], abdiff[2][4], leps, abeps;\n  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][TS][3], (*lix)[3];\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"AHD interpolation...\\n\"));\n#endif\n\n  cielab(0, 0);\n  border_interpolate(5);\n  buffer = (char *)malloc(26 * TS * TS);\n  merror(buffer, \"ahd_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][TS][3])(buffer + 12 * TS * TS);\n  homo = (char(*)[TS][TS])(buffer + 24 * TS * TS);\n\n  for (top = 2; top < height - 5; top += TS - 6)\n    for (left = 2; left < width - 5; left += TS - 6)\n    {\n\n      /*  Interpolate green horizontally and vertically:\t\t*/\n      for (row = top; row < top + TS && row < height - 2; row++)\n      {\n        col = left + (FC(row, left) & 1);\n        for (c = FC(row, col); col < left + TS && col < width - 2; col += 2)\n        {\n          pix = image + row * width + col;\n          val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >> 2;\n          rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n          val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 - pix[-2 * width][c] - pix[2 * width][c]) >> 2;\n          rgb[1][row - top][col - left][1] = ULIM(val, pix[-width][1], pix[width][1]);\n        }\n      }\n\n      /*  Interpolate red and blue, and convert to CIELab:\t\t*/\n      for (d = 0; d < 2; d++)\n        for (row = top + 1; row < top + TS - 1 && row < height - 3; row++)\n          for (col = left + 1; col < left + TS - 1 && col < width - 3; col++)\n          {\n            pix = image + row * width + col;\n            rix = &rgb[d][row - top][col - left];\n            lix = &lab[d][row - top][col - left];\n            if ((c = 2 - FC(row, col)) == 1)\n            {\n              c = FC(row + 1, col);\n              val = pix[0][1] + ((pix[-1][2 - c] + pix[1][2 - c] - rix[-1][1] - rix[1][1]) >> 1);\n              rix[0][2 - c] = CLIP(val);\n              val = pix[0][1] + ((pix[-width][c] + pix[width][c] - rix[-TS][1] - rix[TS][1]) >> 1);\n            }\n            else\n              val = rix[0][1] + ((pix[-width - 1][c] + pix[-width + 1][c] + pix[+width - 1][c] + pix[+width + 1][c] -\n                                  rix[-TS - 1][1] - rix[-TS + 1][1] - rix[+TS - 1][1] - rix[+TS + 1][1] + 1) >>\n                                 2);\n            rix[0][c] = CLIP(val);\n            c = FC(row, col);\n            rix[0][c] = pix[0][c];\n            cielab(rix[0], lix[0]);\n          }\n      /*  Build homogeneity maps from the CIELab images:\t\t*/\n      memset(homo, 0, 2 * TS * TS);\n      for (row = top + 2; row < top + TS - 2 && row < height - 4; row++)\n      {\n        tr = row - top;\n        for (col = left + 2; col < left + TS - 2 && col < width - 4; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n          {\n            lix = &lab[d][tr][tc];\n            for (i = 0; i < 4; i++)\n            {\n              ldiff[d][i] = ABS(lix[0][0] - lix[dir[i]][0]);\n              abdiff[d][i] = SQR(lix[0][1] - lix[dir[i]][1]) + SQR(lix[0][2] - lix[dir[i]][2]);\n            }\n          }\n          leps = MIN(MAX(ldiff[0][0], ldiff[0][1]), MAX(ldiff[1][2], ldiff[1][3]));\n          abeps = MIN(MAX(abdiff[0][0], abdiff[0][1]), MAX(abdiff[1][2], abdiff[1][3]));\n          for (d = 0; d < 2; d++)\n            for (i = 0; i < 4; i++)\n              if (ldiff[d][i] <= leps && abdiff[d][i] <= abeps)\n                homo[d][tr][tc]++;\n        }\n      }\n      /*  Combine the most homogenous pixels for the final result:\t*/\n      for (row = top + 3; row < top + TS - 3 && row < height - 5; row++)\n      {\n        tr = row - top;\n        for (col = left + 3; col < left + TS - 3 && col < width - 5; col++)\n        {\n          tc = col - left;\n          for (d = 0; d < 2; d++)\n            for (hm[d] = 0, i = tr - 1; i <= tr + 1; i++)\n              for (j = tc - 1; j <= tc + 1; j++)\n                hm[d] += homo[d][i][j];\n          if (hm[0] != hm[1])\n            FORC3 image[row * width + col][c] = rgb[hm[1] > hm[0]][tr][tc][c];\n          else\n            FORC3 image[row * width + col][c] = (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) >> 1;\n        }\n      }\n    }\n  free(buffer);\n}\n#endif\n#undef TS\n\nvoid CLASS median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = /* Optimal 9-element median search */\n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n#endif\n#ifdef DCRAW_VERBOSE\n    if (verbose)\n      fprintf(stderr, _(\"Median filter pass %d...\\n\"), pass);\n#endif\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}\n\nvoid CLASS blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {{{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n                                       {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {{{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n                                        {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n\n  if ((unsigned)(colors - 3) > 1)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Blending highlights...\\n\"));\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n#endif\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] += trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] += itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n#endif\n}\n\n#define SCALE (4 >> shrink)\nvoid CLASS recover_highlights()\n{\n  float *map, sum, wgt, grow;\n  int hsat[4], count, spread, change, val, i;\n  unsigned high, wide, mrow, mcol, row, col, kc, c, d, y, x;\n  ushort *pixel;\n  static const signed char dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rebuilding highlights...\\n\"));\n#endif\n\n  grow = pow(2.0, 4 - highlight);\n  FORCC hsat[c] = 32000 * pre_mul[c];\n  for (kc = 0, c = 1; c < colors; c++)\n    if (pre_mul[kc] < pre_mul[c])\n      kc = c;\n  high = height / SCALE;\n  wide = width / SCALE;\n  map = (float *)calloc(high, wide * sizeof *map);\n  merror(map, \"recover_highlights()\");\n  FORCC if (c != kc)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, c - 1, colors - 1);\n#endif\n    memset(map, 0, high * wide * sizeof *map);\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        sum = wgt = count = 0;\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] == 1 && pixel[kc] > 24000)\n            {\n              sum += pixel[c];\n              wgt += pixel[kc];\n              count++;\n            }\n          }\n        if (count == SCALE * SCALE)\n          map[mrow * wide + mcol] = sum / wgt;\n      }\n    for (spread = 32 / grow; spread--;)\n    {\n      for (mrow = 0; mrow < high; mrow++)\n        for (mcol = 0; mcol < wide; mcol++)\n        {\n          if (map[mrow * wide + mcol])\n            continue;\n          sum = count = 0;\n          for (d = 0; d < 8; d++)\n          {\n            y = mrow + dir[d][0];\n            x = mcol + dir[d][1];\n            if (y < high && x < wide && map[y * wide + x] > 0)\n            {\n              sum += (1 + (d & 1)) * map[y * wide + x];\n              count += 1 + (d & 1);\n            }\n          }\n          if (count > 3)\n            map[mrow * wide + mcol] = -(sum + grow) / (count + grow);\n        }\n      for (change = i = 0; i < high * wide; i++)\n        if (map[i] < 0)\n        {\n          map[i] = -map[i];\n          change = 1;\n        }\n      if (!change)\n        break;\n    }\n    for (i = 0; i < high * wide; i++)\n      if (map[i] == 0)\n        map[i] = 1;\n    for (mrow = 0; mrow < high; mrow++)\n      for (mcol = 0; mcol < wide; mcol++)\n      {\n        for (row = mrow * SCALE; row < (mrow + 1) * SCALE; row++)\n          for (col = mcol * SCALE; col < (mcol + 1) * SCALE; col++)\n          {\n            pixel = image[row * width + col];\n            if (pixel[c] / hsat[c] > 1)\n            {\n              val = pixel[kc] * map[mrow * wide + mcol];\n              if (pixel[c] < val)\n                pixel[c] = CLIP(val);\n            }\n          }\n      }\n  }\n  free(map);\n}\n#undef SCALE\n\nvoid CLASS tiff_get(unsigned base, unsigned *tag, unsigned *type, unsigned *len, unsigned *save)\n{\n  *tag = get2();\n  *type = get2();\n  *len = get4();\n  *save = ftell(ifp) + 4;\n  if (*len * (\"11124811248484\"[*type < 14 ? *type : 0] - '0') > 4)\n    fseek(ifp, get4() + base, SEEK_SET);\n}\n\nvoid CLASS parse_thumb_note(int base, unsigned toff, unsigned tlen)\n{\n  unsigned entries, tag, type, len, save;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == toff)\n      thumb_offset = get4() + base;\n    if (tag == tlen)\n      thumb_length = get4();\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nstatic float powf_lim(float a, float b, float limup) { return (b > limup || b < -limup) ? 0.f : powf(a, b); }\nstatic float powf64(float a, float b) { return powf_lim(a, b, 64.f); }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nstatic float my_roundf(float x)\n{\n  float t;\n  if (x >= 0.0)\n  {\n    t = ceilf(x);\n    if (t - x > 0.5)\n      t -= 1.0;\n    return t;\n  }\n  else\n  {\n    t = ceilf(-x);\n    if (t + x > 0.5)\n      t -= 1.0;\n    return -t;\n  }\n}\n\nstatic float _CanonConvertAperture(ushort in)\n{\n  if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))\n    return 0.0f;\n  return powf64(2.0, in / 64.0);\n}\n\nstatic float _CanonConvertEV(short in)\n{\n  short EV, Sign, Frac;\n  float Frac_f;\n  EV = in;\n  if (EV < 0)\n  {\n    EV = -EV;\n    Sign = -1;\n  }\n  else\n  {\n    Sign = 1;\n  }\n  Frac = EV & 0x1f;\n  EV -= Frac; // remove fraction\n\n  if (Frac == 0x0c)\n  { // convert 1/3 and 2/3 codes\n    Frac_f = 32.0f / 3.0f;\n  }\n  else if (Frac == 0x14)\n  {\n    Frac_f = 64.0f / 3.0f;\n  }\n  else\n    Frac_f = (float)Frac;\n\n  return ((float)Sign * ((float)EV + Frac_f)) / 32.0f;\n}\n\nvoid CLASS setCanonBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x80000001) || // 1D\n      (id == 0x80000174) || // 1D2\n      (id == 0x80000232) || // 1D2N\n      (id == 0x80000169) || // 1D3\n      (id == 0x80000281)    // 1D4\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSH;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000167) || // 1Ds\n           (id == 0x80000188) || // 1Ds2\n           (id == 0x80000215) || // 1Ds3\n           (id == 0x80000269) || // 1DX\n           (id == 0x80000328) || // 1DX2\n           (id == 0x80000324) || // 1DC\n           (id == 0x80000213) || // 5D\n           (id == 0x80000218) || // 5D2\n           (id == 0x80000285) || // 5D3\n           (id == 0x80000349) || // 5D4\n           (id == 0x80000382) || // 5DS\n           (id == 0x80000401) || // 5DS R\n           (id == 0x80000302)    // 6D\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n  }\n  else if ((id == 0x80000331) || // M\n           (id == 0x80000355) || // M2\n           (id == 0x80000374) || // M3\n           (id == 0x80000384) || // M10\n           (id == 0x80000394)    // M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF_M;\n  }\n  else if ((id == 0x01140000) || // D30\n           (id == 0x01668000) || // D60\n           (id > 0x80000000))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Canon_EF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Unknown;\n  }\n  else\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n  }\n\n  return;\n}\n\nvoid CLASS processCanonCameraInfo(unsigned id, uchar *CameraInfo, unsigned maxlen)\n{\n  ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0, iCanonLens = 0, iCanonCurFocal = 0,\n         iCanonFocalType = 0;\n  CameraInfo[0] = 0;\n  CameraInfo[1] = 0;\n  switch (id)\n  {\n  case 0x80000001: // 1D\n  case 0x80000167: // 1DS\n    iCanonCurFocal = 10;\n    iCanonLensID = 13;\n    iCanonMinFocal = 14;\n    iCanonMaxFocal = 16;\n    if (!imgdata.lens.makernotes.CurFocal)\n      imgdata.lens.makernotes.CurFocal = sget2(CameraInfo + iCanonCurFocal);\n    if (!imgdata.lens.makernotes.MinFocal)\n      imgdata.lens.makernotes.MinFocal = sget2(CameraInfo + iCanonMinFocal);\n    if (!imgdata.lens.makernotes.MaxFocal)\n      imgdata.lens.makernotes.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);\n    break;\n  case 0x80000174: // 1DMkII\n  case 0x80000188: // 1DsMkII\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    iCanonFocalType = 45;\n    break;\n  case 0x80000232: // 1DMkII N\n    iCanonCurFocal = 9;\n    iCanonLensID = 12;\n    iCanonMinFocal = 17;\n    iCanonMaxFocal = 19;\n    break;\n  case 0x80000169: // 1DMkIII\n  case 0x80000215: // 1DsMkIII\n    iCanonCurFocal = 29;\n    iCanonLensID = 273;\n    iCanonMinFocal = 275;\n    iCanonMaxFocal = 277;\n    break;\n  case 0x80000281: // 1DMkIV\n    iCanonCurFocal = 30;\n    iCanonLensID = 335;\n    iCanonMinFocal = 337;\n    iCanonMaxFocal = 339;\n    break;\n  case 0x80000269: // 1D X\n    iCanonCurFocal = 35;\n    iCanonLensID = 423;\n    iCanonMinFocal = 425;\n    iCanonMaxFocal = 427;\n    break;\n  case 0x80000213: // 5D\n    iCanonCurFocal = 40;\n    if (!sget2Rev(CameraInfo + 12))\n      iCanonLensID = 151;\n    else\n      iCanonLensID = 12;\n    iCanonMinFocal = 147;\n    iCanonMaxFocal = 149;\n    break;\n  case 0x80000218: // 5DMkII\n    iCanonCurFocal = 30;\n    iCanonLensID = 230;\n    iCanonMinFocal = 232;\n    iCanonMaxFocal = 234;\n    break;\n  case 0x80000285: // 5DMkIII\n    iCanonCurFocal = 35;\n    iCanonLensID = 339;\n    iCanonMinFocal = 341;\n    iCanonMaxFocal = 343;\n    break;\n  case 0x80000302: // 6D\n    iCanonCurFocal = 35;\n    iCanonLensID = 353;\n    iCanonMinFocal = 355;\n    iCanonMaxFocal = 357;\n    break;\n  case 0x80000250: // 7D\n    iCanonCurFocal = 30;\n    iCanonLensID = 274;\n    iCanonMinFocal = 276;\n    iCanonMaxFocal = 278;\n    break;\n  case 0x80000190: // 40D\n    iCanonCurFocal = 29;\n    iCanonLensID = 214;\n    iCanonMinFocal = 216;\n    iCanonMaxFocal = 218;\n    iCanonLens = 2347;\n    break;\n  case 0x80000261: // 50D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000287: // 60D\n    iCanonCurFocal = 30;\n    iCanonLensID = 232;\n    iCanonMinFocal = 234;\n    iCanonMaxFocal = 236;\n    break;\n  case 0x80000325: // 70D\n    iCanonCurFocal = 35;\n    iCanonLensID = 358;\n    iCanonMinFocal = 360;\n    iCanonMaxFocal = 362;\n    break;\n  case 0x80000176: // 450D\n    iCanonCurFocal = 29;\n    iCanonLensID = 222;\n    iCanonLens = 2355;\n    break;\n  case 0x80000252: // 500D\n    iCanonCurFocal = 30;\n    iCanonLensID = 246;\n    iCanonMinFocal = 248;\n    iCanonMaxFocal = 250;\n    break;\n  case 0x80000270: // 550D\n    iCanonCurFocal = 30;\n    iCanonLensID = 255;\n    iCanonMinFocal = 257;\n    iCanonMaxFocal = 259;\n    break;\n  case 0x80000286: // 600D\n  case 0x80000288: // 1100D\n    iCanonCurFocal = 30;\n    iCanonLensID = 234;\n    iCanonMinFocal = 236;\n    iCanonMaxFocal = 238;\n    break;\n  case 0x80000301: // 650D\n  case 0x80000326: // 700D\n    iCanonCurFocal = 35;\n    iCanonLensID = 295;\n    iCanonMinFocal = 297;\n    iCanonMaxFocal = 299;\n    break;\n  case 0x80000254: // 1000D\n    iCanonCurFocal = 29;\n    iCanonLensID = 226;\n    iCanonMinFocal = 228;\n    iCanonMaxFocal = 230;\n    iCanonLens = 2359;\n    break;\n  }\n  if (iCanonFocalType)\n  {\n    if (iCanonFocalType >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.FocalType = CameraInfo[iCanonFocalType];\n    if (!imgdata.lens.makernotes.FocalType) // zero means 'fixed' here, replacing with standard '1'\n      imgdata.lens.makernotes.FocalType = 1;\n  }\n  if (!imgdata.lens.makernotes.CurFocal)\n  {\n    if (iCanonCurFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);\n  }\n  if (!imgdata.lens.makernotes.LensID)\n  {\n    if (iCanonLensID >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.LensID = sget2Rev(CameraInfo + iCanonLensID);\n  }\n  if (!imgdata.lens.makernotes.MinFocal)\n  {\n    if (iCanonMinFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);\n  }\n  if (!imgdata.lens.makernotes.MaxFocal)\n  {\n    if (iCanonMaxFocal >= maxlen)\n      return; // broken;\n    imgdata.lens.makernotes.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);\n  }\n  if (!imgdata.lens.makernotes.Lens[0] && iCanonLens)\n  {\n    if (iCanonLens + 64 >= maxlen)\n      return;                        // broken;\n    if (CameraInfo[iCanonLens] < 65) // non-Canon lens\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 64);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-S\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-S \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"TS-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"TS-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"TS-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"MP-E\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"MP-E \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"MP-E\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else if (!strncmp((char *)CameraInfo + iCanonLens, \"EF-M\", 4))\n    {\n      memcpy(imgdata.lens.makernotes.Lens, \"EF-M \", 5);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF-M\", 4);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n      memcpy(imgdata.lens.makernotes.Lens + 5, CameraInfo + iCanonLens + 4, 60);\n    }\n    else\n    {\n      memcpy(imgdata.lens.makernotes.Lens, CameraInfo + iCanonLens, 2);\n      memcpy(imgdata.lens.makernotes.LensFeatures_pre, \"EF\", 2);\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n      imgdata.lens.makernotes.Lens[2] = 32;\n      memcpy(imgdata.lens.makernotes.Lens + 3, CameraInfo + iCanonLens + 2, 62);\n    }\n  }\n  return;\n}\n\nvoid CLASS Canon_CameraSettings()\n{\n  fseek(ifp, 10, SEEK_CUR);\n  imgdata.shootinginfo.DriveMode = get2();\n  get2();\n  imgdata.shootinginfo.FocusMode = get2();\n  fseek(ifp, 18, SEEK_CUR);\n  imgdata.shootinginfo.MeteringMode = get2();\n  get2();\n  imgdata.shootinginfo.AFPoint = get2();\n  imgdata.shootinginfo.ExposureMode = get2();\n  get2();\n  imgdata.lens.makernotes.LensID = get2();\n  imgdata.lens.makernotes.MaxFocal = get2();\n  imgdata.lens.makernotes.MinFocal = get2();\n  imgdata.lens.makernotes.CanonFocalUnits = get2();\n  if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n  {\n    imgdata.lens.makernotes.MaxFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    imgdata.lens.makernotes.MinFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n  }\n  imgdata.lens.makernotes.MaxAp = _CanonConvertAperture(get2());\n  imgdata.lens.makernotes.MinAp = _CanonConvertAperture(get2());\n  fseek(ifp, 12, SEEK_CUR);\n  imgdata.shootinginfo.ImageStabilization = get2();\n}\n\nvoid CLASS Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}\n\nvoid CLASS Canon_WBCTpresets(short WBCTversion)\n{\n  if (WBCTversion == 0)\n    for (int i = 0; i < 15; i++) // tint, as shot R, as shot B, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if (WBCTversion == 1)\n    for (int i = 0; i < 15; i++) // as shot R, as shot B, tint, C\u0421T\n    {\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(get2(), 1.f);\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(get2(), 1.f);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x80000374) || // M3\n                                  (unique_id == 0x80000384) || // M10\n                                  (unique_id == 0x80000394) || // M5\n                                  (unique_id == 0x03970000) || // G7 X Mark II\n                                  (unique_id == 0x04100000)))  // G9 X Mark II\n    for (int i = 0; i < 15; i++)                               // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][3] = 1024.0f / fMAX(1.f, get2());\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  else if ((WBCTversion == 2) && ((unique_id == 0x03950000) || (unique_id == 0x03930000))) // G5 X, G9 X\n    for (int i = 0; i < 15; i++) // tint, offset, as shot R, as shot B, C\u0421T\n    {\n      fseek(ifp, 2, SEEK_CUR);\n      fseek(ifp, 2, SEEK_CUR);\n      imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 1.0f;\n      imgdata.color.WBCT_Coeffs[i][1] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][3] = (float)get2() / 512.0f;\n      imgdata.color.WBCT_Coeffs[i][0] = get2();\n    }\n  return;\n}\n\nvoid CLASS processNikonLensData(uchar *LensData, unsigned len)\n{\n  ushort i;\n  if (!(imgdata.lens.nikon.NikonLensType & 0x01))\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'A';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensFeatures_pre[0] = 'M';\n    imgdata.lens.makernotes.LensFeatures_pre[1] = 'F';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x02)\n  {\n    if (imgdata.lens.nikon.NikonLensType & 0x04)\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'G';\n    else\n      imgdata.lens.makernotes.LensFeatures_suf[0] = 'D';\n    imgdata.lens.makernotes.LensFeatures_suf[1] = ' ';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x08)\n  {\n    imgdata.lens.makernotes.LensFeatures_suf[2] = 'V';\n    imgdata.lens.makernotes.LensFeatures_suf[3] = 'R';\n  }\n\n  if (imgdata.lens.nikon.NikonLensType & 0x10)\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_1INCH;\n  }\n  else\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_F;\n\n  if (imgdata.lens.nikon.NikonLensType & 0x20)\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"FT-1\");\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Nikon_F;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Nikon_CX;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  imgdata.lens.nikon.NikonLensType = imgdata.lens.nikon.NikonLensType & 0xdf;\n\n  if (len < 20)\n  {\n    switch (len)\n    {\n    case 9:\n      i = 2;\n      break;\n    case 15:\n      i = 7;\n      break;\n    case 16:\n      i = 8;\n      break;\n    }\n    imgdata.lens.nikon.NikonLensIDNumber = LensData[i];\n    imgdata.lens.nikon.NikonLensFStops = LensData[i + 1];\n    imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n    if (fabsf(imgdata.lens.makernotes.MinFocal) < 1.1f)\n    {\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 2])\n        imgdata.lens.makernotes.MinFocal = 5.0f * powf64(2.0f, (float)LensData[i + 2] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 3])\n        imgdata.lens.makernotes.MaxFocal = 5.0f * powf64(2.0f, (float)LensData[i + 3] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 4])\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(2.0f, (float)LensData[i + 4] / 24.0f);\n      if ((imgdata.lens.nikon.NikonLensType ^ (uchar)0x01) || LensData[i + 5])\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(2.0f, (float)LensData[i + 5] / 24.0f);\n    }\n    imgdata.lens.nikon.NikonMCUVersion = LensData[i + 6];\n    if (i != 2)\n    {\n      if ((LensData[i - 1]) && (fabsf(imgdata.lens.makernotes.CurFocal) < 1.1f))\n        imgdata.lens.makernotes.CurFocal = 5.0f * powf64(2.0f, (float)LensData[i - 1] / 24.0f);\n      if (LensData[i + 7])\n        imgdata.lens.nikon.NikonEffectiveMaxAp = powf64(2.0f, (float)LensData[i + 7] / 24.0f);\n    }\n    imgdata.lens.makernotes.LensID =\n        (unsigned long long)LensData[i] << 56 | (unsigned long long)LensData[i + 1] << 48 |\n        (unsigned long long)LensData[i + 2] << 40 | (unsigned long long)LensData[i + 3] << 32 |\n        (unsigned long long)LensData[i + 4] << 24 | (unsigned long long)LensData[i + 5] << 16 |\n        (unsigned long long)LensData[i + 6] << 8 | (unsigned long long)imgdata.lens.nikon.NikonLensType;\n  }\n  else if ((len == 459) || (len == 590))\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 390, 64);\n  }\n  else if (len == 509)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 391, 64);\n  }\n  else if (len == 879)\n  {\n    memcpy(imgdata.lens.makernotes.Lens, LensData + 680, 64);\n  }\n  return;\n}\n\nvoid CLASS setOlympusBodyFeatures(unsigned long long id)\n{\n  imgdata.lens.makernotes.CamID = id;\n  if ((id == 0x4434303430ULL) || // E-1\n      (id == 0x4434303431ULL) || // E-300\n      ((id & 0x00ffff0000ULL) == 0x0030300000ULL))\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FT;\n    if ((id == 0x4434303430ULL) ||                              // E-1\n        (id == 0x4434303431ULL) ||                              // E-330\n        ((id >= 0x5330303033ULL) && (id <= 0x5330303138ULL)) || // E-330 to E-520\n        (id == 0x5330303233ULL) ||                              // E-620\n        (id == 0x5330303239ULL) ||                              // E-450\n        (id == 0x5330303330ULL) ||                              // E-600\n        (id == 0x5330303333ULL))                                // E-5\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FT;\n    }\n    else\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_mFT;\n    }\n  }\n  else\n  {\n    imgdata.lens.makernotes.LensMount = imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS parseCanonMakernotes(unsigned tag, unsigned type, unsigned len)\n{\n\n  if (tag == 0x0001)\n    Canon_CameraSettings();\n  else if (tag == 0x0002) // focal length\n  {\n    imgdata.lens.makernotes.FocalType = get2();\n    imgdata.lens.makernotes.CurFocal = get2();\n    if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n    {\n      imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n    }\n  }\n\n  else if (tag == 0x0004) // shot info\n  {\n    short tempAp;\n    fseek(ifp, 30, SEEK_CUR);\n    imgdata.other.FlashEC = _CanonConvertEV((signed short)get2());\n    fseek(ifp, 8 - 32, SEEK_CUR);\n    if ((tempAp = get2()) != 0x7fff)\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(tempAp);\n    if (imgdata.lens.makernotes.CurAp < 0.7f)\n    {\n      fseek(ifp, 32, SEEK_CUR);\n      imgdata.lens.makernotes.CurAp = _CanonConvertAperture(get2());\n    }\n    if (!aperture)\n      aperture = imgdata.lens.makernotes.CurAp;\n  }\n\n  else if (tag == 0x0095 && // lens model tag\n           !imgdata.lens.makernotes.Lens[0])\n  {\n    fread(imgdata.lens.makernotes.Lens, 2, 1, ifp);\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    if (imgdata.lens.makernotes.Lens[0] < 65) // non-Canon lens\n      fread(imgdata.lens.makernotes.Lens + 2, 62, 1, ifp);\n    else\n    {\n      char efs[2];\n      imgdata.lens.makernotes.LensFeatures_pre[0] = imgdata.lens.makernotes.Lens[0];\n      imgdata.lens.makernotes.LensFeatures_pre[1] = imgdata.lens.makernotes.Lens[1];\n      fread(efs, 2, 1, ifp);\n      if (efs[0] == 45 && (efs[1] == 83 || efs[1] == 69 || efs[1] == 77))\n      { // \"EF-S, TS-E, MP-E, EF-M\" lenses\n        imgdata.lens.makernotes.Lens[2] = imgdata.lens.makernotes.LensFeatures_pre[2] = efs[0];\n        imgdata.lens.makernotes.Lens[3] = imgdata.lens.makernotes.LensFeatures_pre[3] = efs[1];\n        imgdata.lens.makernotes.Lens[4] = 32;\n        if (efs[1] == 83)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_S;\n          imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n        }\n        else if (efs[1] == 77)\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF_M;\n        }\n      }\n      else\n      { // \"EF\" lenses\n        imgdata.lens.makernotes.Lens[2] = 32;\n        imgdata.lens.makernotes.Lens[3] = efs[0];\n        imgdata.lens.makernotes.Lens[4] = efs[1];\n      }\n      fread(imgdata.lens.makernotes.Lens + 5, 58, 1, ifp);\n    }\n  }\n\n  else if (tag == 0x00a9)\n  {\n    long int save1 = ftell(ifp);\n    fseek(ifp, save1 + (0x5 << 1), SEEK_SET);\n    Canon_WBpresets(0, 0);\n    fseek(ifp, save1, SEEK_SET);\n  }\n\n  else if (tag == 0x00e0) // sensor info\n  {\n    imgdata.makernotes.canon.SensorWidth = (get2(), get2());\n    imgdata.makernotes.canon.SensorHeight = get2();\n    imgdata.makernotes.canon.SensorLeftBorder = (get2(), get2(), get2());\n    imgdata.makernotes.canon.SensorTopBorder = get2();\n    imgdata.makernotes.canon.SensorRightBorder = get2();\n    imgdata.makernotes.canon.SensorBottomBorder = get2();\n    imgdata.makernotes.canon.BlackMaskLeftBorder = get2();\n    imgdata.makernotes.canon.BlackMaskTopBorder = get2();\n    imgdata.makernotes.canon.BlackMaskRightBorder = get2();\n    imgdata.makernotes.canon.BlackMaskBottomBorder = get2();\n  }\n\n  else if (tag == 0x4001 && len > 500)\n  {\n    int c;\n    long int save1 = ftell(ifp);\n    switch (len)\n    {\n    case 582:\n      imgdata.makernotes.canon.CanonColorDataVer = 1; // 20D / 350D\n      {\n        fseek(ifp, save1 + (0x23 << 1), SEEK_SET);\n        Canon_WBpresets(2, 2);\n        fseek(ifp, save1 + (0x4b << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 653:\n      imgdata.makernotes.canon.CanonColorDataVer = 2; // 1Dmk2 / 1DsMK2\n      {\n        fseek(ifp, save1 + (0x27 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa4 << 1), SEEK_SET);\n        Canon_WBCTpresets(1); // ABCT\n      }\n      break;\n    case 796:\n      imgdata.makernotes.canon.CanonColorDataVer = 3; // 1DmkIIN / 5D / 30D / 400D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x4e << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0c4 << 1), SEEK_SET); // offset 196 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n    // 1DmkIII / 1DSmkIII / 1DmkIV / 5DmkII\n    // 7D / 40D / 50D / 60D / 450D / 500D\n    // 550D / 1000D / 1100D\n    case 674:\n    case 692:\n    case 702:\n    case 1227:\n    case 1250:\n    case 1251:\n    case 1337:\n    case 1338:\n    case 1346:\n      imgdata.makernotes.canon.CanonColorDataVer = 4;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x53 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xa8 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0e7 << 1), SEEK_SET); // offset 231 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if ((imgdata.makernotes.canon.CanonColorDataSubVer == 4) || (imgdata.makernotes.canon.CanonColorDataSubVer == 5))\n      {\n        fseek(ifp, save1 + (0x2b9 << 1), SEEK_SET); // offset 697 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if ((imgdata.makernotes.canon.CanonColorDataSubVer == 6) ||\n               (imgdata.makernotes.canon.CanonColorDataSubVer == 7))\n      {\n        fseek(ifp, save1 + (0x2d0 << 1), SEEK_SET); // offset 720 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 9)\n      {\n        fseek(ifp, save1 + (0x2d4 << 1), SEEK_SET); // offset 724 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    case 5120:\n      imgdata.makernotes.canon.CanonColorDataVer = 5; // PowerSot G10, G12, G5 X, EOS M3, EOS M5\n      {\n        fseek(ifp, save1 + (0x56 << 1), SEEK_SET);\n        if ((unique_id == 0x03970000) || // G7 X Mark II\n            (unique_id == 0x04100000) || // G9 X Mark II\n            (unique_id == 0x80000394))   // EOS M5\n        {\n          fseek(ifp, 18, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          fseek(ifp, 8, SEEK_CUR);\n          Canon_WBpresets(8, 24);\n          fseek(ifp, 168, SEEK_CUR);\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ (c >> 1)] = get2();\n          fseek(ifp, 24, SEEK_CUR);\n          Canon_WBCTpresets(2); // BCADT\n          fseek(ifp, 6, SEEK_CUR);\n        }\n        else\n        {\n          FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Other][c ^ (c >> 1)] = get2();\n          get2();\n          Canon_WBpresets(2, 12);\n          fseek(ifp, save1 + (0xba << 1), SEEK_SET);\n          Canon_WBCTpresets(2);                       // BCADT\n          fseek(ifp, save1 + (0x108 << 1), SEEK_SET); // offset 264 short\n        }\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      break;\n\n    case 1273:\n    case 1275:\n      imgdata.makernotes.canon.CanonColorDataVer = 6; // 600D / 1200D\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x67 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xbc << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x0fb << 1), SEEK_SET); // offset 251 short\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      fseek(ifp, save1 + (0x1e4 << 1), SEEK_SET); // offset 484 shorts\n      imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n      FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      break;\n\n    // 1DX / 5DmkIII / 6D / 100D / 650D / 700D / EOS M / 7DmkII / 750D / 760D\n    case 1312:\n    case 1313:\n    case 1316:\n    case 1506:\n      imgdata.makernotes.canon.CanonColorDataVer = 7;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x80 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0xd5 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x114 << 1), SEEK_SET); // offset 276 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 10)\n      {\n        fseek(ifp, save1 + (0x1fd << 1), SEEK_SET); // offset 509 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else if (imgdata.makernotes.canon.CanonColorDataSubVer == 11)\n      {\n        fseek(ifp, save1 + (0x2dd << 1), SEEK_SET); // offset 733 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n\n    // 5DS / 5DS R / 80D / 1300D / 5D4\n    case 1560:\n    case 1592:\n    case 1353:\n      imgdata.makernotes.canon.CanonColorDataVer = 8;\n      imgdata.makernotes.canon.CanonColorDataSubVer = get2();\n      {\n        fseek(ifp, save1 + (0x85 << 1), SEEK_SET);\n        Canon_WBpresets(2, 12);\n        fseek(ifp, save1 + (0x107 << 1), SEEK_SET);\n        Canon_WBCTpresets(0);                       // BCAT\n        fseek(ifp, save1 + (0x146 << 1), SEEK_SET); // offset 326 shorts\n        int bls = 0;\n        FORC4\n        bls += (imgdata.makernotes.canon.ChannelBlackLevel[c] = get2());\n        imgdata.makernotes.canon.AverageBlackLevel = bls / 4;\n      }\n      if (imgdata.makernotes.canon.CanonColorDataSubVer == 14) // 1300D\n      {\n        fseek(ifp, save1 + (0x231 << 1), SEEK_SET);\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      else\n      {\n        fseek(ifp, save1 + (0x30f << 1), SEEK_SET); // offset 783 shorts\n        imgdata.makernotes.canon.SpecularWhiteLevel = get2();\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.canon.SpecularWhiteLevel;\n      }\n      break;\n    }\n    fseek(ifp, save1, SEEK_SET);\n  }\n}\n\nvoid CLASS setPentaxBodyFeatures(unsigned id)\n{\n  imgdata.lens.makernotes.CamID = id;\n\n  switch (id)\n  {\n  case 0x12994:\n  case 0x12aa2:\n  case 0x12b1a:\n  case 0x12b60:\n  case 0x12b62:\n  case 0x12b7e:\n  case 0x12b80:\n  case 0x12b9c:\n  case 0x12b9d:\n  case 0x12ba2:\n  case 0x12c1e:\n  case 0x12c20:\n  case 0x12cd2:\n  case 0x12cd4:\n  case 0x12cfa:\n  case 0x12d72:\n  case 0x12d73:\n  case 0x12db8:\n  case 0x12dfe:\n  case 0x12e6c:\n  case 0x12e76:\n  case 0x12ef8:\n  case 0x12f52:\n  case 0x12f70:\n  case 0x12f71:\n  case 0x12fb6:\n  case 0x12fc0:\n  case 0x12fca:\n  case 0x1301a:\n  case 0x13024:\n  case 0x1309c:\n  case 0x13222:\n  case 0x1322c:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n    break;\n  case 0x13092:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_K;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    break;\n  case 0x12e08:\n  case 0x13010:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_MF;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_645;\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_MF;\n    break;\n  case 0x12ee4:\n  case 0x12f66:\n  case 0x12f7a:\n  case 0x1302e:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Pentax_Q;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Pentax_Q;\n    break;\n  default:\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n  }\n  return;\n}\n\nvoid CLASS PentaxISO(ushort c)\n{\n  int code[] = {3,   4,   5,   6,   7,   8,   9,   10,  11,   12,   13,  14,  15,  16,  17,  18,  19,\n                20,  21,  22,  23,  24,  25,  26,  27,  28,   29,   30,  31,  32,  33,  34,  35,  36,\n                37,  38,  39,  50,  100, 200, 400, 800, 1600, 3200, 258, 259, 260, 261, 262, 263, 264,\n                265, 266, 267, 268, 269, 270, 271, 272, 273,  274,  275, 276, 277, 278};\n  double value[] = {50,    64,    80,    100,   125,   160,   200,   250,    320,    400,    500,    640,   800,\n                    1000,  1250,  1600,  2000,  2500,  3200,  4000,  5000,   6400,   8000,   10000,  12800, 16000,\n                    20000, 25600, 32000, 40000, 51200, 64000, 80000, 102400, 128000, 160000, 204800, 50,    100,\n                    200,   400,   800,   1600,  3200,  50,    70,    100,    140,    200,    280,    400,   560,\n                    800,   1100,  1600,  2200,  3200,  4500,  6400,  9000,   12800,  18000,  25600,  36000, 51200};\n#define numel (sizeof(code) / sizeof(code[0]))\n  int i;\n  for (i = 0; i < numel; i++)\n  {\n    if (code[i] == c)\n    {\n      iso_speed = value[i];\n      return;\n    }\n  }\n  if (i == numel)\n    iso_speed = 65535.0f;\n}\n#undef numel\n\nvoid CLASS PentaxLensInfo(unsigned id, unsigned len) // tag 0x0207\n{\n  ushort iLensData = 0;\n  uchar *table_buf;\n  table_buf = (uchar *)malloc(MAX(len, 128));\n  fread(table_buf, len, 1, ifp);\n  if ((id < 0x12b9c) || (((id == 0x12b9c) ||  // K100D\n                          (id == 0x12b9d) ||  // K110D\n                          (id == 0x12ba2)) && // K100D Super\n                         ((!table_buf[20] || (table_buf[20] == 0xff)))))\n  {\n    iLensData = 3;\n    if (imgdata.lens.makernotes.LensID == -1)\n      imgdata.lens.makernotes.LensID = (((unsigned)table_buf[0]) << 8) + table_buf[1];\n  }\n  else\n    switch (len)\n    {\n    case 90: // LensInfo3\n      iLensData = 13;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 91: // LensInfo4\n      iLensData = 12;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[3]) << 8) + table_buf[4];\n      break;\n    case 80: // LensInfo5\n    case 128:\n      iLensData = 15;\n      if (imgdata.lens.makernotes.LensID == -1)\n        imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[1] & 0x0f) + table_buf[4]) << 8) + table_buf[5];\n      break;\n    default:\n      if (id >= 0x12b9c) // LensInfo2\n      {\n        iLensData = 4;\n        if (imgdata.lens.makernotes.LensID == -1)\n          imgdata.lens.makernotes.LensID = ((unsigned)((table_buf[0] & 0x0f) + table_buf[2]) << 8) + table_buf[3];\n      }\n    }\n  if (iLensData)\n  {\n    if (table_buf[iLensData + 9] && (fabs(imgdata.lens.makernotes.CurFocal) < 0.1f))\n      imgdata.lens.makernotes.CurFocal =\n          10 * (table_buf[iLensData + 9] >> 2) * powf64(4, (table_buf[iLensData + 9] & 0x03) - 2);\n    if (table_buf[iLensData + 10] & 0xf0)\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0xf0) >> 4) / 4.0f);\n    if (table_buf[iLensData + 10] & 0x0f)\n      imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 10] & 0x0f) + 10) / 4.0f);\n\n    if (iLensData != 12)\n    {\n      switch (table_buf[iLensData] & 0x06)\n      {\n      case 0:\n        imgdata.lens.makernotes.MinAp4MinFocal = 22.0f;\n        break;\n      case 2:\n        imgdata.lens.makernotes.MinAp4MinFocal = 32.0f;\n        break;\n      case 4:\n        imgdata.lens.makernotes.MinAp4MinFocal = 45.0f;\n        break;\n      case 6:\n        imgdata.lens.makernotes.MinAp4MinFocal = 16.0f;\n        break;\n      }\n      if (table_buf[iLensData] & 0x70)\n        imgdata.lens.makernotes.LensFStops = ((float)(((table_buf[iLensData] & 0x70) >> 4) ^ 0x07)) / 2.0f + 5.0f;\n\n      imgdata.lens.makernotes.MinFocusDistance = (float)(table_buf[iLensData + 3] & 0xf8);\n      imgdata.lens.makernotes.FocusRangeIndex = (float)(table_buf[iLensData + 3] & 0x07);\n\n      if ((table_buf[iLensData + 14] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 14] & 0x7f) - 1) / 32.0f);\n    }\n    else if ((id != 0x12e76) && // K-5\n             (table_buf[iLensData + 15] > 1) && (fabs(imgdata.lens.makernotes.MaxAp4CurFocal) < 0.7f))\n    {\n      imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (float)((table_buf[iLensData + 15] & 0x7f) - 1) / 32.0f);\n    }\n  }\n  free(table_buf);\n  return;\n}\n\nvoid CLASS setPhaseOneFeatures(unsigned id)\n{\n\n  ushort i;\n  static const struct\n  {\n    ushort id;\n    char t_model[32];\n  } p1_unique[] = {\n      // Phase One section:\n      {1, \"Hasselblad V\"},\n      {10, \"PhaseOne/Mamiya\"},\n      {12, \"Contax 645\"},\n      {16, \"Hasselblad V\"},\n      {17, \"Hasselblad V\"},\n      {18, \"Contax 645\"},\n      {19, \"PhaseOne/Mamiya\"},\n      {20, \"Hasselblad V\"},\n      {21, \"Contax 645\"},\n      {22, \"PhaseOne/Mamiya\"},\n      {23, \"Hasselblad V\"},\n      {24, \"Hasselblad H\"},\n      {25, \"PhaseOne/Mamiya\"},\n      {32, \"Contax 645\"},\n      {34, \"Hasselblad V\"},\n      {35, \"Hasselblad V\"},\n      {36, \"Hasselblad H\"},\n      {37, \"Contax 645\"},\n      {38, \"PhaseOne/Mamiya\"},\n      {39, \"Hasselblad V\"},\n      {40, \"Hasselblad H\"},\n      {41, \"Contax 645\"},\n      {42, \"PhaseOne/Mamiya\"},\n      {44, \"Hasselblad V\"},\n      {45, \"Hasselblad H\"},\n      {46, \"Contax 645\"},\n      {47, \"PhaseOne/Mamiya\"},\n      {48, \"Hasselblad V\"},\n      {49, \"Hasselblad H\"},\n      {50, \"Contax 645\"},\n      {51, \"PhaseOne/Mamiya\"},\n      {52, \"Hasselblad V\"},\n      {53, \"Hasselblad H\"},\n      {54, \"Contax 645\"},\n      {55, \"PhaseOne/Mamiya\"},\n      {67, \"Hasselblad V\"},\n      {68, \"Hasselblad H\"},\n      {69, \"Contax 645\"},\n      {70, \"PhaseOne/Mamiya\"},\n      {71, \"Hasselblad V\"},\n      {72, \"Hasselblad H\"},\n      {73, \"Contax 645\"},\n      {74, \"PhaseOne/Mamiya\"},\n      {76, \"Hasselblad V\"},\n      {77, \"Hasselblad H\"},\n      {78, \"Contax 645\"},\n      {79, \"PhaseOne/Mamiya\"},\n      {80, \"Hasselblad V\"},\n      {81, \"Hasselblad H\"},\n      {82, \"Contax 645\"},\n      {83, \"PhaseOne/Mamiya\"},\n      {84, \"Hasselblad V\"},\n      {85, \"Hasselblad H\"},\n      {86, \"Contax 645\"},\n      {87, \"PhaseOne/Mamiya\"},\n      {99, \"Hasselblad V\"},\n      {100, \"Hasselblad H\"},\n      {101, \"Contax 645\"},\n      {102, \"PhaseOne/Mamiya\"},\n      {103, \"Hasselblad V\"},\n      {104, \"Hasselblad H\"},\n      {105, \"PhaseOne/Mamiya\"},\n      {106, \"Contax 645\"},\n      {112, \"Hasselblad V\"},\n      {113, \"Hasselblad H\"},\n      {114, \"Contax 645\"},\n      {115, \"PhaseOne/Mamiya\"},\n      {131, \"Hasselblad V\"},\n      {132, \"Hasselblad H\"},\n      {133, \"Contax 645\"},\n      {134, \"PhaseOne/Mamiya\"},\n      {135, \"Hasselblad V\"},\n      {136, \"Hasselblad H\"},\n      {137, \"Contax 645\"},\n      {138, \"PhaseOne/Mamiya\"},\n      {140, \"Hasselblad V\"},\n      {141, \"Hasselblad H\"},\n      {142, \"Contax 645\"},\n      {143, \"PhaseOne/Mamiya\"},\n      {148, \"Hasselblad V\"},\n      {149, \"Hasselblad H\"},\n      {150, \"Contax 645\"},\n      {151, \"PhaseOne/Mamiya\"},\n      {160, \"A-250\"},\n      {161, \"A-260\"},\n      {162, \"A-280\"},\n      {167, \"Hasselblad V\"},\n      {168, \"Hasselblad H\"},\n      {169, \"Contax 645\"},\n      {170, \"PhaseOne/Mamiya\"},\n      {172, \"Hasselblad V\"},\n      {173, \"Hasselblad H\"},\n      {174, \"Contax 645\"},\n      {175, \"PhaseOne/Mamiya\"},\n      {176, \"Hasselblad V\"},\n      {177, \"Hasselblad H\"},\n      {178, \"Contax 645\"},\n      {179, \"PhaseOne/Mamiya\"},\n      {180, \"Hasselblad V\"},\n      {181, \"Hasselblad H\"},\n      {182, \"Contax 645\"},\n      {183, \"PhaseOne/Mamiya\"},\n      {208, \"Hasselblad V\"},\n      {211, \"PhaseOne/Mamiya\"},\n      {448, \"Phase One 645AF\"},\n      {457, \"Phase One 645DF\"},\n      {471, \"Phase One 645DF+\"},\n      {704, \"Phase One iXA\"},\n      {705, \"Phase One iXA - R\"},\n      {706, \"Phase One iXU 150\"},\n      {707, \"Phase One iXU 150 - NIR\"},\n      {708, \"Phase One iXU 180\"},\n      {721, \"Phase One iXR\"},\n      // Leaf section:\n      {333, \"Mamiya\"},\n      {329, \"Universal\"},\n      {330, \"Hasselblad H1/H2\"},\n      {332, \"Contax\"},\n      {336, \"AFi\"},\n      {327, \"Mamiya\"},\n      {324, \"Universal\"},\n      {325, \"Hasselblad H1/H2\"},\n      {326, \"Contax\"},\n      {335, \"AFi\"},\n      {340, \"Mamiya\"},\n      {337, \"Universal\"},\n      {338, \"Hasselblad H1/H2\"},\n      {339, \"Contax\"},\n      {323, \"Mamiya\"},\n      {320, \"Universal\"},\n      {322, \"Hasselblad H1/H2\"},\n      {321, \"Contax\"},\n      {334, \"AFi\"},\n      {369, \"Universal\"},\n      {370, \"Mamiya\"},\n      {371, \"Hasselblad H1/H2\"},\n      {372, \"Contax\"},\n      {373, \"Afi\"},\n  };\n  imgdata.lens.makernotes.CamID = id;\n  if (id && !imgdata.lens.makernotes.body[0])\n  {\n    for (i = 0; i < sizeof p1_unique / sizeof *p1_unique; i++)\n      if (id == p1_unique[i].id)\n      {\n        strcpy(imgdata.lens.makernotes.body, p1_unique[i].t_model);\n      }\n  }\n  return;\n}\n\nvoid CLASS parseFujiMakernotes(unsigned tag, unsigned type)\n{\n  switch (tag)\n  {\n  case 0x1002:\n    imgdata.makernotes.fuji.WB_Preset = get2();\n    break;\n  case 0x1011:\n    imgdata.other.FlashEC = getreal(type);\n    break;\n  case 0x1020:\n    imgdata.makernotes.fuji.Macro = get2();\n    break;\n  case 0x1021:\n    imgdata.makernotes.fuji.FocusMode = get2();\n    break;\n  case 0x1022:\n    imgdata.makernotes.fuji.AFMode = get2();\n    break;\n  case 0x1023:\n    imgdata.makernotes.fuji.FocusPixel[0] = get2();\n    imgdata.makernotes.fuji.FocusPixel[1] = get2();\n    break;\n  case 0x1034:\n    imgdata.makernotes.fuji.ExrMode = get2();\n    break;\n  case 0x1050:\n    imgdata.makernotes.fuji.ShutterType = get2();\n    break;\n  case 0x1400:\n    imgdata.makernotes.fuji.FujiDynamicRange = get2();\n    break;\n  case 0x1401:\n    imgdata.makernotes.fuji.FujiFilmMode = get2();\n    break;\n  case 0x1402:\n    imgdata.makernotes.fuji.FujiDynamicRangeSetting = get2();\n    break;\n  case 0x1403:\n    imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = get2();\n    break;\n  case 0x140b:\n    imgdata.makernotes.fuji.FujiAutoDynamicRange = get2();\n    break;\n  case 0x1404:\n    imgdata.lens.makernotes.MinFocal = getreal(type);\n    break;\n  case 0x1405:\n    imgdata.lens.makernotes.MaxFocal = getreal(type);\n    break;\n  case 0x1406:\n    imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n    break;\n  case 0x1407:\n    imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n    break;\n  case 0x1422:\n    imgdata.makernotes.fuji.ImageStabilization[0] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[1] = get2();\n    imgdata.makernotes.fuji.ImageStabilization[2] = get2();\n    imgdata.shootinginfo.ImageStabilization =\n        (imgdata.makernotes.fuji.ImageStabilization[0] << 9) + imgdata.makernotes.fuji.ImageStabilization[1];\n    break;\n  case 0x1431:\n    imgdata.makernotes.fuji.Rating = get4();\n    break;\n  case 0x3820:\n    imgdata.makernotes.fuji.FrameRate = get2();\n    break;\n  case 0x3821:\n    imgdata.makernotes.fuji.FrameWidth = get2();\n    break;\n  case 0x3822:\n    imgdata.makernotes.fuji.FrameHeight = get2();\n    break;\n  }\n  return;\n}\n\nvoid CLASS setSonyBodyFeatures(unsigned id)\n{\n\n  imgdata.lens.makernotes.CamID = id;\n  if (               // FF cameras\n      (id == 257) || // a900\n      (id == 269) || // a850\n      (id == 340) || // ILCE-7M2\n      (id == 318) || // ILCE-7S\n      (id == 350) || // ILCE-7SM2\n      (id == 311) || // ILCE-7R\n      (id == 347) || // ILCE-7RM2\n      (id == 306) || // ILCE-7\n      (id == 298) || // DSC-RX1\n      (id == 299) || // NEX-VG900\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 354) || // ILCA-99M2\n      (id == 294)    // SLT-99, Hasselblad HV\n      )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n  }\n  else if ((id == 297) || // DSC-RX100\n           (id == 308) || // DSC-RX100M2\n           (id == 309) || // DSC-RX10\n           (id == 317) || // DSC-RX100M3\n           (id == 341) || // DSC-RX100M4\n           (id == 342) || // DSC-RX10M2\n           (id == 355) || // DSC-RX10M3\n           (id == 356)    // DSC-RX100M5\n           )\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_1INCH;\n  }\n\n  else if (id != 002) // DSC-R1\n  {\n    imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n  }\n\n  if ( // E-mount cameras, ILCE series\n      (id == 302) || (id == 306) || (id == 311) || (id == 312) || (id == 313) || (id == 318) || (id == 339) ||\n      (id == 340) || (id == 346) || (id == 347) || (id == 350) || (id == 360))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCE;\n  }\n  else if ( // E-mount cameras, NEX series\n      (id == 278) || (id == 279) || (id == 284) || (id == 288) || (id == 289) || (id == 290) || (id == 293) ||\n      (id == 295) || (id == 296) || (id == 299) || (id == 300) || (id == 305) || (id == 307))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Sony_E;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_NEX;\n  }\n\n  else if ( // A-mount cameras, DSLR series\n      (id == 256) || (id == 257) || (id == 258) || (id == 259) || (id == 260) || (id == 261) || (id == 262) ||\n      (id == 263) || (id == 264) || (id == 265) || (id == 266) || (id == 269) || (id == 270) || (id == 273) ||\n      (id == 274) || (id == 275) || (id == 282) || (id == 283))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSLR;\n  }\n  else if ( // A-mount cameras, SLT series\n      (id == 280) || (id == 281) || (id == 285) || (id == 286) || (id == 287) || (id == 291) || (id == 292) ||\n      (id == 294) || (id == 303))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_SLT;\n  }\n  else if ( // A-mount cameras, ILCA series\n      (id == 319) || (id == 353) || (id == 354))\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_ILCA;\n  }\n\n  else if (          // DSC\n      (id == 002) || // DSC-R1\n      (id == 297) || // DSC-RX100\n      (id == 298) || // DSC-RX1\n      (id == 308) || // DSC-RX100M2\n      (id == 309) || // DSC-RX10\n      (id == 310) || // DSC-RX1R\n      (id == 344) || // DSC-RX1RM2\n      (id == 317) || // DSC-RX100M3\n      (id == 341) || // DSC-RX100M4\n      (id == 342) || // DSC-RX10M2\n      (id == 355) || // DSC-RX10M3\n      (id == 356)    // DSC-RX100M5\n      )\n  {\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n    imgdata.makernotes.sony.SonyCameraType = LIBRAW_SONY_DSC;\n  }\n  return;\n}\n\nvoid CLASS parseSonyLensType2(uchar a, uchar b)\n{\n  ushort lid2;\n  lid2 = (((ushort)a) << 8) | ((ushort)b);\n  if (!lid2)\n    return;\n  if (lid2 < 0x100)\n  {\n    if ((imgdata.lens.makernotes.AdapterID != 0x4900) && (imgdata.lens.makernotes.AdapterID != 0xEF00))\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2)\n      {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        break;\n      }\n    }\n  }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  if ((lid2 >= 50481) && (lid2 < 50500))\n  {\n    strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    imgdata.lens.makernotes.AdapterID = 0x4900;\n  }\n  return;\n}\n\n#define strnXcat(buf, string) strncat(buf, string, LIM(sizeof(buf) - strbuflen(buf) - 1, 0, sizeof(buf)))\n\nvoid CLASS parseSonyLensFeatures(uchar a, uchar b)\n{\n\n  ushort features;\n  features = (((ushort)a) << 8) | ((ushort)b);\n\n  if ((imgdata.lens.makernotes.LensMount == LIBRAW_MOUNT_Canon_EF) ||\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F) || !features)\n    return;\n\n  imgdata.lens.makernotes.LensFeatures_pre[0] = 0;\n  imgdata.lens.makernotes.LensFeatures_suf[0] = 0;\n  if ((features & 0x0200) && (features & 0x0100))\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"E\");\n  else if (features & 0x0200)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"FE\");\n  else if (features & 0x0100)\n    strcpy(imgdata.lens.makernotes.LensFeatures_pre, \"DT\");\n\n  if (!imgdata.lens.makernotes.LensFormat && !imgdata.lens.makernotes.LensMount)\n  {\n    imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FF;\n    imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n\n    if ((features & 0x0200) && (features & 0x0100))\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0200)\n    {\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n    }\n    else if (features & 0x0100)\n    {\n      imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_APSC;\n    }\n  }\n\n  if (features & 0x4000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_pre, \" PZ\");\n\n  if (features & 0x0008)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" G\");\n  else if (features & 0x0004)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" ZA\");\n\n  if ((features & 0x0020) && (features & 0x0040))\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Macro\");\n  else if (features & 0x0020)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" STF\");\n  else if (features & 0x0040)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Reflex\");\n  else if (features & 0x0080)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" Fisheye\");\n\n  if (features & 0x0001)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SSM\");\n  else if (features & 0x0002)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" SAM\");\n\n  if (features & 0x8000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" OSS\");\n\n  if (features & 0x2000)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" LE\");\n\n  if (features & 0x0800)\n    strnXcat(imgdata.lens.makernotes.LensFeatures_suf, \" II\");\n\n  if (imgdata.lens.makernotes.LensFeatures_suf[0] == ' ')\n    memmove(imgdata.lens.makernotes.LensFeatures_suf, imgdata.lens.makernotes.LensFeatures_suf + 1,\n            strbuflen(imgdata.lens.makernotes.LensFeatures_suf) - 1);\n\n  return;\n}\n#undef strnXcat\n\nvoid CLASS process_Sony_0x940c(uchar *buf)\n{\n  ushort lid2;\n  if ((imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) | ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2(SonySubstitution[buf[0x000a]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0009]]);\n  return;\n}\n\nvoid CLASS process_Sony_0x9050(uchar *buf, unsigned id)\n{\n  ushort lid;\n\n  if ((imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_Sony_E) &&\n      (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens))\n  {\n    if (buf[0])\n      imgdata.lens.makernotes.MaxAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n\n    if (buf[1])\n      imgdata.lens.makernotes.MinAp4CurFocal =\n          my_roundf(powf64(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) * 10.0f) / 10.0f;\n  }\n\n  if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n  {\n    if (buf[0x3d] | buf[0x3c])\n    {\n      lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];\n      imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);\n    }\n    if (buf[0x105] && (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n        (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n      imgdata.lens.makernotes.LensMount = SonySubstitution[buf[0x105]];\n    if (buf[0x106])\n      imgdata.lens.makernotes.LensFormat = SonySubstitution[buf[0x106]];\n  }\n\n  if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n  {\n    parseSonyLensType2(SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids\n                       SonySubstitution[buf[0x0107]]);\n  }\n  if ((imgdata.lens.makernotes.LensID == -1) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) &&\n      (buf[0x010a] | buf[0x0109]))\n  {\n    imgdata.lens.makernotes.LensID = // LensType - Minolta/Sony lens ids\n        SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];\n\n    if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n    {\n      imgdata.lens.makernotes.AdapterID = 0x4900;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n      strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n    }\n\n    else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n             (imgdata.lens.makernotes.LensID != 0xFF00))\n    {\n      imgdata.lens.makernotes.AdapterID = 0xEF00;\n      imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n    }\n  }\n\n  if ((id >= 286) && (id <= 293))\n    // \"SLT-A65\", \"SLT-A77\", \"NEX-7\", \"NEX-VG20E\",\n    // \"SLT-A37\", \"SLT-A57\", \"NEX-F3\", \"Lunar\"\n    parseSonyLensFeatures(SonySubstitution[buf[0x115]], SonySubstitution[buf[0x116]]);\n  else if (imgdata.lens.makernotes.CameraMount != LIBRAW_MOUNT_FixedLens)\n    parseSonyLensFeatures(SonySubstitution[buf[0x116]], SonySubstitution[buf[0x117]]);\n\n  if ((id == 347) || (id == 350) || (id == 357))\n  {\n    unsigned long b88 = SonySubstitution[buf[0x88]];\n    unsigned long b89 = SonySubstitution[buf[0x89]];\n    unsigned long b8a = SonySubstitution[buf[0x8a]];\n    unsigned long b8b = SonySubstitution[buf[0x8b]];\n    unsigned long b8c = SonySubstitution[buf[0x8c]];\n    unsigned long b8d = SonySubstitution[buf[0x8d]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%06lx\",\n            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Minolta_A) && (id > 279) && (id != 282) && (id != 283))\n  {\n    unsigned long bf0 = SonySubstitution[buf[0xf0]];\n    unsigned long bf1 = SonySubstitution[buf[0xf1]];\n    unsigned long bf2 = SonySubstitution[buf[0xf2]];\n    unsigned long bf3 = SonySubstitution[buf[0xf3]];\n    unsigned long bf4 = SonySubstitution[buf[0xf4]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%05lx\",\n            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);\n  }\n  else if ((imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E) && (id != 288) && (id != 289) && (id != 290))\n  {\n    unsigned b7c = SonySubstitution[buf[0x7c]];\n    unsigned b7d = SonySubstitution[buf[0x7d]];\n    unsigned b7e = SonySubstitution[buf[0x7e]];\n    unsigned b7f = SonySubstitution[buf[0x7f]];\n    sprintf(imgdata.shootinginfo.InternalBodySerial, \"%04x\", (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);\n  }\n\n  return;\n}\n\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)\n{\n  unsigned ver97 = 0, offset = 0, entries, tag, type, len, save, c;\n  unsigned i;\n\n  uchar NikonKey, ci, cj, ck;\n  unsigned serial = 0;\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  short morder, sorder = order;\n  char buf[10];\n  INT64 fsize = ifp->size();\n\n  fread(buf, 1, 10, ifp);\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \") ||\n           (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if ((!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG)))\n      base = ftell(ifp);\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 pos = ifp->tell();\n    if (len > 8 && pos + len > 2 * fsize)\n      continue;\n    tag |= uptag << 16;\n    if (len > 100 * 1024 * 1024)\n      goto next; // 100Mb tag? No!\n\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n      parseFujiMakernotes(tag, type);\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x1d) // serial number\n        while ((c = fgetc(ifp)) && c != EOF)\n        {\n          if ((!custom_serial) && (!isdigit(c)))\n          {\n            if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n            {\n              custom_serial = 34;\n            }\n            else\n            {\n              custom_serial = 96;\n            }\n          }\n          serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n        }\n      else if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0097)\n      {\n        for (i = 0; i < 4; i++)\n          ver97 = ver97 * 10 + fgetc(ifp) - '0';\n        if (ver97 == 601) // Coolpix A\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n\n      else if (tag == 0xa7) // shutter count\n      {\n        NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n        if ((NikonLensDataVersion > 200) && lenNikonLensData)\n        {\n          if (custom_serial)\n          {\n            ci = xlat[0][custom_serial];\n          }\n          else\n          {\n            ci = xlat[0][serial & 0xff];\n          }\n          cj = xlat[1][NikonKey];\n          ck = 0x60;\n          for (i = 0; i < lenNikonLensData; i++)\n            table_buf[i] ^= (cj += ci * ck++);\n          processNikonLensData(table_buf, lenNikonLensData);\n          lenNikonLensData = 0;\n          free(table_buf);\n        }\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n\n      else if (tag == 37 && (!iso_speed || iso_speed == 65535))\n      {\n        unsigned char cc;\n        fread(&cc, 1, 1, ifp);\n        iso_speed = (int)(100.0 * powf64(2.0, (double)(cc) / 12.0 - 5.0));\n        break;\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      int SubDirOffsetValid = strncmp(model, \"E-300\", 5) && strncmp(model, \"E-330\", 5) && strncmp(model, \"E-400\", 5) &&\n                              strncmp(model, \"E-500\", 5) && strncmp(model, \"E-1\", 3);\n\n      if ((tag == 0x2010) || (tag == 0x2020))\n      {\n        fseek(ifp, save - 4, SEEK_SET);\n        fseek(ifp, base + get4(), SEEK_SET);\n        parse_makernote_0xc634(base, tag, dng_writer);\n      }\n      if (!SubDirOffsetValid && ((len > 4) || (((type == 3) || (type == 8)) && (len > 2)) ||\n                                 (((type == 4) || (type == 9)) && (len > 1)) || (type == 5) || (type > 9)))\n        goto skip_Oly_broken_tags;\n\n      switch (tag)\n      {\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20100102:\n        stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x20100201:\n        imgdata.lens.makernotes.LensID = (unsigned long long)fgetc(ifp) << 16 |\n                                         (unsigned long long)(fgetc(ifp), fgetc(ifp)) << 8 |\n                                         (unsigned long long)fgetc(ifp);\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        if ((!imgdata.lens.LensSerial[0]))\n          stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      case 0x20200401:\n        imgdata.other.FlashEC = getreal(type);\n        break;\n      }\n    skip_Oly_broken_tags:;\n    }\n\n    else if (!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n             (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == CameraDNG)))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 12, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7) && (dng_writer == AdobeDNG))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        imgdata.lens.makernotes.CamID = unique_id = get4();\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n\n                // a450, a500, a550, a560, a580\n                // a33, a35, a55\n                // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2], table_buf[5], table_buf[4], table_buf[7]))\n            {\n              if (table_buf[0] | table_buf[3])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n              if (table_buf[2] | table_buf[5])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n              if (table_buf[4])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n              parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            }\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n            {\n              if (table_buf[1] | table_buf[2])\n                imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n              if (table_buf[3] | table_buf[4])\n                imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n              if (table_buf[5])\n                imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n              if (table_buf[6])\n                imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n              parseSonyLensFeatures(table_buf[0], table_buf[7]);\n            }\n          }\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 65535) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3], table_buf[4], table_buf[5], table_buf[6]))\n        {\n          if (table_buf[1] | table_buf[2])\n            imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n          if (table_buf[3] | table_buf[4])\n            imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n          if (table_buf[5])\n            imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n          if (table_buf[6])\n            imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n          parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        }\n        free(table_buf);\n      }\n    }\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n#else\nvoid CLASS parse_makernote_0xc634(int base, int uptag, unsigned dng_writer) { /*placeholder */}\n#endif\n\nvoid CLASS parse_makernote(int base, int uptag)\n{\n  unsigned offset = 0, entries, tag, type, len, save, c;\n  unsigned ver97 = 0, serial = 0, i, wbi = 0, wb[4] = {0, 0, 0, 0};\n  uchar buf97[324], ci, cj, ck;\n  short morder, sorder = order;\n  char buf[10];\n  unsigned SamsungKey[11];\n  uchar NikonKey;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned custom_serial = 0;\n  unsigned NikonLensDataVersion = 0;\n  unsigned lenNikonLensData = 0;\n\n  unsigned NikonFlashInfoVersion = 0;\n\n  uchar *CanonCameraInfo;\n  unsigned lenCanonCameraInfo = 0;\n\n  uchar *table_buf;\n  uchar *table_buf_0x9050;\n  ushort table_buf_0x9050_present = 0;\n  uchar *table_buf_0x940c;\n  ushort table_buf_0x940c_present = 0;\n\n  INT64 fsize = ifp->size();\n#endif\n  /*\n     The MakerNote might have its own TIFF header (possibly with\n     its own byte-order!), or it might just be a table.\n   */\n  if (!strncmp(make, \"Nokia\", 5))\n    return;\n  fread(buf, 1, 10, ifp);\n  if (!strncmp(buf, \"KDK\", 3) || /* these aren't TIFF tables */\n      !strncmp(buf, \"VER\", 3) || !strncmp(buf, \"IIII\", 4) || !strncmp(buf, \"MMMM\", 4))\n    return;\n  if (!strncmp(buf, \"KC\", 2) || /* Konica KD-400Z, KD-510Z */\n      !strncmp(buf, \"MLY\", 3))\n  { /* Minolta DiMAGE G series */\n    order = 0x4d4d;\n    while ((i = ftell(ifp)) < data_offset && i < 16384)\n    {\n      wb[0] = wb[2];\n      wb[2] = wb[1];\n      wb[1] = wb[3];\n      wb[3] = get2();\n      if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 && wb[2] > 256 && wb[2] < 640)\n        FORC4 cam_mul[c] = wb[c];\n    }\n    goto quit;\n  }\n  if (!strcmp(buf, \"Nikon\"))\n  {\n    base = ftell(ifp);\n    order = get2();\n    if (get2() != 42)\n      goto quit;\n    offset = get4();\n    fseek(ifp, offset - 8, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMPUS\") || !strcmp(buf, \"PENTAX \"))\n  {\n    base = ftell(ifp) - 10;\n    fseek(ifp, -2, SEEK_CUR);\n    order = get2();\n    if (buf[0] == 'O')\n      get2();\n  }\n  else if (!strncmp(buf, \"SONY\", 4) || !strcmp(buf, \"Panasonic\"))\n  {\n    goto nf;\n  }\n  else if (!strncmp(buf, \"FUJIFILM\", 8))\n  {\n    base = ftell(ifp) - 10;\n  nf:\n    order = 0x4949;\n    fseek(ifp, 2, SEEK_CUR);\n  }\n  else if (!strcmp(buf, \"OLYMP\") || !strcmp(buf, \"LEICA\") || !strcmp(buf, \"Ricoh\") || !strcmp(buf, \"EPSON\"))\n    fseek(ifp, -2, SEEK_CUR);\n  else if (!strcmp(buf, \"AOC\") || !strcmp(buf, \"QVC\"))\n    fseek(ifp, -4, SEEK_CUR);\n  else\n  {\n    fseek(ifp, -10, SEEK_CUR);\n    if (!strncmp(make, \"SAMSUNG\", 7))\n      base = ftell(ifp);\n  }\n\n  // adjust pos & base for Leica M8/M9/M Mono tags and dir in tag 0x3400\n  if (!strncasecmp(make, \"LEICA\", 5))\n  {\n    if (!strncmp(model, \"M8\", 2) || !strncasecmp(model, \"Leica M8\", 8) || !strncasecmp(model, \"LEICA X\", 7))\n    {\n      base = ftell(ifp) - 8;\n    }\n    else if (!strncasecmp(model, \"LEICA M (Typ 240)\", 17))\n    {\n      base = 0;\n    }\n    else if (!strncmp(model, \"M9\", 2) || !strncasecmp(model, \"Leica M9\", 8) || !strncasecmp(model, \"M Monochrom\", 11) ||\n             !strncasecmp(model, \"Leica M Monochrom\", 11))\n    {\n      if (!uptag)\n      {\n        base = ftell(ifp) - 10;\n        fseek(ifp, 8, SEEK_CUR);\n      }\n      else if (uptag == 0x3400)\n      {\n        fseek(ifp, 10, SEEK_CUR);\n        base += 10;\n      }\n    }\n    else if (!strncasecmp(model, \"LEICA T\", 7))\n    {\n      base = ftell(ifp) - 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_T;\n#endif\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    else if (!strncasecmp(model, \"LEICA SL\", 8))\n    {\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_SL;\n      imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_FF;\n    }\n#endif\n  }\n\n  entries = get2();\n  if (entries > 1000)\n    return;\n  morder = order;\n\n  while (entries--)\n  {\n    order = morder;\n    tiff_get(base, &tag, &type, &len, &save);\n    tag |= uptag << 16;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos = ftell(ifp);\n    if (len > 8 && _pos + len > 2 * fsize)\n      continue;\n    if (!strncmp(make, \"Canon\", 5))\n    {\n      if (tag == 0x000d && len < 256000) // camera info\n      {\n        CanonCameraInfo = (uchar *)malloc(len);\n        fread(CanonCameraInfo, len, 1, ifp);\n        lenCanonCameraInfo = len;\n      }\n\n      else if (tag == 0x10) // Canon ModelID\n      {\n        unique_id = get4();\n        if (unique_id == 0x03740000)\n          unique_id = 0x80000374; // M3\n        if (unique_id == 0x03840000)\n          unique_id = 0x80000384; // M10\n        if (unique_id == 0x03940000)\n          unique_id = 0x80000394; // M5\n        setCanonBodyFeatures(unique_id);\n        if (lenCanonCameraInfo)\n        {\n          processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo);\n          free(CanonCameraInfo);\n          CanonCameraInfo = 0;\n          lenCanonCameraInfo = 0;\n        }\n      }\n\n      else\n        parseCanonMakernotes(tag, type, len);\n    }\n\n    else if (!strncmp(make, \"FUJI\", 4))\n    {\n      if (tag == 0x0010)\n      {\n        char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n        char *words[4];\n        char yy[2], mm[3], dd[3], ystr[16], ynum[16];\n        int year, nwords, ynum_len;\n        unsigned c;\n        stmread(FujiSerial, len, ifp);\n        nwords = getwords(FujiSerial, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n        for (int i = 0; i < nwords; i++)\n        {\n          mm[2] = dd[2] = 0;\n          if (strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)\n            if (i == 0)\n              strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s\", imgdata.shootinginfo.InternalBodySerial, words[i]);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          else\n          {\n            strncpy(dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 14, 2);\n            strncpy(mm, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 16, 2);\n            strncpy(yy, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18, 2);\n            year = (yy[0] - '0') * 10 + (yy[1] - '0');\n            if (year < 70)\n              year += 2000;\n            else\n              year += 1900;\n\n            ynum_len = (int)strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 18;\n            strncpy(ynum, words[i], ynum_len);\n            ynum[ynum_len] = 0;\n            for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, \"%2x\", &c); j += 2)\n              ystr[j / 2] = c;\n            ystr[ynum_len / 2 + 1] = 0;\n            strcpy(model2, ystr);\n\n            if (i == 0)\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n\n              if (nwords == 1)\n                snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s\",\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12, ystr,\n                         year, mm, dd);\n\n              else\n                snprintf(tbuf, sizeof(tbuf), \"%s %d:%s:%s %s\", ystr, year, mm, dd,\n                         words[0] + strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n            else\n            {\n              char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n              snprintf(tbuf, sizeof(tbuf), \"%s %s %d:%s:%s %s\", imgdata.shootinginfo.InternalBodySerial, ystr, year, mm,\n                       dd, words[i] + strnlen(words[i], sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) - 12);\n              strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,\n                      sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);\n            }\n          }\n        }\n      }\n      else\n        parseFujiMakernotes(tag, type);\n    }\n\n    else if (!strncasecmp(make, \"LEICA\", 5))\n    {\n      if (((tag == 0x035e) || (tag == 0x035f)) && (type == 10) && (len == 9))\n      {\n        int ind = tag == 0x035e ? 0 : 1;\n        for (int j = 0; j < 3; j++)\n          FORCC imgdata.color.dng_color[ind].forwardmatrix[j][c] = getreal(type);\n      }\n\n      if ((tag == 0x0303) && (type != 4))\n      {\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      }\n\n      if ((tag == 0x3405) || (tag == 0x0310) || (tag == 0x34003405))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        imgdata.lens.makernotes.LensID =\n            ((imgdata.lens.makernotes.LensID >> 2) << 8) | (imgdata.lens.makernotes.LensID & 0x3);\n        if (imgdata.lens.makernotes.LensID != -1)\n        {\n          if ((model[0] == 'M') || !strncasecmp(model, \"LEICA M\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n            if (imgdata.lens.makernotes.LensID)\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_M;\n          }\n          else if ((model[0] == 'S') || !strncasecmp(model, \"LEICA S\", 7))\n          {\n            imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_S;\n            if (imgdata.lens.makernotes.Lens[0])\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Leica_S;\n          }\n        }\n      }\n\n      else if (((tag == 0x0313) || (tag == 0x34003406)) && (fabs(imgdata.lens.makernotes.CurAp) < 0.17f) &&\n               ((type == 10) || (type == 5)))\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n        if (imgdata.lens.makernotes.CurAp > 126.3)\n          imgdata.lens.makernotes.CurAp = 0.0f;\n      }\n\n      else if (tag == 0x3400)\n      {\n        parse_makernote(base, 0x3400);\n      }\n    }\n\n    else if (!strncmp(make, \"NIKON\", 5))\n    {\n      if (tag == 0x000a)\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n      else if (tag == 0x0012)\n      {\n        char a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n          imgdata.other.FlashEC = (float)(a * b) / (float)c;\n      }\n      else if (tag == 0x0082) // lens attachment\n      {\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n      }\n      else if (tag == 0x0083) // lens type\n      {\n        imgdata.lens.nikon.NikonLensType = fgetc(ifp);\n      }\n      else if (tag == 0x0084) // lens\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MinFocal = getreal(type);\n        imgdata.lens.makernotes.MaxAp4MaxFocal = getreal(type);\n      }\n      else if (tag == 0x008b) // lens f-stops\n      {\n        uchar a, b, c;\n        a = fgetc(ifp);\n        b = fgetc(ifp);\n        c = fgetc(ifp);\n        if (c)\n        {\n          imgdata.lens.nikon.NikonLensFStops = a * b * (12 / c);\n          imgdata.lens.makernotes.LensFStops = (float)imgdata.lens.nikon.NikonLensFStops / 12.0f;\n        }\n      }\n      else if (tag == 0x0093)\n      {\n        i = get2();\n        if ((i == 7) || (i == 9))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0098) // contains lens data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonLensDataVersion = NikonLensDataVersion * 10 + fgetc(ifp) - '0';\n        }\n        switch (NikonLensDataVersion)\n        {\n        case 100:\n          lenNikonLensData = 9;\n          break;\n        case 101:\n        case 201: // encrypted, starting from v.201\n        case 202:\n        case 203:\n          lenNikonLensData = 15;\n          break;\n        case 204:\n          lenNikonLensData = 16;\n          break;\n        case 400:\n          lenNikonLensData = 459;\n          break;\n        case 401:\n          lenNikonLensData = 590;\n          break;\n        case 402:\n          lenNikonLensData = 509;\n          break;\n        case 403:\n          lenNikonLensData = 879;\n          break;\n        }\n        if (lenNikonLensData > 0)\n        {\n          table_buf = (uchar *)malloc(lenNikonLensData);\n          fread(table_buf, lenNikonLensData, 1, ifp);\n          if ((NikonLensDataVersion < 201) && lenNikonLensData)\n          {\n            processNikonLensData(table_buf, lenNikonLensData);\n            free(table_buf);\n            lenNikonLensData = 0;\n          }\n        }\n      }\n      else if (tag == 0x00a0)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x00a8) // contains flash data\n      {\n        for (i = 0; i < 4; i++)\n        {\n          NikonFlashInfoVersion = NikonFlashInfoVersion * 10 + fgetc(ifp) - '0';\n        }\n      }\n    }\n\n    else if (!strncmp(make, \"OLYMPUS\", 7))\n    {\n      switch (tag)\n      {\n      case 0x0404:\n      case 0x101a:\n      case 0x20100101:\n        if (!imgdata.shootinginfo.BodySerial[0])\n          stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        break;\n      case 0x20100102:\n        if (!imgdata.shootinginfo.InternalBodySerial[0])\n          stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n        break;\n      case 0x0207:\n      case 0x20100100:\n      {\n        uchar sOlyID[8];\n        unsigned long long OlyID;\n        fread(sOlyID, MIN(len, 7), 1, ifp);\n        sOlyID[7] = 0;\n        OlyID = sOlyID[0];\n        i = 1;\n        while (i < 7 && sOlyID[i])\n        {\n          OlyID = OlyID << 8 | sOlyID[i];\n          i++;\n        }\n        setOlympusBodyFeatures(OlyID);\n      }\n      break;\n      case 0x1002:\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, getreal(type) / 2);\n        break;\n      case 0x20401112:\n        imgdata.makernotes.olympus.OlympusCropID = get2();\n        break;\n      case 0x20401113:\n        FORC4 imgdata.makernotes.olympus.OlympusFrame[c] = get2();\n        break;\n      case 0x20100201:\n      {\n        unsigned long long oly_lensid[3];\n        oly_lensid[0] = fgetc(ifp);\n        fgetc(ifp);\n        oly_lensid[1] = fgetc(ifp);\n        oly_lensid[2] = fgetc(ifp);\n        imgdata.lens.makernotes.LensID = (oly_lensid[0] << 16) | (oly_lensid[1] << 8) | oly_lensid[2];\n      }\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FT;\n        imgdata.lens.makernotes.LensFormat = LIBRAW_FORMAT_FT;\n        if (((imgdata.lens.makernotes.LensID < 0x20000) || (imgdata.lens.makernotes.LensID > 0x4ffff)) &&\n            (imgdata.lens.makernotes.LensID & 0x10))\n        {\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_mFT;\n        }\n        break;\n      case 0x20100202:\n        stmread(imgdata.lens.LensSerial, len, ifp);\n        break;\n      case 0x20100203:\n        stmread(imgdata.lens.makernotes.Lens, len, ifp);\n        break;\n      case 0x20100205:\n        imgdata.lens.makernotes.MaxAp4MinFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100206:\n        imgdata.lens.makernotes.MaxAp4MaxFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100207:\n        imgdata.lens.makernotes.MinFocal = (float)get2();\n        break;\n      case 0x20100208:\n        imgdata.lens.makernotes.MaxFocal = (float)get2();\n        if (imgdata.lens.makernotes.MaxFocal > 1000.0f)\n          imgdata.lens.makernotes.MaxFocal = imgdata.lens.makernotes.MinFocal;\n        break;\n      case 0x2010020a:\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(sqrt(2.0f), get2() / 256.0f);\n        break;\n      case 0x20100301:\n        imgdata.lens.makernotes.TeleconverterID = fgetc(ifp) << 8;\n        fgetc(ifp);\n        imgdata.lens.makernotes.TeleconverterID = imgdata.lens.makernotes.TeleconverterID | fgetc(ifp);\n        break;\n      case 0x20100303:\n        stmread(imgdata.lens.makernotes.Teleconverter, len, ifp);\n        break;\n      case 0x20100403:\n        stmread(imgdata.lens.makernotes.Attachment, len, ifp);\n        break;\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(make, \"RICOH\", 5)) && !strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        char buffer[17];\n        int count = 0;\n        fread(buffer, 16, 1, ifp);\n        buffer[16] = 0;\n        for (int i = 0; i < 16; i++)\n        {\n          //    \t        sprintf(imgdata.shootinginfo.InternalBodySerial+2*i, \"%02x\", buffer[i]);\n          if ((isspace(buffer[i])) || (buffer[i] == 0x2D) || (isalnum(buffer[i])))\n            count++;\n        }\n        if (count == 16)\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%8s\", buffer + 8);\n          buffer[8] = 0;\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n        }\n        else\n        {\n          sprintf(imgdata.shootinginfo.BodySerial, \"%02x%02x%02x%02x\", buffer[4], buffer[5], buffer[6], buffer[7]);\n          sprintf(imgdata.shootinginfo.InternalBodySerial, \"%02x%02x%02x%02x\", buffer[8], buffer[9], buffer[10],\n                  buffer[11]);\n        }\n      }\n      else if ((tag == 0x1001) && (type == 3))\n      {\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n        imgdata.lens.makernotes.LensID = -1;\n        imgdata.lens.makernotes.FocalType = 1;\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n    }\n\n    else if (!strncmp(make, \"RICOH\", 5) && strncmp(model, \"PENTAX\", 6))\n    {\n      if ((tag == 0x0005) && !strncmp(model, \"GXR\", 3))\n      {\n        char buffer[9];\n        buffer[8] = 0;\n        fread(buffer, 8, 1, ifp);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%8s\", buffer);\n      }\n\n      else if ((tag == 0x100b) && (type == 10))\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if ((tag == 0x1017) && (get2() == 2))\n      {\n        strcpy(imgdata.lens.makernotes.Attachment, \"Wide-Angle Adapter\");\n      }\n\n      else if (tag == 0x1500)\n      {\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      }\n\n      else if ((tag == 0x2001) && !strncmp(model, \"GXR\", 3))\n      {\n        short ntags, cur_tag;\n        fseek(ifp, 20, SEEK_CUR);\n        ntags = get2();\n        cur_tag = get2();\n        while (cur_tag != 0x002c)\n        {\n          fseek(ifp, 10, SEEK_CUR);\n          cur_tag = get2();\n        }\n        fseek(ifp, 6, SEEK_CUR);\n        fseek(ifp, get4() + 20, SEEK_SET);\n        stread(imgdata.shootinginfo.BodySerial, 12, ifp);\n        get2();\n        imgdata.lens.makernotes.LensID = getc(ifp) - '0';\n        switch (imgdata.lens.makernotes.LensID)\n        {\n        case 1:\n        case 2:\n        case 3:\n        case 5:\n        case 6:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_RicohModule;\n          break;\n        case 8:\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Leica_M;\n          imgdata.lens.makernotes.CameraFormat = LIBRAW_FORMAT_APSC;\n          imgdata.lens.makernotes.LensID = -1;\n          break;\n        default:\n          imgdata.lens.makernotes.LensID = -1;\n        }\n        fseek(ifp, 17, SEEK_CUR);\n        stread(imgdata.lens.LensSerial, 12, ifp);\n      }\n    }\n\n    else if ((!strncmp(make, \"PENTAX\", 6) || !strncmp(model, \"PENTAX\", 6) ||\n              (!strncmp(make, \"SAMSUNG\", 7) && dng_version)) &&\n             strncmp(model, \"GR\", 2))\n    {\n      if (tag == 0x0005)\n      {\n        unique_id = get4();\n        setPentaxBodyFeatures(unique_id);\n      }\n      else if (tag == 0x0013)\n      {\n        imgdata.lens.makernotes.CurAp = (float)get2() / 10.0f;\n      }\n      else if (tag == 0x0014)\n      {\n        PentaxISO(get2());\n      }\n      else if (tag == 0x001d)\n      {\n        imgdata.lens.makernotes.CurFocal = (float)get4() / 100.0f;\n      }\n      else if (tag == 0x003f)\n      {\n        imgdata.lens.makernotes.LensID = fgetc(ifp) << 8 | fgetc(ifp);\n      }\n      else if (tag == 0x004d)\n      {\n        if (type == 9)\n          imgdata.other.FlashEC = getreal(type) / 256.0f;\n        else\n          imgdata.other.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;\n      }\n      else if (tag == 0x007e)\n      {\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = (long)(-1) * get4();\n      }\n      else if (tag == 0x0207)\n      {\n        if (len < 65535) // Safety belt\n          PentaxLensInfo(imgdata.lens.makernotes.CamID, len);\n      }\n      else if (tag == 0x020d)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020e)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x020f)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0210)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0211)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0212)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0213)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0214)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0221)\n      {\n        int nWB = get2();\n        if (nWB <= sizeof(imgdata.color.WBCT_Coeffs) / sizeof(imgdata.color.WBCT_Coeffs[0]))\n          for (int i = 0; i < nWB; i++)\n          {\n            imgdata.color.WBCT_Coeffs[i][0] = (unsigned)0xcfc6 - get2();\n            fseek(ifp, 2, SEEK_CUR);\n            imgdata.color.WBCT_Coeffs[i][1] = get2();\n            imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = 0x2000;\n            imgdata.color.WBCT_Coeffs[i][3] = get2();\n          }\n      }\n      else if (tag == 0x0215)\n      {\n        fseek(ifp, 16, SEEK_CUR);\n        sprintf(imgdata.shootinginfo.InternalBodySerial, \"%d\", get4());\n      }\n      else if (tag == 0x0229)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0x022d)\n      {\n        fseek(ifp, 2, SEEK_CUR);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n        getc(ifp);\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ (c >> 1)] = get2();\n      }\n      else if (tag == 0x0239) // Q-series lens info (LensInfoQ)\n      {\n        char LensInfo[20];\n        fseek(ifp, 2, SEEK_CUR);\n        stread(imgdata.lens.makernotes.Lens, 30, ifp);\n        strcat(imgdata.lens.makernotes.Lens, \" \");\n        stread(LensInfo, 20, ifp);\n        strcat(imgdata.lens.makernotes.Lens, LensInfo);\n      }\n    }\n\n    else if (!strncmp(make, \"SAMSUNG\", 7))\n    {\n      if (tag == 0x0002)\n      {\n        if (get4() == 0x2000)\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX;\n        }\n        else if (!strncmp(model, \"NX mini\", 7))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;\n        }\n        else\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n      }\n      else if (tag == 0x0003)\n      {\n        unique_id = imgdata.lens.makernotes.CamID = get4();\n      }\n      else if (tag == 0xa002)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      }\n      else if (tag == 0xa003)\n      {\n        imgdata.lens.makernotes.LensID = get2();\n        if (imgdata.lens.makernotes.LensID)\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Samsung_NX;\n      }\n      else if (tag == 0xa005)\n      {\n        stmread(imgdata.lens.InternalLensSerial, len, ifp);\n      }\n      else if (tag == 0xa019)\n      {\n        imgdata.lens.makernotes.CurAp = getreal(type);\n      }\n      else if (tag == 0xa01a)\n      {\n        imgdata.lens.makernotes.FocalLengthIn35mmFormat = get4() / 10.0f;\n        if (imgdata.lens.makernotes.FocalLengthIn35mmFormat < 10.0f)\n          imgdata.lens.makernotes.FocalLengthIn35mmFormat *= 10.0f;\n      }\n    }\n\n    else if (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"Konica\", 6) || !strncasecmp(make, \"Minolta\", 7) ||\n             (!strncasecmp(make, \"Hasselblad\", 10) &&\n              (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) ||\n               !strncasecmp(model, \"Lusso\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      ushort lid;\n      if (tag == 0xb001) // Sony ModelID\n      {\n        unique_id = get2();\n        setSonyBodyFeatures(unique_id);\n        if (table_buf_0x9050_present)\n        {\n          process_Sony_0x9050(table_buf_0x9050, unique_id);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n        if (table_buf_0x940c_present)\n        {\n          if (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E)\n          {\n            process_Sony_0x940c(table_buf_0x940c);\n          }\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if ((tag == 0x0010) && // CameraInfo\n               strncasecmp(model, \"DSLR-A100\", 9) && strncasecmp(model, \"NEX-5C\", 6) && !strncasecmp(make, \"SONY\", 4) &&\n               ((len == 368) ||  // a700\n                (len == 5478) || // a850, a900\n                (len == 5506) || // a200, a300, a350\n                (len == 6118) || // a230, a290, a330, a380, a390\n                                 // a450, a500, a550, a560, a580\n                                 // a33, a35, a55\n                                 // NEX3, NEX5, NEX5C, NEXC3, VG10E\n                (len == 15360)))\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (memcmp(table_buf, \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\", 8) &&\n            memcmp(table_buf, \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8))\n        {\n          switch (len)\n          {\n          case 368:\n          case 5478:\n            // a700, a850, a900: CameraInfo\n            if (table_buf[0] | table_buf[3])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);\n            if (table_buf[2] | table_buf[5])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;\n            if (table_buf[4])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;\n            parseSonyLensFeatures(table_buf[1], table_buf[6]);\n            break;\n          default:\n            // CameraInfo2 & 3\n            if (table_buf[1] | table_buf[2])\n              imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n            if (table_buf[3] | table_buf[4])\n              imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n            if (table_buf[5])\n              imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n            if (table_buf[6])\n              imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n            parseSonyLensFeatures(table_buf[0], table_buf[7]);\n          }\n        }\n        free(table_buf);\n      }\n\n      else if ((tag == 0x0020) && // WBInfoA100, needs 0xb028 processing\n               !strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 0x49dc, SEEK_CUR);\n        stmread(imgdata.shootinginfo.InternalBodySerial, 12, ifp);\n      }\n\n      else if (tag == 0x0104)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n\n      else if (tag == 0x0105) // Teleconverter\n      {\n        imgdata.lens.makernotes.TeleconverterID = get2();\n      }\n\n      else if (tag == 0x0114 && len < 256000) // CameraSettings\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        switch (len)\n        {\n        case 280:\n        case 364:\n        case 332:\n          // CameraSettings and CameraSettings2 are big endian\n          if (table_buf[2] | table_buf[3])\n          {\n            lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);\n            imgdata.lens.makernotes.CurAp = powf64(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);\n          }\n          break;\n        case 1536:\n        case 2048:\n          // CameraSettings3 are little endian\n          parseSonyLensType2(table_buf[1016], table_buf[1015]);\n          if (imgdata.lens.makernotes.LensMount != LIBRAW_MOUNT_Canon_EF)\n          {\n            switch (table_buf[153])\n            {\n            case 16:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Minolta_A;\n              break;\n            case 17:\n              imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sony_E;\n              break;\n            }\n          }\n          break;\n        }\n        free(table_buf);\n      }\n\n      else if (tag == 0x9050 && len < 256000) // little endian\n      {\n        table_buf_0x9050 = (uchar *)malloc(len);\n        table_buf_0x9050_present = 1;\n        fread(table_buf_0x9050, len, 1, ifp);\n\n        if (imgdata.lens.makernotes.CamID)\n        {\n          process_Sony_0x9050(table_buf_0x9050, imgdata.lens.makernotes.CamID);\n          free(table_buf_0x9050);\n          table_buf_0x9050_present = 0;\n        }\n      }\n\n      else if (tag == 0x940c && len < 256000)\n      {\n        table_buf_0x940c = (uchar *)malloc(len);\n        table_buf_0x940c_present = 1;\n        fread(table_buf_0x940c, len, 1, ifp);\n        if ((imgdata.lens.makernotes.CamID) && (imgdata.lens.makernotes.CameraMount == LIBRAW_MOUNT_Sony_E))\n        {\n          process_Sony_0x940c(table_buf_0x940c);\n          free(table_buf_0x940c);\n          table_buf_0x940c_present = 0;\n        }\n      }\n\n      else if (((tag == 0xb027) || (tag == 0x010c)) && (imgdata.lens.makernotes.LensID == -1))\n      {\n        imgdata.lens.makernotes.LensID = get4();\n        if ((imgdata.lens.makernotes.LensID > 0x4900) && (imgdata.lens.makernotes.LensID <= 0x5900))\n        {\n          imgdata.lens.makernotes.AdapterID = 0x4900;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Sigma_X3F;\n          strcpy(imgdata.lens.makernotes.Adapter, \"MC-11\");\n        }\n\n        else if ((imgdata.lens.makernotes.LensID > 0xEF00) && (imgdata.lens.makernotes.LensID < 0xFFFF) &&\n                 (imgdata.lens.makernotes.LensID != 0xFF00))\n        {\n          imgdata.lens.makernotes.AdapterID = 0xEF00;\n          imgdata.lens.makernotes.LensID -= imgdata.lens.makernotes.AdapterID;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Canon_EF;\n        }\n        if (tag == 0x010c)\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Minolta_A;\n      }\n\n      else if (tag == 0xb02a && len < 256000) // Sony LensSpec\n      {\n        table_buf = (uchar *)malloc(len);\n        fread(table_buf, len, 1, ifp);\n        if (table_buf[1] | table_buf[2])\n          imgdata.lens.makernotes.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);\n        if (table_buf[3] | table_buf[4])\n          imgdata.lens.makernotes.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);\n        if (table_buf[5])\n          imgdata.lens.makernotes.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;\n        if (table_buf[6])\n          imgdata.lens.makernotes.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;\n        parseSonyLensFeatures(table_buf[0], table_buf[7]);\n        free(table_buf);\n      }\n    }\n\n    fseek(ifp, _pos, SEEK_SET);\n#endif\n\n    if (tag == 2 && strstr(make, \"NIKON\") && !iso_speed)\n      iso_speed = (get2(), get2());\n    if (tag == 37 && strstr(make, \"NIKON\") && (!iso_speed || iso_speed == 65535))\n    {\n      unsigned char cc;\n      fread(&cc, 1, 1, ifp);\n      iso_speed = int(100.0 * powf64(2.0f, float(cc) / 12.0 - 5.0));\n    }\n    if (tag == 4 && len > 26 && len < 35)\n    {\n      if ((i = (get4(), get2())) != 0x7fff && (!iso_speed || iso_speed == 65535))\n        iso_speed = 50 * powf64(2.0, i / 32.0 - 4);\n#ifdef LIBRAW_LIBRARY_BUILD\n      get4();\n#else\n      if ((i = (get2(), get2())) != 0x7fff && !aperture)\n        aperture = powf64(2.0, i / 64.0);\n#endif\n      if ((i = get2()) != 0xffff && !shutter)\n        shutter = powf64(2.0, (short)i / -32.0);\n      wbi = (get2(), get2());\n      shot_order = (get2(), get2());\n    }\n    if ((tag == 4 || tag == 0x114) && !strncmp(make, \"KONICA\", 6))\n    {\n      fseek(ifp, tag == 4 ? 140 : 160, SEEK_CUR);\n      switch (get2())\n      {\n      case 72:\n        flip = 0;\n        break;\n      case 76:\n        flip = 6;\n        break;\n      case 82:\n        flip = 5;\n        break;\n      }\n    }\n    if (tag == 7 && type == 2 && len > 20)\n      fgets(model2, 64, ifp);\n    if (tag == 8 && type == 4)\n      shot_order = get4();\n    if (tag == 9 && !strncmp(make, \"Canon\", 5))\n      fread(artist, 64, 1, ifp);\n    if (tag == 0xc && len == 4)\n      FORC3 cam_mul[(c << 1 | c >> 1) & 3] = getreal(type);\n    if (tag == 0xd && type == 7 && get2() == 0xaaaa)\n    {\n#if 0 /* Canon rotation data is handled by EXIF.Orientation */\n      for (c = i = 2; (ushort)c != 0xbbbb && i < len; i++)\n        c = c << 8 | fgetc(ifp);\n      while ((i += 4) < len - 5)\n        if (get4() == 257 && (i = len) && (c = (get4(), fgetc(ifp))) < 3)\n          flip = \"065\"[c] - '0';\n#endif\n    }\n\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x10 && type == 4)\n      unique_id = get4();\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 _pos2 = ftell(ifp);\n    if (!strncasecmp(make, \"Olympus\", 7))\n    {\n      short nWB, tWB;\n      if ((tag == 0x20300108) || (tag == 0x20310109))\n        imgdata.makernotes.olympus.ColorSpace = get2();\n\n      if ((tag == 0x20400102) && (len == 2) && (!strncasecmp(model, \"E-410\", 5) || !strncasecmp(model, \"E-510\", 5)))\n      {\n        int i;\n        for (i = 0; i < 64; i++)\n          imgdata.color.WBCT_Coeffs[i][2] = imgdata.color.WBCT_Coeffs[i][4] = imgdata.color.WB_Coeffs[i][1] =\n              imgdata.color.WB_Coeffs[i][3] = 0x100;\n        for (i = 64; i < 256; i++)\n          imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n      }\n      if ((tag >= 0x20400102) && (tag <= 0x2040010d))\n      {\n        ushort CT;\n        nWB = tag - 0x20400102;\n        switch (nWB)\n        {\n        case 0:\n          CT = 3000;\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 1:\n          CT = 3300;\n          tWB = 0x100;\n          break;\n        case 2:\n          CT = 3600;\n          tWB = 0x100;\n          break;\n        case 3:\n          CT = 3900;\n          tWB = 0x100;\n          break;\n        case 4:\n          CT = 4000;\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 5:\n          CT = 4300;\n          tWB = 0x100;\n          break;\n        case 6:\n          CT = 4500;\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 7:\n          CT = 4800;\n          tWB = 0x100;\n          break;\n        case 8:\n          CT = 5300;\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          CT = 6000;\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          CT = 6600;\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          CT = 7500;\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          CT = 0;\n          tWB = 0x100;\n        }\n        if (CT)\n        {\n          imgdata.color.WBCT_Coeffs[nWB][0] = CT;\n          imgdata.color.WBCT_Coeffs[nWB][1] = get2();\n          imgdata.color.WBCT_Coeffs[nWB][3] = get2();\n          if (len == 4)\n          {\n            imgdata.color.WBCT_Coeffs[nWB][2] = get2();\n            imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n          }\n        }\n        if (tWB != 0x100)\n          FORC4 imgdata.color.WB_Coeffs[tWB][c] = imgdata.color.WBCT_Coeffs[nWB][c + 1];\n      }\n      if ((tag >= 0x20400113) && (tag <= 0x2040011e))\n      {\n        nWB = tag - 0x20400113;\n        imgdata.color.WBCT_Coeffs[nWB][2] = imgdata.color.WBCT_Coeffs[nWB][4] = get2();\n        switch (nWB)\n        {\n        case 0:\n          tWB = LIBRAW_WBI_Tungsten;\n          break;\n        case 4:\n          tWB = LIBRAW_WBI_FL_W;\n          break;\n        case 6:\n          tWB = LIBRAW_WBI_FL_D;\n          break;\n        case 8:\n          tWB = LIBRAW_WBI_FineWeather;\n          break;\n        case 9:\n          tWB = LIBRAW_WBI_Cloudy;\n          break;\n        case 10:\n          tWB = LIBRAW_WBI_FL_N;\n          break;\n        case 11:\n          tWB = LIBRAW_WBI_Shade;\n          break;\n        default:\n          tWB = 0x100;\n        }\n        if (tWB != 0x100)\n          imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = imgdata.color.WBCT_Coeffs[nWB][2];\n      }\n\n      if (tag == 0x20400121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        if (len == 4)\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = get2();\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n        }\n      }\n      if (tag == 0x2040011f)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = get2();\n      }\n      if (tag == 0x30000120)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        if (len == 2)\n        {\n          for (int i = 0; i < 256; i++)\n            imgdata.color.WB_Coeffs[i][1] = imgdata.color.WB_Coeffs[i][3] = 0x100;\n        }\n      }\n      if (tag == 0x30000121)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n      }\n      if (tag == 0x30000122)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = get2();\n      }\n      if (tag == 0x30000123)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n      }\n      if (tag == 0x30000124)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Sunset][2] = get2();\n      }\n      if (tag == 0x30000130)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n      }\n      if (tag == 0x30000131)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n      }\n      if (tag == 0x30000132)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n      }\n      if (tag == 0x30000133)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n      }\n\n      if ((tag == 0x20400805) && (len == 2))\n      {\n        imgdata.makernotes.olympus.OlympusSensorCalibration[0] = getreal(type);\n        imgdata.makernotes.olympus.OlympusSensorCalibration[1] = getreal(type);\n        FORC4 imgdata.color.linear_max[c] = imgdata.makernotes.olympus.OlympusSensorCalibration[0];\n      }\n      if (tag == 0x20200401)\n      {\n        imgdata.other.FlashEC = getreal(type);\n      }\n    }\n    fseek(ifp, _pos2, SEEK_SET);\n\n#endif\n    if (tag == 0x11 && is_raw && !strncmp(make, \"NIKON\", 5))\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n    }\n    if (tag == 0x14 && type == 7)\n    {\n      if (len == 2560)\n      {\n        fseek(ifp, 1248, SEEK_CUR);\n        goto get2_256;\n      }\n      fread(buf, 1, 10, ifp);\n      if (!strncmp(buf, \"NRW \", 4))\n      {\n        fseek(ifp, strcmp(buf + 4, \"0100\") ? 46 : 1546, SEEK_CUR);\n        cam_mul[0] = get4() << 2;\n        cam_mul[1] = get4() + get4();\n        cam_mul[2] = get4() << 2;\n      }\n    }\n    if (tag == 0x15 && type == 2 && is_raw)\n      fread(model, 64, 1, ifp);\n    if (strstr(make, \"PENTAX\"))\n    {\n      if (tag == 0x1b)\n        tag = 0x1018;\n      if (tag == 0x1c)\n        tag = 0x1017;\n    }\n    if (tag == 0x1d)\n    {\n      while ((c = fgetc(ifp)) && c != EOF)\n#ifdef LIBRAW_LIBRARY_BUILD\n      {\n        if ((!custom_serial) && (!isdigit(c)))\n        {\n          if ((strbuflen(model) == 3) && (!strcmp(model, \"D50\")))\n          {\n            custom_serial = 34;\n          }\n          else\n          {\n            custom_serial = 96;\n          }\n        }\n#endif\n        serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);\n#ifdef LIBRAW_LIBRARY_BUILD\n      }\n      if (!imgdata.shootinginfo.BodySerial[0])\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", serial);\n#endif\n    }\n    if (tag == 0x29 && type == 1)\n    { // Canon PowerShot G9\n      c = wbi < 18 ? \"012347800000005896\"[wbi] - '0' : 0;\n      fseek(ifp, 8 + c * 32, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n    if (tag == 0x3d && type == 3 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2() >> (14 - tiff_bps);\n#endif\n    if (tag == 0x81 && type == 4)\n    {\n      data_offset = get4();\n      fseek(ifp, data_offset + 41, SEEK_SET);\n      raw_height = get2() * 2;\n      raw_width = get2();\n      filters = 0x61616161;\n    }\n    if ((tag == 0x81 && type == 7) || (tag == 0x100 && type == 7) || (tag == 0x280 && type == 1))\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (tag == 0x88 && type == 4 && (thumb_offset = get4()))\n      thumb_offset += base;\n    if (tag == 0x89 && type == 4)\n      thumb_length = get4();\n    if (tag == 0x8c || tag == 0x96)\n      meta_offset = ftell(ifp);\n    if (tag == 0x97)\n    {\n      for (i = 0; i < 4; i++)\n        ver97 = ver97 * 10 + fgetc(ifp) - '0';\n      switch (ver97)\n      {\n      case 100:\n        fseek(ifp, 68, SEEK_CUR);\n        FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();\n        break;\n      case 102:\n        fseek(ifp, 6, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = get2();\n        break;\n      case 103:\n        fseek(ifp, 16, SEEK_CUR);\n        FORC4 cam_mul[c] = get2();\n      }\n      if (ver97 >= 200)\n      {\n        if (ver97 != 205)\n          fseek(ifp, 280, SEEK_CUR);\n        fread(buf97, 324, 1, ifp);\n      }\n    }\n    if (tag == 0xa1 && type == 7)\n    {\n      order = 0x4949;\n      fseek(ifp, 140, SEEK_CUR);\n      FORC3 cam_mul[c] = get4();\n    }\n    if (tag == 0xa4 && type == 3)\n    {\n      fseek(ifp, wbi * 48, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n    }\n\n    if (tag == 0xa7)\n    { // shutter count\n      NikonKey = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);\n      if ((unsigned)(ver97 - 200) < 17)\n      {\n        ci = xlat[0][serial & 0xff];\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < 324; i++)\n          buf97[i] ^= (cj += ci * ck++);\n        i = \"66666>666;6A;:;55\"[ver97 - 200] - '0';\n        FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] = sget2(buf97 + (i & -2) + c * 2);\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if ((NikonLensDataVersion > 200) && lenNikonLensData)\n      {\n        if (custom_serial)\n        {\n          ci = xlat[0][custom_serial];\n        }\n        else\n        {\n          ci = xlat[0][serial & 0xff];\n        }\n        cj = xlat[1][NikonKey];\n        ck = 0x60;\n        for (i = 0; i < lenNikonLensData; i++)\n          table_buf[i] ^= (cj += ci * ck++);\n        processNikonLensData(table_buf, lenNikonLensData);\n        lenNikonLensData = 0;\n        free(table_buf);\n      }\n      if (ver97 == 601) // Coolpix A\n      {\n        imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      }\n#endif\n    }\n\n    if (tag == 0xb001 && type == 3) // Sony ModelID\n    {\n      unique_id = get2();\n    }\n    if (tag == 0x200 && len == 3)\n      shot_order = (get4(), get4());\n    if (tag == 0x200 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x201 && len == 4)\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    if (tag == 0x220 && type == 7)\n      meta_offset = ftell(ifp);\n    if (tag == 0x401 && type == 4 && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    // not corrected for file bitcount, to be patched in open_datastream\n    if (tag == 0x03d && strstr(make, \"NIKON\") && len == 4)\n    {\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black += i;\n    }\n#endif\n    if (tag == 0xe01)\n    { /* Nikon Capture Note */\n#ifdef LIBRAW_LIBRARY_BUILD\n      int loopc = 0;\n#endif\n      order = 0x4949;\n      fseek(ifp, 22, SEEK_CUR);\n      for (offset = 22; offset + 22 < len; offset += 22 + i)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (loopc++ > 1024)\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n        tag = get4();\n        fseek(ifp, 14, SEEK_CUR);\n        i = get4() - 4;\n        if (tag == 0x76a43207)\n          flip = get2();\n        else\n          fseek(ifp, i, SEEK_CUR);\n      }\n    }\n    if (tag == 0xe80 && len == 256 && type == 7)\n    {\n      fseek(ifp, 48, SEEK_CUR);\n      cam_mul[0] = get2() * 508 * 1.078 / 0x10000;\n      cam_mul[2] = get2() * 382 * 1.173 / 0x10000;\n    }\n    if (tag == 0xf00 && type == 7)\n    {\n      if (len == 614)\n        fseek(ifp, 176, SEEK_CUR);\n      else if (len == 734 || len == 1502)\n        fseek(ifp, 148, SEEK_CUR);\n      else\n        goto next;\n      goto get2_256;\n    }\n    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)\n      for (i = 0; i < 3; i++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!imgdata.makernotes.olympus.ColorSpace)\n        {\n          FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n        }\n        else\n        {\n          FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;\n        }\n#else\n        FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;\n#endif\n      }\n    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)\n      FORC4 cblack[c ^ c >> 1] = get2();\n    if (tag == 0x1017 || tag == 0x20400100)\n      cam_mul[0] = get2() / 256.0;\n    if (tag == 0x1018 || tag == 0x20400100)\n      cam_mul[2] = get2() / 256.0;\n    if (tag == 0x2011 && len == 2)\n    {\n    get2_256:\n      order = 0x4d4d;\n      cam_mul[0] = get2() / 256.0;\n      cam_mul[2] = get2() / 256.0;\n    }\n    if ((tag | 0x70) == 0x2070 && (type == 4 || type == 13))\n      fseek(ifp, get4() + base, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    if (tag == 0x2010)\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, 0x2010);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n\n    if (((tag == 0x2020) || (tag == 0x3000) || (tag == 0x2030) || (tag == 0x2031)) && ((type == 7) || (type == 13)) &&\n        !strncasecmp(make, \"Olympus\", 7))\n    {\n      INT64 _pos3 = ftell(ifp);\n      parse_makernote(base, tag);\n      fseek(ifp, _pos3, SEEK_SET);\n    }\n// IB end\n#endif\n    if ((tag == 0x2020) && ((type == 7) || (type == 13)) && !strncmp(buf, \"OLYMP\", 5))\n      parse_thumb_note(base, 257, 258);\n    if (tag == 0x2040)\n      parse_makernote(base, 0x2040);\n    if (tag == 0xb028)\n    {\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_thumb_note(base, 136, 137);\n    }\n    if (tag == 0x4001 && len > 500 && len < 100000)\n    {\n      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;\n      fseek(ifp, i, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n      for (i += 18; i <= len; i += 10)\n      {\n        get2();\n        FORC4 sraw_mul[c ^ (c >> 1)] = get2();\n        if (sraw_mul[1] == 1170)\n          break;\n      }\n    }\n    if (!strncasecmp(make, \"Samsung\", 7))\n    {\n      if (tag == 0xa020) // get the full Samsung encryption key\n        for (i = 0; i < 11; i++)\n          SamsungKey[i] = get4();\n      if (tag == 0xa021) // get and decode Samsung cam_mul array\n        FORC4 cam_mul[c ^ (c >> 1)] = get4() - SamsungKey[c];\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tag == 0xa023)\n      {\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] = get4() - SamsungKey[8];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = get4() - SamsungKey[9];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = get4() - SamsungKey[10];\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][2] = get4() - SamsungKey[0];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Ill_A][3] >> 4;\n        }\n      }\n      if (tag == 0xa024)\n      {\n        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][c ^ (c >> 1)] = get4() - SamsungKey[c + 1];\n        if (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][0] < (imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 1))\n        {\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][1] >> 4;\n          imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_D65][3] >> 4;\n        }\n      }\n      if (tag == 0xa025)\n        imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n            imgdata.color.linear_max[3] = get4() - SamsungKey[0];\n      if (tag == 0xa030 && len == 9)\n        for (i = 0; i < 3; i++)\n          FORC3 imgdata.color.ccm[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n#endif\n      if (tag == 0xa031 && len == 9) // get and decode Samsung color matrix\n        for (i = 0; i < 3; i++)\n          FORC3 cmatrix[i][c] = (float)((short)((get4() + SamsungKey[i * 3 + c]))) / 256.0;\n\n      if (tag == 0xa028)\n        FORC4 cblack[c ^ (c >> 1)] = get4() - SamsungKey[c];\n    }\n    else\n    {\n      // Somebody else use 0xa021 and 0xa028?\n      if (tag == 0xa021)\n        FORC4 cam_mul[c ^ (c >> 1)] = get4();\n      if (tag == 0xa028)\n        FORC4 cam_mul[c ^ (c >> 1)] -= get4();\n    }\n    if (tag == 0x4021 && get4() && get4())\n      FORC4 cam_mul[c] = 1024;\n  next:\n    fseek(ifp, save, SEEK_SET);\n  }\nquit:\n  order = sorder;\n}\n\n/*\n   Since the TIFF DateTime string has no timezone information,\n   assume that the camera's clock was set to Universal Time.\n */\nvoid CLASS get_timestamp(int reversed)\n{\n  struct tm t;\n  char str[20];\n  int i;\n\n  str[19] = 0;\n  if (reversed)\n    for (i = 19; i--;)\n      str[i] = fgetc(ifp);\n  else\n    fread(str, 19, 1, ifp);\n  memset(&t, 0, sizeof t);\n  if (sscanf(str, \"%d:%d:%d %d:%d:%d\", &t.tm_year, &t.tm_mon, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec) != 6)\n    return;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  t.tm_isdst = -1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n}\n\nvoid CLASS parse_exif(int base)\n{\n  unsigned kodak, entries, tag, type, len, save, c;\n  double expo, ape;\n\n  kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n  entries = get2();\n  if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && savepos + len > fsize * 2)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n    switch (tag)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.dng.MinFocal = getreal(type);\n      imgdata.lens.dng.MaxFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n#endif\n    case 33434:\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n      break;\n    case 33437:\n      aperture = getreal(type);\n      break; // 0x829d FNumber\n    case 34855:\n      iso_speed = get2();\n      break;\n    case 34866:\n      if (iso_speed == 0xffff && (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n        iso_speed = getreal(type);\n      break;\n    case 36867:\n    case 36868:\n      get_timestamp(0);\n      break;\n    case 37377:\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter = powf64(2.0, expo);\n      break;\n    case 37378: // 0x9202 ApertureValue\n      if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n        aperture = powf64(2.0, ape / 2);\n      break;\n    case 37385:\n      flash_used = getreal(type);\n      break;\n    case 37386:\n      focal_len = getreal(type);\n      break;\n    case 37500: // tag 0x927c\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\", 6))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_OV5647\", 9))) ||\n          ((!strncmp(make, \"RaspberryPi\", 11)) && (!strncmp(model, \"RP_imx219\", 9))))\n      {\n        char mn_text[512];\n        char *pos;\n        char ccms[512];\n        ushort l;\n        float num;\n\n        fgets(mn_text, len, ifp);\n        pos = strstr(mn_text, \"gain_r=\");\n        if (pos)\n          cam_mul[0] = atof(pos + 7);\n        pos = strstr(mn_text, \"gain_b=\");\n        if (pos)\n          cam_mul[2] = atof(pos + 7);\n        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n          cam_mul[1] = cam_mul[3] = 1.0f;\n        else\n          cam_mul[0] = cam_mul[2] = 0.0f;\n\n        pos = strstr(mn_text, \"ccm=\") + 4;\n        l = strstr(pos, \" \") - pos;\n        memcpy(ccms, pos, l);\n        ccms[l] = '\\0';\n\n        pos = strtok(ccms, \",\");\n        for (l = 0; l < 4; l++)\n        {\n          num = 0.0;\n          for (c = 0; c < 3; c++)\n          {\n            imgdata.color.ccm[l][c] = (float)atoi(pos);\n            num += imgdata.color.ccm[l][c];\n            pos = strtok(NULL, \",\");\n          }\n          if (num > 0.01)\n            FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n        }\n      }\n      else\n#endif\n        parse_makernote(base, 0);\n      break;\n    case 40962:\n      if (kodak)\n        raw_width = get4();\n      break;\n    case 40963:\n      if (kodak)\n        raw_height = get4();\n      break;\n    case 41730:\n      if (get4() == 0x20002)\n        for (exif_cfa = c = 0; c < 8; c += 2)\n          exif_cfa |= fgetc(ifp) * 0x01010101 << c;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS parse_gps_libraw(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  if (entries > 200)\n    return;\n  if (entries > 0)\n    imgdata.other.parsed_gps.gpsparsed = 1;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n      imgdata.other.parsed_gps.latref = getc(ifp);\n      break;\n    case 3:\n      imgdata.other.parsed_gps.longref = getc(ifp);\n      break;\n    case 5:\n      imgdata.other.parsed_gps.altref = getc(ifp);\n      break;\n    case 2:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.latitude[c] = getreal(type);\n      break;\n    case 4:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.longtitude[c] = getreal(type);\n      break;\n    case 7:\n      if (len == 3)\n        FORC(3) imgdata.other.parsed_gps.gpstimestamp[c] = getreal(type);\n      break;\n    case 6:\n      imgdata.other.parsed_gps.altitude = getreal(type);\n      break;\n    case 9:\n      imgdata.other.parsed_gps.gpsstatus = getc(ifp);\n      break;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\n\nvoid CLASS parse_gps(int base)\n{\n  unsigned entries, tag, type, len, save, c;\n\n  entries = get2();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (len > 1024)\n      continue; // no GPS tags are 1k or larger\n    switch (tag)\n    {\n    case 1:\n    case 3:\n    case 5:\n      gpsdata[29 + tag / 2] = getc(ifp);\n      break;\n    case 2:\n    case 4:\n    case 7:\n      FORC(6) gpsdata[tag / 3 * 6 + c] = get4();\n      break;\n    case 6:\n      FORC(2) gpsdata[18 + c] = get4();\n      break;\n    case 18:\n    case 29:\n      fgets((char *)(gpsdata + 14 + tag / 3), MIN(len, 12), ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS romm_coeff(float romm_cam[3][3])\n{\n  static const float rgb_romm[3][3] = /* ROMM == Kodak ProPhoto */\n      {{2.034193, -0.727420, -0.306766}, {-0.228811, 1.231729, -0.002922}, {-0.008565, -0.153273, 1.161839}};\n  int i, j, k;\n\n  for (i = 0; i < 3; i++)\n    for (j = 0; j < 3; j++)\n      for (cmatrix[i][j] = k = 0; k < 3; k++)\n        cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];\n}\n\nvoid CLASS parse_mos(int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes = 0, frot = 0;\n  static const char *mod[] = {\"\",\n                              \"DCB2\",\n                              \"Volare\",\n                              \"Cantare\",\n                              \"CMost\",\n                              \"Valeo 6\",\n                              \"Valeo 11\",\n                              \"Valeo 22\",\n                              \"Valeo 11p\",\n                              \"Valeo 17\",\n                              \"\",\n                              \"Aptus 17\",\n                              \"Aptus 22\",\n                              \"Aptus 75\",\n                              \"Aptus 65\",\n                              \"Aptus 54S\",\n                              \"Aptus 65S\",\n                              \"Aptus 75S\",\n                              \"AFi 5\",\n                              \"AFi 6\",\n                              \"AFi 7\",\n                              \"AFi-II 7\",\n                              \"Aptus-II 7\",\n                              \"\",\n                              \"Aptus-II 6\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10\",\n                              \"Aptus-II 5\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"\",\n                              \"Aptus-II 10R\",\n                              \"Aptus-II 8\",\n                              \"\",\n                              \"Aptus-II 12\",\n                              \"\",\n                              \"AFi-II 12\"};\n  float romm_cam[3][3];\n\n  fseek(ifp, offset, SEEK_SET);\n  while (1)\n  {\n    if (get4() != 0x504b5453)\n      break;\n    get4();\n    fread(data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strcmp(data, \"CameraObj_camera_type\"))\n    {\n      stmread(imgdata.lens.makernotes.body, skip, ifp);\n    }\n    if (!strcmp(data, \"back_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.BodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));\n      strcpy(imgdata.shootinginfo.BodySerial, words[0]);\n    }\n    if (!strcmp(data, \"CaptProf_serial_number\"))\n    {\n      char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];\n      char *words[4];\n      int nwords;\n      stmread(buffer, skip, ifp);\n      nwords = getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.InternalBodySerial));\n      strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);\n    }\n#endif\n    // IB end\n    if (!strcmp(data, \"JPEG_preview_data\"))\n    {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data, \"icc_camera_profile\"))\n    {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data, \"ShootObj_back_type\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      if ((unsigned)i < sizeof mod / sizeof(*mod))\n        strcpy(model, mod[i]);\n    }\n    if (!strcmp(data, \"icc_camera_to_tone_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        ((float *)romm_cam)[i] = int_to_float(get4());\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_color_matrix\"))\n    {\n      for (i = 0; i < 9; i++)\n        fscanf(ifp, \"%f\", (float *)romm_cam + i);\n      romm_coeff(romm_cam);\n    }\n    if (!strcmp(data, \"CaptProf_number_of_planes\"))\n      fscanf(ifp, \"%d\", &planes);\n    if (!strcmp(data, \"CaptProf_raw_data_rotation\"))\n      fscanf(ifp, \"%d\", &flip);\n    if (!strcmp(data, \"CaptProf_mosaic_pattern\"))\n      FORC4\n      {\n        fscanf(ifp, \"%d\", &i);\n        if (i == 1)\n          frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data, \"ImgProf_rotation_angle\"))\n    {\n      fscanf(ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data, \"NeutObj_neutrals\") && !cam_mul[0])\n    {\n      FORC4 fscanf(ifp, \"%d\", neut + c);\n      FORC3 cam_mul[c] = (float)neut[0] / neut[c + 1];\n    }\n    if (!strcmp(data, \"Rows_data\"))\n      load_flags = get4();\n    parse_mos(from);\n    fseek(ifp, skip + from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 * (uchar) \"\\x94\\x61\\x16\\x49\"[(flip / 90 + frot) & 3];\n}\n\nvoid CLASS linear_table(unsigned len)\n{\n  int i;\n  if (len > 0x10000)\n    len = 0x10000;\n  read_shorts(curve, len);\n  for (i = len; i < 0x10000; i++)\n    curve[i] = curve[i - 1];\n  maximum = curve[len < 0x1000 ? 0xfff : len - 1];\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\nvoid CLASS Kodak_WB_0x08tags(int wb, unsigned type)\n{\n  float mul[3] = {1, 1, 1}, num, mul2;\n  int c;\n  FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n  imgdata.color.WB_Coeffs[wb][1] = imgdata.color.WB_Coeffs[wb][3] = mul[1];\n  mul2 = mul[1] * mul[1];\n  imgdata.color.WB_Coeffs[wb][0] = mul2 / mul[0];\n  imgdata.color.WB_Coeffs[wb][2] = mul2 / mul[2];\n  return;\n}\n\n/* Thanks to Alexey Danilchenko for wb as-shot parsing code */\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n  //  int a_blck = 0;\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  INT64 fsize = ifp->size();\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > 2 * fsize)\n      continue;\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n    if (tag == 1011)\n      imgdata.other.FlashEC = getreal(type);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());\n      wbi = -2;\n    }\n\n    if ((tag == 0x03ef) && (!strcmp(model, \"EOS D2000C\")))\n      black = get2();\n    if ((tag == 0x03f0) && (!strcmp(model, \"EOS D2000C\")))\n    {\n      if (black) // already set by tag 0x03ef\n        black = (black + get2()) / 2;\n      else\n        black = get2();\n    }\n    if (tag == 0x0848)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Daylight, type);\n    if (tag == 0x0849)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Tungsten, type);\n    if (tag == 0x084a)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Fluorescent, type);\n    if (tag == 0x084b)\n      Kodak_WB_0x08tags(LIBRAW_WBI_Flash, type);\n    if (tag == 0x0e93)\n      imgdata.color.linear_max[0] = imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =\n          imgdata.color.linear_max[3] = get2();\n    if (tag == 0x09ce)\n      stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);\n    if (tag == 0xfa00)\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n    if (tag == 0xfa27)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n    }\n    if (tag == 0xfa28)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n    }\n    if (tag == 0xfa29)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n    }\n    if (tag == 0xfa2a)\n    {\n      FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get4();\n      imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n    }\n\n    if (tag == 2120 + wbi || (wbi < 0 && tag == 2125)) /* use Auto WB if illuminant index is not set */\n    {\n      FORC3 mul[c] = (num = getreal(type)) == 0 ? 1 : num;\n      FORC3 cam_mul[c] = mul[1] / mul[c]; /* normalise against green */\n    }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 0x903)\n      iso_speed = getreal(type);\n    // if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#else\nvoid CLASS parse_kodak_ifd(int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi = -2, wbtemp = 6500;\n  float mul[3] = {1, 1, 1}, num;\n  static const int wbtag[] = {64037, 64040, 64039, 64041, -1, -1, 64042};\n\n  entries = get2();\n  if (entries > 1024)\n    return;\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n    if (tag == 1020)\n      wbi = getint(type);\n    if (tag == 1021 && len == 72)\n    { /* WB set in software */\n      fseek(ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, get2());\n      wbi = -2;\n    }\n    if (tag == 2118)\n      wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / fMAX(1.0, getreal(type));\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3\n      {\n        for (num = i = 0; i < 4; i++)\n          num += getreal(type) * pow(wbtemp / 100.0, i);\n        cam_mul[c] = 2048 / fMAX(1.0, (num * mul[c]));\n      }\n    if (tag == 2317)\n      linear_table(len);\n    if (tag == 6020)\n      iso_speed = getint(type);\n    if (tag == 64013)\n      wbi = fgetc(ifp);\n    if ((unsigned)wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019)\n      width = getint(type);\n    if (tag == 64020)\n      height = (getint(type) + 1) & -2;\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n#endif\nint CLASS parse_tiff_ifd(int base)\n{\n  unsigned entries, tag, type, len, plen = 16, save;\n  int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;\n  char *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];\n  double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};\n  unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};\n  unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;\n  struct jhead jh;\n  int pana_raw = 0;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512)\n    return 1;\n#ifdef LIBRAW_LIBRARY_BUILD\n  INT64 fsize = ifp->size();\n#endif\n  while (entries--)\n  {\n    tiff_get(base, &tag, &type, &len, &save);\n#ifdef LIBRAW_LIBRARY_BUILD\n    INT64 savepos = ftell(ifp);\n    if (len > 8 && len + savepos > fsize * 2)\n      continue; // skip tag pointing out of 2xfile\n    if (callbacks.exif_cb)\n    {\n      callbacks.exif_cb(callbacks.exifparser_data, tag | (pana_raw ? 0x30000 : 0), type, len, order, ifp);\n      fseek(ifp, savepos, SEEK_SET);\n    }\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncasecmp(make, \"SONY\", 4) ||\n        (!strncasecmp(make, \"Hasselblad\", 10) &&\n         (!strncasecmp(model, \"Stellar\", 7) || !strncasecmp(model, \"Lunar\", 5) || !strncasecmp(model, \"HV\", 2))))\n    {\n      switch (tag)\n      {\n      case 0x7300: // SR2 black level\n        for (int i = 0; i < 4 && i < len; i++)\n          cblack[i] = get2();\n        break;\n      case 0x7480:\n      case 0x7820:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1];\n        break;\n      case 0x7481:\n      case 0x7821:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1];\n        break;\n      case 0x7482:\n      case 0x7822:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1];\n        break;\n      case 0x7483:\n      case 0x7823:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1];\n        break;\n      case 0x7484:\n      case 0x7824:\n        imgdata.color.WBCT_Coeffs[0][0] = 4500;\n        FORC3 imgdata.color.WBCT_Coeffs[0][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[0][4] = imgdata.color.WBCT_Coeffs[0][2];\n        break;\n      case 0x7486:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Fluorescent][1];\n        break;\n      case 0x7825:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1];\n        break;\n      case 0x7826:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1];\n        break;\n      case 0x7827:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1];\n        break;\n      case 0x7828:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1];\n        break;\n      case 0x7829:\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1];\n        break;\n      case 0x782a:\n        imgdata.color.WBCT_Coeffs[1][0] = 8500;\n        FORC3 imgdata.color.WBCT_Coeffs[1][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[1][4] = imgdata.color.WBCT_Coeffs[1][2];\n        break;\n      case 0x782b:\n        imgdata.color.WBCT_Coeffs[2][0] = 6000;\n        FORC3 imgdata.color.WBCT_Coeffs[2][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[2][4] = imgdata.color.WBCT_Coeffs[2][2];\n        break;\n      case 0x782c:\n        imgdata.color.WBCT_Coeffs[3][0] = 3200;\n        FORC3 imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][c] = imgdata.color.WBCT_Coeffs[3][c + 1] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][3] = imgdata.color.WBCT_Coeffs[3][4] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_StudioTungsten][1];\n        break;\n      case 0x782d:\n        imgdata.color.WBCT_Coeffs[4][0] = 2500;\n        FORC3 imgdata.color.WBCT_Coeffs[4][c + 1] = get2();\n        imgdata.color.WBCT_Coeffs[4][4] = imgdata.color.WBCT_Coeffs[4][2];\n        break;\n      case 0x787f:\n        FORC3 imgdata.color.linear_max[c] = get2();\n        imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n        break;\n      }\n    }\n#endif\n\n    switch (tag)\n    {\n    case 1:\n      if (len == 4)\n        pana_raw = get4();\n      break;\n    case 5:\n      width = get2();\n      break;\n    case 6:\n      height = get2();\n      break;\n    case 7:\n      width += get2();\n      break;\n    case 9:\n      if ((i = get2()))\n        filters = i;\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += i;\n#endif\n      break;\n    case 8:\n    case 10:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n        pana_black[3] += get2();\n#endif\n      break;\n    case 14:\n    case 15:\n    case 16:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        imgdata.color.linear_max[tag - 14] = get2();\n        if (tag == 15)\n          imgdata.color.linear_max[3] = imgdata.color.linear_max[1];\n      }\n#endif\n      break;\n    case 17:\n    case 18:\n      if (type == 3 && len == 1)\n        cam_mul[(tag - 17) * 2] = get2() / 256.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 19:\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = 0x100;\n          }\n          else\n            get4();\n        }\n      }\n      break;\n#endif\n    case 23:\n      if (type == 3)\n        iso_speed = get2();\n      break;\n    case 28:\n    case 29:\n    case 30:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw && len == 1 && type == 3)\n      {\n        pana_black[tag - 28] = get2();\n      }\n      else\n#endif\n      {\n        cblack[tag - 28] = get2();\n        cblack[3] = cblack[1];\n      }\n      break;\n    case 36:\n    case 37:\n    case 38:\n      cam_mul[tag - 36] = get2();\n      break;\n    case 39:\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (pana_raw)\n      {\n        ushort nWB, cnt, tWB;\n        nWB = get2();\n        if (nWB > 0x100)\n          break;\n        for (cnt = 0; cnt < nWB; cnt++)\n        {\n          tWB = get2();\n          if (tWB < 0x100)\n          {\n            imgdata.color.WB_Coeffs[tWB][0] = get2();\n            imgdata.color.WB_Coeffs[tWB][1] = imgdata.color.WB_Coeffs[tWB][3] = get2();\n            imgdata.color.WB_Coeffs[tWB][2] = get2();\n          }\n          else\n            fseek(ifp, 6, SEEK_CUR);\n        }\n      }\n      break;\n#endif\n      if (len < 50 || cam_mul[0])\n        break;\n      fseek(ifp, 12, SEEK_CUR);\n      FORC3 cam_mul[c] = get2();\n      break;\n    case 46:\n      if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n        break;\n      thumb_offset = ftell(ifp) - 2;\n      thumb_length = len;\n      break;\n    case 61440: /* Fuji HS10 table */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 2:\n    case 256:\n    case 61441: /* ImageWidth */\n      tiff_ifd[ifd].t_width = getint(type);\n      break;\n    case 3:\n    case 257:\n    case 61442: /* ImageHeight */\n      tiff_ifd[ifd].t_height = getint(type);\n      break;\n    case 258: /* BitsPerSample */\n    case 61443:\n      tiff_ifd[ifd].samples = len & 7;\n      tiff_ifd[ifd].bps = getint(type);\n      if (tiff_bps < tiff_ifd[ifd].bps)\n        tiff_bps = tiff_ifd[ifd].bps;\n      break;\n    case 61446:\n      raw_height = 0;\n      if (tiff_ifd[ifd].bps > 12)\n        break;\n      load_raw = &CLASS packed_load_raw;\n      load_flags = get4() ? 24 : 80;\n      break;\n    case 259: /* Compression */\n      tiff_ifd[ifd].comp = getint(type);\n      break;\n    case 262: /* PhotometricInterpretation */\n      tiff_ifd[ifd].phint = get2();\n      break;\n    case 270: /* ImageDescription */\n      fread(desc, 512, 1, ifp);\n      break;\n    case 271: /* Make */\n      fgets(make, 64, ifp);\n      break;\n    case 272: /* Model */\n      fgets(model, 64, ifp);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 278:\n      tiff_ifd[ifd].rows_per_strip = getint(type);\n      break;\n#endif\n    case 280: /* Panasonic RW2 offset */\n      if (type != 4)\n        break;\n      load_raw = &CLASS panasonic_load_raw;\n      load_flags = 0x2008;\n    case 273: /* StripOffset */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_offsets_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_offsets[i] = get4() + base;\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 513: /* JpegIFOffset */\n    case 61447:\n      tiff_ifd[ifd].offset = get4() + base;\n      if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)\n      {\n        fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);\n        if (ljpeg_start(&jh, 1))\n        {\n          tiff_ifd[ifd].comp = 6;\n          tiff_ifd[ifd].t_width = jh.wide;\n          tiff_ifd[ifd].t_height = jh.high;\n          tiff_ifd[ifd].bps = jh.bits;\n          tiff_ifd[ifd].samples = jh.clrs;\n          if (!(jh.sraw || (jh.clrs & 1)))\n            tiff_ifd[ifd].t_width *= jh.clrs;\n          if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)\n          {\n            tiff_ifd[ifd].t_width /= 2;\n            tiff_ifd[ifd].t_height *= 2;\n          }\n          i = order;\n          parse_tiff(tiff_ifd[ifd].offset + 12);\n          order = i;\n        }\n      }\n      break;\n    case 274: /* Orientation */\n      tiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7] - '0';\n      break;\n    case 277: /* SamplesPerPixel */\n      tiff_ifd[ifd].samples = getint(type) & 7;\n      break;\n    case 279: /* StripByteCounts */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (len > 1 && len < 16384)\n      {\n        off_t sav = ftell(ifp);\n        tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));\n        tiff_ifd[ifd].strip_byte_counts_count = len;\n        for (int i = 0; i < len; i++)\n          tiff_ifd[ifd].strip_byte_counts[i] = get4();\n        fseek(ifp, sav, SEEK_SET); // restore position\n      }\n/* fallback */\n#endif\n    case 514:\n    case 61448:\n      tiff_ifd[ifd].bytes = get4();\n      break;\n    case 61454:\n      FORC3 cam_mul[(4 - c) % 3] = getint(type);\n      break;\n    case 305:\n    case 11: /* Software */\n      fgets(software, 64, ifp);\n      if (!strncmp(software, \"Adobe\", 5) || !strncmp(software, \"dcraw\", 5) || !strncmp(software, \"UFRaw\", 5) ||\n          !strncmp(software, \"Bibble\", 6) || !strcmp(software, \"Digital Photo Professional\"))\n        is_raw = 0;\n      break;\n    case 306: /* DateTime */\n      get_timestamp(0);\n      break;\n    case 315: /* Artist */\n      fread(artist, 64, 1, ifp);\n      break;\n    case 317:\n      tiff_ifd[ifd].predictor = getint(type);\n      break;\n    case 322: /* TileWidth */\n      tiff_ifd[ifd].t_tile_width = getint(type);\n      break;\n    case 323: /* TileLength */\n      tiff_ifd[ifd].t_tile_length = getint(type);\n      break;\n    case 324: /* TileOffsets */\n      tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n      if (len == 1)\n        tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;\n      if (len == 4)\n      {\n        load_raw = &CLASS sinar_4shot_load_raw;\n        is_raw = 5;\n      }\n      break;\n    case 325:\n      tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();\n      break;\n    case 330: /* SubIFDs */\n      if (!strcmp(model, \"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872)\n      {\n        load_raw = &CLASS sony_arw_load_raw;\n        data_offset = get4() + base;\n        ifd++;\n#ifdef LIBRAW_LIBRARY_BUILD\n\tif (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif    \n        break;\n      }\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (!strncmp(make, \"Hasselblad\", 10) && libraw_internal_data.unpacker_data.hasselblad_parser_flag)\n      {\n        fseek(ifp, ftell(ifp) + 4, SEEK_SET);\n        fseek(ifp, get4() + base, SEEK_SET);\n        parse_tiff_ifd(base);\n        break;\n      }\n#endif\n      if (len > 1000)\n        len = 1000; /* 1000 SubIFDs is enough */\n      while (len--)\n      {\n        i = ftell(ifp);\n        fseek(ifp, get4() + base, SEEK_SET);\n        if (parse_tiff_ifd(base))\n          break;\n        fseek(ifp, i + 4, SEEK_SET);\n      }\n      break;\n    case 339:\n      tiff_ifd[ifd].sample_format = getint(type);\n      break;\n    case 400:\n      strcpy(make, \"Sarnoff\");\n      maximum = 0xfff;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 700:\n      if ((type == 1 || type == 2 || type == 6 || type == 7) && len > 1 && len < 5100000)\n      {\n        xmpdata = (char *)malloc(xmplen = len + 1);\n        fread(xmpdata, len, 1, ifp);\n        xmpdata[len] = 0;\n      }\n      break;\n#endif\n    case 28688:\n      FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;\n      for (i = 0; i < 5; i++)\n        for (j = sony_curve[i] + 1; j <= sony_curve[i + 1]; j++)\n          curve[j] = curve[j - 1] + (1 << i);\n      break;\n    case 29184:\n      sony_offset = get4();\n      break;\n    case 29185:\n      sony_length = get4();\n      break;\n    case 29217:\n      sony_key = get4();\n      break;\n    case 29264:\n      parse_minolta(ftell(ifp));\n      raw_width = 0;\n      break;\n    case 29443:\n      FORC4 cam_mul[c ^ (c < 2)] = get2();\n      break;\n    case 29459:\n      FORC4 cam_mul[c] = get2();\n      i = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n      SWAP(cam_mul[i], cam_mul[i + 1])\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i = 0; i < 3; i++)\n      {\n        float num = 0.0;\n        for (c = 0; c < 3; c++)\n        {\n          imgdata.color.ccm[i][c] = (float)((short)get2());\n          num += imgdata.color.ccm[i][c];\n        }\n        if (num > 0.01)\n          FORC3 imgdata.color.ccm[i][c] = imgdata.color.ccm[i][c] / num;\n      }\n      break;\n#endif\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, no more needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2();\n      i = cblack[3];\n      FORC3 if (i > cblack[c]) i = cblack[c];\n      FORC4 cblack[c] -= i;\n      black = i;\n\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"), black, cblack[0], cblack[1], cblack[2],\n                cblack[3]);\n#endif\n      break;\n    case 33405: /* Model2 */\n      fgets(model2, 64, ifp);\n      break;\n    case 33421: /* CFARepeatPatternDim */\n      if (get2() == 6 && get2() == 6)\n        filters = 9;\n      break;\n    case 33422: /* CFAPattern */\n      if (filters == 9)\n      {\n        FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;\n        break;\n      }\n    case 64777: /* Kodak P-series */\n      if (len == 36)\n      {\n        filters = 9;\n        colors = 3;\n        FORC(36) xtrans[0][c] = fgetc(ifp) & 3;\n      }\n      else if (len > 0)\n      {\n        if ((plen = len) > 16)\n          plen = 16;\n        fread(cfa_pat, 1, plen, ifp);\n        for (colors = cfa = i = 0; i < plen && colors < 4; i++)\n        {\n          colors += !(cfa & (1 << cfa_pat[i]));\n          cfa |= 1 << cfa_pat[i];\n        }\n        if (cfa == 070)\n          memcpy(cfa_pc, \"\\003\\004\\005\", 3); /* CMY */\n        if (cfa == 072)\n          memcpy(cfa_pc, \"\\005\\003\\004\\001\", 4); /* GMCY */\n        goto guess_cfa_pc;\n      }\n      break;\n    case 33424:\n    case 65024:\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_kodak_ifd(base);\n      break;\n    case 33434: /* ExposureTime */\n      tiff_ifd[ifd].t_shutter = shutter = getreal(type);\n      break;\n    case 33437: /* FNumber */\n      aperture = getreal(type);\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    // IB start\n    case 0xa405: // FocalLengthIn35mmFormat\n      imgdata.lens.FocalLengthIn35mmFormat = get2();\n      break;\n    case 0xa431: // BodySerialNumber\n    case 0xc62f:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      break;\n    case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa435: // LensSerialNumber\n      stmread(imgdata.lens.LensSerial, len, ifp);\n      break;\n    case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard\n      imgdata.lens.MinFocal = getreal(type);\n      imgdata.lens.MaxFocal = getreal(type);\n      imgdata.lens.MaxAp4MinFocal = getreal(type);\n      imgdata.lens.MaxAp4MaxFocal = getreal(type);\n      break;\n    case 0xa433: // LensMake\n      stmread(imgdata.lens.LensMake, len, ifp);\n      break;\n    case 0xa434: // LensModel\n      stmread(imgdata.lens.Lens, len, ifp);\n      if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n        imgdata.lens.Lens[0] = 0;\n      break;\n    case 0x9205:\n      imgdata.lens.EXIF_MaxAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n// IB end\n#endif\n    case 34306: /* Leaf white balance */\n      FORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n      break;\n    case 34307: /* Leaf CatchLight color matrix */\n      fread(software, 1, 7, ifp);\n      if (strncmp(software, \"MATRIX\", 6))\n        break;\n      colors = 4;\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        FORC4 fscanf(ifp, \"%f\", &rgb_cam[i][c ^ 1]);\n        if (!use_camera_wb)\n          continue;\n        num = 0;\n        FORC4 num += rgb_cam[i][c];\n        FORC4 rgb_cam[i][c] /= MAX(1, num);\n      }\n      break;\n    case 34310: /* Leaf metadata */\n      parse_mos(ftell(ifp));\n    case 34303:\n      strcpy(make, \"Leaf\");\n      break;\n    case 34665: /* EXIF tag */\n      fseek(ifp, get4() + base, SEEK_SET);\n      parse_exif(base);\n      break;\n    case 34853: /* GPSInfo tag */\n    {\n      unsigned pos;\n      fseek(ifp, pos = (get4() + base), SEEK_SET);\n      parse_gps(base);\n#ifdef LIBRAW_LIBRARY_BUILD\n      fseek(ifp, pos, SEEK_SET);\n      parse_gps_libraw(base);\n#endif\n    }\n    break;\n    case 34675: /* InterColorProfile */\n    case 50831: /* AsShotICCProfile */\n      profile_offset = ftell(ifp);\n      profile_length = len;\n      break;\n    case 37122: /* CompressedBitsPerPixel */\n      kodak_cbpp = get4();\n      break;\n    case 37386: /* FocalLength */\n      focal_len = getreal(type);\n      break;\n    case 37393: /* ImageNumber */\n      shot_order = getint(type);\n      break;\n    case 37400: /* old Kodak KDC tag */\n      for (raw_color = i = 0; i < 3; i++)\n      {\n        getreal(type);\n        FORC3 rgb_cam[i][c] = getreal(type);\n      }\n      break;\n    case 40976:\n      strip_offset = get4();\n      switch (tiff_ifd[ifd].comp)\n      {\n      case 32770:\n        load_raw = &CLASS samsung_load_raw;\n        break;\n      case 32772:\n        load_raw = &CLASS samsung2_load_raw;\n        break;\n      case 32773:\n        load_raw = &CLASS samsung3_load_raw;\n        break;\n      }\n      break;\n    case 46275: /* Imacon tags */\n      strcpy(make, \"Imacon\");\n      data_offset = ftell(ifp);\n      ima_len = len;\n      break;\n    case 46279:\n      if (!ima_len)\n        break;\n      fseek(ifp, 38, SEEK_CUR);\n    case 46274:\n      fseek(ifp, 40, SEEK_CUR);\n      raw_width = get4();\n      raw_height = get4();\n      left_margin = get4() & 7;\n      width = raw_width - left_margin - (get4() & 7);\n      top_margin = get4() & 7;\n      height = raw_height - top_margin - (get4() & 7);\n      if (raw_width == 7262 && ima_len == 234317952)\n      {\n        height = 5412;\n        width = 7216;\n        left_margin = 7;\n        filters = 0;\n      }\n      else if (raw_width == 7262)\n      {\n        height = 5444;\n        width = 7244;\n        left_margin = 7;\n      }\n      fseek(ifp, 52, SEEK_CUR);\n      FORC3 cam_mul[c] = getreal(11);\n      fseek(ifp, 114, SEEK_CUR);\n      flip = (get2() >> 7) * 90;\n      if (width * height * 6 == ima_len)\n      {\n        if (flip % 180 == 90)\n          SWAP(width, height);\n        raw_width = width;\n        raw_height = height;\n        left_margin = top_margin = filters = flip = 0;\n      }\n      sprintf(model, \"Ixpress %d-Mp\", height * width / 1000000);\n      load_raw = &CLASS imacon_full_load_raw;\n      if (filters)\n      {\n        if (left_margin & 1)\n          filters = 0x61616161;\n        load_raw = &CLASS unpacked_load_raw;\n      }\n      maximum = 0xffff;\n      break;\n    case 50454: /* Sinar tag */\n    case 50455:\n      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fread(cbuf, 1, len, ifp);\n#else\n      if (fread(cbuf, 1, len, ifp) != len)\n        throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle\n#endif\n      cbuf[len - 1] = 0;\n      for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\\n'))\n        if (!strncmp(++cp, \"Neutral \", 8))\n          sscanf(cp + 8, \"%f %f %f\", cam_mul, cam_mul + 1, cam_mul + 2);\n      free(cbuf);\n      break;\n    case 50458:\n      if (!make[0])\n        strcpy(make, \"Hasselblad\");\n      break;\n    case 50459: /* Hasselblad tag */\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;\n#endif\n      i = order;\n      j = ftell(ifp);\n      c = tiff_nifds;\n      order = get2();\n      fseek(ifp, j + (get2(), get4()), SEEK_SET);\n      parse_tiff_ifd(j);\n      maximum = 0xffff;\n      tiff_nifds = c;\n      order = i;\n      break;\n    case 50706: /* DNGVersion */\n      FORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n      if (!make[0])\n        strcpy(make, \"DNG\");\n      is_raw = 1;\n      break;\n    case 50708: /* UniqueCameraModel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      stmread(imgdata.color.UniqueCameraModel, len, ifp);\n      imgdata.color.UniqueCameraModel[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;\n#endif\n      if (model[0])\n        break;\n#ifndef LIBRAW_LIBRARY_BUILD\n      fgets(make, 64, ifp);\n#else\n      strncpy(make, imgdata.color.UniqueCameraModel, MIN(len, sizeof(imgdata.color.UniqueCameraModel)));\n#endif\n      if ((cp = strchr(make, ' ')))\n      {\n        strcpy(model, cp + 1);\n        *cp = 0;\n      }\n      break;\n    case 50710: /* CFAPlaneColor */\n      if (filters == 9)\n        break;\n      if (len > 4)\n        len = 4;\n      colors = len;\n      fread(cfa_pc, 1, colors, ifp);\n    guess_cfa_pc:\n      FORCC tab[cfa_pc[c]] = c;\n      cdesc[c] = 0;\n      for (i = 16; i--;)\n        filters = filters << 2 | tab[cfa_pat[i % plen]];\n      filters -= !filters;\n      break;\n    case 50711: /* CFALayout */\n      if (get2() == 2)\n        fuji_width = 1;\n      break;\n    case 291:\n    case 50712: /* LinearizationTable */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].lineartable_offset = ftell(ifp);\n      tiff_ifd[ifd].lineartable_len = len;\n#endif\n      linear_table(len);\n      break;\n    case 50713: /* BlackLevelRepeatDim */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[4] =\n#endif\n          cblack[4] = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n          cblack[5] = get2();\n      if (cblack[4] * cblack[5] > (sizeof(cblack) / sizeof(cblack[0]) - 6))\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_cblack[4] = tiff_ifd[ifd].dng_levels.dng_cblack[5] =\n#endif\n            cblack[4] = cblack[5] = 1;\n      break;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0xf00c:\n    {\n      unsigned fwb[4];\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n        if ((fwb[3] == 17) && libraw_internal_data.unpacker_data.lenRAFData > 3 &&\n            libraw_internal_data.unpacker_data.lenRAFData < 10240000)\n        {\n          long long f_save = ftell(ifp);\n          int fj, found = 0;\n          ushort *rafdata = (ushort *)malloc(sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);\n          fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);\n          fread(rafdata, sizeof(ushort), libraw_internal_data.unpacker_data.lenRAFData, ifp);\n          fseek(ifp, f_save, SEEK_SET);\n          for (int fi = 0; fi < (libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)\n          {\n            if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) && (fwb[2] == rafdata[fi + 2]))\n            {\n              if (rafdata[fi - 15] != fwb[0])\n                continue;\n              fi = fi - 15;\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][3] =\n                  rafdata[fi];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][0] = rafdata[fi + 1];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][2] = rafdata[fi + 2];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                  rafdata[fi + 3];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = rafdata[fi + 4];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = rafdata[fi + 5];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                  rafdata[fi + 6];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = rafdata[fi + 7];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = rafdata[fi + 8];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][3] =\n                  rafdata[fi + 9];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][0] = rafdata[fi + 10];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][2] = rafdata[fi + 11];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                  rafdata[fi + 12];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = rafdata[fi + 13];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = rafdata[fi + 14];\n\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                  rafdata[fi + 15];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = rafdata[fi + 16];\n              imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = rafdata[fi + 17];\n\n              fi += 111;\n              for (fj = fi; fj < (fi + 15); fj += 3)\n                if (rafdata[fj] != rafdata[fi])\n                {\n                  found = 1;\n                  break;\n                }\n              if (found)\n              {\n                int FujiCCT_K[31] = {2500, 2550, 2650, 2700, 2800, 2850, 2950, 3000, 3100, 3200, 3300,\n                                     3400, 3600, 3700, 3800, 4000, 4200, 4300, 4500, 4800, 5000, 5300,\n                                     5600, 5900, 6300, 6700, 7100, 7700, 8300, 9100, 10000};\n                fj = fj - 93;\n                for (int iCCT = 0; iCCT < 31; iCCT++)\n                {\n                  imgdata.color.WBCT_Coeffs[iCCT][0] = FujiCCT_K[iCCT];\n                  imgdata.color.WBCT_Coeffs[iCCT][1] = rafdata[iCCT * 3 + 1 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][2] = imgdata.color.WBCT_Coeffs[iCCT][4] = rafdata[iCCT * 3 + fj];\n                  imgdata.color.WBCT_Coeffs[iCCT][3] = rafdata[iCCT * 3 + 2 + fj];\n                }\n              }\n              free(rafdata);\n              break;\n            }\n          }\n        }\n      }\n      FORC4 fwb[c] = get4();\n      if (fwb[3] < 0x100)\n      {\n        imgdata.color.WB_Coeffs[fwb[3]][0] = fwb[1];\n        imgdata.color.WB_Coeffs[fwb[3]][1] = imgdata.color.WB_Coeffs[fwb[3]][3] = fwb[0];\n        imgdata.color.WB_Coeffs[fwb[3]][2] = fwb[2];\n      }\n    }\n    break;\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50709:\n      stmread(imgdata.color.LocalizedCameraModel, len, ifp);\n      break;\n#endif\n\n    case 61450:\n      cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);\n    case 50714: /* BlackLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1 && tiff_ifd[ifd].samples == len) // LinearDNG, per-channel black\n      {\n        for (i = 0; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] = getreal(type) + 0.5;\n\n        tiff_ifd[ifd].dng_levels.dng_black = black = 0;\n      }\n      else\n#endif\n          if ((cblack[4] * cblack[5] < 2) && len == 1)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.dng_black =\n#endif\n            black = getreal(type);\n      }\n      else if (cblack[4] * cblack[5] <= len)\n      {\n        FORC(cblack[4] * cblack[5])\n        cblack[6 + c] = getreal(type);\n        black = 0;\n        FORC4\n        cblack[c] = 0;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (tag == 50714)\n        {\n          FORC(cblack[4] * cblack[5])\n          tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];\n          tiff_ifd[ifd].dng_levels.dng_black = 0;\n          FORC4\n          tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;\n        }\n#endif\n      }\n      break;\n    case 50715: /* BlackLevelDeltaH */\n    case 50716: /* BlackLevelDeltaV */\n      for (num = i = 0; i < len && i < 65536; i++)\n        num += getreal(type);\n      black += num / len + 0.5;\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;\n#endif\n      break;\n    case 50717: /* WhiteLevel */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].dng_levels.dng_whitelevel[0] =\n#endif\n          maximum = getint(type);\n#ifdef LIBRAW_LIBRARY_BUILD\n      if (tiff_ifd[ifd].samples > 1) // Linear DNG case\n        for (i = 1; i < colors && i < 4 && i < len; i++)\n          tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);\n#endif\n      break;\n    case 50718: /* DefaultScale */\n      pixel_aspect = getreal(type);\n      pixel_aspect /= getreal(type);\n      if (pixel_aspect > 0.995 && pixel_aspect < 1.005)\n        pixel_aspect = 1.0;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50778:\n      tiff_ifd[ifd].dng_color[0].illuminant = get2();\n      break;\n    case 50779:\n      tiff_ifd[ifd].dng_color[1].illuminant = get2();\n      break;\n#endif\n    case 50721: /* ColorMatrix1 */\n    case 50722: /* ColorMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 50721 ? 0 : 1;\n#endif\n      FORCC for (j = 0; j < 3; j++)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_color[i].colormatrix[c][j] =\n#endif\n            cm[c][j] = getreal(type);\n      }\n      use_cm = 1;\n      break;\n\n    case 0xc714: /* ForwardMatrix1 */\n    case 0xc715: /* ForwardMatrix2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      i = tag == 0xc714 ? 0 : 1;\n#endif\n      for (j = 0; j < 3; j++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] =\n#endif\n              fm[j][c] = getreal(type);\n        }\n      break;\n\n    case 50723: /* CameraCalibration1 */\n    case 50724: /* CameraCalibration2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      j = tag == 50723 ? 0 : 1;\n#endif\n      for (i = 0; i < colors; i++)\n        FORCC\n        {\n#ifdef LIBRAW_LIBRARY_BUILD\n          tiff_ifd[ifd].dng_color[j].calibration[i][c] =\n#endif\n              cc[i][c] = getreal(type);\n        }\n      break;\n    case 50727: /* AnalogBalance */\n      FORCC\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n        tiff_ifd[ifd].dng_levels.analogbalance[c] =\n#endif\n            ab[c] = getreal(type);\n      }\n      break;\n    case 50728: /* AsShotNeutral */\n      FORCC asn[c] = getreal(type);\n      break;\n    case 50729: /* AsShotWhiteXY */\n      xyz[0] = getreal(type);\n      xyz[1] = getreal(type);\n      xyz[2] = 1 - xyz[0] - xyz[1];\n      FORC3 xyz[c] /= d65_white[c];\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 50730: /* DNG: Baseline Exposure */\n      baseline_exposure = getreal(type);\n      break;\n#endif\n    // IB start\n    case 50740: /* tag 0xc634 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */\n#ifdef LIBRAW_LIBRARY_BUILD\n    {\n      char mbuf[64];\n      unsigned short makernote_found = 0;\n      INT64 curr_pos, start_pos = ftell(ifp);\n      unsigned MakN_order, m_sorder = order;\n      unsigned MakN_length;\n      unsigned pos_in_original_raw;\n      fread(mbuf, 1, 6, ifp);\n\n      if (!strcmp(mbuf, \"Adobe\"))\n      {\n        order = 0x4d4d; // Adobe header is always in \"MM\" / big endian\n        curr_pos = start_pos + 6;\n        while (curr_pos + 8 - start_pos <= len)\n        {\n          fread(mbuf, 1, 4, ifp);\n          curr_pos += 8;\n          if (!strncmp(mbuf, \"MakN\", 4))\n          {\n            makernote_found = 1;\n            MakN_length = get4();\n            MakN_order = get2();\n            pos_in_original_raw = get4();\n            order = MakN_order;\n            parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0, AdobeDNG);\n            break;\n          }\n        }\n      }\n      else\n      {\n        fread(mbuf + 6, 1, 2, ifp);\n        if (!strcmp(mbuf, \"PENTAX \") || !strcmp(mbuf, \"SAMSUNG\"))\n        {\n          makernote_found = 1;\n          fseek(ifp, start_pos, SEEK_SET);\n          parse_makernote_0xc634(base, 0, CameraDNG);\n        }\n      }\n\n      fseek(ifp, start_pos, SEEK_SET);\n      order = m_sorder;\n    }\n// IB end\n#endif\n      if (dng_version)\n        break;\n      parse_minolta(j = get4() + base);\n      fseek(ifp, j, SEEK_SET);\n      parse_tiff_ifd(base);\n      break;\n    case 50752:\n      read_shorts(cr2_slice, 3);\n      break;\n    case 50829: /* ActiveArea */\n      top_margin = getint(type);\n      left_margin = getint(type);\n      height = getint(type) - top_margin;\n      width = getint(type) - left_margin;\n      break;\n    case 50830: /* MaskedAreas */\n      for (i = 0; i < len && i < 32; i++)\n        ((int *)mask)[i] = getint(type);\n      black = 0;\n      break;\n    case 51009: /* OpcodeList2 */\n#ifdef LIBRAW_LIBRARY_BUILD\n      tiff_ifd[ifd].opcode2_offset =\n#endif\n          meta_offset = ftell(ifp);\n      break;\n    case 64772: /* Kodak P-series */\n      if (len < 13)\n        break;\n      fseek(ifp, 16, SEEK_CUR);\n      data_offset = get4();\n      fseek(ifp, 28, SEEK_CUR);\n      data_offset += get4();\n      load_raw = &CLASS packed_load_raw;\n      break;\n    case 65026:\n      if (type == 2)\n        fgets(model2, 64, ifp);\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n  if (sony_length && sony_length < 10240000 && (buf = (unsigned *)malloc(sony_length)))\n  {\n    fseek(ifp, sony_offset, SEEK_SET);\n    fread(buf, sony_length, 1, ifp);\n    sony_decrypt(buf, sony_length / 4, 1, sony_key);\n#ifndef LIBRAW_LIBRARY_BUILD\n    sfp = ifp;\n    if ((ifp = tmpfile()))\n    {\n      fwrite(buf, sony_length, 1, ifp);\n      fseek(ifp, 0, SEEK_SET);\n      parse_tiff_ifd(-sony_offset);\n      fclose(ifp);\n    }\n    ifp = sfp;\n#else\n    if (!ifp->tempbuffer_open(buf, sony_length))\n    {\n      parse_tiff_ifd(-sony_offset);\n      ifp->tempbuffer_close();\n    }\n#endif\n    free(buf);\n  }\n  for (i = 0; i < colors; i++)\n    FORCC cc[i][c] *= ab[i];\n  if (use_cm)\n  {\n    FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++) cam_xyz[c][i] +=\n        cc[c][j] * cm[j][i] * xyz[i];\n    cam_xyz_coeff(cmatrix, cam_xyz);\n  }\n  if (asn[0])\n  {\n    cam_mul[3] = 0;\n    FORCC cam_mul[c] = 1 / asn[c];\n  }\n  if (!use_cm)\n    FORCC pre_mul[c] /= cc[c][c];\n  return 0;\n}\n\nint CLASS parse_tiff(int base)\n{\n  int doff;\n  fseek(ifp, base, SEEK_SET);\n  order = get2();\n  if (order != 0x4949 && order != 0x4d4d)\n    return 0;\n  get2();\n  while ((doff = get4()))\n  {\n    fseek(ifp, doff + base, SEEK_SET);\n    if (parse_tiff_ifd(base))\n      break;\n  }\n  return 1;\n}\n\nvoid CLASS apply_tiff()\n{\n  int max_samp = 0, ties = 0, raw = -1, thm = -1, i;\n  unsigned long long ns, os;\n  struct jhead jh;\n\n  thumb_misc = 16;\n  if (thumb_offset)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 && (unsigned)jh.high < 0x10000)\n      {\n        thumb_misc = jh.bits;\n        thumb_width = jh.wide;\n        thumb_height = jh.high;\n      }\n    }\n  }\n  for (i = tiff_nifds; i--;)\n  {\n    if (tiff_ifd[i].t_shutter)\n      shutter = tiff_ifd[i].t_shutter;\n    tiff_ifd[i].t_shutter = shutter;\n  }\n  for (i = 0; i < tiff_nifds; i++)\n  {\n    if (max_samp < tiff_ifd[i].samples)\n      max_samp = tiff_ifd[i].samples;\n    if (max_samp > 3)\n      max_samp = 3;\n    os = raw_width * raw_height;\n    ns = tiff_ifd[i].t_width * tiff_ifd[i].t_height;\n    if (tiff_bps)\n    {\n      os *= tiff_bps;\n      ns *= tiff_ifd[i].bps;\n    }\n    if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 && (unsigned)tiff_ifd[i].bps < 33 &&\n        (unsigned)tiff_ifd[i].samples < 13 && ns && ((ns > os && (ties = 1)) || (ns == os && shot_select == ties++)))\n    {\n      raw_width = tiff_ifd[i].t_width;\n      raw_height = tiff_ifd[i].t_height;\n      tiff_bps = tiff_ifd[i].bps;\n      tiff_compress = tiff_ifd[i].comp;\n      data_offset = tiff_ifd[i].offset;\n#ifdef LIBRAW_LIBRARY_BUILD\n      data_size = tiff_ifd[i].bytes;\n#endif\n      tiff_flip = tiff_ifd[i].t_flip;\n      tiff_samples = tiff_ifd[i].samples;\n      tile_width = tiff_ifd[i].t_tile_width;\n      tile_length = tiff_ifd[i].t_tile_length;\n      shutter = tiff_ifd[i].t_shutter;\n      raw = i;\n    }\n  }\n  if (is_raw == 1 && ties)\n    is_raw = ties;\n  if (!tile_width)\n    tile_width = INT_MAX;\n  if (!tile_length)\n    tile_length = INT_MAX;\n  for (i = tiff_nifds; i--;)\n    if (tiff_ifd[i].t_flip)\n      tiff_flip = tiff_ifd[i].t_flip;\n  if (raw >= 0 && !load_raw)\n    switch (tiff_compress)\n    {\n    case 32767:\n      if (tiff_ifd[raw].bytes == raw_width * raw_height)\n      {\n        tiff_bps = 12;\n        load_raw = &CLASS sony_arw2_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (tiff_ifd[raw].bytes * 8 != raw_width * raw_height * tiff_bps)\n      {\n        raw_height += 8;\n        load_raw = &CLASS sony_arw_load_raw;\n        break;\n      }\n      load_flags = 79;\n    case 32769:\n      load_flags++;\n    case 32770:\n    case 32773:\n      goto slr;\n    case 0:\n    case 1:\n#ifdef LIBRAW_LIBRARY_BUILD\n      // Sony 14-bit uncompressed\n      if (!strncasecmp(make, \"Sony\", 4) && tiff_ifd[raw].bytes == raw_width * raw_height * 2)\n      {\n        tiff_bps = 14;\n        load_raw = &CLASS unpacked_load_raw;\n        break;\n      }\n      if (!strncasecmp(make, \"Nikon\", 5) && !strncmp(software, \"Nikon Scan\", 10))\n      {\n        load_raw = &CLASS nikon_coolscan_load_raw;\n        raw_color = 1;\n        filters = 0;\n        break;\n      }\n#endif\n      if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 2 == raw_width * raw_height * 3)\n        load_flags = 24;\n      if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)\n      {\n        load_flags = 81;\n        tiff_bps = 12;\n      }\n    slr:\n      switch (tiff_bps)\n      {\n      case 8:\n        load_raw = &CLASS eight_bit_load_raw;\n        break;\n      case 12:\n        if (tiff_ifd[raw].phint == 2)\n          load_flags = 6;\n        load_raw = &CLASS packed_load_raw;\n        break;\n      case 14:\n        load_flags = 0;\n      case 16:\n        load_raw = &CLASS unpacked_load_raw;\n        if (!strncmp(make, \"OLYMPUS\", 7) && tiff_ifd[raw].bytes * 7 > raw_width * raw_height)\n          load_raw = &CLASS olympus_load_raw;\n      }\n      break;\n    case 6:\n    case 7:\n    case 99:\n      load_raw = &CLASS lossless_jpeg_load_raw;\n      break;\n    case 262:\n      load_raw = &CLASS kodak_262_load_raw;\n      break;\n    case 34713:\n      if ((raw_width + 9) / 10 * 16 * raw_height == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 1;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        if (model[0] == 'N')\n          load_flags = 80;\n      }\n      else if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS nikon_yuv_load_raw;\n        gamma_curve(1 / 2.4, 12.92, 1, 4095);\n        memset(cblack, 0, sizeof cblack);\n        filters = 0;\n      }\n      else if (raw_width * raw_height * 2 == tiff_ifd[raw].bytes)\n      {\n        load_raw = &CLASS unpacked_load_raw;\n        load_flags = 4;\n        order = 0x4d4d;\n      }\n      else\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (raw_width * raw_height * 3 == tiff_ifd[raw].bytes * 2)\n      {\n        load_raw = &CLASS packed_load_raw;\n        load_flags = 80;\n      }\n      else if (tiff_ifd[raw].rows_per_strip && tiff_ifd[raw].strip_offsets_count &&\n               tiff_ifd[raw].strip_offsets_count == tiff_ifd[raw].strip_byte_counts_count)\n      {\n        int fit = 1;\n        for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1; i++) // all but last\n          if (tiff_ifd[raw].strip_byte_counts[i] * 2 != tiff_ifd[raw].rows_per_strip * raw_width * 3)\n          {\n            fit = 0;\n            break;\n          }\n        if (fit)\n          load_raw = &CLASS nikon_load_striped_packed_raw;\n        else\n          load_raw = &CLASS nikon_load_raw; // fallback\n      }\n      else\n#endif\n        load_raw = &CLASS nikon_load_raw;\n      break;\n    case 65535:\n      load_raw = &CLASS pentax_load_raw;\n      break;\n    case 65000:\n      switch (tiff_ifd[raw].phint)\n      {\n      case 2:\n        load_raw = &CLASS kodak_rgb_load_raw;\n        filters = 0;\n        break;\n      case 6:\n        load_raw = &CLASS kodak_ycbcr_load_raw;\n        filters = 0;\n        break;\n      case 32803:\n        load_raw = &CLASS kodak_65000_load_raw;\n      }\n    case 32867:\n    case 34892:\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      break;\n#endif\n    default:\n      is_raw = 0;\n    }\n  if (!dng_version)\n    if (((tiff_samples == 3 && tiff_ifd[raw].bytes && tiff_bps != 14 && (tiff_compress & -16) != 32768) ||\n         (tiff_bps == 8 && strncmp(make, \"Phase\", 5) && !strcasestr(make, \"Kodak\") && !strstr(model2, \"DEBUG RAW\"))) &&\n        strncmp(software, \"Nikon Scan\", 10))\n      is_raw = 0;\n  for (i = 0; i < tiff_nifds; i++)\n    if (i != raw &&\n        (tiff_ifd[i].samples == max_samp || (tiff_ifd[i].comp == 7 && tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */\n        && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 && tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&\n        unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&\n        tiff_ifd[i].t_width * tiff_ifd[i].t_height / (SQR(tiff_ifd[i].bps) + 1) >\n            thumb_width * thumb_height / (SQR(thumb_misc) + 1) &&\n        tiff_ifd[i].comp != 34892)\n    {\n      thumb_width = tiff_ifd[i].t_width;\n      thumb_height = tiff_ifd[i].t_height;\n      thumb_offset = tiff_ifd[i].offset;\n      thumb_length = tiff_ifd[i].bytes;\n      thumb_misc = tiff_ifd[i].bps;\n      thm = i;\n    }\n  if (thm >= 0)\n  {\n    thumb_misc |= tiff_ifd[thm].samples << 5;\n    switch (tiff_ifd[thm].comp)\n    {\n    case 0:\n      write_thumb = &CLASS layer_thumb;\n      break;\n    case 1:\n      if (tiff_ifd[thm].bps <= 8)\n        write_thumb = &CLASS ppm_thumb;\n      else if (!strncmp(make, \"Imacon\", 6))\n        write_thumb = &CLASS ppm16_thumb;\n      else\n        thumb_load_raw = &CLASS kodak_thumb_load_raw;\n      break;\n    case 65000:\n      thumb_load_raw = tiff_ifd[thm].phint == 6 ? &CLASS kodak_ycbcr_load_raw : &CLASS kodak_rgb_load_raw;\n    }\n  }\n}\n\nvoid CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}\n\n/*\n   Many cameras have a \"debug mode\" that writes JPEG and raw\n   at the same time.  The raw file has no header, so try to\n   to open the matching JPEG file and read its metadata.\n */\nvoid CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *save = ifp;\n#else\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\n  if (ifp->wfname())\n  {\n    std::wstring rawfile(ifp->wfname());\n    rawfile.replace(rawfile.length() - 3, 3, L\"JPG\");\n    if (!ifp->subfile_open(rawfile.c_str()))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n  if (!ifp->fname())\n  {\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n    return;\n  }\n#endif\n\n  ext = strrchr(ifname, '.');\n  file = strrchr(ifname, '/');\n  if (!file)\n    file = strrchr(ifname, '\\\\');\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!file)\n    file = ifname - 1;\n#else\n  if (!file)\n    file = (char *)ifname - 1;\n#endif\n  file++;\n  if (!ext || strlen(ext) != 4 || ext - file != 8)\n    return;\n  jname = (char *)malloc(strlen(ifname) + 1);\n  merror(jname, \"parse_external_jpeg()\");\n  strcpy(jname, ifname);\n  jfile = file - ifname + jname;\n  jext = ext - ifname + jname;\n  if (strcasecmp(ext, \".jpg\"))\n  {\n    strcpy(jext, isupper(ext[1]) ? \".JPG\" : \".jpg\");\n    if (isdigit(*file))\n    {\n      memcpy(jfile, file + 4, 4);\n      memcpy(jfile + 4, file, 4);\n    }\n  }\n  else\n    while (isdigit(*--jext))\n    {\n      if (*jext != '9')\n      {\n        (*jext)++;\n        break;\n      }\n      *jext = '0';\n    }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (strcmp(jname, ifname))\n  {\n    if ((ifp = fopen(jname, \"rb\")))\n    {\n#ifdef DCRAW_VERBOSE\n      if (verbose)\n        fprintf(stderr, _(\"Reading metadata from %s ...\\n\"), jname);\n#endif\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose(ifp);\n    }\n  }\n#else\n  if (strcmp(jname, ifname))\n  {\n    if (!ifp->subfile_open(jname))\n    {\n      parse_tiff(12);\n      thumb_offset = 0;\n      is_raw = 1;\n      ifp->subfile_close();\n    }\n    else\n      imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n  }\n#endif\n  if (!timestamp)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_METADATA;\n#endif\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"Failed to read metadata from %s\\n\"), jname);\n#endif\n  }\n  free(jname);\n#ifndef LIBRAW_LIBRARY_BUILD\n  ifp = save;\n#endif\n}\n\n/*\n   CIFF block 0x1030 contains an 8x8 white sample.\n   Load this into white[][] for use in scale_colors().\n */\nvoid CLASS ciff_block_1030()\n{\n  static const ushort key[] = {0x410, 0x45f3};\n  int i, bpp, row, col, vbits = 0;\n  unsigned long bitbuf = 0;\n\n  if ((get2(), get4()) != 0x80008 || !get4())\n    return;\n  bpp = get2();\n  if (bpp != 10 && bpp != 12)\n    return;\n  for (i = row = 0; row < 8; row++)\n    for (col = 0; col < 8; col++)\n    {\n      if (vbits < bpp)\n      {\n        bitbuf = bitbuf << 16 | (get2() ^ key[i++ & 1]);\n        vbits += 16;\n      }\n      white[row][col] = bitbuf >> (vbits -= bpp) & ~(-1 << bpp);\n    }\n}\n\n/*\n   Parse a CIFF file, better known as Canon CRW format.\n */\n\nvoid CLASS parse_ciff(int offset, int length, int depth)\n{\n  int tboff, nrecs, c, type, len, save, wbi = -1;\n  ushort key[] = {0x410, 0x45f3};\n\n  fseek(ifp, offset + length - 4, SEEK_SET);\n  tboff = get4() + offset;\n  fseek(ifp, tboff, SEEK_SET);\n  nrecs = get2();\n  if ((nrecs | depth) > 127)\n    return;\n  while (nrecs--)\n  {\n    type = get2();\n    len = get4();\n    save = ftell(ifp) + 4;\n    fseek(ifp, offset + get4(), SEEK_SET);\n    if ((((type >> 8) + 8) | 8) == 0x38)\n    {\n      parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x3004)\n      parse_ciff(ftell(ifp), len, depth + 1);\n#endif\n    if (type == 0x0810)\n      fread(artist, 64, 1, ifp);\n    if (type == 0x080a)\n    {\n      fread(make, 64, 1, ifp);\n      fseek(ifp, strbuflen(make) - 63, SEEK_CUR);\n      fread(model, 64, 1, ifp);\n    }\n    if (type == 0x1810)\n    {\n      width = get4();\n      height = get4();\n      pixel_aspect = int_to_float(get4());\n      flip = get4();\n    }\n    if (type == 0x1835) /* Get the decoder table */\n      tiff_compress = get4();\n    if (type == 0x2007)\n    {\n      thumb_offset = ftell(ifp);\n      thumb_length = len;\n    }\n    if (type == 0x1818)\n    {\n      shutter = powf64(2.0f, -int_to_float((get4(), get4())));\n      aperture = powf64(2.0f, int_to_float(get4()) / 2);\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurAp = aperture;\n#endif\n    }\n    if (type == 0x102a)\n    {\n      //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;\n      iso_speed = powf64(2.0f, ((get2(), get2()) + get2()) / 32.0f - 5.0f) * 100.0f;\n#ifdef LIBRAW_LIBRARY_BUILD\n      aperture = _CanonConvertAperture((get2(), get2()));\n      imgdata.lens.makernotes.CurAp = aperture;\n#else\n      aperture = powf64(2.0, (get2(), (short)get2()) / 64.0);\n#endif\n      shutter = powf64(2.0, -((short)get2()) / 32.0);\n      wbi = (get2(), get2());\n      if (wbi > 17)\n        wbi = 0;\n      fseek(ifp, 32, SEEK_CUR);\n      if (shutter > 1e6)\n        shutter = get2() / 10.0;\n    }\n    if (type == 0x102c)\n    {\n      if (get2() > 512)\n      { /* Pro90, G1 */\n        fseek(ifp, 118, SEEK_CUR);\n        FORC4 cam_mul[c ^ 2] = get2();\n      }\n      else\n      { /* G2, S30, S40 */\n        fseek(ifp, 98, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2();\n      }\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (type == 0x10a9)\n    {\n      INT64 o = ftell(ifp);\n      fseek(ifp, (0x5 << 1), SEEK_CUR);\n      Canon_WBpresets(0, 0);\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x102d)\n    {\n      INT64 o = ftell(ifp);\n      Canon_CameraSettings();\n      fseek(ifp, o, SEEK_SET);\n    }\n    if (type == 0x580b)\n    {\n      if (strcmp(model, \"Canon EOS D30\"))\n        sprintf(imgdata.shootinginfo.BodySerial, \"%d\", len);\n      else\n        sprintf(imgdata.shootinginfo.BodySerial, \"%0x-%05d\", len >> 16, len & 0xffff);\n    }\n#endif\n    if (type == 0x0032)\n    {\n      if (len == 768)\n      { /* EOS D30 */\n        fseek(ifp, 72, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1)] = 1024.0 / get2();\n        if (!wbi)\n          cam_mul[0] = -1; /* use my auto white balance */\n      }\n      else if (!cam_mul[0])\n      {\n        if (get2() == key[0]) /* Pro1, G6, S60, S70 */\n          c = (strstr(model, \"Pro1\") ? \"012346000000000000\" : \"01345:000000006008\")[LIM(0, wbi, 17)] - '0' + 2;\n        else\n        { /* G3, G5, S45, S50 */\n          c = \"023457000000006000\"[LIM(0, wbi, 17)] - '0';\n          key[0] = key[1] = 0;\n        }\n        fseek(ifp, 78 + c * 8, SEEK_CUR);\n        FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get2() ^ key[c & 1];\n        if (!wbi)\n          cam_mul[0] = -1;\n      }\n    }\n    if (type == 0x10a9)\n    { /* D60, 10D, 300D, and clones */\n      if (len > 66)\n        wbi = \"0134567028\"[LIM(0, wbi, 9)] - '0';\n      fseek(ifp, 2 + wbi * 8, SEEK_CUR);\n      FORC4 cam_mul[c ^ (c >> 1)] = get2();\n    }\n    if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))\n      ciff_block_1030(); /* all that don't have 0x10a9 */\n    if (type == 0x1031)\n    {\n      raw_width = (get2(), get2());\n      raw_height = get2();\n    }\n    if (type == 0x501c)\n    {\n      iso_speed = len & 0xffff;\n    }\n    if (type == 0x5029)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CurFocal = len >> 16;\n      imgdata.lens.makernotes.FocalType = len & 0xffff;\n      if (imgdata.lens.makernotes.FocalType == 2)\n      {\n        imgdata.lens.makernotes.CanonFocalUnits = 32;\n        if (imgdata.lens.makernotes.CanonFocalUnits > 1)\n          imgdata.lens.makernotes.CurFocal /= (float)imgdata.lens.makernotes.CanonFocalUnits;\n      }\n      focal_len = imgdata.lens.makernotes.CurFocal;\n#else\n      focal_len = len >> 16;\n      if ((len & 0xffff) == 2)\n        focal_len /= 32;\n#endif\n    }\n    if (type == 0x5813)\n      flash_used = int_to_float(len);\n    if (type == 0x5814)\n      canon_ev = int_to_float(len);\n    if (type == 0x5817)\n      shot_order = len;\n    if (type == 0x5834)\n    {\n      unique_id = len;\n#ifdef LIBRAW_LIBRARY_BUILD\n      setCanonBodyFeatures(unique_id);\n#endif\n    }\n    if (type == 0x580e)\n      timestamp = len;\n    if (type == 0x180e)\n      timestamp = get4();\n#ifdef LOCALTIME\n    if ((type | 0x4000) == 0x580e)\n      timestamp = mktime(gmtime(&timestamp));\n#endif\n    fseek(ifp, save, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_rollei()\n{\n  char line[128], *val;\n  struct tm t;\n\n  fseek(ifp, 0, SEEK_SET);\n  memset(&t, 0, sizeof t);\n  do\n  {\n    fgets(line, 128, ifp);\n    if ((val = strchr(line, '=')))\n      *val++ = 0;\n    else\n      val = line + strbuflen(line);\n    if (!strcmp(line, \"DAT\"))\n      sscanf(val, \"%d.%d.%d\", &t.tm_mday, &t.tm_mon, &t.tm_year);\n    if (!strcmp(line, \"TIM\"))\n      sscanf(val, \"%d:%d:%d\", &t.tm_hour, &t.tm_min, &t.tm_sec);\n    if (!strcmp(line, \"HDR\"))\n      thumb_offset = atoi(val);\n    if (!strcmp(line, \"X  \"))\n      raw_width = atoi(val);\n    if (!strcmp(line, \"Y  \"))\n      raw_height = atoi(val);\n    if (!strcmp(line, \"TX \"))\n      thumb_width = atoi(val);\n    if (!strcmp(line, \"TY \"))\n      thumb_height = atoi(val);\n  } while (strncmp(line, \"EOHD\", 4));\n  data_offset = thumb_offset + thumb_width * thumb_height * 2;\n  t.tm_year -= 1900;\n  t.tm_mon -= 1;\n  if (mktime(&t) > 0)\n    timestamp = mktime(&t);\n  strcpy(make, \"Rollei\");\n  strcpy(model, \"d530flex\");\n  write_thumb = &CLASS rollei_thumb;\n}\n\nvoid CLASS parse_sinar_ia()\n{\n  int entries, off;\n  char str[8], *cp;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  entries = get4();\n  fseek(ifp, get4(), SEEK_SET);\n  while (entries--)\n  {\n    off = get4();\n    get4();\n    fread(str, 8, 1, ifp);\n    if (!strcmp(str, \"META\"))\n      meta_offset = off;\n    if (!strcmp(str, \"THUMB\"))\n      thumb_offset = off;\n    if (!strcmp(str, \"RAW0\"))\n      data_offset = off;\n  }\n  fseek(ifp, meta_offset + 20, SEEK_SET);\n  fread(make, 64, 1, ifp);\n  make[63] = 0;\n  if ((cp = strchr(make, ' ')))\n  {\n    strcpy(model, cp + 1);\n    *cp = 0;\n  }\n  raw_width = get2();\n  raw_height = get2();\n  load_raw = &CLASS unpacked_load_raw;\n  thumb_width = (get4(), get2());\n  thumb_height = get2();\n  write_thumb = &CLASS ppm_thumb;\n  maximum = 0x3fff;\n}\n\nvoid CLASS parse_phase_one(int base)\n{\n  unsigned entries, tag, type, len, data, save, i, c;\n  float romm_cam[3][3];\n  char *cp;\n\n  memset(&ph1, 0, sizeof ph1);\n  fseek(ifp, base, SEEK_SET);\n  order = get4() & 0xffff;\n  if (get4() >> 8 != 0x526177)\n    return; /* \"Raw\" */\n  fseek(ifp, get4() + base, SEEK_SET);\n  entries = get4();\n  get4();\n  while (entries--)\n  {\n    tag = get4();\n    type = get4();\n    len = get4();\n    data = get4();\n    save = ftell(ifp);\n    fseek(ifp, base + data, SEEK_SET);\n    switch (tag)\n    {\n\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x0102:\n      stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n      if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n      }\n      else\n      {\n        unique_id =\n            (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n      }\n      setPhaseOneFeatures(unique_id);\n      break;\n    case 0x0401:\n      if (type == 4)\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (int_to_float(data) / 2.0f));\n      else\n        imgdata.lens.makernotes.CurAp = powf64(2.0f, (getreal(type) / 2.0f));\n      break;\n    case 0x0403:\n      if (type == 4)\n        imgdata.lens.makernotes.CurFocal = int_to_float(data);\n      else\n        imgdata.lens.makernotes.CurFocal = getreal(type);\n      break;\n    case 0x0410:\n      stmread(imgdata.lens.makernotes.body, len, ifp);\n      break;\n    case 0x0412:\n      stmread(imgdata.lens.makernotes.Lens, len, ifp);\n      break;\n    case 0x0414:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0415:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (int_to_float(data) / 2.0f));\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinAp4CurFocal = powf64(2.0f, (getreal(type) / 2.0f));\n      }\n      break;\n    case 0x0416:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MinFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MinFocal = getreal(type);\n      }\n      if (imgdata.lens.makernotes.MinFocal > 1000.0f)\n      {\n        imgdata.lens.makernotes.MinFocal = 0.0f;\n      }\n      break;\n    case 0x0417:\n      if (type == 4)\n      {\n        imgdata.lens.makernotes.MaxFocal = int_to_float(data);\n      }\n      else\n      {\n        imgdata.lens.makernotes.MaxFocal = getreal(type);\n      }\n      break;\n#endif\n\n    case 0x100:\n      flip = \"0653\"[data & 3] - '0';\n      break;\n    case 0x106:\n      for (i = 0; i < 9; i++)\n#ifdef LIBRAW_LIBRARY_BUILD\n        imgdata.color.P1_color[0].romm_cam[i] =\n#endif\n            ((float *)romm_cam)[i] = getreal(11);\n      romm_coeff(romm_cam);\n      break;\n    case 0x107:\n      FORC3 cam_mul[c] = getreal(11);\n      break;\n    case 0x108:\n      raw_width = data;\n      break;\n    case 0x109:\n      raw_height = data;\n      break;\n    case 0x10a:\n      left_margin = data;\n      break;\n    case 0x10b:\n      top_margin = data;\n      break;\n    case 0x10c:\n      width = data;\n      break;\n    case 0x10d:\n      height = data;\n      break;\n    case 0x10e:\n      ph1.format = data;\n      break;\n    case 0x10f:\n      data_offset = data + base;\n      break;\n    case 0x110:\n      meta_offset = data + base;\n      meta_length = len;\n      break;\n    case 0x112:\n      ph1.key_off = save - 4;\n      break;\n    case 0x210:\n      ph1.tag_210 = int_to_float(data);\n      break;\n    case 0x21a:\n      ph1.tag_21a = data;\n      break;\n    case 0x21c:\n      strip_offset = data + base;\n      break;\n    case 0x21d:\n      ph1.t_black = data;\n      break;\n    case 0x222:\n      ph1.split_col = data;\n      break;\n    case 0x223:\n      ph1.black_col = data + base;\n      break;\n    case 0x224:\n      ph1.split_row = data;\n      break;\n    case 0x225:\n      ph1.black_row = data + base;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x226:\n      for (i = 0; i < 9; i++)\n        imgdata.color.P1_color[1].romm_cam[i] = getreal(11);\n      break;\n#endif\n    case 0x301:\n      model[63] = 0;\n      fread(model, 1, 63, ifp);\n      if ((cp = strstr(model, \" camera\")))\n        *cp = 0;\n    }\n    fseek(ifp, save, SEEK_SET);\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (!imgdata.lens.makernotes.body[0] && !imgdata.shootinginfo.BodySerial[0])\n  {\n    fseek(ifp, meta_offset, SEEK_SET);\n    order = get2();\n    fseek(ifp, 6, SEEK_CUR);\n    fseek(ifp, meta_offset + get4(), SEEK_SET);\n    entries = get4();\n    get4();\n    while (entries--)\n    {\n      tag = get4();\n      len = get4();\n      data = get4();\n      save = ftell(ifp);\n      fseek(ifp, meta_offset + data, SEEK_SET);\n      if (tag == 0x0407)\n      {\n        stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n        if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) && (imgdata.shootinginfo.BodySerial[1] == 0x49))\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[2] & 0x3f)) - 0x41;\n        }\n        else\n        {\n          unique_id =\n              (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) | (imgdata.shootinginfo.BodySerial[1] & 0x3f)) - 0x41;\n        }\n        setPhaseOneFeatures(unique_id);\n      }\n      fseek(ifp, save, SEEK_SET);\n    }\n  }\n#endif\n\n  load_raw = ph1.format < 3 ? &CLASS phase_one_load_raw : &CLASS phase_one_load_raw_c;\n  maximum = 0xffff;\n  strcpy(make, \"Phase One\");\n  if (model[0])\n    return;\n  switch (raw_height)\n  {\n  case 2060:\n    strcpy(model, \"LightPhase\");\n    break;\n  case 2682:\n    strcpy(model, \"H 10\");\n    break;\n  case 4128:\n    strcpy(model, \"H 20\");\n    break;\n  case 5488:\n    strcpy(model, \"H 25\");\n    break;\n  }\n}\n\nvoid CLASS parse_fuji(int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek(ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255)\n    return;\n  while (entries--)\n  {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n\n    if (tag == 0x100)\n    {\n      raw_height = get2();\n      raw_width = get2();\n    }\n    else if (tag == 0x121)\n    {\n      height = get2();\n      if ((width = get2()) == 4284)\n        width += 3;\n    }\n    else if (tag == 0x130)\n    {\n      fuji_layout = fgetc(ifp) >> 7;\n      fuji_width = !(fgetc(ifp) & 8);\n    }\n    else if (tag == 0x131)\n    {\n      filters = 9;\n      FORC(36) xtrans_abs[0][35 - c] = fgetc(ifp) & 3;\n    }\n    else if (tag == 0x2ff0)\n    {\n      FORC4 cam_mul[c ^ 1] = get2();\n\n// IB start\n#ifdef LIBRAW_LIBRARY_BUILD\n    }\n    else if (tag == 0x9650)\n    {\n      short a = (short)get2();\n      float b = fMAX(1.0f, get2());\n      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;\n    }\n    else if (tag == 0x2100)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ 1] = get2();\n    }\n    else if (tag == 0x2200)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ 1] = get2();\n    }\n    else if (tag == 0x2300)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();\n    }\n    else if (tag == 0x2301)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();\n    }\n    else if (tag == 0x2302)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();\n    }\n    else if (tag == 0x2310)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();\n    }\n    else if (tag == 0x2400)\n    {\n      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();\n#endif\n      // IB end\n    }\n    else if (tag == 0xc000)\n    {\n      c = order;\n      order = 0x4949;\n      if ((tag = get4()) > 10000)\n        tag = get4();\n      if (tag > 10000)\n        tag = get4();\n      width = tag;\n      height = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n      libraw_internal_data.unpacker_data.posRAFData = save;\n      libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);\n#endif\n      order = c;\n    }\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width >>= fuji_layout;\n}\n\nint CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n\t&& (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n\t) /* \"HEAP\" */\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}\n\nvoid CLASS parse_riff()\n{\n  unsigned i, size, end;\n  char tag[4], date[64], month[64];\n  static const char mon[12][4] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  struct tm t;\n\n  order = 0x4949;\n  fread(tag, 4, 1, ifp);\n  size = get4();\n  end = ftell(ifp) + size;\n  if (!memcmp(tag, \"RIFF\", 4) || !memcmp(tag, \"LIST\", 4))\n  {\n    int maxloop = 1000;\n    get4();\n    while (ftell(ifp) + 7 < end && !feof(ifp) && maxloop--)\n      parse_riff();\n  }\n  else if (!memcmp(tag, \"nctg\", 4))\n  {\n    while (ftell(ifp) + 7 < end)\n    {\n      i = get2();\n      size = get2();\n      if ((i + 1) >> 1 == 10 && size == 20)\n        get_timestamp(0);\n      else\n        fseek(ifp, size, SEEK_CUR);\n    }\n  }\n  else if (!memcmp(tag, \"IDIT\", 4) && size < 64)\n  {\n    fread(date, 64, 1, ifp);\n    date[size] = 0;\n    memset(&t, 0, sizeof t);\n    if (sscanf(date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday, &t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6)\n    {\n      for (i = 0; i < 12 && strcasecmp(mon[i], month); i++)\n        ;\n      t.tm_mon = i;\n      t.tm_year -= 1900;\n      if (mktime(&t) > 0)\n        timestamp = mktime(&t);\n    }\n  }\n  else\n    fseek(ifp, size, SEEK_CUR);\n}\n\nvoid CLASS parse_qt(int end)\n{\n  unsigned save, size;\n  char tag[4];\n\n  order = 0x4d4d;\n  while (ftell(ifp) + 7 < end)\n  {\n    save = ftell(ifp);\n    if ((size = get4()) < 8)\n      return;\n    fread(tag, 4, 1, ifp);\n    if (!memcmp(tag, \"moov\", 4) || !memcmp(tag, \"udta\", 4) || !memcmp(tag, \"CNTH\", 4))\n      parse_qt(save + size);\n    if (!memcmp(tag, \"CNDA\", 4))\n      parse_jpeg(ftell(ifp));\n    fseek(ifp, save + size, SEEK_SET);\n  }\n}\n\nvoid CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"SMaL\");\n  sprintf(model, \"v%d %dx%d\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}\n\nvoid CLASS parse_cine()\n{\n  unsigned off_head, off_setup, off_image, i;\n\n  order = 0x4949;\n  fseek(ifp, 4, SEEK_SET);\n  is_raw = get2() == 2;\n  fseek(ifp, 14, SEEK_CUR);\n  is_raw *= get4();\n  off_head = get4();\n  off_setup = get4();\n  off_image = get4();\n  timestamp = get4();\n  if ((i = get4()))\n    timestamp = i;\n  fseek(ifp, off_head + 4, SEEK_SET);\n  raw_width = get4();\n  raw_height = get4();\n  switch (get2(), get2())\n  {\n  case 8:\n    load_raw = &CLASS eight_bit_load_raw;\n    break;\n  case 16:\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  fseek(ifp, off_setup + 792, SEEK_SET);\n  strcpy(make, \"CINE\");\n  sprintf(model, \"%d\", get4());\n  fseek(ifp, 12, SEEK_CUR);\n  switch ((i = get4()) & 0xffffff)\n  {\n  case 3:\n    filters = 0x94949494;\n    break;\n  case 4:\n    filters = 0x49494949;\n    break;\n  default:\n    is_raw = 0;\n  }\n  fseek(ifp, 72, SEEK_CUR);\n  switch ((get4() + 3600) % 360)\n  {\n  case 270:\n    flip = 4;\n    break;\n  case 180:\n    flip = 1;\n    break;\n  case 90:\n    flip = 7;\n    break;\n  case 0:\n    flip = 2;\n  }\n  cam_mul[0] = getreal(11);\n  cam_mul[2] = getreal(11);\n  maximum = ~((~0u) << get4());\n  fseek(ifp, 668, SEEK_CUR);\n  shutter = get4() / 1000000000.0;\n  fseek(ifp, off_image, SEEK_SET);\n  if (shot_select < is_raw)\n    fseek(ifp, shot_select * 8, SEEK_CUR);\n  data_offset = (INT64)get4() + 8;\n  data_offset += (INT64)get4() << 32;\n}\n\nvoid CLASS parse_redcine()\n{\n  unsigned i, len, rdvo;\n\n  order = 0x4d4d;\n  is_raw = 0;\n  fseek(ifp, 52, SEEK_SET);\n  width = get4();\n  height = get4();\n  fseek(ifp, 0, SEEK_END);\n  fseek(ifp, -(i = ftello(ifp) & 511), SEEK_CUR);\n  if (get4() != i || get4() != 0x52454f42)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: Tail is missing, parsing from head...\\n\"), ifname);\n#endif\n    fseek(ifp, 0, SEEK_SET);\n    while ((len = get4()) != EOF)\n    {\n      if (get4() == 0x52454456)\n        if (is_raw++ == shot_select)\n          data_offset = ftello(ifp) - 8;\n      fseek(ifp, len - 8, SEEK_CUR);\n    }\n  }\n  else\n  {\n    rdvo = get4();\n    fseek(ifp, 12, SEEK_CUR);\n    is_raw = get4();\n    fseeko(ifp, rdvo + 8 + shot_select * 4, SEEK_SET);\n    data_offset = get4();\n  }\n}\n\n/*\n   All matrices are from Adobe DNG Converter unless otherwise noted.\n */\nvoid CLASS adobe_coeff(const char *t_make, const char *t_model\n#ifdef LIBRAW_LIBRARY_BUILD\n                       ,\n                       int internal_only\n#endif\n                       )\n{\n  // clang-format off\n  static const struct\n  {\n    const char *prefix;\n    int t_black, t_maximum, trans[12];\n  } table[] = {\n    { \"AgfaPhoto DC-833m\", 0, 0,\t/* DJC */\n      { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },\n    { \"Apple QuickTake\", 0, 0,\t\t/* DJC */\n      { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },\n    {\"Broadcom RPi IMX219\", 66, 0x3ff,\n      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } },  /* LibRaw */\n    { \"Broadcom RPi OV5647\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Canon EOS D2000\", 0, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Canon EOS D6000\", 0, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Canon EOS D30\", 0, 0,\n      { 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },\n    { \"Canon EOS D60\", 0, 0xfa0,\n      { 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },\n    { \"Canon EOS 5DS\", 0, 0x3c96,\n      { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } },\n    { \"Canon EOS 5D Mark IV\", 0, 0,\n      { 6446, -366, -864, -4436, 12204, 2513, -952, 2496, 6348 }},\n    { \"Canon EOS 5D Mark III\", 0, 0x3c80,\n      { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },\n    { \"Canon EOS 5D Mark II\", 0, 0x3cf0,\n      { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },\n    { \"Canon EOS 5D\", 0, 0xe6c,\n      { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },\n    { \"Canon EOS 6D\", 0, 0x3c82,\n      { 8621,-2197,-787,-3150,11358,912,-1161,2400,4836 } },\n    { \"Canon EOS 7D Mark II\", 0, 0x3510,\n      { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },\n    { \"Canon EOS 7D\", 0, 0x3510,\n      { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },\n    { \"Canon EOS 80D\", 0, 0,\n      { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },\n    { \"Canon EOS 10D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 20Da\", 0, 0,\n      { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },\n    { \"Canon EOS 20D\", 0, 0xfff,\n      { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },\n    { \"Canon EOS 30D\", 0, 0,\n      { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },\n    { \"Canon EOS 40D\", 0, 0x3f60,\n      { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },\n    { \"Canon EOS 50D\", 0, 0x3d93,\n      { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },\n    { \"Canon EOS 60D\", 0, 0x2ff7,\n      { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },\n    { \"Canon EOS 70D\", 0, 0x3bc7,\n      { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },\n    { \"Canon EOS 100D\", 0, 0x350f,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 300D\", 0, 0xfa0,\n      { 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },\n    { \"Canon EOS 350D\", 0, 0xfff,\n      { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },\n    { \"Canon EOS 400D\", 0, 0xe8e,\n      { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },\n    { \"Canon EOS 450D\", 0, 0x390d,\n      { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },\n    { \"Canon EOS 500D\", 0, 0x3479,\n      { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },\n    { \"Canon EOS 550D\", 0, 0x3dd7,\n      { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },\n    { \"Canon EOS 600D\", 0, 0x3510,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 650D\", 0, 0x354d,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 750D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 760D\", 0, 0x3c00,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS 700D\", 0, 0x3c00,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS 1000D\", 0, 0xe43,\n      { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },\n    { \"Canon EOS 1100D\", 0, 0x3510,\n      { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },\n    { \"Canon EOS 1200D\", 0, 0x37c2,\n      { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },\n    { \"Canon EOS 1300D\", 0, 0x37c2,\n      { 6939, -1016, -866, -4428, 12473, 2177, -1175, 2178, 6162 } },\n    { \"Canon EOS M3\", 0, 0,\n      { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },\n    { \"Canon EOS M5\", 0, 0,  /* Adobe */\n      { 8532, -701, -1167, -4095, 11879, 2508, -797, 2424, 7010 }},\n    { \"Canon EOS M10\", 0, 0,\n      { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },\n    { \"Canon EOS M\", 0, 0,\n      { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },\n    { \"Canon EOS-1Ds Mark III\", 0, 0x3bb0,\n      { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },\n    { \"Canon EOS-1Ds Mark II\", 0, 0xe80,\n      { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },\n    { \"Canon EOS-1D Mark IV\", 0, 0x3bb0,\n      { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },\n    { \"Canon EOS-1D Mark III\", 0, 0x3bb0,\n      { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },\n    { \"Canon EOS-1D Mark II N\", 0, 0xe80,\n      { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },\n    { \"Canon EOS-1D Mark II\", 0, 0xe80,\n      { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },\n    { \"Canon EOS-1DS\", 0, 0xe20,\n      { 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },\n    { \"Canon EOS-1D C\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D X Mark II\", 0, 0x3c4e,\n      { 7596,-978,967,-4808,12571,2503,-1398,2567,5752 } },\n    { \"Canon EOS-1D X\", 0, 0x3c4e,\n      { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },\n    { \"Canon EOS-1D\", 0, 0xe20,\n      { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },\n    { \"Canon EOS C500\", 853, 0,\t\t/* DJC */\n      { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } },\n    { \"Canon PowerShot A530\", 0, 0,\n      { 0 } },\t/* don't want the A5 matrix */\n    { \"Canon PowerShot A50\", 0, 0,\n      { -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },\n    { \"Canon PowerShot A5\", 0, 0,\n      { -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },\n    { \"Canon PowerShot G10\", 0, 0,\n      { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },\n    { \"Canon PowerShot G11\", 0, 0,\n      { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },\n    { \"Canon PowerShot G12\", 0, 0,\n      { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },\n    { \"Canon PowerShot G15\", 0, 0,\n      { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },\n    { \"Canon PowerShot G16\", 0, 0,\n      { 14130,-8071,127,2199,6528,1551,3402,-1721,4960 } },\n    { \"Canon PowerShot G1 X Mark II\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1 X\", 0, 0,\n      { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },\n    { \"Canon PowerShot G1\", 0, 0,\n      { -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },\n    { \"Canon PowerShot G2\", 0, 0,\n      { 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },\n    { \"Canon PowerShot G3 X\", 0, 0,\n      { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },\n    { \"Canon PowerShot G3\", 0, 0,\n      { 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },\n    { \"Canon PowerShot G5 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G5\", 0, 0,\n      { 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },\n    { \"Canon PowerShot G6\", 0, 0,\n      { 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },\n    { \"Canon PowerShot G7 X Mark II\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G7 X\", 0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X Mark II\", 0, 0, /* temp */\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9 X\",0, 0,\n      { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },\n    { \"Canon PowerShot G9\", 0, 0,\n      { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },\n    { \"Canon PowerShot Pro1\", 0, 0,\n      { 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },\n    { \"Canon PowerShot Pro70\", 34, 0,\n      { -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },\n    { \"Canon PowerShot Pro90\", 0, 0,\n      { -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },\n    { \"Canon PowerShot S30\", 0, 0,\n      { 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },\n    { \"Canon PowerShot S40\", 0, 0,\n      { 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },\n    { \"Canon PowerShot S45\", 0, 0,\n      { 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },\n    { \"Canon PowerShot S50\", 0, 0,\n      { 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },\n    { \"Canon PowerShot S60\", 0, 0,\n      { 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },\n    { \"Canon PowerShot S70\", 0, 0,\n      { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },\n    { \"Canon PowerShot S90\", 0, 0,\n      { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },\n    { \"Canon PowerShot S95\", 0, 0,\n      { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },\n    { \"Canon PowerShot S120\", 0, 0,\n      { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },\n    { \"Canon PowerShot S110\", 0, 0,\n      { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },\n    { \"Canon PowerShot S100\", 0, 0,\n      { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },\n    { \"Canon PowerShot SX1 IS\", 0, 0,\n      { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },\n    { \"Canon PowerShot SX50 HS\", 0, 0,\n      { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },\n    { \"Canon PowerShot SX60 HS\", 0, 0,\n      { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },\n    { \"Canon PowerShot A3300\", 0, 0,\t/* DJC */\n      { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } },\n    { \"Canon PowerShot A470\", 0, 0,\t/* DJC */\n      { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },\n    { \"Canon PowerShot A610\", 0, 0,\t/* DJC */\n      { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },\n    { \"Canon PowerShot A620\", 0, 0,\t/* DJC */\n      { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },\n    { \"Canon PowerShot A630\", 0, 0,\t/* DJC */\n      { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },\n    { \"Canon PowerShot A640\", 0, 0,\t/* DJC */\n      { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },\n    { \"Canon PowerShot A650\", 0, 0,\t/* DJC */\n      { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },\n    { \"Canon PowerShot A720\", 0, 0,\t/* DJC */\n      { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },\n    { \"Canon PowerShot S3 IS\", 0, 0,\t/* DJC */\n      { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },\n    { \"Canon PowerShot SX110 IS\", 0, 0,\t/* DJC */\n      { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },\n    { \"Canon PowerShot SX220\", 0, 0,\t/* DJC */\n      { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } },\n    { \"Canon IXUS 160\", 0, 0,\t\t/* DJC */\n      { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } },\n    { \"Casio EX-S20\", 0, 0,\t\t/* DJC */\n      { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },\n    { \"Casio EX-Z750\", 0, 0,\t\t/* DJC */\n      { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } },\n    { \"Casio EX-Z10\", 128, 0xfff,\t/* DJC */\n      { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } },\n    { \"CINE 650\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE 660\", 0, 0,\n      { 3390,480,-500,-800,3610,340,-550,2336,1192 } },\n    { \"CINE\", 0, 0,\n      { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },\n    { \"Contax N Digital\", 0, 0xf1e,\n      { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },\n    { \"DXO ONE\", 0, 0,\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Epson R-D1\", 0, 0,\n      { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },\n    { \"Fujifilm E550\", 0, 0,\n      { 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },\n    { \"Fujifilm E900\", 0, 0,\n      { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },\n    { \"Fujifilm F5\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F6\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F77\", 0, 0xfe9,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm F7\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm F8\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm S100FS\", 514, 0,\n      { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },\n    { \"Fujifilm S1\", 0, 0,\n      { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },\n    { \"Fujifilm S20Pro\", 0, 0,\n      { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },\n    { \"Fujifilm S20\", 512, 0x3fff,\n      { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },\n    { \"Fujifilm S2Pro\", 128, 0,\n      { 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },\n    { \"Fujifilm S3Pro\", 0, 0,\n      { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },\n    { \"Fujifilm S5Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm S5000\", 0, 0,\n      { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },\n    { \"Fujifilm S5100\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5500\", 0, 0,\n      { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },\n    { \"Fujifilm S5200\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S5600\", 0, 0,\n      { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },\n    { \"Fujifilm S6\", 0, 0,\n      { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },\n    { \"Fujifilm S7000\", 0, 0,\n      { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },\n    { \"Fujifilm S9000\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9500\", 0, 0,\n      { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },\n    { \"Fujifilm S9100\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm S9600\", 0, 0,\n      { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },\n    { \"Fujifilm SL1000\", 0, 0,\n      { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },\n    { \"Fujifilm IS-1\", 0, 0,\n      { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },\n    { \"Fujifilm IS Pro\", 0, 0,\n      { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },\n    { \"Fujifilm HS10 HS11\", 0, 0xf68,\n      { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },\n    { \"Fujifilm HS2\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS3\", 0, 0,\n      { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },\n    { \"Fujifilm HS50EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm F900EXR\", 0, 0,\n      { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },\n    { \"Fujifilm X100S\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100F\", 0, 0,\n      {11434,-4948,-1210,-3746,12042,1903,-666,1479,5235}},\n    { \"Fujifilm X100T\", 0, 0,\n      { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },\n    { \"Fujifilm X100\", 0, 0,\n      { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },\n    { \"Fujifilm X10\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X20\", 0, 0,\n      { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },\n    { \"Fujifilm X30\", 0, 0,\n      { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },\n    { \"Fujifilm X70\", 0, 0,\n      { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },\n    { \"Fujifilm X-Pro1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-Pro2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm X-A1\", 0, 0,\n      { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },\n    { \"Fujifilm X-A2\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-E1\", 0, 0,\n      { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },\n    { \"Fujifilm X-E2S\", 0, 0,\n      { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },\n    { \"Fujifilm X-E2\", 0, 0,\n      { 12066,-5927,-367,-1969,9878,1503,-721,2034,5453 } },\n    { \"Fujifilm XF1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-M1\", 0, 0,\n      { 13193,-6685,-425,-2229,10458,1534,-878,1763,5217 } },\n    { \"Fujifilm X-S1\", 0, 0,\n      { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },\n    { \"Fujifilm X-T10\", 0, 0,\n      { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },\n    { \"Fujifilm X-T20\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526}},\n    { \"Fujifilm GFX 50S\", 0, 0,\n      {11940,-4431,-1255,-6766,14428,2542,-994,1165,7421}},\n    { \"Fujifilm X-T1\", 0, 0,\n      { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },\n    { \"Fujifilm X-T2\", 0, 0,\n      { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },\n    { \"Fujifilm XQ1\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"Fujifilm XQ2\", 0, 0,\n      { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },\n    { \"GITUP GIT2\", 3200, 0,\n      {8489, -2583,-1036,-8051,15583,2643,-1307,1407,7354}},\n    { \"Hasselblad Lunar\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Hasselblad Stellar\", -800, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Hasselblad CFV\", 0, 0, /* Adobe */\n      { 8519, -3260, -280, -5081, 13459, 1738, -1449, 2960, 7809, } },\n    { \"Hasselblad H-16MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-22MP\", 0, 0, /* LibRaw */\n      { 17765,-5322,-1734,-6168,13354,2135,-264,2524,7440 } },\n    { \"Hasselblad H-31MP\",0, 0, /* LibRaw */\n      { 14480,-5448,-1686,-3534,13123,2260,384,2952,7232 } },\n    { \"Hasselblad H-39MP\",0, 0, /* Adobe */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H3D-50\", 0, 0, /* Adobe  */\n      { 3857,452, -46, -6008, 14477, 1596, -2627, 4481, 5718 } },\n    { \"Hasselblad H4D-40\",0, 0, /* LibRaw */\n      { 6325,-860,-957,-6559,15945,266,167,770,5936 } },\n    { \"Hasselblad H4D-50\",0, 0, /* LibRaw */\n      { 15283,-6272,-465,-2030,16031,478,-2379,390,7965 } },\n    { \"Hasselblad H4D-60\",0, 0, /* Adobe */\n      { 9662, -684, -279, -4903, 12293, 2950, -344, 1669, 6024 } },\n    { \"Hasselblad H5D-50c\",0, 0, /* Adobe */\n      { 4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 } },\n    { \"Hasselblad H5D-50\",0, 0, /* Adobe */\n      { 5656, -659, -346, -3923, 12306, 1791, -1602, 3509, 5442 } },\n    { \"Hasselblad X1D\",0, 0, /* Adobe */\n      {4932, -835, 141, -4878, 11868, 3437, -1138, 1961, 7067 }},\n    { \"HTC One A9\", 64, 1023, /* this is CM1 transposed */\n      { 101, -20, -2, -11, 145, 41, -24, 1, 56 } },\n    { \"Imacon Ixpress\", 0, 0,\t\t/* DJC */\n      { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },\n    { \"Kodak NC2000\", 0, 0,\n      { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },\n    { \"Kodak DCS315C\", -8, 0,\n      { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },\n    { \"Kodak DCS330C\", -8, 0,\n      { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },\n    { \"Kodak DCS420\", 0, 0,\n      { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },\n    { \"Kodak DCS460\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS1\", 0, 0,\n      { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },\n    { \"Kodak EOSDCS3B\", 0, 0,\n      { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },\n    { \"Kodak DCS520C\", -178, 0,\n      { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },\n    { \"Kodak DCS560C\", -177, 0,\n      { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },\n    { \"Kodak DCS620C\", -177, 0,\n      { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },\n    { \"Kodak DCS620X\", -176, 0,\n      { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },\n    { \"Kodak DCS660C\", -173, 0,\n      { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },\n    { \"Kodak DCS720X\", 0, 0,\n      { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },\n    { \"Kodak DCS760C\", 0, 0,\n      { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },\n    { \"Kodak DCS Pro SLR\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14nx\", 0, 0,\n      { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },\n    { \"Kodak DCS Pro 14\", 0, 0,\n      { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },\n    { \"Kodak ProBack645\", 0, 0,\n      { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },\n    { \"Kodak ProBack\", 0, 0,\n      { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },\n    { \"Kodak P712\", 0, 0,\n      { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },\n    { \"Kodak P850\", 0, 0xf7c,\n      { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },\n    { \"Kodak P880\", 0, 0xfff,\n      { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },\n    { \"Kodak EasyShare Z980\", 0, 0,\n      { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },\n    { \"Kodak EasyShare Z981\", 0, 0,\n      { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },\n    { \"Kodak EasyShare Z990\", 0, 0xfed,\n      { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },\n    { \"Kodak EASYSHARE Z1015\", 0, 0xef1,\n      { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },\n    { \"Leaf CMost\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Valeo 6\", 0, 0,\n      { 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },\n    { \"Leaf Aptus 54S\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Leaf Aptus 65\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Aptus 75\", 0, 0,\n      { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },\n    { \"Leaf Credo 40\", 0, 0,\n      { 8035, 435, -962, -6001, 13872, 2320, -1159, 3065, 5434 } },\n    { \"Leaf Credo 50\", 0, 0,\n      { 3984, 0, 0, 0, 10000, 0, 0, 0, 7666 } },\n    { \"Leaf Credo 60\", 0, 0,\n      { 8035, 435, -962, -6001, 13872,2320,-1159,3065,5434 } },\n    { \"Leaf Credo 80\", 0, 0,\n      { 6294, 686, -712, -5435, 13417, 2211, -1006, 2435, 5042 } },\n    { \"Leaf\", 0, 0,\n      { 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },\n    { \"Mamiya ZD\", 0, 0,\n      { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },\n    { \"Micron 2010\", 110, 0,\t\t/* DJC */\n      { 16695,-3761,-2151,155,9682,163,3433,951,4904 } },\n    { \"Minolta DiMAGE 5\", 0, 0xf7d,\n      { 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },\n    { \"Minolta DiMAGE 7Hi\", 0, 0xf7d,\n      { 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },\n    { \"Minolta DiMAGE 7\", 0, 0xf7d,\n      { 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },\n    { \"Minolta DiMAGE A1\", 0, 0xf8b,\n      { 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },\n    { \"Minolta DiMAGE A200\", 0, 0,\n      { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },\n    { \"Minolta DiMAGE A2\", 0, 0xf8f,\n      { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },\n    { \"Minolta DiMAGE Z2\", 0, 0,\t/* DJC */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Minolta DYNAX 5\", 0, 0xffb,\n      { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },\n    { \"Minolta DYNAX 7\", 0, 0xffb,\n      { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },\n    { \"Motorola PIXL\", 0, 0,\t\t/* DJC */\n      { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },\n    { \"Nikon D100\", 0, 0,\n      { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },\n    { \"Nikon D1H\", 0, 0,\n      { 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },\n    { \"Nikon D1X\", 0, 0,\n      { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },\n    { \"Nikon D1\", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */\n      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },\n    { \"Nikon D200\", 0, 0xfbc,\n      { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },\n    { \"Nikon D2H\", 0, 0,\n      { 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },\n    { \"Nikon D2X\", 0, 0,\n      { 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },\n    { \"Nikon D3000\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D3100\", 0, 0,\n      { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },\n    { \"Nikon D3200\", 0, 0xfb9,\n      { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },\n    { \"Nikon D3300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D3400\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D300\", 0, 0,\n      { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },\n    { \"Nikon D3X\", 0, 0,\n      { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },\n    { \"Nikon D3S\", 0, 0,\n      { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },\n    { \"Nikon D3\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D40X\", 0, 0,\n      { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },\n    { \"Nikon D40\", 0, 0,\n      { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },\n    { \"Nikon D4S\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D4\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon Df\", 0, 0,\n      { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },\n    { \"Nikon D5000\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },\n    { \"Nikon D5100\", 0, 0x3de6,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D5200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D5300\", 0, 0,\n      { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },\n    { \"Nikon D5500\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D5600\", 0, 0,\n      { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },\n    { \"Nikon D500\", 0, 0,\n        { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },\n    { \"Nikon D50\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D5\", 0, 0,\n      { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },\n    { \"Nikon D600\", 0, 0x3e07,\n      { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },\n    { \"Nikon D610\",0, 0,\n      { 10426,-4005,-444,-3565,11764,1403,-1206,2266,6549 } },\n    { \"Nikon D60\", 0, 0,\n      { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },\n    { \"Nikon D7000\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon D7100\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D7200\", 0, 0,\n      { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },\n    { \"Nikon D750\", -600, 0,\n      { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },\n    { \"Nikon D700\", 0, 0,\n      { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },\n    { \"Nikon D70\", 0, 0,\n      { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },\n    { \"Nikon D810A\", 0, 0,\n      { 11973, -5685, -888, -1965, 10326, 1901, -115, 1123, 7169 } },\n    { \"Nikon D810\", 0, 0,\n      { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },\n    { \"Nikon D800\", 0, 0,\n      { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },\n    { \"Nikon D80\", 0, 0,\n      { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },\n    { \"Nikon D90\", 0, 0xf00,\n      { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },\n    { \"Nikon E700\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E800\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E950\", 0, 0x3dd,\t\t/* DJC */\n      { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },\n    { \"Nikon E995\", 0, 0,\t/* copied from E5000 */\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E2100\", 0, 0,\t/* copied from Z2, new white balance */\n      { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } },\n    { \"Nikon E2500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E3200\", 0, 0,\t\t/* DJC */\n      { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } },\n    { \"Nikon E4300\", 0, 0,\t/* copied from Minolta DiMAGE Z2 */\n      { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },\n    { \"Nikon E4500\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5000\", 0, 0,\n      { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },\n    { \"Nikon E5400\", 0, 0,\n      { 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },\n    { \"Nikon E5700\", 0, 0,\n      { -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },\n    { \"Nikon E8400\", 0, 0,\n      { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },\n    { \"Nikon E8700\", 0, 0,\n      { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },\n    { \"Nikon E8800\", 0, 0,\n      { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },\n    { \"Nikon COOLPIX A\", 0, 0,\n      { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },\n    { \"Nikon COOLPIX B700\", 0, 0,\n      { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },\n    { \"Nikon COOLPIX P330\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P340\", -200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P6000\", 0, 0,\n      { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },\n    { \"Nikon COOLPIX P7000\", 0, 0,\n      { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },\n    { \"Nikon COOLPIX P7100\", 0, 0,\n      { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },\n    { \"Nikon COOLPIX P7700\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon COOLPIX P7800\", -3200, 0,\n      { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },\n    { \"Nikon 1 V3\", -200, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J4\", 0, 0,\n      { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },\n    { \"Nikon 1 J5\", 0, 0,\n      { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835} },\n    { \"Nikon 1 S2\", -200, 0,\n      { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },\n    { \"Nikon 1 V2\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 J3\", 0, 0,\n      { 8144,-2671,-473,-1740,9834,1601,-58,1971,4296 } },\n    { \"Nikon 1 AW1\", 0, 0,\n      { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },\n    { \"Nikon 1 \", 0, 0,\t\t/* J1, J2, S1, V1 */\n      { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },\n    { \"Olympus AIR-A01\", 0, 0xfe1,\n      { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },\n    { \"Olympus C5050\", 0, 0,\n      { 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },\n    { \"Olympus C5060\", 0, 0,\n      { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },\n    { \"Olympus C7070\", 0, 0,\n      { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },\n    { \"Olympus C70\", 0, 0,\n      { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },\n    { \"Olympus C80\", 0, 0,\n      { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },\n    { \"Olympus E-10\", 0, 0xffc,\n      { 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },\n    { \"Olympus E-1\", 0, 0,\n      { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },\n    { \"Olympus E-20\", 0, 0xffc,\n      { 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },\n    { \"Olympus E-300\", 0, 0,\n      { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },\n    { \"Olympus E-330\", 0, 0,\n      { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },\n    { \"Olympus E-30\", 0, 0xfbc,\n      { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },\n    { \"Olympus E-3\", 0, 0xf99,\n      { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },\n    { \"Olympus E-400\", 0, 0,\n      { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },\n    { \"Olympus E-410\", 0, 0xf6a,\n      { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },\n    { \"Olympus E-420\", 0, 0xfd7,\n      { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },\n    { \"Olympus E-450\", 0, 0xfd2,\n      { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },\n    { \"Olympus E-500\", 0, 0,\n      { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },\n    { \"Olympus E-510\", 0, 0xf6a,\n      { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },\n    { \"Olympus E-520\", 0, 0xfd2,\n      { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },\n    { \"Olympus E-5\", 0, 0xeec,\n      { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },\n    { \"Olympus E-600\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-620\", 0, 0xfaf,\n      { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },\n    { \"Olympus E-P1\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P2\", 0, 0xffd,\n      { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },\n    { \"Olympus E-P3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-P5\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL1s\", 0, 0,\n      { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },\n    { \"Olympus E-PL1\", 0, 0,\n      { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },\n    { \"Olympus E-PL2\", 0, 0xcf3,\n      { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },\n    { \"Olympus E-PL3\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PL5\", 0, 0xfcb,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL6\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-PL7\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PL8\", 0, 0,\n      { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },\n    { \"Olympus E-PM1\", 0, 0,\n      { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },\n    { \"Olympus E-PM2\", 0, 0,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M10\", 0, 0, /* Same for E-M10MarkII */\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus E-M1MarkII\", 0, 0, /* Adobe */\n      { 8380, -2630, -639, -2887, 10725, 2496, -627, 1427, 5438 }},\n    { \"Olympus E-M1\", 0, 0,\n      { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },\n    { \"Olympus E-M5MarkII\", 0, 0,\n      { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },\n    { \"Olympus E-M5\", 0, 0xfe1,\n      { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },\n    { \"Olympus PEN-F\",0, 0,\n      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },\n    { \"Olympus SP350\", 0, 0,\n      { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },\n    { \"Olympus SP3\", 0, 0,\n      { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },\n    { \"Olympus SP500UZ\", 0, 0xfff,\n      { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },\n    { \"Olympus SP510UZ\", 0, 0xffe,\n      { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },\n    { \"Olympus SP550UZ\", 0, 0xffe,\n      { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },\n    { \"Olympus SP560UZ\", 0, 0xff9,\n      { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },\n    { \"Olympus SP570UZ\", 0, 0,\n      { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },\n    { \"Olympus SH-2\", 0, 0,\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus SH-3\", 0, 0, /* Alias of SH-2 */\n     { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },\n    { \"Olympus STYLUS1\",0, 0,\n      { 11976,-5518,-545,-1419,10472,846,-475,1766,4524 } },\n    { \"Olympus TG-4\", 0, 0,\n     { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },\n    { \"Olympus XZ-10\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"Olympus XZ-1\", 0, 0,\n      { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },\n    { \"Olympus XZ-2\", 0, 0,\n      { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },\n    { \"OmniVision\", 16, 0x3ff,\n      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */\n    { \"Pentax *ist DL2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DL\", 0, 0,\n      { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },\n    { \"Pentax *ist DS2\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Pentax *ist DS\", 0, 0,\n      { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },\n    { \"Pentax *ist D\", 0, 0,\n      { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },\n    { \"Pentax K10D\", 0, 0,\n      { 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },\n    { \"Pentax K1\", 0, 0,\n      { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },\n    { \"Pentax K20D\", 0, 0,\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Pentax K200D\", 0, 0,\n      { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },\n    { \"Pentax K2000\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-m\", 0, 0,\n      { 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },\n    { \"Pentax K-x\", 0, 0,\n      { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },\n    { \"Pentax K-r\", 0, 0,\n      { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },\n    { \"Pentax K-1\", 0, 0,\n      { 8566,-2746,-1201,-3612,12204,1550,-893,1680,6264 } },\n    { \"Pentax K-30\", 0, 0,\n      { 8710,-2632,-1167,-3995,12301,1881,-981,1719,6535 } },\n    { \"Pentax K-3 II\", 0, 0,\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-3\", 0, 0,\n      { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },\n    { \"Pentax K-5 II\", 0, 0,\n      { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },\n    { \"Pentax K-5\", 0, 0,\n      { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },\n    { \"Pentax K-70\", 0, 0,\n      {8766, -3149, -747, -3976, 11943, 2292, -517, 1259, 5552 }},\n    { \"Pentax K-7\", 0, 0,\n      { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },\n    { \"Pentax KP\", 0, 0,  /* temp */\n      { 8626,-2607,-1155,-3995,12301,1881,-1039,1822,6925 } },\n    { \"Pentax K-S1\", 0, 0,\n      { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },\n    { \"Pentax K-S2\", 0, 0,\n      { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },\n    { \"Pentax Q-S1\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax MX-1\", 0, 0,\n      { 8804,-2523,-1238,-2423,11627,860,-682,1774,4753 } },\n    { \"Pentax Q10\", 0, 0,\n      { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },\n    { \"Pentax 645D\", 0, 0x3e00,\n      { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },\n    { \"Pentax 645Z\", 0, 0, /* Adobe */\n      { 9702, -3060, -1254, -3685, 12133, 1721, -1086, 2010, 6971}},\n    { \"Panasonic DMC-CM10\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n    { \"Panasonic DMC-CM1\", -15, 0,\n      { 8770, -3194,-820,-2871,11281,1803,-513,1552,4434 } },\n\n    { \"Panasonic DC-FZ82\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DC-FZ80\", -15, 0,  /* temp markets: FZ80 FZ82 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-FZ8\", 0, 0xf7f,\n      { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },\n    { \"Panasonic DMC-FZ18\", 0, 0,\n      { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },\n    { \"Panasonic DMC-FZ28\", -15, 0xf96,\n      { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },\n    { \"Panasonic DMC-FZ300\", -15, 0xfff,\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ330\", -15, 0xfff,  // same as FZ300\n      { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },\n    { \"Panasonic DMC-FZ30\", 0, 0xf94,\n      { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },\n    { \"Panasonic DMC-FZ3\", -15, 0,\n      { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },\n    { \"Panasonic DMC-FZ4\", -15, 0, /* 40,42,45 */\n      { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },\n    { \"Panasonic DMC-FZ50\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-FZ7\", -15, 0,\n      { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },\n    { \"Leica V-LUX1\", 0, 0,\n      { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },\n    { \"Panasonic DMC-L10\", -15, 0xf96,\n      { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },\n    { \"Panasonic DMC-L1\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Leica DIGILUX 3\", 0, 0xf7f,\n      { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },\n    { \"Panasonic DMC-LC1\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Leica DIGILUX 2\", 0, 0,\n      { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },\n    { \"Panasonic DMC-LX100\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX (Typ 109)\", -15, 0,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Panasonic DMC-LF1\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n    { \"Leica C (Typ 112)\", -15, 0,\n      { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },\n\n    { \"Panasonic DMC-LX9\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX10\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n    { \"Panasonic DMC-LX15\", -15, 0,  /* markets: LX9 LX10 LX15 */\n      { 7790, -2736, -755, -3452, 11870, 1769, -628, 1647, 4898 }}, /* Adobe*/\n\n    { \"Panasonic DMC-LX1\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Leica D-Lux (Typ 109)\", 0, 0xf7f,\n      { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },\n    { \"Leica D-LUX2\", 0, 0xf7f,\n      { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },\n    { \"Panasonic DMC-LX2\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Leica D-LUX3\", 0, 0,\n      { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },\n    { \"Panasonic DMC-LX3\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Leica D-LUX 4\", -15, 0,\n      { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },\n    { \"Panasonic DMC-LX5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Leica D-LUX 5\", -15, 0,\n      { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },\n    { \"Panasonic DMC-LX7\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Leica D-LUX 6\", -15, 0,\n      { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },\n    { \"Panasonic DMC-FZ1000\", -15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Leica V-LUX (Typ 114)\", 15, 0,\n      { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },\n    { \"Panasonic DMC-FZ100\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Leica V-LUX 2\", -15, 0xfff,\n      { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },\n    { \"Panasonic DMC-FZ150\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Leica V-LUX 3\", -15, 0xfff,\n      { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },\n    { \"Panasonic DMC-FZ2000\", -15, 0, /* markets: DMC-FZ2000,DMC-FZ2500,FZH1 */\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ2500\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZH1\", -15, 0,\n      { 7386, -2443, -743, -3437, 11864, 1757, -608, 1660, 4766 }},\n    { \"Panasonic DMC-FZ200\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Leica V-LUX 4\", -15, 0xfff,\n      { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },\n    { \"Panasonic DMC-FX150\", -15, 0xfff,\n      { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },\n    { \"Panasonic DMC-G10\", 0, 0,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G1\", -15, 0xf94,\n      { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },\n    { \"Panasonic DMC-G2\", -15, 0xf3c,\n      { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },\n    { \"Panasonic DMC-G3\", -15, 0xfff,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n    { \"Panasonic DMC-G5\", -15, 0xfff,\n      { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },\n    { \"Panasonic DMC-G6\", -15, 0xfff,\n      { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },\n    { \"Panasonic DMC-G7\", -15, 0xfff,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-G8\", -15, 0xfff,  /* markets: DMC-G8, DMC-G80, DMC-G81, DMC-G85 */\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF1\", -15, 0xf92,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF2\", -15, 0xfff,\n      { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },\n    { \"Panasonic DMC-GF3\", -15, 0xfff,\n      { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },\n    { \"Panasonic DMC-GF5\", -15, 0xfff,\n      { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },\n    { \"Panasonic DMC-GF6\", -15, 0,\n      { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },\n    { \"Panasonic DMC-GF7\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF8\", -15, 0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GH1\", -15, 0xf92,\n      { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },\n    { \"Panasonic DMC-GH2\", -15, 0xf95,\n      { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },\n    { \"Panasonic DMC-GH3\", -15, 0,\n      { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },\n    { \"Panasonic DMC-GH4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Yuneec CGO4\", -15, 0,\n      { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },\n    { \"Panasonic DMC-GM1\", -15, 0,\n      { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },\n    { \"Panasonic DMC-GM5\", -15, 0,\n      { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },\n    { \"Panasonic DMC-GX1\", -15, 0,\n      { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },\n\n    { \"Panasonic DC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX850\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GX800\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GF9\", -15, 0,  /* temp markets: GX850 GX800 GF9 */\n{ 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n\n    { \"Panasonic DMC-GX85\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX80\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7MK2\", -15, 0,  /* markets: GX85 GX80 GX7MK2 */\n      { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },\n    { \"Panasonic DMC-GX7\", -15,0,\n      { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },\n    { \"Panasonic DMC-GX8\", -15,0,\n      { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },\n    { \"Panasonic DMC-TZ6\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ8\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS4\", -15, 0,  /* markets: ZS40 TZ60 TZ61 */\n      { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },\n    { \"Panasonic DMC-TZ7\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS5\", -15, 0,  /* markets: ZS50 TZ70 TZ71 */\n      { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },\n    { \"Panasonic DMC-ZS6\", -15, 0,  /* markets: ZS60 TZ80 TZ81 TZ85 */\n      { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },\n    { \"Panasonic DMC-ZS100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-ZS110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ100\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ101\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TZ110\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Panasonic DMC-TX1\", -15, 0,  /* markets: ZS100 ZS110 TZ100 TZ101 TZ110 TX1 */\n      { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },\n    { \"Leica S (Typ 007)\", 0, 0,\n     { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },\n    { \"Leica X\", 0, 0,\t\t/* X and X-U, both (Typ 113) */\n     { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },\n    { \"Leica Q (Typ 116)\", 0, 0,\n     { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },\n    { \"Leica M (Typ 262)\", 0, 0,\n     { 6653,-1486,-611,-4221,13303,929,-881,2416,7226 } },\n    { \"Leica SL (Typ 601)\", 0, 0,\n      { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830} },\n    { \"Phase One H 20\", 0, 0,\t\t/* DJC */\n      { 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },\n    { \"Phase One H 25\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One IQ250\",0, 0,\n      { 4396,-153,-249,-5267,12249,2657,-1397,2323,6014 } },\n    { \"Phase One P 2\", 0, 0,\n      { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },\n    { \"Phase One P 30\", 0, 0,\n      { 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },\n    { \"Phase One P 45\", 0, 0,\n      { 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },\n    { \"Phase One P40\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Phase One P65\", 0, 0,\n      { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },\n    { \"Photron BC2-HD\", 0, 0,\t\t/* DJC */\n      { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } },\n    { \"Red One\", 704, 0xffff,\t\t/* DJC */\n      { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } },\n    { \"Ricoh GR II\", 0, 0,\n      { 4630,-834,-423,-4977,12805,2417,-638,1467,6115 } },\n    { \"Ricoh GR\", 0, 0,\n       { 3708,-543,-160,-5381,12254,3556,-1471,1929,8234 } },\n    { \"Samsung EK-GN120\", 0, 0, /* Adobe; Galaxy NX */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung EX1\", 0, 0x3e00,\n      { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },\n    { \"Samsung EX2F\", 0, 0x7ff,\n      { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },\n    { \"Samsung NX mini\", 0, 0,\n      { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },\n    { \"Samsung NX3300\", 0, 0, /* same as NX3000 */\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX3000\", 0, 0,\n      { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },\n    { \"Samsung NX30\", 0, 0,\t/* NX30, NX300, NX300M */\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2000\", 0, 0,\n      { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },\n    { \"Samsung NX2\", 0, 0xfff,\t/* NX20, NX200, NX210 */\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1000\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX1100\", 0, 0,\n      { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },\n    { \"Samsung NX11\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX10\", 0, 0,\t/* also NX100 */\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX500\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung NX5\", 0, 0,\n      { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },\n    { \"Samsung NX1\", 0, 0,\n      { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },\n    { \"Samsung WB2000\", 0, 0xfff,\n      { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },\n    { \"Samsung GX-1\", 0, 0,\n      { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },\n    { \"Samsung GX20\", 0, 0,\t/* copied from Pentax K20D */\n      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },\n    { \"Samsung S85\", 0, 0,\t\t/* DJC */\n      { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },\n     // Foveon: LibRaw color data\n    { \"Sigma dp0 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp1 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp2 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma dp3 Quattro\", 2047, 0,\n      { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },\n    { \"Sigma sd Quattro H\", 256, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma sd Quattro\", 2047, 0,\n      {1295,108,-311, 256,828,-65,-28,750,254}}, /* temp */\n    { \"Sigma SD9\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD10\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD14\", 15, 16383,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    { \"Sigma SD15\", 15, 4095,\t\t\t/* LibRaw */\n      { 14082,-2201,-1056,-5243,14788,167,-121,196,8881 } },\n    // Merills + SD1\n    { \"Sigma SD1\", 31, 4095,\t\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP1 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP2 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    { \"Sigma DP3 Merrill\", 31, 4095,\t\t/* LibRaw */\n      { 5133,-1895,-353,4978,744,144,3837,3069,2777 } },\n    // Sigma DP (non-Merill Versions)\n    { \"Sigma DP\", 0, 4095,\t\t\t/* LibRaw */\n      //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },\n      { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } },\n    { \"Sinar\", 0, 0,\t\t\t/* DJC */\n      { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },\n    { \"Sony DSC-F828\", 0, 0,\n      { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },\n    { \"Sony DSC-R1\", 0, 0,\n      { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },\n    { \"Sony DSC-V3\", 0, 0,\n      { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },\n    {\"Sony DSC-RX100M5\", -800, 0,  /* Adobe */\n      {6596, -2079, -562, -4782, 13016, 1933, -970, 1581, 5181 }},\n    { \"Sony DSC-RX100M\", -800, 0,\t/* M2 and M3 and M4 */\n      { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },\n    { \"Sony DSC-RX100\", 0, 0,\n      { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },\n    { \"Sony DSC-RX10\",0, 0, /* And M2/M3 too */\n      { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },\n    { \"Sony DSC-RX1RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony DSC-RX1R\", 0, 0,\n      { 8195,-2800,-422,-4261,12273,1709,-1505,2400,5624 } },\n    { \"Sony DSC-RX1\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n    { \"Sony DSLR-A100\", 0, 0xfeb,\n      { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },\n    { \"Sony DSLR-A290\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A2\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A300\", 0, 0,\n      { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },\n    { \"Sony DSLR-A330\", 0, 0,\n      { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },\n    { \"Sony DSLR-A350\", 0, 0xffc,\n      { 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },\n    { \"Sony DSLR-A380\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A390\", 0, 0,\n      { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },\n    { \"Sony DSLR-A450\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A580\", 0, 0xfeb,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony DSLR-A500\", 0, 0xfeb,\n      { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },\n    { \"Sony DSLR-A5\", 0, 0xfeb,\n      { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },\n    { \"Sony DSLR-A700\", 0, 0,\n      { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },\n    { \"Sony DSLR-A850\", 0, 0,\n      { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },\n    { \"Sony DSLR-A900\", 0, 0,\n      { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },\n    { \"Sony ILCA-68\", 0, 0,\n      { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },\n    { \"Sony ILCA-77M2\", 0, 0,\n      { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },\n    { \"Sony ILCA-99M2\", 0, 0, /* Adobe */\n      { 6660, -1918, -471, -4613, 12398, 2485, -649, 1433, 6447}},\n    { \"Sony ILCE-7M2\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-7SM2\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7S\", 0, 0,\n      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },\n    { \"Sony ILCE-7RM2\", 0, 0,\n      { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },\n    { \"Sony ILCE-7R\", 0, 0,\n      { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },\n    { \"Sony ILCE-7\", 0, 0,\n      { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },\n    { \"Sony ILCE-6300\", 0, 0,\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE-6500\", 0, 0, /* Adobe */\n      { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },\n    { \"Sony ILCE\", 0, 0,\t/* 3000, 5000, 5100, 6000, and QX1 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5N\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony NEX-5R\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-5T\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3N\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-3\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-5\", 0, 0,\t\t/* Adobe */\n      { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },\n    { \"Sony NEX-6\", 0, 0,\n      { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },\n    { \"Sony NEX-7\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony NEX\", 0, 0,\t/* NEX-C3, NEX-F3 */\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A33\", 0, 0,\n      { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },\n    { \"Sony SLT-A35\", 0, 0,\n      { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },\n    { \"Sony SLT-A37\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A55\", 0, 0,\n      { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },\n    { \"Sony SLT-A57\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A58\", 0, 0,\n      { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },\n    { \"Sony SLT-A65\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A77\", 0, 0,\n      { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },\n    { \"Sony SLT-A99\", 0, 0,\n      { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },\n  };\n  // clang-format on\n\n  double cam_xyz[4][3];\n  char name[130];\n  int i, j;\n\n  if (colors > 4 || colors < 1)\n    return;\n\n  int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;\n  if (cblack[4] * cblack[5] > 0)\n  {\n    for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n      bl64 += cblack[c + 6];\n    bl64 /= cblack[4] * cblack[5];\n  }\n  int rblack = black + bl4 + bl64;\n\n  sprintf(name, \"%s %s\", t_make, t_model);\n  for (i = 0; i < sizeof table / sizeof *table; i++)\n    if (!strncasecmp(name, table[i].prefix, strlen(table[i].prefix)))\n    {\n      if (!dng_version)\n      {\n        if (table[i].t_black > 0)\n        {\n          black = (ushort)table[i].t_black;\n          memset(cblack, 0, sizeof(cblack));\n        }\n        else if (table[i].t_black < 0 && rblack == 0)\n        {\n          black = (ushort)(-table[i].t_black);\n          memset(cblack, 0, sizeof(cblack));\n        }\n        if (table[i].t_maximum)\n          maximum = (ushort)table[i].t_maximum;\n      }\n      if (table[i].trans[0])\n      {\n        for (raw_color = j = 0; j < 12; j++)\n#ifdef LIBRAW_LIBRARY_BUILD\n          if (internal_only)\n            imgdata.color.cam_xyz[0][j] = table[i].trans[j] / 10000.0;\n          else\n            imgdata.color.cam_xyz[0][j] =\n#endif\n                ((double *)cam_xyz)[j] = table[i].trans[j] / 10000.0;\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!internal_only)\n#endif\n          cam_xyz_coeff(rgb_cam, cam_xyz);\n      }\n      break;\n    }\n}\n\nvoid CLASS simple_coeff(int index)\n{\n  static const float table[][12] = {/* index 0 -- all Foveon cameras */\n                                    {1.4032, -0.2231, -0.1016, -0.5263, 1.4816, 0.017, -0.0112, 0.0183, 0.9113},\n                                    /* index 1 -- Kodak DC20 and DC25 */\n                                    {2.25, 0.75, -1.75, -0.25, -0.25, 0.75, 0.75, -0.25, -0.25, -1.75, 0.75, 2.25},\n                                    /* index 2 -- Logitech Fotoman Pixtura */\n                                    {1.893, -0.418, -0.476, -0.495, 1.773, -0.278, -1.017, -0.655, 2.672},\n                                    /* index 3 -- Nikon E880, E900, and E990 */\n                                    {-1.936280, 1.800443, -1.448486, 2.584324, 1.405365, -0.524955, -0.289090, 0.408680,\n                                     -1.204965, 1.082304, 2.941367, -1.818705}};\n  int i, c;\n\n  for (raw_color = i = 0; i < 3; i++)\n    FORCC rgb_cam[i][c] = table[index][i * colors + c];\n}\n\nshort CLASS guess_byte_order(int words)\n{\n  uchar test[4][2];\n  int t = 2, msb;\n  double diff, sum[2] = {0, 0};\n\n  fread(test[0], 2, 2, ifp);\n  for (words -= 2; words--;)\n  {\n    fread(test[t], 2, 1, ifp);\n    for (msb = 0; msb < 2; msb++)\n    {\n      diff = (test[t ^ 2][msb] << 8 | test[t ^ 2][!msb]) - (test[t][msb] << 8 | test[t][!msb]);\n      sum[msb] += diff * diff;\n    }\n    t = (t + 1) & 3;\n  }\n  return sum[0] < sum[1] ? 0x4d4d : 0x4949;\n}\n\nfloat CLASS find_green(int bps, int bite, int off0, int off1)\n{\n  UINT64 bitbuf = 0;\n  int vbits, col, i, c;\n  ushort img[2][2064];\n  double sum[] = {0, 0};\n\n  FORC(2)\n  {\n    fseek(ifp, c ? off1 : off0, SEEK_SET);\n    for (vbits = col = 0; col < width; col++)\n    {\n      for (vbits -= bps; vbits < 0; vbits += bite)\n      {\n        bitbuf <<= bite;\n        for (i = 0; i < bite; i += 8)\n          bitbuf |= (unsigned)(fgetc(ifp) << i);\n      }\n      img[c][col] = bitbuf << (64 - bps - vbits) >> (64 - bps);\n    }\n  }\n  FORC(width - 1)\n  {\n    sum[c & 1] += ABS(img[0][c] - img[1][c + 1]);\n    sum[~c & 1] += ABS(img[1][c] - img[0][c + 1]);\n  }\n  return 100 * log(sum[0] / sum[1]);\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nstatic void remove_trailing_spaces(char *string, size_t len)\n{\n  if (len < 1)\n    return; // not needed, b/c sizeof of make/model is 64\n  string[len - 1] = 0;\n  if (len < 3)\n    return; // also not needed\n  len = strnlen(string, len - 1);\n  for (int i = len - 1; i >= 0; i--)\n  {\n    if (isspace(string[i]))\n      string[i] = 0;\n    else\n      break;\n  }\n}\n\nvoid CLASS initdata()\n{\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n  for (int i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n}\n\n#endif\n/*\n   Identify which camera created this file, and set global variables\n   accordingly.\n */\nvoid CLASS identify()\n{\n  static const short pana[][6] = {\n      {3130, 1743, 4, 0, -6, 0},    {3130, 2055, 4, 0, -6, 0},      {3130, 2319, 4, 0, -6, 0},\n      {3170, 2103, 18, 0, -42, 20}, {3170, 2367, 18, 13, -42, -21}, {3177, 2367, 0, 0, -1, 0},\n      {3304, 2458, 0, 0, -1, 0},    {3330, 2463, 9, 0, -5, 0},      {3330, 2479, 9, 0, -17, 4},\n      {3370, 1899, 15, 0, -44, 20}, {3370, 2235, 15, 0, -44, 20},   {3370, 2511, 15, 10, -44, -21},\n      {3690, 2751, 3, 0, -8, -3},   {3710, 2751, 0, 0, -3, 0},      {3724, 2450, 0, 0, 0, -2},\n      {3770, 2487, 17, 0, -44, 19}, {3770, 2799, 17, 15, -44, -19}, {3880, 2170, 6, 0, -6, 0},\n      {4060, 3018, 0, 0, 0, -2},    {4290, 2391, 3, 0, -8, -1},     {4330, 2439, 17, 15, -44, -19},\n      {4508, 2962, 0, 0, -3, -4},   {4508, 3330, 0, 0, -3, -6},\n  };\n  static const ushort canon[][11] = {\n      {1944, 1416, 0, 0, 48, 0},\n      {2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25},\n      {2224, 1456, 48, 6, 0, 2},\n      {2376, 1728, 12, 6, 52, 2},\n      {2672, 1968, 12, 6, 44, 2},\n      {3152, 2068, 64, 12, 0, 0, 16},\n      {3160, 2344, 44, 12, 4, 4},\n      {3344, 2484, 4, 6, 52, 6},\n      {3516, 2328, 42, 14, 0, 0},\n      {3596, 2360, 74, 12, 0, 0},\n      {3744, 2784, 52, 12, 8, 12},\n      {3944, 2622, 30, 18, 6, 2},\n      {3948, 2622, 42, 18, 0, 2},\n      {3984, 2622, 76, 20, 0, 2, 14},\n      {4104, 3048, 48, 12, 24, 12},\n      {4116, 2178, 4, 2, 0, 0},\n      {4152, 2772, 192, 12, 0, 0},\n      {4160, 3124, 104, 11, 8, 65},\n      {4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49},\n      {4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49},\n      {4312, 2876, 22, 18, 0, 2},\n      {4352, 2874, 62, 18, 0, 0},\n      {4476, 2954, 90, 34, 0, 0},\n      {4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49},\n      {4480, 3366, 80, 50, 0, 0},\n      {4496, 3366, 80, 50, 12, 0},\n      {4768, 3516, 96, 16, 0, 0, 0, 16},\n      {4832, 3204, 62, 26, 0, 0},\n      {4832, 3228, 62, 51, 0, 0},\n      {5108, 3349, 98, 13, 0, 0},\n      {5120, 3318, 142, 45, 62, 0},\n      {5280, 3528, 72, 52, 0, 0}, /* EOS M */\n      {5344, 3516, 142, 51, 0, 0},\n      {5344, 3584, 126, 100, 0, 2},\n      {5360, 3516, 158, 51, 0, 0},\n      {5568, 3708, 72, 38, 0, 0},\n      {5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49},\n      {5712, 3774, 62, 20, 10, 2},\n      {5792, 3804, 158, 51, 0, 0},\n      {5920, 3950, 122, 80, 2, 0},\n      {6096, 4056, 72, 34, 0, 0},  /* EOS M3 */\n      {6288, 4056, 266, 36, 0, 0}, /* EOS 80D */\n      {6880, 4544, 136, 42, 0, 0}, /* EOS 5D4 */\n      {8896, 5920, 160, 64, 0, 0},\n  };\n  static const struct\n  {\n    ushort id;\n    char t_model[20];\n  } unique[] =\n      {\n          {0x001, \"EOS-1D\"},\n          {0x167, \"EOS-1DS\"},\n          {0x168, \"EOS 10D\"},\n          {0x169, \"EOS-1D Mark III\"},\n          {0x170, \"EOS 300D\"},\n          {0x174, \"EOS-1D Mark II\"},\n          {0x175, \"EOS 20D\"},\n          {0x176, \"EOS 450D\"},\n          {0x188, \"EOS-1Ds Mark II\"},\n          {0x189, \"EOS 350D\"},\n          {0x190, \"EOS 40D\"},\n          {0x213, \"EOS 5D\"},\n          {0x215, \"EOS-1Ds Mark III\"},\n          {0x218, \"EOS 5D Mark II\"},\n          {0x232, \"EOS-1D Mark II N\"},\n          {0x234, \"EOS 30D\"},\n          {0x236, \"EOS 400D\"},\n          {0x250, \"EOS 7D\"},\n          {0x252, \"EOS 500D\"},\n          {0x254, \"EOS 1000D\"},\n          {0x261, \"EOS 50D\"},\n          {0x269, \"EOS-1D X\"},\n          {0x270, \"EOS 550D\"},\n          {0x281, \"EOS-1D Mark IV\"},\n          {0x285, \"EOS 5D Mark III\"},\n          {0x286, \"EOS 600D\"},\n          {0x287, \"EOS 60D\"},\n          {0x288, \"EOS 1100D\"},\n          {0x289, \"EOS 7D Mark II\"},\n          {0x301, \"EOS 650D\"},\n          {0x302, \"EOS 6D\"},\n          {0x324, \"EOS-1D C\"},\n          {0x325, \"EOS 70D\"},\n          {0x326, \"EOS 700D\"},\n          {0x327, \"EOS 1200D\"},\n          {0x328, \"EOS-1D X Mark II\"},\n          {0x331, \"EOS M\"},\n          {0x335, \"EOS M2\"},\n          {0x374, \"EOS M3\"},  /* temp */\n          {0x384, \"EOS M10\"}, /* temp */\n          {0x394, \"EOS M5\"},  /* temp */\n          {0x346, \"EOS 100D\"},\n          {0x347, \"EOS 760D\"},\n          {0x349, \"EOS 5D Mark IV\"},\n          {0x350, \"EOS 80D\"},\n          {0x382, \"EOS 5DS\"},\n          {0x393, \"EOS 750D\"},\n          {0x401, \"EOS 5DS R\"},\n          {0x404, \"EOS 1300D\"},\n      },\n    sonique[] = {\n        {0x002, \"DSC-R1\"},      {0x100, \"DSLR-A100\"},   {0x101, \"DSLR-A900\"},  {0x102, \"DSLR-A700\"},\n        {0x103, \"DSLR-A200\"},   {0x104, \"DSLR-A350\"},   {0x105, \"DSLR-A300\"},  {0x106, \"DSLR-A900\"},\n        {0x107, \"DSLR-A380\"},   {0x108, \"DSLR-A330\"},   {0x109, \"DSLR-A230\"},  {0x10a, \"DSLR-A290\"},\n        {0x10d, \"DSLR-A850\"},   {0x10e, \"DSLR-A850\"},   {0x111, \"DSLR-A550\"},  {0x112, \"DSLR-A500\"},\n        {0x113, \"DSLR-A450\"},   {0x116, \"NEX-5\"},       {0x117, \"NEX-3\"},      {0x118, \"SLT-A33\"},\n        {0x119, \"SLT-A55V\"},    {0x11a, \"DSLR-A560\"},   {0x11b, \"DSLR-A580\"},  {0x11c, \"NEX-C3\"},\n        {0x11d, \"SLT-A35\"},     {0x11e, \"SLT-A65V\"},    {0x11f, \"SLT-A77V\"},   {0x120, \"NEX-5N\"},\n        {0x121, \"NEX-7\"},       {0x122, \"NEX-VG20E\"},   {0x123, \"SLT-A37\"},    {0x124, \"SLT-A57\"},\n        {0x125, \"NEX-F3\"},      {0x126, \"SLT-A99V\"},    {0x127, \"NEX-6\"},      {0x128, \"NEX-5R\"},\n        {0x129, \"DSC-RX100\"},   {0x12a, \"DSC-RX1\"},     {0x12b, \"NEX-VG900\"},  {0x12c, \"NEX-VG30E\"},\n        {0x12e, \"ILCE-3000\"},   {0x12f, \"SLT-A58\"},     {0x131, \"NEX-3N\"},     {0x132, \"ILCE-7\"},\n        {0x133, \"NEX-5T\"},      {0x134, \"DSC-RX100M2\"}, {0x135, \"DSC-RX10\"},   {0x136, \"DSC-RX1R\"},\n        {0x137, \"ILCE-7R\"},     {0x138, \"ILCE-6000\"},   {0x139, \"ILCE-5000\"},  {0x13d, \"DSC-RX100M3\"},\n        {0x13e, \"ILCE-7S\"},     {0x13f, \"ILCA-77M2\"},   {0x153, \"ILCE-5100\"},  {0x154, \"ILCE-7M2\"},\n        {0x155, \"DSC-RX100M4\"}, {0x156, \"DSC-RX10M2\"},  {0x158, \"DSC-RX1RM2\"}, {0x15a, \"ILCE-QX1\"},\n        {0x15b, \"ILCE-7RM2\"},   {0x15e, \"ILCE-7SM2\"},   {0x161, \"ILCA-68\"},    {0x162, \"ILCA-99M2\"},\n        {0x163, \"DSC-RX10M3\"},  {0x164, \"DSC-RX100M5\"}, {0x165, \"ILCE-6300\"},  {0x168, \"ILCE-6500\"},\n    };\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  static const libraw_custom_camera_t const_table[]\n#else\n  static const struct\n  {\n    unsigned fsize;\n    ushort rw, rh;\n    uchar lm, tm, rm, bm, lf, cf, max, flags;\n    char t_make[10], t_model[20];\n    ushort offset;\n  } table[]\n#endif\n      = {\n          {786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-080C\"},\n          {1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-145C\"},\n          {1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-201C\"},\n          {5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\"},\n          {10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-510C\", 12},\n          {16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, \"AVT\", \"F-810C\"},\n          {15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, \"AgfaPhoto\", \"DC-833m\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Alcatel\", \"5035D\"},\n          {31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 4:3\"},\n          {23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, \"GITUP\", \"GIT2 16:9\"},\n          //   Android Raw dumps id start\n          //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg 0x16 bbgr 0x94 rggb\n          {1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"Samsung\", \"S3\"},\n          {2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontMipi\"},\n          {2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3FrontQCOM\"},\n          {2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wMipi\"},\n          {3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"MI3wQCOM\"},\n          {3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, \"I_Mobile\", \"I_StyleQ6\"},\n          {5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel1\"},\n          {5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"UltraPixel2\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, \"OmniVisi\", \"4688\"},\n          {6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, \"OmniVisi\", \"OV5648\"},\n          {6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"OmniVisi\", \"OV56482\"},\n          {6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"OneSV\"},\n          {9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"5mp\"},\n          {9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, \"NGM\", \"ForwardArt\"},\n          {10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX219-mipi 8mp\"},\n          {10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Sony\", \"IMX\"},\n          {10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"HTC\", \"MyTouch4GSlide\"},\n          {10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Xperia\", \"L\"},\n          {15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, \"OmniVison\", \"OV8850\"},\n          {16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3MipiL\"},\n          {16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"IMX135\", \"MipiL\"},\n          {17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G3LQCom\"},\n          {17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, \"Sony\", \"IMX135-QCOM\"},\n          {19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7mipi\"},\n          {19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, \"LG\", \"G4\"},\n          {20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Xiaomi\", \"RedmiNote3Pro\"},\n          {20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, \"Sony\", \"IMX298-mipi 16mp\"},\n          {21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, \"Gione\", \"E7qcom\"},\n          {26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, \"THL\", \"5000\"},\n          {26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, \"Sony\", \"IMX214\"},\n          {26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, \"OV\", \"13860\"},\n          {41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Meizu\", \"MX4\"},\n          {42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, \"Sony\", \"IMX230\"},\n          //   Android Raw dumps id end\n          {20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, \"Aptina\", \"MT9J003\", 0xffff},\n          {2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, \"Baumer\", \"TXG14\", 1078},\n          {5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SD300\"},\n          {6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A460\"},\n          {6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A610\"},\n          {6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A530\"},\n          {7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot S3 IS\"},\n          {9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A620\"},\n          {9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A470\"},\n          {10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A720 IS\"},\n          {10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A630\"},\n          {12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A640\"},\n          {15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot A650\"},\n          {15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX110 IS\"},\n          {15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX120 IS\"},\n          {18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX20 IS\"},\n          {19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, \"Canon\", \"PowerShot SX220 HS\"},\n          {21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, \"Canon\", \"PowerShot SX30 IS\"},\n          {24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, \"Canon\", \"PowerShot A3300 IS\"},\n          {30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, \"Canon\", \"IXUS 160\"},\n          {1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-2000UX\"},\n          {3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, \"Casio\", \"QV-3*00EX\"},\n          {6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, \"Casio\", \"QV-5700\"},\n          {7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, \"Casio\", \"EX-Z60\"},\n          {2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, \"Casio\", \"EX-S20\"},\n          {4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, \"Casio\", \"EX-S100\"},\n          {6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R41\"},\n          {7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-P505\"},\n          {7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Casio\", \"QV-R51\"},\n          {7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, \"Casio\", \"EX-Z50\"},\n          {7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, \"Casio\", \"EX-Z500\"},\n          {7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, \"Casio\", \"EX-Z55\"},\n          {9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, \"Casio\", \"EX-P600\"},\n          {10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z750\"},\n          {10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z75\"},\n          {10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, \"Casio\", \"EX-P700\"},\n          {12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, \"Casio\", \"EX-Z850\"},\n          {12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, \"Casio\", \"EX-Z8\"},\n          {15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, \"Casio\", \"EX-Z1050\"},\n          {18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, \"Casio\", \"EX-ZR100\"},\n          {7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, \"Casio\", \"QV-4000\"},\n          {787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, \"Creative\", \"PC-CAM 600\"},\n          {28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, \"DJI\"},\n          {15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Matrix\"},\n          {3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, \"Foculus\", \"531C\"},\n          {307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Generic\"},\n          {62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, \"Kodak\", \"DC20\"},\n          {1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, \"Kodak\", \"DCS200\"},\n          {4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\"},\n          {4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, \"Kodak\", \"C330\", 3160},\n          {2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, \"Kodak\", \"C330\"},\n          {6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\"},\n          {6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, \"Kodak\", \"C603\", 3160},\n          {460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"C603\"},\n          {12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\"},\n          {12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, \"Kodak\", \"12MP\", 31556},\n          {18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, \"Kodak\", \"12MP\"},\n          {614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, \"Kodak\", \"KAI-0340\"},\n          {15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Lenovo\", \"A820\"},\n          {3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, \"Micron\", \"2010\", 3212},\n          {1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, \"Minolta\", \"RD175\", 513},\n          {1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, \"Nikon\", \"E900\"},\n          {2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, \"Nikon\", \"E950\"},\n          {2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, \"Nikon\", \"E2100\"},\n          {4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, \"Nikon\", \"E990\"},\n          {4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, \"Nikon\", \"E3700\"},\n          {5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E4500\"},\n          {5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, \"Nikon\", \"E4300\"},\n          {7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, \"Nikon\", \"E5000\"},\n          {8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, \"Nikon\", \"COOLPIX S6\"},\n          {5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, \"Olympus\", \"C770UZ\"},\n          {3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, \"Pentax\", \"Optio S\"},\n          {4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S\"},\n          {6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, \"Pentax\", \"Optio S4\"},\n          {10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, \"Pentax\", \"Optio 750Z\"},\n          {4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\"},\n          {4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, \"Photron\", \"BC2-HD\", 8},\n          {13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, \"Pixelink\", \"A782\"},\n          {6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, \"RoverShot\", \"3320AF\"},\n          {311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, \"ST Micro\", \"STV680 VGA\"},\n          {16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, \"Samsung\", \"S85\"},\n          {20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, \"Samsung\", \"WB550\"},\n          {12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, \"Sinar\", \"\", 68},\n          {1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n          {2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, \"Sony\", \"XCD-SX910CR\"},\n      };\n#ifdef LIBRAW_LIBRARY_BUILD\n  libraw_custom_camera_t table[64 + sizeof(const_table) / sizeof(const_table[0])];\n#endif\n\n  static const char *corp[] = {\"AgfaPhoto\", \"Canon\",     \"Casio\",  \"Epson\",   \"Fujifilm\", \"Mamiya\", \"Minolta\",\n                               \"Motorola\",  \"Kodak\",     \"Konica\", \"Leica\",   \"Nikon\",    \"Nokia\",  \"Olympus\",\n                               \"Pentax\",    \"Phase One\", \"Ricoh\",  \"Samsung\", \"Sigma\",    \"Sinar\",  \"Sony\"};\n#ifdef LIBRAW_LIBRARY_BUILD\n  char head[64], *cp;\n#else\n  char head[32], *cp;\n#endif\n  int hlen, flen, fsize, zero_fsize = 1, i, c;\n  struct jhead jh;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  unsigned camera_count = parse_custom_cameras(64, table, imgdata.params.custom_camera_strings);\n  for (int q = 0; q < sizeof(const_table) / sizeof(const_table[0]); q++)\n    memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));\n  camera_count += sizeof(const_table) / sizeof(const_table[0]);\n#endif\n\n  tiff_flip = flip = filters = UINT_MAX; /* unknown */\n  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;\n  maximum = height = width = top_margin = left_margin = 0;\n  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;\n  iso_speed = shutter = aperture = focal_len = unique_id = 0;\n  tiff_nifds = 0;\n  memset(tiff_ifd, 0, sizeof tiff_ifd);\n#ifdef LIBRAW_LIBRARY_BUILD\n  for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)\n  {\n    tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant = 0xffff;\n    for (int c = 0; c < 4; c++)\n      tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n  }\n#endif\n  memset(gpsdata, 0, sizeof gpsdata);\n  memset(cblack, 0, sizeof cblack);\n  memset(white, 0, sizeof white);\n  memset(mask, 0, sizeof mask);\n  thumb_offset = thumb_length = thumb_width = thumb_height = 0;\n  load_raw = thumb_load_raw = 0;\n  write_thumb = &CLASS jpeg_thumb;\n  data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;\n  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;\n  timestamp = shot_order = tiff_samples = black = is_foveon = 0;\n  mix_green = profile_length = data_error = zero_is_bad = 0;\n  pixel_aspect = is_raw = raw_color = 1;\n  tile_width = tile_length = 0;\n\n  for (i = 0; i < 4; i++)\n  {\n    cam_mul[i] = i == 1;\n    pre_mul[i] = i < 3;\n    FORC3 cmatrix[c][i] = 0;\n    FORC3 rgb_cam[c][i] = c == i;\n  }\n  colors = 3;\n  for (i = 0; i < 0x10000; i++)\n    curve[i] = i;\n\n  order = get2();\n  hlen = get4();\n  fseek(ifp, 0, SEEK_SET);\n#ifdef LIBRAW_LIBRARY_BUILD\n  fread(head, 1, 64, ifp);\n  libraw_internal_data.unpacker_data.lenRAFData = libraw_internal_data.unpacker_data.posRAFData = 0;\n#else\n  fread(head, 1, 32, ifp);\n#endif\n  fseek(ifp, 0, SEEK_END);\n  flen = fsize = ftell(ifp);\n  if ((cp = (char *)memmem(head, 32, (char *)\"MMMM\", 4)) || (cp = (char *)memmem(head, 32, (char *)\"IIII\", 4)))\n  {\n    parse_phase_one(cp - head);\n    if (cp - head && parse_tiff(0))\n      apply_tiff();\n  }\n  else if (order == 0x4949 || order == 0x4d4d)\n  {\n    if (!memcmp(head + 6, \"HEAPCCDR\", 8))\n    {\n      data_offset = hlen;\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(hlen, flen - hlen, 0);\n      load_raw = &CLASS canon_load_raw;\n    }\n    else if (parse_tiff(0))\n      apply_tiff();\n  }\n  else if (!memcmp(head, \"\\xff\\xd8\\xff\\xe1\", 4) && !memcmp(head + 6, \"Exif\", 4))\n  {\n    fseek(ifp, 4, SEEK_SET);\n    data_offset = 4 + get2();\n    fseek(ifp, data_offset, SEEK_SET);\n    if (fgetc(ifp) != 0xff)\n      parse_tiff(12);\n    thumb_offset = 0;\n  }\n  else if (!memcmp(head + 25, \"ARECOYK\", 7))\n  {\n    strcpy(make, \"Contax\");\n    strcpy(model, \"N Digital\");\n    fseek(ifp, 33, SEEK_SET);\n    get_timestamp(1);\n    fseek(ifp, 52, SEEK_SET);\n    switch (get4())\n    {\n    case 7:\n      iso_speed = 25;\n      break;\n    case 8:\n      iso_speed = 32;\n      break;\n    case 9:\n      iso_speed = 40;\n      break;\n    case 10:\n      iso_speed = 50;\n      break;\n    case 11:\n      iso_speed = 64;\n      break;\n    case 12:\n      iso_speed = 80;\n      break;\n    case 13:\n      iso_speed = 100;\n      break;\n    case 14:\n      iso_speed = 125;\n      break;\n    case 15:\n      iso_speed = 160;\n      break;\n    case 16:\n      iso_speed = 200;\n      break;\n    case 17:\n      iso_speed = 250;\n      break;\n    case 18:\n      iso_speed = 320;\n      break;\n    case 19:\n      iso_speed = 400;\n      break;\n    }\n    shutter = powf64(2.0f, (((float)get4()) / 8.0f)) / 16000.0f;\n    FORC4 cam_mul[c ^ (c >> 1)] = get4();\n    fseek(ifp, 88, SEEK_SET);\n    aperture = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 112, SEEK_SET);\n    focal_len = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n    fseek(ifp, 104, SEEK_SET);\n    imgdata.lens.makernotes.MaxAp4CurFocal = powf64(2.0f, ((float)get4()) / 16.0f);\n    fseek(ifp, 124, SEEK_SET);\n    stmread(imgdata.lens.makernotes.Lens, 32, ifp);\n    imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_Contax_N;\n    if (imgdata.lens.makernotes.Lens[0])\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_Contax_N;\n#endif\n  }\n  else if (!strcmp(head, \"PXN\"))\n  {\n    strcpy(make, \"Logitech\");\n    strcpy(model, \"Fotoman Pixtura\");\n  }\n  else if (!strcmp(head, \"qktk\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 100\");\n    load_raw = &CLASS quicktake_100_load_raw;\n  }\n  else if (!strcmp(head, \"qktn\"))\n  {\n    strcpy(make, \"Apple\");\n    strcpy(model, \"QuickTake 150\");\n    load_raw = &CLASS kodak_radc_load_raw;\n  }\n  else if (!memcmp(head, \"FUJIFILM\", 8))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    strcpy(model, head + 0x1c);\n    memcpy(model2, head + 0x3c, 4);\n    model2[4] = 0;\n#endif\n    fseek(ifp, 84, SEEK_SET);\n    thumb_offset = get4();\n    thumb_length = get4();\n    fseek(ifp, 92, SEEK_SET);\n    parse_fuji(get4());\n    if (thumb_offset > 120)\n    {\n      fseek(ifp, 120, SEEK_SET);\n      is_raw += (i = get4()) ? 1 : 0;\n      if (is_raw == 2 && shot_select)\n        parse_fuji(i);\n    }\n    load_raw = &CLASS unpacked_load_raw;\n    fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);\n    parse_tiff(data_offset = get4());\n    parse_tiff(thumb_offset + 12);\n    apply_tiff();\n  }\n  else if (!memcmp(head, \"RIFF\", 4))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_riff();\n  }\n  else if (!memcmp(head + 4, \"ftypqt   \", 9))\n  {\n    fseek(ifp, 0, SEEK_SET);\n    parse_qt(fsize);\n    is_raw = 0;\n  }\n  else if (!memcmp(head, \"\\0\\001\\0\\001\\0@\", 6))\n  {\n    fseek(ifp, 6, SEEK_SET);\n    fread(make, 1, 8, ifp);\n    fread(model, 1, 8, ifp);\n    fread(model2, 1, 16, ifp);\n    data_offset = get2();\n    get2();\n    raw_width = get2();\n    raw_height = get2();\n    load_raw = &CLASS nokia_load_raw;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"NOKIARAW\", 8))\n  {\n    strcpy(make, \"NOKIA\");\n    order = 0x4949;\n    fseek(ifp, 300, SEEK_SET);\n    data_offset = get4();\n    i = get4();\n    width = get2();\n    height = get2();\n    switch (tiff_bps = i * 8 / (width * height))\n    {\n    case 8:\n      load_raw = &CLASS eight_bit_load_raw;\n      break;\n    case 10:\n      load_raw = &CLASS nokia_load_raw;\n    }\n    raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);\n    mask[0][3] = 1;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"ARRI\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 20, SEEK_SET);\n    width = get4();\n    height = get4();\n    strcpy(make, \"ARRI\");\n    fseek(ifp, 668, SEEK_SET);\n    fread(model, 1, 64, ifp);\n    data_offset = 4096;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 88;\n    filters = 0x61616161;\n  }\n  else if (!memcmp(head, \"XPDS\", 4))\n  {\n    order = 0x4949;\n    fseek(ifp, 0x800, SEEK_SET);\n    fread(make, 1, 41, ifp);\n    raw_height = get2();\n    raw_width = get2();\n    fseek(ifp, 56, SEEK_CUR);\n    fread(model, 1, 30, ifp);\n    data_offset = 0x10000;\n    load_raw = &CLASS canon_rmf_load_raw;\n    gamma_curve(0, 12.25, 1, 1023);\n  }\n  else if (!memcmp(head + 4, \"RED1\", 4))\n  {\n    strcpy(make, \"Red\");\n    strcpy(model, \"One\");\n    parse_redcine();\n    load_raw = &CLASS redcine_load_raw;\n    gamma_curve(1 / 2.4, 12.92, 1, 4095);\n    filters = 0x49494949;\n  }\n  else if (!memcmp(head, \"DSC-Image\", 9))\n    parse_rollei();\n  else if (!memcmp(head, \"PWAD\", 4))\n    parse_sinar_ia();\n  else if (!memcmp(head, \"\\0MRM\", 4))\n    parse_minolta(0);\n  else if (!memcmp(head, \"FOVb\", 4))\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      parse_foveon();\n    else\n#endif\n      parse_x3f();\n#else\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    parse_foveon();\n#endif\n#endif\n  }\n  else if (!memcmp(head, \"CI\", 2))\n    parse_cine();\n  if (make[0] == 0)\n#ifdef LIBRAW_LIBRARY_BUILD\n    for (zero_fsize = i = 0; i < camera_count; i++)\n#else\n    for (zero_fsize = i = 0; i < sizeof table / sizeof *table; i++)\n#endif\n      if (fsize == table[i].fsize)\n      {\n        strcpy(make, table[i].t_make);\n#ifdef LIBRAW_LIBRARY_BUILD\n        if (!strncmp(make, \"Canon\", 5))\n        {\n          imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n          imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n        }\n#endif\n        strcpy(model, table[i].t_model);\n        flip = table[i].flags >> 2;\n        zero_is_bad = table[i].flags & 2;\n        if (table[i].flags & 1)\n          parse_external_jpeg();\n        data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;\n        raw_width = table[i].rw;\n        raw_height = table[i].rh;\n        left_margin = table[i].lm;\n        top_margin = table[i].tm;\n        width = raw_width - left_margin - table[i].rm;\n        height = raw_height - top_margin - table[i].bm;\n        filters = 0x1010101 * table[i].cf;\n        colors = 4 - !((filters & filters >> 1) & 0x5555);\n        load_flags = table[i].lf;\n        switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))\n        {\n        case 6:\n          load_raw = &CLASS minolta_rd175_load_raw;\n          break;\n        case 8:\n          load_raw = &CLASS eight_bit_load_raw;\n          break;\n        case 10:\n          if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)\n          {\n            load_raw = &CLASS android_loose_load_raw;\n            break;\n          }\n          else if (load_flags & 1)\n          {\n            load_raw = &CLASS android_tight_load_raw;\n            break;\n          }\n        case 12:\n          load_flags |= 128;\n          load_raw = &CLASS packed_load_raw;\n          break;\n        case 16:\n          order = 0x4949 | 0x404 * (load_flags & 1);\n          tiff_bps -= load_flags >> 4;\n          tiff_bps -= load_flags = load_flags >> 1 & 7;\n          load_raw = table[i].offset == 0xffff ? &CLASS unpacked_load_raw_reversed : &CLASS unpacked_load_raw;\n        }\n        maximum = (1 << tiff_bps) - (1 << table[i].max);\n      }\n  if (zero_fsize)\n    fsize = 0;\n  if (make[0] == 0)\n    parse_smal(0, flen);\n  if (make[0] == 0)\n  {\n    parse_jpeg(0);\n    fseek(ifp, 0, SEEK_END);\n    int sz = ftell(ifp);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!strncmp(model, \"RP_imx219\", 9) && sz >= 0x9cb600 && !fseek(ifp, -0x9cb600, SEEK_END) &&\n        fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      strcpy(model, \"RPi IMX219\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 66;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x9cb600 - 1;\n    }\n    else if (!(strncmp(model, \"ov5647\", 6) && strncmp(model, \"RP_OV5647\", 9)) && sz >= 0x61b800 &&\n             !fseek(ifp, -0x61b800, SEEK_END) && fread(head, 1, 0x20, ifp) && !strncmp(head, \"BRCM\", 4))\n    {\n      strcpy(make, \"Broadcom\");\n      if (!strncmp(model, \"ov5647\", 6))\n        strcpy(model, \"RPi OV5647 v.1\");\n      else\n        strcpy(model, \"RPi OV5647 v.2\");\n      if (raw_height > raw_width)\n        flip = 5;\n      data_offset = ftell(ifp) + 0x8000 - 0x20;\n      parse_broadcom();\n      black = 16;\n      maximum = 0x3ff;\n      load_raw = &CLASS broadcom_load_raw;\n      thumb_offset = 0;\n      thumb_length = sz - 0x61b800 - 1;\n#else\n    if (!(strncmp(model, \"ov\", 2) && strncmp(model, \"RP_OV\", 5)) && sz >= 6404096 && !fseek(ifp, -6404096, SEEK_END) &&\n        fread(head, 1, 32, ifp) && !strcmp(head, \"BRCMn\"))\n    {\n      strcpy(make, \"OmniVision\");\n      data_offset = ftell(ifp) + 0x8000 - 32;\n      width = raw_width;\n      raw_width = 2611;\n      load_raw = &CLASS nokia_load_raw;\n      filters = 0x16161616;\n#endif\n    }\n    else\n      is_raw = 0;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  // make sure strings are terminated\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n#endif\n  for (i = 0; i < sizeof corp / sizeof *corp; i++)\n    if (strcasestr(make, corp[i])) /* Simplify company names */\n      strcpy(make, corp[i]);\n  if ((!strncmp(make, \"Kodak\", 5) || !strncmp(make, \"Leica\", 5)) &&\n      ((cp = strcasestr(model, \" DIGITAL CAMERA\")) || (cp = strstr(model, \"FILE VERSION\"))))\n    *cp = 0;\n  if (!strncasecmp(model, \"PENTAX\", 6))\n    strcpy(make, \"Pentax\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  remove_trailing_spaces(make, sizeof(make));\n  remove_trailing_spaces(model, sizeof(model));\n#else\n  cp = make + strlen(make); /* Remove trailing spaces */\n  while (*--cp == ' ')\n    *cp = 0;\n  cp = model + strlen(model);\n  while (*--cp == ' ')\n    *cp = 0;\n#endif\n  i = strbuflen(make); /* Remove make from model */\n  if (!strncasecmp(model, make, i) && model[i++] == ' ')\n    memmove(model, model + i, 64 - i);\n  if (!strncmp(model, \"FinePix \", 8))\n    strcpy(model, model + 8);\n  if (!strncmp(model, \"Digital Camera \", 15))\n    strcpy(model, model + 15);\n  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;\n  if (!is_raw)\n    goto notraw;\n\n  if (!height)\n    height = raw_height;\n  if (!width)\n    width = raw_width;\n  if (height == 2624 && width == 3936) /* Pentax K10D and Samsung GX10 */\n  {\n    height = 2616;\n    width = 3896;\n  }\n  if (height == 3136 && width == 4864) /* Pentax K20D and Samsung GX20 */\n  {\n    height = 3124;\n    width = 4688;\n    filters = 0x16161616;\n  }\n  if (width == 4352 && (!strcmp(model, \"K-r\") || !strcmp(model, \"K-x\")))\n  {\n    width = 4309;\n    filters = 0x16161616;\n  }\n  if (width >= 4960 && !strncmp(model, \"K-5\", 3))\n  {\n    left_margin = 10;\n    width = 4950;\n    filters = 0x16161616;\n  }\n  if (width == 6080 && !strcmp(model, \"K-70\"))\n  {\n    height = 4016;\n    top_margin = 32;\n    width = 6020;\n    left_margin = 60;\n  }\n  if (width == 4736 && !strcmp(model, \"K-7\"))\n  {\n    height = 3122;\n    width = 4684;\n    filters = 0x16161616;\n    top_margin = 2;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3 II\")) /* moved back */\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 6080 && !strcmp(model, \"K-3\"))\n  {\n    left_margin = 4;\n    width = 6040;\n  }\n  if (width == 7424 && !strcmp(model, \"645D\"))\n  {\n    height = 5502;\n    width = 7328;\n    filters = 0x61616161;\n    top_margin = 29;\n    left_margin = 48;\n  }\n  if (height == 3014 && width == 4096) /* Ricoh GX200 */\n    width = 4014;\n  if (dng_version)\n  {\n    if (filters == UINT_MAX)\n      filters = 0;\n    if (filters)\n      is_raw *= tiff_samples;\n    else\n      colors = tiff_samples;\n    switch (tiff_compress)\n    {\n    case 0: /* Compression not set, assuming uncompressed */\n    case 1:\n      load_raw = &CLASS packed_dng_load_raw;\n      break;\n    case 7:\n      load_raw = &CLASS lossless_dng_load_raw;\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 8:\n      load_raw = &CLASS deflate_dng_load_raw;\n      break;\n#endif\n    case 34892:\n      load_raw = &CLASS lossy_dng_load_raw;\n      break;\n    default:\n      load_raw = 0;\n    }\n    if (!strncmp(make, \"Canon\", 5) && unique_id)\n    {\n      for (i = 0; i < sizeof unique / sizeof *unique; i++)\n        if (unique_id == 0x80000000 + unique[i].id)\n        {\n          strcpy(model, unique[i].t_model);\n          break;\n        }\n    }\n    if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n    {\n      for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n        if (unique_id == sonique[i].id)\n        {\n          strcpy(model, sonique[i].t_model);\n          break;\n        }\n    }\n    goto dng_skip;\n  }\n  if (!strncmp(make, \"Canon\", 5) && !fsize && tiff_bps != 15)\n  {\n    if (!load_raw)\n      load_raw = &CLASS lossless_jpeg_load_raw;\n    for (i = 0; i < sizeof canon / sizeof *canon; i++)\n      if (raw_width == canon[i][0] && raw_height == canon[i][1])\n      {\n        width = raw_width - (left_margin = canon[i][2]);\n        height = raw_height - (top_margin = canon[i][3]);\n        width -= canon[i][4];\n        height -= canon[i][5];\n        mask[0][1] = canon[i][6];\n        mask[0][3] = -canon[i][7];\n        mask[1][1] = canon[i][8];\n        mask[1][3] = -canon[i][9];\n        if (canon[i][10])\n          filters = canon[i][10] * 0x01010101;\n      }\n    if ((unique_id | 0x20000) == 0x2720000)\n    {\n      left_margin = 8;\n      top_margin = 16;\n    }\n  }\n  if (!strncmp(make, \"Canon\", 5) && unique_id)\n  {\n    for (i = 0; i < sizeof unique / sizeof *unique; i++)\n      if (unique_id == 0x80000000 + unique[i].id)\n      {\n        adobe_coeff(\"Canon\", unique[i].t_model);\n        strcpy(model, unique[i].t_model);\n      }\n  }\n\n  if (!strncasecmp(make, \"Sony\", 4) && unique_id)\n  {\n    for (i = 0; i < sizeof sonique / sizeof *sonique; i++)\n      if (unique_id == sonique[i].id)\n      {\n        adobe_coeff(\"Sony\", sonique[i].t_model);\n        strcpy(model, sonique[i].t_model);\n      }\n  }\n\n  if (!strncmp(make, \"Nikon\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS packed_load_raw;\n    if (model[0] == 'E')\n      load_flags |= !data_offset << 2 | 2;\n  }\n\n  /* Set parameters based on camera name (for non-DNG files). */\n\n  if (!strcmp(model, \"KAI-0340\") && find_green(16, 16, 3840, 5120) < 25)\n  {\n    height = 480;\n    top_margin = filters = 0;\n    strcpy(model, \"C603\");\n  }\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = 128 << (tiff_bps - 12);\n#else\n  /* Always 512 for arw2_load_raw */\n  if (!strcmp(make, \"Sony\") && raw_width > 3888 && !black && !cblack[0])\n    black = (load_raw == &LibRaw::sony_arw2_load_raw) ? 512 : (128 << (tiff_bps - 12));\n#endif\n\n  if (is_foveon)\n  {\n    if (height * 2 < width)\n      pixel_aspect = 0.5;\n    if (height > width)\n      pixel_aspect = 2;\n    filters = 0;\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n    if (!(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F))\n      simple_coeff(0);\n#endif\n  }\n  else if (!strncmp(make, \"Pentax\", 6))\n  {\n    if (!strncmp(model, \"K-1\", 3))\n    {\n      top_margin = 18;\n      height = raw_height - top_margin;\n      if (raw_width == 7392)\n      {\n        left_margin = 6;\n        width = 7376;\n      }\n    }\n  }\n  else if (!strncmp(make, \"Canon\", 5) && tiff_bps == 15)\n  {\n    switch (width)\n    {\n    case 3344:\n      width -= 66;\n    case 3872:\n      width -= 6;\n    }\n    if (height > width)\n    {\n      SWAP(height, width);\n      SWAP(raw_height, raw_width);\n    }\n    if (width == 7200 && height == 3888)\n    {\n      raw_width = width = 6480;\n      raw_height = height = 4320;\n    }\n    filters = 0;\n    tiff_samples = colors = 3;\n    load_raw = &CLASS canon_sraw_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot 600\"))\n  {\n    height = 613;\n    width = 854;\n    raw_width = 896;\n    colors = 4;\n    filters = 0xe1e4e1e4;\n    load_raw = &CLASS canon_600_load_raw;\n  }\n  else if (!strcmp(model, \"PowerShot A5\") || !strcmp(model, \"PowerShot A5 Zoom\"))\n  {\n    height = 773;\n    width = 960;\n    raw_width = 992;\n    pixel_aspect = 256 / 235.0;\n    filters = 0x1e4e1e4e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot A50\"))\n  {\n    height = 968;\n    width = 1290;\n    raw_width = 1320;\n    filters = 0x1b4e4b1e;\n    goto canon_a5;\n  }\n  else if (!strcmp(model, \"PowerShot Pro70\"))\n  {\n    height = 1024;\n    width = 1552;\n    filters = 0x1e4b4e1b;\n  canon_a5:\n    colors = 4;\n    tiff_bps = 10;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 40;\n  }\n  else if (!strcmp(model, \"PowerShot Pro90 IS\") || !strcmp(model, \"PowerShot G1\"))\n  {\n    colors = 4;\n    filters = 0xb4b4b4b4;\n  }\n  else if (!strcmp(model, \"PowerShot A610\"))\n  {\n    if (canon_s2is())\n      strcpy(model + 10, \"S2 IS\");\n  }\n  else if (!strcmp(model, \"PowerShot SX220 HS\"))\n  {\n    mask[1][3] = -4;\n    top_margin = 16;\n    left_margin = 92;\n  }\n  else if (!strcmp(model, \"PowerShot S120\"))\n  {\n    raw_width = 4192;\n    raw_height = 3062;\n    width = 4022;\n    height = 3016;\n    mask[0][0] = top_margin = 31;\n    mask[0][2] = top_margin + height;\n    left_margin = 120;\n    mask[0][1] = 23;\n    mask[0][3] = 72;\n  }\n  else if (!strcmp(model, \"PowerShot G16\"))\n  {\n    mask[0][0] = 0;\n    mask[0][2] = 80;\n    mask[0][1] = 0;\n    mask[0][3] = 16;\n    top_margin = 29;\n    left_margin = 120;\n    width = raw_width - left_margin - 48;\n    height = raw_height - top_margin - 14;\n  }\n  else if (!strcmp(model, \"PowerShot SX50 HS\"))\n  {\n    top_margin = 17;\n  }\n  else if (!strcmp(model, \"EOS D2000C\"))\n  {\n    filters = 0x61616161;\n    if (!black)\n      black = curve[200];\n  }\n  else if (!strcmp(model, \"D1\"))\n  {\n    cam_mul[0] *= 256 / 527.0;\n    cam_mul[2] *= 256 / 317.0;\n  }\n  else if (!strcmp(model, \"D1X\"))\n  {\n    width -= 4;\n    pixel_aspect = 0.5;\n  }\n  else if (!strcmp(model, \"D40X\") || !strcmp(model, \"D60\") || !strcmp(model, \"D80\") || !strcmp(model, \"D3000\"))\n  {\n    height -= 3;\n    width -= 4;\n  }\n  else if (!strcmp(model, \"D3\") || !strcmp(model, \"D3S\") || !strcmp(model, \"D700\"))\n  {\n    width -= 4;\n    left_margin = 2;\n  }\n  else if (!strcmp(model, \"D3100\"))\n  {\n    width -= 28;\n    left_margin = 6;\n  }\n  else if (!strcmp(model, \"D5000\") || !strcmp(model, \"D90\"))\n  {\n    width -= 42;\n  }\n  else if (!strcmp(model, \"D5100\") || !strcmp(model, \"D7000\") || !strcmp(model, \"COOLPIX A\"))\n  {\n    width -= 44;\n  }\n  else if (!strcmp(model, \"D3200\") || !strncmp(model, \"D6\", 2) || !strncmp(model, \"D800\", 4))\n  {\n    width -= 46;\n  }\n  else if (!strcmp(model, \"D4\") || !strcmp(model, \"Df\"))\n  {\n    width -= 52;\n    left_margin = 2;\n  }\n  else if (!strncmp(model, \"D40\", 3) || !strncmp(model, \"D50\", 3) || !strncmp(model, \"D70\", 3))\n  {\n    width--;\n  }\n  else if (!strcmp(model, \"D100\"))\n  {\n    if (load_flags)\n      raw_width = (width += 3) + 3;\n  }\n  else if (!strcmp(model, \"D200\"))\n  {\n    left_margin = 1;\n    width -= 4;\n    filters = 0x94949494;\n  }\n  else if (!strncmp(model, \"D2H\", 3))\n  {\n    left_margin = 6;\n    width -= 14;\n  }\n  else if (!strncmp(model, \"D2X\", 3))\n  {\n    if (width == 3264)\n      width -= 32;\n    else\n      width -= 8;\n  }\n  else if (!strncmp(model, \"D300\", 4))\n  {\n    width -= 32;\n  }\n  else if (!strncmp(make, \"Nikon\", 5) && raw_width == 4032)\n  {\n    if (!strcmp(model, \"COOLPIX P7700\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7700\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P7800\"))\n    {\n      adobe_coeff(\"Nikon\", \"COOLPIX P7800\");\n      maximum = 65504;\n      load_flags = 0;\n    }\n    else if (!strcmp(model, \"COOLPIX P340\"))\n      load_flags = 0;\n  }\n  else if (!strncmp(model, \"COOLPIX P\", 9) && raw_width != 4032)\n  {\n    load_flags = 24;\n    filters = 0x94949494;\n    if (model[9] == '7' && (iso_speed >= 400 || iso_speed == 0) && !strstr(software, \"V1.2\"))\n      black = 255;\n  }\n  else if (!strncmp(model, \"COOLPIX B700\", 12))\n  {\n    load_flags = 24;\n    black = 200;\n  }\n  else if (!strncmp(model, \"1 \", 2))\n  {\n    height -= 2;\n  }\n  else if (fsize == 1581060)\n  {\n    simple_coeff(3);\n    pre_mul[0] = 1.2085;\n    pre_mul[1] = 1.0943;\n    pre_mul[3] = 1.1103;\n  }\n  else if (fsize == 3178560)\n  {\n    cam_mul[0] *= 4;\n    cam_mul[2] *= 4;\n  }\n  else if (fsize == 4771840)\n  {\n    if (!timestamp && nikon_e995())\n      strcpy(model, \"E995\");\n    if (strcmp(model, \"E995\"))\n    {\n      filters = 0xb4b4b4b4;\n      simple_coeff(3);\n      pre_mul[0] = 1.196;\n      pre_mul[1] = 1.246;\n      pre_mul[2] = 1.018;\n    }\n  }\n  else if (fsize == 2940928)\n  {\n    if (!timestamp && !nikon_e2100())\n      strcpy(model, \"E2500\");\n    if (!strcmp(model, \"E2500\"))\n    {\n      height -= 2;\n      load_flags = 6;\n      colors = 4;\n      filters = 0x4b4b4b4b;\n    }\n  }\n  else if (fsize == 4775936)\n  {\n    if (!timestamp)\n      nikon_3700();\n    if (model[0] == 'E' && atoi(model + 1) < 3700)\n      filters = 0x49494949;\n    if (!strcmp(model, \"Optio 33WR\"))\n    {\n      flip = 1;\n      filters = 0x16161616;\n    }\n    if (make[0] == 'O')\n    {\n      i = find_green(12, 32, 1188864, 3576832);\n      c = find_green(12, 32, 2383920, 2387016);\n      if (abs(i) < abs(c))\n      {\n        SWAP(i, c);\n        load_flags = 24;\n      }\n      if (i < 0)\n        filters = 0x61616161;\n    }\n  }\n  else if (fsize == 5869568)\n  {\n    if (!timestamp && minolta_z2())\n    {\n      strcpy(make, \"Minolta\");\n      strcpy(model, \"DiMAGE Z2\");\n    }\n    load_flags = 6 + 24 * (make[0] == 'M');\n  }\n  else if (fsize == 6291456)\n  {\n    fseek(ifp, 0x300000, SEEK_SET);\n    if ((order = guess_byte_order(0x10000)) == 0x4d4d)\n    {\n      height -= (top_margin = 16);\n      width -= (left_margin = 28);\n      maximum = 0xf5c0;\n      strcpy(make, \"ISG\");\n      model[0] = 0;\n    }\n  }\n  else if (!strncmp(make, \"Fujifilm\", 8))\n  {\n    if (!strcmp(model + 7, \"S2Pro\"))\n    {\n      strcpy(model, \"S2Pro\");\n      height = 2144;\n      width = 2880;\n      flip = 6;\n    }\n    else if (load_raw != &CLASS packed_load_raw)\n      maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;\n    top_margin = (raw_height - height) >> 2 << 1;\n    left_margin = (raw_width - width) >> 2 << 1;\n    if (width == 2848 || width == 3664)\n      filters = 0x16161616;\n    if (width == 4032 || width == 4952)\n      left_margin = 0;\n    if (width == 3328 && (width -= 66))\n      left_margin = 34;\n    if (width == 4936)\n      left_margin = 4;\n    if (width == 6032)\n      left_margin = 0;\n    if (!strcmp(model, \"HS50EXR\") || !strcmp(model, \"F900EXR\"))\n    {\n      width += 2;\n      left_margin = 0;\n      filters = 0x16161616;\n    }\n    if (!strcmp(model, \"GFX 50S\"))\n    {\n      left_margin = 0;\n      top_margin = 0;\n    }\n    if (!strcmp(model, \"S5500\"))\n    {\n      height -= (top_margin = 6);\n    }\n    if (fuji_layout)\n      raw_width *= is_raw;\n    if (filters == 9)\n      FORC(36)((char *)xtrans)[c] = xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];\n  }\n  else if (!strcmp(model, \"KD-400Z\"))\n  {\n    height = 1712;\n    width = 2312;\n    raw_width = 2336;\n    goto konica_400z;\n  }\n  else if (!strcmp(model, \"KD-510Z\"))\n  {\n    goto konica_510z;\n  }\n  else if (!strncasecmp(make, \"Minolta\", 7))\n  {\n    if (!load_raw && (maximum = 0xfff))\n      load_raw = &CLASS unpacked_load_raw;\n    if (!strncmp(model, \"DiMAGE A\", 8))\n    {\n      if (!strcmp(model, \"DiMAGE A200\"))\n        filters = 0x49494949;\n      tiff_bps = 12;\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"ALPHA\", 5) || !strncmp(model, \"DYNAX\", 5) || !strncmp(model, \"MAXXUM\", 6))\n    {\n      sprintf(model + 20, \"DYNAX %-10s\", model + 6 + (model[0] == 'M'));\n      adobe_coeff(make, model + 20);\n      load_raw = &CLASS packed_load_raw;\n    }\n    else if (!strncmp(model, \"DiMAGE G\", 8))\n    {\n      if (model[8] == '4')\n      {\n        height = 1716;\n        width = 2304;\n      }\n      else if (model[8] == '5')\n      {\n      konica_510z:\n        height = 1956;\n        width = 2607;\n        raw_width = 2624;\n      }\n      else if (model[8] == '6')\n      {\n        height = 2136;\n        width = 2848;\n      }\n      data_offset += 14;\n      filters = 0x61616161;\n    konica_400z:\n      load_raw = &CLASS unpacked_load_raw;\n      maximum = 0x3df;\n      order = 0x4d4d;\n    }\n  }\n  else if (!strcmp(model, \"*ist D\"))\n  {\n    load_raw = &CLASS unpacked_load_raw;\n    data_error = -1;\n  }\n  else if (!strcmp(model, \"*ist DS\"))\n  {\n    height -= 2;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 4704)\n  {\n    height -= top_margin = 8;\n    width -= 2 * (left_margin = 8);\n    load_flags = 32;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && !strcmp(model, \"NX3000\"))\n  {\n    top_margin = 24;\n    left_margin = 64;\n    width = 5472;\n    height = 3648;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_height == 3714)\n  {\n    height -= top_margin = 18;\n    left_margin = raw_width - (width = 5536);\n    if (raw_width != 5600)\n      left_margin = top_margin = 0;\n    filters = 0x61616161;\n    colors = 3;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5632)\n  {\n    order = 0x4949;\n    height = 3694;\n    top_margin = 2;\n    width = 5574 - (left_margin = 32 + tiff_bps);\n    if (tiff_bps == 12)\n      load_flags = 80;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 5664)\n  {\n    height -= top_margin = 17;\n    left_margin = 96;\n    width = 5544;\n    filters = 0x49494949;\n  }\n  else if (!strncmp(make, \"Samsung\", 7) && raw_width == 6496)\n  {\n    filters = 0x61616161;\n#ifdef LIBRAW_LIBRARY_BUILD\n    if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])\n#endif\n      black = 1 << (tiff_bps - 7);\n  }\n  else if (!strcmp(model, \"EX1\"))\n  {\n    order = 0x4949;\n    height -= 20;\n    top_margin = 2;\n    if ((width -= 6) > 3682)\n    {\n      height -= 10;\n      width -= 46;\n      top_margin = 8;\n    }\n  }\n  else if (!strcmp(model, \"WB2000\"))\n  {\n    order = 0x4949;\n    height -= 3;\n    top_margin = 2;\n    if ((width -= 10) > 3718)\n    {\n      height -= 28;\n      width -= 56;\n      top_margin = 8;\n    }\n  }\n  else if (strstr(model, \"WB550\"))\n  {\n    strcpy(model, \"WB550\");\n  }\n  else if (!strcmp(model, \"EX2F\"))\n  {\n    height = 3030;\n    width = 4040;\n    top_margin = 15;\n    left_margin = 24;\n    order = 0x4949;\n    filters = 0x49494949;\n    load_raw = &CLASS unpacked_load_raw;\n  }\n  else if (!strcmp(model, \"STV680 VGA\"))\n  {\n    black = 16;\n  }\n  else if (!strcmp(model, \"N95\"))\n  {\n    height = raw_height - (top_margin = 2);\n  }\n  else if (!strcmp(model, \"640x480\"))\n  {\n    gamma_curve(0.45, 4.5, 1, 255);\n  }\n  else if (!strncmp(make, \"Hasselblad\", 10))\n  {\n    if (load_raw == &CLASS lossless_jpeg_load_raw)\n      load_raw = &CLASS hasselblad_load_raw;\n    if (raw_width == 7262)\n    {\n      height = 5444;\n      width = 7248;\n      top_margin = 4;\n      left_margin = 7;\n      filters = 0x61616161;\n      if (!strncasecmp(model, \"H3D\", 3))\n      {\n        adobe_coeff(\"Hasselblad\", \"H3DII-39\");\n        strcpy(model, \"H3DII-39\");\n      }\n    }\n    else if (raw_width == 7410 || raw_width == 8282)\n    {\n      height -= 84;\n      width -= 82;\n      top_margin = 4;\n      left_margin = 41;\n      filters = 0x61616161;\n      adobe_coeff(\"Hasselblad\", \"H4D-40\");\n      strcpy(model, \"H4D-40\");\n    }\n    else if (raw_width == 8384) // X1D\n    {\n      top_margin = 96;\n      height -= 96;\n      left_margin = 48;\n      width -= 106;\n      adobe_coeff(\"Hasselblad\", \"X1D\");\n      maximum = 0xffff;\n      tiff_bps = 16;\n    }\n    else if (raw_width == 9044)\n    {\n      if (black > 500)\n      {\n        top_margin = 12;\n        left_margin = 44;\n        width = 8956;\n        height = 6708;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H4D-60\");\n        strcpy(model, \"H4D-60\");\n        black = 512;\n      }\n      else\n      {\n        height = 6716;\n        width = 8964;\n        top_margin = 8;\n        left_margin = 40;\n        black += load_flags = 256;\n        maximum = 0x8101;\n        strcpy(model, \"H3DII-60\");\n      }\n    }\n    else if (raw_width == 4090)\n    {\n      strcpy(model, \"V96C\");\n      height -= (top_margin = 6);\n      width -= (left_margin = 3) + 7;\n      filters = 0x61616161;\n    }\n    else if (raw_width == 8282 && raw_height == 6240)\n    {\n      if (!strncasecmp(model, \"H5D\", 3))\n      {\n        /* H5D 50*/\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        black = 256;\n        strcpy(model, \"H5D-50\");\n      }\n      else if (!strncasecmp(model, \"H3D\", 3))\n      {\n        black = 0;\n        left_margin = 54;\n        top_margin = 16;\n        width = 8176;\n        height = 6132;\n        memset(cblack, 0, sizeof(cblack));\n        adobe_coeff(\"Hasselblad\", \"H3D-50\");\n        strcpy(model, \"H3D-50\");\n      }\n    }\n    else if (raw_width == 8374 && raw_height == 6304)\n    {\n      /* H5D 50c*/\n      left_margin = 52;\n      top_margin = 100;\n      width = 8272;\n      height = 6200;\n      black = 256;\n      strcpy(model, \"H5D-50c\");\n    }\n    if (tiff_samples > 1)\n    {\n      is_raw = tiff_samples + 1;\n      if (!shot_select && !half_size)\n        filters = 0;\n    }\n  }\n  else if (!strncmp(make, \"Sinar\", 5))\n  {\n    if (!load_raw)\n      load_raw = &CLASS unpacked_load_raw;\n    if (is_raw > 1 && !shot_select && !half_size)\n      filters = 0;\n    maximum = 0x3fff;\n  }\n  else if (!strncmp(make, \"Leaf\", 4))\n  {\n    maximum = 0x3fff;\n    fseek(ifp, data_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1) && jh.bits == 15)\n      maximum = 0x1fff;\n    if (tiff_samples > 1)\n      filters = 0;\n    if (tiff_samples > 1 || tile_length < raw_height)\n    {\n      load_raw = &CLASS leaf_hdr_load_raw;\n      raw_width = tile_width;\n    }\n    if ((width | height) == 2048)\n    {\n      if (tiff_samples == 1)\n      {\n        filters = 1;\n        strcpy(cdesc, \"RBTG\");\n        strcpy(model, \"CatchLight\");\n        top_margin = 8;\n        left_margin = 18;\n        height = 2032;\n        width = 2016;\n      }\n      else\n      {\n        strcpy(model, \"DCB2\");\n        top_margin = 10;\n        left_margin = 16;\n        height = 2028;\n        width = 2022;\n      }\n    }\n    else if (width + height == 3144 + 2060)\n    {\n      if (!model[0])\n        strcpy(model, \"Cantare\");\n      if (width > height)\n      {\n        top_margin = 6;\n        left_margin = 32;\n        height = 2048;\n        width = 3072;\n        filters = 0x61616161;\n      }\n      else\n      {\n        left_margin = 6;\n        top_margin = 32;\n        width = 2048;\n        height = 3072;\n        filters = 0x16161616;\n      }\n      if (!cam_mul[0] || model[0] == 'V')\n        filters = 0;\n      else\n        is_raw = tiff_samples;\n    }\n    else if (width == 2116)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 30);\n      width -= 2 * (left_margin = 55);\n      filters = 0x49494949;\n    }\n    else if (width == 3171)\n    {\n      strcpy(model, \"Valeo 6\");\n      height -= 2 * (top_margin = 24);\n      width -= 2 * (left_margin = 24);\n      filters = 0x16161616;\n    }\n  }\n  else if (!strncmp(make, \"Leica\", 5) || !strncmp(make, \"Panasonic\", 9) || !strncasecmp(make, \"YUNEEC\", 6))\n  {\n    if (raw_width > 0 && ((flen - data_offset) / (raw_width * 8 / 7) == raw_height))\n      load_raw = &CLASS panasonic_load_raw;\n    if (!load_raw)\n    {\n      load_raw = &CLASS unpacked_load_raw;\n      load_flags = 4;\n    }\n    zero_is_bad = 1;\n    if ((height += 12) > raw_height)\n      height = raw_height;\n    for (i = 0; i < sizeof pana / sizeof *pana; i++)\n      if (raw_width == pana[i][0] && raw_height == pana[i][1])\n      {\n        left_margin = pana[i][2];\n        top_margin = pana[i][3];\n        width += pana[i][4];\n        height += pana[i][5];\n      }\n    filters = 0x01010101 * (uchar) \"\\x94\\x61\\x49\\x16\"[((filters - 1) ^ (left_margin & 1) ^ (top_margin << 1)) & 3];\n  }\n  else if (!strcmp(model, \"C770UZ\"))\n  {\n    height = 1718;\n    width = 2304;\n    filters = 0x16161616;\n    load_raw = &CLASS packed_load_raw;\n    load_flags = 30;\n  }\n  else if (!strncmp(make, \"Olympus\", 7))\n  {\n    height += height & 1;\n    if (exif_cfa)\n      filters = exif_cfa;\n    if (width == 4100)\n      width -= 4;\n    if (width == 4080)\n      width -= 24;\n    if (width == 9280)\n    {\n      width -= 6;\n      height -= 6;\n    }\n    if (load_raw == &CLASS unpacked_load_raw)\n      load_flags = 4;\n    tiff_bps = 12;\n    if (!strcmp(model, \"E-300\") || !strcmp(model, \"E-500\"))\n    {\n      width -= 20;\n      if (load_raw == &CLASS unpacked_load_raw)\n      {\n        maximum = 0xfc3;\n        memset(cblack, 0, sizeof cblack);\n      }\n    }\n    else if (!strcmp(model, \"STYLUS1\"))\n    {\n      width -= 14;\n      maximum = 0xfff;\n    }\n    else if (!strcmp(model, \"E-330\"))\n    {\n      width -= 30;\n      if (load_raw == &CLASS unpacked_load_raw)\n        maximum = 0xf79;\n    }\n    else if (!strcmp(model, \"SP550UZ\"))\n    {\n      thumb_length = flen - (thumb_offset = 0xa39800);\n      thumb_height = 480;\n      thumb_width = 640;\n    }\n    else if (!strcmp(model, \"TG-4\"))\n    {\n      width -= 16;\n    }\n  }\n  else if (!strcmp(model, \"N Digital\"))\n  {\n    height = 2047;\n    width = 3072;\n    filters = 0x61616161;\n    data_offset = 0x1a00;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strcmp(model, \"DSC-F828\"))\n  {\n    width = 3288;\n    left_margin = 5;\n    mask[1][3] = -17;\n    data_offset = 862144;\n    load_raw = &CLASS sony_load_raw;\n    filters = 0x9c9c9c9c;\n    colors = 4;\n    strcpy(cdesc, \"RGBE\");\n  }\n  else if (!strcmp(model, \"DSC-V3\"))\n  {\n    width = 3109;\n    left_margin = 59;\n    mask[0][1] = 9;\n    data_offset = 787392;\n    load_raw = &CLASS sony_load_raw;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 3984)\n  {\n    width = 3925;\n    order = 0x4d4d;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4288)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(make, \"Sony\") && raw_width == 4600)\n  {\n    if (!strcmp(model, \"DSLR-A350\"))\n      height -= 4;\n    black = 0;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 4928)\n  {\n    if (height < 3280)\n      width -= 8;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 5504)\n  { // ILCE-3000//5000\n    width -= height > 3664 ? 8 : 32;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 6048)\n  {\n    width -= 24;\n    if (strstr(model, \"RX1\") || strstr(model, \"A99\"))\n      width -= 6;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 7392)\n  {\n    width -= 30;\n  }\n  else if (!strncmp(make, \"Sony\", 4) && raw_width == 8000)\n  {\n    width -= 32;\n  }\n  else if (!strcmp(model, \"DSLR-A100\"))\n  {\n    if (width == 3880)\n    {\n      height--;\n      width = ++raw_width;\n    }\n    else\n    {\n      height -= 4;\n      width -= 4;\n      order = 0x4d4d;\n      load_flags = 2;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strcmp(model, \"PIXL\"))\n  {\n    height -= top_margin = 4;\n    width -= left_margin = 32;\n    gamma_curve(0, 7, 1, 255);\n  }\n  else if (!strcmp(model, \"C603\") || !strcmp(model, \"C330\") || !strcmp(model, \"12MP\"))\n  {\n    order = 0x4949;\n    if (filters && data_offset)\n    {\n      fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);\n      read_shorts(curve, 256);\n    }\n    else\n      gamma_curve(0, 3.875, 1, 255);\n    load_raw = filters ? &CLASS eight_bit_load_raw\n                       : strcmp(model, \"C330\") ? &CLASS kodak_c603_load_raw : &CLASS kodak_c330_load_raw;\n    load_flags = tiff_bps > 16;\n    tiff_bps = 8;\n  }\n  else if (!strncasecmp(model, \"EasyShare\", 9))\n  {\n    data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;\n    load_raw = &CLASS packed_load_raw;\n  }\n  else if (!strncasecmp(make, \"Kodak\", 5))\n  {\n    if (filters == UINT_MAX)\n      filters = 0x61616161;\n    if (!strncmp(model, \"NC2000\", 6) || !strncmp(model, \"EOSDCS\", 6) || !strncmp(model, \"DCS4\", 4))\n    {\n      width -= 4;\n      left_margin = 2;\n      if (model[6] == ' ')\n        model[6] = 0;\n      if (!strcmp(model, \"DCS460A\"))\n        goto bw;\n    }\n    else if (!strcmp(model, \"DCS660M\"))\n    {\n      black = 214;\n      goto bw;\n    }\n    else if (!strcmp(model, \"DCS760M\"))\n    {\n    bw:\n      colors = 1;\n      filters = 0;\n    }\n    if (!strcmp(model + 4, \"20X\"))\n      strcpy(cdesc, \"MYCY\");\n    if (strstr(model, \"DC25\"))\n    {\n      strcpy(model, \"DC25\");\n      data_offset = 15424;\n    }\n    if (!strncmp(model, \"DC2\", 3))\n    {\n      raw_height = 2 + (height = 242);\n      if (!strncmp(model, \"DC290\", 5))\n        iso_speed = 100;\n      if (!strncmp(model, \"DC280\", 5))\n        iso_speed = 70;\n      if (flen < 100000)\n      {\n        raw_width = 256;\n        width = 249;\n        pixel_aspect = (4.0 * height) / (3.0 * width);\n      }\n      else\n      {\n        raw_width = 512;\n        width = 501;\n        pixel_aspect = (493.0 * height) / (373.0 * width);\n      }\n      top_margin = left_margin = 1;\n      colors = 4;\n      filters = 0x8d8d8d8d;\n      simple_coeff(1);\n      pre_mul[1] = 1.179;\n      pre_mul[2] = 1.209;\n      pre_mul[3] = 1.036;\n      load_raw = &CLASS eight_bit_load_raw;\n    }\n    else if (!strcmp(model, \"40\"))\n    {\n      strcpy(model, \"DC40\");\n      height = 512;\n      width = 768;\n      data_offset = 1152;\n      load_raw = &CLASS kodak_radc_load_raw;\n      tiff_bps = 12;\n    }\n    else if (strstr(model, \"DC50\"))\n    {\n      strcpy(model, \"DC50\");\n      height = 512;\n      width = 768;\n      iso_speed = 84;\n      data_offset = 19712;\n      load_raw = &CLASS kodak_radc_load_raw;\n    }\n    else if (strstr(model, \"DC120\"))\n    {\n      strcpy(model, \"DC120\");\n      raw_height = height = 976;\n      raw_width = width = 848;\n      iso_speed = 160;\n      pixel_aspect = height / 0.75 / width;\n      load_raw = tiff_compress == 7 ? &CLASS kodak_jpeg_load_raw : &CLASS kodak_dc120_load_raw;\n    }\n    else if (!strcmp(model, \"DCS200\"))\n    {\n      thumb_height = 128;\n      thumb_width = 192;\n      thumb_offset = 6144;\n      thumb_misc = 360;\n      iso_speed = 140;\n      write_thumb = &CLASS layer_thumb;\n      black = 17;\n    }\n  }\n  else if (!strcmp(model, \"Fotoman Pixtura\"))\n  {\n    height = 512;\n    width = 768;\n    data_offset = 3632;\n    load_raw = &CLASS kodak_radc_load_raw;\n    filters = 0x61616161;\n    simple_coeff(2);\n  }\n  else if (!strncmp(model, \"QuickTake\", 9))\n  {\n    if (head[5])\n      strcpy(model + 10, \"200\");\n    fseek(ifp, 544, SEEK_SET);\n    height = get2();\n    width = get2();\n    data_offset = (get4(), get2()) == 30 ? 738 : 736;\n    if (height > width)\n    {\n      SWAP(height, width);\n      fseek(ifp, data_offset - 6, SEEK_SET);\n      flip = ~get2() & 3 ? 5 : 6;\n    }\n    filters = 0x61616161;\n  }\n  else if (!strncmp(make, \"Rollei\", 6) && !load_raw)\n  {\n    switch (raw_width)\n    {\n    case 1316:\n      height = 1030;\n      width = 1300;\n      top_margin = 1;\n      left_margin = 6;\n      break;\n    case 2568:\n      height = 1960;\n      width = 2560;\n      top_margin = 2;\n      left_margin = 8;\n    }\n    filters = 0x16161616;\n    load_raw = &CLASS rollei_load_raw;\n  }\n  else if (!strcmp(model, \"GRAS-50S5C\"))\n  {\n    height = 2048;\n    width = 2440;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x49494949;\n    order = 0x4949;\n    maximum = 0xfffC;\n  }\n  else if (!strcmp(model, \"BB-500CL\"))\n  {\n    height = 2058;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"BB-500GE\"))\n  {\n    height = 2058;\n    width = 2456;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x3fff;\n  }\n  else if (!strcmp(model, \"SVS625CL\"))\n  {\n    height = 2050;\n    width = 2448;\n    load_raw = &CLASS unpacked_load_raw;\n    data_offset = 0;\n    filters = 0x94949494;\n    order = 0x4949;\n    maximum = 0x0fff;\n  }\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if (!model[0])\n    sprintf(model, \"%dx%d\", width, height);\n  if (filters == UINT_MAX)\n    filters = 0x94949494;\n  if (thumb_offset && !thumb_height)\n  {\n    fseek(ifp, thumb_offset, SEEK_SET);\n    if (ljpeg_start(&jh, 1))\n    {\n      thumb_width = jh.wide;\n      thumb_height = jh.high;\n    }\n  }\n\ndng_skip:\n#ifdef LIBRAW_LIBRARY_BUILD\n  if (dng_version) /* Override black level by DNG tags */\n  {\n    /* copy DNG data from per-IFD field to color.dng */\n    int iifd = 0;\n    for (; iifd < tiff_nifds; iifd++)\n      if (tiff_ifd[iifd].offset == data_offset) // found\n        break;\n\n    if (iifd < tiff_nifds)\n    {\n      memmove(&imgdata.color.dng_color[0], &tiff_ifd[iifd].dng_color[0], sizeof(tiff_ifd[iifd].dng_color[0]));\n      memmove(&imgdata.color.dng_color[1], &tiff_ifd[iifd].dng_color[1], sizeof(tiff_ifd[iifd].dng_color[1]));\n      memmove(&imgdata.color.dng_levels, &tiff_ifd[iifd].dng_levels, sizeof(tiff_ifd[iifd].dng_levels));\n      meta_offset = tiff_ifd[iifd].opcode2_offset;\n      if (tiff_ifd[iifd].lineartable_offset && tiff_ifd[iifd].lineartable_len)\n      {\n        INT64 pos = ftell(ifp);\n        fseek(ifp, tiff_ifd[iifd].lineartable_offset, SEEK_SET);\n        linear_table(tiff_ifd[iifd].lineartable_len);\n        fseek(ifp, pos, SEEK_SET);\n      }\n      // Need to add curve too\n    }\n    /* Copy DNG black level to  */\n    maximum = imgdata.color.dng_levels.dng_whitelevel[0];\n    black = imgdata.color.dng_levels.dng_black;\n    int ll = LIM(0, (sizeof(cblack) / sizeof(cblack[0])),\n                 (sizeof(imgdata.color.dng_levels.dng_cblack) / sizeof(imgdata.color.dng_levels.dng_cblack[0])));\n    for (int i = 0; i < ll; i++)\n      cblack[i] = imgdata.color.dng_levels.dng_cblack[i];\n  }\n#endif\n  /* Early reject for damaged images */\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 4 || colors > 4 || colors < 1)\n  {\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n    return;\n  }\n  if ((use_camera_matrix & ((use_camera_wb || dng_version) | 0x2)) && cmatrix[0][0] > 0.125)\n  {\n    memcpy(rgb_cam, cmatrix, sizeof cmatrix);\n    raw_color = 0;\n  }\n\n  if (raw_color)\n    adobe_coeff(make, model);\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if (imgdata.color.cam_xyz[0][0] < 0.01)\n    adobe_coeff(make, model, 1);\n#endif\n\n  if (load_raw == &CLASS kodak_radc_load_raw)\n    if (raw_color)\n      adobe_coeff(\"Apple\", \"Quicktake\");\n\n  if (fuji_width)\n  {\n    fuji_width = width >> !fuji_layout;\n    filters = fuji_width & 1 ? 0x94949494 : 0x49494949;\n    width = (height >> fuji_layout) + fuji_width;\n    height = width - 1;\n    pixel_aspect = 1;\n  }\n  else\n  {\n    if (raw_height < height)\n      raw_height = height;\n    if (raw_width < width)\n      raw_width = width;\n  }\n  if (!tiff_bps)\n    tiff_bps = 12;\n  if (!maximum)\n  {\n    maximum = (1 << tiff_bps) - 1;\n    if (maximum < 0x10000 && curve[maximum] > 0 && load_raw == &CLASS sony_arw2_load_raw)\n      maximum = curve[maximum];\n  }\n  if (!load_raw || height < 22 || width < 22 ||\n#ifdef LIBRAW_LIBRARY_BUILD\n      (tiff_bps > 16 && load_raw != &LibRaw::deflate_dng_load_raw)\n#else\n      tiff_bps > 16\n#endif\n      || tiff_samples > 6 || colors > 4)\n    is_raw = 0;\n\n  if (raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_width > 64000)\n    is_raw = 0;\n\n#ifdef NO_JASPER\n  if (load_raw == &CLASS redcine_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjasper\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JASPER;\n#endif\n  }\n#endif\n#ifdef NO_JPEG\n  if (load_raw == &CLASS kodak_jpeg_load_raw || load_raw == &CLASS lossy_dng_load_raw)\n  {\n#ifdef DCRAW_VERBOSE\n    fprintf(stderr, _(\"%s: You must link dcraw with %s!!\\n\"), ifname, \"libjpeg\");\n#endif\n    is_raw = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n    imgdata.process_warnings |= LIBRAW_WARN_NO_JPEGLIB;\n#endif\n  }\n#endif\n  if (!cdesc[0])\n    strcpy(cdesc, colors == 3 ? \"RGBG\" : \"GMCY\");\n  if (!raw_height)\n    raw_height = height;\n  if (!raw_width)\n    raw_width = width;\n  if (filters > 999 && colors == 3)\n    filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) & filters << 1;\nnotraw:\n  if (flip == UINT_MAX)\n    flip = tiff_flip;\n  if (flip == UINT_MAX)\n    flip = 0;\n\n  // Convert from degrees to bit-field if needed\n  if (flip > 89 || flip < -89)\n  {\n    switch ((flip + 3600) % 360)\n    {\n    case 270:\n      flip = 5;\n      break;\n    case 180:\n      flip = 3;\n      break;\n    case 90:\n      flip = 6;\n      break;\n    }\n  }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);\n#endif\n}\n\nvoid CLASS convert_to_rgb()\n{\n#ifndef LIBRAW_LIBRARY_BUILD\n  int row, col, c;\n#endif\n  int i, j, k;\n#ifndef LIBRAW_LIBRARY_BUILD\n  ushort *img;\n  float out[3];\n#endif\n  float out_cam[3][4];\n  double num, inverse[3][3];\n  static const double xyzd50_srgb[3][3] = {\n      {0.436083, 0.385083, 0.143055}, {0.222507, 0.716888, 0.060608}, {0.013930, 0.097097, 0.714022}};\n  static const double rgb_rgb[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  static const double adobe_rgb[3][3] = {\n      {0.715146, 0.284856, 0.000000}, {0.000000, 1.000000, 0.000000}, {0.000000, 0.041166, 0.958839}};\n  static const double wide_rgb[3][3] = {\n      {0.593087, 0.404710, 0.002206}, {0.095413, 0.843149, 0.061439}, {0.011621, 0.069091, 0.919288}};\n  static const double prophoto_rgb[3][3] = {\n      {0.529317, 0.330092, 0.140588}, {0.098368, 0.873465, 0.028169}, {0.016879, 0.117663, 0.865457}};\n  static const double aces_rgb[3][3] = {\n      {0.432996, 0.375380, 0.189317}, {0.089427, 0.816523, 0.102989}, {0.019165, 0.118150, 0.941914}};\n  static const double(*out_rgb[])[3] = {rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb, aces_rgb};\n  static const char *name[] = {\"sRGB\", \"Adobe RGB (1998)\", \"WideGamut D65\", \"ProPhoto D65\", \"XYZ\", \"ACES\"};\n  static const unsigned phead[] = {1024, 0, 0x2100000,  0x6d6e7472, 0x52474220, 0x58595a20, 0,\n                                   0,    0, 0x61637370, 0,          0,          0x6e6f6e65, 0,\n                                   0,    0, 0,          0xf6d6,     0x10000,    0xd32d};\n  unsigned pbody[] = {10,         0x63707274, 0,  36, /* cprt */\n                      0x64657363, 0,          40,     /* desc */\n                      0x77747074, 0,          20,     /* wtpt */\n                      0x626b7074, 0,          20,     /* bkpt */\n                      0x72545243, 0,          14,     /* rTRC */\n                      0x67545243, 0,          14,     /* gTRC */\n                      0x62545243, 0,          14,     /* bTRC */\n                      0x7258595a, 0,          20,     /* rXYZ */\n                      0x6758595a, 0,          20,     /* gXYZ */\n                      0x6258595a, 0,          20};    /* bXYZ */\n  static const unsigned pwhite[] = {0xf351, 0x10000, 0x116cc};\n  unsigned pcurve[] = {0x63757276, 0, 1, 0x1000000};\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 0, 2);\n#endif\n  gamma_curve(gamm[0], gamm[1], 0, 0);\n  memcpy(out_cam, rgb_cam, sizeof out_cam);\n#ifndef LIBRAW_LIBRARY_BUILD\n  raw_color |= colors == 1 || document_mode || output_color < 1 || output_color > 6;\n#else\n  raw_color |= colors == 1 || output_color < 1 || output_color > 6;\n#endif\n  if (!raw_color)\n  {\n    oprof = (unsigned *)calloc(phead[0], 1);\n    merror(oprof, \"convert_to_rgb()\");\n    memcpy(oprof, phead, sizeof phead);\n    if (output_color == 5)\n      oprof[4] = oprof[5];\n    oprof[0] = 132 + 12 * pbody[0];\n    for (i = 0; i < pbody[0]; i++)\n    {\n      oprof[oprof[0] / 4] = i ? (i > 1 ? 0x58595a20 : 0x64657363) : 0x74657874;\n      pbody[i * 3 + 2] = oprof[0];\n      oprof[0] += (pbody[i * 3 + 3] + 3) & -4;\n    }\n    memcpy(oprof + 32, pbody, sizeof pbody);\n    oprof[pbody[5] / 4 + 2] = strlen(name[output_color - 1]) + 1;\n    memcpy((char *)oprof + pbody[8] + 8, pwhite, sizeof pwhite);\n    pcurve[3] = (short)(256 / gamm[5] + 0.5) << 16;\n    for (i = 4; i < 7; i++)\n      memcpy((char *)oprof + pbody[i * 3 + 2], pcurve, sizeof pcurve);\n    pseudoinverse((double(*)[3])out_rgb[output_color - 1], inverse, 3);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < 3; j++)\n      {\n        for (num = k = 0; k < 3; k++)\n          num += xyzd50_srgb[i][k] * inverse[j][k];\n        oprof[pbody[j * 3 + 23] / 4 + i + 2] = num * 0x10000 + 0.5;\n      }\n    for (i = 0; i < phead[0] / 4; i++)\n      oprof[i] = htonl(oprof[i]);\n    strcpy((char *)oprof + pbody[2] + 8, \"auto-generated by dcraw\");\n    strcpy((char *)oprof + pbody[5] + 12, name[output_color - 1]);\n    for (i = 0; i < 3; i++)\n      for (j = 0; j < colors; j++)\n        for (out_cam[i][j] = k = 0; k < 3; k++)\n          out_cam[i][j] += out_rgb[output_color - 1][i][k] * rgb_cam[k][j];\n  }\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, raw_color ? _(\"Building histograms...\\n\") : _(\"Converting to %s colorspace...\\n\"),\n            name[output_color - 1]);\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  convert_to_rgb_loop(out_cam);\n#else\n  memset(histogram, 0, sizeof histogram);\n  for (img = image[0], row = 0; row < height; row++)\n    for (col = 0; col < width; col++, img += 4)\n    {\n      if (!raw_color)\n      {\n        out[0] = out[1] = out[2] = 0;\n        FORCC\n        {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        FORC3 img[c] = CLIP((int)out[c]);\n      }\n      else if (document_mode)\n        img[0] = img[fcol(row, col)];\n      FORCC histogram[c][img[c] >> 3]++;\n    }\n#endif\n  if (colors == 4 && output_color)\n    colors = 3;\n#ifndef LIBRAW_LIBRARY_BUILD\n  if (document_mode && filters)\n    colors = 1;\n#endif\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_CONVERT_RGB, 1, 2);\n#endif\n}\n\nvoid CLASS fuji_rotate()\n{\n  int i, row, col;\n  double step;\n  float r, c, fr, fc;\n  unsigned ur, uc;\n  ushort wide, high, (*img)[4], (*pix)[4];\n\n  if (!fuji_width)\n    return;\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Rotating image 45 degrees...\\n\"));\n#endif\n  fuji_width = (fuji_width - 1 + shrink) >> shrink;\n  step = sqrt(0.5);\n  wide = fuji_width / step;\n  high = (height - fuji_width) / step;\n  img = (ushort(*)[4])calloc(high, wide * sizeof *img);\n  merror(img, \"fuji_rotate()\");\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 0, 2);\n#endif\n\n  for (row = 0; row < high; row++)\n    for (col = 0; col < wide; col++)\n    {\n      ur = r = fuji_width + (row - col) * step;\n      uc = c = (row + col) * step;\n      if (ur > height - 2 || uc > width - 2)\n        continue;\n      fr = r - ur;\n      fc = c - uc;\n      pix = image + ur * width + uc;\n      for (i = 0; i < colors; i++)\n        img[row * wide + col][i] = (pix[0][i] * (1 - fc) + pix[1][i] * fc) * (1 - fr) +\n                                   (pix[width][i] * (1 - fc) + pix[width + 1][i] * fc) * fr;\n    }\n\n  free(image);\n  width = wide;\n  height = high;\n  image = img;\n  fuji_width = 0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_FUJI_ROTATE, 1, 2);\n#endif\n}\n\nvoid CLASS stretch()\n{\n  ushort newdim, (*img)[4], *pix0, *pix1;\n  int row, col, c;\n  double rc, frac;\n\n  if (pixel_aspect == 1)\n    return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 0, 2);\n#endif\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"Stretching the image...\\n\"));\n#endif\n  if (pixel_aspect < 1)\n  {\n    newdim = height / pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(width, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = row = 0; row < newdim; row++, rc += pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c * width];\n      if (c + 1 < height)\n        pix1 += width * 4;\n      for (col = 0; col < width; col++, pix0 += 4, pix1 += 4)\n        FORCC img[row * width + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    height = newdim;\n  }\n  else\n  {\n    newdim = width * pixel_aspect + 0.5;\n    img = (ushort(*)[4])calloc(height, newdim * sizeof *img);\n    merror(img, \"stretch()\");\n    for (rc = col = 0; col < newdim; col++, rc += 1 / pixel_aspect)\n    {\n      frac = rc - (c = rc);\n      pix0 = pix1 = image[c];\n      if (c + 1 < width)\n        pix1 += 4;\n      for (row = 0; row < height; row++, pix0 += width * 4, pix1 += width * 4)\n        FORCC img[row * newdim + col][c] = pix0[c] * (1 - frac) + pix1[c] * frac + 0.5;\n    }\n    width = newdim;\n  }\n  free(image);\n  image = img;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_STRETCH, 1, 2);\n#endif\n}\n\nint CLASS flip_index(int row, int col)\n{\n  if (flip & 4)\n    SWAP(row, col);\n  if (flip & 2)\n    row = iheight - 1 - row;\n  if (flip & 1)\n    col = iwidth - 1 - col;\n  return row * iwidth + col;\n}\n\nvoid CLASS tiff_set(struct tiff_hdr *th, ushort *ntag, ushort tag, ushort type, int count, int val)\n{\n  struct tiff_tag *tt;\n  int c;\n\n  tt = (struct tiff_tag *)(ntag + 1) + (*ntag)++;\n  tt->val.i = val;\n  if (type == 1 && count <= 4)\n    FORC(4) tt->val.c[c] = val >> (c << 3);\n  else if (type == 2)\n  {\n    count = strnlen((char *)th + val, count - 1) + 1;\n    if (count <= 4)\n      FORC(4) tt->val.c[c] = ((char *)th)[val + c];\n  }\n  else if (type == 3 && count <= 2)\n    FORC(2) tt->val.s[c] = val >> (c << 4);\n  tt->count = count;\n  tt->type = type;\n  tt->tag = tag;\n}\n\n#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)\n\nvoid CLASS tiff_head(struct tiff_hdr *th, int full)\n{\n  int c, psize = 0;\n  struct tm *t;\n\n  memset(th, 0, sizeof *th);\n  th->t_order = htonl(0x4d4d4949) >> 16;\n  th->magic = 42;\n  th->ifd = 10;\n  th->rat[0] = th->rat[2] = 300;\n  th->rat[1] = th->rat[3] = 1;\n  FORC(6) th->rat[4 + c] = 1000000;\n  th->rat[4] *= shutter;\n  th->rat[6] *= aperture;\n  th->rat[8] *= focal_len;\n  strncpy(th->t_desc, desc, 512);\n  strncpy(th->t_make, make, 64);\n  strncpy(th->t_model, model, 64);\n  strcpy(th->soft, \"dcraw v\" DCRAW_VERSION);\n  t = localtime(&timestamp);\n  sprintf(th->date, \"%04d:%02d:%02d %02d:%02d:%02d\", t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour,\n          t->tm_min, t->tm_sec);\n  strncpy(th->t_artist, artist, 64);\n  if (full)\n  {\n    tiff_set(th, &th->ntag, 254, 4, 1, 0);\n    tiff_set(th, &th->ntag, 256, 4, 1, width);\n    tiff_set(th, &th->ntag, 257, 4, 1, height);\n    tiff_set(th, &th->ntag, 258, 3, colors, output_bps);\n    if (colors > 2)\n      th->tag[th->ntag - 1].val.i = TOFF(th->bps);\n    FORC4 th->bps[c] = output_bps;\n    tiff_set(th, &th->ntag, 259, 3, 1, 1);\n    tiff_set(th, &th->ntag, 262, 3, 1, 1 + (colors > 1));\n  }\n  tiff_set(th, &th->ntag, 270, 2, 512, TOFF(th->t_desc));\n  tiff_set(th, &th->ntag, 271, 2, 64, TOFF(th->t_make));\n  tiff_set(th, &th->ntag, 272, 2, 64, TOFF(th->t_model));\n  if (full)\n  {\n    if (oprof)\n      psize = ntohl(oprof[0]);\n    tiff_set(th, &th->ntag, 273, 4, 1, sizeof *th + psize);\n    tiff_set(th, &th->ntag, 277, 3, 1, colors);\n    tiff_set(th, &th->ntag, 278, 4, 1, height);\n    tiff_set(th, &th->ntag, 279, 4, 1, height * width * colors * output_bps / 8);\n  }\n  else\n    tiff_set(th, &th->ntag, 274, 3, 1, \"12435867\"[flip] - '0');\n  tiff_set(th, &th->ntag, 282, 5, 1, TOFF(th->rat[0]));\n  tiff_set(th, &th->ntag, 283, 5, 1, TOFF(th->rat[2]));\n  tiff_set(th, &th->ntag, 284, 3, 1, 1);\n  tiff_set(th, &th->ntag, 296, 3, 1, 2);\n  tiff_set(th, &th->ntag, 305, 2, 32, TOFF(th->soft));\n  tiff_set(th, &th->ntag, 306, 2, 20, TOFF(th->date));\n  tiff_set(th, &th->ntag, 315, 2, 64, TOFF(th->t_artist));\n  tiff_set(th, &th->ntag, 34665, 4, 1, TOFF(th->nexif));\n  if (psize)\n    tiff_set(th, &th->ntag, 34675, 7, psize, sizeof *th);\n  tiff_set(th, &th->nexif, 33434, 5, 1, TOFF(th->rat[4]));\n  tiff_set(th, &th->nexif, 33437, 5, 1, TOFF(th->rat[6]));\n  tiff_set(th, &th->nexif, 34855, 3, 1, iso_speed);\n  tiff_set(th, &th->nexif, 37386, 5, 1, TOFF(th->rat[8]));\n  if (gpsdata[1])\n  {\n    tiff_set(th, &th->ntag, 34853, 4, 1, TOFF(th->ngps));\n    tiff_set(th, &th->ngps, 0, 1, 4, 0x202);\n    tiff_set(th, &th->ngps, 1, 2, 2, gpsdata[29]);\n    tiff_set(th, &th->ngps, 2, 5, 3, TOFF(th->gps[0]));\n    tiff_set(th, &th->ngps, 3, 2, 2, gpsdata[30]);\n    tiff_set(th, &th->ngps, 4, 5, 3, TOFF(th->gps[6]));\n    tiff_set(th, &th->ngps, 5, 1, 1, gpsdata[31]);\n    tiff_set(th, &th->ngps, 6, 5, 1, TOFF(th->gps[18]));\n    tiff_set(th, &th->ngps, 7, 5, 3, TOFF(th->gps[12]));\n    tiff_set(th, &th->ngps, 18, 2, 12, TOFF(th->gps[20]));\n    tiff_set(th, &th->ngps, 29, 2, 12, TOFF(th->gps[23]));\n    memcpy(th->gps, gpsdata, sizeof th->gps);\n  }\n}\n\n#ifdef LIBRAW_LIBRARY_BUILD\nvoid CLASS jpeg_thumb_writer(FILE *tfp, char *t_humb, int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc(0xff, tfp);\n  fputc(0xd8, tfp);\n  if (strcmp(t_humb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, tfp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, tfp);\n  }\n  fwrite(t_humb + 2, 1, t_humb_length - 2, tfp);\n}\n\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  jpeg_thumb_writer(ofp, thumb, thumb_length);\n  free(thumb);\n}\n#else\nvoid CLASS jpeg_thumb()\n{\n  char *thumb;\n  ushort exif[5];\n  struct tiff_hdr th;\n\n  thumb = (char *)malloc(thumb_length);\n  merror(thumb, \"jpeg_thumb()\");\n  fread(thumb, 1, thumb_length, ifp);\n  fputc(0xff, ofp);\n  fputc(0xd8, ofp);\n  if (strcmp(thumb + 6, \"Exif\"))\n  {\n    memcpy(exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n    exif[1] = htons(8 + sizeof th);\n    fwrite(exif, 1, sizeof exif, ofp);\n    tiff_head(&th, 0);\n    fwrite(&th, 1, sizeof th, ofp);\n  }\n  fwrite(thumb + 2, 1, thumb_length - 2, ofp);\n  free(thumb);\n}\n#endif\n\nvoid CLASS write_ppm_tiff()\n{\n  struct tiff_hdr th;\n  uchar *ppm;\n  ushort *ppm2;\n  int c, row, col, soff, rstep, cstep;\n  int perc, val, total, t_white = 0x2000;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  perc = width * height * auto_bright_thr;\n#else\n  perc = width * height * 0.01; /* 99th percentile white level */\n#endif\n  if (fuji_width)\n    perc /= 2;\n  if (!((highlight & ~2) || no_auto_bright))\n    for (t_white = c = 0; c < colors; c++)\n    {\n      for (val = 0x2000, total = 0; --val > 32;)\n        if ((total += histogram[c][val]) > perc)\n          break;\n      if (t_white < val)\n        t_white = val;\n    }\n  gamma_curve(gamm[0], gamm[1], 2, (t_white << 3) / bright);\n  iheight = height;\n  iwidth = width;\n  if (flip & 4)\n    SWAP(height, width);\n  ppm = (uchar *)calloc(width, colors * output_bps / 8);\n  ppm2 = (ushort *)ppm;\n  merror(ppm, \"write_ppm_tiff()\");\n  if (output_tiff)\n  {\n    tiff_head(&th, 1);\n    fwrite(&th, sizeof th, 1, ofp);\n    if (oprof)\n      fwrite(oprof, ntohl(oprof[0]), 1, ofp);\n  }\n  else if (colors > 3)\n    fprintf(ofp, \"P7\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %d\\nMAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", width, height, colors,\n            (1 << output_bps) - 1, cdesc);\n  else\n    fprintf(ofp, \"P%d\\n%d %d\\n%d\\n\", colors / 2 + 5, width, height, (1 << output_bps) - 1);\n  soff = flip_index(0, 0);\n  cstep = flip_index(0, 1) - soff;\n  rstep = flip_index(1, 0) - flip_index(0, width);\n  for (row = 0; row < height; row++, soff += rstep)\n  {\n    for (col = 0; col < width; col++, soff += cstep)\n      if (output_bps == 8)\n        FORCC ppm[col * colors + c] = curve[image[soff][c]] >> 8;\n      else\n        FORCC ppm2[col * colors + c] = curve[image[soff][c]];\n    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)\n      swab((char *)ppm2, (char *)ppm2, width * colors * 2);\n    fwrite(ppm, colors * output_bps / 8, width, ofp);\n  }\n  free(ppm);\n}\n"], "filenames": ["dcraw/dcraw.c", "internal/dcraw_common.cpp"], "buggy_code_start_loc": [12872, 11544], "buggy_code_end_loc": [14799, 13471], "fixing_code_start_loc": [12873, 11545], "fixing_code_end_loc": [14807, 13479], "type": "CWE-119", "message": "A boundary error within the \"parse_tiff_ifd()\" function (internal/dcraw_common.cpp) in LibRaw versions before 0.18.2 can be exploited to cause a memory corruption via e.g. a specially crafted KDC file with model set to \"DSLR-A100\" and containing multiple sequences of 0x100 and 0x14A TAGs.", "other": {"cve": {"id": "CVE-2017-6887", "sourceIdentifier": "PSIRT-CNA@flexerasoftware.com", "published": "2017-05-16T16:29:00.253", "lastModified": "2017-11-04T01:29:49.867", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A boundary error within the \"parse_tiff_ifd()\" function (internal/dcraw_common.cpp) in LibRaw versions before 0.18.2 can be exploited to cause a memory corruption via e.g. a specially crafted KDC file with model set to \"DSLR-A100\" and containing multiple sequences of 0x100 and 0x14A TAGs."}, {"lang": "es", "value": "Un error de l\u00edmites dentro de la funci\u00f3n \"parse_tiff_ifd()\" (en el archivo internal/dcraw_common.cpp) en LibRaw versiones anteriores a 0.18.2, puede ser explotado para causar un corrupci\u00f3n de memoria por medio de, por ejemplo, un archivo KDC especialmente dise\u00f1ado con el modelo establecido en \"DSLR-A100\" y que contenga m\u00faltiples secuencias de TAGs 0x100 y 0x14A."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.18.1", "matchCriteriaId": "54CB3A8F-1F07-49F4-AC34-9199D0EA24AF"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3950", "source": "PSIRT-CNA@flexerasoftware.com"}, {"url": "http://www.securityfocus.com/bid/98592", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://secuniaresearch.flexerasoftware.com/advisories/75737/", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://secuniaresearch.flexerasoftware.com/secunia_research/2017-6/", "source": "PSIRT-CNA@flexerasoftware.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/d7c3d2cb460be10a3ea7b32e9443a83c243b2251"}}