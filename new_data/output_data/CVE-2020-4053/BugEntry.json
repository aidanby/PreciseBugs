{"buggy_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage installer // import \"helm.sh/helm/v3/pkg/plugin/installer\"\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"helm.sh/helm/v3/internal/third_party/dep/fs\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n\t\"helm.sh/helm/v3/pkg/plugin/cache\"\n)\n\n// HTTPInstaller installs plugins from an archive served by a web server.\ntype HTTPInstaller struct {\n\tCacheDir   string\n\tPluginName string\n\tbase\n\textractor Extractor\n\tgetter    getter.Getter\n}\n\n// TarGzExtractor extracts gzip compressed tar archives\ntype TarGzExtractor struct{}\n\n// Extractor provides an interface for extracting archives\ntype Extractor interface {\n\tExtract(buffer *bytes.Buffer, targetDir string) error\n}\n\n// Extractors contains a map of suffixes and matching implementations of extractor to return\nvar Extractors = map[string]Extractor{\n\t\".tar.gz\": &TarGzExtractor{},\n\t\".tgz\":    &TarGzExtractor{},\n}\n\n// NewExtractor creates a new extractor matching the source file name\nfunc NewExtractor(source string) (Extractor, error) {\n\tfor suffix, extractor := range Extractors {\n\t\tif strings.HasSuffix(source, suffix) {\n\t\t\treturn extractor, nil\n\t\t}\n\t}\n\treturn nil, errors.Errorf(\"no extractor implemented yet for %s\", source)\n}\n\n// NewHTTPInstaller creates a new HttpInstaller.\nfunc NewHTTPInstaller(source string) (*HTTPInstaller, error) {\n\tkey, err := cache.Key(source)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\textractor, err := NewExtractor(source)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tget, err := getter.All(new(cli.EnvSettings)).ByScheme(\"http\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ti := &HTTPInstaller{\n\t\tCacheDir:   helmpath.CachePath(\"plugins\", key),\n\t\tPluginName: stripPluginName(filepath.Base(source)),\n\t\tbase:       newBase(source),\n\t\textractor:  extractor,\n\t\tgetter:     get,\n\t}\n\treturn i, nil\n}\n\n// helper that relies on some sort of convention for plugin name (plugin-name-<version>)\nfunc stripPluginName(name string) string {\n\tvar strippedName string\n\tfor suffix := range Extractors {\n\t\tif strings.HasSuffix(name, suffix) {\n\t\t\tstrippedName = strings.TrimSuffix(name, suffix)\n\t\t\tbreak\n\t\t}\n\t}\n\tre := regexp.MustCompile(`(.*)-[0-9]+\\..*`)\n\treturn re.ReplaceAllString(strippedName, `$1`)\n}\n\n// Install downloads and extracts the tarball into the cache directory\n// and installs into the plugin directory.\n//\n// Implements Installer.\nfunc (i *HTTPInstaller) Install() error {\n\tpluginData, err := i.getter.Get(i.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := i.extractor.Extract(pluginData, i.CacheDir); err != nil {\n\t\treturn err\n\t}\n\n\tif !isPlugin(i.CacheDir) {\n\t\treturn ErrMissingMetadata\n\t}\n\n\tsrc, err := filepath.Abs(i.CacheDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdebug(\"copying %s to %s\", src, i.Path())\n\treturn fs.CopyDir(src, i.Path())\n}\n\n// Update updates a local repository\n// Not implemented for now since tarball most likely will be packaged by version\nfunc (i *HTTPInstaller) Update() error {\n\treturn errors.Errorf(\"method Update() not implemented for HttpInstaller\")\n}\n\n// Path is overridden because we want to join on the plugin name not the file name\nfunc (i HTTPInstaller) Path() string {\n\tif i.base.Source == \"\" {\n\t\treturn \"\"\n\t}\n\treturn helmpath.DataPath(\"plugins\", i.PluginName)\n}\n\n// Extract extracts compressed archives\n//\n// Implements Extractor.\nfunc (g *TarGzExtractor) Extract(buffer *bytes.Buffer, targetDir string) error {\n\tuncompressedStream, err := gzip.NewReader(buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := os.MkdirAll(targetDir, 0755); err != nil {\n\t\treturn err\n\t}\n\n\ttarReader := tar.NewReader(uncompressedStream)\n\tfor {\n\t\theader, err := tarReader.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpath := filepath.Join(targetDir, header.Name)\n\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\tif err := os.Mkdir(path, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeReg:\n\t\t\toutFile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := io.Copy(outFile, tarReader); err != nil {\n\t\t\t\toutFile.Close()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\toutFile.Close()\n\t\t// We don't want to process these extension header files.\n\t\tcase tar.TypeXGlobalHeader, tar.TypeXHeader:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\treturn errors.Errorf(\"unknown type: %b in %s\", header.Typeflag, header.Name)\n\t\t}\n\t}\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage installer // import \"helm.sh/helm/v3/pkg/plugin/installer\"\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/base64\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"helm.sh/helm/v3/internal/test/ensure\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n)\n\nvar _ Installer = new(HTTPInstaller)\n\n// Fake http client\ntype TestHTTPGetter struct {\n\tMockResponse *bytes.Buffer\n\tMockError    error\n}\n\nfunc (t *TestHTTPGetter) Get(href string, _ ...getter.Option) (*bytes.Buffer, error) {\n\treturn t.MockResponse, t.MockError\n}\n\n// Fake plugin tarball data\nvar fakePluginB64 = \"H4sIAKRj51kAA+3UX0vCUBgGcC9jn+Iwuk3Peza3GeyiUlJQkcogCOzgli7dJm4TvYk+a5+k479UqquUCJ/fLs549sLO2TnvWnJa9aXnjwujYdYLovxMhsPcfnHOLdNkOXthM/IVQQYjg2yyLLJ4kXGhLp5j0z3P41tZksqxmspL3B/O+j/XtZu1y8rdYzkOZRCxduKPk53ny6Wwz/GfIIf1As8lxzGJSmoHNLJZphKHG4YpTCE0wVk3DULfpSJ3DMMqkj3P5JfMYLdX1Vr9Ie/5E5cstcdC8K04iGLX5HaJuKpWL17F0TCIBi5pf/0pjtLhun5j3f9v6r7wfnI/H0eNp9d1/5P6Gez0vzo7wsoxfrAZbTny/o9k6J8z/VkO/LPlWdC1iVpbEEcq5nmeJ13LEtmbV0k2r2PrOs9PuuNglC5rL1Y5S/syXRQmutaNw1BGnnp8Wq3UG51WvX1da3bKtZtCN/R09DwAAAAAAAAAAAAAAAAAAADAb30AoMczDwAoAAA=\"\n\nfunc TestStripName(t *testing.T) {\n\tif stripPluginName(\"fake-plugin-0.0.1.tar.gz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n\tif stripPluginName(\"fake-plugin-0.0.1.tgz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n\tif stripPluginName(\"fake-plugin.tgz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n\tif stripPluginName(\"fake-plugin.tar.gz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n}\n\nfunc TestHTTPInstaller(t *testing.T) {\n\tdefer ensure.HelmHome(t)()\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz\"\n\n\tif err := os.MkdirAll(helmpath.DataPath(\"plugins\"), 0755); err != nil {\n\t\tt.Fatalf(\"Could not create %s: %s\", helmpath.DataPath(\"plugins\"), err)\n\t}\n\n\ti, err := NewForSource(source, \"0.0.1\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// ensure a HTTPInstaller was returned\n\thttpInstaller, ok := i.(*HTTPInstaller)\n\tif !ok {\n\t\tt.Fatal(\"expected a HTTPInstaller\")\n\t}\n\n\t// inject fake http client responding with minimal plugin tarball\n\tmockTgz, err := base64.StdEncoding.DecodeString(fakePluginB64)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not decode fake tgz plugin: %s\", err)\n\t}\n\n\thttpInstaller.getter = &TestHTTPGetter{\n\t\tMockResponse: bytes.NewBuffer(mockTgz),\n\t}\n\n\t// install the plugin\n\tif err := Install(i); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i.Path() != helmpath.DataPath(\"plugins\", \"fake-plugin\") {\n\t\tt.Fatalf(\"expected path '$XDG_CONFIG_HOME/helm/plugins/fake-plugin', got %q\", i.Path())\n\t}\n\n\t// Install again to test plugin exists error\n\tif err := Install(i); err == nil {\n\t\tt.Fatal(\"expected error for plugin exists, got none\")\n\t} else if err.Error() != \"plugin already exists\" {\n\t\tt.Fatalf(\"expected error for plugin exists, got (%v)\", err)\n\t}\n\n}\n\nfunc TestHTTPInstallerNonExistentVersion(t *testing.T) {\n\tdefer ensure.HelmHome(t)()\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.2.tar.gz\"\n\n\tif err := os.MkdirAll(helmpath.DataPath(\"plugins\"), 0755); err != nil {\n\t\tt.Fatalf(\"Could not create %s: %s\", helmpath.DataPath(\"plugins\"), err)\n\t}\n\n\ti, err := NewForSource(source, \"0.0.2\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// ensure a HTTPInstaller was returned\n\thttpInstaller, ok := i.(*HTTPInstaller)\n\tif !ok {\n\t\tt.Fatal(\"expected a HTTPInstaller\")\n\t}\n\n\t// inject fake http client responding with error\n\thttpInstaller.getter = &TestHTTPGetter{\n\t\tMockError: errors.Errorf(\"failed to download plugin for some reason\"),\n\t}\n\n\t// attempt to install the plugin\n\tif err := Install(i); err == nil {\n\t\tt.Fatal(\"expected error from http client\")\n\t}\n\n}\n\nfunc TestHTTPInstallerUpdate(t *testing.T) {\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz\"\n\tdefer ensure.HelmHome(t)()\n\n\tif err := os.MkdirAll(helmpath.DataPath(\"plugins\"), 0755); err != nil {\n\t\tt.Fatalf(\"Could not create %s: %s\", helmpath.DataPath(\"plugins\"), err)\n\t}\n\n\ti, err := NewForSource(source, \"0.0.1\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// ensure a HTTPInstaller was returned\n\thttpInstaller, ok := i.(*HTTPInstaller)\n\tif !ok {\n\t\tt.Fatal(\"expected a HTTPInstaller\")\n\t}\n\n\t// inject fake http client responding with minimal plugin tarball\n\tmockTgz, err := base64.StdEncoding.DecodeString(fakePluginB64)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not decode fake tgz plugin: %s\", err)\n\t}\n\n\thttpInstaller.getter = &TestHTTPGetter{\n\t\tMockResponse: bytes.NewBuffer(mockTgz),\n\t}\n\n\t// install the plugin before updating\n\tif err := Install(i); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i.Path() != helmpath.DataPath(\"plugins\", \"fake-plugin\") {\n\t\tt.Fatalf(\"expected path '$XDG_CONFIG_HOME/helm/plugins/fake-plugin', got %q\", i.Path())\n\t}\n\n\t// Update plugin, should fail because it is not implemented\n\tif err := Update(i); err == nil {\n\t\tt.Fatal(\"update method not implemented for http installer\")\n\t}\n}\n\nfunc TestExtract(t *testing.T) {\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz\"\n\n\ttempDir, err := ioutil.TempDir(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Set the umask to default open permissions so we can actually test\n\toldmask := syscall.Umask(0000)\n\tdefer func() {\n\t\tsyscall.Umask(oldmask)\n\t}()\n\n\t// Write a tarball to a buffer for us to extract\n\tvar tarbuf bytes.Buffer\n\ttw := tar.NewWriter(&tarbuf)\n\tvar files = []struct {\n\t\tName, Body string\n\t\tMode       int64\n\t}{\n\t\t{\"plugin.yaml\", \"plugin metadata\", 0600},\n\t\t{\"README.md\", \"some text\", 0777},\n\t}\n\tfor _, file := range files {\n\t\thdr := &tar.Header{\n\t\t\tName:     file.Name,\n\t\t\tTypeflag: tar.TypeReg,\n\t\t\tMode:     file.Mode,\n\t\t\tSize:     int64(len(file.Body)),\n\t\t}\n\t\tif err := tw.WriteHeader(hdr); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := tw.Write([]byte(file.Body)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Add pax global headers. This should be ignored.\n\t// Note the PAX header that isn't global cannot be written using WriteHeader.\n\t// Details are in the internal Go function for the tar packaged named\n\t// allowedFormats. For a TypeXHeader it will return a message stating\n\t// \"cannot manually encode TypeXHeader, TypeGNULongName, or TypeGNULongLink headers\"\n\tif err := tw.WriteHeader(&tar.Header{\n\t\tName:     \"pax_global_header\",\n\t\tTypeflag: tar.TypeXGlobalHeader,\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tw.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar buf bytes.Buffer\n\tgz := gzip.NewWriter(&buf)\n\tif _, err := gz.Write(tarbuf.Bytes()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgz.Close()\n\t// END tarball creation\n\n\textractor, err := NewExtractor(source)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = extractor.Extract(&buf, tempDir); err != nil {\n\t\tt.Fatalf(\"Did not expect error but got error: %v\", err)\n\t}\n\n\tpluginYAMLFullPath := filepath.Join(tempDir, \"plugin.yaml\")\n\tif info, err := os.Stat(pluginYAMLFullPath); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"Expected %s to exist but doesn't\", pluginYAMLFullPath)\n\t\t}\n\t\tt.Fatal(err)\n\t} else if info.Mode().Perm() != 0600 {\n\t\tt.Fatalf(\"Expected %s to have 0600 mode it but has %o\", pluginYAMLFullPath, info.Mode().Perm())\n\t}\n\n\treadmeFullPath := filepath.Join(tempDir, \"README.md\")\n\tif info, err := os.Stat(readmeFullPath); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"Expected %s to exist but doesn't\", readmeFullPath)\n\t\t}\n\t\tt.Fatal(err)\n\t} else if info.Mode().Perm() != 0777 {\n\t\tt.Fatalf(\"Expected %s to have 0777 mode it but has %o\", readmeFullPath, info.Mode().Perm())\n\t}\n\n}\n"], "fixing_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage installer // import \"helm.sh/helm/v3/pkg/plugin/installer\"\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/pkg/errors\"\n\n\t\"helm.sh/helm/v3/internal/third_party/dep/fs\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n\t\"helm.sh/helm/v3/pkg/plugin/cache\"\n)\n\n// HTTPInstaller installs plugins from an archive served by a web server.\ntype HTTPInstaller struct {\n\tCacheDir   string\n\tPluginName string\n\tbase\n\textractor Extractor\n\tgetter    getter.Getter\n}\n\n// TarGzExtractor extracts gzip compressed tar archives\ntype TarGzExtractor struct{}\n\n// Extractor provides an interface for extracting archives\ntype Extractor interface {\n\tExtract(buffer *bytes.Buffer, targetDir string) error\n}\n\n// Extractors contains a map of suffixes and matching implementations of extractor to return\nvar Extractors = map[string]Extractor{\n\t\".tar.gz\": &TarGzExtractor{},\n\t\".tgz\":    &TarGzExtractor{},\n}\n\n// NewExtractor creates a new extractor matching the source file name\nfunc NewExtractor(source string) (Extractor, error) {\n\tfor suffix, extractor := range Extractors {\n\t\tif strings.HasSuffix(source, suffix) {\n\t\t\treturn extractor, nil\n\t\t}\n\t}\n\treturn nil, errors.Errorf(\"no extractor implemented yet for %s\", source)\n}\n\n// NewHTTPInstaller creates a new HttpInstaller.\nfunc NewHTTPInstaller(source string) (*HTTPInstaller, error) {\n\tkey, err := cache.Key(source)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\textractor, err := NewExtractor(source)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tget, err := getter.All(new(cli.EnvSettings)).ByScheme(\"http\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ti := &HTTPInstaller{\n\t\tCacheDir:   helmpath.CachePath(\"plugins\", key),\n\t\tPluginName: stripPluginName(filepath.Base(source)),\n\t\tbase:       newBase(source),\n\t\textractor:  extractor,\n\t\tgetter:     get,\n\t}\n\treturn i, nil\n}\n\n// helper that relies on some sort of convention for plugin name (plugin-name-<version>)\nfunc stripPluginName(name string) string {\n\tvar strippedName string\n\tfor suffix := range Extractors {\n\t\tif strings.HasSuffix(name, suffix) {\n\t\t\tstrippedName = strings.TrimSuffix(name, suffix)\n\t\t\tbreak\n\t\t}\n\t}\n\tre := regexp.MustCompile(`(.*)-[0-9]+\\..*`)\n\treturn re.ReplaceAllString(strippedName, `$1`)\n}\n\n// Install downloads and extracts the tarball into the cache directory\n// and installs into the plugin directory.\n//\n// Implements Installer.\nfunc (i *HTTPInstaller) Install() error {\n\tpluginData, err := i.getter.Get(i.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := i.extractor.Extract(pluginData, i.CacheDir); err != nil {\n\t\treturn errors.Wrap(err, \"extracting files from archive\")\n\t}\n\n\tif !isPlugin(i.CacheDir) {\n\t\treturn ErrMissingMetadata\n\t}\n\n\tsrc, err := filepath.Abs(i.CacheDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdebug(\"copying %s to %s\", src, i.Path())\n\treturn fs.CopyDir(src, i.Path())\n}\n\n// Update updates a local repository\n// Not implemented for now since tarball most likely will be packaged by version\nfunc (i *HTTPInstaller) Update() error {\n\treturn errors.Errorf(\"method Update() not implemented for HttpInstaller\")\n}\n\n// Path is overridden because we want to join on the plugin name not the file name\nfunc (i HTTPInstaller) Path() string {\n\tif i.base.Source == \"\" {\n\t\treturn \"\"\n\t}\n\treturn helmpath.DataPath(\"plugins\", i.PluginName)\n}\n\n// CleanJoin resolves dest as a subpath of root.\n//\n// This function runs several security checks on the path, generating an error if\n// the supplied `dest` looks suspicious or would result in dubious behavior on the\n// filesystem.\n//\n// CleanJoin assumes that any attempt by `dest` to break out of the CWD is an attempt\n// to be malicious. (If you don't care about this, use the securejoin-filepath library.)\n// It will emit an error if it detects paths that _look_ malicious, operating on the\n// assumption that we don't actually want to do anything with files that already\n// appear to be nefarious.\n//\n//   - The character `:` is considered illegal because it is a separator on UNIX and a\n//     drive designator on Windows.\n//   - The path component `..` is considered suspicions, and therefore illegal\n//   - The character \\ (backslash) is treated as a path separator and is converted to /.\n//   - Beginning a path with a path separator is illegal\n//   - Rudimentary symlink protects are offered by SecureJoin.\nfunc cleanJoin(root, dest string) (string, error) {\n\n\t// On Windows, this is a drive separator. On UNIX-like, this is the path list separator.\n\t// In neither case do we want to trust a TAR that contains these.\n\tif strings.Contains(dest, \":\") {\n\t\treturn \"\", errors.New(\"path contains ':', which is illegal\")\n\t}\n\n\t// The Go tar library does not convert separators for us.\n\t// We assume here, as we do elsewhere, that `\\\\` means a Windows path.\n\tdest = strings.ReplaceAll(dest, \"\\\\\", \"/\")\n\n\t// We want to alert the user that something bad was attempted. Cleaning it\n\t// is not a good practice.\n\tfor _, part := range strings.Split(dest, \"/\") {\n\t\tif part == \"..\" {\n\t\t\treturn \"\", errors.New(\"path contains '..', which is illegal\")\n\t\t}\n\t}\n\n\t// If a path is absolute, the creator of the TAR is doing something shady.\n\tif path.IsAbs(dest) {\n\t\treturn \"\", errors.New(\"path is absolute, which is illegal\")\n\t}\n\n\t// SecureJoin will do some cleaning, as well as some rudimentary checking of symlinks.\n\tnewpath, err := securejoin.SecureJoin(root, dest)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn filepath.ToSlash(newpath), nil\n}\n\n// Extract extracts compressed archives\n//\n// Implements Extractor.\nfunc (g *TarGzExtractor) Extract(buffer *bytes.Buffer, targetDir string) error {\n\tuncompressedStream, err := gzip.NewReader(buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := os.MkdirAll(targetDir, 0755); err != nil {\n\t\treturn err\n\t}\n\n\ttarReader := tar.NewReader(uncompressedStream)\n\tfor {\n\t\theader, err := tarReader.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpath, err := cleanJoin(targetDir, header.Name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch header.Typeflag {\n\t\tcase tar.TypeDir:\n\t\t\tif err := os.Mkdir(path, 0755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase tar.TypeReg:\n\t\t\toutFile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := io.Copy(outFile, tarReader); err != nil {\n\t\t\t\toutFile.Close()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\toutFile.Close()\n\t\t// We don't want to process these extension header files.\n\t\tcase tar.TypeXGlobalHeader, tar.TypeXHeader:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\treturn errors.Errorf(\"unknown type: %b in %s\", header.Typeflag, header.Name)\n\t\t}\n\t}\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage installer // import \"helm.sh/helm/v3/pkg/plugin/installer\"\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/base64\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"helm.sh/helm/v3/internal/test/ensure\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/helmpath\"\n)\n\nvar _ Installer = new(HTTPInstaller)\n\n// Fake http client\ntype TestHTTPGetter struct {\n\tMockResponse *bytes.Buffer\n\tMockError    error\n}\n\nfunc (t *TestHTTPGetter) Get(href string, _ ...getter.Option) (*bytes.Buffer, error) {\n\treturn t.MockResponse, t.MockError\n}\n\n// Fake plugin tarball data\nvar fakePluginB64 = \"H4sIAKRj51kAA+3UX0vCUBgGcC9jn+Iwuk3Peza3GeyiUlJQkcogCOzgli7dJm4TvYk+a5+k479UqquUCJ/fLs549sLO2TnvWnJa9aXnjwujYdYLovxMhsPcfnHOLdNkOXthM/IVQQYjg2yyLLJ4kXGhLp5j0z3P41tZksqxmspL3B/O+j/XtZu1y8rdYzkOZRCxduKPk53ny6Wwz/GfIIf1As8lxzGJSmoHNLJZphKHG4YpTCE0wVk3DULfpSJ3DMMqkj3P5JfMYLdX1Vr9Ie/5E5cstcdC8K04iGLX5HaJuKpWL17F0TCIBi5pf/0pjtLhun5j3f9v6r7wfnI/H0eNp9d1/5P6Gez0vzo7wsoxfrAZbTny/o9k6J8z/VkO/LPlWdC1iVpbEEcq5nmeJ13LEtmbV0k2r2PrOs9PuuNglC5rL1Y5S/syXRQmutaNw1BGnnp8Wq3UG51WvX1da3bKtZtCN/R09DwAAAAAAAAAAAAAAAAAAADAb30AoMczDwAoAAA=\"\n\nfunc TestStripName(t *testing.T) {\n\tif stripPluginName(\"fake-plugin-0.0.1.tar.gz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n\tif stripPluginName(\"fake-plugin-0.0.1.tgz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n\tif stripPluginName(\"fake-plugin.tgz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n\tif stripPluginName(\"fake-plugin.tar.gz\") != \"fake-plugin\" {\n\t\tt.Errorf(\"name does not match expected value\")\n\t}\n}\n\nfunc TestHTTPInstaller(t *testing.T) {\n\tdefer ensure.HelmHome(t)()\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz\"\n\n\tif err := os.MkdirAll(helmpath.DataPath(\"plugins\"), 0755); err != nil {\n\t\tt.Fatalf(\"Could not create %s: %s\", helmpath.DataPath(\"plugins\"), err)\n\t}\n\n\ti, err := NewForSource(source, \"0.0.1\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// ensure a HTTPInstaller was returned\n\thttpInstaller, ok := i.(*HTTPInstaller)\n\tif !ok {\n\t\tt.Fatal(\"expected a HTTPInstaller\")\n\t}\n\n\t// inject fake http client responding with minimal plugin tarball\n\tmockTgz, err := base64.StdEncoding.DecodeString(fakePluginB64)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not decode fake tgz plugin: %s\", err)\n\t}\n\n\thttpInstaller.getter = &TestHTTPGetter{\n\t\tMockResponse: bytes.NewBuffer(mockTgz),\n\t}\n\n\t// install the plugin\n\tif err := Install(i); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i.Path() != helmpath.DataPath(\"plugins\", \"fake-plugin\") {\n\t\tt.Fatalf(\"expected path '$XDG_CONFIG_HOME/helm/plugins/fake-plugin', got %q\", i.Path())\n\t}\n\n\t// Install again to test plugin exists error\n\tif err := Install(i); err == nil {\n\t\tt.Fatal(\"expected error for plugin exists, got none\")\n\t} else if err.Error() != \"plugin already exists\" {\n\t\tt.Fatalf(\"expected error for plugin exists, got (%v)\", err)\n\t}\n\n}\n\nfunc TestHTTPInstallerNonExistentVersion(t *testing.T) {\n\tdefer ensure.HelmHome(t)()\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.2.tar.gz\"\n\n\tif err := os.MkdirAll(helmpath.DataPath(\"plugins\"), 0755); err != nil {\n\t\tt.Fatalf(\"Could not create %s: %s\", helmpath.DataPath(\"plugins\"), err)\n\t}\n\n\ti, err := NewForSource(source, \"0.0.2\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// ensure a HTTPInstaller was returned\n\thttpInstaller, ok := i.(*HTTPInstaller)\n\tif !ok {\n\t\tt.Fatal(\"expected a HTTPInstaller\")\n\t}\n\n\t// inject fake http client responding with error\n\thttpInstaller.getter = &TestHTTPGetter{\n\t\tMockError: errors.Errorf(\"failed to download plugin for some reason\"),\n\t}\n\n\t// attempt to install the plugin\n\tif err := Install(i); err == nil {\n\t\tt.Fatal(\"expected error from http client\")\n\t}\n\n}\n\nfunc TestHTTPInstallerUpdate(t *testing.T) {\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz\"\n\tdefer ensure.HelmHome(t)()\n\n\tif err := os.MkdirAll(helmpath.DataPath(\"plugins\"), 0755); err != nil {\n\t\tt.Fatalf(\"Could not create %s: %s\", helmpath.DataPath(\"plugins\"), err)\n\t}\n\n\ti, err := NewForSource(source, \"0.0.1\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// ensure a HTTPInstaller was returned\n\thttpInstaller, ok := i.(*HTTPInstaller)\n\tif !ok {\n\t\tt.Fatal(\"expected a HTTPInstaller\")\n\t}\n\n\t// inject fake http client responding with minimal plugin tarball\n\tmockTgz, err := base64.StdEncoding.DecodeString(fakePluginB64)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not decode fake tgz plugin: %s\", err)\n\t}\n\n\thttpInstaller.getter = &TestHTTPGetter{\n\t\tMockResponse: bytes.NewBuffer(mockTgz),\n\t}\n\n\t// install the plugin before updating\n\tif err := Install(i); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i.Path() != helmpath.DataPath(\"plugins\", \"fake-plugin\") {\n\t\tt.Fatalf(\"expected path '$XDG_CONFIG_HOME/helm/plugins/fake-plugin', got %q\", i.Path())\n\t}\n\n\t// Update plugin, should fail because it is not implemented\n\tif err := Update(i); err == nil {\n\t\tt.Fatal(\"update method not implemented for http installer\")\n\t}\n}\n\nfunc TestExtract(t *testing.T) {\n\tsource := \"https://repo.localdomain/plugins/fake-plugin-0.0.1.tar.gz\"\n\n\ttempDir, err := ioutil.TempDir(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Set the umask to default open permissions so we can actually test\n\toldmask := syscall.Umask(0000)\n\tdefer func() {\n\t\tsyscall.Umask(oldmask)\n\t}()\n\n\t// Write a tarball to a buffer for us to extract\n\tvar tarbuf bytes.Buffer\n\ttw := tar.NewWriter(&tarbuf)\n\tvar files = []struct {\n\t\tName, Body string\n\t\tMode       int64\n\t}{\n\t\t{\"plugin.yaml\", \"plugin metadata\", 0600},\n\t\t{\"README.md\", \"some text\", 0777},\n\t}\n\tfor _, file := range files {\n\t\thdr := &tar.Header{\n\t\t\tName:     file.Name,\n\t\t\tTypeflag: tar.TypeReg,\n\t\t\tMode:     file.Mode,\n\t\t\tSize:     int64(len(file.Body)),\n\t\t}\n\t\tif err := tw.WriteHeader(hdr); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := tw.Write([]byte(file.Body)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Add pax global headers. This should be ignored.\n\t// Note the PAX header that isn't global cannot be written using WriteHeader.\n\t// Details are in the internal Go function for the tar packaged named\n\t// allowedFormats. For a TypeXHeader it will return a message stating\n\t// \"cannot manually encode TypeXHeader, TypeGNULongName, or TypeGNULongLink headers\"\n\tif err := tw.WriteHeader(&tar.Header{\n\t\tName:     \"pax_global_header\",\n\t\tTypeflag: tar.TypeXGlobalHeader,\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := tw.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar buf bytes.Buffer\n\tgz := gzip.NewWriter(&buf)\n\tif _, err := gz.Write(tarbuf.Bytes()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgz.Close()\n\t// END tarball creation\n\n\textractor, err := NewExtractor(source)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = extractor.Extract(&buf, tempDir); err != nil {\n\t\tt.Fatalf(\"Did not expect error but got error: %v\", err)\n\t}\n\n\tpluginYAMLFullPath := filepath.Join(tempDir, \"plugin.yaml\")\n\tif info, err := os.Stat(pluginYAMLFullPath); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"Expected %s to exist but doesn't\", pluginYAMLFullPath)\n\t\t}\n\t\tt.Fatal(err)\n\t} else if info.Mode().Perm() != 0600 {\n\t\tt.Fatalf(\"Expected %s to have 0600 mode it but has %o\", pluginYAMLFullPath, info.Mode().Perm())\n\t}\n\n\treadmeFullPath := filepath.Join(tempDir, \"README.md\")\n\tif info, err := os.Stat(readmeFullPath); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"Expected %s to exist but doesn't\", readmeFullPath)\n\t\t}\n\t\tt.Fatal(err)\n\t} else if info.Mode().Perm() != 0777 {\n\t\tt.Fatalf(\"Expected %s to have 0777 mode it but has %o\", readmeFullPath, info.Mode().Perm())\n\t}\n\n}\n\nfunc TestCleanJoin(t *testing.T) {\n\tfor i, fixture := range []struct {\n\t\tpath        string\n\t\texpect      string\n\t\texpectError bool\n\t}{\n\t\t{\"foo/bar.txt\", \"/tmp/foo/bar.txt\", false},\n\t\t{\"/foo/bar.txt\", \"\", true},\n\t\t{\"./foo/bar.txt\", \"/tmp/foo/bar.txt\", false},\n\t\t{\"./././././foo/bar.txt\", \"/tmp/foo/bar.txt\", false},\n\t\t{\"../../../../foo/bar.txt\", \"\", true},\n\t\t{\"foo/../../../../bar.txt\", \"\", true},\n\t\t{\"c:/foo/bar.txt\", \"/tmp/c:/foo/bar.txt\", true},\n\t\t{\"foo\\\\bar.txt\", \"/tmp/foo/bar.txt\", false},\n\t\t{\"c:\\\\foo\\\\bar.txt\", \"\", true},\n\t} {\n\t\tout, err := cleanJoin(\"/tmp\", fixture.path)\n\t\tif err != nil {\n\t\t\tif !fixture.expectError {\n\t\t\t\tt.Errorf(\"Test %d: Path was not cleaned: %s\", i, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif fixture.expect != out {\n\t\t\tt.Errorf(\"Test %d: Expected %q but got %q\", i, fixture.expect, out)\n\t\t}\n\t}\n\n}\n"], "filenames": ["pkg/plugin/installer/http_installer.go", "pkg/plugin/installer/http_installer_test.go"], "buggy_code_start_loc": [23, 279], "buggy_code_end_loc": [175, 279], "fixing_code_start_loc": [24, 280], "fixing_code_end_loc": [232, 310], "type": "CWE-22", "message": "In Helm greater than or equal to 3.0.0 and less than 3.2.4, a path traversal attack is possible when installing Helm plugins from a tar archive over HTTP. It is possible for a malicious plugin author to inject a relative path into a plugin archive, and copy a file outside of the intended directory. This has been fixed in 3.2.4.", "other": {"cve": {"id": "CVE-2020-4053", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-16T22:15:10.597", "lastModified": "2020-07-06T16:47:18.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Helm greater than or equal to 3.0.0 and less than 3.2.4, a path traversal attack is possible when installing Helm plugins from a tar archive over HTTP. It is possible for a malicious plugin author to inject a relative path into a plugin archive, and copy a file outside of the intended directory. This has been fixed in 3.2.4."}, {"lang": "es", "value": "En Helm versiones superiores o iguales a 3.0.0 y menores a 3.2.4, es posible un ataque de salto de ruta al instalar plugins de Helm desde un archivo tar por medio de HTTP. Es posible que un autor de plugin malicioso inyecte una ruta relativa en un archivo de plugin y copie un archivo fuera del directorio previsto. Esto se ha corregido en la versi\u00f3n 3.2.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 8.5}, "baseSeverity": "HIGH", "exploitabilityScore": 6.8, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.2.4", "matchCriteriaId": "F90E5468-5EE9-4943-ACCF-2E1F6BC013ED"}]}]}], "references": [{"url": "https://github.com/helm/helm/commit/0ad800ef43d3b826f31a5ad8dfbb4fe05d143688", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/helm/helm/releases/tag/v3.2.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/helm/helm/security/advisories/GHSA-qq3j-xp49-j73f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/helm/helm/commit/0ad800ef43d3b826f31a5ad8dfbb4fe05d143688"}}