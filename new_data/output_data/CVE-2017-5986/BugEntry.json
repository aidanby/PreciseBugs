{"buggy_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2003 Intel Corp.\n * Copyright (c) 2001-2002 Nokia, Inc.\n * Copyright (c) 2001 La Monte H.P. Yarroll\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions interface with the sockets layer to implement the\n * SCTP Extensions for the Sockets API.\n *\n * Note that the descriptions from the specification are USER level\n * functions--this file is the functions which populate the struct proto\n * for SCTP which is the BOTTOM of the sockets interface.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Narasimha Budihal     <narsi@refcode.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Xingang Guo           <xingang.guo@intel.com>\n *    Daisy Chang           <daisyc@us.ibm.com>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Inaky Perez-Gonzalez  <inaky.gonzalez@intel.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Anup Pemmaiah         <pemmaiah@cc.usu.edu>\n *    Kevin Gao             <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/ip.h>\n#include <linux/capability.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/compat.h>\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/busy_poll.h>\n\n#include <linux/socket.h> /* for sa_family_t */\n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n/* Forward declarations for internal helper functions. */\nstatic int sctp_writeable(struct sock *sk);\nstatic void sctp_wfree(struct sk_buff *skb);\nstatic int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,\n\t\t\t\tsize_t msg_len);\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);\nstatic int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo);\nstatic void sctp_wait_for_close(struct sock *sk, long timeo);\nstatic void sctp_destruct_sock(struct sock *sk);\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len);\nstatic int sctp_bindx_add(struct sock *, struct sockaddr *, int);\nstatic int sctp_bindx_rem(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_add_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_del_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk);\nstatic int sctp_do_bind(struct sock *, union sctp_addr *, int);\nstatic int sctp_autobind(struct sock *sk);\nstatic void sctp_sock_migrate(struct sock *, struct sock *,\n\t\t\t      struct sctp_association *, sctp_socket_type_t);\n\nstatic int sctp_memory_pressure;\nstatic atomic_long_t sctp_memory_allocated;\nstruct percpu_counter sctp_sockets_allocated;\n\nstatic void sctp_enter_memory_pressure(struct sock *sk)\n{\n\tsctp_memory_pressure = 1;\n}\n\n\n/* Get the sndbuf space available at the time on the association.  */\nstatic inline int sctp_wspace(struct sctp_association *asoc)\n{\n\tint amt;\n\n\tif (asoc->ep->sndbuf_policy)\n\t\tamt = asoc->sndbuf_used;\n\telse\n\t\tamt = sk_wmem_alloc_get(asoc->base.sk);\n\n\tif (amt >= asoc->base.sk->sk_sndbuf) {\n\t\tif (asoc->base.sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\t\tamt = 0;\n\t\telse {\n\t\t\tamt = sk_stream_wspace(asoc->base.sk);\n\t\t\tif (amt < 0)\n\t\t\t\tamt = 0;\n\t\t}\n\t} else {\n\t\tamt = asoc->base.sk->sk_sndbuf - amt;\n\t}\n\treturn amt;\n}\n\n/* Increment the used sndbuf space count of the corresponding association by\n * the size of the outgoing data chunk.\n * Also, set the skb destructor for sndbuf accounting later.\n *\n * Since it is always 1-1 between chunk and skb, and also a new skb is always\n * allocated for chunk bundling in sctp_packet_transmit(), we can use the\n * destructor in the data chunk skb for the purpose of the sndbuf space\n * tracking.\n */\nstatic inline void sctp_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\t/* The sndbuf space is tracked per association.  */\n\tsctp_association_hold(asoc);\n\n\tskb_set_owner_w(chunk->skb, sk);\n\n\tchunk->skb->destructor = sctp_wfree;\n\t/* Save the chunk pointer in skb for sctp_wfree to use later.  */\n\tskb_shinfo(chunk->skb)->destructor_arg = chunk;\n\n\tasoc->sndbuf_used += SCTP_DATA_SNDSIZE(chunk) +\n\t\t\t\tsizeof(struct sk_buff) +\n\t\t\t\tsizeof(struct sctp_chunk);\n\n\tatomic_add(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\tsk->sk_wmem_queued += chunk->skb->truesize;\n\tsk_mem_charge(sk, chunk->skb->truesize);\n}\n\n/* Verify that this is a valid address. */\nstatic inline int sctp_verify_addr(struct sock *sk, union sctp_addr *addr,\n\t\t\t\t   int len)\n{\n\tstruct sctp_af *af;\n\n\t/* Verify basic sockaddr. */\n\taf = sctp_sockaddr_af(sctp_sk(sk), addr, len);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\t/* Is this a valid SCTP address?  */\n\tif (!af->addr_valid(addr, sctp_sk(sk), NULL))\n\t\treturn -EINVAL;\n\n\tif (!sctp_sk(sk)->pf->send_verify(sctp_sk(sk), (addr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* Look up the association by its id.  If this is not a UDP-style\n * socket, the ID field is always ignored.\n */\nstruct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)\n{\n\tstruct sctp_association *asoc = NULL;\n\n\t/* If this is not a UDP-style socket, assoc id should be ignored. */\n\tif (!sctp_style(sk, UDP)) {\n\t\t/* Return NULL if the socket state is not ESTABLISHED. It\n\t\t * could be a TCP-style listening socket or a socket which\n\t\t * hasn't yet called connect() to establish an association.\n\t\t */\n\t\tif (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))\n\t\t\treturn NULL;\n\n\t\t/* Get the first and the only association from the list. */\n\t\tif (!list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tasoc = list_entry(sctp_sk(sk)->ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\treturn asoc;\n\t}\n\n\t/* Otherwise this is a UDP-style socket. */\n\tif (!id || (id == (sctp_assoc_t)-1))\n\t\treturn NULL;\n\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\tasoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\n\tif (!asoc || (asoc->base.sk != sk) || asoc->base.dead)\n\t\treturn NULL;\n\n\treturn asoc;\n}\n\n/* Look up the transport from an address and an assoc id. If both address and\n * id are specified, the associations matching the address and the id should be\n * the same.\n */\nstatic struct sctp_transport *sctp_addr_id2transport(struct sock *sk,\n\t\t\t\t\t      struct sockaddr_storage *addr,\n\t\t\t\t\t      sctp_assoc_t id)\n{\n\tstruct sctp_association *addr_asoc = NULL, *id_asoc = NULL;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->ss_family);\n\tunion sctp_addr *laddr = (union sctp_addr *)addr;\n\tstruct sctp_transport *transport;\n\n\tif (sctp_verify_addr(sk, laddr, af->sockaddr_len))\n\t\treturn NULL;\n\n\taddr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)->ep,\n\t\t\t\t\t       laddr,\n\t\t\t\t\t       &transport);\n\n\tif (!addr_asoc)\n\t\treturn NULL;\n\n\tid_asoc = sctp_id2assoc(sk, id);\n\tif (id_asoc && (id_asoc != addr_asoc))\n\t\treturn NULL;\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t\t\t\t\t(union sctp_addr *)addr);\n\n\treturn transport;\n}\n\n/* API 3.1.2 bind() - UDP Style Syntax\n * The syntax of bind() is,\n *\n *   ret = bind(int sd, struct sockaddr *addr, int addrlen);\n *\n *   sd      - the socket descriptor returned by socket().\n *   addr    - the address structure (struct sockaddr_in or struct\n *             sockaddr_in6 [RFC 2553]),\n *   addr_len - the size of the address structure.\n */\nstatic int sctp_bind(struct sock *sk, struct sockaddr *addr, int addr_len)\n{\n\tint retval = 0;\n\n\tlock_sock(sk);\n\n\tpr_debug(\"%s: sk:%p, addr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t/* Disallow binding twice. */\n\tif (!sctp_sk(sk)->ep->base.bind_addr.port)\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)addr,\n\t\t\t\t      addr_len);\n\telse\n\t\tretval = -EINVAL;\n\n\trelease_sock(sk);\n\n\treturn retval;\n}\n\nstatic long sctp_get_port_local(struct sock *, union sctp_addr *);\n\n/* Verify this is a valid sockaddr. */\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len)\n{\n\tstruct sctp_af *af;\n\n\t/* Check minimum size.  */\n\tif (len < sizeof (struct sockaddr))\n\t\treturn NULL;\n\n\t/* V4 mapped address are really of AF_INET family */\n\tif (addr->sa.sa_family == AF_INET6 &&\n\t    ipv6_addr_v4mapped(&addr->v6.sin6_addr)) {\n\t\tif (!opt->pf->af_supported(AF_INET, opt))\n\t\t\treturn NULL;\n\t} else {\n\t\t/* Does this PF support this AF? */\n\t\tif (!opt->pf->af_supported(addr->sa.sa_family, opt))\n\t\t\treturn NULL;\n\t}\n\n\t/* If we get this far, af is valid. */\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\n\tif (len < af->sockaddr_len)\n\t\treturn NULL;\n\n\treturn af;\n}\n\n/* Bind a local address either to an endpoint or to an association.  */\nstatic int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tstruct sctp_af *af;\n\tunsigned short snum;\n\tint ret = 0;\n\n\t/* Common sockaddr verification. */\n\taf = sctp_sockaddr_af(sp, addr, len);\n\tif (!af) {\n\t\tpr_debug(\"%s: sk:%p, newaddr:%p, len:%d EINVAL\\n\",\n\t\t\t __func__, sk, addr, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: sk:%p, new addr:%pISc, port:%d, new port:%d, len:%d\\n\",\n\t\t __func__, sk, &addr->sa, bp->port, snum, len);\n\n\t/* PF specific bind() address verification. */\n\tif (!sp->pf->bind_verify(sp, addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* We must either be unbound, or bind to the same port.\n\t * It's OK to allow 0 ports if we are already bound.\n\t * We'll just inhert an already bound port in this case\n\t */\n\tif (bp->port) {\n\t\tif (!snum)\n\t\t\tsnum = bp->port;\n\t\telse if (snum != bp->port) {\n\t\t\tpr_debug(\"%s: new port %d doesn't match existing port \"\n\t\t\t\t \"%d\\n\", __func__, snum, bp->port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (snum && snum < PROT_SOCK &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t/* See if the address matches any of the addresses we may have\n\t * already bound before checking against other endpoints.\n\t */\n\tif (sctp_bind_addr_match(bp, addr, sp))\n\t\treturn -EINVAL;\n\n\t/* Make sure we are allowed to bind here.\n\t * The function sctp_get_port_local() does duplicate address\n\t * detection.\n\t */\n\taddr->v4.sin_port = htons(snum);\n\tif ((ret = sctp_get_port_local(sk, addr))) {\n\t\treturn -EADDRINUSE;\n\t}\n\n\t/* Refresh ephemeral port.  */\n\tif (!bp->port)\n\t\tbp->port = inet_sk(sk)->inet_num;\n\n\t/* Add the address to the bind address list.\n\t * Use GFP_ATOMIC since BHs will be disabled.\n\t */\n\tret = sctp_add_bind_addr(bp, addr, af->sockaddr_len,\n\t\t\t\t SCTP_ADDR_SRC, GFP_ATOMIC);\n\n\t/* Copy back into socket for getsockname() use. */\n\tif (!ret) {\n\t\tinet_sk(sk)->inet_sport = htons(inet_sk(sk)->inet_num);\n\t\tsp->pf->to_sk_saddr(addr, sk);\n\t}\n\n\treturn ret;\n}\n\n /* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks\n *\n * R1) One and only one ASCONF Chunk MAY be in transit and unacknowledged\n * at any one time.  If a sender, after sending an ASCONF chunk, decides\n * it needs to transfer another ASCONF Chunk, it MUST wait until the\n * ASCONF-ACK Chunk returns from the previous ASCONF Chunk before sending a\n * subsequent ASCONF. Note this restriction binds each side, so at any\n * time two ASCONF may be in-transit on any given association (one sent\n * from each endpoint).\n */\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct net \t*net = sock_net(asoc->base.sk);\n\tint\t\tretval = 0;\n\n\t/* If there is an outstanding ASCONF chunk, queue it for later\n\t * transmission.\n\t */\n\tif (asoc->addip_last_asconf) {\n\t\tlist_add_tail(&chunk->list, &asoc->addip_chunk_list);\n\t\tgoto out;\n\t}\n\n\t/* Hold the chunk until an ASCONF_ACK is received. */\n\tsctp_chunk_hold(chunk);\n\tretval = sctp_primitive_ASCONF(net, asoc, chunk);\n\tif (retval)\n\t\tsctp_chunk_free(chunk);\n\telse\n\t\tasoc->addip_last_asconf = chunk;\n\nout:\n\treturn retval;\n}\n\n/* Add a list of addresses as bind addresses to local endpoint or\n * association.\n *\n * Basically run through each address specified in the addrs/addrcnt\n * array/length pair, determine if it is IPv6 or IPv4 and call\n * sctp_do_bind() on it.\n *\n * If any of them fails, then the operation will be reversed and the\n * ones that were added will be removed.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_bindx_add(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tint cnt;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tstruct sockaddr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\", __func__, sk,\n\t\t addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t/* The list may contain either IPv4 or IPv6 address;\n\t\t * determine the address length for walking thru the list.\n\t\t */\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_add;\n\t\t}\n\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)sa_addr,\n\t\t\t\t      af->sockaddr_len);\n\n\t\taddr_buf += af->sockaddr_len;\n\nerr_bindx_add:\n\t\tif (retval < 0) {\n\t\t\t/* Failed. Cleanup the ones that have been added */\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_rem(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n/* Send an ASCONF chunk with Add IP address parameters to all the peers of the\n * associations that are part of the endpoint indicating that a list of local\n * addresses are added to the endpoint.\n *\n * If any of the addresses is already in the bind address list of the\n * association, we do not send the chunk for that association.  But it will not\n * affect other associations.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_send_asconf_add_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int \t\t\taddrcnt)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock\t\t*sp;\n\tstruct sctp_endpoint\t\t*ep;\n\tstruct sctp_association\t\t*asoc;\n\tstruct sctp_bind_addr\t\t*bp;\n\tstruct sctp_chunk\t\t*chunk;\n\tstruct sctp_sockaddr_entry\t*laddr;\n\tunion sctp_addr\t\t\t*addr;\n\tunion sctp_addr\t\t\tsaveaddr;\n\tvoid\t\t\t\t*addr_buf;\n\tstruct sctp_af\t\t\t*af;\n\tstruct list_head\t\t*p;\n\tint \t\t\t\ti;\n\tint \t\t\t\tretval = 0;\n\n\tif (!net->sctp.addip_enable)\n\t\treturn retval;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_ADD_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * in the bind address list of the association. If so,\n\t\t * do not send the asconf chunk to its peer, but continue with\n\t\t * other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sctp_assoc_lookup_laddr(asoc, addr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Use the first valid address in bind addr list of\n\t\t * association as Address Parameter of ASCONF CHUNK.\n\t\t */\n\t\tbp = &asoc->base.bind_addr;\n\t\tp = bp->address_list.next;\n\t\tladdr = list_entry(p, struct sctp_sockaddr_entry, list);\n\t\tchunk = sctp_make_asconf_update_ip(asoc, &laddr->a, addrs,\n\t\t\t\t\t\t   addrcnt, SCTP_PARAM_ADD_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Add the new addresses to the bind address list with\n\t\t * use_as_src set to 0.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tmemcpy(&saveaddr, addr, af->sockaddr_len);\n\t\t\tretval = sctp_add_bind_addr(bp, &saveaddr,\n\t\t\t\t\t\t    sizeof(saveaddr),\n\t\t\t\t\t\t    SCTP_ADDR_NEW, GFP_ATOMIC);\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (asoc->src_out_of_asoc_ok) {\n\t\t\tstruct sctp_transport *trans;\n\n\t\t\tlist_for_each_entry(trans,\n\t\t\t    &asoc->peer.transport_addr_list, transports) {\n\t\t\t\t/* Clear the source and route cache */\n\t\t\t\tdst_release(trans->dst);\n\t\t\t\ttrans->cwnd = min(4*asoc->pathmtu, max_t(__u32,\n\t\t\t\t    2*asoc->pathmtu, 4380));\n\t\t\t\ttrans->ssthresh = asoc->peer.i.a_rwnd;\n\t\t\t\ttrans->rto = asoc->rto_initial;\n\t\t\t\tsctp_max_rto(asoc, trans);\n\t\t\t\ttrans->rtt = trans->srtt = trans->rttvar = 0;\n\t\t\t\tsctp_transport_route(trans, NULL,\n\t\t\t\t    sctp_sk(asoc->base.sk));\n\t\t\t}\n\t\t}\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\n\nout:\n\treturn retval;\n}\n\n/* Remove a list of addresses from bind addresses list.  Do not remove the\n * last address.\n *\n * Basically run through each address specified in the addrs/addrcnt\n * array/length pair, determine if it is IPv6 or IPv4 and call\n * sctp_del_bind() on it.\n *\n * If any of them fails, then the operation will be reversed and the\n * ones that were removed will be added back.\n *\n * At least one address has to be left; if only one address is\n * available, the operation will return -EBUSY.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t/* If the bind address list is empty or if there is only one\n\t\t * bind address, there is nothing more to be removed (we need\n\t\t * at least one address here).\n\t\t */\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (sa_addr->v4.sin_port &&\n\t\t    sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!sa_addr->v4.sin_port)\n\t\t\tsa_addr->v4.sin_port = htons(bp->port);\n\n\t\t/* FIXME - There is probably a need to check if sk->sk_saddr and\n\t\t * sk->sk_rcv_addr are currently set to one of the addresses to\n\t\t * be removed. This is something which needs to be looked into\n\t\t * when we are fixing the outstanding issues with multi-homing\n\t\t * socket routing and failover schemes. Refer to comments in\n\t\t * sctp_do_bind(). -daisy\n\t\t */\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\t/* Failed. Add the ones that has been removed back */\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n/* Send an ASCONF chunk with Delete IP address parameters to all the peers of\n * the associations that are part of the endpoint indicating that a list of\n * local addresses are removed from the endpoint.\n *\n * If any of the addresses is already in the bind address list of the\n * association, we do not send the chunk for that association.  But it will not\n * affect other associations.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_send_asconf_del_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int\t\t\taddrcnt)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_endpoint\t*ep;\n\tstruct sctp_association\t*asoc;\n\tstruct sctp_transport\t*transport;\n\tstruct sctp_bind_addr\t*bp;\n\tstruct sctp_chunk\t*chunk;\n\tunion sctp_addr\t\t*laddr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tstruct sctp_sockaddr_entry *saddr;\n\tint \t\t\ti;\n\tint \t\t\tretval = 0;\n\tint\t\t\tstored = 0;\n\n\tchunk = NULL;\n\tif (!net->sctp.addip_enable)\n\t\treturn retval;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_DEL_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * not present in the bind address list of the association.\n\t\t * If so, do not send the asconf chunk to its peer, but\n\t\t * continue with other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!sctp_assoc_lookup_laddr(asoc, laddr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Find one address in the association's bind address list\n\t\t * that is not in the packed array of addresses. This is to\n\t\t * make sure that we do not delete all the addresses in the\n\t\t * association.\n\t\t */\n\t\tbp = &asoc->base.bind_addr;\n\t\tladdr = sctp_find_unmatch_addr(bp, (union sctp_addr *)addrs,\n\t\t\t\t\t       addrcnt, sp);\n\t\tif ((laddr == NULL) && (addrcnt == 1)) {\n\t\t\tif (asoc->asconf_addr_del_pending)\n\t\t\t\tcontinue;\n\t\t\tasoc->asconf_addr_del_pending =\n\t\t\t    kzalloc(sizeof(union sctp_addr), GFP_ATOMIC);\n\t\t\tif (asoc->asconf_addr_del_pending == NULL) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tasoc->asconf_addr_del_pending->sa.sa_family =\n\t\t\t\t    addrs->sa_family;\n\t\t\tasoc->asconf_addr_del_pending->v4.sin_port =\n\t\t\t\t    htons(bp->port);\n\t\t\tif (addrs->sa_family == AF_INET) {\n\t\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t\tsin = (struct sockaddr_in *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v4.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\t} else if (addrs->sa_family == AF_INET6) {\n\t\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\t\tsin6 = (struct sockaddr_in6 *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v6.sin6_addr = sin6->sin6_addr;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s: keep the last address asoc:%p %pISc at %p\\n\",\n\t\t\t\t __func__, asoc, &asoc->asconf_addr_del_pending->sa,\n\t\t\t\t asoc->asconf_addr_del_pending);\n\n\t\t\tasoc->src_out_of_asoc_ok = 1;\n\t\t\tstored = 1;\n\t\t\tgoto skip_mkasconf;\n\t\t}\n\n\t\tif (laddr == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t/* We do not need RCU protection throughout this loop\n\t\t * because this is done under a socket lock from the\n\t\t * setsockopt call.\n\t\t */\n\t\tchunk = sctp_make_asconf_update_ip(asoc, laddr, addrs, addrcnt,\n\t\t\t\t\t\t   SCTP_PARAM_DEL_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\nskip_mkasconf:\n\t\t/* Reset use_as_src flag for the addresses in the bind address\n\t\t * list that are to be deleted.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\t\tif (sctp_cmp_addr_exact(&saddr->a, laddr))\n\t\t\t\t\tsaddr->state = SCTP_ADDR_DEL;\n\t\t\t}\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\n\t\t/* Update the route and saddr entries for all the transports\n\t\t * as some of the addresses in the bind address list are\n\t\t * about to be deleted and cannot be used as source addresses.\n\t\t */\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\tsctp_transport_route(transport, NULL,\n\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t}\n\n\t\tif (stored)\n\t\t\t/* We don't need to transmit ASCONF */\n\t\t\tcontinue;\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\nout:\n\treturn retval;\n}\n\n/* set addr events to assocs in the endpoint.  ep and addr_wq must be locked */\nint sctp_asconf_mgmt(struct sctp_sock *sp, struct sctp_sockaddr_entry *addrw)\n{\n\tstruct sock *sk = sctp_opt2sk(sp);\n\tunion sctp_addr *addr;\n\tstruct sctp_af *af;\n\n\t/* It is safe to write port space in caller. */\n\taddr = &addrw->a;\n\taddr->v4.sin_port = htons(sp->ep->base.bind_addr.port);\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\tif (sctp_verify_addr(sk, addr, af->sockaddr_len))\n\t\treturn -EINVAL;\n\n\tif (addrw->state == SCTP_ADDR_NEW)\n\t\treturn sctp_send_asconf_add_ip(sk, (struct sockaddr *)addr, 1);\n\telse\n\t\treturn sctp_send_asconf_del_ip(sk, (struct sockaddr *)addr, 1);\n}\n\n/* Helper for tunneling sctp_bindx() requests through sctp_setsockopt()\n *\n * API 8.1\n * int sctp_bindx(int sd, struct sockaddr *addrs, int addrcnt,\n *                int flags);\n *\n * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.\n * If the sd is an IPv6 socket, the addresses passed can either be IPv4\n * or IPv6 addresses.\n *\n * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see\n * Section 3.1.2 for this usage.\n *\n * addrs is a pointer to an array of one or more socket addresses. Each\n * address is contained in its appropriate structure (i.e. struct\n * sockaddr_in or struct sockaddr_in6) the family of the address type\n * must be used to distinguish the address length (note that this\n * representation is termed a \"packed array\" of addresses). The caller\n * specifies the number of addresses in the array with addrcnt.\n *\n * On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns\n * -1, and sets errno to the appropriate error code.\n *\n * For SCTP, the port given in each socket address must be the same, or\n * sctp_bindx() will fail, setting errno to EINVAL.\n *\n * The flags parameter is formed from the bitwise OR of zero or more of\n * the following currently defined flags:\n *\n * SCTP_BINDX_ADD_ADDR\n *\n * SCTP_BINDX_REM_ADDR\n *\n * SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the\n * association, and SCTP_BINDX_REM_ADDR directs SCTP to remove the given\n * addresses from the association. The two flags are mutually exclusive;\n * if both are given, sctp_bindx() will fail with EINVAL. A caller may\n * not remove all addresses from an association; sctp_bindx() will\n * reject such an attempt with EINVAL.\n *\n * An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate\n * additional addresses with an endpoint after calling bind().  Or use\n * sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses a listening\n * socket is associated with so that no new association accepted will be\n * associated with those addresses. If the endpoint supports dynamic\n * address a SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause a\n * endpoint to send the appropriate message to the peer to change the\n * peers address lists.\n *\n * Adding and removing addresses from a connected association is\n * optional functionality. Implementations that do not support this\n * functionality should return EOPNOTSUPP.\n *\n * Basically do nothing but copying the addresses from user to kernel\n * land and invoking either sctp_bindx_add() or sctp_bindx_rem() on the sk.\n * This is used for tunneling the sctp_bindx() request through sctp_setsockopt()\n * from userspace.\n *\n * We don't use copy_from_user() for optimization: we first do the\n * sanity checks (buffer size -fast- and access check-healthy\n * pointer); if all of those succeed, then we can alloc the memory\n * (expensive operation) needed to copy the data to kernel. Then we do\n * the copying without checking the user space area\n * (__copy_from_user()).\n *\n * On exit there is no need to do sockfd_put(), sys_setsockopt() does\n * it.\n *\n * sk        The sk of the socket\n * addrs     The pointer to the addresses in user land\n * addrssize Size of the addrs buffer\n * op        Operation to perform (add or remove, see the flags of\n *           sctp_bindx)\n *\n * Returns 0 if ok, <0 errno code on error.\n */\nstatic int sctp_setsockopt_bindx(struct sock *sk,\n\t\t\t\t struct sockaddr __user *addrs,\n\t\t\t\t int addrs_size, int op)\n{\n\tstruct sockaddr *kaddrs;\n\tint err;\n\tint addrcnt = 0;\n\tint walk_size = 0;\n\tstruct sockaddr *sa_addr;\n\tvoid *addr_buf;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d opt:%d\\n\",\n\t\t __func__, sk, addrs, addrs_size, op);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t/* Check the user passed a healthy pointer.  */\n\tif (unlikely(!access_ok(VERIFY_READ, addrs, addrs_size)))\n\t\treturn -EFAULT;\n\n\t/* Alloc space for the address array in kernel memory.  */\n\tkaddrs = kmalloc(addrs_size, GFP_USER | __GFP_NOWARN);\n\tif (unlikely(!kaddrs))\n\t\treturn -ENOMEM;\n\n\tif (__copy_from_user(kaddrs, addrs, addrs_size)) {\n\t\tkfree(kaddrs);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Walk through the addrs buffer and count the number of addresses. */\n\taddr_buf = kaddrs;\n\twhile (walk_size < addrs_size) {\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size) {\n\t\t\tkfree(kaddrs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\n\t\t/* If the address family is not supported or if this address\n\t\t * causes the address buffer to overflow return EINVAL.\n\t\t */\n\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size) {\n\t\t\tkfree(kaddrs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddrcnt++;\n\t\taddr_buf += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t/* Do the work. */\n\tswitch (op) {\n\tcase SCTP_BINDX_ADD_ADDR:\n\t\terr = sctp_bindx_add(sk, kaddrs, addrcnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = sctp_send_asconf_add_ip(sk, kaddrs, addrcnt);\n\t\tbreak;\n\n\tcase SCTP_BINDX_REM_ADDR:\n\t\terr = sctp_bindx_rem(sk, kaddrs, addrcnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = sctp_send_asconf_del_ip(sk, kaddrs, addrcnt);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(kaddrs);\n\n\treturn err;\n}\n\n/* __sctp_connect(struct sock* sk, struct sockaddr *kaddrs, int addrs_size)\n *\n * Common routine for handling connect() and sctp_connectx().\n * Connect will come in with just a single address.\n */\nstatic int __sctp_connect(struct sock *sk,\n\t\t\t  struct sockaddr *kaddrs,\n\t\t\t  int addrs_size,\n\t\t\t  sctp_assoc_t *assoc_id)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_association *asoc2;\n\tstruct sctp_transport *transport;\n\tunion sctp_addr to;\n\tsctp_scope_t scope;\n\tlong timeo;\n\tint err = 0;\n\tint addrcnt = 0;\n\tint walk_size = 0;\n\tunion sctp_addr *sa_addr = NULL;\n\tvoid *addr_buf;\n\tunsigned short port;\n\tunsigned int f_flags = 0;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\t/* connect() cannot be done on a socket that is already in ESTABLISHED\n\t * state - UDP-style peeled off socket or a TCP-style socket that\n\t * is already connected.\n\t * It cannot be done even on a TCP-style listening socket.\n\t */\n\tif (sctp_sstate(sk, ESTABLISHED) || sctp_sstate(sk, CLOSING) ||\n\t    (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))) {\n\t\terr = -EISCONN;\n\t\tgoto out_free;\n\t}\n\n\t/* Walk through the addrs buffer and count the number of addresses. */\n\taddr_buf = kaddrs;\n\twhile (walk_size < addrs_size) {\n\t\tstruct sctp_af *af;\n\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\n\t\t/* If the address family is not supported or if this address\n\t\t * causes the address buffer to overflow return EINVAL.\n\t\t */\n\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tport = ntohs(sa_addr->v4.sin_port);\n\n\t\t/* Save current address so we can work with it */\n\t\tmemcpy(&to, sa_addr, af->sockaddr_len);\n\n\t\terr = sctp_verify_addr(sk, &to, af->sockaddr_len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\t/* Make sure the destination port is correctly set\n\t\t * in all addresses.\n\t\t */\n\t\tif (asoc && asoc->peer.port && asoc->peer.port != port) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* Check if there already is a matching association on the\n\t\t * endpoint (other than the one created here).\n\t\t */\n\t\tasoc2 = sctp_endpoint_lookup_assoc(ep, &to, &transport);\n\t\tif (asoc2 && asoc2 != asoc) {\n\t\t\tif (asoc2->state >= SCTP_STATE_ESTABLISHED)\n\t\t\t\terr = -EISCONN;\n\t\t\telse\n\t\t\t\terr = -EALREADY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* If we could not find a matching association on the endpoint,\n\t\t * make sure that there is no peeled-off association matching\n\t\t * the peer address even on another socket.\n\t\t */\n\t\tif (sctp_endpoint_is_peeled_off(ep, &to)) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (!asoc) {\n\t\t\t/* If a bind() or sctp_bindx() is not called prior to\n\t\t\t * an sctp_connectx() call, the system picks an\n\t\t\t * ephemeral port and will choose an address set\n\t\t\t * equivalent to binding with a wildcard address.\n\t\t\t */\n\t\t\tif (!ep->base.bind_addr.port) {\n\t\t\t\tif (sctp_autobind(sk)) {\n\t\t\t\t\terr = -EAGAIN;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If an unprivileged user inherits a 1-many\n\t\t\t\t * style socket with open associations on a\n\t\t\t\t * privileged port, it MAY be permitted to\n\t\t\t\t * accept new associations, but it SHOULD NOT\n\t\t\t\t * be permitted to open new associations.\n\t\t\t\t */\n\t\t\t\tif (ep->base.bind_addr.port < PROT_SOCK &&\n\t\t\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE)) {\n\t\t\t\t\terr = -EACCES;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscope = sctp_scope(&to);\n\t\t\tasoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);\n\t\t\tif (!asoc) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (err < 0) {\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t}\n\n\t\t/* Prime the peer's transport structures.  */\n\t\ttransport = sctp_assoc_add_peer(asoc, &to, GFP_KERNEL,\n\t\t\t\t\t\tSCTP_UNKNOWN);\n\t\tif (!transport) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\taddrcnt++;\n\t\taddr_buf += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t/* In case the user of sctp_connectx() wants an association\n\t * id back, assign one now.\n\t */\n\tif (assoc_id) {\n\t\terr = sctp_assoc_set_id(asoc, GFP_KERNEL);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t}\n\n\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);\n\tif (err < 0) {\n\t\tgoto out_free;\n\t}\n\n\t/* Initialize sk's dport and daddr for getpeername() */\n\tinet_sk(sk)->inet_dport = htons(asoc->peer.port);\n\tsp->pf->to_sk_daddr(sa_addr, sk);\n\tsk->sk_err = 0;\n\n\t/* in-kernel sockets don't generally have a file allocated to them\n\t * if all they do is call sock_create_kern().\n\t */\n\tif (sk->sk_socket->file)\n\t\tf_flags = sk->sk_socket->file->f_flags;\n\n\ttimeo = sock_sndtimeo(sk, f_flags & O_NONBLOCK);\n\n\tif (assoc_id)\n\t\t*assoc_id = asoc->assoc_id;\n\terr = sctp_wait_for_connect(asoc, &timeo);\n\t/* Note: the asoc may be freed after the return of\n\t * sctp_wait_for_connect.\n\t */\n\n\t/* Don't free association on exit. */\n\tasoc = NULL;\n\nout_free:\n\tpr_debug(\"%s: took out_free path with asoc:%p kaddrs:%p err:%d\\n\",\n\t\t __func__, asoc, kaddrs, err);\n\n\tif (asoc) {\n\t\t/* sctp_primitive_ASSOCIATE may have added this association\n\t\t * To the hash table, try to unhash it, just in case, its a noop\n\t\t * if it wasn't hashed so we're safe\n\t\t */\n\t\tsctp_association_free(asoc);\n\t}\n\treturn err;\n}\n\n/* Helper for tunneling sctp_connectx() requests through sctp_setsockopt()\n *\n * API 8.9\n * int sctp_connectx(int sd, struct sockaddr *addrs, int addrcnt,\n * \t\t\tsctp_assoc_t *asoc);\n *\n * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.\n * If the sd is an IPv6 socket, the addresses passed can either be IPv4\n * or IPv6 addresses.\n *\n * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see\n * Section 3.1.2 for this usage.\n *\n * addrs is a pointer to an array of one or more socket addresses. Each\n * address is contained in its appropriate structure (i.e. struct\n * sockaddr_in or struct sockaddr_in6) the family of the address type\n * must be used to distengish the address length (note that this\n * representation is termed a \"packed array\" of addresses). The caller\n * specifies the number of addresses in the array with addrcnt.\n *\n * On success, sctp_connectx() returns 0. It also sets the assoc_id to\n * the association id of the new association.  On failure, sctp_connectx()\n * returns -1, and sets errno to the appropriate error code.  The assoc_id\n * is not touched by the kernel.\n *\n * For SCTP, the port given in each socket address must be the same, or\n * sctp_connectx() will fail, setting errno to EINVAL.\n *\n * An application can use sctp_connectx to initiate an association with\n * an endpoint that is multi-homed.  Much like sctp_bindx() this call\n * allows a caller to specify multiple addresses at which a peer can be\n * reached.  The way the SCTP stack uses the list of addresses to set up\n * the association is implementation dependent.  This function only\n * specifies that the stack will try to make use of all the addresses in\n * the list when needed.\n *\n * Note that the list of addresses passed in is only used for setting up\n * the association.  It does not necessarily equal the set of addresses\n * the peer uses for the resulting association.  If the caller wants to\n * find out the set of peer addresses, it must use sctp_getpaddrs() to\n * retrieve them after the association has been set up.\n *\n * Basically do nothing but copying the addresses from user to kernel\n * land and invoking either sctp_connectx(). This is used for tunneling\n * the sctp_connectx() request through sctp_setsockopt() from userspace.\n *\n * We don't use copy_from_user() for optimization: we first do the\n * sanity checks (buffer size -fast- and access check-healthy\n * pointer); if all of those succeed, then we can alloc the memory\n * (expensive operation) needed to copy the data to kernel. Then we do\n * the copying without checking the user space area\n * (__copy_from_user()).\n *\n * On exit there is no need to do sockfd_put(), sys_setsockopt() does\n * it.\n *\n * sk        The sk of the socket\n * addrs     The pointer to the addresses in user land\n * addrssize Size of the addrs buffer\n *\n * Returns >=0 if ok, <0 errno code on error.\n */\nstatic int __sctp_setsockopt_connectx(struct sock *sk,\n\t\t\t\t      struct sockaddr __user *addrs,\n\t\t\t\t      int addrs_size,\n\t\t\t\t      sctp_assoc_t *assoc_id)\n{\n\tstruct sockaddr *kaddrs;\n\tgfp_t gfp = GFP_KERNEL;\n\tint err = 0;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d\\n\",\n\t\t __func__, sk, addrs, addrs_size);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t/* Check the user passed a healthy pointer.  */\n\tif (unlikely(!access_ok(VERIFY_READ, addrs, addrs_size)))\n\t\treturn -EFAULT;\n\n\t/* Alloc space for the address array in kernel memory.  */\n\tif (sk->sk_socket->file)\n\t\tgfp = GFP_USER | __GFP_NOWARN;\n\tkaddrs = kmalloc(addrs_size, gfp);\n\tif (unlikely(!kaddrs))\n\t\treturn -ENOMEM;\n\n\tif (__copy_from_user(kaddrs, addrs, addrs_size)) {\n\t\terr = -EFAULT;\n\t} else {\n\t\terr = __sctp_connect(sk, kaddrs, addrs_size, assoc_id);\n\t}\n\n\tkfree(kaddrs);\n\n\treturn err;\n}\n\n/*\n * This is an older interface.  It's kept for backward compatibility\n * to the option that doesn't provide association id.\n */\nstatic int sctp_setsockopt_connectx_old(struct sock *sk,\n\t\t\t\t\tstruct sockaddr __user *addrs,\n\t\t\t\t\tint addrs_size)\n{\n\treturn __sctp_setsockopt_connectx(sk, addrs, addrs_size, NULL);\n}\n\n/*\n * New interface for the API.  The since the API is done with a socket\n * option, to make it simple we feed back the association id is as a return\n * indication to the call.  Error is always negative and association id is\n * always positive.\n */\nstatic int sctp_setsockopt_connectx(struct sock *sk,\n\t\t\t\t    struct sockaddr __user *addrs,\n\t\t\t\t    int addrs_size)\n{\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n\terr = __sctp_setsockopt_connectx(sk, addrs, addrs_size, &assoc_id);\n\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn assoc_id;\n}\n\n/*\n * New (hopefully final) interface for the API.\n * We use the sctp_getaddrs_old structure so that use-space library\n * can avoid any unnecessary allocations. The only different part\n * is that we store the actual length of the address buffer into the\n * addrs_num structure member. That way we can re-use the existing\n * code.\n */\n#ifdef CONFIG_COMPAT\nstruct compat_sctp_getaddrs_old {\n\tsctp_assoc_t\tassoc_id;\n\ts32\t\taddr_num;\n\tcompat_uptr_t\taddrs;\t\t/* struct sockaddr * */\n};\n#endif\n\nstatic int sctp_getsockopt_connectx3(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sctp_getaddrs_old param32;\n\n\t\tif (len < sizeof(param32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param32, optval, sizeof(param32)))\n\t\t\treturn -EFAULT;\n\n\t\tparam.assoc_id = param32.assoc_id;\n\t\tparam.addr_num = param32.addr_num;\n\t\tparam.addrs = compat_ptr(param32.addrs);\n\t} else\n#endif\n\t{\n\t\tif (len < sizeof(param))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = __sctp_setsockopt_connectx(sk, (struct sockaddr __user *)\n\t\t\t\t\t param.addrs, param.addr_num,\n\t\t\t\t\t &assoc_id);\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n/* API 3.1.4 close() - UDP Style Syntax\n * Applications use close() to perform graceful shutdown (as described in\n * Section 10.1 of [SCTP]) on ALL the associations currently represented\n * by a UDP-style socket.\n *\n * The syntax is\n *\n *   ret = close(int sd);\n *\n *   sd      - the socket descriptor of the associations to be closed.\n *\n * To gracefully shutdown a specific association represented by the\n * UDP-style socket, an application should use the sendmsg() call,\n * passing no user data, but including the appropriate flag in the\n * ancillary data (see Section xxxx).\n *\n * If sd in the close() call is a branched-off socket representing only\n * one association, the shutdown is performed on that association only.\n *\n * 4.1.6 close() - TCP Style Syntax\n *\n * Applications use close() to gracefully close down an association.\n *\n * The syntax is:\n *\n *    int close(int sd);\n *\n *      sd      - the socket descriptor of the association to be closed.\n *\n * After an application calls close() on a socket descriptor, no further\n * socket operations will succeed on that descriptor.\n *\n * API 7.1.4 SO_LINGER\n *\n * An application using the TCP-style socket can use this option to\n * perform the SCTP ABORT primitive.  The linger option structure is:\n *\n *  struct  linger {\n *     int     l_onoff;                // option on/off\n *     int     l_linger;               // linger time\n * };\n *\n * To enable the option, set l_onoff to 1.  If the l_linger value is set\n * to 0, calling close() is the same as the ABORT primitive.  If the\n * value is set to a negative value, the setsockopt() call will return\n * an error.  If the value is set to a positive value linger_time, the\n * close() can be blocked for at most linger_time ms.  If the graceful\n * shutdown phase does not finish during this period, close() will\n * return but the graceful shutdown phase continues in the system.\n */\nstatic void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_state = SCTP_SS_CLOSING;\n\n\tep = sctp_sk(sk)->ep;\n\n\t/* Clean up any skbs sitting on the receive queue.  */\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\n\t/* Walk all associations on an endpoint.  */\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\t/* A closed association can still be in the list if\n\t\t\t * it belongs to a TCP-style listening socket that is\n\t\t\t * not yet accepted. If so, free it. If not, send an\n\t\t\t * ABORT or SHUTDOWN based on the linger options.\n\t\t\t */\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\n\t/* On a TCP-style socket, block for at most linger_time if set. */\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t * Also, sctp_destroy_sock() needs to be called with addr_wq_lock\n\t * held and that should be grabbed before socket lock.\n\t */\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}\n\n/* Handle EPIPE error. */\nstatic int sctp_error(struct sock *sk, int flags, int err)\n{\n\tif (err == -EPIPE)\n\t\terr = sock_error(sk) ? : -EPIPE;\n\tif (err == -EPIPE && !(flags & MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\treturn err;\n}\n\n/* API 3.1.3 sendmsg() - UDP Style Syntax\n *\n * An application uses sendmsg() and recvmsg() calls to transmit data to\n * and receive data from its peer.\n *\n *  ssize_t sendmsg(int socket, const struct msghdr *message,\n *                  int flags);\n *\n *  socket  - the socket descriptor of the endpoint.\n *  message - pointer to the msghdr structure which contains a single\n *            user message and possibly some ancillary data.\n *\n *            See Section 5 for complete description of the data\n *            structures.\n *\n *  flags   - flags sent or received with the user message, see Section\n *            5 for complete description of the flags.\n *\n * Note:  This function could use a rewrite especially when explicit\n * connect support comes in.\n */\n/* BUG:  We do not implement the equivalent of sk_stream_wait_memory(). */\n\nstatic int sctp_msghdr_parse(const struct msghdr *, sctp_cmsgs_t *);\n\nstatic int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *new_asoc = NULL, *asoc = NULL;\n\tstruct sctp_transport *transport, *chunk_tp;\n\tstruct sctp_chunk *chunk;\n\tunion sctp_addr to;\n\tstruct sockaddr *msg_name = NULL;\n\tstruct sctp_sndrcvinfo default_sinfo;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tstruct sctp_initmsg *sinit;\n\tsctp_assoc_t associd = 0;\n\tsctp_cmsgs_t cmsgs = { NULL };\n\tsctp_scope_t scope;\n\tbool fill_sinfo_ttl = false, wait_connect = false;\n\tstruct sctp_datamsg *datamsg;\n\tint msg_flags = msg->msg_flags;\n\t__u16 sinfo_flags = 0;\n\tlong timeo;\n\tint err;\n\n\terr = 0;\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tpr_debug(\"%s: sk:%p, msg:%p, msg_len:%zu ep:%p\\n\", __func__, sk,\n\t\t msg, msg_len, ep);\n\n\t/* We cannot send a message over a TCP-style listening socket. */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING)) {\n\t\terr = -EPIPE;\n\t\tgoto out_nounlock;\n\t}\n\n\t/* Parse out the SCTP CMSGs.  */\n\terr = sctp_msghdr_parse(msg, &cmsgs);\n\tif (err) {\n\t\tpr_debug(\"%s: msghdr parse err:%x\\n\", __func__, err);\n\t\tgoto out_nounlock;\n\t}\n\n\t/* Fetch the destination address for this packet.  This\n\t * address only selects the association--it is not necessarily\n\t * the address we will send to.\n\t * For a peeled-off socket, msg_name is ignored.\n\t */\n\tif (!sctp_style(sk, UDP_HIGH_BANDWIDTH) && msg->msg_name) {\n\t\tint msg_namelen = msg->msg_namelen;\n\n\t\terr = sctp_verify_addr(sk, (union sctp_addr *)msg->msg_name,\n\t\t\t\t       msg_namelen);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (msg_namelen > sizeof(to))\n\t\t\tmsg_namelen = sizeof(to);\n\t\tmemcpy(&to, msg->msg_name, msg_namelen);\n\t\tmsg_name = msg->msg_name;\n\t}\n\n\tsinit = cmsgs.init;\n\tif (cmsgs.sinfo != NULL) {\n\t\tmemset(&default_sinfo, 0, sizeof(default_sinfo));\n\t\tdefault_sinfo.sinfo_stream = cmsgs.sinfo->snd_sid;\n\t\tdefault_sinfo.sinfo_flags = cmsgs.sinfo->snd_flags;\n\t\tdefault_sinfo.sinfo_ppid = cmsgs.sinfo->snd_ppid;\n\t\tdefault_sinfo.sinfo_context = cmsgs.sinfo->snd_context;\n\t\tdefault_sinfo.sinfo_assoc_id = cmsgs.sinfo->snd_assoc_id;\n\n\t\tsinfo = &default_sinfo;\n\t\tfill_sinfo_ttl = true;\n\t} else {\n\t\tsinfo = cmsgs.srinfo;\n\t}\n\t/* Did the user specify SNDINFO/SNDRCVINFO? */\n\tif (sinfo) {\n\t\tsinfo_flags = sinfo->sinfo_flags;\n\t\tassocid = sinfo->sinfo_assoc_id;\n\t}\n\n\tpr_debug(\"%s: msg_len:%zu, sinfo_flags:0x%x\\n\", __func__,\n\t\t msg_len, sinfo_flags);\n\n\t/* SCTP_EOF or SCTP_ABORT cannot be set on a TCP-style socket. */\n\tif (sctp_style(sk, TCP) && (sinfo_flags & (SCTP_EOF | SCTP_ABORT))) {\n\t\terr = -EINVAL;\n\t\tgoto out_nounlock;\n\t}\n\n\t/* If SCTP_EOF is set, no data can be sent. Disallow sending zero\n\t * length messages when SCTP_EOF|SCTP_ABORT is not set.\n\t * If SCTP_ABORT is set, the message length could be non zero with\n\t * the msg_iov set to the user abort reason.\n\t */\n\tif (((sinfo_flags & SCTP_EOF) && (msg_len > 0)) ||\n\t    (!(sinfo_flags & (SCTP_EOF|SCTP_ABORT)) && (msg_len == 0))) {\n\t\terr = -EINVAL;\n\t\tgoto out_nounlock;\n\t}\n\n\t/* If SCTP_ADDR_OVER is set, there must be an address\n\t * specified in msg_name.\n\t */\n\tif ((sinfo_flags & SCTP_ADDR_OVER) && (!msg->msg_name)) {\n\t\terr = -EINVAL;\n\t\tgoto out_nounlock;\n\t}\n\n\ttransport = NULL;\n\n\tpr_debug(\"%s: about to look up association\\n\", __func__);\n\n\tlock_sock(sk);\n\n\t/* If a msg_name has been specified, assume this is to be used.  */\n\tif (msg_name) {\n\t\t/* Look for a matching association on the endpoint. */\n\t\tasoc = sctp_endpoint_lookup_assoc(ep, &to, &transport);\n\n\t\t/* If we could not find a matching association on the\n\t\t * endpoint, make sure that it is not a TCP-style\n\t\t * socket that already has an association or there is\n\t\t * no peeled-off association on another socket.\n\t\t */\n\t\tif (!asoc &&\n\t\t    ((sctp_style(sk, TCP) &&\n\t\t      (sctp_sstate(sk, ESTABLISHED) ||\n\t\t       sctp_sstate(sk, CLOSING))) ||\n\t\t     sctp_endpoint_is_peeled_off(ep, &to))) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, associd);\n\t\tif (!asoc) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (asoc) {\n\t\tpr_debug(\"%s: just looked up association:%p\\n\", __func__, asoc);\n\n\t\t/* We cannot send a message on a TCP-style SCTP_SS_ESTABLISHED\n\t\t * socket that has an association in CLOSED state. This can\n\t\t * happen when an accepted socket has an association that is\n\t\t * already CLOSED.\n\t\t */\n\t\tif (sctp_state(asoc, CLOSED) && sctp_style(sk, TCP)) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (sinfo_flags & SCTP_EOF) {\n\t\t\tpr_debug(\"%s: shutting down association:%p\\n\",\n\t\t\t\t __func__, asoc);\n\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t\t\terr = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (sinfo_flags & SCTP_ABORT) {\n\n\t\t\tchunk = sctp_make_abort_user(asoc, msg, msg_len);\n\t\t\tif (!chunk) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s: aborting association:%p\\n\",\n\t\t\t\t __func__, asoc);\n\n\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t\terr = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Do we need to create the association?  */\n\tif (!asoc) {\n\t\tpr_debug(\"%s: there is no association yet\\n\", __func__);\n\n\t\tif (sinfo_flags & (SCTP_EOF | SCTP_ABORT)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Check for invalid stream against the stream counts,\n\t\t * either the default or the user specified stream counts.\n\t\t */\n\t\tif (sinfo) {\n\t\t\tif (!sinit || !sinit->sinit_num_ostreams) {\n\t\t\t\t/* Check against the defaults. */\n\t\t\t\tif (sinfo->sinfo_stream >=\n\t\t\t\t    sp->initmsg.sinit_num_ostreams) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Check against the requested.  */\n\t\t\t\tif (sinfo->sinfo_stream >=\n\t\t\t\t    sinit->sinit_num_ostreams) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * API 3.1.2 bind() - UDP Style Syntax\n\t\t * If a bind() or sctp_bindx() is not called prior to a\n\t\t * sendmsg() call that initiates a new association, the\n\t\t * system picks an ephemeral port and will choose an address\n\t\t * set equivalent to binding with a wildcard address.\n\t\t */\n\t\tif (!ep->base.bind_addr.port) {\n\t\t\tif (sctp_autobind(sk)) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * If an unprivileged user inherits a one-to-many\n\t\t\t * style socket with open associations on a privileged\n\t\t\t * port, it MAY be permitted to accept new associations,\n\t\t\t * but it SHOULD NOT be permitted to open new\n\t\t\t * associations.\n\t\t\t */\n\t\t\tif (ep->base.bind_addr.port < PROT_SOCK &&\n\t\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE)) {\n\t\t\t\terr = -EACCES;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tscope = sctp_scope(&to);\n\t\tnew_asoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);\n\t\tif (!new_asoc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tasoc = new_asoc;\n\t\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);\n\t\tif (err < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* If the SCTP_INIT ancillary data is specified, set all\n\t\t * the association init values accordingly.\n\t\t */\n\t\tif (sinit) {\n\t\t\tif (sinit->sinit_num_ostreams) {\n\t\t\t\tasoc->c.sinit_num_ostreams =\n\t\t\t\t\tsinit->sinit_num_ostreams;\n\t\t\t}\n\t\t\tif (sinit->sinit_max_instreams) {\n\t\t\t\tasoc->c.sinit_max_instreams =\n\t\t\t\t\tsinit->sinit_max_instreams;\n\t\t\t}\n\t\t\tif (sinit->sinit_max_attempts) {\n\t\t\t\tasoc->max_init_attempts\n\t\t\t\t\t= sinit->sinit_max_attempts;\n\t\t\t}\n\t\t\tif (sinit->sinit_max_init_timeo) {\n\t\t\t\tasoc->max_init_timeo =\n\t\t\t\t msecs_to_jiffies(sinit->sinit_max_init_timeo);\n\t\t\t}\n\t\t}\n\n\t\t/* Prime the peer's transport structures.  */\n\t\ttransport = sctp_assoc_add_peer(asoc, &to, GFP_KERNEL, SCTP_UNKNOWN);\n\t\tif (!transport) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* ASSERT: we have a valid association at this point.  */\n\tpr_debug(\"%s: we have a valid association\\n\", __func__);\n\n\tif (!sinfo) {\n\t\t/* If the user didn't specify SNDINFO/SNDRCVINFO, make up\n\t\t * one with some defaults.\n\t\t */\n\t\tmemset(&default_sinfo, 0, sizeof(default_sinfo));\n\t\tdefault_sinfo.sinfo_stream = asoc->default_stream;\n\t\tdefault_sinfo.sinfo_flags = asoc->default_flags;\n\t\tdefault_sinfo.sinfo_ppid = asoc->default_ppid;\n\t\tdefault_sinfo.sinfo_context = asoc->default_context;\n\t\tdefault_sinfo.sinfo_timetolive = asoc->default_timetolive;\n\t\tdefault_sinfo.sinfo_assoc_id = sctp_assoc2id(asoc);\n\n\t\tsinfo = &default_sinfo;\n\t} else if (fill_sinfo_ttl) {\n\t\t/* In case SNDINFO was specified, we still need to fill\n\t\t * it with a default ttl from the assoc here.\n\t\t */\n\t\tsinfo->sinfo_timetolive = asoc->default_timetolive;\n\t}\n\n\t/* API 7.1.7, the sndbuf size per association bounds the\n\t * maximum size of data that can be sent in a single send call.\n\t */\n\tif (msg_len > sk->sk_sndbuf) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_free;\n\t}\n\n\tif (asoc->pmtu_pending)\n\t\tsctp_assoc_pending_pmtu(sk, asoc);\n\n\t/* If fragmentation is disabled and the message length exceeds the\n\t * association fragmentation point, return EMSGSIZE.  The I-D\n\t * does not specify what this error is, but this looks like\n\t * a great fit.\n\t */\n\tif (sctp_sk(sk)->disable_fragments && (msg_len > asoc->frag_point)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_free;\n\t}\n\n\t/* Check for invalid stream. */\n\tif (sinfo->sinfo_stream >= asoc->c.sinit_num_ostreams) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (sctp_wspace(asoc) < msg_len)\n\t\tsctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\tif (!sctp_wspace(asoc)) {\n\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\t/* If an address is passed with the sendto/sendmsg call, it is used\n\t * to override the primary destination address in the TCP model, or\n\t * when SCTP_ADDR_OVER flag is set in the UDP model.\n\t */\n\tif ((sctp_style(sk, TCP) && msg_name) ||\n\t    (sinfo_flags & SCTP_ADDR_OVER)) {\n\t\tchunk_tp = sctp_assoc_lookup_paddr(asoc, &to);\n\t\tif (!chunk_tp) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t} else\n\t\tchunk_tp = NULL;\n\n\t/* Auto-connect, if we aren't connected already. */\n\tif (sctp_state(asoc, CLOSED)) {\n\t\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\n\t\twait_connect = true;\n\t\tpr_debug(\"%s: we associated primitively\\n\", __func__);\n\t}\n\n\t/* Break the message into multiple chunks of maximum size. */\n\tdatamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);\n\tif (IS_ERR(datamsg)) {\n\t\terr = PTR_ERR(datamsg);\n\t\tgoto out_free;\n\t}\n\n\t/* Now send the (possibly) fragmented message. */\n\tlist_for_each_entry(chunk, &datamsg->chunks, frag_list) {\n\t\tsctp_chunk_hold(chunk);\n\n\t\t/* Do accounting for the write space.  */\n\t\tsctp_set_owner_w(chunk);\n\n\t\tchunk->transport = chunk_tp;\n\t}\n\n\t/* Send it to the lower layers.  Note:  all chunks\n\t * must either fail or succeed.   The lower layer\n\t * works that way today.  Keep it that way or this\n\t * breaks.\n\t */\n\terr = sctp_primitive_SEND(net, asoc, datamsg);\n\t/* Did the lower layer accept the chunk? */\n\tif (err) {\n\t\tsctp_datamsg_free(datamsg);\n\t\tgoto out_free;\n\t}\n\n\tpr_debug(\"%s: we sent primitively\\n\", __func__);\n\n\tsctp_datamsg_put(datamsg);\n\terr = msg_len;\n\n\tif (unlikely(wait_connect)) {\n\t\ttimeo = sock_sndtimeo(sk, msg_flags & MSG_DONTWAIT);\n\t\tsctp_wait_for_connect(asoc, &timeo);\n\t}\n\n\t/* If we are already past ASSOCIATE, the lower\n\t * layers are responsible for association cleanup.\n\t */\n\tgoto out_unlock;\n\nout_free:\n\tif (new_asoc)\n\t\tsctp_association_free(asoc);\nout_unlock:\n\trelease_sock(sk);\n\nout_nounlock:\n\treturn sctp_error(sk, msg_flags, err);\n\n#if 0\ndo_sock_err:\n\tif (msg_len)\n\t\terr = msg_len;\n\telse\n\t\terr = sock_error(sk);\n\tgoto out;\n\ndo_interrupted:\n\tif (msg_len)\n\t\terr = msg_len;\n\tgoto out;\n#endif /* 0 */\n}\n\n/* This is an extended version of skb_pull() that removes the data from the\n * start of a skb even when data is spread across the list of skb's in the\n * frag_list. len specifies the total amount of data that needs to be removed.\n * when 'len' bytes could be removed from the skb, it returns 0.\n * If 'len' exceeds the total skb length,  it returns the no. of bytes that\n * could not be removed.\n */\nstatic int sctp_skb_pull(struct sk_buff *skb, int len)\n{\n\tstruct sk_buff *list;\n\tint skb_len = skb_headlen(skb);\n\tint rlen;\n\n\tif (len <= skb_len) {\n\t\t__skb_pull(skb, len);\n\t\treturn 0;\n\t}\n\tlen -= skb_len;\n\t__skb_pull(skb, skb_len);\n\n\tskb_walk_frags(skb, list) {\n\t\trlen = sctp_skb_pull(list, len);\n\t\tskb->len -= (len-rlen);\n\t\tskb->data_len -= (len-rlen);\n\n\t\tif (!rlen)\n\t\t\treturn 0;\n\n\t\tlen = rlen;\n\t}\n\n\treturn len;\n}\n\n/* API 3.1.3  recvmsg() - UDP Style Syntax\n *\n *  ssize_t recvmsg(int socket, struct msghdr *message,\n *                    int flags);\n *\n *  socket  - the socket descriptor of the endpoint.\n *  message - pointer to the msghdr structure which contains a single\n *            user message and possibly some ancillary data.\n *\n *            See Section 5 for complete description of the data\n *            structures.\n *\n *  flags   - flags sent or received with the user message, see Section\n *            5 for complete description of the flags.\n */\nstatic int sctp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\tint noblock, int flags, int *addr_len)\n{\n\tstruct sctp_ulpevent *event = NULL;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sk_buff *skb, *head_skb;\n\tint copied;\n\tint err = 0;\n\tint skb_len;\n\n\tpr_debug(\"%s: sk:%p, msghdr:%p, len:%zd, noblock:%d, flags:0x%x, \"\n\t\t \"addr_len:%p)\\n\", __func__, sk, msg, len, noblock, flags,\n\t\t addr_len);\n\n\tlock_sock(sk);\n\n\tif (sctp_style(sk, TCP) && !sctp_sstate(sk, ESTABLISHED) &&\n\t    !sctp_sstate(sk, CLOSING) && !sctp_sstate(sk, CLOSED)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tskb = sctp_skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\t/* Get the total length of the skb including any skb's in the\n\t * frag_list.\n\t */\n\tskb_len = skb->len;\n\n\tcopied = skb_len;\n\tif (copied > len)\n\t\tcopied = len;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tevent = sctp_skb2event(skb);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tif (event->chunk && event->chunk->head_skb)\n\t\thead_skb = event->chunk->head_skb;\n\telse\n\t\thead_skb = skb;\n\tsock_recv_ts_and_drops(msg, sk, head_skb);\n\tif (sctp_ulpevent_is_notification(event)) {\n\t\tmsg->msg_flags |= MSG_NOTIFICATION;\n\t\tsp->pf->event_msgname(event, msg->msg_name, addr_len);\n\t} else {\n\t\tsp->pf->skb_msgname(head_skb, msg->msg_name, addr_len);\n\t}\n\n\t/* Check if we allow SCTP_NXTINFO. */\n\tif (sp->recvnxtinfo)\n\t\tsctp_ulpevent_read_nxtinfo(event, msg, sk);\n\t/* Check if we allow SCTP_RCVINFO. */\n\tif (sp->recvrcvinfo)\n\t\tsctp_ulpevent_read_rcvinfo(event, msg);\n\t/* Check if we allow SCTP_SNDRCVINFO. */\n\tif (sp->subscribe.sctp_data_io_event)\n\t\tsctp_ulpevent_read_sndrcvinfo(event, msg);\n\n\terr = copied;\n\n\t/* If skb's length exceeds the user's buffer, update the skb and\n\t * push it back to the receive_queue so that the next call to\n\t * recvmsg() will return the remaining data. Don't set MSG_EOR.\n\t */\n\tif (skb_len > copied) {\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\t\tif (flags & MSG_PEEK)\n\t\t\tgoto out_free;\n\t\tsctp_skb_pull(skb, copied);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\t/* When only partial message is copied to the user, increase\n\t\t * rwnd by that amount. If all the data in the skb is read,\n\t\t * rwnd is updated when the event is freed.\n\t\t */\n\t\tif (!sctp_ulpevent_is_notification(event))\n\t\t\tsctp_assoc_rwnd_increase(event->asoc, copied);\n\t\tgoto out;\n\t} else if ((event->msg_flags & MSG_NOTIFICATION) ||\n\t\t   (event->msg_flags & MSG_EOR))\n\t\tmsg->msg_flags |= MSG_EOR;\n\telse\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\nout_free:\n\tif (flags & MSG_PEEK) {\n\t\t/* Release the skb reference acquired after peeking the skb in\n\t\t * sctp_skb_recv_datagram().\n\t\t */\n\t\tkfree_skb(skb);\n\t} else {\n\t\t/* Free the event which includes releasing the reference to\n\t\t * the owner of the skb, freeing the skb and updating the\n\t\t * rwnd.\n\t\t */\n\t\tsctp_ulpevent_free(event);\n\t}\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)\n *\n * This option is a on/off flag.  If enabled no SCTP message\n * fragmentation will be performed.  Instead if a message being sent\n * exceeds the current PMTU size, the message will NOT be sent and\n * instead a error will be indicated to the user.\n */\nstatic int sctp_setsockopt_disable_fragments(struct sock *sk,\n\t\t\t\t\t     char __user *optval,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->disable_fragments = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_events(struct sock *sk, char __user *optval,\n\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_ulpevent *event;\n\n\tif (optlen > sizeof(struct sctp_event_subscribe))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sctp_sk(sk)->subscribe, optval, optlen))\n\t\treturn -EFAULT;\n\n\t/* At the time when a user app subscribes to SCTP_SENDER_DRY_EVENT,\n\t * if there is no data to be sent or retransmit, the stack will\n\t * immediately send up this notification.\n\t */\n\tif (sctp_ulpevent_type_enabled(SCTP_SENDER_DRY_EVENT,\n\t\t\t\t       &sctp_sk(sk)->subscribe)) {\n\t\tasoc = sctp_id2assoc(sk, 0);\n\n\t\tif (asoc && sctp_outq_is_empty(&asoc->outqueue)) {\n\t\t\tevent = sctp_ulpevent_make_sender_dry_event(asoc,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsctp_ulpq_tail_event(&asoc->ulpq, event);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)\n *\n * This socket option is applicable to the UDP-style socket only.  When\n * set it will cause associations that are idle for more than the\n * specified number of seconds to automatically close.  An association\n * being idle is defined an association that has NOT sent or received\n * user data.  The special value of '0' indicates that no automatic\n * close of any associations should be performed.  The option expects an\n * integer defining the number of seconds of idle time before an\n * association is closed.\n */\nstatic int sctp_setsockopt_autoclose(struct sock *sk, char __user *optval,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sp->autoclose, optval, optlen))\n\t\treturn -EFAULT;\n\n\tif (sp->autoclose > net->sctp.max_autoclose)\n\t\tsp->autoclose = net->sctp.max_autoclose;\n\n\treturn 0;\n}\n\n/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n *\n * Applications can enable or disable heartbeats for any peer address of\n * an association, modify an address's heartbeat interval, force a\n * heartbeat to be sent immediately, and adjust the address's maximum\n * number of retransmissions sent before an address is considered\n * unreachable.  The following structure is used to access and modify an\n * address's parameters:\n *\n *  struct sctp_paddrparams {\n *     sctp_assoc_t            spp_assoc_id;\n *     struct sockaddr_storage spp_address;\n *     uint32_t                spp_hbinterval;\n *     uint16_t                spp_pathmaxrxt;\n *     uint32_t                spp_pathmtu;\n *     uint32_t                spp_sackdelay;\n *     uint32_t                spp_flags;\n * };\n *\n *   spp_assoc_id    - (one-to-many style socket) This is filled in the\n *                     application, and identifies the association for\n *                     this query.\n *   spp_address     - This specifies which address is of interest.\n *   spp_hbinterval  - This contains the value of the heartbeat interval,\n *                     in milliseconds.  If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmaxrxt  - This contains the maximum number of\n *                     retransmissions before this address shall be\n *                     considered unreachable. If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmtu     - When Path MTU discovery is disabled the value\n *                     specified here will be the \"fixed\" path mtu.\n *                     Note that if the spp_address field is empty\n *                     then all associations on this address will\n *                     have this fixed path mtu set upon them.\n *\n *   spp_sackdelay   - When delayed sack is enabled, this value specifies\n *                     the number of milliseconds that sacks will be delayed\n *                     for. This value will apply to all addresses of an\n *                     association if the spp_address field is empty. Note\n *                     also, that if delayed sack is enabled and this\n *                     value is set to 0, no change is made to the last\n *                     recorded delayed sack timer value.\n *\n *   spp_flags       - These flags are used to control various features\n *                     on an association. The flag field may contain\n *                     zero or more of the following options.\n *\n *                     SPP_HB_ENABLE  - Enable heartbeats on the\n *                     specified address. Note that if the address\n *                     field is empty all addresses for the association\n *                     have heartbeats enabled upon them.\n *\n *                     SPP_HB_DISABLE - Disable heartbeats on the\n *                     speicifed address. Note that if the address\n *                     field is empty all addresses for the association\n *                     will have their heartbeats disabled. Note also\n *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are\n *                     mutually exclusive, only one of these two should\n *                     be specified. Enabling both fields will have\n *                     undetermined results.\n *\n *                     SPP_HB_DEMAND - Request a user initiated heartbeat\n *                     to be made immediately.\n *\n *                     SPP_HB_TIME_IS_ZERO - Specify's that the time for\n *                     heartbeat delayis to be set to the value of 0\n *                     milliseconds.\n *\n *                     SPP_PMTUD_ENABLE - This field will enable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected.\n *\n *                     SPP_PMTUD_DISABLE - This field will disable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected. Not also that\n *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n *                     exclusive. Enabling both will have undetermined\n *                     results.\n *\n *                     SPP_SACKDELAY_ENABLE - Setting this flag turns\n *                     on delayed sack. The time specified in spp_sackdelay\n *                     is used to specify the sack delay for this address. Note\n *                     that if spp_address is empty then all addresses will\n *                     enable delayed sack and take on the sack delay\n *                     value specified in spp_sackdelay.\n *                     SPP_SACKDELAY_DISABLE - Setting this flag turns\n *                     off delayed sack. If the spp_address field is blank then\n *                     delayed sack is disabled for the entire association. Note\n *                     also that this field is mutually exclusive to\n *                     SPP_SACKDELAY_ENABLE, setting both will have undefined\n *                     results.\n */\nstatic int sctp_apply_peer_addr_params(struct sctp_paddrparams *params,\n\t\t\t\t       struct sctp_transport   *trans,\n\t\t\t\t       struct sctp_association *asoc,\n\t\t\t\t       struct sctp_sock        *sp,\n\t\t\t\t       int                      hb_change,\n\t\t\t\t       int                      pmtud_change,\n\t\t\t\t       int                      sackdelay_change)\n{\n\tint error;\n\n\tif (params->spp_flags & SPP_HB_DEMAND && trans) {\n\t\tstruct net *net = sock_net(trans->asoc->base.sk);\n\n\t\terror = sctp_primitive_REQUESTHEARTBEAT(net, trans->asoc, trans);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Note that unless the spp_flag is set to SPP_HB_ENABLE the value of\n\t * this field is ignored.  Note also that a value of zero indicates\n\t * the current setting should be left unchanged.\n\t */\n\tif (params->spp_flags & SPP_HB_ENABLE) {\n\n\t\t/* Re-zero the interval if the SPP_HB_TIME_IS_ZERO is\n\t\t * set.  This lets us use 0 value when this flag\n\t\t * is set.\n\t\t */\n\t\tif (params->spp_flags & SPP_HB_TIME_IS_ZERO)\n\t\t\tparams->spp_hbinterval = 0;\n\n\t\tif (params->spp_hbinterval ||\n\t\t    (params->spp_flags & SPP_HB_TIME_IS_ZERO)) {\n\t\t\tif (trans) {\n\t\t\t\ttrans->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else if (asoc) {\n\t\t\t\tasoc->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else {\n\t\t\t\tsp->hbinterval = params->spp_hbinterval;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hb_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_HB) | hb_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_HB) | hb_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_HB) | hb_change;\n\t\t}\n\t}\n\n\t/* When Path MTU discovery is disabled the value specified here will\n\t * be the \"fixed\" path mtu (i.e. the value of the spp_flags field must\n\t * include the flag SPP_PMTUD_DISABLE for this field to have any\n\t * effect).\n\t */\n\tif ((params->spp_flags & SPP_PMTUD_DISABLE) && params->spp_pathmtu) {\n\t\tif (trans) {\n\t\t\ttrans->pathmtu = params->spp_pathmtu;\n\t\t\tsctp_assoc_sync_pmtu(sctp_opt2sk(sp), asoc);\n\t\t} else if (asoc) {\n\t\t\tasoc->pathmtu = params->spp_pathmtu;\n\t\t\tsctp_frag_point(asoc, params->spp_pathmtu);\n\t\t} else {\n\t\t\tsp->pathmtu = params->spp_pathmtu;\n\t\t}\n\t}\n\n\tif (pmtud_change) {\n\t\tif (trans) {\n\t\t\tint update = (trans->param_flags & SPP_PMTUD_DISABLE) &&\n\t\t\t\t(params->spp_flags & SPP_PMTUD_ENABLE);\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t\tif (update) {\n\t\t\t\tsctp_transport_pmtu(trans, sctp_opt2sk(sp));\n\t\t\t\tsctp_assoc_sync_pmtu(sctp_opt2sk(sp), asoc);\n\t\t\t}\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t}\n\t}\n\n\t/* Note that unless the spp_flag is set to SPP_SACKDELAY_ENABLE the\n\t * value of this field is ignored.  Note also that a value of zero\n\t * indicates the current setting should be left unchanged.\n\t */\n\tif ((params->spp_flags & SPP_SACKDELAY_ENABLE) && params->spp_sackdelay) {\n\t\tif (trans) {\n\t\t\ttrans->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else if (asoc) {\n\t\t\tasoc->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else {\n\t\t\tsp->sackdelay = params->spp_sackdelay;\n\t\t}\n\t}\n\n\tif (sackdelay_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t}\n\t}\n\n\t/* Note that a value of zero indicates the current setting should be\n\t   left unchanged.\n\t */\n\tif (params->spp_pathmaxrxt) {\n\t\tif (trans) {\n\t\t\ttrans->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else if (asoc) {\n\t\t\tasoc->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else {\n\t\t\tsp->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_peer_addr_params(struct sock *sk,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\tint error;\n\tint hb_change, pmtud_change, sackdelay_change;\n\n\tif (optlen != sizeof(struct sctp_paddrparams))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&params, optval, optlen))\n\t\treturn -EFAULT;\n\n\t/* Validate flags and value parameters. */\n\thb_change        = params.spp_flags & SPP_HB;\n\tpmtud_change     = params.spp_flags & SPP_PMTUD;\n\tsackdelay_change = params.spp_flags & SPP_SACKDELAY;\n\n\tif (hb_change        == SPP_HB ||\n\t    pmtud_change     == SPP_PMTUD ||\n\t    sackdelay_change == SPP_SACKDELAY ||\n\t    params.spp_sackdelay > 500 ||\n\t    (params.spp_pathmtu &&\n\t     params.spp_pathmtu < SCTP_DEFAULT_MINSEGMENT))\n\t\treturn -EINVAL;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Get association, if assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Heartbeat demand can only be sent on a transport or\n\t * association, but not a socket.\n\t */\n\tif (params.spp_flags & SPP_HB_DEMAND && !trans && !asoc)\n\t\treturn -EINVAL;\n\n\t/* Process parameters. */\n\terror = sctp_apply_peer_addr_params(&params, trans, asoc, sp,\n\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t    sackdelay_change);\n\n\tif (error)\n\t\treturn error;\n\n\t/* If changes are for association, also apply parameters to each\n\t * transport.\n\t */\n\tif (!trans && asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tsctp_apply_peer_addr_params(&params, trans, asoc, sp,\n\t\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t\t    sackdelay_change);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_enable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_ENABLE;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_disable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_DISABLE;\n}\n\n/*\n * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)\n *\n * This option will effect the way delayed acks are performed.  This\n * option allows you to get or set the delayed ack time, in\n * milliseconds.  It also allows changing the delayed ack frequency.\n * Changing the frequency to 1 disables the delayed sack algorithm.  If\n * the assoc_id is 0, then this sets or gets the endpoints default\n * values.  If the assoc_id field is non-zero, then the set or get\n * effects the specified association for the one to many model (the\n * assoc_id field is ignored by the one to one model).  Note that if\n * sack_delay or sack_freq are 0 when setting this option, then the\n * current values will remain unchanged.\n *\n * struct sctp_sack_info {\n *     sctp_assoc_t            sack_assoc_id;\n *     uint32_t                sack_delay;\n *     uint32_t                sack_freq;\n * };\n *\n * sack_assoc_id -  This parameter, indicates which association the user\n *    is performing an action upon.  Note that if this field's value is\n *    zero then the endpoints default value is changed (effecting future\n *    associations only).\n *\n * sack_delay -  This parameter contains the number of milliseconds that\n *    the user is requesting the delayed ACK timer be set to.  Note that\n *    this value is defined in the standard to be between 200 and 500\n *    milliseconds.\n *\n * sack_freq -  This parameter contains the number of packets that must\n *    be received before a sack is sent without waiting for the delay\n *    timer to expire.  The default value for this is 2, setting this\n *    value to 1 will disable the delayed sack algorithm.\n */\n\nstatic int sctp_setsockopt_delayed_ack(struct sock *sk,\n\t\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_sack_info    params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (optlen == sizeof(struct sctp_sack_info)) {\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tif (params.sack_delay == 0 && params.sack_freq == 0)\n\t\t\treturn 0;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tif (params.sack_delay == 0)\n\t\t\tparams.sack_freq = 1;\n\t\telse\n\t\t\tparams.sack_freq = 0;\n\t} else\n\t\treturn -EINVAL;\n\n\t/* Validate value parameter. */\n\tif (params.sack_delay > 500)\n\t\treturn -EINVAL;\n\n\t/* Get association, if sack_assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.sack_assoc_id);\n\tif (!asoc && params.sack_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (params.sack_delay) {\n\t\tif (asoc) {\n\t\t\tasoc->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params.sack_delay);\n\t\t\tasoc->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t\t} else {\n\t\t\tsp->sackdelay = params.sack_delay;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t}\n\n\tif (params.sack_freq == 1) {\n\t\tif (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(asoc->param_flags);\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(sp->param_flags);\n\t\t}\n\t} else if (params.sack_freq > 1) {\n\t\tif (asoc) {\n\t\t\tasoc->sackfreq = params.sack_freq;\n\t\t\tasoc->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t\t} else {\n\t\t\tsp->sackfreq = params.sack_freq;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t}\n\n\t/* If change is for association, also apply to each transport. */\n\tif (asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (params.sack_delay) {\n\t\t\t\ttrans->sackdelay =\n\t\t\t\t\tmsecs_to_jiffies(params.sack_delay);\n\t\t\t\ttrans->param_flags =\n\t\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t\t}\n\t\t\tif (params.sack_freq == 1) {\n\t\t\t\ttrans->param_flags =\n\t\t\t\t\tsctp_spp_sackdelay_disable(trans->param_flags);\n\t\t\t} else if (params.sack_freq > 1) {\n\t\t\t\ttrans->sackfreq = params.sack_freq;\n\t\t\t\ttrans->param_flags =\n\t\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.3 Initialization Parameters (SCTP_INITMSG)\n *\n * Applications can specify protocol parameters for the default association\n * initialization.  The option name argument to setsockopt() and getsockopt()\n * is SCTP_INITMSG.\n *\n * Setting initialization parameters is effective only on an unconnected\n * socket (for UDP-style sockets only future associations are effected\n * by the change).  With TCP-style sockets, this option is inherited by\n * sockets derived from a listener socket.\n */\nstatic int sctp_setsockopt_initmsg(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_initmsg sinit;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sinit, optval, optlen))\n\t\treturn -EFAULT;\n\n\tif (sinit.sinit_num_ostreams)\n\t\tsp->initmsg.sinit_num_ostreams = sinit.sinit_num_ostreams;\n\tif (sinit.sinit_max_instreams)\n\t\tsp->initmsg.sinit_max_instreams = sinit.sinit_max_instreams;\n\tif (sinit.sinit_max_attempts)\n\t\tsp->initmsg.sinit_max_attempts = sinit.sinit_max_attempts;\n\tif (sinit.sinit_max_init_timeo)\n\t\tsp->initmsg.sinit_max_init_timeo = sinit.sinit_max_init_timeo;\n\n\treturn 0;\n}\n\n/*\n * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)\n *\n *   Applications that wish to use the sendto() system call may wish to\n *   specify a default set of parameters that would normally be supplied\n *   through the inclusion of ancillary data.  This socket option allows\n *   such an application to set the default sctp_sndrcvinfo structure.\n *   The application that wishes to use this socket option simply passes\n *   in to this call the sctp_sndrcvinfo structure defined in Section\n *   5.2.2) The input parameters accepted by this call include\n *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,\n *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in\n *   to this call if the caller is using the UDP model.\n */\nstatic int sctp_setsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\t      char __user *optval,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndrcvinfo info;\n\n\tif (optlen != sizeof(info))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&info, optval, optlen))\n\t\treturn -EFAULT;\n\tif (info.sinfo_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info.sinfo_assoc_id);\n\tif (!asoc && info.sinfo_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tasoc->default_stream = info.sinfo_stream;\n\t\tasoc->default_flags = info.sinfo_flags;\n\t\tasoc->default_ppid = info.sinfo_ppid;\n\t\tasoc->default_context = info.sinfo_context;\n\t\tasoc->default_timetolive = info.sinfo_timetolive;\n\t} else {\n\t\tsp->default_stream = info.sinfo_stream;\n\t\tsp->default_flags = info.sinfo_flags;\n\t\tsp->default_ppid = info.sinfo_ppid;\n\t\tsp->default_context = info.sinfo_context;\n\t\tsp->default_timetolive = info.sinfo_timetolive;\n\t}\n\n\treturn 0;\n}\n\n/* RFC6458, Section 8.1.31. Set/get Default Send Parameters\n * (SCTP_DEFAULT_SNDINFO)\n */\nstatic int sctp_setsockopt_default_sndinfo(struct sock *sk,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndinfo info;\n\n\tif (optlen != sizeof(info))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&info, optval, optlen))\n\t\treturn -EFAULT;\n\tif (info.snd_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info.snd_assoc_id);\n\tif (!asoc && info.snd_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tasoc->default_stream = info.snd_sid;\n\t\tasoc->default_flags = info.snd_flags;\n\t\tasoc->default_ppid = info.snd_ppid;\n\t\tasoc->default_context = info.snd_context;\n\t} else {\n\t\tsp->default_stream = info.snd_sid;\n\t\tsp->default_flags = info.snd_flags;\n\t\tsp->default_ppid = info.snd_ppid;\n\t\tsp->default_context = info.snd_context;\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)\n *\n * Requests that the local SCTP stack use the enclosed peer address as\n * the association primary.  The enclosed address must be one of the\n * association peer's addresses.\n */\nstatic int sctp_setsockopt_primary_addr(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_prim prim;\n\tstruct sctp_transport *trans;\n\n\tif (optlen != sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&prim, optval, sizeof(struct sctp_prim)))\n\t\treturn -EFAULT;\n\n\ttrans = sctp_addr_id2transport(sk, &prim.ssp_addr, prim.ssp_assoc_id);\n\tif (!trans)\n\t\treturn -EINVAL;\n\n\tsctp_assoc_set_primary(trans->asoc, trans);\n\n\treturn 0;\n}\n\n/*\n * 7.1.5 SCTP_NODELAY\n *\n * Turn on/off any Nagle-like algorithm.  This means that packets are\n * generally sent as soon as possible and no unnecessary delays are\n * introduced, at the cost of more packets in the network.  Expects an\n *  integer boolean flag.\n */\nstatic int sctp_setsockopt_nodelay(struct sock *sk, char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->nodelay = (val == 0) ? 0 : 1;\n\treturn 0;\n}\n\n/*\n *\n * 7.1.1 SCTP_RTOINFO\n *\n * The protocol parameters used to initialize and bound retransmission\n * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access\n * and modify these parameters.\n * All parameters are time values, in milliseconds.  A value of 0, when\n * modifying the parameters, indicates that the current value should not\n * be changed.\n *\n */\nstatic int sctp_setsockopt_rtoinfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\tunsigned long rto_min, rto_max;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&rtoinfo, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\t/* Set the values to the specific association */\n\tif (!asoc && rtoinfo.srto_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\trto_max = rtoinfo.srto_max;\n\trto_min = rtoinfo.srto_min;\n\n\tif (rto_max)\n\t\trto_max = asoc ? msecs_to_jiffies(rto_max) : rto_max;\n\telse\n\t\trto_max = asoc ? asoc->rto_max : sp->rtoinfo.srto_max;\n\n\tif (rto_min)\n\t\trto_min = asoc ? msecs_to_jiffies(rto_min) : rto_min;\n\telse\n\t\trto_min = asoc ? asoc->rto_min : sp->rtoinfo.srto_min;\n\n\tif (rto_min > rto_max)\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (rtoinfo.srto_initial != 0)\n\t\t\tasoc->rto_initial =\n\t\t\t\tmsecs_to_jiffies(rtoinfo.srto_initial);\n\t\tasoc->rto_max = rto_max;\n\t\tasoc->rto_min = rto_min;\n\t} else {\n\t\t/* If there is no association or the association-id = 0\n\t\t * set the values to the endpoint.\n\t\t */\n\t\tif (rtoinfo.srto_initial != 0)\n\t\t\tsp->rtoinfo.srto_initial = rtoinfo.srto_initial;\n\t\tsp->rtoinfo.srto_max = rto_max;\n\t\tsp->rtoinfo.srto_min = rto_min;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.2 SCTP_ASSOCINFO\n *\n * This option is used to tune the maximum retransmission attempts\n * of the association.\n * Returns an error if the new association retransmission value is\n * greater than the sum of the retransmission value  of the peer.\n * See [SCTP] for more information.\n *\n */\nstatic int sctp_setsockopt_associnfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assocparams))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&assocparams, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Set the values to the specific association */\n\tif (asoc) {\n\t\tif (assocparams.sasoc_asocmaxrxt != 0) {\n\t\t\t__u32 path_sum = 0;\n\t\t\tint   paths = 0;\n\t\t\tstruct sctp_transport *peer_addr;\n\n\t\t\tlist_for_each_entry(peer_addr, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tpath_sum += peer_addr->pathmaxrxt;\n\t\t\t\tpaths++;\n\t\t\t}\n\n\t\t\t/* Only validate asocmaxrxt if we have more than\n\t\t\t * one path/transport.  We do this because path\n\t\t\t * retransmissions are only counted when we have more\n\t\t\t * then one path.\n\t\t\t */\n\t\t\tif (paths > 1 &&\n\t\t\t    assocparams.sasoc_asocmaxrxt > path_sum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tasoc->max_retrans = assocparams.sasoc_asocmaxrxt;\n\t\t}\n\n\t\tif (assocparams.sasoc_cookie_life != 0)\n\t\t\tasoc->cookie_life = ms_to_ktime(assocparams.sasoc_cookie_life);\n\t} else {\n\t\t/* Set the values to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (assocparams.sasoc_asocmaxrxt != 0)\n\t\t\tsp->assocparams.sasoc_asocmaxrxt =\n\t\t\t\t\t\tassocparams.sasoc_asocmaxrxt;\n\t\tif (assocparams.sasoc_cookie_life != 0)\n\t\t\tsp->assocparams.sasoc_cookie_life =\n\t\t\t\t\t\tassocparams.sasoc_cookie_life;\n\t}\n\treturn 0;\n}\n\n/*\n * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n *\n * This socket option is a boolean flag which turns on or off mapped V4\n * addresses.  If this option is turned on and the socket is type\n * PF_INET6, then IPv4 addresses will be mapped to V6 representation.\n * If this option is turned off, then no mapping will be done of V4\n * addresses and a user will receive both PF_INET6 and PF_INET type\n * addresses on the socket.\n */\nstatic int sctp_setsockopt_mappedv4(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (val)\n\t\tsp->v4mapped = 1;\n\telse\n\t\tsp->v4mapped = 0;\n\n\treturn 0;\n}\n\n/*\n * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n * This option will get or set the maximum size to put in any outgoing\n * SCTP DATA chunk.  If a message is larger than this size it will be\n * fragmented by SCTP into the specified size.  Note that the underlying\n * SCTP implementation may fragment into smaller sized chunks when the\n * PMTU of the underlying association is smaller than the value set by\n * the user.  The default value for this option is '0' which indicates\n * the user is NOT limiting fragmentation and only the PMTU will effect\n * SCTP's choice of DATA chunk size.  Note also that values set larger\n * than the maximum size of an IP datagram will effectively let SCTP\n * control fragmentation (i.e. the same as setting this option to 0).\n *\n * The following structure is used to access and modify this parameter:\n *\n * struct sctp_assoc_value {\n *   sctp_assoc_t assoc_id;\n *   uint32_t assoc_value;\n * };\n *\n * assoc_id:  This parameter is ignored for one-to-one style sockets.\n *    For one-to-many style sockets this parameter indicates which\n *    association the user is performing an action upon.  Note that if\n *    this field's value is zero then the endpoints default value is\n *    changed (effecting future associations only).\n * assoc_value:  This parameter specifies the maximum size in bytes.\n */\nstatic int sctp_setsockopt_maxseg(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint val;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&val, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tparams.assoc_id = 0;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tval = params.assoc_value;\n\t} else\n\t\treturn -EINVAL;\n\n\tif ((val != 0) && ((val < 8) || (val > SCTP_MAX_CHUNK_LEN)))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (val == 0) {\n\t\t\tval = asoc->pathmtu;\n\t\t\tval -= sp->pf->af->net_header_len;\n\t\t\tval -= sizeof(struct sctphdr) +\n\t\t\t\t\tsizeof(struct sctp_data_chunk);\n\t\t}\n\t\tasoc->user_frag = val;\n\t\tasoc->frag_point = sctp_frag_point(asoc, asoc->pathmtu);\n\t} else {\n\t\tsp->user_frag = val;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *  7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)\n *\n *   Requests that the peer mark the enclosed address as the association\n *   primary. The enclosed address must be one of the association's\n *   locally bound addresses. The following structure is used to make a\n *   set primary request:\n */\nstatic int sctp_setsockopt_peer_primary_addr(struct sock *sk, char __user *optval,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_association\t*asoc = NULL;\n\tstruct sctp_setpeerprim\tprim;\n\tstruct sctp_chunk\t*chunk;\n\tstruct sctp_af\t\t*af;\n\tint \t\t\terr;\n\n\tsp = sctp_sk(sk);\n\n\tif (!net->sctp.addip_enable)\n\t\treturn -EPERM;\n\n\tif (optlen != sizeof(struct sctp_setpeerprim))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&prim, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, prim.sspp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.asconf_capable)\n\t\treturn -EPERM;\n\n\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_SET_PRIMARY)\n\t\treturn -EPERM;\n\n\tif (!sctp_state(asoc, ESTABLISHED))\n\t\treturn -ENOTCONN;\n\n\taf = sctp_get_af_specific(prim.sspp_addr.ss_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tif (!af->addr_valid((union sctp_addr *)&prim.sspp_addr, sp, NULL))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!sctp_assoc_lookup_laddr(asoc, (union sctp_addr *)&prim.sspp_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Create an ASCONF chunk with SET_PRIMARY parameter\t*/\n\tchunk = sctp_make_asconf_set_prim(asoc,\n\t\t\t\t\t  (union sctp_addr *)&prim.sspp_addr);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\terr = sctp_send_asconf(asoc, chunk);\n\n\tpr_debug(\"%s: we set peer primary addr primitively\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int sctp_setsockopt_adaptation_layer(struct sock *sk, char __user *optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (optlen != sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&adaptation, optval, optlen))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->adaptation_ind = adaptation.ssb_adaptation_ind;\n\n\treturn 0;\n}\n\n/*\n * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)\n *\n * The context field in the sctp_sndrcvinfo structure is normally only\n * used when a failed message is retrieved holding the value that was\n * sent down on the actual send call.  This option allows the setting of\n * a default context on an association basis that will be received on\n * reading messages from the peer.  This is especially helpful in the\n * one-2-many model for an application to keep some reference to an\n * internal state machine that is processing messages on the\n * association.  Note that the setting of this value only effects\n * received messages from the peer and does not effect the value that is\n * saved with outbound messages.\n */\nstatic int sctp_setsockopt_context(struct sock *sk, char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&params, optval, optlen))\n\t\treturn -EFAULT;\n\n\tsp = sctp_sk(sk);\n\n\tif (params.assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tasoc->default_rcv_context = params.assoc_value;\n\t} else {\n\t\tsp->default_rcv_context = params.assoc_value;\n\t}\n\n\treturn 0;\n}\n\n/*\n * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)\n *\n * This options will at a minimum specify if the implementation is doing\n * fragmented interleave.  Fragmented interleave, for a one to many\n * socket, is when subsequent calls to receive a message may return\n * parts of messages from different associations.  Some implementations\n * may allow you to turn this value on or off.  If so, when turned off,\n * no fragment interleave will occur (which will cause a head of line\n * blocking amongst multiple associations sharing the same one to many\n * socket).  When this option is turned on, then each receive call may\n * come from a different association (thus the user must receive data\n * with the extended calls (e.g. sctp_recvmsg) to keep track of which\n * association each receive belongs to.\n *\n * This option takes a boolean value.  A non-zero value indicates that\n * fragmented interleave is on.  A value of zero indicates that\n * fragmented interleave is off.\n *\n * Note that it is important that an implementation that allows this\n * option to be turned on, have it off by default.  Otherwise an unaware\n * application using the one to many model may become confused and act\n * incorrectly.\n */\nstatic int sctp_setsockopt_fragment_interleave(struct sock *sk,\n\t\t\t\t\t       char __user *optval,\n\t\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->frag_interleave = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\n/*\n * 8.1.21.  Set or Get the SCTP Partial Delivery Point\n *       (SCTP_PARTIAL_DELIVERY_POINT)\n *\n * This option will set or get the SCTP partial delivery point.  This\n * point is the size of a message where the partial delivery API will be\n * invoked to help free up rwnd space for the peer.  Setting this to a\n * lower value will cause partial deliveries to happen more often.  The\n * calls argument is an integer that sets or gets the partial delivery\n * point.  Note also that the call will fail if the user attempts to set\n * this value larger than the socket receive buffer size.\n *\n * Note that any single message having a length smaller than or equal to\n * the SCTP partial delivery point will be delivered in one single read\n * call as long as the user provided buffer is large enough to hold the\n * message.\n */\nstatic int sctp_setsockopt_partial_delivery_point(struct sock *sk,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  unsigned int optlen)\n{\n\tu32 val;\n\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\t/* Note: We double the receive buffer from what the user sets\n\t * it to be, also initial rwnd is based on rcvbuf/2.\n\t */\n\tif (val > (sk->sk_rcvbuf >> 1))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->pd_point = val;\n\n\treturn 0; /* is this the right error code? */\n}\n\n/*\n * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)\n *\n * This option will allow a user to change the maximum burst of packets\n * that can be emitted by this association.  Note that the default value\n * is 4, and some implementations may restrict this setting so that it\n * can only be lowered.\n *\n * NOTE: This text doesn't seem right.  Do this on a socket basis with\n * future associations inheriting the socket value.\n */\nstatic int sctp_setsockopt_maxburst(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\tint val;\n\tint assoc_id = 0;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option deprecated.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&val, optval, optlen))\n\t\t\treturn -EFAULT;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tval = params.assoc_value;\n\t\tassoc_id = params.assoc_id;\n\t} else\n\t\treturn -EINVAL;\n\n\tsp = sctp_sk(sk);\n\n\tif (assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tasoc->max_burst = val;\n\t} else\n\t\tsp->max_burst = val;\n\n\treturn 0;\n}\n\n/*\n * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)\n *\n * This set option adds a chunk type that the user is requesting to be\n * received only in an authenticated way.  Changes to the list of chunks\n * will only effect future associations on the socket.\n */\nstatic int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunk val;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (val.sauth_chunk) {\n\tcase SCTP_CID_INIT:\n\tcase SCTP_CID_INIT_ACK:\n\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\tcase SCTP_CID_AUTH:\n\t\treturn -EINVAL;\n\t}\n\n\t/* add this chunk id to the endpoint */\n\treturn sctp_auth_ep_add_chunkid(ep, val.sauth_chunk);\n}\n\n/*\n * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)\n *\n * This option gets or sets the list of HMAC algorithms that the local\n * endpoint requires the peer to use.\n */\nstatic int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_hmacalgo *hmacs;\n\tu32 idents;\n\tint err;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = memdup_user(optval, optlen);\n\tif (IS_ERR(hmacs))\n\t\treturn PTR_ERR(hmacs);\n\n\tidents = hmacs->shmac_num_idents;\n\tif (idents == 0 || idents > SCTP_AUTH_NUM_HMACS ||\n\t    (idents * sizeof(u16)) > (optlen - sizeof(struct sctp_hmacalgo))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}\n\n/*\n * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)\n *\n * This option will set a shared secret key which is used to build an\n * association shared key.\n */\nstatic int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = memdup_user(optval, optlen);\n\tif (IS_ERR(authkey))\n\t\treturn PTR_ERR(authkey);\n\n\tif (authkey->sca_keylength > optlen - sizeof(struct sctp_authkey)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(ep, asoc, authkey);\nout:\n\tkzfree(authkey);\n\treturn ret;\n}\n\n/*\n * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)\n *\n * This option will get or set the active shared key to be used to build\n * the association shared key.\n */\nstatic int sctp_setsockopt_active_key(struct sock *sk,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_set_active_key(ep, asoc, val.scact_keynumber);\n}\n\n/*\n * 7.1.22.  Delete a shared key (SCTP_AUTH_DELETE_KEY)\n *\n * This set option will delete a shared secret key from use.\n */\nstatic int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t   char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_del_key_id(ep, asoc, val.scact_keynumber);\n\n}\n\n/*\n * 8.1.23 SCTP_AUTO_ASCONF\n *\n * This option will enable or disable the use of the automatic generation of\n * ASCONF chunks to add and delete addresses to an existing association.  Note\n * that this option has two caveats namely: a) it only affects sockets that\n * are bound to all addresses available to the SCTP stack, and b) the system\n * administrator may have an overriding control that turns the ASCONF feature\n * off no matter what setting the socket option may have.\n * This option expects an integer boolean flag, where a non-zero value turns on\n * the option, and a zero value turns off the option.\n * Note. In this implementation, socket operation overrides default parameter\n * being set by sysctl as well as FreeBSD implementation\n */\nstatic int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (!sctp_is_ep_boundall(sk) && val)\n\t\treturn -EINVAL;\n\tif ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))\n\t\treturn 0;\n\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}\n\n/*\n * SCTP_PEER_ADDR_THLDS\n *\n * This option allows us to alter the partially failed threshold for one or all\n * transports in an association.  See Section 6.1 of:\n * http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt\n */\nstatic int sctp_setsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_paddrthlds val;\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\n\tif (optlen < sizeof(struct sctp_paddrthlds))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, (struct sctp_paddrthlds __user *)optval,\n\t\t\t   sizeof(struct sctp_paddrthlds)))\n\t\treturn -EFAULT;\n\n\n\tif (sctp_is_any(sk, (const union sctp_addr *)&val.spt_address)) {\n\t\tasoc = sctp_id2assoc(sk, val.spt_assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -ENOENT;\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports) {\n\t\t\tif (val.spt_pathmaxrxt)\n\t\t\t\ttrans->pathmaxrxt = val.spt_pathmaxrxt;\n\t\t\ttrans->pf_retrans = val.spt_pathpfthld;\n\t\t}\n\n\t\tif (val.spt_pathmaxrxt)\n\t\t\tasoc->pathmaxrxt = val.spt_pathmaxrxt;\n\t\tasoc->pf_retrans = val.spt_pathpfthld;\n\t} else {\n\t\ttrans = sctp_addr_id2transport(sk, &val.spt_address,\n\t\t\t\t\t       val.spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tif (val.spt_pathmaxrxt)\n\t\t\ttrans->pathmaxrxt = val.spt_pathmaxrxt;\n\t\ttrans->pf_retrans = val.spt_pathpfthld;\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvrcvinfo(struct sock *sk,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->recvrcvinfo = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvnxtinfo(struct sock *sk,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->recvnxtinfo = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_pr_supported(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(params))\n\t\tgoto out;\n\n\tif (copy_from_user(&params, optval, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tasoc->prsctp_enable = !!params.assoc_value;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tsp->ep->prsctp_enable = !!params.assoc_value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_default_prinfo(struct sock *sk,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_default_prinfo info;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(info))\n\t\tgoto out;\n\n\tif (copy_from_user(&info, optval, sizeof(info))) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (info.pr_policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tif (info.pr_policy == SCTP_PR_SCTP_NONE)\n\t\tinfo.pr_value = 0;\n\n\tasoc = sctp_id2assoc(sk, info.pr_assoc_id);\n\tif (asoc) {\n\t\tSCTP_PR_SET_POLICY(asoc->default_flags, info.pr_policy);\n\t\tasoc->default_timetolive = info.pr_value;\n\t} else if (!info.pr_assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tSCTP_PR_SET_POLICY(sp->default_flags, info.pr_policy);\n\t\tsp->default_timetolive = info.pr_value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\n/* API 6.2 setsockopt(), getsockopt()\n *\n * Applications use setsockopt() and getsockopt() to set or retrieve\n * socket options.  Socket options are used to change the default\n * behavior of sockets calls.  They are described in Section 7.\n *\n * The syntax is:\n *\n *   ret = getsockopt(int sd, int level, int optname, void __user *optval,\n *                    int __user *optlen);\n *   ret = setsockopt(int sd, int level, int optname, const void __user *optval,\n *                    int optlen);\n *\n *   sd      - the socket descript.\n *   level   - set to IPPROTO_SCTP for all SCTP options.\n *   optname - the option name.\n *   optval  - the buffer to store the value of the option.\n *   optlen  - the size of the buffer.\n */\nstatic int sctp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint retval = 0;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t/* I can hardly begin to describe how wrong this is.  This is\n\t * so broken as to be worse than useless.  The API draft\n\t * REALLY is NOT helpful here...  I am not convinced that the\n\t * semantics of setsockopt() with a level OTHER THAN SOL_SCTP\n\t * are at all well-founded.\n\t */\n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\t\tretval = af->setsockopt(sk, level, optname, optval, optlen);\n\t\tgoto out_nounlock;\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_SOCKOPT_BINDX_ADD:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_bindx(sk, (struct sockaddr __user *)optval,\n\t\t\t\t\t       optlen, SCTP_BINDX_ADD_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_BINDX_REM:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_bindx(sk, (struct sockaddr __user *)optval,\n\t\t\t\t\t       optlen, SCTP_BINDX_REM_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX_OLD:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_connectx_old(sk,\n\t\t\t\t\t    (struct sockaddr __user *)optval,\n\t\t\t\t\t    optlen);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_connectx(sk,\n\t\t\t\t\t    (struct sockaddr __user *)optval,\n\t\t\t\t\t    optlen);\n\t\tbreak;\n\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_setsockopt_disable_fragments(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_setsockopt_events(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_setsockopt_autoclose(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_setsockopt_peer_addr_params(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_setsockopt_delayed_ack(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_setsockopt_partial_delivery_point(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_setsockopt_initmsg(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_setsockopt_default_send_param(sk, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_setsockopt_default_sndinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_primary_addr(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SET_PEER_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_peer_primary_addr(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_setsockopt_nodelay(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_setsockopt_rtoinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_setsockopt_associnfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_setsockopt_mappedv4(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_setsockopt_maxseg(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_setsockopt_adaptation_layer(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_setsockopt_context(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_setsockopt_fragment_interleave(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_setsockopt_maxburst(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_CHUNK:\n\t\tretval = sctp_setsockopt_auth_chunk(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_setsockopt_hmac_ident(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\t\tretval = sctp_setsockopt_auth_key(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_setsockopt_active_key(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_DELETE_KEY:\n\t\tretval = sctp_setsockopt_del_key(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_setsockopt_auto_asconf(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_setsockopt_recvnxtinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_setsockopt_pr_supported(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_setsockopt_default_prinfo(sk, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\nout_nounlock:\n\treturn retval;\n}\n\n/* API 3.1.6 connect() - UDP Style Syntax\n *\n * An application may use the connect() call in the UDP model to initiate an\n * association without sending data.\n *\n * The syntax is:\n *\n * ret = connect(int sd, const struct sockaddr *nam, socklen_t len);\n *\n * sd: the socket descriptor to have a new association added to.\n *\n * nam: the address structure (either struct sockaddr_in or struct\n *    sockaddr_in6 defined in RFC2553 [7]).\n *\n * len: the size of the address.\n */\nstatic int sctp_connect(struct sock *sk, struct sockaddr *addr,\n\t\t\tint addr_len)\n{\n\tint err = 0;\n\tstruct sctp_af *af;\n\n\tlock_sock(sk);\n\n\tpr_debug(\"%s: sk:%p, sockaddr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t/* Validate addr_len before calling common connect/connectx routine. */\n\taf = sctp_get_af_specific(addr->sa_family);\n\tif (!af || addr_len < af->sockaddr_len) {\n\t\terr = -EINVAL;\n\t} else {\n\t\t/* Pass correct addr len to common routine (so it knows there\n\t\t * is only one address being passed.\n\t\t */\n\t\terr = __sctp_connect(sk, addr, af->sockaddr_len, NULL);\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* FIXME: Write comments. */\nstatic int sctp_disconnect(struct sock *sk, int flags)\n{\n\treturn -EOPNOTSUPP; /* STUB */\n}\n\n/* 4.1.4 accept() - TCP Style Syntax\n *\n * Applications use accept() call to remove an established SCTP\n * association from the accept queue of the endpoint.  A new socket\n * descriptor will be returned from accept() to represent the newly\n * formed association.\n */\nstatic struct sock *sctp_accept(struct sock *sk, int flags, int *err)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sock *newsk = NULL;\n\tstruct sctp_association *asoc;\n\tlong timeo;\n\tint error = 0;\n\n\tlock_sock(sk);\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!sctp_style(sk, TCP)) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!sctp_sstate(sk, LISTENING)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\terror = sctp_wait_for_accept(sk, timeo);\n\tif (error)\n\t\tgoto out;\n\n\t/* We treat the list of associations on the endpoint as the accept\n\t * queue and pick the first association on the list.\n\t */\n\tasoc = list_entry(ep->asocs.next, struct sctp_association, asocs);\n\n\tnewsk = sp->pf->create_accept_sk(sk, asoc);\n\tif (!newsk) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, newsk, asoc, SCTP_SOCKET_TCP);\n\nout:\n\trelease_sock(sk);\n\t*err = error;\n\treturn newsk;\n}\n\n/* The SCTP ioctl handler. */\nstatic int sctp_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\t/*\n\t * SEQPACKET-style sockets in LISTENING state are valid, for\n\t * SCTP, so only discard TCP-style sockets in LISTENING state.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int amount = 0;\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb != NULL) {\n\t\t\t/*\n\t\t\t * We will only return the amount of this packet since\n\t\t\t * that is all that will be read.\n\t\t\t */\n\t\t\tamount = skb->len;\n\t\t}\n\t\trc = put_user(amount, (int __user *)arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/* This is the function which gets called during socket creation to\n * initialized the SCTP-specific portion of the sock.\n * The sock structure should already be zero-filled memory.\n */\nstatic int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk->sk_gso_type = SKB_GSO_SCTP;\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tmemset(&sp->subscribe, 0, sizeof(struct sctp_event_subscribe));\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tlocal_bh_disable();\n\tpercpu_counter_inc(&sctp_sockets_allocated);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\n\t/* Nothing can fail after this block, otherwise\n\t * sctp_destroy_sock() will be called without addr_wq_lock held\n\t */\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&sock_net(sk)->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &net->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t\tspin_unlock(&sock_net(sk)->sctp.addr_wq_lock);\n\t} else {\n\t\tsp->do_auto_asconf = 0;\n\t}\n\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n\n/* Cleanup any SCTP per socket resources. Must be called with\n * sock_net(sk)->sctp.addr_wq_lock held if sp->do_auto_asconf is true\n */\nstatic void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\t/* Release our hold on the endpoint. */\n\tsp = sctp_sk(sk);\n\t/* This could happen during socket init, thus we bail out\n\t * early, since the rest of the below is not setup either.\n\t */\n\tif (sp->ep == NULL)\n\t\treturn;\n\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tpercpu_counter_dec(&sctp_sockets_allocated);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}\n\n/* Triggered when there are no references on the socket anymore */\nstatic void sctp_destruct_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t/* Free up the HMAC transform. */\n\tcrypto_free_shash(sp->hmac);\n\n\tinet_sock_destruct(sk);\n}\n\n/* API 4.1.7 shutdown() - TCP Style Syntax\n *     int shutdown(int socket, int how);\n *\n *     sd      - the socket descriptor of the association to be closed.\n *     how     - Specifies the type of shutdown.  The  values  are\n *               as follows:\n *               SHUT_RD\n *                     Disables further receive operations. No SCTP\n *                     protocol action is taken.\n *               SHUT_WR\n *                     Disables further send operations, and initiates\n *                     the SCTP shutdown sequence.\n *               SHUT_RDWR\n *                     Disables further send  and  receive  operations\n *                     and initiates the SCTP shutdown sequence.\n */\nstatic void sctp_shutdown(struct sock *sk, int how)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\n\tif (!sctp_style(sk, TCP))\n\t\treturn;\n\n\tep = sctp_sk(sk)->ep;\n\tif (how & SEND_SHUTDOWN && !list_empty(&ep->asocs)) {\n\t\tstruct sctp_association *asoc;\n\n\t\tsk->sk_state = SCTP_SS_CLOSING;\n\t\tasoc = list_entry(ep->asocs.next,\n\t\t\t\t  struct sctp_association, asocs);\n\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n}\n\nint sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,\n\t\t       struct sctp_info *info)\n{\n\tstruct sctp_transport *prim;\n\tstruct list_head *pos;\n\tint mask;\n\n\tmemset(info, 0, sizeof(*info));\n\tif (!asoc) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo->sctpi_s_autoclose = sp->autoclose;\n\t\tinfo->sctpi_s_adaptation_ind = sp->adaptation_ind;\n\t\tinfo->sctpi_s_pd_point = sp->pd_point;\n\t\tinfo->sctpi_s_nodelay = sp->nodelay;\n\t\tinfo->sctpi_s_disable_fragments = sp->disable_fragments;\n\t\tinfo->sctpi_s_v4mapped = sp->v4mapped;\n\t\tinfo->sctpi_s_frag_interleave = sp->frag_interleave;\n\t\tinfo->sctpi_s_type = sp->type;\n\n\t\treturn 0;\n\t}\n\n\tinfo->sctpi_tag = asoc->c.my_vtag;\n\tinfo->sctpi_state = asoc->state;\n\tinfo->sctpi_rwnd = asoc->a_rwnd;\n\tinfo->sctpi_unackdata = asoc->unack_data;\n\tinfo->sctpi_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tinfo->sctpi_instrms = asoc->c.sinit_max_instreams;\n\tinfo->sctpi_outstrms = asoc->c.sinit_num_ostreams;\n\tlist_for_each(pos, &asoc->base.inqueue.in_chunk_list)\n\t\tinfo->sctpi_inqueue++;\n\tlist_for_each(pos, &asoc->outqueue.out_chunk_list)\n\t\tinfo->sctpi_outqueue++;\n\tinfo->sctpi_overall_error = asoc->overall_error_count;\n\tinfo->sctpi_max_burst = asoc->max_burst;\n\tinfo->sctpi_maxseg = asoc->frag_point;\n\tinfo->sctpi_peer_rwnd = asoc->peer.rwnd;\n\tinfo->sctpi_peer_tag = asoc->c.peer_vtag;\n\n\tmask = asoc->peer.ecn_capable << 1;\n\tmask = (mask | asoc->peer.ipv4_address) << 1;\n\tmask = (mask | asoc->peer.ipv6_address) << 1;\n\tmask = (mask | asoc->peer.hostname_address) << 1;\n\tmask = (mask | asoc->peer.asconf_capable) << 1;\n\tmask = (mask | asoc->peer.prsctp_capable) << 1;\n\tmask = (mask | asoc->peer.auth_capable);\n\tinfo->sctpi_peer_capable = mask;\n\tmask = asoc->peer.sack_needed << 1;\n\tmask = (mask | asoc->peer.sack_generation) << 1;\n\tmask = (mask | asoc->peer.zero_window_announced);\n\tinfo->sctpi_peer_sack = mask;\n\n\tinfo->sctpi_isacks = asoc->stats.isacks;\n\tinfo->sctpi_osacks = asoc->stats.osacks;\n\tinfo->sctpi_opackets = asoc->stats.opackets;\n\tinfo->sctpi_ipackets = asoc->stats.ipackets;\n\tinfo->sctpi_rtxchunks = asoc->stats.rtxchunks;\n\tinfo->sctpi_outofseqtsns = asoc->stats.outofseqtsns;\n\tinfo->sctpi_idupchunks = asoc->stats.idupchunks;\n\tinfo->sctpi_gapcnt = asoc->stats.gapcnt;\n\tinfo->sctpi_ouodchunks = asoc->stats.ouodchunks;\n\tinfo->sctpi_iuodchunks = asoc->stats.iuodchunks;\n\tinfo->sctpi_oodchunks = asoc->stats.oodchunks;\n\tinfo->sctpi_iodchunks = asoc->stats.iodchunks;\n\tinfo->sctpi_octrlchunks = asoc->stats.octrlchunks;\n\tinfo->sctpi_ictrlchunks = asoc->stats.ictrlchunks;\n\n\tprim = asoc->peer.primary_path;\n\tmemcpy(&info->sctpi_p_address, &prim->ipaddr,\n\t       sizeof(struct sockaddr_storage));\n\tinfo->sctpi_p_state = prim->state;\n\tinfo->sctpi_p_cwnd = prim->cwnd;\n\tinfo->sctpi_p_srtt = prim->srtt;\n\tinfo->sctpi_p_rto = jiffies_to_msecs(prim->rto);\n\tinfo->sctpi_p_hbinterval = prim->hbinterval;\n\tinfo->sctpi_p_pathmaxrxt = prim->pathmaxrxt;\n\tinfo->sctpi_p_sackdelay = jiffies_to_msecs(prim->sackdelay);\n\tinfo->sctpi_p_ssthresh = prim->ssthresh;\n\tinfo->sctpi_p_partial_bytes_acked = prim->partial_bytes_acked;\n\tinfo->sctpi_p_flight_size = prim->flight_size;\n\tinfo->sctpi_p_error = prim->error_count;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sctp_get_sctp_info);\n\n/* use callback to avoid exporting the core structure */\nint sctp_transport_walk_start(struct rhashtable_iter *iter)\n{\n\tint err;\n\n\trhltable_walk_enter(&sctp_transport_hashtable, iter);\n\n\terr = rhashtable_walk_start(iter);\n\tif (err && err != -EAGAIN) {\n\t\trhashtable_walk_stop(iter);\n\t\trhashtable_walk_exit(iter);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid sctp_transport_walk_stop(struct rhashtable_iter *iter)\n{\n\trhashtable_walk_stop(iter);\n\trhashtable_walk_exit(iter);\n}\n\nstruct sctp_transport *sctp_transport_get_next(struct net *net,\n\t\t\t\t\t       struct rhashtable_iter *iter)\n{\n\tstruct sctp_transport *t;\n\n\tt = rhashtable_walk_next(iter);\n\tfor (; t; t = rhashtable_walk_next(iter)) {\n\t\tif (IS_ERR(t)) {\n\t\t\tif (PTR_ERR(t) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (net_eq(sock_net(t->asoc->base.sk), net) &&\n\t\t    t->asoc->peer.primary_path == t)\n\t\t\tbreak;\n\t}\n\n\treturn t;\n}\n\nstruct sctp_transport *sctp_transport_get_idx(struct net *net,\n\t\t\t\t\t      struct rhashtable_iter *iter,\n\t\t\t\t\t      int pos)\n{\n\tvoid *obj = SEQ_START_TOKEN;\n\n\twhile (pos && (obj = sctp_transport_get_next(net, iter)) &&\n\t       !IS_ERR(obj))\n\t\tpos--;\n\n\treturn obj;\n}\n\nint sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),\n\t\t\t   void *p) {\n\tint err = 0;\n\tint hash = 0;\n\tstruct sctp_ep_common *epb;\n\tstruct sctp_hashbucket *head;\n\n\tfor (head = sctp_ep_hashtable; hash < sctp_ep_hashsize;\n\t     hash++, head++) {\n\t\tread_lock(&head->lock);\n\t\tsctp_for_each_hentry(epb, &head->chain) {\n\t\t\terr = cb(sctp_ep(epb), p);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tread_unlock(&head->lock);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_endpoint);\n\nint sctp_transport_lookup_process(int (*cb)(struct sctp_transport *, void *),\n\t\t\t\t  struct net *net,\n\t\t\t\t  const union sctp_addr *laddr,\n\t\t\t\t  const union sctp_addr *paddr, void *p)\n{\n\tstruct sctp_transport *transport;\n\tint err;\n\n\trcu_read_lock();\n\ttransport = sctp_addrs_lookup_transport(net, laddr, paddr);\n\trcu_read_unlock();\n\tif (!transport)\n\t\treturn -ENOENT;\n\n\terr = cb(transport, p);\n\tsctp_transport_put(transport);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_transport_lookup_process);\n\nint sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),\n\t\t\t    struct net *net, int pos, void *p) {\n\tstruct rhashtable_iter hti;\n\tvoid *obj;\n\tint err;\n\n\terr = sctp_transport_walk_start(&hti);\n\tif (err)\n\t\treturn err;\n\n\tsctp_transport_get_idx(net, &hti, pos);\n\tobj = sctp_transport_get_next(net, &hti);\n\tfor (; obj && !IS_ERR(obj); obj = sctp_transport_get_next(net, &hti)) {\n\t\tstruct sctp_transport *transport = obj;\n\n\t\tif (!sctp_transport_hold(transport))\n\t\t\tcontinue;\n\t\terr = cb(transport, p);\n\t\tsctp_transport_put(transport);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tsctp_transport_walk_stop(&hti);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_transport);\n\n/* 7.2.1 Association Status (SCTP_STATUS)\n\n * Applications can retrieve current status information about an\n * association, including association state, peer receiver window size,\n * number of unacked data chunks, and number of data chunks pending\n * receipt.  This information is read-only.\n */\nstatic int sctp_getsockopt_sctp_status(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_status status;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_transport *transport;\n\tsctp_assoc_t associd;\n\tint retval = 0;\n\n\tif (len < sizeof(status)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(status);\n\tif (copy_from_user(&status, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tassocid = status.sstat_assoc_id;\n\tasoc = sctp_id2assoc(sk, associd);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttransport = asoc->peer.primary_path;\n\n\tstatus.sstat_assoc_id = sctp_assoc2id(asoc);\n\tstatus.sstat_state = sctp_assoc_to_state(asoc);\n\tstatus.sstat_rwnd =  asoc->peer.rwnd;\n\tstatus.sstat_unackdata = asoc->unack_data;\n\n\tstatus.sstat_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tstatus.sstat_instrms = asoc->c.sinit_max_instreams;\n\tstatus.sstat_outstrms = asoc->c.sinit_num_ostreams;\n\tstatus.sstat_fragmentation_point = asoc->frag_point;\n\tstatus.sstat_primary.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tmemcpy(&status.sstat_primary.spinfo_address, &transport->ipaddr,\n\t\t\ttransport->af_specific->sockaddr_len);\n\t/* Map ipv4 address into v4-mapped-on-v6 address.  */\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t(union sctp_addr *)&status.sstat_primary.spinfo_address);\n\tstatus.sstat_primary.spinfo_state = transport->state;\n\tstatus.sstat_primary.spinfo_cwnd = transport->cwnd;\n\tstatus.sstat_primary.spinfo_srtt = transport->srtt;\n\tstatus.sstat_primary.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tstatus.sstat_primary.spinfo_mtu = transport->pathmtu;\n\n\tif (status.sstat_primary.spinfo_state == SCTP_UNKNOWN)\n\t\tstatus.sstat_primary.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"%s: len:%d, state:%d, rwnd:%d, assoc_id:%d\\n\",\n\t\t __func__, len, status.sstat_state, status.sstat_rwnd,\n\t\t status.sstat_assoc_id);\n\n\tif (copy_to_user(optval, &status, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n\n/* 7.2.2 Peer Address Information (SCTP_GET_PEER_ADDR_INFO)\n *\n * Applications can retrieve information about a specific peer address\n * of an association, including its reachability state, congestion\n * window, and retransmission timer values.  This information is\n * read-only.\n */\nstatic int sctp_getsockopt_peer_addr_info(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_paddrinfo pinfo;\n\tstruct sctp_transport *transport;\n\tint retval = 0;\n\n\tif (len < sizeof(pinfo)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(pinfo);\n\tif (copy_from_user(&pinfo, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\ttransport = sctp_addr_id2transport(sk, &pinfo.spinfo_address,\n\t\t\t\t\t   pinfo.spinfo_assoc_id);\n\tif (!transport)\n\t\treturn -EINVAL;\n\n\tpinfo.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tpinfo.spinfo_state = transport->state;\n\tpinfo.spinfo_cwnd = transport->cwnd;\n\tpinfo.spinfo_srtt = transport->srtt;\n\tpinfo.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tpinfo.spinfo_mtu = transport->pathmtu;\n\n\tif (pinfo.spinfo_state == SCTP_UNKNOWN)\n\t\tpinfo.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &pinfo, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)\n *\n * This option is a on/off flag.  If enabled no SCTP message\n * fragmentation will be performed.  Instead if a message being sent\n * exceeds the current PMTU size, the message will NOT be sent and\n * instead a error will be indicated to the user.\n */\nstatic int sctp_getsockopt_disable_fragments(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->disable_fragments == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* 7.1.15 Set notification and ancillary events (SCTP_EVENTS)\n *\n * This socket option is used to specify various notifications and\n * ancillary data the user wishes to receive.\n */\nstatic int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > sizeof(struct sctp_event_subscribe))\n\t\tlen = sizeof(struct sctp_event_subscribe);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->subscribe, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)\n *\n * This socket option is applicable to the UDP-style socket only.  When\n * set it will cause associations that are idle for more than the\n * specified number of seconds to automatically close.  An association\n * being idle is defined an association that has NOT sent or received\n * user data.  The special value of '0' indicates that no automatic\n * close of any associations should be performed.  The option expects an\n * integer defining the number of seconds of idle time before an\n * association is closed.\n */\nstatic int sctp_getsockopt_autoclose(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\tlen = sizeof(int);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->autoclose, sizeof(int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* Helper routine to branch off an association to a new socket.  */\nint sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\nEXPORT_SYMBOL(sctp_do_peeloff);\n\nstatic int sctp_getsockopt_peeloff(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_arg_t peeloff;\n\tstruct socket *newsock;\n\tstruct file *newfile;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_do_peeloff(sk, peeloff.associd, &newsock);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* Map the socket to an unused fd that can be returned to the user.  */\n\tretval = get_unused_fd_flags(0);\n\tif (retval < 0) {\n\t\tsock_release(newsock);\n\t\tgoto out;\n\t}\n\n\tnewfile = sock_alloc_file(newsock, 0, NULL);\n\tif (IS_ERR(newfile)) {\n\t\tput_unused_fd(retval);\n\t\tsock_release(newsock);\n\t\treturn PTR_ERR(newfile);\n\t}\n\n\tpr_debug(\"%s: sk:%p, newsk:%p, sd:%d\\n\", __func__, sk, newsock->sk,\n\t\t retval);\n\n\t/* Return the fd mapped to the new socket.  */\n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tpeeloff.sd = retval;\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}\n\n/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n *\n * Applications can enable or disable heartbeats for any peer address of\n * an association, modify an address's heartbeat interval, force a\n * heartbeat to be sent immediately, and adjust the address's maximum\n * number of retransmissions sent before an address is considered\n * unreachable.  The following structure is used to access and modify an\n * address's parameters:\n *\n *  struct sctp_paddrparams {\n *     sctp_assoc_t            spp_assoc_id;\n *     struct sockaddr_storage spp_address;\n *     uint32_t                spp_hbinterval;\n *     uint16_t                spp_pathmaxrxt;\n *     uint32_t                spp_pathmtu;\n *     uint32_t                spp_sackdelay;\n *     uint32_t                spp_flags;\n * };\n *\n *   spp_assoc_id    - (one-to-many style socket) This is filled in the\n *                     application, and identifies the association for\n *                     this query.\n *   spp_address     - This specifies which address is of interest.\n *   spp_hbinterval  - This contains the value of the heartbeat interval,\n *                     in milliseconds.  If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmaxrxt  - This contains the maximum number of\n *                     retransmissions before this address shall be\n *                     considered unreachable. If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmtu     - When Path MTU discovery is disabled the value\n *                     specified here will be the \"fixed\" path mtu.\n *                     Note that if the spp_address field is empty\n *                     then all associations on this address will\n *                     have this fixed path mtu set upon them.\n *\n *   spp_sackdelay   - When delayed sack is enabled, this value specifies\n *                     the number of milliseconds that sacks will be delayed\n *                     for. This value will apply to all addresses of an\n *                     association if the spp_address field is empty. Note\n *                     also, that if delayed sack is enabled and this\n *                     value is set to 0, no change is made to the last\n *                     recorded delayed sack timer value.\n *\n *   spp_flags       - These flags are used to control various features\n *                     on an association. The flag field may contain\n *                     zero or more of the following options.\n *\n *                     SPP_HB_ENABLE  - Enable heartbeats on the\n *                     specified address. Note that if the address\n *                     field is empty all addresses for the association\n *                     have heartbeats enabled upon them.\n *\n *                     SPP_HB_DISABLE - Disable heartbeats on the\n *                     speicifed address. Note that if the address\n *                     field is empty all addresses for the association\n *                     will have their heartbeats disabled. Note also\n *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are\n *                     mutually exclusive, only one of these two should\n *                     be specified. Enabling both fields will have\n *                     undetermined results.\n *\n *                     SPP_HB_DEMAND - Request a user initiated heartbeat\n *                     to be made immediately.\n *\n *                     SPP_PMTUD_ENABLE - This field will enable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected.\n *\n *                     SPP_PMTUD_DISABLE - This field will disable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected. Not also that\n *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n *                     exclusive. Enabling both will have undetermined\n *                     results.\n *\n *                     SPP_SACKDELAY_ENABLE - Setting this flag turns\n *                     on delayed sack. The time specified in spp_sackdelay\n *                     is used to specify the sack delay for this address. Note\n *                     that if spp_address is empty then all addresses will\n *                     enable delayed sack and take on the sack delay\n *                     value specified in spp_sackdelay.\n *                     SPP_SACKDELAY_DISABLE - Setting this flag turns\n *                     off delayed sack. If the spp_address field is blank then\n *                     delayed sack is disabled for the entire association. Note\n *                     also that this field is mutually exclusive to\n *                     SPP_SACKDELAY_ENABLE, setting both will have undefined\n *                     results.\n */\nstatic int sctp_getsockopt_peer_addr_params(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_paddrparams))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_paddrparams);\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Get association, if assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id && sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trans) {\n\t\t/* Fetch transport values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);\n\t\tparams.spp_pathmtu    = trans->pathmtu;\n\t\tparams.spp_pathmaxrxt = trans->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(trans->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = trans->param_flags;\n\t} else if (asoc) {\n\t\t/* Fetch association values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(asoc->hbinterval);\n\t\tparams.spp_pathmtu    = asoc->pathmtu;\n\t\tparams.spp_pathmaxrxt = asoc->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(asoc->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = asoc->param_flags;\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tparams.spp_hbinterval = sp->hbinterval;\n\t\tparams.spp_pathmtu    = sp->pathmtu;\n\t\tparams.spp_sackdelay  = sp->sackdelay;\n\t\tparams.spp_pathmaxrxt = sp->pathmaxrxt;\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = sp->param_flags;\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)\n *\n * This option will effect the way delayed acks are performed.  This\n * option allows you to get or set the delayed ack time, in\n * milliseconds.  It also allows changing the delayed ack frequency.\n * Changing the frequency to 1 disables the delayed sack algorithm.  If\n * the assoc_id is 0, then this sets or gets the endpoints default\n * values.  If the assoc_id field is non-zero, then the set or get\n * effects the specified association for the one to many model (the\n * assoc_id field is ignored by the one to one model).  Note that if\n * sack_delay or sack_freq are 0 when setting this option, then the\n * current values will remain unchanged.\n *\n * struct sctp_sack_info {\n *     sctp_assoc_t            sack_assoc_id;\n *     uint32_t                sack_delay;\n *     uint32_t                sack_freq;\n * };\n *\n * sack_assoc_id -  This parameter, indicates which association the user\n *    is performing an action upon.  Note that if this field's value is\n *    zero then the endpoints default value is changed (effecting future\n *    associations only).\n *\n * sack_delay -  This parameter contains the number of milliseconds that\n *    the user is requesting the delayed ACK timer be set to.  Note that\n *    this value is defined in the standard to be between 200 and 500\n *    milliseconds.\n *\n * sack_freq -  This parameter contains the number of packets that must\n *    be received before a sack is sent without waiting for the delay\n *    timer to expire.  The default value for this is 2, setting this\n *    value to 1 will disable the delayed sack algorithm.\n */\nstatic int sctp_getsockopt_delayed_ack(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_sack_info    params;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len >= sizeof(struct sctp_sack_info)) {\n\t\tlen = sizeof(struct sctp_sack_info);\n\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else if (len == sizeof(struct sctp_assoc_value)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\t/* Get association, if sack_assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.sack_assoc_id);\n\tif (!asoc && params.sack_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\t/* Fetch association values. */\n\t\tif (asoc->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay = jiffies_to_msecs(\n\t\t\t\tasoc->sackdelay);\n\t\t\tparams.sack_freq = asoc->sackfreq;\n\n\t\t} else {\n\t\t\tparams.sack_delay = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tif (sp->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay  = sp->sackdelay;\n\t\t\tparams.sack_freq = sp->sackfreq;\n\t\t} else {\n\t\t\tparams.sack_delay  = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* 7.1.3 Initialization Parameters (SCTP_INITMSG)\n *\n * Applications can specify protocol parameters for the default association\n * initialization.  The option name argument to setsockopt() and getsockopt()\n * is SCTP_INITMSG.\n *\n * Setting initialization parameters is effective only on an unconnected\n * socket (for UDP-style sockets only future associations are effected\n * by the change).  With TCP-style sockets, this option is inherited by\n * sockets derived from a listener socket.\n */\nstatic int sctp_getsockopt_initmsg(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tif (len < sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_initmsg);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->initmsg, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\nstatic int sctp_getsockopt_peer_addrs(struct sock *sk, int len,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_transport *from;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tsize_t space_left;\n\tint bytes_copied;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t/* For UDP-style sockets, id specifies the association to query.  */\n\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\tlist_for_each_entry(from, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tmemcpy(&temp, &from->ipaddr, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(to, &temp, addrlen))\n\t\t\treturn -EFAULT;\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num))\n\t\treturn -EFAULT;\n\tbytes_copied = ((char __user *)to) - optval;\n\tif (put_user(bytes_copied, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_copy_laddrs(struct sock *sk, __u16 port, void *to,\n\t\t\t    size_t space_left, int *bytes_copied)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tunion sctp_addr temp;\n\tint cnt = 0;\n\tint addrlen;\n\tstruct net *net = sock_net(sk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &net->sctp.local_addr_list, list) {\n\t\tif (!addr->valid)\n\t\t\tcontinue;\n\n\t\tif ((PF_INET == sk->sk_family) &&\n\t\t    (AF_INET6 == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tif ((PF_INET6 == sk->sk_family) &&\n\t\t    inet_v6_ipv6only(sk) &&\n\t\t    (AF_INET == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\tif (!temp.v4.sin_port)\n\t\t\ttemp.v4.sin_port = htons(port);\n\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sctp_sk(sk), &temp);\n\n\t\tif (space_left < addrlen) {\n\t\t\tcnt =  -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(to, &temp, addrlen);\n\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t\t*bytes_copied += addrlen;\n\t}\n\trcu_read_unlock();\n\n\treturn cnt;\n}\n\n\nstatic int sctp_getsockopt_local_addrs(struct sock *sk, int len,\n\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_sockaddr_entry *addr;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tint err = 0;\n\tsize_t space_left;\n\tint bytes_copied = 0;\n\tvoid *addrs;\n\tvoid *buf;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t/*\n\t *  For UDP-style sockets, id specifies the association to query.\n\t *  If the id field is set to the value '0' then the locally bound\n\t *  addresses are returned without regard to any particular\n\t *  association.\n\t */\n\tif (0 == getaddrs.assoc_id) {\n\t\tbp = &sctp_sk(sk)->ep->base.bind_addr;\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tbp = &asoc->base.bind_addr;\n\t}\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\taddrs = kmalloc(space_left, GFP_USER | __GFP_NOWARN);\n\tif (!addrs)\n\t\treturn -ENOMEM;\n\n\t/* If the endpoint is bound to 0.0.0.0 or ::0, get the valid\n\t * addresses from the global local address list.\n\t */\n\tif (sctp_list_single_entry(&bp->address_list)) {\n\t\taddr = list_entry(bp->address_list.next,\n\t\t\t\t  struct sctp_sockaddr_entry, list);\n\t\tif (sctp_is_any(sk, &addr->a)) {\n\t\t\tcnt = sctp_copy_laddrs(sk, bp->port, addrs,\n\t\t\t\t\t\tspace_left, &bytes_copied);\n\t\t\tif (cnt < 0) {\n\t\t\t\terr = cnt;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto copy_getaddrs;\n\t\t}\n\t}\n\n\tbuf = addrs;\n\t/* Protection on the bound address list is not needed since\n\t * in the socket option context we hold a socket lock and\n\t * thus the bound address list can't change.\n\t */\n\tlist_for_each_entry(addr, &bp->address_list, list) {\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen) {\n\t\t\terr =  -ENOMEM; /*fixme: right error?*/\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buf, &temp, addrlen);\n\t\tbuf += addrlen;\n\t\tbytes_copied += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\ncopy_getaddrs:\n\tif (copy_to_user(to, addrs, bytes_copied)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (put_user(bytes_copied, optlen))\n\t\terr = -EFAULT;\nout:\n\tkfree(addrs);\n\treturn err;\n}\n\n/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)\n *\n * Requests that the local SCTP stack use the enclosed peer address as\n * the association primary.  The enclosed address must be one of the\n * association peer's addresses.\n */\nstatic int sctp_getsockopt_primary_addr(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct sctp_prim prim;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_prim);\n\n\tif (copy_from_user(&prim, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, prim.ssp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.primary_path)\n\t\treturn -ENOTCONN;\n\n\tmemcpy(&prim.ssp_addr, &asoc->peer.primary_path->ipaddr,\n\t\tasoc->peer.primary_path->af_specific->sockaddr_len);\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sp,\n\t\t\t(union sctp_addr *)&prim.ssp_addr);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &prim, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.11  Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)\n *\n * Requests that the local endpoint set the specified Adaptation Layer\n * Indication parameter for all future INIT and INIT-ACK exchanges.\n */\nstatic int sctp_getsockopt_adaptation_layer(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (len < sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_setadaptation);\n\n\tadaptation.ssb_adaptation_ind = sctp_sk(sk)->adaptation_ind;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &adaptation, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)\n *\n *   Applications that wish to use the sendto() system call may wish to\n *   specify a default set of parameters that would normally be supplied\n *   through the inclusion of ancillary data.  This socket option allows\n *   such an application to set the default sctp_sndrcvinfo structure.\n\n\n *   The application that wishes to use this socket option simply passes\n *   in to this call the sctp_sndrcvinfo structure defined in Section\n *   5.2.2) The input parameters accepted by this call include\n *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,\n *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in\n *   to this call if the caller is using the UDP model.\n *\n *   For getsockopt, it get the default sctp_sndrcvinfo structure.\n */\nstatic int sctp_getsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\tint len, char __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndrcvinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.sinfo_assoc_id);\n\tif (!asoc && info.sinfo_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tinfo.sinfo_stream = asoc->default_stream;\n\t\tinfo.sinfo_flags = asoc->default_flags;\n\t\tinfo.sinfo_ppid = asoc->default_ppid;\n\t\tinfo.sinfo_context = asoc->default_context;\n\t\tinfo.sinfo_timetolive = asoc->default_timetolive;\n\t} else {\n\t\tinfo.sinfo_stream = sp->default_stream;\n\t\tinfo.sinfo_flags = sp->default_flags;\n\t\tinfo.sinfo_ppid = sp->default_ppid;\n\t\tinfo.sinfo_context = sp->default_context;\n\t\tinfo.sinfo_timetolive = sp->default_timetolive;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* RFC6458, Section 8.1.31. Set/get Default Send Parameters\n * (SCTP_DEFAULT_SNDINFO)\n */\nstatic int sctp_getsockopt_default_sndinfo(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.snd_assoc_id);\n\tif (!asoc && info.snd_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tinfo.snd_sid = asoc->default_stream;\n\t\tinfo.snd_flags = asoc->default_flags;\n\t\tinfo.snd_ppid = asoc->default_ppid;\n\t\tinfo.snd_context = asoc->default_context;\n\t} else {\n\t\tinfo.snd_sid = sp->default_stream;\n\t\tinfo.snd_flags = sp->default_flags;\n\t\tinfo.snd_ppid = sp->default_ppid;\n\t\tinfo.snd_context = sp->default_context;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.5 SCTP_NODELAY\n *\n * Turn on/off any Nagle-like algorithm.  This means that packets are\n * generally sent as soon as possible and no unnecessary delays are\n * introduced, at the cost of more packets in the network.  Expects an\n * integer boolean flag.\n */\n\nstatic int sctp_getsockopt_nodelay(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->nodelay == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n *\n * 7.1.1 SCTP_RTOINFO\n *\n * The protocol parameters used to initialize and bound retransmission\n * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access\n * and modify these parameters.\n * All parameters are time values, in milliseconds.  A value of 0, when\n * modifying the parameters, indicates that the current value should not\n * be changed.\n *\n */\nstatic int sctp_getsockopt_rtoinfo(struct sock *sk, int len,\n\t\t\t\tchar __user *optval,\n\t\t\t\tint __user *optlen) {\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_rtoinfo);\n\n\tif (copy_from_user(&rtoinfo, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\tif (!asoc && rtoinfo.srto_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Values corresponding to the specific association. */\n\tif (asoc) {\n\t\trtoinfo.srto_initial = jiffies_to_msecs(asoc->rto_initial);\n\t\trtoinfo.srto_max = jiffies_to_msecs(asoc->rto_max);\n\t\trtoinfo.srto_min = jiffies_to_msecs(asoc->rto_min);\n\t} else {\n\t\t/* Values corresponding to the endpoint. */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\trtoinfo.srto_initial = sp->rtoinfo.srto_initial;\n\t\trtoinfo.srto_max = sp->rtoinfo.srto_max;\n\t\trtoinfo.srto_min = sp->rtoinfo.srto_min;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &rtoinfo, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.2 SCTP_ASSOCINFO\n *\n * This option is used to tune the maximum retransmission attempts\n * of the association.\n * Returns an error if the new association retransmission value is\n * greater than the sum of the retransmission value  of the peer.\n * See [SCTP] for more information.\n *\n */\nstatic int sctp_getsockopt_associnfo(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos;\n\tint cnt = 0;\n\n\tif (len < sizeof (struct sctp_assocparams))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assocparams);\n\n\tif (copy_from_user(&assocparams, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Values correspoinding to the specific association */\n\tif (asoc) {\n\t\tassocparams.sasoc_asocmaxrxt = asoc->max_retrans;\n\t\tassocparams.sasoc_peer_rwnd = asoc->peer.rwnd;\n\t\tassocparams.sasoc_local_rwnd = asoc->a_rwnd;\n\t\tassocparams.sasoc_cookie_life = ktime_to_ms(asoc->cookie_life);\n\n\t\tlist_for_each(pos, &asoc->peer.transport_addr_list) {\n\t\t\tcnt++;\n\t\t}\n\n\t\tassocparams.sasoc_number_peer_destinations = cnt;\n\t} else {\n\t\t/* Values corresponding to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tassocparams.sasoc_asocmaxrxt = sp->assocparams.sasoc_asocmaxrxt;\n\t\tassocparams.sasoc_peer_rwnd = sp->assocparams.sasoc_peer_rwnd;\n\t\tassocparams.sasoc_local_rwnd = sp->assocparams.sasoc_local_rwnd;\n\t\tassocparams.sasoc_cookie_life =\n\t\t\t\t\tsp->assocparams.sasoc_cookie_life;\n\t\tassocparams.sasoc_number_peer_destinations =\n\t\t\t\t\tsp->assocparams.\n\t\t\t\t\tsasoc_number_peer_destinations;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &assocparams, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n *\n * This socket option is a boolean flag which turns on or off mapped V4\n * addresses.  If this option is turned on and the socket is type\n * PF_INET6, then IPv4 addresses will be mapped to V6 representation.\n * If this option is turned off, then no mapping will be done of V4\n * addresses and a user will receive both PF_INET6 and PF_INET type\n * addresses on the socket.\n */\nstatic int sctp_getsockopt_mappedv4(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = sp->v4mapped;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)\n * (chapter and verse is quoted at sctp_setsockopt_context())\n */\nstatic int sctp_getsockopt_context(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_value);\n\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\tsp = sctp_sk(sk);\n\n\tif (params.assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tparams.assoc_value = asoc->default_rcv_context;\n\t} else {\n\t\tparams.assoc_value = sp->default_rcv_context;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n * This option will get or set the maximum size to put in any outgoing\n * SCTP DATA chunk.  If a message is larger than this size it will be\n * fragmented by SCTP into the specified size.  Note that the underlying\n * SCTP implementation may fragment into smaller sized chunks when the\n * PMTU of the underlying association is smaller than the value set by\n * the user.  The default value for this option is '0' which indicates\n * the user is NOT limiting fragmentation and only the PMTU will effect\n * SCTP's choice of DATA chunk size.  Note also that values set larger\n * than the maximum size of an IP datagram will effectively let SCTP\n * control fragmentation (i.e. the same as setting this option to 0).\n *\n * The following structure is used to access and modify this parameter:\n *\n * struct sctp_assoc_value {\n *   sctp_assoc_t assoc_id;\n *   uint32_t assoc_value;\n * };\n *\n * assoc_id:  This parameter is ignored for one-to-one style sockets.\n *    For one-to-many style sockets this parameter indicates which\n *    association the user is performing an action upon.  Note that if\n *    this field's value is zero then the endpoints default value is\n *    changed (effecting future associations only).\n * assoc_value:  This parameter specifies the maximum size in bytes.\n */\nstatic int sctp_getsockopt_maxseg(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = 0;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, sizeof(params)))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tparams.assoc_value = asoc->frag_point;\n\telse\n\t\tparams.assoc_value = sctp_sk(sk)->user_frag;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*\n * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)\n * (chapter and verse is quoted at sctp_setsockopt_fragment_interleave())\n */\nstatic int sctp_getsockopt_fragment_interleave(struct sock *sk, int len,\n\t\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\n\tval = sctp_sk(sk)->frag_interleave;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.25.  Set or Get the sctp partial delivery point\n * (chapter and verse is quoted at sctp_setsockopt_partial_delivery_point())\n */\nstatic int sctp_getsockopt_partial_delivery_point(struct sock *sk, int len,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int __user *optlen)\n{\n\tu32 val;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tval = sctp_sk(sk)->pd_point;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)\n * (chapter and verse is quoted at sctp_setsockopt_maxburst())\n */\nstatic int sctp_getsockopt_maxburst(struct sock *sk, int len,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = 0;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tsp = sctp_sk(sk);\n\n\tif (params.assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tparams.assoc_value = asoc->max_burst;\n\t} else\n\t\tparams.assoc_value = sp->max_burst;\n\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int sctp_getsockopt_hmac_ident(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_hmacalgo  __user *p = (void __user *)optval;\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 data_len = 0;\n\tu32 num_idents;\n\tint i;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\thmacs = ep->auth_hmacs_list;\n\tdata_len = ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\n\tif (len < sizeof(struct sctp_hmacalgo) + data_len)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_hmacalgo) + data_len;\n\tnum_idents = data_len / sizeof(u16);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_idents, &p->shmac_num_idents))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < num_idents; i++) {\n\t\t__u16 hmacid = ntohs(hmacs->hmac_ids[i]);\n\n\t\tif (copy_to_user(&p->shmac_idents[i], &hmacid, sizeof(__u16)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tval.scact_keynumber = asoc->active_key_id;\n\telse\n\t\tval.scact_keynumber = ep->active_key_id;\n\n\tlen = sizeof(struct sctp_authkeyid);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tch = asoc->peer.peer_chunks;\n\tif (!ch)\n\t\tgoto num;\n\n\t/* See if the user provided enough room for all the data */\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_local_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc && val.gauth_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tch = (struct sctp_chunks_param *)asoc->c.auth_chunks;\n\telse\n\t\tch = ep->auth_chunk_list;\n\n\tif (!ch)\n\t\tgoto num;\n\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < sizeof(struct sctp_authchunks) + num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.2.5.  Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)\n * This option gets the current number of associations that are attached\n * to a one-to-many style socket.  The option value is an uint32_t.\n */\nstatic int sctp_getsockopt_assoc_number(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tu32 val = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tval++;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.1.23 SCTP_AUTO_ASCONF\n * See the corresponding setsockopt entry as description\n */\nstatic int sctp_getsockopt_auto_asconf(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->do_auto_asconf && sctp_is_ep_boundall(sk))\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * 8.2.6. Get the Current Identifiers of Associations\n *        (SCTP_GET_ASSOC_ID_LIST)\n *\n * This option gets the current list of SCTP association identifiers of\n * the SCTP associations handled by a one-to-many style socket.\n */\nstatic int sctp_getsockopt_assoc_ids(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_assoc_ids *ids;\n\tu32 num = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(struct sctp_assoc_ids))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tnum++;\n\t}\n\n\tif (len < sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num;\n\n\tids = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (unlikely(!ids))\n\t\treturn -ENOMEM;\n\n\tids->gaids_number_of_ids = num;\n\tnum = 0;\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tids->gaids_assoc_id[num++] = asoc->assoc_id;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, ids, len)) {\n\t\tkfree(ids);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(ids);\n\treturn 0;\n}\n\n/*\n * SCTP_PEER_ADDR_THLDS\n *\n * This option allows us to fetch the partially failed threshold for one or all\n * transports in an association.  See Section 6.1 of:\n * http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt\n */\nstatic int sctp_getsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int len,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_paddrthlds val;\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_paddrthlds))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_paddrthlds);\n\tif (copy_from_user(&val, (struct sctp_paddrthlds __user *)optval, len))\n\t\treturn -EFAULT;\n\n\tif (sctp_is_any(sk, (const union sctp_addr *)&val.spt_address)) {\n\t\tasoc = sctp_id2assoc(sk, val.spt_assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -ENOENT;\n\n\t\tval.spt_pathpfthld = asoc->pf_retrans;\n\t\tval.spt_pathmaxrxt = asoc->pathmaxrxt;\n\t} else {\n\t\ttrans = sctp_addr_id2transport(sk, &val.spt_address,\n\t\t\t\t\t       val.spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tval.spt_pathmaxrxt = trans->pathmaxrxt;\n\t\tval.spt_pathpfthld = trans->pf_retrans;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * SCTP_GET_ASSOC_STATS\n *\n * This option retrieves local per endpoint statistics. It is modeled\n * after OpenSolaris' implementation\n */\nstatic int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n\t/* Mark beginning of a new observation period */\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tpr_debug(\"%s: len:%d, assoc_id:%d\\n\", __func__, len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvrcvinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvrcvinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvnxtinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvnxtinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_pr_supported(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tparams.assoc_value = asoc->prsctp_enable;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tparams.assoc_value = sp->ep->prsctp_enable;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_default_prinfo(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_default_prinfo info;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(info)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(info);\n\tif (copy_from_user(&info, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, info.pr_assoc_id);\n\tif (asoc) {\n\t\tinfo.pr_policy = SCTP_PR_POLICY(asoc->default_flags);\n\t\tinfo.pr_value = asoc->default_timetolive;\n\t} else if (!info.pr_assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo.pr_policy = SCTP_PR_POLICY(sp->default_flags);\n\t\tinfo.pr_value = sp->default_timetolive;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &info, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_prstatus params;\n\tstruct sctp_association *asoc;\n\tint policy;\n\tint retval = -EINVAL;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc)\n\t\tgoto out;\n\n\tif (policy == SCTP_PR_SCTP_NONE) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tasoc->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tasoc->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tasoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tasoc->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint retval = 0;\n\tint len;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t/* I can hardly begin to describe how wrong this is.  This is\n\t * so broken as to be worse than useless.  The API draft\n\t * REALLY is NOT helpful here...  I am not convinced that the\n\t * semantics of getsockopt() with a level OTHER THAN SOL_SCTP\n\t * are at all well-founded.\n\t */\n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t\tretval = af->getsockopt(sk, level, optname, optval, optlen);\n\t\treturn retval;\n\t}\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_STATUS:\n\t\tretval = sctp_getsockopt_sctp_status(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_getsockopt_disable_fragments(sk, len, optval,\n\t\t\t\t\t\t\t   optlen);\n\t\tbreak;\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_getsockopt_events(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_getsockopt_autoclose(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_PEELOFF:\n\t\tretval = sctp_getsockopt_peeloff(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_getsockopt_peer_addr_params(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_getsockopt_delayed_ack(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_getsockopt_initmsg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDRS:\n\t\tretval = sctp_getsockopt_peer_addrs(sk, len, optval,\n\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_GET_LOCAL_ADDRS:\n\t\tretval = sctp_getsockopt_local_addrs(sk, len, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_CONNECTX3:\n\t\tretval = sctp_getsockopt_connectx3(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_getsockopt_default_send_param(sk, len,\n\t\t\t\t\t\t\t    optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_getsockopt_default_sndinfo(sk, len,\n\t\t\t\t\t\t\t optval, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_getsockopt_primary_addr(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_getsockopt_nodelay(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_getsockopt_rtoinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_getsockopt_associnfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_getsockopt_mappedv4(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_getsockopt_maxseg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDR_INFO:\n\t\tretval = sctp_getsockopt_peer_addr_info(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_getsockopt_adaptation_layer(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_getsockopt_context(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_getsockopt_fragment_interleave(sk, len, optval,\n\t\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_getsockopt_partial_delivery_point(sk, len, optval,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_getsockopt_maxburst(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\tcase SCTP_AUTH_CHUNK:\n\tcase SCTP_AUTH_DELETE_KEY:\n\t\tretval = -EOPNOTSUPP;\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_getsockopt_hmac_ident(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_getsockopt_active_key(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_peer_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_LOCAL_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_local_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_NUMBER:\n\t\tretval = sctp_getsockopt_assoc_number(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_ID_LIST:\n\t\tretval = sctp_getsockopt_assoc_ids(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_getsockopt_auto_asconf(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_getsockopt_paddr_thresholds(sk, optval, len, optlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_STATS:\n\t\tretval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_getsockopt_default_prinfo(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_PR_ASSOC_STATUS:\n\t\tretval = sctp_getsockopt_pr_assocstatus(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn retval;\n}\n\nstatic int sctp_hash(struct sock *sk)\n{\n\t/* STUB */\n\treturn 0;\n}\n\nstatic void sctp_unhash(struct sock *sk)\n{\n\t/* STUB */\n}\n\n/* Check if port is acceptable.  Possibly find first available port.\n *\n * The port hash table (contained in the 'global' SCTP protocol storage\n * returned by struct sctp_protocol *sctp_get_protocol()). The hash\n * table is an array of 4096 lists (sctp_bind_hashbucket). Each\n * list (the list number is the port number hashed out, so as you\n * would expect from a hash function, all the ports in a given list have\n * such a number that hashes out to the same list number; you were\n * expecting that, right?); so each list has a set of ports, with a\n * link to the socket (struct sock) that uses it, the port number and\n * a fastreuse flag (FIXME: NPI ipg).\n */\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *, unsigned short snum);\n\nstatic long sctp_get_port_local(struct sock *sk, union sctp_addr *addr)\n{\n\tstruct sctp_bind_hashbucket *head; /* hash list */\n\tstruct sctp_bind_bucket *pp;\n\tunsigned short snum;\n\tint ret;\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: begins, snum:%d\\n\", __func__, snum);\n\n\tlocal_bh_disable();\n\n\tif (snum == 0) {\n\t\t/* Search for an available port. */\n\t\tint low, high, remaining, index;\n\t\tunsigned int rover;\n\t\tstruct net *net = sock_net(sk);\n\n\t\tinet_get_local_port_range(net, &low, &high);\n\t\tremaining = (high - low) + 1;\n\t\trover = prandom_u32() % remaining + low;\n\n\t\tdo {\n\t\t\trover++;\n\t\t\tif ((rover < low) || (rover > high))\n\t\t\t\trover = low;\n\t\t\tif (inet_is_local_reserved_port(net, rover))\n\t\t\t\tcontinue;\n\t\t\tindex = sctp_phashfn(sock_net(sk), rover);\n\t\t\thead = &sctp_port_hashtable[index];\n\t\t\tspin_lock(&head->lock);\n\t\t\tsctp_for_each_hentry(pp, &head->chain)\n\t\t\t\tif ((pp->port == rover) &&\n\t\t\t\t    net_eq(sock_net(sk), pp->net))\n\t\t\t\t\tgoto next;\n\t\t\tbreak;\n\t\tnext:\n\t\t\tspin_unlock(&head->lock);\n\t\t} while (--remaining > 0);\n\n\t\t/* Exhausted local port range during search? */\n\t\tret = 1;\n\t\tif (remaining <= 0)\n\t\t\tgoto fail;\n\n\t\t/* OK, here is the one we will use.  HEAD (the port\n\t\t * hash table list entry) is non-NULL and we hold it's\n\t\t * mutex.\n\t\t */\n\t\tsnum = rover;\n\t} else {\n\t\t/* We are given an specific port number; we verify\n\t\t * that it is not being used. If it is used, we will\n\t\t * exahust the search in the hash list corresponding\n\t\t * to the port number (snum) - we detect that with the\n\t\t * port iterator, pp being NULL.\n\t\t */\n\t\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(sk), snum)];\n\t\tspin_lock(&head->lock);\n\t\tsctp_for_each_hentry(pp, &head->chain) {\n\t\t\tif ((pp->port == snum) && net_eq(pp->net, sock_net(sk)))\n\t\t\t\tgoto pp_found;\n\t\t}\n\t}\n\tpp = NULL;\n\tgoto pp_not_found;\npp_found:\n\tif (!hlist_empty(&pp->owner)) {\n\t\t/* We had a port hash table hit - there is an\n\t\t * available port (pp != NULL) and it is being\n\t\t * used by other socket (pp->owner not empty); that other\n\t\t * socket is going to be sk2.\n\t\t */\n\t\tint reuse = sk->sk_reuse;\n\t\tstruct sock *sk2;\n\n\t\tpr_debug(\"%s: found a possible match\\n\", __func__);\n\n\t\tif (pp->fastreuse && sk->sk_reuse &&\n\t\t\tsk->sk_state != SCTP_SS_LISTENING)\n\t\t\tgoto success;\n\n\t\t/* Run through the list of sockets bound to the port\n\t\t * (pp->port) [via the pointers bind_next and\n\t\t * bind_pprev in the struct sock *sk2 (pp->sk)]. On each one,\n\t\t * we get the endpoint they describe and run through\n\t\t * the endpoint's list of IP (v4 or v6) addresses,\n\t\t * comparing each of the addresses with the address of\n\t\t * the socket sk. If we find a match, then that means\n\t\t * that this port/socket (sk) combination are already\n\t\t * in an endpoint.\n\t\t */\n\t\tsk_for_each_bound(sk2, &pp->owner) {\n\t\t\tstruct sctp_endpoint *ep2;\n\t\t\tep2 = sctp_sk(sk2)->ep;\n\n\t\t\tif (sk == sk2 ||\n\t\t\t    (reuse && sk2->sk_reuse &&\n\t\t\t     sk2->sk_state != SCTP_SS_LISTENING))\n\t\t\t\tcontinue;\n\n\t\t\tif (sctp_bind_addr_conflict(&ep2->base.bind_addr, addr,\n\t\t\t\t\t\t sctp_sk(sk2), sctp_sk(sk))) {\n\t\t\t\tret = (long)sk2;\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"%s: found a match\\n\", __func__);\n\t}\npp_not_found:\n\t/* If there was a hash table miss, create a new port.  */\n\tret = 1;\n\tif (!pp && !(pp = sctp_bucket_create(head, sock_net(sk), snum)))\n\t\tgoto fail_unlock;\n\n\t/* In either case (hit or miss), make sure fastreuse is 1 only\n\t * if sk->sk_reuse is too (that is, if the caller requested\n\t * SO_REUSEADDR on this socket -sk-).\n\t */\n\tif (hlist_empty(&pp->owner)) {\n\t\tif (sk->sk_reuse && sk->sk_state != SCTP_SS_LISTENING)\n\t\t\tpp->fastreuse = 1;\n\t\telse\n\t\t\tpp->fastreuse = 0;\n\t} else if (pp->fastreuse &&\n\t\t(!sk->sk_reuse || sk->sk_state == SCTP_SS_LISTENING))\n\t\tpp->fastreuse = 0;\n\n\t/* We are set, so fill up all the data in the hash table\n\t * entry, tie the socket list information with the rest of the\n\t * sockets FIXME: Blurry, NPI (ipg).\n\t */\nsuccess:\n\tif (!sctp_sk(sk)->bind_hash) {\n\t\tinet_sk(sk)->inet_num = snum;\n\t\tsk_add_bind_node(sk, &pp->owner);\n\t\tsctp_sk(sk)->bind_hash = pp;\n\t}\n\tret = 0;\n\nfail_unlock:\n\tspin_unlock(&head->lock);\n\nfail:\n\tlocal_bh_enable();\n\treturn ret;\n}\n\n/* Assign a 'snum' port to the socket.  If snum == 0, an ephemeral\n * port is requested.\n */\nstatic int sctp_get_port(struct sock *sk, unsigned short snum)\n{\n\tunion sctp_addr addr;\n\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t/* Set up a dummy address struct from the sk. */\n\taf->from_sk(&addr, sk);\n\taddr.v4.sin_port = htons(snum);\n\n\t/* Note: sk->sk_num gets filled in if ephemeral port request. */\n\treturn !!sctp_get_port_local(sk, &addr);\n}\n\n/*\n *  Move a socket to LISTENING state.\n */\nstatic int sctp_listen_start(struct sock *sk, int backlog)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct crypto_shash *tfm = NULL;\n\tchar alg[32];\n\n\t/* Allocate HMAC for generating cookie. */\n\tif (!sp->hmac && sp->sctp_hmac_alg) {\n\t\tsprintf(alg, \"hmac(%s)\", sp->sctp_hmac_alg);\n\t\ttfm = crypto_alloc_shash(alg, 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tnet_info_ratelimited(\"failed to load transform for %s: %ld\\n\",\n\t\t\t\t\t     sp->sctp_hmac_alg, PTR_ERR(tfm));\n\t\t\treturn -ENOSYS;\n\t\t}\n\t\tsctp_sk(sk)->hmac = tfm;\n\t}\n\n\t/*\n\t * If a bind() or sctp_bindx() is not called prior to a listen()\n\t * call that allows new associations to be accepted, the system\n\t * picks an ephemeral port and will choose an address set equivalent\n\t * to binding with a wildcard address.\n\t *\n\t * This is not currently spelled out in the SCTP sockets\n\t * extensions draft, but follows the practice as seen in TCP\n\t * sockets.\n\t *\n\t */\n\tsk->sk_state = SCTP_SS_LISTENING;\n\tif (!ep->base.bind_addr.port) {\n\t\tif (sctp_autobind(sk))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (sctp_get_port(sk, inet_sk(sk)->inet_num)) {\n\t\t\tsk->sk_state = SCTP_SS_CLOSED;\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsctp_hash_endpoint(ep);\n\treturn 0;\n}\n\n/*\n * 4.1.3 / 5.1.3 listen()\n *\n *   By default, new associations are not accepted for UDP style sockets.\n *   An application uses listen() to mark a socket as being able to\n *   accept new associations.\n *\n *   On TCP style sockets, applications use listen() to ready the SCTP\n *   endpoint for accepting inbound associations.\n *\n *   On both types of endpoints a backlog of '0' disables listening.\n *\n *  Move a socket to LISTENING state.\n */\nint sctp_inet_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tint err = -EINVAL;\n\n\tif (unlikely(backlog < 0))\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\t/* Peeled-off sockets are not allowed to listen().  */\n\tif (sctp_style(sk, UDP_HIGH_BANDWIDTH))\n\t\tgoto out;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\tgoto out;\n\n\t/* If backlog is zero, disable listening. */\n\tif (!backlog) {\n\t\tif (sctp_sstate(sk, CLOSED))\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tsctp_unhash_endpoint(ep);\n\t\tsk->sk_state = SCTP_SS_CLOSED;\n\t\tif (sk->sk_reuse)\n\t\t\tsctp_sk(sk)->bind_hash->fastreuse = 1;\n\t\tgoto out;\n\t}\n\n\t/* If we are already listening, just update the backlog */\n\tif (sctp_sstate(sk, LISTENING))\n\t\tsk->sk_max_ack_backlog = backlog;\n\telse {\n\t\terr = sctp_listen_start(sk, backlog);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/*\n * This function is done by modeling the current datagram_poll() and the\n * tcp_poll().  Note that, based on these implementations, we don't\n * lock the socket in this function, even though it seems that,\n * ideally, locking or some other mechanisms can be used to ensure\n * the integrity of the counters (sndbuf and wmem_alloc) used\n * in this place.  We assume that we don't need locks either until proven\n * otherwise.\n *\n * Another thing to note is that we include the Async I/O support\n * here, again, by modeling the current TCP/UDP code.  We don't have\n * a good way to test with it yet.\n */\nunsigned int sctp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tunsigned int mask;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tsock_rps_record_flow(sk);\n\n\t/* A TCP-style listening socket becomes readable when the accept queue\n\t * is not empty.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\treturn (!list_empty(&sp->ep->asocs)) ?\n\t\t\t(POLLIN | POLLRDNORM) : 0;\n\n\tmask = 0;\n\n\t/* Is there any exceptional events?  */\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\n\t/* Is it readable?  Reconsider this code with TCP-style support.  */\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t/* The association is either gone or not ready.  */\n\tif (!sctp_style(sk, UDP) && sctp_sstate(sk, CLOSED))\n\t\treturn mask;\n\n\t/* Is it writable?  */\n\tif (sctp_writeable(sk)) {\n\t\tmask |= POLLOUT | POLLWRNORM;\n\t} else {\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\t/*\n\t\t * Since the socket is not locked, the buffer\n\t\t * might be made available after the writeable check and\n\t\t * before the bit is set.  This could cause a lost I/O\n\t\t * signal.  tcp_poll() has a race breaker for this race\n\t\t * condition.  Based on their implementation, we put\n\t\t * in the following code to cover it as well.\n\t\t */\n\t\tif (sctp_writeable(sk))\n\t\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\treturn mask;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *net, unsigned short snum)\n{\n\tstruct sctp_bind_bucket *pp;\n\n\tpp = kmem_cache_alloc(sctp_bucket_cachep, GFP_ATOMIC);\n\tif (pp) {\n\t\tSCTP_DBG_OBJCNT_INC(bind_bucket);\n\t\tpp->port = snum;\n\t\tpp->fastreuse = 0;\n\t\tINIT_HLIST_HEAD(&pp->owner);\n\t\tpp->net = net;\n\t\thlist_add_head(&pp->node, &head->chain);\n\t}\n\treturn pp;\n}\n\n/* Caller must hold hashbucket lock for this tb with local BH disabled */\nstatic void sctp_bucket_destroy(struct sctp_bind_bucket *pp)\n{\n\tif (pp && hlist_empty(&pp->owner)) {\n\t\t__hlist_del(&pp->node);\n\t\tkmem_cache_free(sctp_bucket_cachep, pp);\n\t\tSCTP_DBG_OBJCNT_DEC(bind_bucket);\n\t}\n}\n\n/* Release this socket's reference to a local port.  */\nstatic inline void __sctp_put_port(struct sock *sk)\n{\n\tstruct sctp_bind_hashbucket *head =\n\t\t&sctp_port_hashtable[sctp_phashfn(sock_net(sk),\n\t\t\t\t\t\t  inet_sk(sk)->inet_num)];\n\tstruct sctp_bind_bucket *pp;\n\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(sk)->bind_hash;\n\t__sk_del_bind_node(sk);\n\tsctp_sk(sk)->bind_hash = NULL;\n\tinet_sk(sk)->inet_num = 0;\n\tsctp_bucket_destroy(pp);\n\tspin_unlock(&head->lock);\n}\n\nvoid sctp_put_port(struct sock *sk)\n{\n\tlocal_bh_disable();\n\t__sctp_put_port(sk);\n\tlocal_bh_enable();\n}\n\n/*\n * The system picks an ephemeral port and choose an address set equivalent\n * to binding with a wildcard address.\n * One of those addresses will be the primary address for the association.\n * This automatically enables the multihoming capability of SCTP.\n */\nstatic int sctp_autobind(struct sock *sk)\n{\n\tunion sctp_addr autoaddr;\n\tstruct sctp_af *af;\n\t__be16 port;\n\n\t/* Initialize a local sockaddr structure to INADDR_ANY. */\n\taf = sctp_sk(sk)->pf->af;\n\n\tport = htons(inet_sk(sk)->inet_num);\n\taf->inaddr_any(&autoaddr, port);\n\n\treturn sctp_do_bind(sk, &autoaddr, af->sockaddr_len);\n}\n\n/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.\n *\n * From RFC 2292\n * 4.2 The cmsghdr Structure *\n *\n * When ancillary data is sent or received, any number of ancillary data\n * objects can be specified by the msg_control and msg_controllen members of\n * the msghdr structure, because each object is preceded by\n * a cmsghdr structure defining the object's length (the cmsg_len member).\n * Historically Berkeley-derived implementations have passed only one object\n * at a time, but this API allows multiple objects to be\n * passed in a single call to sendmsg() or recvmsg(). The following example\n * shows two ancillary data objects in a control buffer.\n *\n *   |<--------------------------- msg_controllen -------------------------->|\n *   |                                                                       |\n *\n *   |<----- ancillary data object ----->|<----- ancillary data object ----->|\n *\n *   |<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|\n *   |                                   |                                   |\n *\n *   |<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |\n *\n *   |<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |\n *   |                                |  |                                |  |\n *\n *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|\n *\n *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|\n *\n *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n *    ^\n *    |\n *\n * msg_control\n * points here\n */\nstatic int sctp_msghdr_parse(const struct msghdr *msg, sctp_cmsgs_t *cmsgs)\n{\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr *my_msg = (struct msghdr *)msg;\n\n\tfor_each_cmsghdr(cmsg, my_msg) {\n\t\tif (!CMSG_OK(my_msg, cmsg))\n\t\t\treturn -EINVAL;\n\n\t\t/* Should we parse this header or ignore?  */\n\t\tif (cmsg->cmsg_level != IPPROTO_SCTP)\n\t\t\tcontinue;\n\n\t\t/* Strictly check lengths following example in SCM code.  */\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase SCTP_INIT:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.1 SCTP Initiation Structure (SCTP_INIT)\n\t\t\t *\n\t\t\t * This cmsghdr structure provides information for\n\t\t\t * initializing new SCTP associations with sendmsg().\n\t\t\t * The SCTP_INITMSG socket option uses this same data\n\t\t\t * structure.  This structure is not used for\n\t\t\t * recvmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ----------------------\n\t\t\t * IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_initmsg)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->init = CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDRCV:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.2 SCTP Header Information Structure(SCTP_SNDRCV)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for\n\t\t\t * sendmsg() and describes SCTP header information\n\t\t\t * about a received message through recvmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ----------------------\n\t\t\t * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndrcvinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->srinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->srinfo->sinfo_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_PR_SCTP_MASK |\n\t\t\t      SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDINFO:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for\n\t\t\t * sendmsg(). This structure and SCTP_RCVINFO replaces\n\t\t\t * SCTP_SNDRCV which has been deprecated.\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_SNDINFO    struct sctp_sndinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->sinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->sinfo->snd_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_PR_SCTP_MASK |\n\t\t\t      SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Wait for a packet..\n * Note: This function is the same function as in core/datagram.c\n * with a few modifications to make lksctp work.\n */\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p)\n{\n\tint error;\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t/* Socket errors? */\n\terror = sock_error(sk);\n\tif (error)\n\t\tgoto out;\n\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tgoto ready;\n\n\t/* Socket shut down?  */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out;\n\n\t/* Sequenced packets can come disconnected.  If so we report the\n\t * problem.\n\t */\n\terror = -ENOTCONN;\n\n\t/* Is there a good reason to think that we may receive some data?  */\n\tif (list_empty(&sctp_sk(sk)->ep->asocs) && !sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\t/* Handle signals.  */\n\tif (signal_pending(current))\n\t\tgoto interrupted;\n\n\t/* Let another process have a go.  Since we are going to sleep\n\t * anyway.  Note: This may cause odd behaviors if the message\n\t * does not fit in the user's buffer, but this seems to be the\n\t * only way to honor MSG_DONTWAIT realistically.\n\t */\n\trelease_sock(sk);\n\t*timeo_p = schedule_timeout(*timeo_p);\n\tlock_sock(sk);\n\nready:\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn 0;\n\ninterrupted:\n\terror = sock_intr_errno(*timeo_p);\n\nout:\n\tfinish_wait(sk_sleep(sk), &wait);\n\t*err = error;\n\treturn error;\n}\n\n/* Receive a datagram.\n * Note: This is pretty much the same routine as in core/datagram.c\n * with a few changes to make lksctp work.\n */\nstruct sk_buff *sctp_skb_recv_datagram(struct sock *sk, int flags,\n\t\t\t\t       int noblock, int *err)\n{\n\tint error;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\n\ttimeo = sock_rcvtimeo(sk, noblock);\n\n\tpr_debug(\"%s: timeo:%ld, max:%ld\\n\", __func__, timeo,\n\t\t MAX_SCHEDULE_TIMEOUT);\n\n\tdo {\n\t\t/* Again only user level code calls this function,\n\t\t * so nothing interrupt level\n\t\t * will suddenly eat the receive_queue.\n\t\t *\n\t\t *  Look at current nfs client by the way...\n\t\t *  However, this function was correct in any case. 8)\n\t\t */\n\t\tif (flags & MSG_PEEK) {\n\t\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\t\tif (skb)\n\t\t\t\tatomic_inc(&skb->users);\n\t\t} else {\n\t\t\tskb = __skb_dequeue(&sk->sk_receive_queue);\n\t\t}\n\n\t\tif (skb)\n\t\t\treturn skb;\n\n\t\t/* Caller is allowed not to check sk->sk_err before calling. */\n\t\terror = sock_error(sk);\n\t\tif (error)\n\t\t\tgoto no_packet;\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\n\t\tif (sk_can_busy_loop(sk) &&\n\t\t    sk_busy_loop(sk, noblock))\n\t\t\tcontinue;\n\n\t\t/* User doesn't want to wait.  */\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (sctp_wait_for_packet(sk, err, &timeo) == 0);\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}\n\n/* If sndbuf has changed, wake up per association sndbuf waiters.  */\nstatic void __sctp_write_space(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (sctp_wspace(asoc) <= 0)\n\t\treturn;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\twake_up_interruptible(&asoc->wait);\n\n\tif (sctp_writeable(sk)) {\n\t\tstruct socket_wq *wq;\n\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq) {\n\t\t\tif (waitqueue_active(&wq->wait))\n\t\t\t\twake_up_interruptible(&wq->wait);\n\n\t\t\t/* Note that we try to include the Async I/O support\n\t\t\t * here by modeling from the current TCP/UDP code.\n\t\t\t * We have not tested with it yet.\n\t\t\t */\n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void sctp_wake_up_waiters(struct sock *sk,\n\t\t\t\t struct sctp_association *asoc)\n{\n\tstruct sctp_association *tmp = asoc;\n\n\t/* We do accounting for the sndbuf space per association,\n\t * so we only need to wake our own association.\n\t */\n\tif (asoc->ep->sndbuf_policy)\n\t\treturn __sctp_write_space(asoc);\n\n\t/* If association goes down and is just flushing its\n\t * outq, then just normally notify others.\n\t */\n\tif (asoc->base.dead)\n\t\treturn sctp_write_space(sk);\n\n\t/* Accounting for the sndbuf space is per socket, so we\n\t * need to wake up others, try to be fair and in case of\n\t * other associations, let them have a go first instead\n\t * of just doing a sctp_write_space() call.\n\t *\n\t * Note that we reach sctp_wake_up_waiters() only when\n\t * associations free up queued chunks, thus we are under\n\t * lock and the list of associations on a socket is\n\t * guaranteed not to change.\n\t */\n\tfor (tmp = list_next_entry(tmp, asocs); 1;\n\t     tmp = list_next_entry(tmp, asocs)) {\n\t\t/* Manually skip the head element. */\n\t\tif (&tmp->asocs == &((sctp_sk(sk))->ep->asocs))\n\t\t\tcontinue;\n\t\t/* Wake up association. */\n\t\t__sctp_write_space(tmp);\n\t\t/* We've reached the end. */\n\t\tif (tmp == asoc)\n\t\t\tbreak;\n\t}\n}\n\n/* Do accounting for the sndbuf space.\n * Decrement the used sndbuf space of the corresponding association by the\n * data size which was just transmitted(freed).\n */\nstatic void sctp_wfree(struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = skb_shinfo(skb)->destructor_arg;\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\tasoc->sndbuf_used -= SCTP_DATA_SNDSIZE(chunk) +\n\t\t\t\tsizeof(struct sk_buff) +\n\t\t\t\tsizeof(struct sctp_chunk);\n\n\tatomic_sub(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\n\t/*\n\t * This undoes what is done via sctp_set_owner_w and sk_mem_charge\n\t */\n\tsk->sk_wmem_queued   -= skb->truesize;\n\tsk_mem_uncharge(sk, skb->truesize);\n\n\tsock_wfree(skb);\n\tsctp_wake_up_waiters(sk, asoc);\n\n\tsctp_association_put(asoc);\n}\n\n/* Do accounting for the receive space on the socket.\n * Accounting for the association is done in ulpevent.c\n * We set this as a destructor for the cloned data skbs so that\n * accounting is done at the correct time.\n */\nvoid sctp_sock_rfree(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tatomic_sub(event->rmem_len, &sk->sk_rmem_alloc);\n\n\t/*\n\t * Mimic the behavior of sock_rfree\n\t */\n\tsk_mem_uncharge(sk, event->rmem_len);\n}\n\n\n/* Helper function to wait for space in the sndbuf.  */\nstatic int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n\nvoid sctp_data_ready(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\tPOLLRDNORM | POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\n/* If socket sndbuf has changed, wake up all per association waiters.  */\nvoid sctp_write_space(struct sock *sk)\n{\n\tstruct sctp_association *asoc;\n\n\t/* Wake up the tasks in each wait queue.  */\n\tlist_for_each_entry(asoc, &((sctp_sk(sk))->ep->asocs), asocs) {\n\t\t__sctp_write_space(asoc);\n\t}\n}\n\n/* Is there any sndbuf space available on the socket?\n *\n * Note that sk_wmem_alloc is the sum of the send buffers on all of the\n * associations on the same socket.  For a UDP-style socket with\n * multiple associations, it is possible for it to be \"unwriteable\"\n * prematurely.  I assume that this is acceptable because\n * a premature \"unwriteable\" is better than an accidental \"writeable\" which\n * would cause an unwanted block under certain circumstances.  For the 1-1\n * UDP-style sockets or TCP-style sockets, this code should work.\n *  - Daisy\n */\nstatic int sctp_writeable(struct sock *sk)\n{\n\tint amt = 0;\n\n\tamt = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\tif (amt < 0)\n\t\tamt = 0;\n\treturn amt;\n}\n\n/* Wait for an association to go into ESTABLISHED state. If timeout is 0,\n * returns immediately with EINPROGRESS.\n */\nstatic int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld\\n\", __func__, asoc, *timeo_p);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\n\t\tif (sctp_state(asoc, ESTABLISHED))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\tif (asoc->init_err_counter + 1 > asoc->max_init_attempts)\n\t\terr = -ETIMEDOUT;\n\telse\n\t\terr = -ECONNREFUSED;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EINPROGRESS;\n\tgoto out;\n}\n\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo)\n{\n\tstruct sctp_endpoint *ep;\n\tint err = 0;\n\tDEFINE_WAIT(wait);\n\n\tep = sctp_sk(sk)->ep;\n\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(sk_sleep(sk), &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\n\t\tif (list_empty(&ep->asocs)) {\n\t\t\trelease_sock(sk);\n\t\t\ttimeo = schedule_timeout(timeo);\n\t\t\tlock_sock(sk);\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (!sctp_sstate(sk, LISTENING))\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tif (!list_empty(&ep->asocs))\n\t\t\tbreak;\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t}\n\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void sctp_wait_for_close(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\t} while (!signal_pending(current) && timeout);\n\n\tfinish_wait(sk_sleep(sk), &wait);\n}\n\nstatic void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t/* Don't forget the fragments. */\n\tskb_walk_frags(skb, frag)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}\n\nvoid sctp_copy_sock(struct sock *newsk, struct sock *sk,\n\t\t    struct sctp_association *asoc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_sock *newinet;\n\n\tnewsk->sk_type = sk->sk_type;\n\tnewsk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tnewsk->sk_flags = sk->sk_flags;\n\tnewsk->sk_tsflags = sk->sk_tsflags;\n\tnewsk->sk_no_check_tx = sk->sk_no_check_tx;\n\tnewsk->sk_no_check_rx = sk->sk_no_check_rx;\n\tnewsk->sk_reuse = sk->sk_reuse;\n\n\tnewsk->sk_shutdown = sk->sk_shutdown;\n\tnewsk->sk_destruct = sctp_destruct_sock;\n\tnewsk->sk_family = sk->sk_family;\n\tnewsk->sk_protocol = IPPROTO_SCTP;\n\tnewsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\tnewsk->sk_sndbuf = sk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = sk->sk_rcvbuf;\n\tnewsk->sk_lingertime = sk->sk_lingertime;\n\tnewsk->sk_rcvtimeo = sk->sk_rcvtimeo;\n\tnewsk->sk_sndtimeo = sk->sk_sndtimeo;\n\tnewsk->sk_rxhash = sk->sk_rxhash;\n\n\tnewinet = inet_sk(newsk);\n\n\t/* Initialize sk's sport, dport, rcv_saddr and daddr for\n\t * getsockname() and getpeername()\n\t */\n\tnewinet->inet_sport = inet->inet_sport;\n\tnewinet->inet_saddr = inet->inet_saddr;\n\tnewinet->inet_rcv_saddr = inet->inet_rcv_saddr;\n\tnewinet->inet_dport = htons(asoc->peer.port);\n\tnewinet->pmtudisc = inet->pmtudisc;\n\tnewinet->inet_id = asoc->next_tsn ^ jiffies;\n\n\tnewinet->uc_ttl = inet->uc_ttl;\n\tnewinet->mc_loop = 1;\n\tnewinet->mc_ttl = 1;\n\tnewinet->mc_index = 0;\n\tnewinet->mc_list = NULL;\n\n\tif (newsk->sk_flags & SK_FLAGS_TIMESTAMP)\n\t\tnet_enable_timestamp();\n\n\tsecurity_sk_clone(sk, newsk);\n}\n\nstatic inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock) +\n\t\t\t    sizeof(struct sctp_sock) -\n\t\t\t    offsetof(struct sctp_sock, auto_asconf_list);\n\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}\n\n/* Populate the fields of the newsk from the oldsk and migrate the assoc\n * and its messages to the newsk.\n */\nstatic void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tsctp_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tspin_lock_bh(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock_bh(&head->lock);\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP)) {\n\t\tnewsk->sk_state = SCTP_SS_CLOSED;\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\t} else {\n\t\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\t}\n\n\trelease_sock(newsk);\n}\n\n\n/* This proto struct describes the ULP interface for SCTP.  */\nstruct proto sctp_prot = {\n\t.name        =\t\"SCTP\",\n\t.owner       =\tTHIS_MODULE,\n\t.close       =\tsctp_close,\n\t.connect     =\tsctp_connect,\n\t.disconnect  =\tsctp_disconnect,\n\t.accept      =\tsctp_accept,\n\t.ioctl       =\tsctp_ioctl,\n\t.init        =\tsctp_init_sock,\n\t.destroy     =\tsctp_destroy_sock,\n\t.shutdown    =\tsctp_shutdown,\n\t.setsockopt  =\tsctp_setsockopt,\n\t.getsockopt  =\tsctp_getsockopt,\n\t.sendmsg     =\tsctp_sendmsg,\n\t.recvmsg     =\tsctp_recvmsg,\n\t.bind        =\tsctp_bind,\n\t.backlog_rcv =\tsctp_backlog_rcv,\n\t.hash        =\tsctp_hash,\n\t.unhash      =\tsctp_unhash,\n\t.get_port    =\tsctp_get_port,\n\t.obj_size    =  sizeof(struct sctp_sock),\n\t.sysctl_mem  =  sysctl_sctp_mem,\n\t.sysctl_rmem =  sysctl_sctp_rmem,\n\t.sysctl_wmem =  sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\t.memory_allocated = &sctp_memory_allocated,\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n#include <net/transp_v6.h>\nstatic void sctp_v6_destroy_sock(struct sock *sk)\n{\n\tsctp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstruct proto sctpv6_prot = {\n\t.name\t\t= \"SCTPv6\",\n\t.owner\t\t= THIS_MODULE,\n\t.close\t\t= sctp_close,\n\t.connect\t= sctp_connect,\n\t.disconnect\t= sctp_disconnect,\n\t.accept\t\t= sctp_accept,\n\t.ioctl\t\t= sctp_ioctl,\n\t.init\t\t= sctp_init_sock,\n\t.destroy\t= sctp_v6_destroy_sock,\n\t.shutdown\t= sctp_shutdown,\n\t.setsockopt\t= sctp_setsockopt,\n\t.getsockopt\t= sctp_getsockopt,\n\t.sendmsg\t= sctp_sendmsg,\n\t.recvmsg\t= sctp_recvmsg,\n\t.bind\t\t= sctp_bind,\n\t.backlog_rcv\t= sctp_backlog_rcv,\n\t.hash\t\t= sctp_hash,\n\t.unhash\t\t= sctp_unhash,\n\t.get_port\t= sctp_get_port,\n\t.obj_size\t= sizeof(struct sctp6_sock),\n\t.sysctl_mem\t= sysctl_sctp_mem,\n\t.sysctl_rmem\t= sysctl_sctp_rmem,\n\t.sysctl_wmem\t= sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\t.memory_allocated = &sctp_memory_allocated,\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n"], "fixing_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2003 Intel Corp.\n * Copyright (c) 2001-2002 Nokia, Inc.\n * Copyright (c) 2001 La Monte H.P. Yarroll\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions interface with the sockets layer to implement the\n * SCTP Extensions for the Sockets API.\n *\n * Note that the descriptions from the specification are USER level\n * functions--this file is the functions which populate the struct proto\n * for SCTP which is the BOTTOM of the sockets interface.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Narasimha Budihal     <narsi@refcode.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Xingang Guo           <xingang.guo@intel.com>\n *    Daisy Chang           <daisyc@us.ibm.com>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Inaky Perez-Gonzalez  <inaky.gonzalez@intel.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Anup Pemmaiah         <pemmaiah@cc.usu.edu>\n *    Kevin Gao             <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/ip.h>\n#include <linux/capability.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/compat.h>\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/busy_poll.h>\n\n#include <linux/socket.h> /* for sa_family_t */\n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n/* Forward declarations for internal helper functions. */\nstatic int sctp_writeable(struct sock *sk);\nstatic void sctp_wfree(struct sk_buff *skb);\nstatic int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,\n\t\t\t\tsize_t msg_len);\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);\nstatic int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo);\nstatic void sctp_wait_for_close(struct sock *sk, long timeo);\nstatic void sctp_destruct_sock(struct sock *sk);\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len);\nstatic int sctp_bindx_add(struct sock *, struct sockaddr *, int);\nstatic int sctp_bindx_rem(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_add_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_del_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk);\nstatic int sctp_do_bind(struct sock *, union sctp_addr *, int);\nstatic int sctp_autobind(struct sock *sk);\nstatic void sctp_sock_migrate(struct sock *, struct sock *,\n\t\t\t      struct sctp_association *, sctp_socket_type_t);\n\nstatic int sctp_memory_pressure;\nstatic atomic_long_t sctp_memory_allocated;\nstruct percpu_counter sctp_sockets_allocated;\n\nstatic void sctp_enter_memory_pressure(struct sock *sk)\n{\n\tsctp_memory_pressure = 1;\n}\n\n\n/* Get the sndbuf space available at the time on the association.  */\nstatic inline int sctp_wspace(struct sctp_association *asoc)\n{\n\tint amt;\n\n\tif (asoc->ep->sndbuf_policy)\n\t\tamt = asoc->sndbuf_used;\n\telse\n\t\tamt = sk_wmem_alloc_get(asoc->base.sk);\n\n\tif (amt >= asoc->base.sk->sk_sndbuf) {\n\t\tif (asoc->base.sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\t\tamt = 0;\n\t\telse {\n\t\t\tamt = sk_stream_wspace(asoc->base.sk);\n\t\t\tif (amt < 0)\n\t\t\t\tamt = 0;\n\t\t}\n\t} else {\n\t\tamt = asoc->base.sk->sk_sndbuf - amt;\n\t}\n\treturn amt;\n}\n\n/* Increment the used sndbuf space count of the corresponding association by\n * the size of the outgoing data chunk.\n * Also, set the skb destructor for sndbuf accounting later.\n *\n * Since it is always 1-1 between chunk and skb, and also a new skb is always\n * allocated for chunk bundling in sctp_packet_transmit(), we can use the\n * destructor in the data chunk skb for the purpose of the sndbuf space\n * tracking.\n */\nstatic inline void sctp_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\t/* The sndbuf space is tracked per association.  */\n\tsctp_association_hold(asoc);\n\n\tskb_set_owner_w(chunk->skb, sk);\n\n\tchunk->skb->destructor = sctp_wfree;\n\t/* Save the chunk pointer in skb for sctp_wfree to use later.  */\n\tskb_shinfo(chunk->skb)->destructor_arg = chunk;\n\n\tasoc->sndbuf_used += SCTP_DATA_SNDSIZE(chunk) +\n\t\t\t\tsizeof(struct sk_buff) +\n\t\t\t\tsizeof(struct sctp_chunk);\n\n\tatomic_add(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\tsk->sk_wmem_queued += chunk->skb->truesize;\n\tsk_mem_charge(sk, chunk->skb->truesize);\n}\n\n/* Verify that this is a valid address. */\nstatic inline int sctp_verify_addr(struct sock *sk, union sctp_addr *addr,\n\t\t\t\t   int len)\n{\n\tstruct sctp_af *af;\n\n\t/* Verify basic sockaddr. */\n\taf = sctp_sockaddr_af(sctp_sk(sk), addr, len);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\t/* Is this a valid SCTP address?  */\n\tif (!af->addr_valid(addr, sctp_sk(sk), NULL))\n\t\treturn -EINVAL;\n\n\tif (!sctp_sk(sk)->pf->send_verify(sctp_sk(sk), (addr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* Look up the association by its id.  If this is not a UDP-style\n * socket, the ID field is always ignored.\n */\nstruct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)\n{\n\tstruct sctp_association *asoc = NULL;\n\n\t/* If this is not a UDP-style socket, assoc id should be ignored. */\n\tif (!sctp_style(sk, UDP)) {\n\t\t/* Return NULL if the socket state is not ESTABLISHED. It\n\t\t * could be a TCP-style listening socket or a socket which\n\t\t * hasn't yet called connect() to establish an association.\n\t\t */\n\t\tif (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))\n\t\t\treturn NULL;\n\n\t\t/* Get the first and the only association from the list. */\n\t\tif (!list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tasoc = list_entry(sctp_sk(sk)->ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\treturn asoc;\n\t}\n\n\t/* Otherwise this is a UDP-style socket. */\n\tif (!id || (id == (sctp_assoc_t)-1))\n\t\treturn NULL;\n\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\tasoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\n\tif (!asoc || (asoc->base.sk != sk) || asoc->base.dead)\n\t\treturn NULL;\n\n\treturn asoc;\n}\n\n/* Look up the transport from an address and an assoc id. If both address and\n * id are specified, the associations matching the address and the id should be\n * the same.\n */\nstatic struct sctp_transport *sctp_addr_id2transport(struct sock *sk,\n\t\t\t\t\t      struct sockaddr_storage *addr,\n\t\t\t\t\t      sctp_assoc_t id)\n{\n\tstruct sctp_association *addr_asoc = NULL, *id_asoc = NULL;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->ss_family);\n\tunion sctp_addr *laddr = (union sctp_addr *)addr;\n\tstruct sctp_transport *transport;\n\n\tif (sctp_verify_addr(sk, laddr, af->sockaddr_len))\n\t\treturn NULL;\n\n\taddr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)->ep,\n\t\t\t\t\t       laddr,\n\t\t\t\t\t       &transport);\n\n\tif (!addr_asoc)\n\t\treturn NULL;\n\n\tid_asoc = sctp_id2assoc(sk, id);\n\tif (id_asoc && (id_asoc != addr_asoc))\n\t\treturn NULL;\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t\t\t\t\t(union sctp_addr *)addr);\n\n\treturn transport;\n}\n\n/* API 3.1.2 bind() - UDP Style Syntax\n * The syntax of bind() is,\n *\n *   ret = bind(int sd, struct sockaddr *addr, int addrlen);\n *\n *   sd      - the socket descriptor returned by socket().\n *   addr    - the address structure (struct sockaddr_in or struct\n *             sockaddr_in6 [RFC 2553]),\n *   addr_len - the size of the address structure.\n */\nstatic int sctp_bind(struct sock *sk, struct sockaddr *addr, int addr_len)\n{\n\tint retval = 0;\n\n\tlock_sock(sk);\n\n\tpr_debug(\"%s: sk:%p, addr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t/* Disallow binding twice. */\n\tif (!sctp_sk(sk)->ep->base.bind_addr.port)\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)addr,\n\t\t\t\t      addr_len);\n\telse\n\t\tretval = -EINVAL;\n\n\trelease_sock(sk);\n\n\treturn retval;\n}\n\nstatic long sctp_get_port_local(struct sock *, union sctp_addr *);\n\n/* Verify this is a valid sockaddr. */\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len)\n{\n\tstruct sctp_af *af;\n\n\t/* Check minimum size.  */\n\tif (len < sizeof (struct sockaddr))\n\t\treturn NULL;\n\n\t/* V4 mapped address are really of AF_INET family */\n\tif (addr->sa.sa_family == AF_INET6 &&\n\t    ipv6_addr_v4mapped(&addr->v6.sin6_addr)) {\n\t\tif (!opt->pf->af_supported(AF_INET, opt))\n\t\t\treturn NULL;\n\t} else {\n\t\t/* Does this PF support this AF? */\n\t\tif (!opt->pf->af_supported(addr->sa.sa_family, opt))\n\t\t\treturn NULL;\n\t}\n\n\t/* If we get this far, af is valid. */\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\n\tif (len < af->sockaddr_len)\n\t\treturn NULL;\n\n\treturn af;\n}\n\n/* Bind a local address either to an endpoint or to an association.  */\nstatic int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tstruct sctp_af *af;\n\tunsigned short snum;\n\tint ret = 0;\n\n\t/* Common sockaddr verification. */\n\taf = sctp_sockaddr_af(sp, addr, len);\n\tif (!af) {\n\t\tpr_debug(\"%s: sk:%p, newaddr:%p, len:%d EINVAL\\n\",\n\t\t\t __func__, sk, addr, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: sk:%p, new addr:%pISc, port:%d, new port:%d, len:%d\\n\",\n\t\t __func__, sk, &addr->sa, bp->port, snum, len);\n\n\t/* PF specific bind() address verification. */\n\tif (!sp->pf->bind_verify(sp, addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* We must either be unbound, or bind to the same port.\n\t * It's OK to allow 0 ports if we are already bound.\n\t * We'll just inhert an already bound port in this case\n\t */\n\tif (bp->port) {\n\t\tif (!snum)\n\t\t\tsnum = bp->port;\n\t\telse if (snum != bp->port) {\n\t\t\tpr_debug(\"%s: new port %d doesn't match existing port \"\n\t\t\t\t \"%d\\n\", __func__, snum, bp->port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (snum && snum < PROT_SOCK &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t/* See if the address matches any of the addresses we may have\n\t * already bound before checking against other endpoints.\n\t */\n\tif (sctp_bind_addr_match(bp, addr, sp))\n\t\treturn -EINVAL;\n\n\t/* Make sure we are allowed to bind here.\n\t * The function sctp_get_port_local() does duplicate address\n\t * detection.\n\t */\n\taddr->v4.sin_port = htons(snum);\n\tif ((ret = sctp_get_port_local(sk, addr))) {\n\t\treturn -EADDRINUSE;\n\t}\n\n\t/* Refresh ephemeral port.  */\n\tif (!bp->port)\n\t\tbp->port = inet_sk(sk)->inet_num;\n\n\t/* Add the address to the bind address list.\n\t * Use GFP_ATOMIC since BHs will be disabled.\n\t */\n\tret = sctp_add_bind_addr(bp, addr, af->sockaddr_len,\n\t\t\t\t SCTP_ADDR_SRC, GFP_ATOMIC);\n\n\t/* Copy back into socket for getsockname() use. */\n\tif (!ret) {\n\t\tinet_sk(sk)->inet_sport = htons(inet_sk(sk)->inet_num);\n\t\tsp->pf->to_sk_saddr(addr, sk);\n\t}\n\n\treturn ret;\n}\n\n /* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks\n *\n * R1) One and only one ASCONF Chunk MAY be in transit and unacknowledged\n * at any one time.  If a sender, after sending an ASCONF chunk, decides\n * it needs to transfer another ASCONF Chunk, it MUST wait until the\n * ASCONF-ACK Chunk returns from the previous ASCONF Chunk before sending a\n * subsequent ASCONF. Note this restriction binds each side, so at any\n * time two ASCONF may be in-transit on any given association (one sent\n * from each endpoint).\n */\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct net \t*net = sock_net(asoc->base.sk);\n\tint\t\tretval = 0;\n\n\t/* If there is an outstanding ASCONF chunk, queue it for later\n\t * transmission.\n\t */\n\tif (asoc->addip_last_asconf) {\n\t\tlist_add_tail(&chunk->list, &asoc->addip_chunk_list);\n\t\tgoto out;\n\t}\n\n\t/* Hold the chunk until an ASCONF_ACK is received. */\n\tsctp_chunk_hold(chunk);\n\tretval = sctp_primitive_ASCONF(net, asoc, chunk);\n\tif (retval)\n\t\tsctp_chunk_free(chunk);\n\telse\n\t\tasoc->addip_last_asconf = chunk;\n\nout:\n\treturn retval;\n}\n\n/* Add a list of addresses as bind addresses to local endpoint or\n * association.\n *\n * Basically run through each address specified in the addrs/addrcnt\n * array/length pair, determine if it is IPv6 or IPv4 and call\n * sctp_do_bind() on it.\n *\n * If any of them fails, then the operation will be reversed and the\n * ones that were added will be removed.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_bindx_add(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tint cnt;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tstruct sockaddr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\", __func__, sk,\n\t\t addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t/* The list may contain either IPv4 or IPv6 address;\n\t\t * determine the address length for walking thru the list.\n\t\t */\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_add;\n\t\t}\n\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)sa_addr,\n\t\t\t\t      af->sockaddr_len);\n\n\t\taddr_buf += af->sockaddr_len;\n\nerr_bindx_add:\n\t\tif (retval < 0) {\n\t\t\t/* Failed. Cleanup the ones that have been added */\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_rem(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n/* Send an ASCONF chunk with Add IP address parameters to all the peers of the\n * associations that are part of the endpoint indicating that a list of local\n * addresses are added to the endpoint.\n *\n * If any of the addresses is already in the bind address list of the\n * association, we do not send the chunk for that association.  But it will not\n * affect other associations.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_send_asconf_add_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int \t\t\taddrcnt)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock\t\t*sp;\n\tstruct sctp_endpoint\t\t*ep;\n\tstruct sctp_association\t\t*asoc;\n\tstruct sctp_bind_addr\t\t*bp;\n\tstruct sctp_chunk\t\t*chunk;\n\tstruct sctp_sockaddr_entry\t*laddr;\n\tunion sctp_addr\t\t\t*addr;\n\tunion sctp_addr\t\t\tsaveaddr;\n\tvoid\t\t\t\t*addr_buf;\n\tstruct sctp_af\t\t\t*af;\n\tstruct list_head\t\t*p;\n\tint \t\t\t\ti;\n\tint \t\t\t\tretval = 0;\n\n\tif (!net->sctp.addip_enable)\n\t\treturn retval;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_ADD_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * in the bind address list of the association. If so,\n\t\t * do not send the asconf chunk to its peer, but continue with\n\t\t * other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sctp_assoc_lookup_laddr(asoc, addr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Use the first valid address in bind addr list of\n\t\t * association as Address Parameter of ASCONF CHUNK.\n\t\t */\n\t\tbp = &asoc->base.bind_addr;\n\t\tp = bp->address_list.next;\n\t\tladdr = list_entry(p, struct sctp_sockaddr_entry, list);\n\t\tchunk = sctp_make_asconf_update_ip(asoc, &laddr->a, addrs,\n\t\t\t\t\t\t   addrcnt, SCTP_PARAM_ADD_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Add the new addresses to the bind address list with\n\t\t * use_as_src set to 0.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tmemcpy(&saveaddr, addr, af->sockaddr_len);\n\t\t\tretval = sctp_add_bind_addr(bp, &saveaddr,\n\t\t\t\t\t\t    sizeof(saveaddr),\n\t\t\t\t\t\t    SCTP_ADDR_NEW, GFP_ATOMIC);\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (asoc->src_out_of_asoc_ok) {\n\t\t\tstruct sctp_transport *trans;\n\n\t\t\tlist_for_each_entry(trans,\n\t\t\t    &asoc->peer.transport_addr_list, transports) {\n\t\t\t\t/* Clear the source and route cache */\n\t\t\t\tdst_release(trans->dst);\n\t\t\t\ttrans->cwnd = min(4*asoc->pathmtu, max_t(__u32,\n\t\t\t\t    2*asoc->pathmtu, 4380));\n\t\t\t\ttrans->ssthresh = asoc->peer.i.a_rwnd;\n\t\t\t\ttrans->rto = asoc->rto_initial;\n\t\t\t\tsctp_max_rto(asoc, trans);\n\t\t\t\ttrans->rtt = trans->srtt = trans->rttvar = 0;\n\t\t\t\tsctp_transport_route(trans, NULL,\n\t\t\t\t    sctp_sk(asoc->base.sk));\n\t\t\t}\n\t\t}\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\n\nout:\n\treturn retval;\n}\n\n/* Remove a list of addresses from bind addresses list.  Do not remove the\n * last address.\n *\n * Basically run through each address specified in the addrs/addrcnt\n * array/length pair, determine if it is IPv6 or IPv4 and call\n * sctp_del_bind() on it.\n *\n * If any of them fails, then the operation will be reversed and the\n * ones that were removed will be added back.\n *\n * At least one address has to be left; if only one address is\n * available, the operation will return -EBUSY.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t/* If the bind address list is empty or if there is only one\n\t\t * bind address, there is nothing more to be removed (we need\n\t\t * at least one address here).\n\t\t */\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (sa_addr->v4.sin_port &&\n\t\t    sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!sa_addr->v4.sin_port)\n\t\t\tsa_addr->v4.sin_port = htons(bp->port);\n\n\t\t/* FIXME - There is probably a need to check if sk->sk_saddr and\n\t\t * sk->sk_rcv_addr are currently set to one of the addresses to\n\t\t * be removed. This is something which needs to be looked into\n\t\t * when we are fixing the outstanding issues with multi-homing\n\t\t * socket routing and failover schemes. Refer to comments in\n\t\t * sctp_do_bind(). -daisy\n\t\t */\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\t/* Failed. Add the ones that has been removed back */\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n/* Send an ASCONF chunk with Delete IP address parameters to all the peers of\n * the associations that are part of the endpoint indicating that a list of\n * local addresses are removed from the endpoint.\n *\n * If any of the addresses is already in the bind address list of the\n * association, we do not send the chunk for that association.  But it will not\n * affect other associations.\n *\n * Only sctp_setsockopt_bindx() is supposed to call this function.\n */\nstatic int sctp_send_asconf_del_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int\t\t\taddrcnt)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_endpoint\t*ep;\n\tstruct sctp_association\t*asoc;\n\tstruct sctp_transport\t*transport;\n\tstruct sctp_bind_addr\t*bp;\n\tstruct sctp_chunk\t*chunk;\n\tunion sctp_addr\t\t*laddr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tstruct sctp_sockaddr_entry *saddr;\n\tint \t\t\ti;\n\tint \t\t\tretval = 0;\n\tint\t\t\tstored = 0;\n\n\tchunk = NULL;\n\tif (!net->sctp.addip_enable)\n\t\treturn retval;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_DEL_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * not present in the bind address list of the association.\n\t\t * If so, do not send the asconf chunk to its peer, but\n\t\t * continue with other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!sctp_assoc_lookup_laddr(asoc, laddr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Find one address in the association's bind address list\n\t\t * that is not in the packed array of addresses. This is to\n\t\t * make sure that we do not delete all the addresses in the\n\t\t * association.\n\t\t */\n\t\tbp = &asoc->base.bind_addr;\n\t\tladdr = sctp_find_unmatch_addr(bp, (union sctp_addr *)addrs,\n\t\t\t\t\t       addrcnt, sp);\n\t\tif ((laddr == NULL) && (addrcnt == 1)) {\n\t\t\tif (asoc->asconf_addr_del_pending)\n\t\t\t\tcontinue;\n\t\t\tasoc->asconf_addr_del_pending =\n\t\t\t    kzalloc(sizeof(union sctp_addr), GFP_ATOMIC);\n\t\t\tif (asoc->asconf_addr_del_pending == NULL) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tasoc->asconf_addr_del_pending->sa.sa_family =\n\t\t\t\t    addrs->sa_family;\n\t\t\tasoc->asconf_addr_del_pending->v4.sin_port =\n\t\t\t\t    htons(bp->port);\n\t\t\tif (addrs->sa_family == AF_INET) {\n\t\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t\tsin = (struct sockaddr_in *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v4.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\t} else if (addrs->sa_family == AF_INET6) {\n\t\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\t\tsin6 = (struct sockaddr_in6 *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v6.sin6_addr = sin6->sin6_addr;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s: keep the last address asoc:%p %pISc at %p\\n\",\n\t\t\t\t __func__, asoc, &asoc->asconf_addr_del_pending->sa,\n\t\t\t\t asoc->asconf_addr_del_pending);\n\n\t\t\tasoc->src_out_of_asoc_ok = 1;\n\t\t\tstored = 1;\n\t\t\tgoto skip_mkasconf;\n\t\t}\n\n\t\tif (laddr == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t/* We do not need RCU protection throughout this loop\n\t\t * because this is done under a socket lock from the\n\t\t * setsockopt call.\n\t\t */\n\t\tchunk = sctp_make_asconf_update_ip(asoc, laddr, addrs, addrcnt,\n\t\t\t\t\t\t   SCTP_PARAM_DEL_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\nskip_mkasconf:\n\t\t/* Reset use_as_src flag for the addresses in the bind address\n\t\t * list that are to be deleted.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\t\tif (sctp_cmp_addr_exact(&saddr->a, laddr))\n\t\t\t\t\tsaddr->state = SCTP_ADDR_DEL;\n\t\t\t}\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\n\t\t/* Update the route and saddr entries for all the transports\n\t\t * as some of the addresses in the bind address list are\n\t\t * about to be deleted and cannot be used as source addresses.\n\t\t */\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\tsctp_transport_route(transport, NULL,\n\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t}\n\n\t\tif (stored)\n\t\t\t/* We don't need to transmit ASCONF */\n\t\t\tcontinue;\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\nout:\n\treturn retval;\n}\n\n/* set addr events to assocs in the endpoint.  ep and addr_wq must be locked */\nint sctp_asconf_mgmt(struct sctp_sock *sp, struct sctp_sockaddr_entry *addrw)\n{\n\tstruct sock *sk = sctp_opt2sk(sp);\n\tunion sctp_addr *addr;\n\tstruct sctp_af *af;\n\n\t/* It is safe to write port space in caller. */\n\taddr = &addrw->a;\n\taddr->v4.sin_port = htons(sp->ep->base.bind_addr.port);\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\tif (sctp_verify_addr(sk, addr, af->sockaddr_len))\n\t\treturn -EINVAL;\n\n\tif (addrw->state == SCTP_ADDR_NEW)\n\t\treturn sctp_send_asconf_add_ip(sk, (struct sockaddr *)addr, 1);\n\telse\n\t\treturn sctp_send_asconf_del_ip(sk, (struct sockaddr *)addr, 1);\n}\n\n/* Helper for tunneling sctp_bindx() requests through sctp_setsockopt()\n *\n * API 8.1\n * int sctp_bindx(int sd, struct sockaddr *addrs, int addrcnt,\n *                int flags);\n *\n * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.\n * If the sd is an IPv6 socket, the addresses passed can either be IPv4\n * or IPv6 addresses.\n *\n * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see\n * Section 3.1.2 for this usage.\n *\n * addrs is a pointer to an array of one or more socket addresses. Each\n * address is contained in its appropriate structure (i.e. struct\n * sockaddr_in or struct sockaddr_in6) the family of the address type\n * must be used to distinguish the address length (note that this\n * representation is termed a \"packed array\" of addresses). The caller\n * specifies the number of addresses in the array with addrcnt.\n *\n * On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns\n * -1, and sets errno to the appropriate error code.\n *\n * For SCTP, the port given in each socket address must be the same, or\n * sctp_bindx() will fail, setting errno to EINVAL.\n *\n * The flags parameter is formed from the bitwise OR of zero or more of\n * the following currently defined flags:\n *\n * SCTP_BINDX_ADD_ADDR\n *\n * SCTP_BINDX_REM_ADDR\n *\n * SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the\n * association, and SCTP_BINDX_REM_ADDR directs SCTP to remove the given\n * addresses from the association. The two flags are mutually exclusive;\n * if both are given, sctp_bindx() will fail with EINVAL. A caller may\n * not remove all addresses from an association; sctp_bindx() will\n * reject such an attempt with EINVAL.\n *\n * An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate\n * additional addresses with an endpoint after calling bind().  Or use\n * sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses a listening\n * socket is associated with so that no new association accepted will be\n * associated with those addresses. If the endpoint supports dynamic\n * address a SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause a\n * endpoint to send the appropriate message to the peer to change the\n * peers address lists.\n *\n * Adding and removing addresses from a connected association is\n * optional functionality. Implementations that do not support this\n * functionality should return EOPNOTSUPP.\n *\n * Basically do nothing but copying the addresses from user to kernel\n * land and invoking either sctp_bindx_add() or sctp_bindx_rem() on the sk.\n * This is used for tunneling the sctp_bindx() request through sctp_setsockopt()\n * from userspace.\n *\n * We don't use copy_from_user() for optimization: we first do the\n * sanity checks (buffer size -fast- and access check-healthy\n * pointer); if all of those succeed, then we can alloc the memory\n * (expensive operation) needed to copy the data to kernel. Then we do\n * the copying without checking the user space area\n * (__copy_from_user()).\n *\n * On exit there is no need to do sockfd_put(), sys_setsockopt() does\n * it.\n *\n * sk        The sk of the socket\n * addrs     The pointer to the addresses in user land\n * addrssize Size of the addrs buffer\n * op        Operation to perform (add or remove, see the flags of\n *           sctp_bindx)\n *\n * Returns 0 if ok, <0 errno code on error.\n */\nstatic int sctp_setsockopt_bindx(struct sock *sk,\n\t\t\t\t struct sockaddr __user *addrs,\n\t\t\t\t int addrs_size, int op)\n{\n\tstruct sockaddr *kaddrs;\n\tint err;\n\tint addrcnt = 0;\n\tint walk_size = 0;\n\tstruct sockaddr *sa_addr;\n\tvoid *addr_buf;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d opt:%d\\n\",\n\t\t __func__, sk, addrs, addrs_size, op);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t/* Check the user passed a healthy pointer.  */\n\tif (unlikely(!access_ok(VERIFY_READ, addrs, addrs_size)))\n\t\treturn -EFAULT;\n\n\t/* Alloc space for the address array in kernel memory.  */\n\tkaddrs = kmalloc(addrs_size, GFP_USER | __GFP_NOWARN);\n\tif (unlikely(!kaddrs))\n\t\treturn -ENOMEM;\n\n\tif (__copy_from_user(kaddrs, addrs, addrs_size)) {\n\t\tkfree(kaddrs);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Walk through the addrs buffer and count the number of addresses. */\n\taddr_buf = kaddrs;\n\twhile (walk_size < addrs_size) {\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size) {\n\t\t\tkfree(kaddrs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\n\t\t/* If the address family is not supported or if this address\n\t\t * causes the address buffer to overflow return EINVAL.\n\t\t */\n\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size) {\n\t\t\tkfree(kaddrs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddrcnt++;\n\t\taddr_buf += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t/* Do the work. */\n\tswitch (op) {\n\tcase SCTP_BINDX_ADD_ADDR:\n\t\terr = sctp_bindx_add(sk, kaddrs, addrcnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = sctp_send_asconf_add_ip(sk, kaddrs, addrcnt);\n\t\tbreak;\n\n\tcase SCTP_BINDX_REM_ADDR:\n\t\terr = sctp_bindx_rem(sk, kaddrs, addrcnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = sctp_send_asconf_del_ip(sk, kaddrs, addrcnt);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(kaddrs);\n\n\treturn err;\n}\n\n/* __sctp_connect(struct sock* sk, struct sockaddr *kaddrs, int addrs_size)\n *\n * Common routine for handling connect() and sctp_connectx().\n * Connect will come in with just a single address.\n */\nstatic int __sctp_connect(struct sock *sk,\n\t\t\t  struct sockaddr *kaddrs,\n\t\t\t  int addrs_size,\n\t\t\t  sctp_assoc_t *assoc_id)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_association *asoc2;\n\tstruct sctp_transport *transport;\n\tunion sctp_addr to;\n\tsctp_scope_t scope;\n\tlong timeo;\n\tint err = 0;\n\tint addrcnt = 0;\n\tint walk_size = 0;\n\tunion sctp_addr *sa_addr = NULL;\n\tvoid *addr_buf;\n\tunsigned short port;\n\tunsigned int f_flags = 0;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\t/* connect() cannot be done on a socket that is already in ESTABLISHED\n\t * state - UDP-style peeled off socket or a TCP-style socket that\n\t * is already connected.\n\t * It cannot be done even on a TCP-style listening socket.\n\t */\n\tif (sctp_sstate(sk, ESTABLISHED) || sctp_sstate(sk, CLOSING) ||\n\t    (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))) {\n\t\terr = -EISCONN;\n\t\tgoto out_free;\n\t}\n\n\t/* Walk through the addrs buffer and count the number of addresses. */\n\taddr_buf = kaddrs;\n\twhile (walk_size < addrs_size) {\n\t\tstruct sctp_af *af;\n\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\n\t\t/* If the address family is not supported or if this address\n\t\t * causes the address buffer to overflow return EINVAL.\n\t\t */\n\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tport = ntohs(sa_addr->v4.sin_port);\n\n\t\t/* Save current address so we can work with it */\n\t\tmemcpy(&to, sa_addr, af->sockaddr_len);\n\n\t\terr = sctp_verify_addr(sk, &to, af->sockaddr_len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\t/* Make sure the destination port is correctly set\n\t\t * in all addresses.\n\t\t */\n\t\tif (asoc && asoc->peer.port && asoc->peer.port != port) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* Check if there already is a matching association on the\n\t\t * endpoint (other than the one created here).\n\t\t */\n\t\tasoc2 = sctp_endpoint_lookup_assoc(ep, &to, &transport);\n\t\tif (asoc2 && asoc2 != asoc) {\n\t\t\tif (asoc2->state >= SCTP_STATE_ESTABLISHED)\n\t\t\t\terr = -EISCONN;\n\t\t\telse\n\t\t\t\terr = -EALREADY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* If we could not find a matching association on the endpoint,\n\t\t * make sure that there is no peeled-off association matching\n\t\t * the peer address even on another socket.\n\t\t */\n\t\tif (sctp_endpoint_is_peeled_off(ep, &to)) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (!asoc) {\n\t\t\t/* If a bind() or sctp_bindx() is not called prior to\n\t\t\t * an sctp_connectx() call, the system picks an\n\t\t\t * ephemeral port and will choose an address set\n\t\t\t * equivalent to binding with a wildcard address.\n\t\t\t */\n\t\t\tif (!ep->base.bind_addr.port) {\n\t\t\t\tif (sctp_autobind(sk)) {\n\t\t\t\t\terr = -EAGAIN;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If an unprivileged user inherits a 1-many\n\t\t\t\t * style socket with open associations on a\n\t\t\t\t * privileged port, it MAY be permitted to\n\t\t\t\t * accept new associations, but it SHOULD NOT\n\t\t\t\t * be permitted to open new associations.\n\t\t\t\t */\n\t\t\t\tif (ep->base.bind_addr.port < PROT_SOCK &&\n\t\t\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE)) {\n\t\t\t\t\terr = -EACCES;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscope = sctp_scope(&to);\n\t\t\tasoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);\n\t\t\tif (!asoc) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (err < 0) {\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t}\n\n\t\t/* Prime the peer's transport structures.  */\n\t\ttransport = sctp_assoc_add_peer(asoc, &to, GFP_KERNEL,\n\t\t\t\t\t\tSCTP_UNKNOWN);\n\t\tif (!transport) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\taddrcnt++;\n\t\taddr_buf += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t/* In case the user of sctp_connectx() wants an association\n\t * id back, assign one now.\n\t */\n\tif (assoc_id) {\n\t\terr = sctp_assoc_set_id(asoc, GFP_KERNEL);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t}\n\n\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);\n\tif (err < 0) {\n\t\tgoto out_free;\n\t}\n\n\t/* Initialize sk's dport and daddr for getpeername() */\n\tinet_sk(sk)->inet_dport = htons(asoc->peer.port);\n\tsp->pf->to_sk_daddr(sa_addr, sk);\n\tsk->sk_err = 0;\n\n\t/* in-kernel sockets don't generally have a file allocated to them\n\t * if all they do is call sock_create_kern().\n\t */\n\tif (sk->sk_socket->file)\n\t\tf_flags = sk->sk_socket->file->f_flags;\n\n\ttimeo = sock_sndtimeo(sk, f_flags & O_NONBLOCK);\n\n\tif (assoc_id)\n\t\t*assoc_id = asoc->assoc_id;\n\terr = sctp_wait_for_connect(asoc, &timeo);\n\t/* Note: the asoc may be freed after the return of\n\t * sctp_wait_for_connect.\n\t */\n\n\t/* Don't free association on exit. */\n\tasoc = NULL;\n\nout_free:\n\tpr_debug(\"%s: took out_free path with asoc:%p kaddrs:%p err:%d\\n\",\n\t\t __func__, asoc, kaddrs, err);\n\n\tif (asoc) {\n\t\t/* sctp_primitive_ASSOCIATE may have added this association\n\t\t * To the hash table, try to unhash it, just in case, its a noop\n\t\t * if it wasn't hashed so we're safe\n\t\t */\n\t\tsctp_association_free(asoc);\n\t}\n\treturn err;\n}\n\n/* Helper for tunneling sctp_connectx() requests through sctp_setsockopt()\n *\n * API 8.9\n * int sctp_connectx(int sd, struct sockaddr *addrs, int addrcnt,\n * \t\t\tsctp_assoc_t *asoc);\n *\n * If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.\n * If the sd is an IPv6 socket, the addresses passed can either be IPv4\n * or IPv6 addresses.\n *\n * A single address may be specified as INADDR_ANY or IN6ADDR_ANY, see\n * Section 3.1.2 for this usage.\n *\n * addrs is a pointer to an array of one or more socket addresses. Each\n * address is contained in its appropriate structure (i.e. struct\n * sockaddr_in or struct sockaddr_in6) the family of the address type\n * must be used to distengish the address length (note that this\n * representation is termed a \"packed array\" of addresses). The caller\n * specifies the number of addresses in the array with addrcnt.\n *\n * On success, sctp_connectx() returns 0. It also sets the assoc_id to\n * the association id of the new association.  On failure, sctp_connectx()\n * returns -1, and sets errno to the appropriate error code.  The assoc_id\n * is not touched by the kernel.\n *\n * For SCTP, the port given in each socket address must be the same, or\n * sctp_connectx() will fail, setting errno to EINVAL.\n *\n * An application can use sctp_connectx to initiate an association with\n * an endpoint that is multi-homed.  Much like sctp_bindx() this call\n * allows a caller to specify multiple addresses at which a peer can be\n * reached.  The way the SCTP stack uses the list of addresses to set up\n * the association is implementation dependent.  This function only\n * specifies that the stack will try to make use of all the addresses in\n * the list when needed.\n *\n * Note that the list of addresses passed in is only used for setting up\n * the association.  It does not necessarily equal the set of addresses\n * the peer uses for the resulting association.  If the caller wants to\n * find out the set of peer addresses, it must use sctp_getpaddrs() to\n * retrieve them after the association has been set up.\n *\n * Basically do nothing but copying the addresses from user to kernel\n * land and invoking either sctp_connectx(). This is used for tunneling\n * the sctp_connectx() request through sctp_setsockopt() from userspace.\n *\n * We don't use copy_from_user() for optimization: we first do the\n * sanity checks (buffer size -fast- and access check-healthy\n * pointer); if all of those succeed, then we can alloc the memory\n * (expensive operation) needed to copy the data to kernel. Then we do\n * the copying without checking the user space area\n * (__copy_from_user()).\n *\n * On exit there is no need to do sockfd_put(), sys_setsockopt() does\n * it.\n *\n * sk        The sk of the socket\n * addrs     The pointer to the addresses in user land\n * addrssize Size of the addrs buffer\n *\n * Returns >=0 if ok, <0 errno code on error.\n */\nstatic int __sctp_setsockopt_connectx(struct sock *sk,\n\t\t\t\t      struct sockaddr __user *addrs,\n\t\t\t\t      int addrs_size,\n\t\t\t\t      sctp_assoc_t *assoc_id)\n{\n\tstruct sockaddr *kaddrs;\n\tgfp_t gfp = GFP_KERNEL;\n\tint err = 0;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d\\n\",\n\t\t __func__, sk, addrs, addrs_size);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t/* Check the user passed a healthy pointer.  */\n\tif (unlikely(!access_ok(VERIFY_READ, addrs, addrs_size)))\n\t\treturn -EFAULT;\n\n\t/* Alloc space for the address array in kernel memory.  */\n\tif (sk->sk_socket->file)\n\t\tgfp = GFP_USER | __GFP_NOWARN;\n\tkaddrs = kmalloc(addrs_size, gfp);\n\tif (unlikely(!kaddrs))\n\t\treturn -ENOMEM;\n\n\tif (__copy_from_user(kaddrs, addrs, addrs_size)) {\n\t\terr = -EFAULT;\n\t} else {\n\t\terr = __sctp_connect(sk, kaddrs, addrs_size, assoc_id);\n\t}\n\n\tkfree(kaddrs);\n\n\treturn err;\n}\n\n/*\n * This is an older interface.  It's kept for backward compatibility\n * to the option that doesn't provide association id.\n */\nstatic int sctp_setsockopt_connectx_old(struct sock *sk,\n\t\t\t\t\tstruct sockaddr __user *addrs,\n\t\t\t\t\tint addrs_size)\n{\n\treturn __sctp_setsockopt_connectx(sk, addrs, addrs_size, NULL);\n}\n\n/*\n * New interface for the API.  The since the API is done with a socket\n * option, to make it simple we feed back the association id is as a return\n * indication to the call.  Error is always negative and association id is\n * always positive.\n */\nstatic int sctp_setsockopt_connectx(struct sock *sk,\n\t\t\t\t    struct sockaddr __user *addrs,\n\t\t\t\t    int addrs_size)\n{\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n\terr = __sctp_setsockopt_connectx(sk, addrs, addrs_size, &assoc_id);\n\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn assoc_id;\n}\n\n/*\n * New (hopefully final) interface for the API.\n * We use the sctp_getaddrs_old structure so that use-space library\n * can avoid any unnecessary allocations. The only different part\n * is that we store the actual length of the address buffer into the\n * addrs_num structure member. That way we can re-use the existing\n * code.\n */\n#ifdef CONFIG_COMPAT\nstruct compat_sctp_getaddrs_old {\n\tsctp_assoc_t\tassoc_id;\n\ts32\t\taddr_num;\n\tcompat_uptr_t\taddrs;\t\t/* struct sockaddr * */\n};\n#endif\n\nstatic int sctp_getsockopt_connectx3(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sctp_getaddrs_old param32;\n\n\t\tif (len < sizeof(param32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param32, optval, sizeof(param32)))\n\t\t\treturn -EFAULT;\n\n\t\tparam.assoc_id = param32.assoc_id;\n\t\tparam.addr_num = param32.addr_num;\n\t\tparam.addrs = compat_ptr(param32.addrs);\n\t} else\n#endif\n\t{\n\t\tif (len < sizeof(param))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = __sctp_setsockopt_connectx(sk, (struct sockaddr __user *)\n\t\t\t\t\t param.addrs, param.addr_num,\n\t\t\t\t\t &assoc_id);\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n/* API 3.1.4 close() - UDP Style Syntax\n * Applications use close() to perform graceful shutdown (as described in\n * Section 10.1 of [SCTP]) on ALL the associations currently represented\n * by a UDP-style socket.\n *\n * The syntax is\n *\n *   ret = close(int sd);\n *\n *   sd      - the socket descriptor of the associations to be closed.\n *\n * To gracefully shutdown a specific association represented by the\n * UDP-style socket, an application should use the sendmsg() call,\n * passing no user data, but including the appropriate flag in the\n * ancillary data (see Section xxxx).\n *\n * If sd in the close() call is a branched-off socket representing only\n * one association, the shutdown is performed on that association only.\n *\n * 4.1.6 close() - TCP Style Syntax\n *\n * Applications use close() to gracefully close down an association.\n *\n * The syntax is:\n *\n *    int close(int sd);\n *\n *      sd      - the socket descriptor of the association to be closed.\n *\n * After an application calls close() on a socket descriptor, no further\n * socket operations will succeed on that descriptor.\n *\n * API 7.1.4 SO_LINGER\n *\n * An application using the TCP-style socket can use this option to\n * perform the SCTP ABORT primitive.  The linger option structure is:\n *\n *  struct  linger {\n *     int     l_onoff;                // option on/off\n *     int     l_linger;               // linger time\n * };\n *\n * To enable the option, set l_onoff to 1.  If the l_linger value is set\n * to 0, calling close() is the same as the ABORT primitive.  If the\n * value is set to a negative value, the setsockopt() call will return\n * an error.  If the value is set to a positive value linger_time, the\n * close() can be blocked for at most linger_time ms.  If the graceful\n * shutdown phase does not finish during this period, close() will\n * return but the graceful shutdown phase continues in the system.\n */\nstatic void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_state = SCTP_SS_CLOSING;\n\n\tep = sctp_sk(sk)->ep;\n\n\t/* Clean up any skbs sitting on the receive queue.  */\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\n\t/* Walk all associations on an endpoint.  */\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\t/* A closed association can still be in the list if\n\t\t\t * it belongs to a TCP-style listening socket that is\n\t\t\t * not yet accepted. If so, free it. If not, send an\n\t\t\t * ABORT or SHUTDOWN based on the linger options.\n\t\t\t */\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\n\t/* On a TCP-style socket, block for at most linger_time if set. */\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t * Also, sctp_destroy_sock() needs to be called with addr_wq_lock\n\t * held and that should be grabbed before socket lock.\n\t */\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}\n\n/* Handle EPIPE error. */\nstatic int sctp_error(struct sock *sk, int flags, int err)\n{\n\tif (err == -EPIPE)\n\t\terr = sock_error(sk) ? : -EPIPE;\n\tif (err == -EPIPE && !(flags & MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\treturn err;\n}\n\n/* API 3.1.3 sendmsg() - UDP Style Syntax\n *\n * An application uses sendmsg() and recvmsg() calls to transmit data to\n * and receive data from its peer.\n *\n *  ssize_t sendmsg(int socket, const struct msghdr *message,\n *                  int flags);\n *\n *  socket  - the socket descriptor of the endpoint.\n *  message - pointer to the msghdr structure which contains a single\n *            user message and possibly some ancillary data.\n *\n *            See Section 5 for complete description of the data\n *            structures.\n *\n *  flags   - flags sent or received with the user message, see Section\n *            5 for complete description of the flags.\n *\n * Note:  This function could use a rewrite especially when explicit\n * connect support comes in.\n */\n/* BUG:  We do not implement the equivalent of sk_stream_wait_memory(). */\n\nstatic int sctp_msghdr_parse(const struct msghdr *, sctp_cmsgs_t *);\n\nstatic int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *new_asoc = NULL, *asoc = NULL;\n\tstruct sctp_transport *transport, *chunk_tp;\n\tstruct sctp_chunk *chunk;\n\tunion sctp_addr to;\n\tstruct sockaddr *msg_name = NULL;\n\tstruct sctp_sndrcvinfo default_sinfo;\n\tstruct sctp_sndrcvinfo *sinfo;\n\tstruct sctp_initmsg *sinit;\n\tsctp_assoc_t associd = 0;\n\tsctp_cmsgs_t cmsgs = { NULL };\n\tsctp_scope_t scope;\n\tbool fill_sinfo_ttl = false, wait_connect = false;\n\tstruct sctp_datamsg *datamsg;\n\tint msg_flags = msg->msg_flags;\n\t__u16 sinfo_flags = 0;\n\tlong timeo;\n\tint err;\n\n\terr = 0;\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tpr_debug(\"%s: sk:%p, msg:%p, msg_len:%zu ep:%p\\n\", __func__, sk,\n\t\t msg, msg_len, ep);\n\n\t/* We cannot send a message over a TCP-style listening socket. */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING)) {\n\t\terr = -EPIPE;\n\t\tgoto out_nounlock;\n\t}\n\n\t/* Parse out the SCTP CMSGs.  */\n\terr = sctp_msghdr_parse(msg, &cmsgs);\n\tif (err) {\n\t\tpr_debug(\"%s: msghdr parse err:%x\\n\", __func__, err);\n\t\tgoto out_nounlock;\n\t}\n\n\t/* Fetch the destination address for this packet.  This\n\t * address only selects the association--it is not necessarily\n\t * the address we will send to.\n\t * For a peeled-off socket, msg_name is ignored.\n\t */\n\tif (!sctp_style(sk, UDP_HIGH_BANDWIDTH) && msg->msg_name) {\n\t\tint msg_namelen = msg->msg_namelen;\n\n\t\terr = sctp_verify_addr(sk, (union sctp_addr *)msg->msg_name,\n\t\t\t\t       msg_namelen);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (msg_namelen > sizeof(to))\n\t\t\tmsg_namelen = sizeof(to);\n\t\tmemcpy(&to, msg->msg_name, msg_namelen);\n\t\tmsg_name = msg->msg_name;\n\t}\n\n\tsinit = cmsgs.init;\n\tif (cmsgs.sinfo != NULL) {\n\t\tmemset(&default_sinfo, 0, sizeof(default_sinfo));\n\t\tdefault_sinfo.sinfo_stream = cmsgs.sinfo->snd_sid;\n\t\tdefault_sinfo.sinfo_flags = cmsgs.sinfo->snd_flags;\n\t\tdefault_sinfo.sinfo_ppid = cmsgs.sinfo->snd_ppid;\n\t\tdefault_sinfo.sinfo_context = cmsgs.sinfo->snd_context;\n\t\tdefault_sinfo.sinfo_assoc_id = cmsgs.sinfo->snd_assoc_id;\n\n\t\tsinfo = &default_sinfo;\n\t\tfill_sinfo_ttl = true;\n\t} else {\n\t\tsinfo = cmsgs.srinfo;\n\t}\n\t/* Did the user specify SNDINFO/SNDRCVINFO? */\n\tif (sinfo) {\n\t\tsinfo_flags = sinfo->sinfo_flags;\n\t\tassocid = sinfo->sinfo_assoc_id;\n\t}\n\n\tpr_debug(\"%s: msg_len:%zu, sinfo_flags:0x%x\\n\", __func__,\n\t\t msg_len, sinfo_flags);\n\n\t/* SCTP_EOF or SCTP_ABORT cannot be set on a TCP-style socket. */\n\tif (sctp_style(sk, TCP) && (sinfo_flags & (SCTP_EOF | SCTP_ABORT))) {\n\t\terr = -EINVAL;\n\t\tgoto out_nounlock;\n\t}\n\n\t/* If SCTP_EOF is set, no data can be sent. Disallow sending zero\n\t * length messages when SCTP_EOF|SCTP_ABORT is not set.\n\t * If SCTP_ABORT is set, the message length could be non zero with\n\t * the msg_iov set to the user abort reason.\n\t */\n\tif (((sinfo_flags & SCTP_EOF) && (msg_len > 0)) ||\n\t    (!(sinfo_flags & (SCTP_EOF|SCTP_ABORT)) && (msg_len == 0))) {\n\t\terr = -EINVAL;\n\t\tgoto out_nounlock;\n\t}\n\n\t/* If SCTP_ADDR_OVER is set, there must be an address\n\t * specified in msg_name.\n\t */\n\tif ((sinfo_flags & SCTP_ADDR_OVER) && (!msg->msg_name)) {\n\t\terr = -EINVAL;\n\t\tgoto out_nounlock;\n\t}\n\n\ttransport = NULL;\n\n\tpr_debug(\"%s: about to look up association\\n\", __func__);\n\n\tlock_sock(sk);\n\n\t/* If a msg_name has been specified, assume this is to be used.  */\n\tif (msg_name) {\n\t\t/* Look for a matching association on the endpoint. */\n\t\tasoc = sctp_endpoint_lookup_assoc(ep, &to, &transport);\n\n\t\t/* If we could not find a matching association on the\n\t\t * endpoint, make sure that it is not a TCP-style\n\t\t * socket that already has an association or there is\n\t\t * no peeled-off association on another socket.\n\t\t */\n\t\tif (!asoc &&\n\t\t    ((sctp_style(sk, TCP) &&\n\t\t      (sctp_sstate(sk, ESTABLISHED) ||\n\t\t       sctp_sstate(sk, CLOSING))) ||\n\t\t     sctp_endpoint_is_peeled_off(ep, &to))) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, associd);\n\t\tif (!asoc) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (asoc) {\n\t\tpr_debug(\"%s: just looked up association:%p\\n\", __func__, asoc);\n\n\t\t/* We cannot send a message on a TCP-style SCTP_SS_ESTABLISHED\n\t\t * socket that has an association in CLOSED state. This can\n\t\t * happen when an accepted socket has an association that is\n\t\t * already CLOSED.\n\t\t */\n\t\tif (sctp_state(asoc, CLOSED) && sctp_style(sk, TCP)) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (sinfo_flags & SCTP_EOF) {\n\t\t\tpr_debug(\"%s: shutting down association:%p\\n\",\n\t\t\t\t __func__, asoc);\n\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t\t\terr = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (sinfo_flags & SCTP_ABORT) {\n\n\t\t\tchunk = sctp_make_abort_user(asoc, msg, msg_len);\n\t\t\tif (!chunk) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s: aborting association:%p\\n\",\n\t\t\t\t __func__, asoc);\n\n\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t\terr = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Do we need to create the association?  */\n\tif (!asoc) {\n\t\tpr_debug(\"%s: there is no association yet\\n\", __func__);\n\n\t\tif (sinfo_flags & (SCTP_EOF | SCTP_ABORT)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* Check for invalid stream against the stream counts,\n\t\t * either the default or the user specified stream counts.\n\t\t */\n\t\tif (sinfo) {\n\t\t\tif (!sinit || !sinit->sinit_num_ostreams) {\n\t\t\t\t/* Check against the defaults. */\n\t\t\t\tif (sinfo->sinfo_stream >=\n\t\t\t\t    sp->initmsg.sinit_num_ostreams) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Check against the requested.  */\n\t\t\t\tif (sinfo->sinfo_stream >=\n\t\t\t\t    sinit->sinit_num_ostreams) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * API 3.1.2 bind() - UDP Style Syntax\n\t\t * If a bind() or sctp_bindx() is not called prior to a\n\t\t * sendmsg() call that initiates a new association, the\n\t\t * system picks an ephemeral port and will choose an address\n\t\t * set equivalent to binding with a wildcard address.\n\t\t */\n\t\tif (!ep->base.bind_addr.port) {\n\t\t\tif (sctp_autobind(sk)) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * If an unprivileged user inherits a one-to-many\n\t\t\t * style socket with open associations on a privileged\n\t\t\t * port, it MAY be permitted to accept new associations,\n\t\t\t * but it SHOULD NOT be permitted to open new\n\t\t\t * associations.\n\t\t\t */\n\t\t\tif (ep->base.bind_addr.port < PROT_SOCK &&\n\t\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE)) {\n\t\t\t\terr = -EACCES;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tscope = sctp_scope(&to);\n\t\tnew_asoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);\n\t\tif (!new_asoc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tasoc = new_asoc;\n\t\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);\n\t\tif (err < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t/* If the SCTP_INIT ancillary data is specified, set all\n\t\t * the association init values accordingly.\n\t\t */\n\t\tif (sinit) {\n\t\t\tif (sinit->sinit_num_ostreams) {\n\t\t\t\tasoc->c.sinit_num_ostreams =\n\t\t\t\t\tsinit->sinit_num_ostreams;\n\t\t\t}\n\t\t\tif (sinit->sinit_max_instreams) {\n\t\t\t\tasoc->c.sinit_max_instreams =\n\t\t\t\t\tsinit->sinit_max_instreams;\n\t\t\t}\n\t\t\tif (sinit->sinit_max_attempts) {\n\t\t\t\tasoc->max_init_attempts\n\t\t\t\t\t= sinit->sinit_max_attempts;\n\t\t\t}\n\t\t\tif (sinit->sinit_max_init_timeo) {\n\t\t\t\tasoc->max_init_timeo =\n\t\t\t\t msecs_to_jiffies(sinit->sinit_max_init_timeo);\n\t\t\t}\n\t\t}\n\n\t\t/* Prime the peer's transport structures.  */\n\t\ttransport = sctp_assoc_add_peer(asoc, &to, GFP_KERNEL, SCTP_UNKNOWN);\n\t\tif (!transport) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* ASSERT: we have a valid association at this point.  */\n\tpr_debug(\"%s: we have a valid association\\n\", __func__);\n\n\tif (!sinfo) {\n\t\t/* If the user didn't specify SNDINFO/SNDRCVINFO, make up\n\t\t * one with some defaults.\n\t\t */\n\t\tmemset(&default_sinfo, 0, sizeof(default_sinfo));\n\t\tdefault_sinfo.sinfo_stream = asoc->default_stream;\n\t\tdefault_sinfo.sinfo_flags = asoc->default_flags;\n\t\tdefault_sinfo.sinfo_ppid = asoc->default_ppid;\n\t\tdefault_sinfo.sinfo_context = asoc->default_context;\n\t\tdefault_sinfo.sinfo_timetolive = asoc->default_timetolive;\n\t\tdefault_sinfo.sinfo_assoc_id = sctp_assoc2id(asoc);\n\n\t\tsinfo = &default_sinfo;\n\t} else if (fill_sinfo_ttl) {\n\t\t/* In case SNDINFO was specified, we still need to fill\n\t\t * it with a default ttl from the assoc here.\n\t\t */\n\t\tsinfo->sinfo_timetolive = asoc->default_timetolive;\n\t}\n\n\t/* API 7.1.7, the sndbuf size per association bounds the\n\t * maximum size of data that can be sent in a single send call.\n\t */\n\tif (msg_len > sk->sk_sndbuf) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_free;\n\t}\n\n\tif (asoc->pmtu_pending)\n\t\tsctp_assoc_pending_pmtu(sk, asoc);\n\n\t/* If fragmentation is disabled and the message length exceeds the\n\t * association fragmentation point, return EMSGSIZE.  The I-D\n\t * does not specify what this error is, but this looks like\n\t * a great fit.\n\t */\n\tif (sctp_sk(sk)->disable_fragments && (msg_len > asoc->frag_point)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_free;\n\t}\n\n\t/* Check for invalid stream. */\n\tif (sinfo->sinfo_stream >= asoc->c.sinit_num_ostreams) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (sctp_wspace(asoc) < msg_len)\n\t\tsctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\tif (!sctp_wspace(asoc)) {\n\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\t/* If an address is passed with the sendto/sendmsg call, it is used\n\t * to override the primary destination address in the TCP model, or\n\t * when SCTP_ADDR_OVER flag is set in the UDP model.\n\t */\n\tif ((sctp_style(sk, TCP) && msg_name) ||\n\t    (sinfo_flags & SCTP_ADDR_OVER)) {\n\t\tchunk_tp = sctp_assoc_lookup_paddr(asoc, &to);\n\t\tif (!chunk_tp) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t} else\n\t\tchunk_tp = NULL;\n\n\t/* Auto-connect, if we aren't connected already. */\n\tif (sctp_state(asoc, CLOSED)) {\n\t\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\n\t\twait_connect = true;\n\t\tpr_debug(\"%s: we associated primitively\\n\", __func__);\n\t}\n\n\t/* Break the message into multiple chunks of maximum size. */\n\tdatamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);\n\tif (IS_ERR(datamsg)) {\n\t\terr = PTR_ERR(datamsg);\n\t\tgoto out_free;\n\t}\n\n\t/* Now send the (possibly) fragmented message. */\n\tlist_for_each_entry(chunk, &datamsg->chunks, frag_list) {\n\t\tsctp_chunk_hold(chunk);\n\n\t\t/* Do accounting for the write space.  */\n\t\tsctp_set_owner_w(chunk);\n\n\t\tchunk->transport = chunk_tp;\n\t}\n\n\t/* Send it to the lower layers.  Note:  all chunks\n\t * must either fail or succeed.   The lower layer\n\t * works that way today.  Keep it that way or this\n\t * breaks.\n\t */\n\terr = sctp_primitive_SEND(net, asoc, datamsg);\n\t/* Did the lower layer accept the chunk? */\n\tif (err) {\n\t\tsctp_datamsg_free(datamsg);\n\t\tgoto out_free;\n\t}\n\n\tpr_debug(\"%s: we sent primitively\\n\", __func__);\n\n\tsctp_datamsg_put(datamsg);\n\terr = msg_len;\n\n\tif (unlikely(wait_connect)) {\n\t\ttimeo = sock_sndtimeo(sk, msg_flags & MSG_DONTWAIT);\n\t\tsctp_wait_for_connect(asoc, &timeo);\n\t}\n\n\t/* If we are already past ASSOCIATE, the lower\n\t * layers are responsible for association cleanup.\n\t */\n\tgoto out_unlock;\n\nout_free:\n\tif (new_asoc)\n\t\tsctp_association_free(asoc);\nout_unlock:\n\trelease_sock(sk);\n\nout_nounlock:\n\treturn sctp_error(sk, msg_flags, err);\n\n#if 0\ndo_sock_err:\n\tif (msg_len)\n\t\terr = msg_len;\n\telse\n\t\terr = sock_error(sk);\n\tgoto out;\n\ndo_interrupted:\n\tif (msg_len)\n\t\terr = msg_len;\n\tgoto out;\n#endif /* 0 */\n}\n\n/* This is an extended version of skb_pull() that removes the data from the\n * start of a skb even when data is spread across the list of skb's in the\n * frag_list. len specifies the total amount of data that needs to be removed.\n * when 'len' bytes could be removed from the skb, it returns 0.\n * If 'len' exceeds the total skb length,  it returns the no. of bytes that\n * could not be removed.\n */\nstatic int sctp_skb_pull(struct sk_buff *skb, int len)\n{\n\tstruct sk_buff *list;\n\tint skb_len = skb_headlen(skb);\n\tint rlen;\n\n\tif (len <= skb_len) {\n\t\t__skb_pull(skb, len);\n\t\treturn 0;\n\t}\n\tlen -= skb_len;\n\t__skb_pull(skb, skb_len);\n\n\tskb_walk_frags(skb, list) {\n\t\trlen = sctp_skb_pull(list, len);\n\t\tskb->len -= (len-rlen);\n\t\tskb->data_len -= (len-rlen);\n\n\t\tif (!rlen)\n\t\t\treturn 0;\n\n\t\tlen = rlen;\n\t}\n\n\treturn len;\n}\n\n/* API 3.1.3  recvmsg() - UDP Style Syntax\n *\n *  ssize_t recvmsg(int socket, struct msghdr *message,\n *                    int flags);\n *\n *  socket  - the socket descriptor of the endpoint.\n *  message - pointer to the msghdr structure which contains a single\n *            user message and possibly some ancillary data.\n *\n *            See Section 5 for complete description of the data\n *            structures.\n *\n *  flags   - flags sent or received with the user message, see Section\n *            5 for complete description of the flags.\n */\nstatic int sctp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\tint noblock, int flags, int *addr_len)\n{\n\tstruct sctp_ulpevent *event = NULL;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sk_buff *skb, *head_skb;\n\tint copied;\n\tint err = 0;\n\tint skb_len;\n\n\tpr_debug(\"%s: sk:%p, msghdr:%p, len:%zd, noblock:%d, flags:0x%x, \"\n\t\t \"addr_len:%p)\\n\", __func__, sk, msg, len, noblock, flags,\n\t\t addr_len);\n\n\tlock_sock(sk);\n\n\tif (sctp_style(sk, TCP) && !sctp_sstate(sk, ESTABLISHED) &&\n\t    !sctp_sstate(sk, CLOSING) && !sctp_sstate(sk, CLOSED)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tskb = sctp_skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\t/* Get the total length of the skb including any skb's in the\n\t * frag_list.\n\t */\n\tskb_len = skb->len;\n\n\tcopied = skb_len;\n\tif (copied > len)\n\t\tcopied = len;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tevent = sctp_skb2event(skb);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tif (event->chunk && event->chunk->head_skb)\n\t\thead_skb = event->chunk->head_skb;\n\telse\n\t\thead_skb = skb;\n\tsock_recv_ts_and_drops(msg, sk, head_skb);\n\tif (sctp_ulpevent_is_notification(event)) {\n\t\tmsg->msg_flags |= MSG_NOTIFICATION;\n\t\tsp->pf->event_msgname(event, msg->msg_name, addr_len);\n\t} else {\n\t\tsp->pf->skb_msgname(head_skb, msg->msg_name, addr_len);\n\t}\n\n\t/* Check if we allow SCTP_NXTINFO. */\n\tif (sp->recvnxtinfo)\n\t\tsctp_ulpevent_read_nxtinfo(event, msg, sk);\n\t/* Check if we allow SCTP_RCVINFO. */\n\tif (sp->recvrcvinfo)\n\t\tsctp_ulpevent_read_rcvinfo(event, msg);\n\t/* Check if we allow SCTP_SNDRCVINFO. */\n\tif (sp->subscribe.sctp_data_io_event)\n\t\tsctp_ulpevent_read_sndrcvinfo(event, msg);\n\n\terr = copied;\n\n\t/* If skb's length exceeds the user's buffer, update the skb and\n\t * push it back to the receive_queue so that the next call to\n\t * recvmsg() will return the remaining data. Don't set MSG_EOR.\n\t */\n\tif (skb_len > copied) {\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\t\tif (flags & MSG_PEEK)\n\t\t\tgoto out_free;\n\t\tsctp_skb_pull(skb, copied);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\t/* When only partial message is copied to the user, increase\n\t\t * rwnd by that amount. If all the data in the skb is read,\n\t\t * rwnd is updated when the event is freed.\n\t\t */\n\t\tif (!sctp_ulpevent_is_notification(event))\n\t\t\tsctp_assoc_rwnd_increase(event->asoc, copied);\n\t\tgoto out;\n\t} else if ((event->msg_flags & MSG_NOTIFICATION) ||\n\t\t   (event->msg_flags & MSG_EOR))\n\t\tmsg->msg_flags |= MSG_EOR;\n\telse\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\nout_free:\n\tif (flags & MSG_PEEK) {\n\t\t/* Release the skb reference acquired after peeking the skb in\n\t\t * sctp_skb_recv_datagram().\n\t\t */\n\t\tkfree_skb(skb);\n\t} else {\n\t\t/* Free the event which includes releasing the reference to\n\t\t * the owner of the skb, freeing the skb and updating the\n\t\t * rwnd.\n\t\t */\n\t\tsctp_ulpevent_free(event);\n\t}\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)\n *\n * This option is a on/off flag.  If enabled no SCTP message\n * fragmentation will be performed.  Instead if a message being sent\n * exceeds the current PMTU size, the message will NOT be sent and\n * instead a error will be indicated to the user.\n */\nstatic int sctp_setsockopt_disable_fragments(struct sock *sk,\n\t\t\t\t\t     char __user *optval,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->disable_fragments = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_events(struct sock *sk, char __user *optval,\n\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_ulpevent *event;\n\n\tif (optlen > sizeof(struct sctp_event_subscribe))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sctp_sk(sk)->subscribe, optval, optlen))\n\t\treturn -EFAULT;\n\n\t/* At the time when a user app subscribes to SCTP_SENDER_DRY_EVENT,\n\t * if there is no data to be sent or retransmit, the stack will\n\t * immediately send up this notification.\n\t */\n\tif (sctp_ulpevent_type_enabled(SCTP_SENDER_DRY_EVENT,\n\t\t\t\t       &sctp_sk(sk)->subscribe)) {\n\t\tasoc = sctp_id2assoc(sk, 0);\n\n\t\tif (asoc && sctp_outq_is_empty(&asoc->outqueue)) {\n\t\t\tevent = sctp_ulpevent_make_sender_dry_event(asoc,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (!event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsctp_ulpq_tail_event(&asoc->ulpq, event);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)\n *\n * This socket option is applicable to the UDP-style socket only.  When\n * set it will cause associations that are idle for more than the\n * specified number of seconds to automatically close.  An association\n * being idle is defined an association that has NOT sent or received\n * user data.  The special value of '0' indicates that no automatic\n * close of any associations should be performed.  The option expects an\n * integer defining the number of seconds of idle time before an\n * association is closed.\n */\nstatic int sctp_setsockopt_autoclose(struct sock *sk, char __user *optval,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sp->autoclose, optval, optlen))\n\t\treturn -EFAULT;\n\n\tif (sp->autoclose > net->sctp.max_autoclose)\n\t\tsp->autoclose = net->sctp.max_autoclose;\n\n\treturn 0;\n}\n\n/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n *\n * Applications can enable or disable heartbeats for any peer address of\n * an association, modify an address's heartbeat interval, force a\n * heartbeat to be sent immediately, and adjust the address's maximum\n * number of retransmissions sent before an address is considered\n * unreachable.  The following structure is used to access and modify an\n * address's parameters:\n *\n *  struct sctp_paddrparams {\n *     sctp_assoc_t            spp_assoc_id;\n *     struct sockaddr_storage spp_address;\n *     uint32_t                spp_hbinterval;\n *     uint16_t                spp_pathmaxrxt;\n *     uint32_t                spp_pathmtu;\n *     uint32_t                spp_sackdelay;\n *     uint32_t                spp_flags;\n * };\n *\n *   spp_assoc_id    - (one-to-many style socket) This is filled in the\n *                     application, and identifies the association for\n *                     this query.\n *   spp_address     - This specifies which address is of interest.\n *   spp_hbinterval  - This contains the value of the heartbeat interval,\n *                     in milliseconds.  If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmaxrxt  - This contains the maximum number of\n *                     retransmissions before this address shall be\n *                     considered unreachable. If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmtu     - When Path MTU discovery is disabled the value\n *                     specified here will be the \"fixed\" path mtu.\n *                     Note that if the spp_address field is empty\n *                     then all associations on this address will\n *                     have this fixed path mtu set upon them.\n *\n *   spp_sackdelay   - When delayed sack is enabled, this value specifies\n *                     the number of milliseconds that sacks will be delayed\n *                     for. This value will apply to all addresses of an\n *                     association if the spp_address field is empty. Note\n *                     also, that if delayed sack is enabled and this\n *                     value is set to 0, no change is made to the last\n *                     recorded delayed sack timer value.\n *\n *   spp_flags       - These flags are used to control various features\n *                     on an association. The flag field may contain\n *                     zero or more of the following options.\n *\n *                     SPP_HB_ENABLE  - Enable heartbeats on the\n *                     specified address. Note that if the address\n *                     field is empty all addresses for the association\n *                     have heartbeats enabled upon them.\n *\n *                     SPP_HB_DISABLE - Disable heartbeats on the\n *                     speicifed address. Note that if the address\n *                     field is empty all addresses for the association\n *                     will have their heartbeats disabled. Note also\n *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are\n *                     mutually exclusive, only one of these two should\n *                     be specified. Enabling both fields will have\n *                     undetermined results.\n *\n *                     SPP_HB_DEMAND - Request a user initiated heartbeat\n *                     to be made immediately.\n *\n *                     SPP_HB_TIME_IS_ZERO - Specify's that the time for\n *                     heartbeat delayis to be set to the value of 0\n *                     milliseconds.\n *\n *                     SPP_PMTUD_ENABLE - This field will enable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected.\n *\n *                     SPP_PMTUD_DISABLE - This field will disable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected. Not also that\n *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n *                     exclusive. Enabling both will have undetermined\n *                     results.\n *\n *                     SPP_SACKDELAY_ENABLE - Setting this flag turns\n *                     on delayed sack. The time specified in spp_sackdelay\n *                     is used to specify the sack delay for this address. Note\n *                     that if spp_address is empty then all addresses will\n *                     enable delayed sack and take on the sack delay\n *                     value specified in spp_sackdelay.\n *                     SPP_SACKDELAY_DISABLE - Setting this flag turns\n *                     off delayed sack. If the spp_address field is blank then\n *                     delayed sack is disabled for the entire association. Note\n *                     also that this field is mutually exclusive to\n *                     SPP_SACKDELAY_ENABLE, setting both will have undefined\n *                     results.\n */\nstatic int sctp_apply_peer_addr_params(struct sctp_paddrparams *params,\n\t\t\t\t       struct sctp_transport   *trans,\n\t\t\t\t       struct sctp_association *asoc,\n\t\t\t\t       struct sctp_sock        *sp,\n\t\t\t\t       int                      hb_change,\n\t\t\t\t       int                      pmtud_change,\n\t\t\t\t       int                      sackdelay_change)\n{\n\tint error;\n\n\tif (params->spp_flags & SPP_HB_DEMAND && trans) {\n\t\tstruct net *net = sock_net(trans->asoc->base.sk);\n\n\t\terror = sctp_primitive_REQUESTHEARTBEAT(net, trans->asoc, trans);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Note that unless the spp_flag is set to SPP_HB_ENABLE the value of\n\t * this field is ignored.  Note also that a value of zero indicates\n\t * the current setting should be left unchanged.\n\t */\n\tif (params->spp_flags & SPP_HB_ENABLE) {\n\n\t\t/* Re-zero the interval if the SPP_HB_TIME_IS_ZERO is\n\t\t * set.  This lets us use 0 value when this flag\n\t\t * is set.\n\t\t */\n\t\tif (params->spp_flags & SPP_HB_TIME_IS_ZERO)\n\t\t\tparams->spp_hbinterval = 0;\n\n\t\tif (params->spp_hbinterval ||\n\t\t    (params->spp_flags & SPP_HB_TIME_IS_ZERO)) {\n\t\t\tif (trans) {\n\t\t\t\ttrans->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else if (asoc) {\n\t\t\t\tasoc->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else {\n\t\t\t\tsp->hbinterval = params->spp_hbinterval;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hb_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_HB) | hb_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_HB) | hb_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_HB) | hb_change;\n\t\t}\n\t}\n\n\t/* When Path MTU discovery is disabled the value specified here will\n\t * be the \"fixed\" path mtu (i.e. the value of the spp_flags field must\n\t * include the flag SPP_PMTUD_DISABLE for this field to have any\n\t * effect).\n\t */\n\tif ((params->spp_flags & SPP_PMTUD_DISABLE) && params->spp_pathmtu) {\n\t\tif (trans) {\n\t\t\ttrans->pathmtu = params->spp_pathmtu;\n\t\t\tsctp_assoc_sync_pmtu(sctp_opt2sk(sp), asoc);\n\t\t} else if (asoc) {\n\t\t\tasoc->pathmtu = params->spp_pathmtu;\n\t\t\tsctp_frag_point(asoc, params->spp_pathmtu);\n\t\t} else {\n\t\t\tsp->pathmtu = params->spp_pathmtu;\n\t\t}\n\t}\n\n\tif (pmtud_change) {\n\t\tif (trans) {\n\t\t\tint update = (trans->param_flags & SPP_PMTUD_DISABLE) &&\n\t\t\t\t(params->spp_flags & SPP_PMTUD_ENABLE);\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t\tif (update) {\n\t\t\t\tsctp_transport_pmtu(trans, sctp_opt2sk(sp));\n\t\t\t\tsctp_assoc_sync_pmtu(sctp_opt2sk(sp), asoc);\n\t\t\t}\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t}\n\t}\n\n\t/* Note that unless the spp_flag is set to SPP_SACKDELAY_ENABLE the\n\t * value of this field is ignored.  Note also that a value of zero\n\t * indicates the current setting should be left unchanged.\n\t */\n\tif ((params->spp_flags & SPP_SACKDELAY_ENABLE) && params->spp_sackdelay) {\n\t\tif (trans) {\n\t\t\ttrans->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else if (asoc) {\n\t\t\tasoc->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else {\n\t\t\tsp->sackdelay = params->spp_sackdelay;\n\t\t}\n\t}\n\n\tif (sackdelay_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t}\n\t}\n\n\t/* Note that a value of zero indicates the current setting should be\n\t   left unchanged.\n\t */\n\tif (params->spp_pathmaxrxt) {\n\t\tif (trans) {\n\t\t\ttrans->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else if (asoc) {\n\t\t\tasoc->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else {\n\t\t\tsp->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_peer_addr_params(struct sock *sk,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\tint error;\n\tint hb_change, pmtud_change, sackdelay_change;\n\n\tif (optlen != sizeof(struct sctp_paddrparams))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&params, optval, optlen))\n\t\treturn -EFAULT;\n\n\t/* Validate flags and value parameters. */\n\thb_change        = params.spp_flags & SPP_HB;\n\tpmtud_change     = params.spp_flags & SPP_PMTUD;\n\tsackdelay_change = params.spp_flags & SPP_SACKDELAY;\n\n\tif (hb_change        == SPP_HB ||\n\t    pmtud_change     == SPP_PMTUD ||\n\t    sackdelay_change == SPP_SACKDELAY ||\n\t    params.spp_sackdelay > 500 ||\n\t    (params.spp_pathmtu &&\n\t     params.spp_pathmtu < SCTP_DEFAULT_MINSEGMENT))\n\t\treturn -EINVAL;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Get association, if assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Heartbeat demand can only be sent on a transport or\n\t * association, but not a socket.\n\t */\n\tif (params.spp_flags & SPP_HB_DEMAND && !trans && !asoc)\n\t\treturn -EINVAL;\n\n\t/* Process parameters. */\n\terror = sctp_apply_peer_addr_params(&params, trans, asoc, sp,\n\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t    sackdelay_change);\n\n\tif (error)\n\t\treturn error;\n\n\t/* If changes are for association, also apply parameters to each\n\t * transport.\n\t */\n\tif (!trans && asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tsctp_apply_peer_addr_params(&params, trans, asoc, sp,\n\t\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t\t    sackdelay_change);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_enable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_ENABLE;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_disable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_DISABLE;\n}\n\n/*\n * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)\n *\n * This option will effect the way delayed acks are performed.  This\n * option allows you to get or set the delayed ack time, in\n * milliseconds.  It also allows changing the delayed ack frequency.\n * Changing the frequency to 1 disables the delayed sack algorithm.  If\n * the assoc_id is 0, then this sets or gets the endpoints default\n * values.  If the assoc_id field is non-zero, then the set or get\n * effects the specified association for the one to many model (the\n * assoc_id field is ignored by the one to one model).  Note that if\n * sack_delay or sack_freq are 0 when setting this option, then the\n * current values will remain unchanged.\n *\n * struct sctp_sack_info {\n *     sctp_assoc_t            sack_assoc_id;\n *     uint32_t                sack_delay;\n *     uint32_t                sack_freq;\n * };\n *\n * sack_assoc_id -  This parameter, indicates which association the user\n *    is performing an action upon.  Note that if this field's value is\n *    zero then the endpoints default value is changed (effecting future\n *    associations only).\n *\n * sack_delay -  This parameter contains the number of milliseconds that\n *    the user is requesting the delayed ACK timer be set to.  Note that\n *    this value is defined in the standard to be between 200 and 500\n *    milliseconds.\n *\n * sack_freq -  This parameter contains the number of packets that must\n *    be received before a sack is sent without waiting for the delay\n *    timer to expire.  The default value for this is 2, setting this\n *    value to 1 will disable the delayed sack algorithm.\n */\n\nstatic int sctp_setsockopt_delayed_ack(struct sock *sk,\n\t\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_sack_info    params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (optlen == sizeof(struct sctp_sack_info)) {\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tif (params.sack_delay == 0 && params.sack_freq == 0)\n\t\t\treturn 0;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tif (params.sack_delay == 0)\n\t\t\tparams.sack_freq = 1;\n\t\telse\n\t\t\tparams.sack_freq = 0;\n\t} else\n\t\treturn -EINVAL;\n\n\t/* Validate value parameter. */\n\tif (params.sack_delay > 500)\n\t\treturn -EINVAL;\n\n\t/* Get association, if sack_assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.sack_assoc_id);\n\tif (!asoc && params.sack_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (params.sack_delay) {\n\t\tif (asoc) {\n\t\t\tasoc->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params.sack_delay);\n\t\t\tasoc->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t\t} else {\n\t\t\tsp->sackdelay = params.sack_delay;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t}\n\n\tif (params.sack_freq == 1) {\n\t\tif (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(asoc->param_flags);\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(sp->param_flags);\n\t\t}\n\t} else if (params.sack_freq > 1) {\n\t\tif (asoc) {\n\t\t\tasoc->sackfreq = params.sack_freq;\n\t\t\tasoc->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t\t} else {\n\t\t\tsp->sackfreq = params.sack_freq;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t}\n\n\t/* If change is for association, also apply to each transport. */\n\tif (asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tif (params.sack_delay) {\n\t\t\t\ttrans->sackdelay =\n\t\t\t\t\tmsecs_to_jiffies(params.sack_delay);\n\t\t\t\ttrans->param_flags =\n\t\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t\t}\n\t\t\tif (params.sack_freq == 1) {\n\t\t\t\ttrans->param_flags =\n\t\t\t\t\tsctp_spp_sackdelay_disable(trans->param_flags);\n\t\t\t} else if (params.sack_freq > 1) {\n\t\t\t\ttrans->sackfreq = params.sack_freq;\n\t\t\t\ttrans->param_flags =\n\t\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.3 Initialization Parameters (SCTP_INITMSG)\n *\n * Applications can specify protocol parameters for the default association\n * initialization.  The option name argument to setsockopt() and getsockopt()\n * is SCTP_INITMSG.\n *\n * Setting initialization parameters is effective only on an unconnected\n * socket (for UDP-style sockets only future associations are effected\n * by the change).  With TCP-style sockets, this option is inherited by\n * sockets derived from a listener socket.\n */\nstatic int sctp_setsockopt_initmsg(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_initmsg sinit;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sinit, optval, optlen))\n\t\treturn -EFAULT;\n\n\tif (sinit.sinit_num_ostreams)\n\t\tsp->initmsg.sinit_num_ostreams = sinit.sinit_num_ostreams;\n\tif (sinit.sinit_max_instreams)\n\t\tsp->initmsg.sinit_max_instreams = sinit.sinit_max_instreams;\n\tif (sinit.sinit_max_attempts)\n\t\tsp->initmsg.sinit_max_attempts = sinit.sinit_max_attempts;\n\tif (sinit.sinit_max_init_timeo)\n\t\tsp->initmsg.sinit_max_init_timeo = sinit.sinit_max_init_timeo;\n\n\treturn 0;\n}\n\n/*\n * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)\n *\n *   Applications that wish to use the sendto() system call may wish to\n *   specify a default set of parameters that would normally be supplied\n *   through the inclusion of ancillary data.  This socket option allows\n *   such an application to set the default sctp_sndrcvinfo structure.\n *   The application that wishes to use this socket option simply passes\n *   in to this call the sctp_sndrcvinfo structure defined in Section\n *   5.2.2) The input parameters accepted by this call include\n *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,\n *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in\n *   to this call if the caller is using the UDP model.\n */\nstatic int sctp_setsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\t      char __user *optval,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndrcvinfo info;\n\n\tif (optlen != sizeof(info))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&info, optval, optlen))\n\t\treturn -EFAULT;\n\tif (info.sinfo_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info.sinfo_assoc_id);\n\tif (!asoc && info.sinfo_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tasoc->default_stream = info.sinfo_stream;\n\t\tasoc->default_flags = info.sinfo_flags;\n\t\tasoc->default_ppid = info.sinfo_ppid;\n\t\tasoc->default_context = info.sinfo_context;\n\t\tasoc->default_timetolive = info.sinfo_timetolive;\n\t} else {\n\t\tsp->default_stream = info.sinfo_stream;\n\t\tsp->default_flags = info.sinfo_flags;\n\t\tsp->default_ppid = info.sinfo_ppid;\n\t\tsp->default_context = info.sinfo_context;\n\t\tsp->default_timetolive = info.sinfo_timetolive;\n\t}\n\n\treturn 0;\n}\n\n/* RFC6458, Section 8.1.31. Set/get Default Send Parameters\n * (SCTP_DEFAULT_SNDINFO)\n */\nstatic int sctp_setsockopt_default_sndinfo(struct sock *sk,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndinfo info;\n\n\tif (optlen != sizeof(info))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&info, optval, optlen))\n\t\treturn -EFAULT;\n\tif (info.snd_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info.snd_assoc_id);\n\tif (!asoc && info.snd_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tasoc->default_stream = info.snd_sid;\n\t\tasoc->default_flags = info.snd_flags;\n\t\tasoc->default_ppid = info.snd_ppid;\n\t\tasoc->default_context = info.snd_context;\n\t} else {\n\t\tsp->default_stream = info.snd_sid;\n\t\tsp->default_flags = info.snd_flags;\n\t\tsp->default_ppid = info.snd_ppid;\n\t\tsp->default_context = info.snd_context;\n\t}\n\n\treturn 0;\n}\n\n/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)\n *\n * Requests that the local SCTP stack use the enclosed peer address as\n * the association primary.  The enclosed address must be one of the\n * association peer's addresses.\n */\nstatic int sctp_setsockopt_primary_addr(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_prim prim;\n\tstruct sctp_transport *trans;\n\n\tif (optlen != sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&prim, optval, sizeof(struct sctp_prim)))\n\t\treturn -EFAULT;\n\n\ttrans = sctp_addr_id2transport(sk, &prim.ssp_addr, prim.ssp_assoc_id);\n\tif (!trans)\n\t\treturn -EINVAL;\n\n\tsctp_assoc_set_primary(trans->asoc, trans);\n\n\treturn 0;\n}\n\n/*\n * 7.1.5 SCTP_NODELAY\n *\n * Turn on/off any Nagle-like algorithm.  This means that packets are\n * generally sent as soon as possible and no unnecessary delays are\n * introduced, at the cost of more packets in the network.  Expects an\n *  integer boolean flag.\n */\nstatic int sctp_setsockopt_nodelay(struct sock *sk, char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->nodelay = (val == 0) ? 0 : 1;\n\treturn 0;\n}\n\n/*\n *\n * 7.1.1 SCTP_RTOINFO\n *\n * The protocol parameters used to initialize and bound retransmission\n * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access\n * and modify these parameters.\n * All parameters are time values, in milliseconds.  A value of 0, when\n * modifying the parameters, indicates that the current value should not\n * be changed.\n *\n */\nstatic int sctp_setsockopt_rtoinfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\tunsigned long rto_min, rto_max;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&rtoinfo, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\t/* Set the values to the specific association */\n\tif (!asoc && rtoinfo.srto_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\trto_max = rtoinfo.srto_max;\n\trto_min = rtoinfo.srto_min;\n\n\tif (rto_max)\n\t\trto_max = asoc ? msecs_to_jiffies(rto_max) : rto_max;\n\telse\n\t\trto_max = asoc ? asoc->rto_max : sp->rtoinfo.srto_max;\n\n\tif (rto_min)\n\t\trto_min = asoc ? msecs_to_jiffies(rto_min) : rto_min;\n\telse\n\t\trto_min = asoc ? asoc->rto_min : sp->rtoinfo.srto_min;\n\n\tif (rto_min > rto_max)\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (rtoinfo.srto_initial != 0)\n\t\t\tasoc->rto_initial =\n\t\t\t\tmsecs_to_jiffies(rtoinfo.srto_initial);\n\t\tasoc->rto_max = rto_max;\n\t\tasoc->rto_min = rto_min;\n\t} else {\n\t\t/* If there is no association or the association-id = 0\n\t\t * set the values to the endpoint.\n\t\t */\n\t\tif (rtoinfo.srto_initial != 0)\n\t\t\tsp->rtoinfo.srto_initial = rtoinfo.srto_initial;\n\t\tsp->rtoinfo.srto_max = rto_max;\n\t\tsp->rtoinfo.srto_min = rto_min;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.2 SCTP_ASSOCINFO\n *\n * This option is used to tune the maximum retransmission attempts\n * of the association.\n * Returns an error if the new association retransmission value is\n * greater than the sum of the retransmission value  of the peer.\n * See [SCTP] for more information.\n *\n */\nstatic int sctp_setsockopt_associnfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assocparams))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&assocparams, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Set the values to the specific association */\n\tif (asoc) {\n\t\tif (assocparams.sasoc_asocmaxrxt != 0) {\n\t\t\t__u32 path_sum = 0;\n\t\t\tint   paths = 0;\n\t\t\tstruct sctp_transport *peer_addr;\n\n\t\t\tlist_for_each_entry(peer_addr, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tpath_sum += peer_addr->pathmaxrxt;\n\t\t\t\tpaths++;\n\t\t\t}\n\n\t\t\t/* Only validate asocmaxrxt if we have more than\n\t\t\t * one path/transport.  We do this because path\n\t\t\t * retransmissions are only counted when we have more\n\t\t\t * then one path.\n\t\t\t */\n\t\t\tif (paths > 1 &&\n\t\t\t    assocparams.sasoc_asocmaxrxt > path_sum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tasoc->max_retrans = assocparams.sasoc_asocmaxrxt;\n\t\t}\n\n\t\tif (assocparams.sasoc_cookie_life != 0)\n\t\t\tasoc->cookie_life = ms_to_ktime(assocparams.sasoc_cookie_life);\n\t} else {\n\t\t/* Set the values to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (assocparams.sasoc_asocmaxrxt != 0)\n\t\t\tsp->assocparams.sasoc_asocmaxrxt =\n\t\t\t\t\t\tassocparams.sasoc_asocmaxrxt;\n\t\tif (assocparams.sasoc_cookie_life != 0)\n\t\t\tsp->assocparams.sasoc_cookie_life =\n\t\t\t\t\t\tassocparams.sasoc_cookie_life;\n\t}\n\treturn 0;\n}\n\n/*\n * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n *\n * This socket option is a boolean flag which turns on or off mapped V4\n * addresses.  If this option is turned on and the socket is type\n * PF_INET6, then IPv4 addresses will be mapped to V6 representation.\n * If this option is turned off, then no mapping will be done of V4\n * addresses and a user will receive both PF_INET6 and PF_INET type\n * addresses on the socket.\n */\nstatic int sctp_setsockopt_mappedv4(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (val)\n\t\tsp->v4mapped = 1;\n\telse\n\t\tsp->v4mapped = 0;\n\n\treturn 0;\n}\n\n/*\n * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n * This option will get or set the maximum size to put in any outgoing\n * SCTP DATA chunk.  If a message is larger than this size it will be\n * fragmented by SCTP into the specified size.  Note that the underlying\n * SCTP implementation may fragment into smaller sized chunks when the\n * PMTU of the underlying association is smaller than the value set by\n * the user.  The default value for this option is '0' which indicates\n * the user is NOT limiting fragmentation and only the PMTU will effect\n * SCTP's choice of DATA chunk size.  Note also that values set larger\n * than the maximum size of an IP datagram will effectively let SCTP\n * control fragmentation (i.e. the same as setting this option to 0).\n *\n * The following structure is used to access and modify this parameter:\n *\n * struct sctp_assoc_value {\n *   sctp_assoc_t assoc_id;\n *   uint32_t assoc_value;\n * };\n *\n * assoc_id:  This parameter is ignored for one-to-one style sockets.\n *    For one-to-many style sockets this parameter indicates which\n *    association the user is performing an action upon.  Note that if\n *    this field's value is zero then the endpoints default value is\n *    changed (effecting future associations only).\n * assoc_value:  This parameter specifies the maximum size in bytes.\n */\nstatic int sctp_setsockopt_maxseg(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint val;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&val, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tparams.assoc_id = 0;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tval = params.assoc_value;\n\t} else\n\t\treturn -EINVAL;\n\n\tif ((val != 0) && ((val < 8) || (val > SCTP_MAX_CHUNK_LEN)))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (val == 0) {\n\t\t\tval = asoc->pathmtu;\n\t\t\tval -= sp->pf->af->net_header_len;\n\t\t\tval -= sizeof(struct sctphdr) +\n\t\t\t\t\tsizeof(struct sctp_data_chunk);\n\t\t}\n\t\tasoc->user_frag = val;\n\t\tasoc->frag_point = sctp_frag_point(asoc, asoc->pathmtu);\n\t} else {\n\t\tsp->user_frag = val;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n *  7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)\n *\n *   Requests that the peer mark the enclosed address as the association\n *   primary. The enclosed address must be one of the association's\n *   locally bound addresses. The following structure is used to make a\n *   set primary request:\n */\nstatic int sctp_setsockopt_peer_primary_addr(struct sock *sk, char __user *optval,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_association\t*asoc = NULL;\n\tstruct sctp_setpeerprim\tprim;\n\tstruct sctp_chunk\t*chunk;\n\tstruct sctp_af\t\t*af;\n\tint \t\t\terr;\n\n\tsp = sctp_sk(sk);\n\n\tif (!net->sctp.addip_enable)\n\t\treturn -EPERM;\n\n\tif (optlen != sizeof(struct sctp_setpeerprim))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&prim, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, prim.sspp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.asconf_capable)\n\t\treturn -EPERM;\n\n\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_SET_PRIMARY)\n\t\treturn -EPERM;\n\n\tif (!sctp_state(asoc, ESTABLISHED))\n\t\treturn -ENOTCONN;\n\n\taf = sctp_get_af_specific(prim.sspp_addr.ss_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tif (!af->addr_valid((union sctp_addr *)&prim.sspp_addr, sp, NULL))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!sctp_assoc_lookup_laddr(asoc, (union sctp_addr *)&prim.sspp_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Create an ASCONF chunk with SET_PRIMARY parameter\t*/\n\tchunk = sctp_make_asconf_set_prim(asoc,\n\t\t\t\t\t  (union sctp_addr *)&prim.sspp_addr);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\terr = sctp_send_asconf(asoc, chunk);\n\n\tpr_debug(\"%s: we set peer primary addr primitively\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int sctp_setsockopt_adaptation_layer(struct sock *sk, char __user *optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (optlen != sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&adaptation, optval, optlen))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->adaptation_ind = adaptation.ssb_adaptation_ind;\n\n\treturn 0;\n}\n\n/*\n * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)\n *\n * The context field in the sctp_sndrcvinfo structure is normally only\n * used when a failed message is retrieved holding the value that was\n * sent down on the actual send call.  This option allows the setting of\n * a default context on an association basis that will be received on\n * reading messages from the peer.  This is especially helpful in the\n * one-2-many model for an application to keep some reference to an\n * internal state machine that is processing messages on the\n * association.  Note that the setting of this value only effects\n * received messages from the peer and does not effect the value that is\n * saved with outbound messages.\n */\nstatic int sctp_setsockopt_context(struct sock *sk, char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&params, optval, optlen))\n\t\treturn -EFAULT;\n\n\tsp = sctp_sk(sk);\n\n\tif (params.assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tasoc->default_rcv_context = params.assoc_value;\n\t} else {\n\t\tsp->default_rcv_context = params.assoc_value;\n\t}\n\n\treturn 0;\n}\n\n/*\n * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)\n *\n * This options will at a minimum specify if the implementation is doing\n * fragmented interleave.  Fragmented interleave, for a one to many\n * socket, is when subsequent calls to receive a message may return\n * parts of messages from different associations.  Some implementations\n * may allow you to turn this value on or off.  If so, when turned off,\n * no fragment interleave will occur (which will cause a head of line\n * blocking amongst multiple associations sharing the same one to many\n * socket).  When this option is turned on, then each receive call may\n * come from a different association (thus the user must receive data\n * with the extended calls (e.g. sctp_recvmsg) to keep track of which\n * association each receive belongs to.\n *\n * This option takes a boolean value.  A non-zero value indicates that\n * fragmented interleave is on.  A value of zero indicates that\n * fragmented interleave is off.\n *\n * Note that it is important that an implementation that allows this\n * option to be turned on, have it off by default.  Otherwise an unaware\n * application using the one to many model may become confused and act\n * incorrectly.\n */\nstatic int sctp_setsockopt_fragment_interleave(struct sock *sk,\n\t\t\t\t\t       char __user *optval,\n\t\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->frag_interleave = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\n/*\n * 8.1.21.  Set or Get the SCTP Partial Delivery Point\n *       (SCTP_PARTIAL_DELIVERY_POINT)\n *\n * This option will set or get the SCTP partial delivery point.  This\n * point is the size of a message where the partial delivery API will be\n * invoked to help free up rwnd space for the peer.  Setting this to a\n * lower value will cause partial deliveries to happen more often.  The\n * calls argument is an integer that sets or gets the partial delivery\n * point.  Note also that the call will fail if the user attempts to set\n * this value larger than the socket receive buffer size.\n *\n * Note that any single message having a length smaller than or equal to\n * the SCTP partial delivery point will be delivered in one single read\n * call as long as the user provided buffer is large enough to hold the\n * message.\n */\nstatic int sctp_setsockopt_partial_delivery_point(struct sock *sk,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  unsigned int optlen)\n{\n\tu32 val;\n\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\t/* Note: We double the receive buffer from what the user sets\n\t * it to be, also initial rwnd is based on rcvbuf/2.\n\t */\n\tif (val > (sk->sk_rcvbuf >> 1))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->pd_point = val;\n\n\treturn 0; /* is this the right error code? */\n}\n\n/*\n * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)\n *\n * This option will allow a user to change the maximum burst of packets\n * that can be emitted by this association.  Note that the default value\n * is 4, and some implementations may restrict this setting so that it\n * can only be lowered.\n *\n * NOTE: This text doesn't seem right.  Do this on a socket basis with\n * future associations inheriting the socket value.\n */\nstatic int sctp_setsockopt_maxburst(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\tint val;\n\tint assoc_id = 0;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option deprecated.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&val, optval, optlen))\n\t\t\treturn -EFAULT;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tif (copy_from_user(&params, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\tval = params.assoc_value;\n\t\tassoc_id = params.assoc_id;\n\t} else\n\t\treturn -EINVAL;\n\n\tsp = sctp_sk(sk);\n\n\tif (assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tasoc->max_burst = val;\n\t} else\n\t\tsp->max_burst = val;\n\n\treturn 0;\n}\n\n/*\n * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)\n *\n * This set option adds a chunk type that the user is requesting to be\n * received only in an authenticated way.  Changes to the list of chunks\n * will only effect future associations on the socket.\n */\nstatic int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunk val;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (val.sauth_chunk) {\n\tcase SCTP_CID_INIT:\n\tcase SCTP_CID_INIT_ACK:\n\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\tcase SCTP_CID_AUTH:\n\t\treturn -EINVAL;\n\t}\n\n\t/* add this chunk id to the endpoint */\n\treturn sctp_auth_ep_add_chunkid(ep, val.sauth_chunk);\n}\n\n/*\n * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)\n *\n * This option gets or sets the list of HMAC algorithms that the local\n * endpoint requires the peer to use.\n */\nstatic int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_hmacalgo *hmacs;\n\tu32 idents;\n\tint err;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\n\thmacs = memdup_user(optval, optlen);\n\tif (IS_ERR(hmacs))\n\t\treturn PTR_ERR(hmacs);\n\n\tidents = hmacs->shmac_num_idents;\n\tif (idents == 0 || idents > SCTP_AUTH_NUM_HMACS ||\n\t    (idents * sizeof(u16)) > (optlen - sizeof(struct sctp_hmacalgo))) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = sctp_auth_ep_set_hmacs(ep, hmacs);\nout:\n\tkfree(hmacs);\n\treturn err;\n}\n\n/*\n * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)\n *\n * This option will set a shared secret key which is used to build an\n * association shared key.\n */\nstatic int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = memdup_user(optval, optlen);\n\tif (IS_ERR(authkey))\n\t\treturn PTR_ERR(authkey);\n\n\tif (authkey->sca_keylength > optlen - sizeof(struct sctp_authkey)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(ep, asoc, authkey);\nout:\n\tkzfree(authkey);\n\treturn ret;\n}\n\n/*\n * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)\n *\n * This option will get or set the active shared key to be used to build\n * the association shared key.\n */\nstatic int sctp_setsockopt_active_key(struct sock *sk,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_set_active_key(ep, asoc, val.scact_keynumber);\n}\n\n/*\n * 7.1.22.  Delete a shared key (SCTP_AUTH_DELETE_KEY)\n *\n * This set option will delete a shared secret key from use.\n */\nstatic int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t   char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_del_key_id(ep, asoc, val.scact_keynumber);\n\n}\n\n/*\n * 8.1.23 SCTP_AUTO_ASCONF\n *\n * This option will enable or disable the use of the automatic generation of\n * ASCONF chunks to add and delete addresses to an existing association.  Note\n * that this option has two caveats namely: a) it only affects sockets that\n * are bound to all addresses available to the SCTP stack, and b) the system\n * administrator may have an overriding control that turns the ASCONF feature\n * off no matter what setting the socket option may have.\n * This option expects an integer boolean flag, where a non-zero value turns on\n * the option, and a zero value turns off the option.\n * Note. In this implementation, socket operation overrides default parameter\n * being set by sysctl as well as FreeBSD implementation\n */\nstatic int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (!sctp_is_ep_boundall(sk) && val)\n\t\treturn -EINVAL;\n\tif ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))\n\t\treturn 0;\n\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}\n\n/*\n * SCTP_PEER_ADDR_THLDS\n *\n * This option allows us to alter the partially failed threshold for one or all\n * transports in an association.  See Section 6.1 of:\n * http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt\n */\nstatic int sctp_setsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_paddrthlds val;\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\n\tif (optlen < sizeof(struct sctp_paddrthlds))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, (struct sctp_paddrthlds __user *)optval,\n\t\t\t   sizeof(struct sctp_paddrthlds)))\n\t\treturn -EFAULT;\n\n\n\tif (sctp_is_any(sk, (const union sctp_addr *)&val.spt_address)) {\n\t\tasoc = sctp_id2assoc(sk, val.spt_assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -ENOENT;\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports) {\n\t\t\tif (val.spt_pathmaxrxt)\n\t\t\t\ttrans->pathmaxrxt = val.spt_pathmaxrxt;\n\t\t\ttrans->pf_retrans = val.spt_pathpfthld;\n\t\t}\n\n\t\tif (val.spt_pathmaxrxt)\n\t\t\tasoc->pathmaxrxt = val.spt_pathmaxrxt;\n\t\tasoc->pf_retrans = val.spt_pathpfthld;\n\t} else {\n\t\ttrans = sctp_addr_id2transport(sk, &val.spt_address,\n\t\t\t\t\t       val.spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tif (val.spt_pathmaxrxt)\n\t\t\ttrans->pathmaxrxt = val.spt_pathmaxrxt;\n\t\ttrans->pf_retrans = val.spt_pathpfthld;\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvrcvinfo(struct sock *sk,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->recvrcvinfo = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvnxtinfo(struct sock *sk,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->recvnxtinfo = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_pr_supported(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(params))\n\t\tgoto out;\n\n\tif (copy_from_user(&params, optval, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tasoc->prsctp_enable = !!params.assoc_value;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tsp->ep->prsctp_enable = !!params.assoc_value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_default_prinfo(struct sock *sk,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_default_prinfo info;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(info))\n\t\tgoto out;\n\n\tif (copy_from_user(&info, optval, sizeof(info))) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (info.pr_policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tif (info.pr_policy == SCTP_PR_SCTP_NONE)\n\t\tinfo.pr_value = 0;\n\n\tasoc = sctp_id2assoc(sk, info.pr_assoc_id);\n\tif (asoc) {\n\t\tSCTP_PR_SET_POLICY(asoc->default_flags, info.pr_policy);\n\t\tasoc->default_timetolive = info.pr_value;\n\t} else if (!info.pr_assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tSCTP_PR_SET_POLICY(sp->default_flags, info.pr_policy);\n\t\tsp->default_timetolive = info.pr_value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\n/* API 6.2 setsockopt(), getsockopt()\n *\n * Applications use setsockopt() and getsockopt() to set or retrieve\n * socket options.  Socket options are used to change the default\n * behavior of sockets calls.  They are described in Section 7.\n *\n * The syntax is:\n *\n *   ret = getsockopt(int sd, int level, int optname, void __user *optval,\n *                    int __user *optlen);\n *   ret = setsockopt(int sd, int level, int optname, const void __user *optval,\n *                    int optlen);\n *\n *   sd      - the socket descript.\n *   level   - set to IPPROTO_SCTP for all SCTP options.\n *   optname - the option name.\n *   optval  - the buffer to store the value of the option.\n *   optlen  - the size of the buffer.\n */\nstatic int sctp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint retval = 0;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t/* I can hardly begin to describe how wrong this is.  This is\n\t * so broken as to be worse than useless.  The API draft\n\t * REALLY is NOT helpful here...  I am not convinced that the\n\t * semantics of setsockopt() with a level OTHER THAN SOL_SCTP\n\t * are at all well-founded.\n\t */\n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\t\tretval = af->setsockopt(sk, level, optname, optval, optlen);\n\t\tgoto out_nounlock;\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_SOCKOPT_BINDX_ADD:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_bindx(sk, (struct sockaddr __user *)optval,\n\t\t\t\t\t       optlen, SCTP_BINDX_ADD_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_BINDX_REM:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_bindx(sk, (struct sockaddr __user *)optval,\n\t\t\t\t\t       optlen, SCTP_BINDX_REM_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX_OLD:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_connectx_old(sk,\n\t\t\t\t\t    (struct sockaddr __user *)optval,\n\t\t\t\t\t    optlen);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX:\n\t\t/* 'optlen' is the size of the addresses buffer. */\n\t\tretval = sctp_setsockopt_connectx(sk,\n\t\t\t\t\t    (struct sockaddr __user *)optval,\n\t\t\t\t\t    optlen);\n\t\tbreak;\n\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_setsockopt_disable_fragments(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_setsockopt_events(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_setsockopt_autoclose(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_setsockopt_peer_addr_params(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_setsockopt_delayed_ack(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_setsockopt_partial_delivery_point(sk, optval, optlen);\n\t\tbreak;\n\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_setsockopt_initmsg(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_setsockopt_default_send_param(sk, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_setsockopt_default_sndinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_primary_addr(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SET_PEER_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_peer_primary_addr(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_setsockopt_nodelay(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_setsockopt_rtoinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_setsockopt_associnfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_setsockopt_mappedv4(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_setsockopt_maxseg(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_setsockopt_adaptation_layer(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_setsockopt_context(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_setsockopt_fragment_interleave(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_setsockopt_maxburst(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_CHUNK:\n\t\tretval = sctp_setsockopt_auth_chunk(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_setsockopt_hmac_ident(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\t\tretval = sctp_setsockopt_auth_key(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_setsockopt_active_key(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_DELETE_KEY:\n\t\tretval = sctp_setsockopt_del_key(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_setsockopt_auto_asconf(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_setsockopt_recvnxtinfo(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_setsockopt_pr_supported(sk, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_setsockopt_default_prinfo(sk, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\nout_nounlock:\n\treturn retval;\n}\n\n/* API 3.1.6 connect() - UDP Style Syntax\n *\n * An application may use the connect() call in the UDP model to initiate an\n * association without sending data.\n *\n * The syntax is:\n *\n * ret = connect(int sd, const struct sockaddr *nam, socklen_t len);\n *\n * sd: the socket descriptor to have a new association added to.\n *\n * nam: the address structure (either struct sockaddr_in or struct\n *    sockaddr_in6 defined in RFC2553 [7]).\n *\n * len: the size of the address.\n */\nstatic int sctp_connect(struct sock *sk, struct sockaddr *addr,\n\t\t\tint addr_len)\n{\n\tint err = 0;\n\tstruct sctp_af *af;\n\n\tlock_sock(sk);\n\n\tpr_debug(\"%s: sk:%p, sockaddr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t/* Validate addr_len before calling common connect/connectx routine. */\n\taf = sctp_get_af_specific(addr->sa_family);\n\tif (!af || addr_len < af->sockaddr_len) {\n\t\terr = -EINVAL;\n\t} else {\n\t\t/* Pass correct addr len to common routine (so it knows there\n\t\t * is only one address being passed.\n\t\t */\n\t\terr = __sctp_connect(sk, addr, af->sockaddr_len, NULL);\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* FIXME: Write comments. */\nstatic int sctp_disconnect(struct sock *sk, int flags)\n{\n\treturn -EOPNOTSUPP; /* STUB */\n}\n\n/* 4.1.4 accept() - TCP Style Syntax\n *\n * Applications use accept() call to remove an established SCTP\n * association from the accept queue of the endpoint.  A new socket\n * descriptor will be returned from accept() to represent the newly\n * formed association.\n */\nstatic struct sock *sctp_accept(struct sock *sk, int flags, int *err)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sock *newsk = NULL;\n\tstruct sctp_association *asoc;\n\tlong timeo;\n\tint error = 0;\n\n\tlock_sock(sk);\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!sctp_style(sk, TCP)) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!sctp_sstate(sk, LISTENING)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\terror = sctp_wait_for_accept(sk, timeo);\n\tif (error)\n\t\tgoto out;\n\n\t/* We treat the list of associations on the endpoint as the accept\n\t * queue and pick the first association on the list.\n\t */\n\tasoc = list_entry(ep->asocs.next, struct sctp_association, asocs);\n\n\tnewsk = sp->pf->create_accept_sk(sk, asoc);\n\tif (!newsk) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, newsk, asoc, SCTP_SOCKET_TCP);\n\nout:\n\trelease_sock(sk);\n\t*err = error;\n\treturn newsk;\n}\n\n/* The SCTP ioctl handler. */\nstatic int sctp_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\t/*\n\t * SEQPACKET-style sockets in LISTENING state are valid, for\n\t * SCTP, so only discard TCP-style sockets in LISTENING state.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int amount = 0;\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb != NULL) {\n\t\t\t/*\n\t\t\t * We will only return the amount of this packet since\n\t\t\t * that is all that will be read.\n\t\t\t */\n\t\t\tamount = skb->len;\n\t\t}\n\t\trc = put_user(amount, (int __user *)arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n/* This is the function which gets called during socket creation to\n * initialized the SCTP-specific portion of the sock.\n * The sock structure should already be zero-filled memory.\n */\nstatic int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk->sk_gso_type = SKB_GSO_SCTP;\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tmemset(&sp->subscribe, 0, sizeof(struct sctp_event_subscribe));\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tlocal_bh_disable();\n\tpercpu_counter_inc(&sctp_sockets_allocated);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\n\t/* Nothing can fail after this block, otherwise\n\t * sctp_destroy_sock() will be called without addr_wq_lock held\n\t */\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&sock_net(sk)->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &net->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t\tspin_unlock(&sock_net(sk)->sctp.addr_wq_lock);\n\t} else {\n\t\tsp->do_auto_asconf = 0;\n\t}\n\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n\n/* Cleanup any SCTP per socket resources. Must be called with\n * sock_net(sk)->sctp.addr_wq_lock held if sp->do_auto_asconf is true\n */\nstatic void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\t/* Release our hold on the endpoint. */\n\tsp = sctp_sk(sk);\n\t/* This could happen during socket init, thus we bail out\n\t * early, since the rest of the below is not setup either.\n\t */\n\tif (sp->ep == NULL)\n\t\treturn;\n\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tpercpu_counter_dec(&sctp_sockets_allocated);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}\n\n/* Triggered when there are no references on the socket anymore */\nstatic void sctp_destruct_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t/* Free up the HMAC transform. */\n\tcrypto_free_shash(sp->hmac);\n\n\tinet_sock_destruct(sk);\n}\n\n/* API 4.1.7 shutdown() - TCP Style Syntax\n *     int shutdown(int socket, int how);\n *\n *     sd      - the socket descriptor of the association to be closed.\n *     how     - Specifies the type of shutdown.  The  values  are\n *               as follows:\n *               SHUT_RD\n *                     Disables further receive operations. No SCTP\n *                     protocol action is taken.\n *               SHUT_WR\n *                     Disables further send operations, and initiates\n *                     the SCTP shutdown sequence.\n *               SHUT_RDWR\n *                     Disables further send  and  receive  operations\n *                     and initiates the SCTP shutdown sequence.\n */\nstatic void sctp_shutdown(struct sock *sk, int how)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\n\tif (!sctp_style(sk, TCP))\n\t\treturn;\n\n\tep = sctp_sk(sk)->ep;\n\tif (how & SEND_SHUTDOWN && !list_empty(&ep->asocs)) {\n\t\tstruct sctp_association *asoc;\n\n\t\tsk->sk_state = SCTP_SS_CLOSING;\n\t\tasoc = list_entry(ep->asocs.next,\n\t\t\t\t  struct sctp_association, asocs);\n\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n}\n\nint sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,\n\t\t       struct sctp_info *info)\n{\n\tstruct sctp_transport *prim;\n\tstruct list_head *pos;\n\tint mask;\n\n\tmemset(info, 0, sizeof(*info));\n\tif (!asoc) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo->sctpi_s_autoclose = sp->autoclose;\n\t\tinfo->sctpi_s_adaptation_ind = sp->adaptation_ind;\n\t\tinfo->sctpi_s_pd_point = sp->pd_point;\n\t\tinfo->sctpi_s_nodelay = sp->nodelay;\n\t\tinfo->sctpi_s_disable_fragments = sp->disable_fragments;\n\t\tinfo->sctpi_s_v4mapped = sp->v4mapped;\n\t\tinfo->sctpi_s_frag_interleave = sp->frag_interleave;\n\t\tinfo->sctpi_s_type = sp->type;\n\n\t\treturn 0;\n\t}\n\n\tinfo->sctpi_tag = asoc->c.my_vtag;\n\tinfo->sctpi_state = asoc->state;\n\tinfo->sctpi_rwnd = asoc->a_rwnd;\n\tinfo->sctpi_unackdata = asoc->unack_data;\n\tinfo->sctpi_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tinfo->sctpi_instrms = asoc->c.sinit_max_instreams;\n\tinfo->sctpi_outstrms = asoc->c.sinit_num_ostreams;\n\tlist_for_each(pos, &asoc->base.inqueue.in_chunk_list)\n\t\tinfo->sctpi_inqueue++;\n\tlist_for_each(pos, &asoc->outqueue.out_chunk_list)\n\t\tinfo->sctpi_outqueue++;\n\tinfo->sctpi_overall_error = asoc->overall_error_count;\n\tinfo->sctpi_max_burst = asoc->max_burst;\n\tinfo->sctpi_maxseg = asoc->frag_point;\n\tinfo->sctpi_peer_rwnd = asoc->peer.rwnd;\n\tinfo->sctpi_peer_tag = asoc->c.peer_vtag;\n\n\tmask = asoc->peer.ecn_capable << 1;\n\tmask = (mask | asoc->peer.ipv4_address) << 1;\n\tmask = (mask | asoc->peer.ipv6_address) << 1;\n\tmask = (mask | asoc->peer.hostname_address) << 1;\n\tmask = (mask | asoc->peer.asconf_capable) << 1;\n\tmask = (mask | asoc->peer.prsctp_capable) << 1;\n\tmask = (mask | asoc->peer.auth_capable);\n\tinfo->sctpi_peer_capable = mask;\n\tmask = asoc->peer.sack_needed << 1;\n\tmask = (mask | asoc->peer.sack_generation) << 1;\n\tmask = (mask | asoc->peer.zero_window_announced);\n\tinfo->sctpi_peer_sack = mask;\n\n\tinfo->sctpi_isacks = asoc->stats.isacks;\n\tinfo->sctpi_osacks = asoc->stats.osacks;\n\tinfo->sctpi_opackets = asoc->stats.opackets;\n\tinfo->sctpi_ipackets = asoc->stats.ipackets;\n\tinfo->sctpi_rtxchunks = asoc->stats.rtxchunks;\n\tinfo->sctpi_outofseqtsns = asoc->stats.outofseqtsns;\n\tinfo->sctpi_idupchunks = asoc->stats.idupchunks;\n\tinfo->sctpi_gapcnt = asoc->stats.gapcnt;\n\tinfo->sctpi_ouodchunks = asoc->stats.ouodchunks;\n\tinfo->sctpi_iuodchunks = asoc->stats.iuodchunks;\n\tinfo->sctpi_oodchunks = asoc->stats.oodchunks;\n\tinfo->sctpi_iodchunks = asoc->stats.iodchunks;\n\tinfo->sctpi_octrlchunks = asoc->stats.octrlchunks;\n\tinfo->sctpi_ictrlchunks = asoc->stats.ictrlchunks;\n\n\tprim = asoc->peer.primary_path;\n\tmemcpy(&info->sctpi_p_address, &prim->ipaddr,\n\t       sizeof(struct sockaddr_storage));\n\tinfo->sctpi_p_state = prim->state;\n\tinfo->sctpi_p_cwnd = prim->cwnd;\n\tinfo->sctpi_p_srtt = prim->srtt;\n\tinfo->sctpi_p_rto = jiffies_to_msecs(prim->rto);\n\tinfo->sctpi_p_hbinterval = prim->hbinterval;\n\tinfo->sctpi_p_pathmaxrxt = prim->pathmaxrxt;\n\tinfo->sctpi_p_sackdelay = jiffies_to_msecs(prim->sackdelay);\n\tinfo->sctpi_p_ssthresh = prim->ssthresh;\n\tinfo->sctpi_p_partial_bytes_acked = prim->partial_bytes_acked;\n\tinfo->sctpi_p_flight_size = prim->flight_size;\n\tinfo->sctpi_p_error = prim->error_count;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sctp_get_sctp_info);\n\n/* use callback to avoid exporting the core structure */\nint sctp_transport_walk_start(struct rhashtable_iter *iter)\n{\n\tint err;\n\n\trhltable_walk_enter(&sctp_transport_hashtable, iter);\n\n\terr = rhashtable_walk_start(iter);\n\tif (err && err != -EAGAIN) {\n\t\trhashtable_walk_stop(iter);\n\t\trhashtable_walk_exit(iter);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid sctp_transport_walk_stop(struct rhashtable_iter *iter)\n{\n\trhashtable_walk_stop(iter);\n\trhashtable_walk_exit(iter);\n}\n\nstruct sctp_transport *sctp_transport_get_next(struct net *net,\n\t\t\t\t\t       struct rhashtable_iter *iter)\n{\n\tstruct sctp_transport *t;\n\n\tt = rhashtable_walk_next(iter);\n\tfor (; t; t = rhashtable_walk_next(iter)) {\n\t\tif (IS_ERR(t)) {\n\t\t\tif (PTR_ERR(t) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (net_eq(sock_net(t->asoc->base.sk), net) &&\n\t\t    t->asoc->peer.primary_path == t)\n\t\t\tbreak;\n\t}\n\n\treturn t;\n}\n\nstruct sctp_transport *sctp_transport_get_idx(struct net *net,\n\t\t\t\t\t      struct rhashtable_iter *iter,\n\t\t\t\t\t      int pos)\n{\n\tvoid *obj = SEQ_START_TOKEN;\n\n\twhile (pos && (obj = sctp_transport_get_next(net, iter)) &&\n\t       !IS_ERR(obj))\n\t\tpos--;\n\n\treturn obj;\n}\n\nint sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),\n\t\t\t   void *p) {\n\tint err = 0;\n\tint hash = 0;\n\tstruct sctp_ep_common *epb;\n\tstruct sctp_hashbucket *head;\n\n\tfor (head = sctp_ep_hashtable; hash < sctp_ep_hashsize;\n\t     hash++, head++) {\n\t\tread_lock(&head->lock);\n\t\tsctp_for_each_hentry(epb, &head->chain) {\n\t\t\terr = cb(sctp_ep(epb), p);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tread_unlock(&head->lock);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_endpoint);\n\nint sctp_transport_lookup_process(int (*cb)(struct sctp_transport *, void *),\n\t\t\t\t  struct net *net,\n\t\t\t\t  const union sctp_addr *laddr,\n\t\t\t\t  const union sctp_addr *paddr, void *p)\n{\n\tstruct sctp_transport *transport;\n\tint err;\n\n\trcu_read_lock();\n\ttransport = sctp_addrs_lookup_transport(net, laddr, paddr);\n\trcu_read_unlock();\n\tif (!transport)\n\t\treturn -ENOENT;\n\n\terr = cb(transport, p);\n\tsctp_transport_put(transport);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_transport_lookup_process);\n\nint sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),\n\t\t\t    struct net *net, int pos, void *p) {\n\tstruct rhashtable_iter hti;\n\tvoid *obj;\n\tint err;\n\n\terr = sctp_transport_walk_start(&hti);\n\tif (err)\n\t\treturn err;\n\n\tsctp_transport_get_idx(net, &hti, pos);\n\tobj = sctp_transport_get_next(net, &hti);\n\tfor (; obj && !IS_ERR(obj); obj = sctp_transport_get_next(net, &hti)) {\n\t\tstruct sctp_transport *transport = obj;\n\n\t\tif (!sctp_transport_hold(transport))\n\t\t\tcontinue;\n\t\terr = cb(transport, p);\n\t\tsctp_transport_put(transport);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tsctp_transport_walk_stop(&hti);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_transport);\n\n/* 7.2.1 Association Status (SCTP_STATUS)\n\n * Applications can retrieve current status information about an\n * association, including association state, peer receiver window size,\n * number of unacked data chunks, and number of data chunks pending\n * receipt.  This information is read-only.\n */\nstatic int sctp_getsockopt_sctp_status(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_status status;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_transport *transport;\n\tsctp_assoc_t associd;\n\tint retval = 0;\n\n\tif (len < sizeof(status)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(status);\n\tif (copy_from_user(&status, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tassocid = status.sstat_assoc_id;\n\tasoc = sctp_id2assoc(sk, associd);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttransport = asoc->peer.primary_path;\n\n\tstatus.sstat_assoc_id = sctp_assoc2id(asoc);\n\tstatus.sstat_state = sctp_assoc_to_state(asoc);\n\tstatus.sstat_rwnd =  asoc->peer.rwnd;\n\tstatus.sstat_unackdata = asoc->unack_data;\n\n\tstatus.sstat_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tstatus.sstat_instrms = asoc->c.sinit_max_instreams;\n\tstatus.sstat_outstrms = asoc->c.sinit_num_ostreams;\n\tstatus.sstat_fragmentation_point = asoc->frag_point;\n\tstatus.sstat_primary.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tmemcpy(&status.sstat_primary.spinfo_address, &transport->ipaddr,\n\t\t\ttransport->af_specific->sockaddr_len);\n\t/* Map ipv4 address into v4-mapped-on-v6 address.  */\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t(union sctp_addr *)&status.sstat_primary.spinfo_address);\n\tstatus.sstat_primary.spinfo_state = transport->state;\n\tstatus.sstat_primary.spinfo_cwnd = transport->cwnd;\n\tstatus.sstat_primary.spinfo_srtt = transport->srtt;\n\tstatus.sstat_primary.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tstatus.sstat_primary.spinfo_mtu = transport->pathmtu;\n\n\tif (status.sstat_primary.spinfo_state == SCTP_UNKNOWN)\n\t\tstatus.sstat_primary.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"%s: len:%d, state:%d, rwnd:%d, assoc_id:%d\\n\",\n\t\t __func__, len, status.sstat_state, status.sstat_rwnd,\n\t\t status.sstat_assoc_id);\n\n\tif (copy_to_user(optval, &status, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n\n/* 7.2.2 Peer Address Information (SCTP_GET_PEER_ADDR_INFO)\n *\n * Applications can retrieve information about a specific peer address\n * of an association, including its reachability state, congestion\n * window, and retransmission timer values.  This information is\n * read-only.\n */\nstatic int sctp_getsockopt_peer_addr_info(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_paddrinfo pinfo;\n\tstruct sctp_transport *transport;\n\tint retval = 0;\n\n\tif (len < sizeof(pinfo)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(pinfo);\n\tif (copy_from_user(&pinfo, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\ttransport = sctp_addr_id2transport(sk, &pinfo.spinfo_address,\n\t\t\t\t\t   pinfo.spinfo_assoc_id);\n\tif (!transport)\n\t\treturn -EINVAL;\n\n\tpinfo.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tpinfo.spinfo_state = transport->state;\n\tpinfo.spinfo_cwnd = transport->cwnd;\n\tpinfo.spinfo_srtt = transport->srtt;\n\tpinfo.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tpinfo.spinfo_mtu = transport->pathmtu;\n\n\tif (pinfo.spinfo_state == SCTP_UNKNOWN)\n\t\tpinfo.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &pinfo, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n/* 7.1.12 Enable/Disable message fragmentation (SCTP_DISABLE_FRAGMENTS)\n *\n * This option is a on/off flag.  If enabled no SCTP message\n * fragmentation will be performed.  Instead if a message being sent\n * exceeds the current PMTU size, the message will NOT be sent and\n * instead a error will be indicated to the user.\n */\nstatic int sctp_getsockopt_disable_fragments(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->disable_fragments == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* 7.1.15 Set notification and ancillary events (SCTP_EVENTS)\n *\n * This socket option is used to specify various notifications and\n * ancillary data the user wishes to receive.\n */\nstatic int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > sizeof(struct sctp_event_subscribe))\n\t\tlen = sizeof(struct sctp_event_subscribe);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->subscribe, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* 7.1.8 Automatic Close of associations (SCTP_AUTOCLOSE)\n *\n * This socket option is applicable to the UDP-style socket only.  When\n * set it will cause associations that are idle for more than the\n * specified number of seconds to automatically close.  An association\n * being idle is defined an association that has NOT sent or received\n * user data.  The special value of '0' indicates that no automatic\n * close of any associations should be performed.  The option expects an\n * integer defining the number of seconds of idle time before an\n * association is closed.\n */\nstatic int sctp_getsockopt_autoclose(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\tlen = sizeof(int);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->autoclose, sizeof(int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/* Helper routine to branch off an association to a new socket.  */\nint sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\nEXPORT_SYMBOL(sctp_do_peeloff);\n\nstatic int sctp_getsockopt_peeloff(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_arg_t peeloff;\n\tstruct socket *newsock;\n\tstruct file *newfile;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_do_peeloff(sk, peeloff.associd, &newsock);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* Map the socket to an unused fd that can be returned to the user.  */\n\tretval = get_unused_fd_flags(0);\n\tif (retval < 0) {\n\t\tsock_release(newsock);\n\t\tgoto out;\n\t}\n\n\tnewfile = sock_alloc_file(newsock, 0, NULL);\n\tif (IS_ERR(newfile)) {\n\t\tput_unused_fd(retval);\n\t\tsock_release(newsock);\n\t\treturn PTR_ERR(newfile);\n\t}\n\n\tpr_debug(\"%s: sk:%p, newsk:%p, sd:%d\\n\", __func__, sk, newsock->sk,\n\t\t retval);\n\n\t/* Return the fd mapped to the new socket.  */\n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tpeeloff.sd = retval;\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}\n\n/* 7.1.13 Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n *\n * Applications can enable or disable heartbeats for any peer address of\n * an association, modify an address's heartbeat interval, force a\n * heartbeat to be sent immediately, and adjust the address's maximum\n * number of retransmissions sent before an address is considered\n * unreachable.  The following structure is used to access and modify an\n * address's parameters:\n *\n *  struct sctp_paddrparams {\n *     sctp_assoc_t            spp_assoc_id;\n *     struct sockaddr_storage spp_address;\n *     uint32_t                spp_hbinterval;\n *     uint16_t                spp_pathmaxrxt;\n *     uint32_t                spp_pathmtu;\n *     uint32_t                spp_sackdelay;\n *     uint32_t                spp_flags;\n * };\n *\n *   spp_assoc_id    - (one-to-many style socket) This is filled in the\n *                     application, and identifies the association for\n *                     this query.\n *   spp_address     - This specifies which address is of interest.\n *   spp_hbinterval  - This contains the value of the heartbeat interval,\n *                     in milliseconds.  If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmaxrxt  - This contains the maximum number of\n *                     retransmissions before this address shall be\n *                     considered unreachable. If a  value of zero\n *                     is present in this field then no changes are to\n *                     be made to this parameter.\n *   spp_pathmtu     - When Path MTU discovery is disabled the value\n *                     specified here will be the \"fixed\" path mtu.\n *                     Note that if the spp_address field is empty\n *                     then all associations on this address will\n *                     have this fixed path mtu set upon them.\n *\n *   spp_sackdelay   - When delayed sack is enabled, this value specifies\n *                     the number of milliseconds that sacks will be delayed\n *                     for. This value will apply to all addresses of an\n *                     association if the spp_address field is empty. Note\n *                     also, that if delayed sack is enabled and this\n *                     value is set to 0, no change is made to the last\n *                     recorded delayed sack timer value.\n *\n *   spp_flags       - These flags are used to control various features\n *                     on an association. The flag field may contain\n *                     zero or more of the following options.\n *\n *                     SPP_HB_ENABLE  - Enable heartbeats on the\n *                     specified address. Note that if the address\n *                     field is empty all addresses for the association\n *                     have heartbeats enabled upon them.\n *\n *                     SPP_HB_DISABLE - Disable heartbeats on the\n *                     speicifed address. Note that if the address\n *                     field is empty all addresses for the association\n *                     will have their heartbeats disabled. Note also\n *                     that SPP_HB_ENABLE and SPP_HB_DISABLE are\n *                     mutually exclusive, only one of these two should\n *                     be specified. Enabling both fields will have\n *                     undetermined results.\n *\n *                     SPP_HB_DEMAND - Request a user initiated heartbeat\n *                     to be made immediately.\n *\n *                     SPP_PMTUD_ENABLE - This field will enable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected.\n *\n *                     SPP_PMTUD_DISABLE - This field will disable PMTU\n *                     discovery upon the specified address. Note that\n *                     if the address feild is empty then all addresses\n *                     on the association are effected. Not also that\n *                     SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n *                     exclusive. Enabling both will have undetermined\n *                     results.\n *\n *                     SPP_SACKDELAY_ENABLE - Setting this flag turns\n *                     on delayed sack. The time specified in spp_sackdelay\n *                     is used to specify the sack delay for this address. Note\n *                     that if spp_address is empty then all addresses will\n *                     enable delayed sack and take on the sack delay\n *                     value specified in spp_sackdelay.\n *                     SPP_SACKDELAY_DISABLE - Setting this flag turns\n *                     off delayed sack. If the spp_address field is blank then\n *                     delayed sack is disabled for the entire association. Note\n *                     also that this field is mutually exclusive to\n *                     SPP_SACKDELAY_ENABLE, setting both will have undefined\n *                     results.\n */\nstatic int sctp_getsockopt_peer_addr_params(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_paddrparams))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_paddrparams);\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Get association, if assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id && sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trans) {\n\t\t/* Fetch transport values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);\n\t\tparams.spp_pathmtu    = trans->pathmtu;\n\t\tparams.spp_pathmaxrxt = trans->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(trans->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = trans->param_flags;\n\t} else if (asoc) {\n\t\t/* Fetch association values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(asoc->hbinterval);\n\t\tparams.spp_pathmtu    = asoc->pathmtu;\n\t\tparams.spp_pathmaxrxt = asoc->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(asoc->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = asoc->param_flags;\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tparams.spp_hbinterval = sp->hbinterval;\n\t\tparams.spp_pathmtu    = sp->pathmtu;\n\t\tparams.spp_sackdelay  = sp->sackdelay;\n\t\tparams.spp_pathmaxrxt = sp->pathmaxrxt;\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = sp->param_flags;\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)\n *\n * This option will effect the way delayed acks are performed.  This\n * option allows you to get or set the delayed ack time, in\n * milliseconds.  It also allows changing the delayed ack frequency.\n * Changing the frequency to 1 disables the delayed sack algorithm.  If\n * the assoc_id is 0, then this sets or gets the endpoints default\n * values.  If the assoc_id field is non-zero, then the set or get\n * effects the specified association for the one to many model (the\n * assoc_id field is ignored by the one to one model).  Note that if\n * sack_delay or sack_freq are 0 when setting this option, then the\n * current values will remain unchanged.\n *\n * struct sctp_sack_info {\n *     sctp_assoc_t            sack_assoc_id;\n *     uint32_t                sack_delay;\n *     uint32_t                sack_freq;\n * };\n *\n * sack_assoc_id -  This parameter, indicates which association the user\n *    is performing an action upon.  Note that if this field's value is\n *    zero then the endpoints default value is changed (effecting future\n *    associations only).\n *\n * sack_delay -  This parameter contains the number of milliseconds that\n *    the user is requesting the delayed ACK timer be set to.  Note that\n *    this value is defined in the standard to be between 200 and 500\n *    milliseconds.\n *\n * sack_freq -  This parameter contains the number of packets that must\n *    be received before a sack is sent without waiting for the delay\n *    timer to expire.  The default value for this is 2, setting this\n *    value to 1 will disable the delayed sack algorithm.\n */\nstatic int sctp_getsockopt_delayed_ack(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_sack_info    params;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len >= sizeof(struct sctp_sack_info)) {\n\t\tlen = sizeof(struct sctp_sack_info);\n\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else if (len == sizeof(struct sctp_assoc_value)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\t/* Get association, if sack_assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.sack_assoc_id);\n\tif (!asoc && params.sack_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\t/* Fetch association values. */\n\t\tif (asoc->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay = jiffies_to_msecs(\n\t\t\t\tasoc->sackdelay);\n\t\t\tparams.sack_freq = asoc->sackfreq;\n\n\t\t} else {\n\t\t\tparams.sack_delay = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tif (sp->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay  = sp->sackdelay;\n\t\t\tparams.sack_freq = sp->sackfreq;\n\t\t} else {\n\t\t\tparams.sack_delay  = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* 7.1.3 Initialization Parameters (SCTP_INITMSG)\n *\n * Applications can specify protocol parameters for the default association\n * initialization.  The option name argument to setsockopt() and getsockopt()\n * is SCTP_INITMSG.\n *\n * Setting initialization parameters is effective only on an unconnected\n * socket (for UDP-style sockets only future associations are effected\n * by the change).  With TCP-style sockets, this option is inherited by\n * sockets derived from a listener socket.\n */\nstatic int sctp_getsockopt_initmsg(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tif (len < sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_initmsg);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->initmsg, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\nstatic int sctp_getsockopt_peer_addrs(struct sock *sk, int len,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_transport *from;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tsize_t space_left;\n\tint bytes_copied;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t/* For UDP-style sockets, id specifies the association to query.  */\n\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\tlist_for_each_entry(from, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tmemcpy(&temp, &from->ipaddr, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(to, &temp, addrlen))\n\t\t\treturn -EFAULT;\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num))\n\t\treturn -EFAULT;\n\tbytes_copied = ((char __user *)to) - optval;\n\tif (put_user(bytes_copied, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_copy_laddrs(struct sock *sk, __u16 port, void *to,\n\t\t\t    size_t space_left, int *bytes_copied)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tunion sctp_addr temp;\n\tint cnt = 0;\n\tint addrlen;\n\tstruct net *net = sock_net(sk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &net->sctp.local_addr_list, list) {\n\t\tif (!addr->valid)\n\t\t\tcontinue;\n\n\t\tif ((PF_INET == sk->sk_family) &&\n\t\t    (AF_INET6 == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tif ((PF_INET6 == sk->sk_family) &&\n\t\t    inet_v6_ipv6only(sk) &&\n\t\t    (AF_INET == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\tif (!temp.v4.sin_port)\n\t\t\ttemp.v4.sin_port = htons(port);\n\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sctp_sk(sk), &temp);\n\n\t\tif (space_left < addrlen) {\n\t\t\tcnt =  -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(to, &temp, addrlen);\n\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t\t*bytes_copied += addrlen;\n\t}\n\trcu_read_unlock();\n\n\treturn cnt;\n}\n\n\nstatic int sctp_getsockopt_local_addrs(struct sock *sk, int len,\n\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_sockaddr_entry *addr;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tint err = 0;\n\tsize_t space_left;\n\tint bytes_copied = 0;\n\tvoid *addrs;\n\tvoid *buf;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t/*\n\t *  For UDP-style sockets, id specifies the association to query.\n\t *  If the id field is set to the value '0' then the locally bound\n\t *  addresses are returned without regard to any particular\n\t *  association.\n\t */\n\tif (0 == getaddrs.assoc_id) {\n\t\tbp = &sctp_sk(sk)->ep->base.bind_addr;\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tbp = &asoc->base.bind_addr;\n\t}\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\taddrs = kmalloc(space_left, GFP_USER | __GFP_NOWARN);\n\tif (!addrs)\n\t\treturn -ENOMEM;\n\n\t/* If the endpoint is bound to 0.0.0.0 or ::0, get the valid\n\t * addresses from the global local address list.\n\t */\n\tif (sctp_list_single_entry(&bp->address_list)) {\n\t\taddr = list_entry(bp->address_list.next,\n\t\t\t\t  struct sctp_sockaddr_entry, list);\n\t\tif (sctp_is_any(sk, &addr->a)) {\n\t\t\tcnt = sctp_copy_laddrs(sk, bp->port, addrs,\n\t\t\t\t\t\tspace_left, &bytes_copied);\n\t\t\tif (cnt < 0) {\n\t\t\t\terr = cnt;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto copy_getaddrs;\n\t\t}\n\t}\n\n\tbuf = addrs;\n\t/* Protection on the bound address list is not needed since\n\t * in the socket option context we hold a socket lock and\n\t * thus the bound address list can't change.\n\t */\n\tlist_for_each_entry(addr, &bp->address_list, list) {\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen) {\n\t\t\terr =  -ENOMEM; /*fixme: right error?*/\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buf, &temp, addrlen);\n\t\tbuf += addrlen;\n\t\tbytes_copied += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\ncopy_getaddrs:\n\tif (copy_to_user(to, addrs, bytes_copied)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (put_user(bytes_copied, optlen))\n\t\terr = -EFAULT;\nout:\n\tkfree(addrs);\n\treturn err;\n}\n\n/* 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)\n *\n * Requests that the local SCTP stack use the enclosed peer address as\n * the association primary.  The enclosed address must be one of the\n * association peer's addresses.\n */\nstatic int sctp_getsockopt_primary_addr(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct sctp_prim prim;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_prim);\n\n\tif (copy_from_user(&prim, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, prim.ssp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.primary_path)\n\t\treturn -ENOTCONN;\n\n\tmemcpy(&prim.ssp_addr, &asoc->peer.primary_path->ipaddr,\n\t\tasoc->peer.primary_path->af_specific->sockaddr_len);\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sp,\n\t\t\t(union sctp_addr *)&prim.ssp_addr);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &prim, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.11  Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)\n *\n * Requests that the local endpoint set the specified Adaptation Layer\n * Indication parameter for all future INIT and INIT-ACK exchanges.\n */\nstatic int sctp_getsockopt_adaptation_layer(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (len < sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_setadaptation);\n\n\tadaptation.ssb_adaptation_ind = sctp_sk(sk)->adaptation_ind;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &adaptation, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.14 Set default send parameters (SCTP_DEFAULT_SEND_PARAM)\n *\n *   Applications that wish to use the sendto() system call may wish to\n *   specify a default set of parameters that would normally be supplied\n *   through the inclusion of ancillary data.  This socket option allows\n *   such an application to set the default sctp_sndrcvinfo structure.\n\n\n *   The application that wishes to use this socket option simply passes\n *   in to this call the sctp_sndrcvinfo structure defined in Section\n *   5.2.2) The input parameters accepted by this call include\n *   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context,\n *   sinfo_timetolive.  The user must provide the sinfo_assoc_id field in\n *   to this call if the caller is using the UDP model.\n *\n *   For getsockopt, it get the default sctp_sndrcvinfo structure.\n */\nstatic int sctp_getsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\tint len, char __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndrcvinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.sinfo_assoc_id);\n\tif (!asoc && info.sinfo_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tinfo.sinfo_stream = asoc->default_stream;\n\t\tinfo.sinfo_flags = asoc->default_flags;\n\t\tinfo.sinfo_ppid = asoc->default_ppid;\n\t\tinfo.sinfo_context = asoc->default_context;\n\t\tinfo.sinfo_timetolive = asoc->default_timetolive;\n\t} else {\n\t\tinfo.sinfo_stream = sp->default_stream;\n\t\tinfo.sinfo_flags = sp->default_flags;\n\t\tinfo.sinfo_ppid = sp->default_ppid;\n\t\tinfo.sinfo_context = sp->default_context;\n\t\tinfo.sinfo_timetolive = sp->default_timetolive;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/* RFC6458, Section 8.1.31. Set/get Default Send Parameters\n * (SCTP_DEFAULT_SNDINFO)\n */\nstatic int sctp_getsockopt_default_sndinfo(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.snd_assoc_id);\n\tif (!asoc && info.snd_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\tif (asoc) {\n\t\tinfo.snd_sid = asoc->default_stream;\n\t\tinfo.snd_flags = asoc->default_flags;\n\t\tinfo.snd_ppid = asoc->default_ppid;\n\t\tinfo.snd_context = asoc->default_context;\n\t} else {\n\t\tinfo.snd_sid = sp->default_stream;\n\t\tinfo.snd_flags = sp->default_flags;\n\t\tinfo.snd_ppid = sp->default_ppid;\n\t\tinfo.snd_context = sp->default_context;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.5 SCTP_NODELAY\n *\n * Turn on/off any Nagle-like algorithm.  This means that packets are\n * generally sent as soon as possible and no unnecessary delays are\n * introduced, at the cost of more packets in the network.  Expects an\n * integer boolean flag.\n */\n\nstatic int sctp_getsockopt_nodelay(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->nodelay == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n *\n * 7.1.1 SCTP_RTOINFO\n *\n * The protocol parameters used to initialize and bound retransmission\n * timeout (RTO) are tunable. sctp_rtoinfo structure is used to access\n * and modify these parameters.\n * All parameters are time values, in milliseconds.  A value of 0, when\n * modifying the parameters, indicates that the current value should not\n * be changed.\n *\n */\nstatic int sctp_getsockopt_rtoinfo(struct sock *sk, int len,\n\t\t\t\tchar __user *optval,\n\t\t\t\tint __user *optlen) {\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_rtoinfo);\n\n\tif (copy_from_user(&rtoinfo, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\tif (!asoc && rtoinfo.srto_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Values corresponding to the specific association. */\n\tif (asoc) {\n\t\trtoinfo.srto_initial = jiffies_to_msecs(asoc->rto_initial);\n\t\trtoinfo.srto_max = jiffies_to_msecs(asoc->rto_max);\n\t\trtoinfo.srto_min = jiffies_to_msecs(asoc->rto_min);\n\t} else {\n\t\t/* Values corresponding to the endpoint. */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\trtoinfo.srto_initial = sp->rtoinfo.srto_initial;\n\t\trtoinfo.srto_max = sp->rtoinfo.srto_max;\n\t\trtoinfo.srto_min = sp->rtoinfo.srto_min;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &rtoinfo, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n *\n * 7.1.2 SCTP_ASSOCINFO\n *\n * This option is used to tune the maximum retransmission attempts\n * of the association.\n * Returns an error if the new association retransmission value is\n * greater than the sum of the retransmission value  of the peer.\n * See [SCTP] for more information.\n *\n */\nstatic int sctp_getsockopt_associnfo(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos;\n\tint cnt = 0;\n\n\tif (len < sizeof (struct sctp_assocparams))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assocparams);\n\n\tif (copy_from_user(&assocparams, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Values correspoinding to the specific association */\n\tif (asoc) {\n\t\tassocparams.sasoc_asocmaxrxt = asoc->max_retrans;\n\t\tassocparams.sasoc_peer_rwnd = asoc->peer.rwnd;\n\t\tassocparams.sasoc_local_rwnd = asoc->a_rwnd;\n\t\tassocparams.sasoc_cookie_life = ktime_to_ms(asoc->cookie_life);\n\n\t\tlist_for_each(pos, &asoc->peer.transport_addr_list) {\n\t\t\tcnt++;\n\t\t}\n\n\t\tassocparams.sasoc_number_peer_destinations = cnt;\n\t} else {\n\t\t/* Values corresponding to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tassocparams.sasoc_asocmaxrxt = sp->assocparams.sasoc_asocmaxrxt;\n\t\tassocparams.sasoc_peer_rwnd = sp->assocparams.sasoc_peer_rwnd;\n\t\tassocparams.sasoc_local_rwnd = sp->assocparams.sasoc_local_rwnd;\n\t\tassocparams.sasoc_cookie_life =\n\t\t\t\t\tsp->assocparams.sasoc_cookie_life;\n\t\tassocparams.sasoc_number_peer_destinations =\n\t\t\t\t\tsp->assocparams.\n\t\t\t\t\tsasoc_number_peer_destinations;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &assocparams, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.16 Set/clear IPv4 mapped addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n *\n * This socket option is a boolean flag which turns on or off mapped V4\n * addresses.  If this option is turned on and the socket is type\n * PF_INET6, then IPv4 addresses will be mapped to V6 representation.\n * If this option is turned off, then no mapping will be done of V4\n * addresses and a user will receive both PF_INET6 and PF_INET type\n * addresses on the socket.\n */\nstatic int sctp_getsockopt_mappedv4(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = sp->v4mapped;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.29.  Set or Get the default context (SCTP_CONTEXT)\n * (chapter and verse is quoted at sctp_setsockopt_context())\n */\nstatic int sctp_getsockopt_context(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_value);\n\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\tsp = sctp_sk(sk);\n\n\tif (params.assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tparams.assoc_value = asoc->default_rcv_context;\n\t} else {\n\t\tparams.assoc_value = sp->default_rcv_context;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n * This option will get or set the maximum size to put in any outgoing\n * SCTP DATA chunk.  If a message is larger than this size it will be\n * fragmented by SCTP into the specified size.  Note that the underlying\n * SCTP implementation may fragment into smaller sized chunks when the\n * PMTU of the underlying association is smaller than the value set by\n * the user.  The default value for this option is '0' which indicates\n * the user is NOT limiting fragmentation and only the PMTU will effect\n * SCTP's choice of DATA chunk size.  Note also that values set larger\n * than the maximum size of an IP datagram will effectively let SCTP\n * control fragmentation (i.e. the same as setting this option to 0).\n *\n * The following structure is used to access and modify this parameter:\n *\n * struct sctp_assoc_value {\n *   sctp_assoc_t assoc_id;\n *   uint32_t assoc_value;\n * };\n *\n * assoc_id:  This parameter is ignored for one-to-one style sockets.\n *    For one-to-many style sockets this parameter indicates which\n *    association the user is performing an action upon.  Note that if\n *    this field's value is zero then the endpoints default value is\n *    changed (effecting future associations only).\n * assoc_value:  This parameter specifies the maximum size in bytes.\n */\nstatic int sctp_getsockopt_maxseg(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = 0;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, sizeof(params)))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tparams.assoc_value = asoc->frag_point;\n\telse\n\t\tparams.assoc_value = sctp_sk(sk)->user_frag;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n/*\n * 7.1.24.  Get or set fragmented interleave (SCTP_FRAGMENT_INTERLEAVE)\n * (chapter and verse is quoted at sctp_setsockopt_fragment_interleave())\n */\nstatic int sctp_getsockopt_fragment_interleave(struct sock *sk, int len,\n\t\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\n\tval = sctp_sk(sk)->frag_interleave;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.25.  Set or Get the sctp partial delivery point\n * (chapter and verse is quoted at sctp_setsockopt_partial_delivery_point())\n */\nstatic int sctp_getsockopt_partial_delivery_point(struct sock *sk, int len,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int __user *optlen)\n{\n\tu32 val;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tval = sctp_sk(sk)->pd_point;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 7.1.28.  Set or Get the maximum burst (SCTP_MAX_BURST)\n * (chapter and verse is quoted at sctp_setsockopt_maxburst())\n */\nstatic int sctp_getsockopt_maxburst(struct sock *sk, int len,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_sock *sp;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = 0;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tsp = sctp_sk(sk);\n\n\tif (params.assoc_id != 0) {\n\t\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tparams.assoc_value = asoc->max_burst;\n\t} else\n\t\tparams.assoc_value = sp->max_burst;\n\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int sctp_getsockopt_hmac_ident(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_hmacalgo  __user *p = (void __user *)optval;\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 data_len = 0;\n\tu32 num_idents;\n\tint i;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\thmacs = ep->auth_hmacs_list;\n\tdata_len = ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\n\tif (len < sizeof(struct sctp_hmacalgo) + data_len)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_hmacalgo) + data_len;\n\tnum_idents = data_len / sizeof(u16);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_idents, &p->shmac_num_idents))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < num_idents; i++) {\n\t\t__u16 hmacid = ntohs(hmacs->hmac_ids[i]);\n\n\t\tif (copy_to_user(&p->shmac_idents[i], &hmacid, sizeof(__u16)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tval.scact_keynumber = asoc->active_key_id;\n\telse\n\t\tval.scact_keynumber = ep->active_key_id;\n\n\tlen = sizeof(struct sctp_authkeyid);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tch = asoc->peer.peer_chunks;\n\tif (!ch)\n\t\tgoto num;\n\n\t/* See if the user provided enough room for all the data */\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_local_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authchunks)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc && val.gauth_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tch = (struct sctp_chunks_param *)asoc->c.auth_chunks;\n\telse\n\t\tch = ep->auth_chunk_list;\n\n\tif (!ch)\n\t\tgoto num;\n\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(sctp_paramhdr_t);\n\tif (len < sizeof(struct sctp_authchunks) + num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.2.5.  Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)\n * This option gets the current number of associations that are attached\n * to a one-to-many style socket.  The option value is an uint32_t.\n */\nstatic int sctp_getsockopt_assoc_number(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tu32 val = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tval++;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * 8.1.23 SCTP_AUTO_ASCONF\n * See the corresponding setsockopt entry as description\n */\nstatic int sctp_getsockopt_auto_asconf(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->do_auto_asconf && sctp_is_ep_boundall(sk))\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * 8.2.6. Get the Current Identifiers of Associations\n *        (SCTP_GET_ASSOC_ID_LIST)\n *\n * This option gets the current list of SCTP association identifiers of\n * the SCTP associations handled by a one-to-many style socket.\n */\nstatic int sctp_getsockopt_assoc_ids(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_assoc_ids *ids;\n\tu32 num = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(struct sctp_assoc_ids))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tnum++;\n\t}\n\n\tif (len < sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num;\n\n\tids = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (unlikely(!ids))\n\t\treturn -ENOMEM;\n\n\tids->gaids_number_of_ids = num;\n\tnum = 0;\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tids->gaids_assoc_id[num++] = asoc->assoc_id;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, ids, len)) {\n\t\tkfree(ids);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(ids);\n\treturn 0;\n}\n\n/*\n * SCTP_PEER_ADDR_THLDS\n *\n * This option allows us to fetch the partially failed threshold for one or all\n * transports in an association.  See Section 6.1 of:\n * http://www.ietf.org/id/draft-nishida-tsvwg-sctp-failover-05.txt\n */\nstatic int sctp_getsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int len,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_paddrthlds val;\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_paddrthlds))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_paddrthlds);\n\tif (copy_from_user(&val, (struct sctp_paddrthlds __user *)optval, len))\n\t\treturn -EFAULT;\n\n\tif (sctp_is_any(sk, (const union sctp_addr *)&val.spt_address)) {\n\t\tasoc = sctp_id2assoc(sk, val.spt_assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -ENOENT;\n\n\t\tval.spt_pathpfthld = asoc->pf_retrans;\n\t\tval.spt_pathmaxrxt = asoc->pathmaxrxt;\n\t} else {\n\t\ttrans = sctp_addr_id2transport(sk, &val.spt_address,\n\t\t\t\t\t       val.spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tval.spt_pathmaxrxt = trans->pathmaxrxt;\n\t\tval.spt_pathpfthld = trans->pf_retrans;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/*\n * SCTP_GET_ASSOC_STATS\n *\n * This option retrieves local per endpoint statistics. It is modeled\n * after OpenSolaris' implementation\n */\nstatic int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t/* User must provide at least the assoc id */\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\n\t/* Allow the struct to grow and fill in as much as possible */\n\tlen = min_t(size_t, len, sizeof(sas));\n\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t/* New high max rto observed, will return 0 if not a single\n\t * RTO update took place. obs_rto_ipaddr will be bogus\n\t * in such a case\n\t */\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n\t/* Mark beginning of a new observation period */\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tpr_debug(\"%s: len:%d, assoc_id:%d\\n\", __func__, len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvrcvinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvrcvinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvnxtinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvnxtinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_pr_supported(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tparams.assoc_value = asoc->prsctp_enable;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tparams.assoc_value = sp->ep->prsctp_enable;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_default_prinfo(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_default_prinfo info;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(info)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(info);\n\tif (copy_from_user(&info, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, info.pr_assoc_id);\n\tif (asoc) {\n\t\tinfo.pr_policy = SCTP_PR_POLICY(asoc->default_flags);\n\t\tinfo.pr_value = asoc->default_timetolive;\n\t} else if (!info.pr_assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo.pr_policy = SCTP_PR_POLICY(sp->default_flags);\n\t\tinfo.pr_value = sp->default_timetolive;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &info, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_prstatus params;\n\tstruct sctp_association *asoc;\n\tint policy;\n\tint retval = -EINVAL;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc)\n\t\tgoto out;\n\n\tif (policy == SCTP_PR_SCTP_NONE) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tasoc->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tasoc->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tasoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tasoc->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint retval = 0;\n\tint len;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t/* I can hardly begin to describe how wrong this is.  This is\n\t * so broken as to be worse than useless.  The API draft\n\t * REALLY is NOT helpful here...  I am not convinced that the\n\t * semantics of getsockopt() with a level OTHER THAN SOL_SCTP\n\t * are at all well-founded.\n\t */\n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t\tretval = af->getsockopt(sk, level, optname, optval, optlen);\n\t\treturn retval;\n\t}\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_STATUS:\n\t\tretval = sctp_getsockopt_sctp_status(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_getsockopt_disable_fragments(sk, len, optval,\n\t\t\t\t\t\t\t   optlen);\n\t\tbreak;\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_getsockopt_events(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_getsockopt_autoclose(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_PEELOFF:\n\t\tretval = sctp_getsockopt_peeloff(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_getsockopt_peer_addr_params(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_getsockopt_delayed_ack(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_getsockopt_initmsg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDRS:\n\t\tretval = sctp_getsockopt_peer_addrs(sk, len, optval,\n\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_GET_LOCAL_ADDRS:\n\t\tretval = sctp_getsockopt_local_addrs(sk, len, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_CONNECTX3:\n\t\tretval = sctp_getsockopt_connectx3(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_getsockopt_default_send_param(sk, len,\n\t\t\t\t\t\t\t    optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_getsockopt_default_sndinfo(sk, len,\n\t\t\t\t\t\t\t optval, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_getsockopt_primary_addr(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_getsockopt_nodelay(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_getsockopt_rtoinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_getsockopt_associnfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_getsockopt_mappedv4(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_getsockopt_maxseg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDR_INFO:\n\t\tretval = sctp_getsockopt_peer_addr_info(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_getsockopt_adaptation_layer(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_getsockopt_context(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_getsockopt_fragment_interleave(sk, len, optval,\n\t\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_getsockopt_partial_delivery_point(sk, len, optval,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_getsockopt_maxburst(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\tcase SCTP_AUTH_CHUNK:\n\tcase SCTP_AUTH_DELETE_KEY:\n\t\tretval = -EOPNOTSUPP;\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_getsockopt_hmac_ident(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_getsockopt_active_key(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_peer_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_LOCAL_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_local_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_NUMBER:\n\t\tretval = sctp_getsockopt_assoc_number(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_ID_LIST:\n\t\tretval = sctp_getsockopt_assoc_ids(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_getsockopt_auto_asconf(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_getsockopt_paddr_thresholds(sk, optval, len, optlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_STATS:\n\t\tretval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_getsockopt_default_prinfo(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_PR_ASSOC_STATUS:\n\t\tretval = sctp_getsockopt_pr_assocstatus(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn retval;\n}\n\nstatic int sctp_hash(struct sock *sk)\n{\n\t/* STUB */\n\treturn 0;\n}\n\nstatic void sctp_unhash(struct sock *sk)\n{\n\t/* STUB */\n}\n\n/* Check if port is acceptable.  Possibly find first available port.\n *\n * The port hash table (contained in the 'global' SCTP protocol storage\n * returned by struct sctp_protocol *sctp_get_protocol()). The hash\n * table is an array of 4096 lists (sctp_bind_hashbucket). Each\n * list (the list number is the port number hashed out, so as you\n * would expect from a hash function, all the ports in a given list have\n * such a number that hashes out to the same list number; you were\n * expecting that, right?); so each list has a set of ports, with a\n * link to the socket (struct sock) that uses it, the port number and\n * a fastreuse flag (FIXME: NPI ipg).\n */\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *, unsigned short snum);\n\nstatic long sctp_get_port_local(struct sock *sk, union sctp_addr *addr)\n{\n\tstruct sctp_bind_hashbucket *head; /* hash list */\n\tstruct sctp_bind_bucket *pp;\n\tunsigned short snum;\n\tint ret;\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: begins, snum:%d\\n\", __func__, snum);\n\n\tlocal_bh_disable();\n\n\tif (snum == 0) {\n\t\t/* Search for an available port. */\n\t\tint low, high, remaining, index;\n\t\tunsigned int rover;\n\t\tstruct net *net = sock_net(sk);\n\n\t\tinet_get_local_port_range(net, &low, &high);\n\t\tremaining = (high - low) + 1;\n\t\trover = prandom_u32() % remaining + low;\n\n\t\tdo {\n\t\t\trover++;\n\t\t\tif ((rover < low) || (rover > high))\n\t\t\t\trover = low;\n\t\t\tif (inet_is_local_reserved_port(net, rover))\n\t\t\t\tcontinue;\n\t\t\tindex = sctp_phashfn(sock_net(sk), rover);\n\t\t\thead = &sctp_port_hashtable[index];\n\t\t\tspin_lock(&head->lock);\n\t\t\tsctp_for_each_hentry(pp, &head->chain)\n\t\t\t\tif ((pp->port == rover) &&\n\t\t\t\t    net_eq(sock_net(sk), pp->net))\n\t\t\t\t\tgoto next;\n\t\t\tbreak;\n\t\tnext:\n\t\t\tspin_unlock(&head->lock);\n\t\t} while (--remaining > 0);\n\n\t\t/* Exhausted local port range during search? */\n\t\tret = 1;\n\t\tif (remaining <= 0)\n\t\t\tgoto fail;\n\n\t\t/* OK, here is the one we will use.  HEAD (the port\n\t\t * hash table list entry) is non-NULL and we hold it's\n\t\t * mutex.\n\t\t */\n\t\tsnum = rover;\n\t} else {\n\t\t/* We are given an specific port number; we verify\n\t\t * that it is not being used. If it is used, we will\n\t\t * exahust the search in the hash list corresponding\n\t\t * to the port number (snum) - we detect that with the\n\t\t * port iterator, pp being NULL.\n\t\t */\n\t\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(sk), snum)];\n\t\tspin_lock(&head->lock);\n\t\tsctp_for_each_hentry(pp, &head->chain) {\n\t\t\tif ((pp->port == snum) && net_eq(pp->net, sock_net(sk)))\n\t\t\t\tgoto pp_found;\n\t\t}\n\t}\n\tpp = NULL;\n\tgoto pp_not_found;\npp_found:\n\tif (!hlist_empty(&pp->owner)) {\n\t\t/* We had a port hash table hit - there is an\n\t\t * available port (pp != NULL) and it is being\n\t\t * used by other socket (pp->owner not empty); that other\n\t\t * socket is going to be sk2.\n\t\t */\n\t\tint reuse = sk->sk_reuse;\n\t\tstruct sock *sk2;\n\n\t\tpr_debug(\"%s: found a possible match\\n\", __func__);\n\n\t\tif (pp->fastreuse && sk->sk_reuse &&\n\t\t\tsk->sk_state != SCTP_SS_LISTENING)\n\t\t\tgoto success;\n\n\t\t/* Run through the list of sockets bound to the port\n\t\t * (pp->port) [via the pointers bind_next and\n\t\t * bind_pprev in the struct sock *sk2 (pp->sk)]. On each one,\n\t\t * we get the endpoint they describe and run through\n\t\t * the endpoint's list of IP (v4 or v6) addresses,\n\t\t * comparing each of the addresses with the address of\n\t\t * the socket sk. If we find a match, then that means\n\t\t * that this port/socket (sk) combination are already\n\t\t * in an endpoint.\n\t\t */\n\t\tsk_for_each_bound(sk2, &pp->owner) {\n\t\t\tstruct sctp_endpoint *ep2;\n\t\t\tep2 = sctp_sk(sk2)->ep;\n\n\t\t\tif (sk == sk2 ||\n\t\t\t    (reuse && sk2->sk_reuse &&\n\t\t\t     sk2->sk_state != SCTP_SS_LISTENING))\n\t\t\t\tcontinue;\n\n\t\t\tif (sctp_bind_addr_conflict(&ep2->base.bind_addr, addr,\n\t\t\t\t\t\t sctp_sk(sk2), sctp_sk(sk))) {\n\t\t\t\tret = (long)sk2;\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"%s: found a match\\n\", __func__);\n\t}\npp_not_found:\n\t/* If there was a hash table miss, create a new port.  */\n\tret = 1;\n\tif (!pp && !(pp = sctp_bucket_create(head, sock_net(sk), snum)))\n\t\tgoto fail_unlock;\n\n\t/* In either case (hit or miss), make sure fastreuse is 1 only\n\t * if sk->sk_reuse is too (that is, if the caller requested\n\t * SO_REUSEADDR on this socket -sk-).\n\t */\n\tif (hlist_empty(&pp->owner)) {\n\t\tif (sk->sk_reuse && sk->sk_state != SCTP_SS_LISTENING)\n\t\t\tpp->fastreuse = 1;\n\t\telse\n\t\t\tpp->fastreuse = 0;\n\t} else if (pp->fastreuse &&\n\t\t(!sk->sk_reuse || sk->sk_state == SCTP_SS_LISTENING))\n\t\tpp->fastreuse = 0;\n\n\t/* We are set, so fill up all the data in the hash table\n\t * entry, tie the socket list information with the rest of the\n\t * sockets FIXME: Blurry, NPI (ipg).\n\t */\nsuccess:\n\tif (!sctp_sk(sk)->bind_hash) {\n\t\tinet_sk(sk)->inet_num = snum;\n\t\tsk_add_bind_node(sk, &pp->owner);\n\t\tsctp_sk(sk)->bind_hash = pp;\n\t}\n\tret = 0;\n\nfail_unlock:\n\tspin_unlock(&head->lock);\n\nfail:\n\tlocal_bh_enable();\n\treturn ret;\n}\n\n/* Assign a 'snum' port to the socket.  If snum == 0, an ephemeral\n * port is requested.\n */\nstatic int sctp_get_port(struct sock *sk, unsigned short snum)\n{\n\tunion sctp_addr addr;\n\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t/* Set up a dummy address struct from the sk. */\n\taf->from_sk(&addr, sk);\n\taddr.v4.sin_port = htons(snum);\n\n\t/* Note: sk->sk_num gets filled in if ephemeral port request. */\n\treturn !!sctp_get_port_local(sk, &addr);\n}\n\n/*\n *  Move a socket to LISTENING state.\n */\nstatic int sctp_listen_start(struct sock *sk, int backlog)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct crypto_shash *tfm = NULL;\n\tchar alg[32];\n\n\t/* Allocate HMAC for generating cookie. */\n\tif (!sp->hmac && sp->sctp_hmac_alg) {\n\t\tsprintf(alg, \"hmac(%s)\", sp->sctp_hmac_alg);\n\t\ttfm = crypto_alloc_shash(alg, 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tnet_info_ratelimited(\"failed to load transform for %s: %ld\\n\",\n\t\t\t\t\t     sp->sctp_hmac_alg, PTR_ERR(tfm));\n\t\t\treturn -ENOSYS;\n\t\t}\n\t\tsctp_sk(sk)->hmac = tfm;\n\t}\n\n\t/*\n\t * If a bind() or sctp_bindx() is not called prior to a listen()\n\t * call that allows new associations to be accepted, the system\n\t * picks an ephemeral port and will choose an address set equivalent\n\t * to binding with a wildcard address.\n\t *\n\t * This is not currently spelled out in the SCTP sockets\n\t * extensions draft, but follows the practice as seen in TCP\n\t * sockets.\n\t *\n\t */\n\tsk->sk_state = SCTP_SS_LISTENING;\n\tif (!ep->base.bind_addr.port) {\n\t\tif (sctp_autobind(sk))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (sctp_get_port(sk, inet_sk(sk)->inet_num)) {\n\t\t\tsk->sk_state = SCTP_SS_CLOSED;\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsctp_hash_endpoint(ep);\n\treturn 0;\n}\n\n/*\n * 4.1.3 / 5.1.3 listen()\n *\n *   By default, new associations are not accepted for UDP style sockets.\n *   An application uses listen() to mark a socket as being able to\n *   accept new associations.\n *\n *   On TCP style sockets, applications use listen() to ready the SCTP\n *   endpoint for accepting inbound associations.\n *\n *   On both types of endpoints a backlog of '0' disables listening.\n *\n *  Move a socket to LISTENING state.\n */\nint sctp_inet_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tint err = -EINVAL;\n\n\tif (unlikely(backlog < 0))\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\t/* Peeled-off sockets are not allowed to listen().  */\n\tif (sctp_style(sk, UDP_HIGH_BANDWIDTH))\n\t\tgoto out;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\tgoto out;\n\n\t/* If backlog is zero, disable listening. */\n\tif (!backlog) {\n\t\tif (sctp_sstate(sk, CLOSED))\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tsctp_unhash_endpoint(ep);\n\t\tsk->sk_state = SCTP_SS_CLOSED;\n\t\tif (sk->sk_reuse)\n\t\t\tsctp_sk(sk)->bind_hash->fastreuse = 1;\n\t\tgoto out;\n\t}\n\n\t/* If we are already listening, just update the backlog */\n\tif (sctp_sstate(sk, LISTENING))\n\t\tsk->sk_max_ack_backlog = backlog;\n\telse {\n\t\terr = sctp_listen_start(sk, backlog);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/*\n * This function is done by modeling the current datagram_poll() and the\n * tcp_poll().  Note that, based on these implementations, we don't\n * lock the socket in this function, even though it seems that,\n * ideally, locking or some other mechanisms can be used to ensure\n * the integrity of the counters (sndbuf and wmem_alloc) used\n * in this place.  We assume that we don't need locks either until proven\n * otherwise.\n *\n * Another thing to note is that we include the Async I/O support\n * here, again, by modeling the current TCP/UDP code.  We don't have\n * a good way to test with it yet.\n */\nunsigned int sctp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tunsigned int mask;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tsock_rps_record_flow(sk);\n\n\t/* A TCP-style listening socket becomes readable when the accept queue\n\t * is not empty.\n\t */\n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\treturn (!list_empty(&sp->ep->asocs)) ?\n\t\t\t(POLLIN | POLLRDNORM) : 0;\n\n\tmask = 0;\n\n\t/* Is there any exceptional events?  */\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\n\t/* Is it readable?  Reconsider this code with TCP-style support.  */\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t/* The association is either gone or not ready.  */\n\tif (!sctp_style(sk, UDP) && sctp_sstate(sk, CLOSED))\n\t\treturn mask;\n\n\t/* Is it writable?  */\n\tif (sctp_writeable(sk)) {\n\t\tmask |= POLLOUT | POLLWRNORM;\n\t} else {\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\t/*\n\t\t * Since the socket is not locked, the buffer\n\t\t * might be made available after the writeable check and\n\t\t * before the bit is set.  This could cause a lost I/O\n\t\t * signal.  tcp_poll() has a race breaker for this race\n\t\t * condition.  Based on their implementation, we put\n\t\t * in the following code to cover it as well.\n\t\t */\n\t\tif (sctp_writeable(sk))\n\t\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\treturn mask;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *net, unsigned short snum)\n{\n\tstruct sctp_bind_bucket *pp;\n\n\tpp = kmem_cache_alloc(sctp_bucket_cachep, GFP_ATOMIC);\n\tif (pp) {\n\t\tSCTP_DBG_OBJCNT_INC(bind_bucket);\n\t\tpp->port = snum;\n\t\tpp->fastreuse = 0;\n\t\tINIT_HLIST_HEAD(&pp->owner);\n\t\tpp->net = net;\n\t\thlist_add_head(&pp->node, &head->chain);\n\t}\n\treturn pp;\n}\n\n/* Caller must hold hashbucket lock for this tb with local BH disabled */\nstatic void sctp_bucket_destroy(struct sctp_bind_bucket *pp)\n{\n\tif (pp && hlist_empty(&pp->owner)) {\n\t\t__hlist_del(&pp->node);\n\t\tkmem_cache_free(sctp_bucket_cachep, pp);\n\t\tSCTP_DBG_OBJCNT_DEC(bind_bucket);\n\t}\n}\n\n/* Release this socket's reference to a local port.  */\nstatic inline void __sctp_put_port(struct sock *sk)\n{\n\tstruct sctp_bind_hashbucket *head =\n\t\t&sctp_port_hashtable[sctp_phashfn(sock_net(sk),\n\t\t\t\t\t\t  inet_sk(sk)->inet_num)];\n\tstruct sctp_bind_bucket *pp;\n\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(sk)->bind_hash;\n\t__sk_del_bind_node(sk);\n\tsctp_sk(sk)->bind_hash = NULL;\n\tinet_sk(sk)->inet_num = 0;\n\tsctp_bucket_destroy(pp);\n\tspin_unlock(&head->lock);\n}\n\nvoid sctp_put_port(struct sock *sk)\n{\n\tlocal_bh_disable();\n\t__sctp_put_port(sk);\n\tlocal_bh_enable();\n}\n\n/*\n * The system picks an ephemeral port and choose an address set equivalent\n * to binding with a wildcard address.\n * One of those addresses will be the primary address for the association.\n * This automatically enables the multihoming capability of SCTP.\n */\nstatic int sctp_autobind(struct sock *sk)\n{\n\tunion sctp_addr autoaddr;\n\tstruct sctp_af *af;\n\t__be16 port;\n\n\t/* Initialize a local sockaddr structure to INADDR_ANY. */\n\taf = sctp_sk(sk)->pf->af;\n\n\tport = htons(inet_sk(sk)->inet_num);\n\taf->inaddr_any(&autoaddr, port);\n\n\treturn sctp_do_bind(sk, &autoaddr, af->sockaddr_len);\n}\n\n/* Parse out IPPROTO_SCTP CMSG headers.  Perform only minimal validation.\n *\n * From RFC 2292\n * 4.2 The cmsghdr Structure *\n *\n * When ancillary data is sent or received, any number of ancillary data\n * objects can be specified by the msg_control and msg_controllen members of\n * the msghdr structure, because each object is preceded by\n * a cmsghdr structure defining the object's length (the cmsg_len member).\n * Historically Berkeley-derived implementations have passed only one object\n * at a time, but this API allows multiple objects to be\n * passed in a single call to sendmsg() or recvmsg(). The following example\n * shows two ancillary data objects in a control buffer.\n *\n *   |<--------------------------- msg_controllen -------------------------->|\n *   |                                                                       |\n *\n *   |<----- ancillary data object ----->|<----- ancillary data object ----->|\n *\n *   |<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|\n *   |                                   |                                   |\n *\n *   |<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |\n *\n *   |<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |\n *   |                                |  |                                |  |\n *\n *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n *   |cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|\n *\n *   |len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|\n *\n *   +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n *    ^\n *    |\n *\n * msg_control\n * points here\n */\nstatic int sctp_msghdr_parse(const struct msghdr *msg, sctp_cmsgs_t *cmsgs)\n{\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr *my_msg = (struct msghdr *)msg;\n\n\tfor_each_cmsghdr(cmsg, my_msg) {\n\t\tif (!CMSG_OK(my_msg, cmsg))\n\t\t\treturn -EINVAL;\n\n\t\t/* Should we parse this header or ignore?  */\n\t\tif (cmsg->cmsg_level != IPPROTO_SCTP)\n\t\t\tcontinue;\n\n\t\t/* Strictly check lengths following example in SCM code.  */\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase SCTP_INIT:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.1 SCTP Initiation Structure (SCTP_INIT)\n\t\t\t *\n\t\t\t * This cmsghdr structure provides information for\n\t\t\t * initializing new SCTP associations with sendmsg().\n\t\t\t * The SCTP_INITMSG socket option uses this same data\n\t\t\t * structure.  This structure is not used for\n\t\t\t * recvmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ----------------------\n\t\t\t * IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_initmsg)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->init = CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDRCV:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.2 SCTP Header Information Structure(SCTP_SNDRCV)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for\n\t\t\t * sendmsg() and describes SCTP header information\n\t\t\t * about a received message through recvmsg().\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ----------------------\n\t\t\t * IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndrcvinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->srinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->srinfo->sinfo_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_PR_SCTP_MASK |\n\t\t\t      SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDINFO:\n\t\t\t/* SCTP Socket API Extension\n\t\t\t * 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)\n\t\t\t *\n\t\t\t * This cmsghdr structure specifies SCTP options for\n\t\t\t * sendmsg(). This structure and SCTP_RCVINFO replaces\n\t\t\t * SCTP_SNDRCV which has been deprecated.\n\t\t\t *\n\t\t\t * cmsg_level    cmsg_type      cmsg_data[]\n\t\t\t * ------------  ------------   ---------------------\n\t\t\t * IPPROTO_SCTP  SCTP_SNDINFO    struct sctp_sndinfo\n\t\t\t */\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->sinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->sinfo->snd_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_PR_SCTP_MASK |\n\t\t\t      SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Wait for a packet..\n * Note: This function is the same function as in core/datagram.c\n * with a few modifications to make lksctp work.\n */\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p)\n{\n\tint error;\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t/* Socket errors? */\n\terror = sock_error(sk);\n\tif (error)\n\t\tgoto out;\n\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tgoto ready;\n\n\t/* Socket shut down?  */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out;\n\n\t/* Sequenced packets can come disconnected.  If so we report the\n\t * problem.\n\t */\n\terror = -ENOTCONN;\n\n\t/* Is there a good reason to think that we may receive some data?  */\n\tif (list_empty(&sctp_sk(sk)->ep->asocs) && !sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\t/* Handle signals.  */\n\tif (signal_pending(current))\n\t\tgoto interrupted;\n\n\t/* Let another process have a go.  Since we are going to sleep\n\t * anyway.  Note: This may cause odd behaviors if the message\n\t * does not fit in the user's buffer, but this seems to be the\n\t * only way to honor MSG_DONTWAIT realistically.\n\t */\n\trelease_sock(sk);\n\t*timeo_p = schedule_timeout(*timeo_p);\n\tlock_sock(sk);\n\nready:\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn 0;\n\ninterrupted:\n\terror = sock_intr_errno(*timeo_p);\n\nout:\n\tfinish_wait(sk_sleep(sk), &wait);\n\t*err = error;\n\treturn error;\n}\n\n/* Receive a datagram.\n * Note: This is pretty much the same routine as in core/datagram.c\n * with a few changes to make lksctp work.\n */\nstruct sk_buff *sctp_skb_recv_datagram(struct sock *sk, int flags,\n\t\t\t\t       int noblock, int *err)\n{\n\tint error;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\n\ttimeo = sock_rcvtimeo(sk, noblock);\n\n\tpr_debug(\"%s: timeo:%ld, max:%ld\\n\", __func__, timeo,\n\t\t MAX_SCHEDULE_TIMEOUT);\n\n\tdo {\n\t\t/* Again only user level code calls this function,\n\t\t * so nothing interrupt level\n\t\t * will suddenly eat the receive_queue.\n\t\t *\n\t\t *  Look at current nfs client by the way...\n\t\t *  However, this function was correct in any case. 8)\n\t\t */\n\t\tif (flags & MSG_PEEK) {\n\t\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\t\tif (skb)\n\t\t\t\tatomic_inc(&skb->users);\n\t\t} else {\n\t\t\tskb = __skb_dequeue(&sk->sk_receive_queue);\n\t\t}\n\n\t\tif (skb)\n\t\t\treturn skb;\n\n\t\t/* Caller is allowed not to check sk->sk_err before calling. */\n\t\terror = sock_error(sk);\n\t\tif (error)\n\t\t\tgoto no_packet;\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\n\t\tif (sk_can_busy_loop(sk) &&\n\t\t    sk_busy_loop(sk, noblock))\n\t\t\tcontinue;\n\n\t\t/* User doesn't want to wait.  */\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (sctp_wait_for_packet(sk, err, &timeo) == 0);\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}\n\n/* If sndbuf has changed, wake up per association sndbuf waiters.  */\nstatic void __sctp_write_space(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (sctp_wspace(asoc) <= 0)\n\t\treturn;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\twake_up_interruptible(&asoc->wait);\n\n\tif (sctp_writeable(sk)) {\n\t\tstruct socket_wq *wq;\n\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq) {\n\t\t\tif (waitqueue_active(&wq->wait))\n\t\t\t\twake_up_interruptible(&wq->wait);\n\n\t\t\t/* Note that we try to include the Async I/O support\n\t\t\t * here by modeling from the current TCP/UDP code.\n\t\t\t * We have not tested with it yet.\n\t\t\t */\n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void sctp_wake_up_waiters(struct sock *sk,\n\t\t\t\t struct sctp_association *asoc)\n{\n\tstruct sctp_association *tmp = asoc;\n\n\t/* We do accounting for the sndbuf space per association,\n\t * so we only need to wake our own association.\n\t */\n\tif (asoc->ep->sndbuf_policy)\n\t\treturn __sctp_write_space(asoc);\n\n\t/* If association goes down and is just flushing its\n\t * outq, then just normally notify others.\n\t */\n\tif (asoc->base.dead)\n\t\treturn sctp_write_space(sk);\n\n\t/* Accounting for the sndbuf space is per socket, so we\n\t * need to wake up others, try to be fair and in case of\n\t * other associations, let them have a go first instead\n\t * of just doing a sctp_write_space() call.\n\t *\n\t * Note that we reach sctp_wake_up_waiters() only when\n\t * associations free up queued chunks, thus we are under\n\t * lock and the list of associations on a socket is\n\t * guaranteed not to change.\n\t */\n\tfor (tmp = list_next_entry(tmp, asocs); 1;\n\t     tmp = list_next_entry(tmp, asocs)) {\n\t\t/* Manually skip the head element. */\n\t\tif (&tmp->asocs == &((sctp_sk(sk))->ep->asocs))\n\t\t\tcontinue;\n\t\t/* Wake up association. */\n\t\t__sctp_write_space(tmp);\n\t\t/* We've reached the end. */\n\t\tif (tmp == asoc)\n\t\t\tbreak;\n\t}\n}\n\n/* Do accounting for the sndbuf space.\n * Decrement the used sndbuf space of the corresponding association by the\n * data size which was just transmitted(freed).\n */\nstatic void sctp_wfree(struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = skb_shinfo(skb)->destructor_arg;\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\tasoc->sndbuf_used -= SCTP_DATA_SNDSIZE(chunk) +\n\t\t\t\tsizeof(struct sk_buff) +\n\t\t\t\tsizeof(struct sctp_chunk);\n\n\tatomic_sub(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\n\t/*\n\t * This undoes what is done via sctp_set_owner_w and sk_mem_charge\n\t */\n\tsk->sk_wmem_queued   -= skb->truesize;\n\tsk_mem_uncharge(sk, skb->truesize);\n\n\tsock_wfree(skb);\n\tsctp_wake_up_waiters(sk, asoc);\n\n\tsctp_association_put(asoc);\n}\n\n/* Do accounting for the receive space on the socket.\n * Accounting for the association is done in ulpevent.c\n * We set this as a destructor for the cloned data skbs so that\n * accounting is done at the correct time.\n */\nvoid sctp_sock_rfree(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tatomic_sub(event->rmem_len, &sk->sk_rmem_alloc);\n\n\t/*\n\t * Mimic the behavior of sock_rfree\n\t */\n\tsk_mem_uncharge(sk, event->rmem_len);\n}\n\n\n/* Helper function to wait for space in the sndbuf.  */\nstatic int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tif (sk != asoc->base.sk)\n\t\t\tgoto do_error;\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n\nvoid sctp_data_ready(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\tPOLLRDNORM | POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\n/* If socket sndbuf has changed, wake up all per association waiters.  */\nvoid sctp_write_space(struct sock *sk)\n{\n\tstruct sctp_association *asoc;\n\n\t/* Wake up the tasks in each wait queue.  */\n\tlist_for_each_entry(asoc, &((sctp_sk(sk))->ep->asocs), asocs) {\n\t\t__sctp_write_space(asoc);\n\t}\n}\n\n/* Is there any sndbuf space available on the socket?\n *\n * Note that sk_wmem_alloc is the sum of the send buffers on all of the\n * associations on the same socket.  For a UDP-style socket with\n * multiple associations, it is possible for it to be \"unwriteable\"\n * prematurely.  I assume that this is acceptable because\n * a premature \"unwriteable\" is better than an accidental \"writeable\" which\n * would cause an unwanted block under certain circumstances.  For the 1-1\n * UDP-style sockets or TCP-style sockets, this code should work.\n *  - Daisy\n */\nstatic int sctp_writeable(struct sock *sk)\n{\n\tint amt = 0;\n\n\tamt = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\tif (amt < 0)\n\t\tamt = 0;\n\treturn amt;\n}\n\n/* Wait for an association to go into ESTABLISHED state. If timeout is 0,\n * returns immediately with EINPROGRESS.\n */\nstatic int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld\\n\", __func__, asoc, *timeo_p);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\n\t\tif (sctp_state(asoc, ESTABLISHED))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\tif (asoc->init_err_counter + 1 > asoc->max_init_attempts)\n\t\terr = -ETIMEDOUT;\n\telse\n\t\terr = -ECONNREFUSED;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EINPROGRESS;\n\tgoto out;\n}\n\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo)\n{\n\tstruct sctp_endpoint *ep;\n\tint err = 0;\n\tDEFINE_WAIT(wait);\n\n\tep = sctp_sk(sk)->ep;\n\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(sk_sleep(sk), &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\n\t\tif (list_empty(&ep->asocs)) {\n\t\t\trelease_sock(sk);\n\t\t\ttimeo = schedule_timeout(timeo);\n\t\t\tlock_sock(sk);\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (!sctp_sstate(sk, LISTENING))\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tif (!list_empty(&ep->asocs))\n\t\t\tbreak;\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t}\n\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void sctp_wait_for_close(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\t} while (!signal_pending(current) && timeout);\n\n\tfinish_wait(sk_sleep(sk), &wait);\n}\n\nstatic void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t/* Don't forget the fragments. */\n\tskb_walk_frags(skb, frag)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}\n\nvoid sctp_copy_sock(struct sock *newsk, struct sock *sk,\n\t\t    struct sctp_association *asoc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_sock *newinet;\n\n\tnewsk->sk_type = sk->sk_type;\n\tnewsk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tnewsk->sk_flags = sk->sk_flags;\n\tnewsk->sk_tsflags = sk->sk_tsflags;\n\tnewsk->sk_no_check_tx = sk->sk_no_check_tx;\n\tnewsk->sk_no_check_rx = sk->sk_no_check_rx;\n\tnewsk->sk_reuse = sk->sk_reuse;\n\n\tnewsk->sk_shutdown = sk->sk_shutdown;\n\tnewsk->sk_destruct = sctp_destruct_sock;\n\tnewsk->sk_family = sk->sk_family;\n\tnewsk->sk_protocol = IPPROTO_SCTP;\n\tnewsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\tnewsk->sk_sndbuf = sk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = sk->sk_rcvbuf;\n\tnewsk->sk_lingertime = sk->sk_lingertime;\n\tnewsk->sk_rcvtimeo = sk->sk_rcvtimeo;\n\tnewsk->sk_sndtimeo = sk->sk_sndtimeo;\n\tnewsk->sk_rxhash = sk->sk_rxhash;\n\n\tnewinet = inet_sk(newsk);\n\n\t/* Initialize sk's sport, dport, rcv_saddr and daddr for\n\t * getsockname() and getpeername()\n\t */\n\tnewinet->inet_sport = inet->inet_sport;\n\tnewinet->inet_saddr = inet->inet_saddr;\n\tnewinet->inet_rcv_saddr = inet->inet_rcv_saddr;\n\tnewinet->inet_dport = htons(asoc->peer.port);\n\tnewinet->pmtudisc = inet->pmtudisc;\n\tnewinet->inet_id = asoc->next_tsn ^ jiffies;\n\n\tnewinet->uc_ttl = inet->uc_ttl;\n\tnewinet->mc_loop = 1;\n\tnewinet->mc_ttl = 1;\n\tnewinet->mc_index = 0;\n\tnewinet->mc_list = NULL;\n\n\tif (newsk->sk_flags & SK_FLAGS_TIMESTAMP)\n\t\tnet_enable_timestamp();\n\n\tsecurity_sk_clone(sk, newsk);\n}\n\nstatic inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock) +\n\t\t\t    sizeof(struct sctp_sock) -\n\t\t\t    offsetof(struct sctp_sock, auto_asconf_list);\n\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}\n\n/* Populate the fields of the newsk from the oldsk and migrate the assoc\n * and its messages to the newsk.\n */\nstatic void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tsctp_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tspin_lock_bh(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock_bh(&head->lock);\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP)) {\n\t\tnewsk->sk_state = SCTP_SS_CLOSED;\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\t} else {\n\t\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\t}\n\n\trelease_sock(newsk);\n}\n\n\n/* This proto struct describes the ULP interface for SCTP.  */\nstruct proto sctp_prot = {\n\t.name        =\t\"SCTP\",\n\t.owner       =\tTHIS_MODULE,\n\t.close       =\tsctp_close,\n\t.connect     =\tsctp_connect,\n\t.disconnect  =\tsctp_disconnect,\n\t.accept      =\tsctp_accept,\n\t.ioctl       =\tsctp_ioctl,\n\t.init        =\tsctp_init_sock,\n\t.destroy     =\tsctp_destroy_sock,\n\t.shutdown    =\tsctp_shutdown,\n\t.setsockopt  =\tsctp_setsockopt,\n\t.getsockopt  =\tsctp_getsockopt,\n\t.sendmsg     =\tsctp_sendmsg,\n\t.recvmsg     =\tsctp_recvmsg,\n\t.bind        =\tsctp_bind,\n\t.backlog_rcv =\tsctp_backlog_rcv,\n\t.hash        =\tsctp_hash,\n\t.unhash      =\tsctp_unhash,\n\t.get_port    =\tsctp_get_port,\n\t.obj_size    =  sizeof(struct sctp_sock),\n\t.sysctl_mem  =  sysctl_sctp_mem,\n\t.sysctl_rmem =  sysctl_sctp_rmem,\n\t.sysctl_wmem =  sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\t.memory_allocated = &sctp_memory_allocated,\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n#include <net/transp_v6.h>\nstatic void sctp_v6_destroy_sock(struct sock *sk)\n{\n\tsctp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstruct proto sctpv6_prot = {\n\t.name\t\t= \"SCTPv6\",\n\t.owner\t\t= THIS_MODULE,\n\t.close\t\t= sctp_close,\n\t.connect\t= sctp_connect,\n\t.disconnect\t= sctp_disconnect,\n\t.accept\t\t= sctp_accept,\n\t.ioctl\t\t= sctp_ioctl,\n\t.init\t\t= sctp_init_sock,\n\t.destroy\t= sctp_v6_destroy_sock,\n\t.shutdown\t= sctp_shutdown,\n\t.setsockopt\t= sctp_setsockopt,\n\t.getsockopt\t= sctp_getsockopt,\n\t.sendmsg\t= sctp_sendmsg,\n\t.recvmsg\t= sctp_recvmsg,\n\t.bind\t\t= sctp_bind,\n\t.backlog_rcv\t= sctp_backlog_rcv,\n\t.hash\t\t= sctp_hash,\n\t.unhash\t\t= sctp_unhash,\n\t.get_port\t= sctp_get_port,\n\t.obj_size\t= sizeof(struct sctp6_sock),\n\t.sysctl_mem\t= sysctl_sctp_mem,\n\t.sysctl_rmem\t= sysctl_sctp_rmem,\n\t.sysctl_wmem\t= sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\t.memory_allocated = &sctp_memory_allocated,\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n"], "filenames": ["net/sctp/socket.c"], "buggy_code_start_loc": [7429], "buggy_code_end_loc": [7430], "fixing_code_start_loc": [7429], "fixing_code_end_loc": [7431], "type": "CWE-362", "message": "Race condition in the sctp_wait_for_sndbuf function in net/sctp/socket.c in the Linux kernel before 4.9.11 allows local users to cause a denial of service (assertion failure and panic) via a multithreaded application that peels off an association in a certain buffer-full state.", "other": {"cve": {"id": "CVE-2017-5986", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-18T21:59:00.130", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the sctp_wait_for_sndbuf function in net/sctp/socket.c in the Linux kernel before 4.9.11 allows local users to cause a denial of service (assertion failure and panic) via a multithreaded application that peels off an association in a certain buffer-full state."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n sctp_wait_for_sndbuf en net/sctp/socket.c en el kernel de Linux en versiones anteriores a 4.9.11 permite a usuarios locales provocar una denegaci\u00f3n de servicio (fallo de aserci\u00f3n y p\u00e1nico) a trav\u00e9s de una aplicaci\u00f3n multihilo que despega una asociaci\u00f3n en un cierto estado de b\u00fafer completo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.11", "matchCriteriaId": "A2C8FBA2-BF83-4E8F-AA66-F34C0F33E703"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2dcab598484185dea7ec22219c76dcdd59e3cb90", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3804", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/14/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96222", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1308", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1420276", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/2dcab598484185dea7ec22219c76dcdd59e3cb90", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2dcab598484185dea7ec22219c76dcdd59e3cb90"}}