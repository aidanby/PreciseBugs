{"buggy_code": ["var _ = require('underscore');\n\nmodule.exports = diff;\nfunction diff(old, new_) {\n  var changes = [];\n\n  changes = changes.concat(compare([], old, new_));\n\n  comparing = [];\n  return changes;\n}\n\nfunction delCheck(op) {\n  if (op.type === 'put' && op.value === undefined) {\n    op.type = 'del';\n    delete op.value;\n  }\n  return op;\n}\n\nvar comparing = [];\nfunction compare(path, old, new_) {\n  var changes = [];\n  if (old !== null && new_ !== null &&\n      typeof old === 'object' &&\n      !_.contains(comparing, old)) {\n\n    comparing.push(old);\n    var oldKeys = Object.keys(old);\n    var newKeys = Object.keys(new_);\n\n    var sameKeys = _.intersection(oldKeys, newKeys);\n    sameKeys.forEach(function (k) {\n      var childChanges = compare(path.concat(k), old[k], new_[k]);\n      changes = changes.concat(childChanges);\n    });\n\n    var delKeys = _.difference(oldKeys, newKeys);\n    delKeys.forEach(function (k) {\n      changes.push({ type: 'del', key: path.concat(k) });\n    });\n\n    var newKeys_ = _.difference(newKeys, oldKeys);\n    newKeys_.forEach(function (k) {\n      changes.push(delCheck(\n        { type: 'put', key: path.concat(k), value: new_[k] }));\n    });\n\n  } else if (old !== new_) {\n    changes.push(delCheck({ type: 'put', key: path, value: new_ }));\n  }\n\n  return changes;\n}\n\nmodule.exports.apply = apply;\nfunction apply(changes, target, modify) {\n  var obj, clone;\n  if (modify) {\n    obj = target;\n  } else {\n    clone = require('udc');\n    obj = clone(target);\n  }\n  changes.forEach(function (ch) {\n    var ptr, keys, len;\n    switch (ch.type) {\n      case 'put':\n        ptr = obj;\n        keys = ch.key;\n        len = keys.length;\n        if (len) {\n          keys.forEach(function (prop, i) {\n            if (!(prop in ptr)) {\n              ptr[prop] = {};\n            }\n\n            if (i < len - 1) {\n              ptr = ptr[prop];\n            } else {\n              ptr[prop] = ch.value;\n            }\n          });\n        } else {\n          obj = ch.value;\n        }\n        break;\n\n      case 'del':\n        ptr = obj;\n        keys = ch.key;\n        len = keys.length;\n        if (len) {\n          keys.forEach(function (prop, i) {\n            if (!(prop in ptr)) {\n              ptr[prop] = {};\n            }\n\n            if (i < len - 1) {\n              ptr = ptr[prop];\n            } else {\n              if (Array.isArray(ptr)) {\n                ptr.splice(parseInt(prop, 10), 1);\n              } else {\n                delete ptr[prop];\n              }\n            }\n          });\n        } else {\n          obj = null;\n        }\n        break;\n    }\n  });\n  return obj;\n}\n", "var expect = require('chai').expect\n  , diff = require('..');\n\ndescribe('changeset', function () {\n  beforeEach(function (done) {\n    done();\n  });\n\n  it('should be able to diff two objects and return a changeset',\n    function (done) {\n      var a = {\n        name: 'Eugene',\n        number: 42,\n        tags: ['tag1', 'tag2', 'tag3'],\n        scores: {\n          tetris: 1000,\n          carmageddon: 3,\n          someArray: ['one', 'two', 'three']\n        }\n      };\n\n      a.self = a;\n      a.scoresAgain = a.scores;\n\n      var b = {\n        name: 'Susan',\n        number: 43,\n        tags: ['tag1', 'tag4'],\n        scores: {\n          carmageddon: 3,\n          zelda: 3000,\n          someArray: ['one', 'three']\n        },\n        age: 37\n      };\n\n      b.friend = a;\n      b.self = b;\n\n      var changes = diff(a, b);\n\n      expect(changes).to.deep.equal([\n        { type: 'put', key: ['name'], value: 'Susan' },\n        { type: 'put', key: ['number'], value: 43 },\n        { type: 'put', key: ['tags', '1'], value: 'tag4' },\n        { type: 'del', key: ['tags', '2'] },\n        { type: 'put', key: [ 'scores', 'someArray', '1' ], value: 'three' },\n        { type: 'del', key: [ 'scores', 'someArray', '2' ] },\n        { type: 'del', key: ['scores', 'tetris'] },\n        { type: 'put', key: ['scores', 'zelda'], value: 3000 },\n        { type: 'put', key: ['self'], value: b },\n        { type: 'del', key: ['scoresAgain'], },\n        { type: 'put', key: ['age'], value: 37 },\n        { type: 'put', key: ['friend'], value: a }\n      ]);\n\n      done();\n    });\n\n  it('should be able to handle basic types', function (done) {\n    var a = 'Eugene';\n    var b = 'Susan';\n\n    var changes = diff(a, b);\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: 'Susan' }\n    ]);\n\n    done();\n  });\n\n  it('should be able to handle nulls', function (done) {\n    var changes;\n\n    changes = diff(null, 'Susan');\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: 'Susan' }\n    ]);\n\n    changes = diff('Eugene', null);\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: null }\n    ]);\n\n    done();\n  });\n\n  it('should be able to handle undefined', function (done) {\n    var changes;\n\n    changes = diff(undefined, 'Susan');\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: 'Susan' }\n    ]);\n\n    changes = diff('Eugene', undefined);\n    expect(changes).to.deep.equal([\n      { type: 'del', key: [] }\n    ]);\n\n    done();\n  });\n\n  it('should be able to apply a changeset to an object', function (done) {\n    var a = {\n      name: 'Eugene',\n      number: 42,\n      tags: ['tag1', 'tag2', 'tag3'],\n      scores: {\n        tetris: 1000,\n        carmageddon: 3,\n        someArray: ['one', 'two', 'three']\n      }\n    };\n\n    a.self = a;\n    a.scoresAgain = a.scores;\n\n    var b = {\n      name: 'Susan',\n      number: 43,\n      tags: ['tag1', 'tag4'],\n      scores: {\n        carmageddon: 3,\n        zelda: 3000,\n        someArray: ['one', 'three']\n      },\n      age: 37\n    };\n\n    b.friend = a;\n    b.self = b;\n\n    var clone = require(\"udc\");\n    var bClone = clone(b);\n\n    var changes = diff(a, b);\n    var b_ = diff.apply(changes, a);\n    expect(b_.scores.someArray.length).to.equal(b.scores.someArray.length);\n    expect(b_).to.deep.equals(b);\n    expect(b).to.deep.equals(bClone); // Target did not change.\n    done();\n  });\n\n  it('should be able to apply a changeset to a value', function (done) {\n    var a = 'Eugene';\n    var b = 'Susan';\n\n    var changes = diff(a, b);\n    var b_ = diff.apply(changes, a);\n    expect(b_).to.deep.equals(b);\n    done();\n  });\n\n  it('should be able to apply a changeset with nulls', function (done) {\n    var changes, b_;\n\n    changes = diff(null, 'Susan');\n     b_ = diff.apply(changes, null);\n    expect(b_).to.deep.equals('Susan');\n\n    changes = diff('Eugene', null);\n     b_ = diff.apply(changes, 'Eugene');\n    expect(b_).to.deep.equals(null);\n\n    done();\n  });\n\n  it('should be able to apply a changeset with undefined', function (done) {\n    var changes, b_;\n\n    changes = diff(undefined, 'Susan');\n     b_ = diff.apply(changes, undefined);\n    expect(b_).to.deep.equals('Susan');\n\n    changes = diff('Eugene', undefined);\n     b_ = diff.apply(changes, 'Eugene');\n    expect(b_).to.deep.equals(null);\n\n    done();\n  });\n\n  it('should be able to apply a changeset to an object and modify it',\n      function (done) {\n        var a = {\n          name: 'Eugene',\n          number: 42,\n          tags: ['tag1', 'tag2', 'tag3'],\n          scores: {\n            tetris: 1000,\n            carmageddon: 3,\n            someArray: ['one', 'two', 'three']\n          }\n        };\n\n        a.self = a;\n        a.scoresAgain = a.scores;\n\n        var b = {\n          name: 'Susan',\n          number: 43,\n          tags: ['tag1', 'tag4'],\n          scores: {\n            carmageddon: 3,\n            zelda: 3000,\n            someArray: ['one', 'three']\n          },\n          age: 37\n        };\n\n        b.friend = a;\n        b.self = b;\n\n        var changes = diff(a, b);\n        var b_ = diff.apply(changes, a, true);\n        expect(b_.scores.someArray.length).to.equal(b.scores.someArray.length);\n        expect(b_).to.deep.equals(b);\n        expect(b_).to.equal(a);\n        done();\n    });\n\n  it('should be able to self-modify and replace an entire object',\n    function(done) {\n      var data = { name: 'Eugene', number: 43 };\n      var change = [ { type: 'put', key: [], value: 'xxx' } ];\n      var obj = diff.apply(change, data, true);\n      expect(obj).to.equal('xxx');\n      done();\n    });\n\n  it('should be able to deal with incrementally built arrays', function(done) {\n    var obj = [];\n    var changeset = [\n      { type: 'put', key: [], value: [] },\n      { type: 'put', key: [ 0, 'make' ], value: 'Toyota' },\n      { type: 'put', key: [ 0, 'model' ], value: 'Camry' },\n      { type: 'put', key: [ 1, 'make' ], value: 'Toyota' },\n      { type: 'put', key: [ 1, 'model' ], value: 'Corolla' } ];\n    obj = diff.apply(changeset, obj, true);\n    expect(obj).to.deep.equals([\n      { make: 'Toyota', model: 'Camry' },\n      { make: 'Toyota', model: 'Corolla' }\n    ]);\n    done();\n  });\n});\n"], "fixing_code": ["var _ = require('underscore');\n\nmodule.exports = diff;\nfunction diff(old, new_) {\n  var changes = [];\n\n  changes = changes.concat(compare([], old, new_));\n\n  comparing = [];\n  return changes;\n}\n\nfunction delCheck(op) {\n  if (op.type === 'put' && op.value === undefined) {\n    op.type = 'del';\n    delete op.value;\n  }\n  return op;\n}\n\nvar comparing = [];\nfunction compare(path, old, new_) {\n  var changes = [];\n  if (old !== null && new_ !== null &&\n      typeof old === 'object' &&\n      !_.contains(comparing, old)) {\n\n    comparing.push(old);\n    var oldKeys = Object.keys(old);\n    var newKeys = Object.keys(new_);\n\n    var sameKeys = _.intersection(oldKeys, newKeys);\n    sameKeys.forEach(function (k) {\n      var childChanges = compare(path.concat(k), old[k], new_[k]);\n      changes = changes.concat(childChanges);\n    });\n\n    var delKeys = _.difference(oldKeys, newKeys);\n    delKeys.forEach(function (k) {\n      changes.push({ type: 'del', key: path.concat(k) });\n    });\n\n    var newKeys_ = _.difference(newKeys, oldKeys);\n    newKeys_.forEach(function (k) {\n      changes.push(delCheck(\n        { type: 'put', key: path.concat(k), value: new_[k] }));\n    });\n\n  } else if (old !== new_) {\n    changes.push(delCheck({ type: 'put', key: path, value: new_ }));\n  }\n\n  return changes;\n}\n\nmodule.exports.apply = apply;\nfunction apply(changes, target, modify) {\n  var obj, clone;\n  if (modify) {\n    obj = target;\n  } else {\n    clone = require('udc');\n    obj = clone(target);\n  }\n  changes.forEach(function (ch) {\n    var ptr, keys, len;\n    switch (ch.type) {\n      case 'put':\n        ptr = obj;\n        keys = ch.key;\n        len = keys.length;\n        if (len) {\n          keys.forEach(function (prop, i) {\n            if (!(prop in ptr)) {\n              ptr[prop] = {};\n            }\n\n            if (i < len - 1 && ptr.hasOwnProperty(prop)) {\n              ptr = ptr[prop];\n            } else if (prop !== '__proto__') {\n              ptr[prop] = ch.value;\n            }\n          });\n        } else {\n          obj = ch.value;\n        }\n        break;\n\n      case 'del':\n        ptr = obj;\n        keys = ch.key;\n        len = keys.length;\n        if (len) {\n          keys.forEach(function (prop, i) {\n            if (!(prop in ptr)) {\n              ptr[prop] = {};\n            }\n\n            if (i < len - 1) {\n              ptr = ptr[prop];\n            } else {\n              if (Array.isArray(ptr)) {\n                ptr.splice(parseInt(prop, 10), 1);\n              } else if (ptr.hasOwnProperty(prop)) {\n                delete ptr[prop];\n              }\n            }\n          });\n        } else {\n          obj = null;\n        }\n        break;\n    }\n  });\n  return obj;\n}\n", "var expect = require('chai').expect\n  , diff = require('..');\n\ndescribe('changeset', function () {\n  beforeEach(function (done) {\n    done();\n  });\n\n  it('should be able to diff two objects and return a changeset',\n    function (done) {\n      var a = {\n        name: 'Eugene',\n        number: 42,\n        tags: ['tag1', 'tag2', 'tag3'],\n        scores: {\n          tetris: 1000,\n          carmageddon: 3,\n          someArray: ['one', 'two', 'three']\n        }\n      };\n\n      a.self = a;\n      a.scoresAgain = a.scores;\n\n      var b = {\n        name: 'Susan',\n        number: 43,\n        tags: ['tag1', 'tag4'],\n        scores: {\n          carmageddon: 3,\n          zelda: 3000,\n          someArray: ['one', 'three']\n        },\n        age: 37\n      };\n\n      b.friend = a;\n      b.self = b;\n\n      var changes = diff(a, b);\n\n      expect(changes).to.deep.equal([\n        { type: 'put', key: ['name'], value: 'Susan' },\n        { type: 'put', key: ['number'], value: 43 },\n        { type: 'put', key: ['tags', '1'], value: 'tag4' },\n        { type: 'del', key: ['tags', '2'] },\n        { type: 'put', key: [ 'scores', 'someArray', '1' ], value: 'three' },\n        { type: 'del', key: [ 'scores', 'someArray', '2' ] },\n        { type: 'del', key: ['scores', 'tetris'] },\n        { type: 'put', key: ['scores', 'zelda'], value: 3000 },\n        { type: 'put', key: ['self'], value: b },\n        { type: 'del', key: ['scoresAgain'], },\n        { type: 'put', key: ['age'], value: 37 },\n        { type: 'put', key: ['friend'], value: a }\n      ]);\n\n      done();\n    });\n\n  it('should be able to handle basic types', function (done) {\n    var a = 'Eugene';\n    var b = 'Susan';\n\n    var changes = diff(a, b);\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: 'Susan' }\n    ]);\n\n    done();\n  });\n\n  it('should be able to handle nulls', function (done) {\n    var changes;\n\n    changes = diff(null, 'Susan');\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: 'Susan' }\n    ]);\n\n    changes = diff('Eugene', null);\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: null }\n    ]);\n\n    done();\n  });\n\n  it('should be able to handle undefined', function (done) {\n    var changes;\n\n    changes = diff(undefined, 'Susan');\n    expect(changes).to.deep.equal([\n      { type: 'put', key: [], value: 'Susan' }\n    ]);\n\n    changes = diff('Eugene', undefined);\n    expect(changes).to.deep.equal([\n      { type: 'del', key: [] }\n    ]);\n\n    done();\n  });\n\n  it('should be able to apply a changeset to an object', function (done) {\n    var a = {\n      name: 'Eugene',\n      number: 42,\n      tags: ['tag1', 'tag2', 'tag3'],\n      scores: {\n        tetris: 1000,\n        carmageddon: 3,\n        someArray: ['one', 'two', 'three']\n      }\n    };\n\n    a.self = a;\n    a.scoresAgain = a.scores;\n\n    var b = {\n      name: 'Susan',\n      number: 43,\n      tags: ['tag1', 'tag4'],\n      scores: {\n        carmageddon: 3,\n        zelda: 3000,\n        someArray: ['one', 'three']\n      },\n      age: 37\n    };\n\n    b.friend = a;\n    b.self = b;\n\n    var clone = require(\"udc\");\n    var bClone = clone(b);\n\n    var changes = diff(a, b);\n    var b_ = diff.apply(changes, a);\n    expect(b_.scores.someArray.length).to.equal(b.scores.someArray.length);\n    expect(b_).to.deep.equals(b);\n    expect(b).to.deep.equals(bClone); // Target did not change.\n    done();\n  });\n\n  it('should be able to apply a changeset to a value', function (done) {\n    var a = 'Eugene';\n    var b = 'Susan';\n\n    var changes = diff(a, b);\n    var b_ = diff.apply(changes, a);\n    expect(b_).to.deep.equals(b);\n    done();\n  });\n\n  it('should be able to apply a changeset with nulls', function (done) {\n    var changes, b_;\n\n    changes = diff(null, 'Susan');\n     b_ = diff.apply(changes, null);\n    expect(b_).to.deep.equals('Susan');\n\n    changes = diff('Eugene', null);\n     b_ = diff.apply(changes, 'Eugene');\n    expect(b_).to.deep.equals(null);\n\n    done();\n  });\n\n  it('should be able to apply a changeset with undefined', function (done) {\n    var changes, b_;\n\n    changes = diff(undefined, 'Susan');\n     b_ = diff.apply(changes, undefined);\n    expect(b_).to.deep.equals('Susan');\n\n    changes = diff('Eugene', undefined);\n     b_ = diff.apply(changes, 'Eugene');\n    expect(b_).to.deep.equals(null);\n\n    done();\n  });\n\n  it('should be able to apply a changeset to an object and modify it',\n      function (done) {\n        var a = {\n          name: 'Eugene',\n          number: 42,\n          tags: ['tag1', 'tag2', 'tag3'],\n          scores: {\n            tetris: 1000,\n            carmageddon: 3,\n            someArray: ['one', 'two', 'three']\n          }\n        };\n\n        a.self = a;\n        a.scoresAgain = a.scores;\n\n        var b = {\n          name: 'Susan',\n          number: 43,\n          tags: ['tag1', 'tag4'],\n          scores: {\n            carmageddon: 3,\n            zelda: 3000,\n            someArray: ['one', 'three']\n          },\n          age: 37\n        };\n\n        b.friend = a;\n        b.self = b;\n\n        var changes = diff(a, b);\n        var b_ = diff.apply(changes, a, true);\n        expect(b_.scores.someArray.length).to.equal(b.scores.someArray.length);\n        expect(b_).to.deep.equals(b);\n        expect(b_).to.equal(a);\n        done();\n    });\n\n  it('should be able to self-modify and replace an entire object',\n    function(done) {\n      var data = { name: 'Eugene', number: 43 };\n      var change = [ { type: 'put', key: [], value: 'xxx' } ];\n      var obj = diff.apply(change, data, true);\n      expect(obj).to.equal('xxx');\n      done();\n    });\n\n  it('should be able to deal with incrementally built arrays', function(done) {\n    var obj = [];\n    var changeset = [\n      { type: 'put', key: [], value: [] },\n      { type: 'put', key: [ 0, 'make' ], value: 'Toyota' },\n      { type: 'put', key: [ 0, 'model' ], value: 'Camry' },\n      { type: 'put', key: [ 1, 'make' ], value: 'Toyota' },\n      { type: 'put', key: [ 1, 'model' ], value: 'Corolla' } ];\n    obj = diff.apply(changeset, obj, true);\n    expect(obj).to.deep.equals([\n      { make: 'Toyota', model: 'Camry' },\n      { make: 'Toyota', model: 'Corolla' }\n    ]);\n    done();\n  });\n\n  it('should not allow prototype pollution', function(done) {\n    var changeset = [\n      { type: 'put', key: ['__proto__','polluted'], value: 'Yes! Its Polluted'}\n    ];\n    diff.apply(changeset, {}, true);\n    expect({}.polluted).to.not.equal('Yes! Its Polluted');\n    done();\n  })\n});\n"], "filenames": ["index.js", "test/index.js"], "buggy_code_start_loc": [78, 245], "buggy_code_end_loc": [105, 245], "fixing_code_start_loc": [78, 246], "fixing_code_end_loc": [105, 255], "type": "CWE-1321", "message": "Prototype pollution vulnerability in 'changeset' versions 0.0.1 through 0.2.5 allows an attacker to cause a denial of service and may lead to remote code execution.", "other": {"cve": {"id": "CVE-2021-25915", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-03-09T15:15:15.977", "lastModified": "2022-06-28T14:11:45.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prototype pollution vulnerability in 'changeset' versions 0.0.1 through 0.2.5 allows an attacker to cause a denial of service and may lead to remote code execution."}, {"lang": "es", "value": "Una vulnerabilidad de contaminaci\u00f3n del prototipo en \"changeset\" versiones 0.0.1 hasta 0.2.5, permite a un atacante causar una denegaci\u00f3n de servicio y puede conllevar a una ejecuci\u00f3n de c\u00f3digo remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:changeset_project:changeset:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "0.0.1", "versionEndExcluding": "0.2.6", "matchCriteriaId": "BF967612-E0BB-4A5E-BEAE-953F0980F091"}]}]}], "references": [{"url": "https://github.com/eugeneware/changeset/commit/9e588844edbb9993b32e7366cc799262b4447f99", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25915", "source": "vulnerabilitylab@mend.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eugeneware/changeset/commit/9e588844edbb9993b32e7366cc799262b4447f99"}}