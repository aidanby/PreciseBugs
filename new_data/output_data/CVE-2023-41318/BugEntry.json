{"buggy_code": ["package _routers\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alioygur/is\"\n\t\"github.com/getsentry/sentry-go\"\n\t\"github.com/turt2live/matrix-media-repo/api/_responses\"\n\t\"github.com/turt2live/matrix-media-repo/common\"\n\t\"github.com/turt2live/matrix-media-repo/common/rcontext\"\n\t\"github.com/turt2live/matrix-media-repo/util\"\n)\n\ntype GeneratorFn = func(r *http.Request, ctx rcontext.RequestContext) interface{}\n\ntype RContextRouter struct {\n\tgeneratorFn GeneratorFn\n\tnext        http.Handler\n}\n\nfunc NewRContextRouter(generatorFn GeneratorFn, next http.Handler) *RContextRouter {\n\treturn &RContextRouter{generatorFn: generatorFn, next: next}\n}\n\nfunc (c *RContextRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlog := GetLogger(r)\n\trctx := rcontext.RequestContext{\n\t\tContext: r.Context(),\n\t\tLog:     log,\n\t\tConfig:  *GetDomainConfig(r),\n\t\tRequest: r,\n\t}\n\n\tvar res interface{}\n\tres = c.generatorFn(r, rctx)\n\tif res == nil {\n\t\tres = &_responses.EmptyResponse{}\n\t}\n\n\tshouldCache := true\n\twrappedRes, isNoCache := res.(*_responses.DoNotCacheResponse)\n\tif isNoCache {\n\t\tshouldCache = false\n\t\tres = wrappedRes.Payload\n\t}\n\n\theaders := w.Header()\n\n\t// Check for HTML response and reply accordingly\n\tif htmlRes, isHtml := res.(*_responses.HtmlResponse); isHtml {\n\t\tlog.Infof(\"Replying with result: %T <%d chars of html>\", res, len(htmlRes.HTML))\n\n\t\t// Write out HTML here, now that we know it's happening\n\t\tif shouldCache {\n\t\t\theaders.Set(\"Cache-Control\", \"private, max-age=259200\") // 3 days\n\t\t}\n\t\theaders.Set(\"Content-Type\", \"text/html; charset=UTF-8\")\n\n\t\t// Clear the CSP because we're serving HTML\n\t\theaders.Set(\"Content-Security-Policy\", \"\")\n\t\theaders.Set(\"X-Content-Security-Policy\", \"\")\n\n\t\tr = writeStatusCode(w, r, http.StatusOK)\n\t\tif _, err := w.Write([]byte(htmlRes.HTML)); err != nil {\n\t\t\tpanic(errors.New(\"error sending HtmlResponse: \" + err.Error()))\n\t\t}\n\t\treturn // don't continue\n\t}\n\n\t// Next try handling the response as a download, which might turn into an error\n\tproposedStatusCode := http.StatusOK\n\tvar stream io.ReadCloser\n\texpectedBytes := int64(0)\n\tvar contentType string\nbeforeParseDownload:\n\tlog.Infof(\"Replying with result: %T %+v\", res, res)\n\tif downloadRes, isDownload := res.(*_responses.DownloadResponse); isDownload {\n\t\tdoRange, rangeStart, rangeEnd, rangeErrMsg := parseRange(r, downloadRes)\n\t\tif doRange && rangeErrMsg != \"\" {\n\t\t\tproposedStatusCode = http.StatusRequestedRangeNotSatisfiable\n\t\t\tres = _responses.BadRequest(rangeErrMsg)\n\t\t\tdoRange = false\n\t\t\tgoto beforeParseDownload // reprocess `res`\n\t\t}\n\n\t\tcontentType = downloadRes.ContentType\n\t\texpectedBytes = downloadRes.SizeBytes\n\n\t\tif shouldCache {\n\t\t\theaders.Set(\"Cache-Control\", \"private, max-age=259200\") // 3 days\n\t\t}\n\n\t\tif downloadRes.SizeBytes > 0 {\n\t\t\theaders.Set(\"Accept-Ranges\", \"bytes\")\n\t\t}\n\n\t\tdisposition := downloadRes.TargetDisposition\n\t\tif disposition == \"\" {\n\t\t\tdisposition = \"inline\"\n\t\t} else if disposition == \"infer\" {\n\t\t\tif contentType == \"\" {\n\t\t\t\tdisposition = \"attachment\"\n\t\t\t} else {\n\t\t\t\tif util.HasAnyPrefix(contentType, []string{\"image/\", \"audio/\", \"video/\", \"text/plain\"}) {\n\t\t\t\t\tdisposition = \"inline\"\n\t\t\t\t} else {\n\t\t\t\t\tdisposition = \"attachment\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfname := downloadRes.Filename\n\t\tif fname == \"\" {\n\t\t\texts, err := mime.ExtensionsByType(contentType)\n\t\t\tif err != nil {\n\t\t\t\texts = nil\n\t\t\t\tsentry.CaptureException(err)\n\t\t\t\tlog.Warn(\"Unexpected error inferring file extension: \", err)\n\t\t\t}\n\t\t\text := \"\"\n\t\t\tif exts != nil && len(exts) > 0 {\n\t\t\t\text = exts[0]\n\t\t\t}\n\t\t\tfname = \"file\" + ext\n\t\t}\n\t\tif is.ASCII(fname) {\n\t\t\theaders.Set(\"Content-Disposition\", disposition+\"; filename=\"+url.QueryEscape(fname))\n\t\t} else {\n\t\t\theaders.Set(\"Content-Disposition\", disposition+\"; filename*=utf-8''\"+url.QueryEscape(fname))\n\t\t}\n\n\t\tif _, ok := stream.(io.ReadSeekCloser); ok && doRange {\n\t\t\theaders.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", rangeStart, rangeEnd, downloadRes.SizeBytes))\n\t\t\tproposedStatusCode = http.StatusPartialContent\n\t\t}\n\t\tstream = downloadRes.Data\n\t}\n\n\t// Try to find a suitable error code, if one is needed\n\tif errRes, isError := res.(_responses.ErrorResponse); isError {\n\t\tres = &errRes // just fix it\n\t}\n\tif errRes, isError := res.(*_responses.ErrorResponse); isError && proposedStatusCode == http.StatusOK {\n\t\tswitch errRes.InternalCode {\n\t\tcase common.ErrCodeUnknownToken:\n\t\t\tproposedStatusCode = http.StatusUnauthorized\n\t\t\tbreak\n\t\tcase common.ErrCodeNotFound:\n\t\t\tproposedStatusCode = http.StatusNotFound\n\t\t\tbreak\n\t\tcase common.ErrCodeMediaTooLarge:\n\t\t\tproposedStatusCode = http.StatusRequestEntityTooLarge\n\t\t\tbreak\n\t\tcase common.ErrCodeBadRequest:\n\t\t\tproposedStatusCode = http.StatusBadRequest\n\t\t\tbreak\n\t\tcase common.ErrCodeMethodNotAllowed:\n\t\t\tproposedStatusCode = http.StatusMethodNotAllowed\n\t\t\tbreak\n\t\tcase common.ErrCodeForbidden:\n\t\t\tproposedStatusCode = http.StatusForbidden\n\t\t\tbreak\n\t\tcase common.ErrCodeCannotOverwrite:\n\t\t\tproposedStatusCode = http.StatusConflict\n\t\t\tbreak\n\t\tcase common.ErrCodeNotYetUploaded:\n\t\t\tproposedStatusCode = http.StatusGatewayTimeout\n\t\t\tbreak\n\t\tdefault: // Treat as unknown (a generic server error)\n\t\t\tproposedStatusCode = http.StatusInternalServerError\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Prepare a stream if one isn't set, and assume JSON\n\tif stream == nil {\n\t\tcontentType = \"application/json\"\n\t\tb, err := json.Marshal(res)\n\t\tif err != nil {\n\t\t\tpanic(err) // blow up this request\n\t\t}\n\t\tstream = io.NopCloser(bytes.NewReader(b))\n\t\texpectedBytes = int64(len(b))\n\t}\n\n\tmediaType, params, err := mime.ParseMediaType(contentType)\n\tif err != nil {\n\t\tsentry.CaptureException(err)\n\t\tlog.Warn(\"Failed to parse content type header for media on reply: \", err)\n\t} else {\n\t\t// TODO: Maybe we only strip the charset from images? Is it valid to have the param on other types?\n\t\tif !strings.HasPrefix(mediaType, \"text/\") && mediaType != \"application/json\" {\n\t\t\tdelete(params, \"charset\")\n\t\t}\n\t\tcontentType = mime.FormatMediaType(mediaType, params)\n\t}\n\theaders.Set(\"Content-Type\", contentType)\n\n\tif expectedBytes > 0 {\n\t\theaders.Set(\"Content-Length\", strconv.FormatInt(expectedBytes, 10))\n\t}\n\n\tr = writeStatusCode(w, r, proposedStatusCode)\n\n\tdefer stream.Close()\n\twritten, err := io.Copy(w, stream)\n\tif err != nil {\n\t\tpanic(err) // blow up this request\n\t}\n\tif expectedBytes > 0 && written != expectedBytes {\n\t\tpanic(errors.New(fmt.Sprintf(\"mismatch transfer size: %d expected, %d sent\", expectedBytes, written)))\n\t}\n\n\tif c.next != nil {\n\t\tc.next.ServeHTTP(w, r)\n\t}\n}\n\nfunc GetStatusCode(r *http.Request) int {\n\tx, ok := r.Context().Value(common.ContextStatusCode).(int)\n\tif !ok {\n\t\treturn http.StatusOK\n\t}\n\treturn x\n}\n\nfunc writeStatusCode(w http.ResponseWriter, r *http.Request, statusCode int) *http.Request {\n\tw.WriteHeader(statusCode)\n\treturn r.WithContext(context.WithValue(r.Context(), common.ContextStatusCode, statusCode))\n}\n\nfunc parseRange(r *http.Request, res *_responses.DownloadResponse) (bool, int64, int64, string) {\n\trangeHeader := r.Header.Get(\"Range\")\n\tif rangeHeader == \"\" || res.SizeBytes <= 0 {\n\t\treturn false, 0, 0, \"\"\n\t}\n\n\tif !strings.HasPrefix(rangeHeader, \"bytes=\") {\n\t\treturn true, 0, 0, \"Improper range units\"\n\t}\n\tif !strings.Contains(rangeHeader, \",\") && !strings.HasPrefix(rangeHeader, \"bytes=-\") {\n\t\tparts := strings.Split(rangeHeader[len(\"bytes=\"):], \"-\")\n\t\tif len(parts) <= 2 {\n\t\t\trstart, err := strconv.ParseInt(parts[0], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn true, 0, 0, \"Improper start of range\"\n\t\t\t}\n\t\t\tif rstart < 0 {\n\t\t\t\treturn true, 0, 0, \"Improper start of range: negative\"\n\t\t\t}\n\n\t\t\trend := int64(-1)\n\t\t\tif len(parts) > 1 && parts[1] != \"\" {\n\t\t\t\trend, err = strconv.ParseInt(parts[1], 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn true, 0, 0, \"Improper end of range\"\n\t\t\t\t}\n\t\t\t\tif rend < 1 {\n\t\t\t\t\treturn true, 0, 0, \"Improper end of range: negative\"\n\t\t\t\t}\n\t\t\t\tif rend >= res.SizeBytes {\n\t\t\t\t\treturn true, 0, 0, \"Improper end of range: out of bounds\"\n\t\t\t\t}\n\t\t\t\tif rend <= rstart {\n\t\t\t\t\treturn true, 0, 0, \"Start must be before end\"\n\t\t\t\t}\n\t\t\t\tif (rstart + rend) >= res.SizeBytes {\n\t\t\t\t\treturn true, 0, 0, \"Range too large\"\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tadd := int64(10485760) // 10mb default\n\t\t\t\tconf := GetDomainConfig(r)\n\t\t\t\tif conf.Downloads.DefaultRangeChunkSizeBytes > 0 {\n\t\t\t\t\tadd = conf.Downloads.DefaultRangeChunkSizeBytes\n\t\t\t\t}\n\t\t\t\trend = int64(math.Min(float64(rstart+add), float64(res.SizeBytes-1)))\n\t\t\t}\n\n\t\t\tif (rend - rstart) <= 0 {\n\t\t\t\treturn true, 0, 0, \"Range invalid at last pass\"\n\t\t\t}\n\t\t\treturn true, rstart, rend, \"\"\n\t\t}\n\t}\n\treturn false, 0, 0, \"\"\n}\n", "package util\n\nimport (\n\t\"mime\"\n\t\"strings\"\n)\n\nfunc FixContentType(ct string) string {\n\treturn strings.Split(ct, \";\")[0]\n}\n\nfunc ExtensionForContentType(ct string) string {\n\texts, _ := mime.ExtensionsByType(ct)\n\tif len(exts) > 0 {\n\t\treturn exts[0]\n\t}\n\treturn \".bin\"\n}\n"], "fixing_code": ["package _routers\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"mime\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alioygur/is\"\n\t\"github.com/getsentry/sentry-go\"\n\t\"github.com/turt2live/matrix-media-repo/api/_responses\"\n\t\"github.com/turt2live/matrix-media-repo/common\"\n\t\"github.com/turt2live/matrix-media-repo/common/rcontext\"\n\t\"github.com/turt2live/matrix-media-repo/util\"\n)\n\ntype GeneratorFn = func(r *http.Request, ctx rcontext.RequestContext) interface{}\n\ntype RContextRouter struct {\n\tgeneratorFn GeneratorFn\n\tnext        http.Handler\n}\n\nfunc NewRContextRouter(generatorFn GeneratorFn, next http.Handler) *RContextRouter {\n\treturn &RContextRouter{generatorFn: generatorFn, next: next}\n}\n\nfunc (c *RContextRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlog := GetLogger(r)\n\trctx := rcontext.RequestContext{\n\t\tContext: r.Context(),\n\t\tLog:     log,\n\t\tConfig:  *GetDomainConfig(r),\n\t\tRequest: r,\n\t}\n\n\tvar res interface{}\n\tres = c.generatorFn(r, rctx)\n\tif res == nil {\n\t\tres = &_responses.EmptyResponse{}\n\t}\n\n\tshouldCache := true\n\twrappedRes, isNoCache := res.(*_responses.DoNotCacheResponse)\n\tif isNoCache {\n\t\tshouldCache = false\n\t\tres = wrappedRes.Payload\n\t}\n\n\theaders := w.Header()\n\n\t// Check for HTML response and reply accordingly\n\tif htmlRes, isHtml := res.(*_responses.HtmlResponse); isHtml {\n\t\tlog.Infof(\"Replying with result: %T <%d chars of html>\", res, len(htmlRes.HTML))\n\n\t\t// Write out HTML here, now that we know it's happening\n\t\tif shouldCache {\n\t\t\theaders.Set(\"Cache-Control\", \"private, max-age=259200\") // 3 days\n\t\t}\n\t\theaders.Set(\"Content-Type\", \"text/html; charset=UTF-8\")\n\n\t\t// Clear the CSP because we're serving HTML\n\t\theaders.Set(\"Content-Security-Policy\", \"\")\n\t\theaders.Set(\"X-Content-Security-Policy\", \"\")\n\n\t\tr = writeStatusCode(w, r, http.StatusOK)\n\t\tif _, err := w.Write([]byte(htmlRes.HTML)); err != nil {\n\t\t\tpanic(errors.New(\"error sending HtmlResponse: \" + err.Error()))\n\t\t}\n\t\treturn // don't continue\n\t}\n\n\t// Next try handling the response as a download, which might turn into an error\n\tproposedStatusCode := http.StatusOK\n\tvar stream io.ReadCloser\n\texpectedBytes := int64(0)\n\tvar contentType string\nbeforeParseDownload:\n\tlog.Infof(\"Replying with result: %T %+v\", res, res)\n\tif downloadRes, isDownload := res.(*_responses.DownloadResponse); isDownload {\n\t\tdoRange, rangeStart, rangeEnd, rangeErrMsg := parseRange(r, downloadRes)\n\t\tif doRange && rangeErrMsg != \"\" {\n\t\t\tproposedStatusCode = http.StatusRequestedRangeNotSatisfiable\n\t\t\tres = _responses.BadRequest(rangeErrMsg)\n\t\t\tdoRange = false\n\t\t\tgoto beforeParseDownload // reprocess `res`\n\t\t}\n\n\t\tcontentType = downloadRes.ContentType\n\t\texpectedBytes = downloadRes.SizeBytes\n\n\t\tif shouldCache {\n\t\t\theaders.Set(\"Cache-Control\", \"private, max-age=259200\") // 3 days\n\t\t}\n\n\t\tif downloadRes.SizeBytes > 0 {\n\t\t\theaders.Set(\"Accept-Ranges\", \"bytes\")\n\t\t}\n\n\t\tdisposition := downloadRes.TargetDisposition\n\t\tif disposition == \"\" {\n\t\t\tdisposition = \"inline\"\n\t\t} else if disposition == \"infer\" {\n\t\t\tif contentType == \"\" {\n\t\t\t\tdisposition = \"attachment\"\n\t\t\t} else {\n\t\t\t\tif util.CanInline(contentType) {\n\t\t\t\t\tdisposition = \"inline\"\n\t\t\t\t} else {\n\t\t\t\t\tdisposition = \"attachment\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfname := downloadRes.Filename\n\t\tif fname == \"\" {\n\t\t\texts, err := mime.ExtensionsByType(contentType)\n\t\t\tif err != nil {\n\t\t\t\texts = nil\n\t\t\t\tsentry.CaptureException(err)\n\t\t\t\tlog.Warn(\"Unexpected error inferring file extension: \", err)\n\t\t\t}\n\t\t\text := \"\"\n\t\t\tif exts != nil && len(exts) > 0 {\n\t\t\t\text = exts[0]\n\t\t\t}\n\t\t\tfname = \"file\" + ext\n\t\t}\n\t\tif is.ASCII(fname) {\n\t\t\theaders.Set(\"Content-Disposition\", disposition+\"; filename=\"+url.QueryEscape(fname))\n\t\t} else {\n\t\t\theaders.Set(\"Content-Disposition\", disposition+\"; filename*=utf-8''\"+url.QueryEscape(fname))\n\t\t}\n\n\t\tif _, ok := stream.(io.ReadSeekCloser); ok && doRange {\n\t\t\theaders.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", rangeStart, rangeEnd, downloadRes.SizeBytes))\n\t\t\tproposedStatusCode = http.StatusPartialContent\n\t\t}\n\t\tstream = downloadRes.Data\n\t}\n\n\t// Try to find a suitable error code, if one is needed\n\tif errRes, isError := res.(_responses.ErrorResponse); isError {\n\t\tres = &errRes // just fix it\n\t}\n\tif errRes, isError := res.(*_responses.ErrorResponse); isError && proposedStatusCode == http.StatusOK {\n\t\tswitch errRes.InternalCode {\n\t\tcase common.ErrCodeUnknownToken:\n\t\t\tproposedStatusCode = http.StatusUnauthorized\n\t\t\tbreak\n\t\tcase common.ErrCodeNotFound:\n\t\t\tproposedStatusCode = http.StatusNotFound\n\t\t\tbreak\n\t\tcase common.ErrCodeMediaTooLarge:\n\t\t\tproposedStatusCode = http.StatusRequestEntityTooLarge\n\t\t\tbreak\n\t\tcase common.ErrCodeBadRequest:\n\t\t\tproposedStatusCode = http.StatusBadRequest\n\t\t\tbreak\n\t\tcase common.ErrCodeMethodNotAllowed:\n\t\t\tproposedStatusCode = http.StatusMethodNotAllowed\n\t\t\tbreak\n\t\tcase common.ErrCodeForbidden:\n\t\t\tproposedStatusCode = http.StatusForbidden\n\t\t\tbreak\n\t\tcase common.ErrCodeCannotOverwrite:\n\t\t\tproposedStatusCode = http.StatusConflict\n\t\t\tbreak\n\t\tcase common.ErrCodeNotYetUploaded:\n\t\t\tproposedStatusCode = http.StatusGatewayTimeout\n\t\t\tbreak\n\t\tdefault: // Treat as unknown (a generic server error)\n\t\t\tproposedStatusCode = http.StatusInternalServerError\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Prepare a stream if one isn't set, and assume JSON\n\tif stream == nil {\n\t\tcontentType = \"application/json\"\n\t\tb, err := json.Marshal(res)\n\t\tif err != nil {\n\t\t\tpanic(err) // blow up this request\n\t\t}\n\t\tstream = io.NopCloser(bytes.NewReader(b))\n\t\texpectedBytes = int64(len(b))\n\t}\n\n\tmediaType, params, err := mime.ParseMediaType(contentType)\n\tif err != nil {\n\t\tsentry.CaptureException(err)\n\t\tlog.Warn(\"Failed to parse content type header for media on reply: \", err)\n\t} else {\n\t\t// TODO: Maybe we only strip the charset from images? Is it valid to have the param on other types?\n\t\tif !strings.HasPrefix(mediaType, \"text/\") && mediaType != \"application/json\" {\n\t\t\tdelete(params, \"charset\")\n\t\t}\n\t\tcontentType = mime.FormatMediaType(mediaType, params)\n\t}\n\theaders.Set(\"Content-Type\", contentType)\n\n\tif expectedBytes > 0 {\n\t\theaders.Set(\"Content-Length\", strconv.FormatInt(expectedBytes, 10))\n\t}\n\n\tr = writeStatusCode(w, r, proposedStatusCode)\n\n\tdefer stream.Close()\n\twritten, err := io.Copy(w, stream)\n\tif err != nil {\n\t\tpanic(err) // blow up this request\n\t}\n\tif expectedBytes > 0 && written != expectedBytes {\n\t\tpanic(errors.New(fmt.Sprintf(\"mismatch transfer size: %d expected, %d sent\", expectedBytes, written)))\n\t}\n\n\tif c.next != nil {\n\t\tc.next.ServeHTTP(w, r)\n\t}\n}\n\nfunc GetStatusCode(r *http.Request) int {\n\tx, ok := r.Context().Value(common.ContextStatusCode).(int)\n\tif !ok {\n\t\treturn http.StatusOK\n\t}\n\treturn x\n}\n\nfunc writeStatusCode(w http.ResponseWriter, r *http.Request, statusCode int) *http.Request {\n\tw.WriteHeader(statusCode)\n\treturn r.WithContext(context.WithValue(r.Context(), common.ContextStatusCode, statusCode))\n}\n\nfunc parseRange(r *http.Request, res *_responses.DownloadResponse) (bool, int64, int64, string) {\n\trangeHeader := r.Header.Get(\"Range\")\n\tif rangeHeader == \"\" || res.SizeBytes <= 0 {\n\t\treturn false, 0, 0, \"\"\n\t}\n\n\tif !strings.HasPrefix(rangeHeader, \"bytes=\") {\n\t\treturn true, 0, 0, \"Improper range units\"\n\t}\n\tif !strings.Contains(rangeHeader, \",\") && !strings.HasPrefix(rangeHeader, \"bytes=-\") {\n\t\tparts := strings.Split(rangeHeader[len(\"bytes=\"):], \"-\")\n\t\tif len(parts) <= 2 {\n\t\t\trstart, err := strconv.ParseInt(parts[0], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn true, 0, 0, \"Improper start of range\"\n\t\t\t}\n\t\t\tif rstart < 0 {\n\t\t\t\treturn true, 0, 0, \"Improper start of range: negative\"\n\t\t\t}\n\n\t\t\trend := int64(-1)\n\t\t\tif len(parts) > 1 && parts[1] != \"\" {\n\t\t\t\trend, err = strconv.ParseInt(parts[1], 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn true, 0, 0, \"Improper end of range\"\n\t\t\t\t}\n\t\t\t\tif rend < 1 {\n\t\t\t\t\treturn true, 0, 0, \"Improper end of range: negative\"\n\t\t\t\t}\n\t\t\t\tif rend >= res.SizeBytes {\n\t\t\t\t\treturn true, 0, 0, \"Improper end of range: out of bounds\"\n\t\t\t\t}\n\t\t\t\tif rend <= rstart {\n\t\t\t\t\treturn true, 0, 0, \"Start must be before end\"\n\t\t\t\t}\n\t\t\t\tif (rstart + rend) >= res.SizeBytes {\n\t\t\t\t\treturn true, 0, 0, \"Range too large\"\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tadd := int64(10485760) // 10mb default\n\t\t\t\tconf := GetDomainConfig(r)\n\t\t\t\tif conf.Downloads.DefaultRangeChunkSizeBytes > 0 {\n\t\t\t\t\tadd = conf.Downloads.DefaultRangeChunkSizeBytes\n\t\t\t\t}\n\t\t\t\trend = int64(math.Min(float64(rstart+add), float64(res.SizeBytes-1)))\n\t\t\t}\n\n\t\t\tif (rend - rstart) <= 0 {\n\t\t\t\treturn true, 0, 0, \"Range invalid at last pass\"\n\t\t\t}\n\t\t\treturn true, rstart, rend, \"\"\n\t\t}\n\t}\n\treturn false, 0, 0, \"\"\n}\n", "package util\n\nimport (\n\t\"mime\"\n\t\"strings\"\n)\n\nfunc FixContentType(ct string) string {\n\treturn strings.Split(ct, \";\")[0]\n}\n\nfunc ExtensionForContentType(ct string) string {\n\texts, _ := mime.ExtensionsByType(ct)\n\tif len(exts) > 0 {\n\t\treturn exts[0]\n\t}\n\treturn \".bin\"\n}\n\nfunc CanInline(ct string) bool {\n\tct = FixContentType(ct)\n\treturn ArrayContains(InlineContentTypes, ct)\n}\n\nvar InlineContentTypes = []string{\n\t// Types are inherited from https://github.com/matrix-org/synapse/pull/15988\n\n\t\"text/css\",\n\t\"text/plain\",\n\t\"text/csv\",\n\t\"application/json\",\n\t\"application/ld+json\",\n\t\"image/jpeg\",\n\t\"image/gif\",\n\t\"image/png\",\n\t\"image/apng\",\n\t\"image/webp\",\n\t\"image/avif\",\n\t\"video/mp4\",\n\t\"video/webm\",\n\t\"video/ogg\",\n\t\"video/quicktime\",\n\t\"audio/mp4\",\n\t\"audio/webm\",\n\t\"audio/aac\",\n\t\"audio/mpeg\",\n\t\"audio/ogg\",\n\t\"audio/wave\",\n\t\"audio/wav\",\n\t\"audio/x-wav\",\n\t\"audio/x-pn-wav\",\n\t\"audio/flac\",\n\t\"audio/x-flac\",\n}\n"], "filenames": ["api/_routers/98-use-rcontext.go", "util/mime.go"], "buggy_code_start_loc": [115, 18], "buggy_code_end_loc": [116, 18], "fixing_code_start_loc": [115, 19], "fixing_code_end_loc": [116, 55], "type": "CWE-79", "message": "matrix-media-repo is a highly customizable multi-domain media repository for the Matrix chat ecosystem. In affected versions an attacker could upload a malicious piece of media to the media repo, which would then be served with `Content-Disposition: inline` upon download. This vulnerability could be leveraged to execute scripts embedded in SVG content. Commits `77ec235` and `bf8abdd` fix the issue and are included in the 1.3.0 release. Operators should upgrade to v1.3.0 as soon as possible. Operators unable to upgrade should override the `Content-Disposition` header returned by matrix-media-repo as a workaround.", "other": {"cve": {"id": "CVE-2023-41318", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-08T20:15:14.693", "lastModified": "2023-09-13T02:17:59.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-media-repo is a highly customizable multi-domain media repository for the Matrix chat ecosystem. In affected versions an attacker could upload a malicious piece of media to the media repo, which would then be served with `Content-Disposition: inline` upon download. This vulnerability could be leveraged to execute scripts embedded in SVG content. Commits `77ec235` and `bf8abdd` fix the issue and are included in the 1.3.0 release. Operators should upgrade to v1.3.0 as soon as possible. Operators unable to upgrade should override the `Content-Disposition` header returned by matrix-media-repo as a workaround."}, {"lang": "es", "value": "Matrix-media-repo es un repositorio de medios multidominio altamente personalizable para el ecosistema de chat de Matrix. En las versiones afectadas, un atacante podr\u00eda cargar un contenido malicioso en el repositorio de contenidos, que luego se entregar\u00eda con \"Content-Disposition: inline\" al descargarlo. Esta vulnerabilidad podr\u00eda aprovecharse para ejecutar scripts incrustados en contenido SVG. Los commits `77ec235` y `bf8abdd` solucionan el problema y se incluyen en la versi\u00f3n 1.3.0. Los operadores deben actualizar a la versi\u00f3n 1.3.0 lo antes posible. Los operadores que no puedan actualizar deben anular el encabezado \"Content-Disposition\" devuelto por Matrix-media-repo como workaround."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:turt2live:matrix-media-repo:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "7900287F-C40A-4E34-A327-C0F6A014AB60"}]}]}], "references": [{"url": "https://developer.mozilla.org/en-US/docs/Web/SVG/Element/script", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/turt2live/matrix-media-repo/commit/77ec2354e8f46d5ef149d1dcaf25f51c04149137", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/turt2live/matrix-media-repo/commit/bf8abdd7a5371118e280c65a8e0ec2b2e9bdaf59", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/turt2live/matrix-media-repo/security/advisories/GHSA-5crw-6j7v-xc72", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/turt2live/matrix-media-repo/commit/77ec2354e8f46d5ef149d1dcaf25f51c04149137"}}