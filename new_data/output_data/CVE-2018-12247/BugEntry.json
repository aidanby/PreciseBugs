{"buggy_code": ["/*\n** kernel.c - Kernel module\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/istruct.h>\n\ntypedef enum {\n  NOEX_PUBLIC    = 0x00,\n  NOEX_NOSUPER   = 0x01,\n  NOEX_PRIVATE   = 0x02,\n  NOEX_PROTECTED = 0x04,\n  NOEX_MASK      = 0x06,\n  NOEX_BASIC     = 0x08,\n  NOEX_UNDEF     = NOEX_NOSUPER,\n  NOEX_MODFUNC   = 0x12,\n  NOEX_SUPER     = 0x20,\n  NOEX_VCALL     = 0x40,\n  NOEX_RESPONDS  = 0x80\n} mrb_method_flag_t;\n\nMRB_API mrb_bool\nmrb_func_basic_p(mrb_state *mrb, mrb_value obj, mrb_sym mid, mrb_func_t func)\n{\n  mrb_method_t m = mrb_method_search(mrb, mrb_class(mrb, obj), mid);\n  struct RProc *p;\n\n  if (MRB_METHOD_UNDEF_P(m)) return FALSE;\n  if (MRB_METHOD_FUNC_P(m))\n    return MRB_METHOD_FUNC(m) == func;\n  p = MRB_METHOD_PROC(m);\n  if (MRB_PROC_CFUNC_P(p) && (MRB_PROC_CFUNC(p) == func))\n    return TRUE;\n  return FALSE;\n}\n\nstatic mrb_bool\nmrb_obj_basic_to_s_p(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_func_basic_p(mrb, obj, mrb_intern_lit(mrb, \"to_s\"), mrb_any_to_s);\n}\n\n/* 15.3.1.3.17 */\n/*\n *  call-seq:\n *     obj.inspect   -> string\n *\n *  Returns a string containing a human-readable representation of\n *  <i>obj</i>. If not overridden and no instance variables, uses the\n *  <code>to_s</code> method to generate the string.\n *  <i>obj</i>.  If not overridden, uses the <code>to_s</code> method to\n *  generate the string.\n *\n *     [ 1, 2, 3..4, 'five' ].inspect   #=> \"[1, 2, 3..4, \\\"five\\\"]\"\n *     Time.new.inspect                 #=> \"2008-03-08 19:43:39 +0900\"\n */\nMRB_API mrb_value\nmrb_obj_inspect(mrb_state *mrb, mrb_value obj)\n{\n  if ((mrb_type(obj) == MRB_TT_OBJECT) && mrb_obj_basic_to_s_p(mrb, obj)) {\n    return mrb_obj_iv_inspect(mrb, mrb_obj_ptr(obj));\n  }\n  return mrb_any_to_s(mrb, obj);\n}\n\n/* 15.3.1.3.2  */\n/*\n *  call-seq:\n *     obj === other   -> true or false\n *\n *  Case Equality---For class <code>Object</code>, effectively the same\n *  as calling  <code>#==</code>, but typically overridden by descendants\n *  to provide meaningful semantics in <code>case</code> statements.\n */\nstatic mrb_value\nmrb_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"o\", &arg);\n  return mrb_bool_value(mrb_equal(mrb, self, arg));\n}\n\n/* 15.3.1.3.3  */\n/* 15.3.1.3.33 */\n/*\n *  Document-method: __id__\n *  Document-method: object_id\n *\n *  call-seq:\n *     obj.__id__       -> fixnum\n *     obj.object_id    -> fixnum\n *\n *  Returns an integer identifier for <i>obj</i>. The same number will\n *  be returned on all calls to <code>id</code> for a given object, and\n *  no two active objects will share an id.\n *  <code>Object#object_id</code> is a different concept from the\n *  <code>:name</code> notation, which returns the symbol id of\n *  <code>name</code>. Replaces the deprecated <code>Object#id</code>.\n */\nmrb_value\nmrb_obj_id_m(mrb_state *mrb, mrb_value self)\n{\n  return mrb_fixnum_value(mrb_obj_id(self));\n}\n\n/* 15.3.1.2.2  */\n/* 15.3.1.2.5  */\n/* 15.3.1.3.6  */\n/* 15.3.1.3.25 */\n/*\n *  call-seq:\n *     block_given?   -> true or false\n *     iterator?      -> true or false\n *\n *  Returns <code>true</code> if <code>yield</code> would execute a\n *  block in the current context. The <code>iterator?</code> form\n *  is mildly deprecated.\n *\n *     def try\n *       if block_given?\n *         yield\n *       else\n *         \"no block\"\n *       end\n *     end\n *     try                  #=> \"no block\"\n *     try { \"hello\" }      #=> \"hello\"\n *     try do \"hello\" end   #=> \"hello\"\n */\nstatic mrb_value\nmrb_f_block_given_p_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_callinfo *ci = &mrb->c->ci[-1];\n  mrb_callinfo *cibase = mrb->c->cibase;\n  mrb_value *bp;\n  struct RProc *p;\n\n  if (ci <= cibase) {\n    /* toplevel does not have block */\n    return mrb_false_value();\n  }\n  p = ci->proc;\n  /* search method/class/module proc */\n  while (p) {\n    if (MRB_PROC_SCOPE_P(p)) break;\n    p = p->upper;\n  }\n  if (p == NULL) return mrb_false_value();\n  /* search ci corresponding to proc */\n  while (cibase < ci) {\n    if (ci->proc == p) break;\n    ci--;\n  }\n  if (ci == cibase) {\n    return mrb_false_value();\n  }\n  else if (ci->env) {\n    struct REnv *e = ci->env;\n    int bidx;\n\n    /* top-level does not have block slot (always false) */\n    if (e->stack == mrb->c->stbase)\n      return mrb_false_value();\n    /* use saved block arg position */\n    bidx = MRB_ENV_BIDX(e);\n    /* bidx may be useless (e.g. define_method) */\n    if (bidx >= MRB_ENV_STACK_LEN(e))\n      return mrb_false_value();\n    bp = &e->stack[bidx];\n  }\n  else {\n    bp = ci[1].stackent+1;\n    if (ci->argc >= 0) {\n      bp += ci->argc;\n    }\n    else {\n      bp++;\n    }\n  }\n  if (mrb_nil_p(*bp))\n    return mrb_false_value();\n  return mrb_true_value();\n}\n\n/* 15.3.1.3.7  */\n/*\n *  call-seq:\n *     obj.class    -> class\n *\n *  Returns the class of <i>obj</i>. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Fixnum\n *     self.class   #=> Object\n */\nstatic mrb_value\nmrb_obj_class_m(mrb_state *mrb, mrb_value self)\n{\n  return mrb_obj_value(mrb_obj_class(mrb, self));\n}\n\nstatic struct RClass*\nmrb_singleton_class_clone(mrb_state *mrb, mrb_value obj)\n{\n  struct RClass *klass = mrb_basic_ptr(obj)->c;\n\n  if (klass->tt != MRB_TT_SCLASS)\n    return klass;\n  else {\n    /* copy singleton(unnamed) class */\n    struct RClass *clone = (struct RClass*)mrb_obj_alloc(mrb, klass->tt, mrb->class_class);\n\n    switch (mrb_type(obj)) {\n    case MRB_TT_CLASS:\n    case MRB_TT_SCLASS:\n      break;\n    default:\n      clone->c = mrb_singleton_class_clone(mrb, mrb_obj_value(klass));\n      break;\n    }\n    clone->super = klass->super;\n    if (klass->iv) {\n      mrb_iv_copy(mrb, mrb_obj_value(clone), mrb_obj_value(klass));\n      mrb_obj_iv_set(mrb, (struct RObject*)clone, mrb_intern_lit(mrb, \"__attached__\"), obj);\n    }\n    if (klass->mt) {\n      clone->mt = kh_copy(mt, mrb, klass->mt);\n    }\n    else {\n      clone->mt = kh_init(mt, mrb);\n    }\n    clone->tt = MRB_TT_SCLASS;\n    return clone;\n  }\n}\n\nstatic void\ncopy_class(mrb_state *mrb, mrb_value dst, mrb_value src)\n{\n  struct RClass *dc = mrb_class_ptr(dst);\n  struct RClass *sc = mrb_class_ptr(src);\n  /* if the origin is not the same as the class, then the origin and\n     the current class need to be copied */\n  if (sc->flags & MRB_FLAG_IS_PREPENDED) {\n    struct RClass *c0 = sc->super;\n    struct RClass *c1 = dc;\n\n    /* copy prepended iclasses */\n    while (!(c0->flags & MRB_FLAG_IS_ORIGIN)) {\n      c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n      c1 = c1->super;\n      c0 = c0->super;\n    }\n    c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n    c1->super->flags |= MRB_FLAG_IS_ORIGIN;\n  }\n  if (sc->mt) {\n    dc->mt = kh_copy(mt, mrb, sc->mt);\n  }\n  else {\n    dc->mt = kh_init(mt, mrb);\n  }\n  dc->super = sc->super;\n  MRB_SET_INSTANCE_TT(dc, MRB_INSTANCE_TT(sc));\n}\n\nstatic void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}\n\n/* 15.3.1.3.8  */\n/*\n *  call-seq:\n *     obj.clone -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference. Copies\n *  the frozen state of <i>obj</i>. See also the discussion\n *  under <code>Object#dup</code>.\n *\n *     class Klass\n *        attr_accessor :str\n *     end\n *     s1 = Klass.new      #=> #<Klass:0x401b3a38>\n *     s1.str = \"Hello\"    #=> \"Hello\"\n *     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n *     s2.str[1,4] = \"i\"   #=> \"i\"\n *     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n *     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n *\n *  Some Class(True False Nil Symbol Fixnum Float) Object  cannot clone.\n */\nMRB_API mrb_value\nmrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n\n  return clone;\n}\n\n/* 15.3.1.3.9  */\n/*\n *  call-seq:\n *     obj.dup -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference.\n *  <code>dup</code> copies the frozen state of <i>obj</i>. See also\n *  the discussion under <code>Object#clone</code>. In general,\n *  <code>clone</code> and <code>dup</code> may have different semantics\n *  in descendant classes. While <code>clone</code> is used to duplicate\n *  an object, including its internal state, <code>dup</code> typically\n *  uses the class of the descendant object to create the new instance.\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n */\n\nMRB_API mrb_value\nmrb_obj_dup(mrb_state *mrb, mrb_value obj)\n{\n  struct RBasic *p;\n  mrb_value dup;\n\n  if (mrb_immediate_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't dup %S\", obj);\n  }\n  if (mrb_type(obj) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't dup singleton class\");\n  }\n  p = mrb_obj_alloc(mrb, mrb_type(obj), mrb_obj_class(mrb, obj));\n  dup = mrb_obj_value(p);\n  init_copy(mrb, dup, obj);\n\n  return dup;\n}\n\nstatic mrb_value\nmrb_obj_extend(mrb_state *mrb, mrb_int argc, mrb_value *argv, mrb_value obj)\n{\n  mrb_int i;\n\n  if (argc == 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments (at least 1)\");\n  }\n  for (i = 0; i < argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_MODULE);\n  }\n  while (argc--) {\n    mrb_funcall(mrb, argv[argc], \"extend_object\", 1, obj);\n    mrb_funcall(mrb, argv[argc], \"extended\", 1, obj);\n  }\n  return obj;\n}\n\n/* 15.3.1.3.13 */\n/*\n *  call-seq:\n *     obj.extend(module, ...)    -> obj\n *\n *  Adds to _obj_ the instance methods from each module given as a\n *  parameter.\n *\n *     module Mod\n *       def hello\n *         \"Hello from Mod.\\n\"\n *       end\n *     end\n *\n *     class Klass\n *       def hello\n *         \"Hello from Klass.\\n\"\n *       end\n *     end\n *\n *     k = Klass.new\n *     k.hello         #=> \"Hello from Klass.\\n\"\n *     k.extend(Mod)   #=> #<Klass:0x401b3bc8>\n *     k.hello         #=> \"Hello from Mod.\\n\"\n */\nstatic mrb_value\nmrb_obj_extend_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value *argv;\n  mrb_int argc;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  return mrb_obj_extend(mrb, argc, argv, self);\n}\n\nstatic mrb_value\nmrb_obj_freeze(mrb_state *mrb, mrb_value self)\n{\n  struct RBasic *b;\n\n  switch (mrb_type(self)) {\n    case MRB_TT_FALSE:\n    case MRB_TT_TRUE:\n    case MRB_TT_FIXNUM:\n    case MRB_TT_SYMBOL:\n#ifndef MRB_WITHOUT_FLOAT\n    case MRB_TT_FLOAT:\n#endif\n      return self;\n    default:\n      break;\n  }\n\n  b = mrb_basic_ptr(self);\n  if (!MRB_FROZEN_P(b)) {\n    MRB_SET_FROZEN_FLAG(b);\n  }\n  return self;\n}\n\nstatic mrb_value\nmrb_obj_frozen(mrb_state *mrb, mrb_value self)\n{\n  struct RBasic *b;\n\n  switch (mrb_type(self)) {\n    case MRB_TT_FALSE:\n    case MRB_TT_TRUE:\n    case MRB_TT_FIXNUM:\n    case MRB_TT_SYMBOL:\n#ifndef MRB_WITHOUT_FLOAT\n    case MRB_TT_FLOAT:\n#endif\n      return mrb_true_value();\n    default:\n      break;\n  }\n\n  b = mrb_basic_ptr(self);\n  if (!MRB_FROZEN_P(b)) {\n    return mrb_false_value();\n  }\n  return mrb_true_value();\n}\n\n/* 15.3.1.3.15 */\n/*\n *  call-seq:\n *     obj.hash    -> fixnum\n *\n *  Generates a <code>Fixnum</code> hash value for this object. This\n *  function must have the property that <code>a.eql?(b)</code> implies\n *  <code>a.hash == b.hash</code>. The hash value is used by class\n *  <code>Hash</code>. Any hash value that exceeds the capacity of a\n *  <code>Fixnum</code> will be truncated before being used.\n */\nMRB_API mrb_value\nmrb_obj_hash(mrb_state *mrb, mrb_value self)\n{\n  return mrb_fixnum_value(mrb_obj_id(self));\n}\n\n/* 15.3.1.3.16 */\nstatic mrb_value\nmrb_obj_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value orig;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  if (mrb_obj_equal(mrb, self, orig)) return self;\n  if ((mrb_type(self) != mrb_type(orig)) || (mrb_obj_class(mrb, self) != mrb_obj_class(mrb, orig))) {\n      mrb_raise(mrb, E_TYPE_ERROR, \"initialize_copy should take same class object\");\n  }\n  return self;\n}\n\n\nMRB_API mrb_bool\nmrb_obj_is_instance_of(mrb_state *mrb, mrb_value obj, struct RClass* c)\n{\n  if (mrb_obj_class(mrb, obj) == c) return TRUE;\n  return FALSE;\n}\n\n/* 15.3.1.3.19 */\n/*\n *  call-seq:\n *     obj.instance_of?(class)    -> true or false\n *\n *  Returns <code>true</code> if <i>obj</i> is an instance of the given\n *  class. See also <code>Object#kind_of?</code>.\n */\nstatic mrb_value\nobj_is_instance_of(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"C\", &arg);\n\n  return mrb_bool_value(mrb_obj_is_instance_of(mrb, self, mrb_class_ptr(arg)));\n}\n\n/* 15.3.1.3.20 */\n/*\n *  call-seq:\n *     obj.instance_variable_defined?(symbol)    -> true or false\n *\n *  Returns <code>true</code> if the given instance variable is\n *  defined in <i>obj</i>.\n *\n *     class Fred\n *       def initialize(p1, p2)\n *         @a, @b = p1, p2\n *       end\n *     end\n *     fred = Fred.new('cat', 99)\n *     fred.instance_variable_defined?(:@a)    #=> true\n *     fred.instance_variable_defined?(\"@b\")   #=> true\n *     fred.instance_variable_defined?(\"@c\")   #=> false\n */\nstatic mrb_value\nmrb_obj_ivar_defined(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb_iv_check(mrb, sym);\n  return mrb_bool_value(mrb_iv_defined(mrb, self, sym));\n}\n\n/* 15.3.1.3.21 */\n/*\n *  call-seq:\n *     obj.instance_variable_get(symbol)    -> obj\n *\n *  Returns the value of the given instance variable, or nil if the\n *  instance variable is not set. The <code>@</code> part of the\n *  variable name should be included for regular instance\n *  variables. Throws a <code>NameError</code> exception if the\n *  supplied symbol is not valid as an instance variable name.\n *\n *     class Fred\n *       def initialize(p1, p2)\n *         @a, @b = p1, p2\n *       end\n *     end\n *     fred = Fred.new('cat', 99)\n *     fred.instance_variable_get(:@a)    #=> \"cat\"\n *     fred.instance_variable_get(\"@b\")   #=> 99\n */\nstatic mrb_value\nmrb_obj_ivar_get(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym iv_name;\n\n  mrb_get_args(mrb, \"n\", &iv_name);\n  mrb_iv_check(mrb, iv_name);\n  return mrb_iv_get(mrb, self, iv_name);\n}\n\n/* 15.3.1.3.22 */\n/*\n *  call-seq:\n *     obj.instance_variable_set(symbol, obj)    -> obj\n *\n *  Sets the instance variable names by <i>symbol</i> to\n *  <i>object</i>, thereby frustrating the efforts of the class's\n *  author to attempt to provide proper encapsulation. The variable\n *  did not have to exist prior to this call.\n *\n *     class Fred\n *       def initialize(p1, p2)\n *         @a, @b = p1, p2\n *       end\n *     end\n *     fred = Fred.new('cat', 99)\n *     fred.instance_variable_set(:@a, 'dog')   #=> \"dog\"\n *     fred.instance_variable_set(:@c, 'cat')   #=> \"cat\"\n *     fred.inspect                             #=> \"#<Fred:0x401b3da8 @a=\\\"dog\\\", @b=99, @c=\\\"cat\\\">\"\n */\nstatic mrb_value\nmrb_obj_ivar_set(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym iv_name;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"no\", &iv_name, &val);\n  mrb_iv_check(mrb, iv_name);\n  mrb_iv_set(mrb, self, iv_name, val);\n  return val;\n}\n\n/* 15.3.1.3.24 */\n/* 15.3.1.3.26 */\n/*\n *  call-seq:\n *     obj.is_a?(class)       -> true or false\n *     obj.kind_of?(class)    -> true or false\n *\n *  Returns <code>true</code> if <i>class</i> is the class of\n *  <i>obj</i>, or if <i>class</i> is one of the superclasses of\n *  <i>obj</i> or modules included in <i>obj</i>.\n *\n *     module M;    end\n *     class A\n *       include M\n *     end\n *     class B < A; end\n *     class C < B; end\n *     b = B.new\n *     b.instance_of? A   #=> false\n *     b.instance_of? B   #=> true\n *     b.instance_of? C   #=> false\n *     b.instance_of? M   #=> false\n *     b.kind_of? A       #=> true\n *     b.kind_of? B       #=> true\n *     b.kind_of? C       #=> false\n *     b.kind_of? M       #=> true\n */\nstatic mrb_value\nmrb_obj_is_kind_of_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"C\", &arg);\n\n  return mrb_bool_value(mrb_obj_is_kind_of(mrb, self, mrb_class_ptr(arg)));\n}\n\nKHASH_DECLARE(st, mrb_sym, char, FALSE)\nKHASH_DEFINE(st, mrb_sym, char, FALSE, kh_int_hash_func, kh_int_hash_equal)\n\nstatic void\nmethod_entry_loop(mrb_state *mrb, struct RClass* klass, khash_t(st)* set)\n{\n  khint_t i;\n\n  khash_t(mt) *h = klass->mt;\n  if (!h || kh_size(h) == 0) return;\n  for (i=0;i<kh_end(h);i++) {\n    if (kh_exist(h, i)) {\n      mrb_method_t m = kh_value(h, i);\n      if (MRB_METHOD_UNDEF_P(m)) continue;\n      kh_put(st, mrb, set, kh_key(h, i));\n    }\n  }\n}\n\nmrb_value\nmrb_class_instance_method_list(mrb_state *mrb, mrb_bool recur, struct RClass* klass, int obj)\n{\n  khint_t i;\n  mrb_value ary;\n  mrb_bool prepended = FALSE;\n  struct RClass* oldklass;\n  khash_t(st)* set = kh_init(st, mrb);\n\n  if (!recur && (klass->flags & MRB_FLAG_IS_PREPENDED)) {\n    MRB_CLASS_ORIGIN(klass);\n    prepended = TRUE;\n  }\n\n  oldklass = 0;\n  while (klass && (klass != oldklass)) {\n    method_entry_loop(mrb, klass, set);\n    if ((klass->tt == MRB_TT_ICLASS && !prepended) ||\n        (klass->tt == MRB_TT_SCLASS)) {\n    }\n    else {\n      if (!recur) break;\n    }\n    oldklass = klass;\n    klass = klass->super;\n  }\n\n  ary = mrb_ary_new_capa(mrb, kh_size(set));\n  for (i=0;i<kh_end(set);i++) {\n    if (kh_exist(set, i)) {\n      mrb_ary_push(mrb, ary, mrb_symbol_value(kh_key(set, i)));\n    }\n  }\n  kh_destroy(st, mrb, set);\n\n  return ary;\n}\n\nstatic mrb_value\nmrb_obj_singleton_methods(mrb_state *mrb, mrb_bool recur, mrb_value obj)\n{\n  khint_t i;\n  mrb_value ary;\n  struct RClass* klass;\n  khash_t(st)* set = kh_init(st, mrb);\n\n  klass = mrb_class(mrb, obj);\n\n  if (klass && (klass->tt == MRB_TT_SCLASS)) {\n      method_entry_loop(mrb, klass, set);\n      klass = klass->super;\n  }\n  if (recur) {\n      while (klass && ((klass->tt == MRB_TT_SCLASS) || (klass->tt == MRB_TT_ICLASS))) {\n        method_entry_loop(mrb, klass, set);\n        klass = klass->super;\n      }\n  }\n\n  ary = mrb_ary_new(mrb);\n  for (i=0;i<kh_end(set);i++) {\n    if (kh_exist(set, i)) {\n      mrb_ary_push(mrb, ary, mrb_symbol_value(kh_key(set, i)));\n    }\n  }\n  kh_destroy(st, mrb, set);\n\n  return ary;\n}\n\nstatic mrb_value\nmrb_obj_methods(mrb_state *mrb, mrb_bool recur, mrb_value obj, mrb_method_flag_t flag)\n{\n  return mrb_class_instance_method_list(mrb, recur, mrb_class(mrb, obj), 0);\n}\n/* 15.3.1.3.31 */\n/*\n *  call-seq:\n *     obj.methods    -> array\n *\n *  Returns a list of the names of methods publicly accessible in\n *  <i>obj</i>. This will include all the methods accessible in\n *  <i>obj</i>'s ancestors.\n *\n *     class Klass\n *       def kMethod()\n *       end\n *     end\n *     k = Klass.new\n *     k.methods[0..9]    #=> [:kMethod, :respond_to?, :nil?, :is_a?,\n *                        #    :class, :instance_variable_set,\n *                        #    :methods, :extend, :__send__, :instance_eval]\n *     k.methods.length   #=> 42\n */\nstatic mrb_value\nmrb_obj_methods_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, (mrb_method_flag_t)0); /* everything but private */\n}\n\n/* 15.3.1.3.32 */\n/*\n * call_seq:\n *   nil.nil?               -> true\n *   <anything_else>.nil?   -> false\n *\n * Only the object <i>nil</i> responds <code>true</code> to <code>nil?</code>.\n */\nstatic mrb_value\nmrb_false(mrb_state *mrb, mrb_value self)\n{\n  return mrb_false_value();\n}\n\n/* 15.3.1.3.36 */\n/*\n *  call-seq:\n *     obj.private_methods(all=true)   -> array\n *\n *  Returns the list of private methods accessible to <i>obj</i>. If\n *  the <i>all</i> parameter is set to <code>false</code>, only those methods\n *  in the receiver will be listed.\n */\nstatic mrb_value\nmrb_obj_private_methods(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, NOEX_PRIVATE); /* private attribute not define */\n}\n\n/* 15.3.1.3.37 */\n/*\n *  call-seq:\n *     obj.protected_methods(all=true)   -> array\n *\n *  Returns the list of protected methods accessible to <i>obj</i>. If\n *  the <i>all</i> parameter is set to <code>false</code>, only those methods\n *  in the receiver will be listed.\n */\nstatic mrb_value\nmrb_obj_protected_methods(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, NOEX_PROTECTED); /* protected attribute not define */\n}\n\n/* 15.3.1.3.38 */\n/*\n *  call-seq:\n *     obj.public_methods(all=true)   -> array\n *\n *  Returns the list of public methods accessible to <i>obj</i>. If\n *  the <i>all</i> parameter is set to <code>false</code>, only those methods\n *  in the receiver will be listed.\n */\nstatic mrb_value\nmrb_obj_public_methods(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, NOEX_PUBLIC); /* public attribute not define */\n}\n\n/* 15.3.1.2.12  */\n/* 15.3.1.3.40 */\n/*\n *  call-seq:\n *     raise\n *     raise(string)\n *     raise(exception [, string])\n *\n *  With no arguments, raises a <code>RuntimeError</code>\n *  With a single +String+ argument, raises a\n *  +RuntimeError+ with the string as a message. Otherwise,\n *  the first parameter should be the name of an +Exception+\n *  class (or an object that returns an +Exception+ object when sent\n *  an +exception+ message). The optional second parameter sets the\n *  message associated with the exception, and the third parameter is an\n *  array of callback information. Exceptions are caught by the\n *  +rescue+ clause of <code>begin...end</code> blocks.\n *\n *     raise \"Failed to create socket\"\n *     raise ArgumentError, \"No parameters\", caller\n */\nMRB_API mrb_value\nmrb_f_raise(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a[2], exc;\n  mrb_int argc;\n\n\n  argc = mrb_get_args(mrb, \"|oo\", &a[0], &a[1]);\n  switch (argc) {\n  case 0:\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"\");\n    break;\n  case 1:\n    if (mrb_string_p(a[0])) {\n      a[1] = a[0];\n      argc = 2;\n      a[0] = mrb_obj_value(E_RUNTIME_ERROR);\n    }\n    /* fall through */\n  default:\n    exc = mrb_make_exception(mrb, argc, a);\n    mrb_exc_raise(mrb, exc);\n    break;\n  }\n  return mrb_nil_value();            /* not reached */\n}\n\nstatic mrb_value\nmrb_krn_class_defined(mrb_state *mrb, mrb_value self)\n{\n  mrb_value str;\n\n  mrb_get_args(mrb, \"S\", &str);\n  return mrb_bool_value(mrb_class_defined(mrb, RSTRING_PTR(str)));\n}\n\n\n/* 15.3.1.3.41 */\n/*\n *  call-seq:\n *     obj.remove_instance_variable(symbol)    -> obj\n *\n *  Removes the named instance variable from <i>obj</i>, returning that\n *  variable's value.\n *\n *     class Dummy\n *       attr_reader :var\n *       def initialize\n *         @var = 99\n *       end\n *       def remove\n *         remove_instance_variable(:@var)\n *       end\n *     end\n *     d = Dummy.new\n *     d.var      #=> 99\n *     d.remove   #=> 99\n *     d.var      #=> nil\n */\nstatic mrb_value\nmrb_obj_remove_instance_variable(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym sym;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb_iv_check(mrb, sym);\n  val = mrb_iv_remove(mrb, self, sym);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, sym, \"instance variable %S not defined\", mrb_sym2str(mrb, sym));\n  }\n  return val;\n}\n\nvoid\nmrb_method_missing(mrb_state *mrb, mrb_sym name, mrb_value self, mrb_value args)\n{\n  mrb_no_method_error(mrb, name, args, \"undefined method '%S'\", mrb_sym2str(mrb, name));\n}\n\n/* 15.3.1.3.30 */\n/*\n *  call-seq:\n *     obj.method_missing(symbol [, *args] )   -> result\n *\n *  Invoked by Ruby when <i>obj</i> is sent a message it cannot handle.\n *  <i>symbol</i> is the symbol for the method called, and <i>args</i>\n *  are any arguments that were passed to it. By default, the interpreter\n *  raises an error when this method is called. However, it is possible\n *  to override the method to provide more dynamic behavior.\n *  If it is decided that a particular method should not be handled, then\n *  <i>super</i> should be called, so that ancestors can pick up the\n *  missing method.\n *  The example below creates\n *  a class <code>Roman</code>, which responds to methods with names\n *  consisting of roman numerals, returning the corresponding integer\n *  values.\n *\n *     class Roman\n *       def romanToInt(str)\n *         # ...\n *       end\n *       def method_missing(methId)\n *         str = methId.id2name\n *         romanToInt(str)\n *       end\n *     end\n *\n *     r = Roman.new\n *     r.iv      #=> 4\n *     r.xxiii   #=> 23\n *     r.mm      #=> 2000\n */\n#ifdef MRB_DEFAULT_METHOD_MISSING\nstatic mrb_value\nmrb_obj_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym name;\n  mrb_value *a;\n  mrb_int alen;\n\n  mrb_get_args(mrb, \"n*!\", &name, &a, &alen);\n  mrb_method_missing(mrb, name, mod, mrb_ary_new_from_values(mrb, alen, a));\n  /* not reached */\n  return mrb_nil_value();\n}\n#endif\n\nstatic inline mrb_bool\nbasic_obj_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym id, int pub)\n{\n  return mrb_respond_to(mrb, obj, id);\n}\n/* 15.3.1.3.43 */\n/*\n *  call-seq:\n *     obj.respond_to?(symbol, include_private=false) -> true or false\n *\n *  Returns +true+ if _obj_ responds to the given\n *  method. Private methods are included in the search only if the\n *  optional second parameter evaluates to +true+.\n *\n *  If the method is not implemented,\n *  as Process.fork on Windows, File.lchmod on GNU/Linux, etc.,\n *  false is returned.\n *\n *  If the method is not defined, <code>respond_to_missing?</code>\n *  method is called and the result is returned.\n */\nstatic mrb_value\nobj_respond_to(mrb_state *mrb, mrb_value self)\n{\n  mrb_value mid;\n  mrb_sym id, rtm_id;\n  mrb_bool priv = FALSE, respond_to_p = TRUE;\n\n  mrb_get_args(mrb, \"o|b\", &mid, &priv);\n\n  if (mrb_symbol_p(mid)) {\n    id = mrb_symbol(mid);\n  }\n  else {\n    mrb_value tmp;\n    if (mrb_string_p(mid)) {\n      tmp = mrb_check_intern_str(mrb, mid);\n    }\n    else {\n      tmp = mrb_check_string_type(mrb, mid);\n      if (mrb_nil_p(tmp)) {\n        tmp = mrb_inspect(mrb, mid);\n        mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a symbol\", tmp);\n      }\n      tmp = mrb_check_intern_str(mrb, tmp);\n    }\n    if (mrb_nil_p(tmp)) {\n      respond_to_p = FALSE;\n    }\n    else {\n      id = mrb_symbol(tmp);\n    }\n  }\n\n  if (respond_to_p) {\n    respond_to_p = basic_obj_respond_to(mrb, self, id, !priv);\n  }\n\n  if (!respond_to_p) {\n    rtm_id = mrb_intern_lit(mrb, \"respond_to_missing?\");\n    if (basic_obj_respond_to(mrb, self, rtm_id, !priv)) {\n      mrb_value args[2], v;\n      args[0] = mid;\n      args[1] = mrb_bool_value(priv);\n      v = mrb_funcall_argv(mrb, self, rtm_id, 2, args);\n      return mrb_bool_value(mrb_bool(v));\n    }\n  }\n  return mrb_bool_value(respond_to_p);\n}\n\n/* 15.3.1.3.45 */\n/*\n *  call-seq:\n *     obj.singleton_methods(all=true)    -> array\n *\n *  Returns an array of the names of singleton methods for <i>obj</i>.\n *  If the optional <i>all</i> parameter is true, the list will include\n *  methods in modules included in <i>obj</i>.\n *  Only public and protected singleton methods are returned.\n *\n *     module Other\n *       def three() end\n *     end\n *\n *     class Single\n *       def Single.four() end\n *     end\n *\n *     a = Single.new\n *\n *     def a.one()\n *     end\n *\n *     class << a\n *       include Other\n *       def two()\n *       end\n *     end\n *\n *     Single.singleton_methods    #=> [:four]\n *     a.singleton_methods(false)  #=> [:two, :one]\n *     a.singleton_methods         #=> [:two, :one, :three]\n */\nstatic mrb_value\nmrb_obj_singleton_methods_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_singleton_methods(mrb, recur, self);\n}\n\nstatic mrb_value\nmod_define_singleton_method(mrb_state *mrb, mrb_value self)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value blk = mrb_nil_value();\n\n  mrb_get_args(mrb, \"n&\", &mid, &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, mrb_class_ptr(mrb_singleton_class(mrb, self)), mid, m);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\nmrb_obj_ceqq(mrb_state *mrb, mrb_value self)\n{\n  mrb_value v;\n  mrb_int i, len;\n  mrb_sym eqq = mrb_intern_lit(mrb, \"===\");\n  mrb_value ary = mrb_ary_splat(mrb, self);\n\n  mrb_get_args(mrb, \"o\", &v);\n  len = RARRAY_LEN(ary);\n  for (i=0; i<len; i++) {\n    mrb_value c = mrb_funcall_argv(mrb, mrb_ary_entry(ary, i), eqq, 1, &v);\n    if (mrb_test(c)) return mrb_true_value();\n  }\n  return mrb_false_value();\n}\n\n/* 15.3.1.2.7 */\n/*\n *  call-seq:\n *     local_variables   -> array\n *\n *  Returns the names of local variables in the current scope.\n *\n *  [mruby limitation]\n *  If variable symbol information was stripped out from\n *  compiled binary files using `mruby-strip -l`, this\n *  method always returns an empty array.\n */\nstatic mrb_value\nmrb_local_variables(mrb_state *mrb, mrb_value self)\n{\n  struct RProc *proc;\n  mrb_irep *irep;\n  mrb_value vars;\n  size_t i;\n\n  proc = mrb->c->ci[-1].proc;\n\n  if (MRB_PROC_CFUNC_P(proc)) {\n    return mrb_ary_new(mrb);\n  }\n  vars = mrb_hash_new(mrb);\n  while (proc) {\n    if (MRB_PROC_CFUNC_P(proc)) break;\n    irep = proc->body.irep;\n    if (!irep->lv) break;\n    for (i = 0; i + 1 < irep->nlocals; ++i) {\n      if (irep->lv[i].name) {\n        mrb_hash_set(mrb, vars, mrb_symbol_value(irep->lv[i].name), mrb_true_value());\n      }\n    }\n    if (!MRB_PROC_ENV_P(proc)) break;\n    proc = proc->upper;\n    //if (MRB_PROC_SCOPE_P(proc)) break;\n    if (!proc->c) break;\n  }\n\n  return mrb_hash_keys(mrb, vars);\n}\n\nmrb_value mrb_obj_equal_m(mrb_state *mrb, mrb_value);\nvoid\nmrb_init_kernel(mrb_state *mrb)\n{\n  struct RClass *krn;\n\n  mrb->kernel_module = krn = mrb_define_module(mrb, \"Kernel\");                                                    /* 15.3.1 */\n  mrb_define_class_method(mrb, krn, \"block_given?\",         mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.2.2  */\n  mrb_define_class_method(mrb, krn, \"global_variables\",     mrb_f_global_variables,          MRB_ARGS_NONE());    /* 15.3.1.2.4  */\n  mrb_define_class_method(mrb, krn, \"iterator?\",            mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.2.5  */\n  mrb_define_class_method(mrb, krn, \"local_variables\",      mrb_local_variables,             MRB_ARGS_NONE());    /* 15.3.1.2.7  */\n;     /* 15.3.1.2.11 */\n  mrb_define_class_method(mrb, krn, \"raise\",                mrb_f_raise,                     MRB_ARGS_OPT(2));    /* 15.3.1.2.12 */\n\n  mrb_define_method(mrb, krn, \"singleton_class\",            mrb_singleton_class,             MRB_ARGS_NONE());\n\n  mrb_define_method(mrb, krn, \"===\",                        mrb_equal_m,                     MRB_ARGS_REQ(1));    /* 15.3.1.3.2  */\n  mrb_define_method(mrb, krn, \"block_given?\",               mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.3.6  */\n  mrb_define_method(mrb, krn, \"class\",                      mrb_obj_class_m,                 MRB_ARGS_NONE());    /* 15.3.1.3.7  */\n  mrb_define_method(mrb, krn, \"clone\",                      mrb_obj_clone,                   MRB_ARGS_NONE());    /* 15.3.1.3.8  */\n  mrb_define_method(mrb, krn, \"dup\",                        mrb_obj_dup,                     MRB_ARGS_NONE());    /* 15.3.1.3.9  */\n  mrb_define_method(mrb, krn, \"eql?\",                       mrb_obj_equal_m,                 MRB_ARGS_REQ(1));    /* 15.3.1.3.10 */\n  mrb_define_method(mrb, krn, \"equal?\",                     mrb_obj_equal_m,                 MRB_ARGS_REQ(1));    /* 15.3.1.3.11 */\n  mrb_define_method(mrb, krn, \"extend\",                     mrb_obj_extend_m,                MRB_ARGS_ANY());     /* 15.3.1.3.13 */\n  mrb_define_method(mrb, krn, \"freeze\",                     mrb_obj_freeze,                  MRB_ARGS_NONE());\n  mrb_define_method(mrb, krn, \"frozen?\",                    mrb_obj_frozen,                  MRB_ARGS_NONE());\n  mrb_define_method(mrb, krn, \"global_variables\",           mrb_f_global_variables,          MRB_ARGS_NONE());    /* 15.3.1.3.14 */\n  mrb_define_method(mrb, krn, \"hash\",                       mrb_obj_hash,                    MRB_ARGS_NONE());    /* 15.3.1.3.15 */\n  mrb_define_method(mrb, krn, \"initialize_copy\",            mrb_obj_init_copy,               MRB_ARGS_REQ(1));    /* 15.3.1.3.16 */\n  mrb_define_method(mrb, krn, \"inspect\",                    mrb_obj_inspect,                 MRB_ARGS_NONE());    /* 15.3.1.3.17 */\n  mrb_define_method(mrb, krn, \"instance_of?\",               obj_is_instance_of,              MRB_ARGS_REQ(1));    /* 15.3.1.3.19 */\n  mrb_define_method(mrb, krn, \"instance_variable_defined?\", mrb_obj_ivar_defined,            MRB_ARGS_REQ(1));    /* 15.3.1.3.20 */\n  mrb_define_method(mrb, krn, \"instance_variable_get\",      mrb_obj_ivar_get,                MRB_ARGS_REQ(1));    /* 15.3.1.3.21 */\n  mrb_define_method(mrb, krn, \"instance_variable_set\",      mrb_obj_ivar_set,                MRB_ARGS_REQ(2));    /* 15.3.1.3.22 */\n  mrb_define_method(mrb, krn, \"instance_variables\",         mrb_obj_instance_variables,      MRB_ARGS_NONE());    /* 15.3.1.3.23 */\n  mrb_define_method(mrb, krn, \"is_a?\",                      mrb_obj_is_kind_of_m,            MRB_ARGS_REQ(1));    /* 15.3.1.3.24 */\n  mrb_define_method(mrb, krn, \"iterator?\",                  mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.3.25 */\n  mrb_define_method(mrb, krn, \"kind_of?\",                   mrb_obj_is_kind_of_m,            MRB_ARGS_REQ(1));    /* 15.3.1.3.26 */\n  mrb_define_method(mrb, krn, \"local_variables\",            mrb_local_variables,             MRB_ARGS_NONE());    /* 15.3.1.3.28 */\n#ifdef MRB_DEFAULT_METHOD_MISSING\n  mrb_define_method(mrb, krn, \"method_missing\",             mrb_obj_missing,                 MRB_ARGS_ANY());     /* 15.3.1.3.30 */\n#endif\n  mrb_define_method(mrb, krn, \"methods\",                    mrb_obj_methods_m,               MRB_ARGS_OPT(1));    /* 15.3.1.3.31 */\n  mrb_define_method(mrb, krn, \"nil?\",                       mrb_false,                       MRB_ARGS_NONE());    /* 15.3.1.3.32 */\n  mrb_define_method(mrb, krn, \"object_id\",                  mrb_obj_id_m,                    MRB_ARGS_NONE());    /* 15.3.1.3.33 */\n  mrb_define_method(mrb, krn, \"private_methods\",            mrb_obj_private_methods,         MRB_ARGS_OPT(1));    /* 15.3.1.3.36 */\n  mrb_define_method(mrb, krn, \"protected_methods\",          mrb_obj_protected_methods,       MRB_ARGS_OPT(1));    /* 15.3.1.3.37 */\n  mrb_define_method(mrb, krn, \"public_methods\",             mrb_obj_public_methods,          MRB_ARGS_OPT(1));    /* 15.3.1.3.38 */\n  mrb_define_method(mrb, krn, \"raise\",                      mrb_f_raise,                     MRB_ARGS_ANY());     /* 15.3.1.3.40 */\n  mrb_define_method(mrb, krn, \"remove_instance_variable\",   mrb_obj_remove_instance_variable,MRB_ARGS_REQ(1));    /* 15.3.1.3.41 */\n  mrb_define_method(mrb, krn, \"respond_to?\",                obj_respond_to,                  MRB_ARGS_ANY());     /* 15.3.1.3.43 */\n  mrb_define_method(mrb, krn, \"send\",                       mrb_f_send,                      MRB_ARGS_ANY());     /* 15.3.1.3.44 */\n  mrb_define_method(mrb, krn, \"singleton_methods\",          mrb_obj_singleton_methods_m,     MRB_ARGS_OPT(1));    /* 15.3.1.3.45 */\n  mrb_define_method(mrb, krn, \"define_singleton_method\",    mod_define_singleton_method,     MRB_ARGS_ANY());\n  mrb_define_method(mrb, krn, \"to_s\",                       mrb_any_to_s,                    MRB_ARGS_NONE());    /* 15.3.1.3.46 */\n  mrb_define_method(mrb, krn, \"__case_eqq\",                 mrb_obj_ceqq,                    MRB_ARGS_REQ(1));    /* internal */\n\n  mrb_define_method(mrb, krn, \"class_defined?\",             mrb_krn_class_defined,           MRB_ARGS_REQ(1));\n\n  mrb_include_module(mrb, mrb->object_class, mrb->kernel_module);\n  mrb_alias_method(mrb, mrb->module_class, mrb_intern_lit(mrb, \"dup\"), mrb_intern_lit(mrb, \"clone\"));\n}\n"], "fixing_code": ["/*\n** kernel.c - Kernel module\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/hash.h>\n#include <mruby/class.h>\n#include <mruby/proc.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/istruct.h>\n\ntypedef enum {\n  NOEX_PUBLIC    = 0x00,\n  NOEX_NOSUPER   = 0x01,\n  NOEX_PRIVATE   = 0x02,\n  NOEX_PROTECTED = 0x04,\n  NOEX_MASK      = 0x06,\n  NOEX_BASIC     = 0x08,\n  NOEX_UNDEF     = NOEX_NOSUPER,\n  NOEX_MODFUNC   = 0x12,\n  NOEX_SUPER     = 0x20,\n  NOEX_VCALL     = 0x40,\n  NOEX_RESPONDS  = 0x80\n} mrb_method_flag_t;\n\nMRB_API mrb_bool\nmrb_func_basic_p(mrb_state *mrb, mrb_value obj, mrb_sym mid, mrb_func_t func)\n{\n  mrb_method_t m = mrb_method_search(mrb, mrb_class(mrb, obj), mid);\n  struct RProc *p;\n\n  if (MRB_METHOD_UNDEF_P(m)) return FALSE;\n  if (MRB_METHOD_FUNC_P(m))\n    return MRB_METHOD_FUNC(m) == func;\n  p = MRB_METHOD_PROC(m);\n  if (MRB_PROC_CFUNC_P(p) && (MRB_PROC_CFUNC(p) == func))\n    return TRUE;\n  return FALSE;\n}\n\nstatic mrb_bool\nmrb_obj_basic_to_s_p(mrb_state *mrb, mrb_value obj)\n{\n  return mrb_func_basic_p(mrb, obj, mrb_intern_lit(mrb, \"to_s\"), mrb_any_to_s);\n}\n\n/* 15.3.1.3.17 */\n/*\n *  call-seq:\n *     obj.inspect   -> string\n *\n *  Returns a string containing a human-readable representation of\n *  <i>obj</i>. If not overridden and no instance variables, uses the\n *  <code>to_s</code> method to generate the string.\n *  <i>obj</i>.  If not overridden, uses the <code>to_s</code> method to\n *  generate the string.\n *\n *     [ 1, 2, 3..4, 'five' ].inspect   #=> \"[1, 2, 3..4, \\\"five\\\"]\"\n *     Time.new.inspect                 #=> \"2008-03-08 19:43:39 +0900\"\n */\nMRB_API mrb_value\nmrb_obj_inspect(mrb_state *mrb, mrb_value obj)\n{\n  if ((mrb_type(obj) == MRB_TT_OBJECT) && mrb_obj_basic_to_s_p(mrb, obj)) {\n    return mrb_obj_iv_inspect(mrb, mrb_obj_ptr(obj));\n  }\n  return mrb_any_to_s(mrb, obj);\n}\n\n/* 15.3.1.3.2  */\n/*\n *  call-seq:\n *     obj === other   -> true or false\n *\n *  Case Equality---For class <code>Object</code>, effectively the same\n *  as calling  <code>#==</code>, but typically overridden by descendants\n *  to provide meaningful semantics in <code>case</code> statements.\n */\nstatic mrb_value\nmrb_equal_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"o\", &arg);\n  return mrb_bool_value(mrb_equal(mrb, self, arg));\n}\n\n/* 15.3.1.3.3  */\n/* 15.3.1.3.33 */\n/*\n *  Document-method: __id__\n *  Document-method: object_id\n *\n *  call-seq:\n *     obj.__id__       -> fixnum\n *     obj.object_id    -> fixnum\n *\n *  Returns an integer identifier for <i>obj</i>. The same number will\n *  be returned on all calls to <code>id</code> for a given object, and\n *  no two active objects will share an id.\n *  <code>Object#object_id</code> is a different concept from the\n *  <code>:name</code> notation, which returns the symbol id of\n *  <code>name</code>. Replaces the deprecated <code>Object#id</code>.\n */\nmrb_value\nmrb_obj_id_m(mrb_state *mrb, mrb_value self)\n{\n  return mrb_fixnum_value(mrb_obj_id(self));\n}\n\n/* 15.3.1.2.2  */\n/* 15.3.1.2.5  */\n/* 15.3.1.3.6  */\n/* 15.3.1.3.25 */\n/*\n *  call-seq:\n *     block_given?   -> true or false\n *     iterator?      -> true or false\n *\n *  Returns <code>true</code> if <code>yield</code> would execute a\n *  block in the current context. The <code>iterator?</code> form\n *  is mildly deprecated.\n *\n *     def try\n *       if block_given?\n *         yield\n *       else\n *         \"no block\"\n *       end\n *     end\n *     try                  #=> \"no block\"\n *     try { \"hello\" }      #=> \"hello\"\n *     try do \"hello\" end   #=> \"hello\"\n */\nstatic mrb_value\nmrb_f_block_given_p_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_callinfo *ci = &mrb->c->ci[-1];\n  mrb_callinfo *cibase = mrb->c->cibase;\n  mrb_value *bp;\n  struct RProc *p;\n\n  if (ci <= cibase) {\n    /* toplevel does not have block */\n    return mrb_false_value();\n  }\n  p = ci->proc;\n  /* search method/class/module proc */\n  while (p) {\n    if (MRB_PROC_SCOPE_P(p)) break;\n    p = p->upper;\n  }\n  if (p == NULL) return mrb_false_value();\n  /* search ci corresponding to proc */\n  while (cibase < ci) {\n    if (ci->proc == p) break;\n    ci--;\n  }\n  if (ci == cibase) {\n    return mrb_false_value();\n  }\n  else if (ci->env) {\n    struct REnv *e = ci->env;\n    int bidx;\n\n    /* top-level does not have block slot (always false) */\n    if (e->stack == mrb->c->stbase)\n      return mrb_false_value();\n    /* use saved block arg position */\n    bidx = MRB_ENV_BIDX(e);\n    /* bidx may be useless (e.g. define_method) */\n    if (bidx >= MRB_ENV_STACK_LEN(e))\n      return mrb_false_value();\n    bp = &e->stack[bidx];\n  }\n  else {\n    bp = ci[1].stackent+1;\n    if (ci->argc >= 0) {\n      bp += ci->argc;\n    }\n    else {\n      bp++;\n    }\n  }\n  if (mrb_nil_p(*bp))\n    return mrb_false_value();\n  return mrb_true_value();\n}\n\n/* 15.3.1.3.7  */\n/*\n *  call-seq:\n *     obj.class    -> class\n *\n *  Returns the class of <i>obj</i>. This method must always be\n *  called with an explicit receiver, as <code>class</code> is also a\n *  reserved word in Ruby.\n *\n *     1.class      #=> Fixnum\n *     self.class   #=> Object\n */\nstatic mrb_value\nmrb_obj_class_m(mrb_state *mrb, mrb_value self)\n{\n  return mrb_obj_value(mrb_obj_class(mrb, self));\n}\n\nstatic struct RClass*\nmrb_singleton_class_clone(mrb_state *mrb, mrb_value obj)\n{\n  struct RClass *klass = mrb_basic_ptr(obj)->c;\n\n  if (klass->tt != MRB_TT_SCLASS)\n    return klass;\n  else {\n    /* copy singleton(unnamed) class */\n    struct RClass *clone = (struct RClass*)mrb_obj_alloc(mrb, klass->tt, mrb->class_class);\n\n    switch (mrb_type(obj)) {\n    case MRB_TT_CLASS:\n    case MRB_TT_SCLASS:\n      break;\n    default:\n      clone->c = mrb_singleton_class_clone(mrb, mrb_obj_value(klass));\n      break;\n    }\n    clone->super = klass->super;\n    if (klass->iv) {\n      mrb_iv_copy(mrb, mrb_obj_value(clone), mrb_obj_value(klass));\n      mrb_obj_iv_set(mrb, (struct RObject*)clone, mrb_intern_lit(mrb, \"__attached__\"), obj);\n    }\n    if (klass->mt) {\n      clone->mt = kh_copy(mt, mrb, klass->mt);\n    }\n    else {\n      clone->mt = kh_init(mt, mrb);\n    }\n    clone->tt = MRB_TT_SCLASS;\n    return clone;\n  }\n}\n\nstatic void\ncopy_class(mrb_state *mrb, mrb_value dst, mrb_value src)\n{\n  struct RClass *dc = mrb_class_ptr(dst);\n  struct RClass *sc = mrb_class_ptr(src);\n  /* if the origin is not the same as the class, then the origin and\n     the current class need to be copied */\n  if (sc->flags & MRB_FLAG_IS_PREPENDED) {\n    struct RClass *c0 = sc->super;\n    struct RClass *c1 = dc;\n\n    /* copy prepended iclasses */\n    while (!(c0->flags & MRB_FLAG_IS_ORIGIN)) {\n      c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n      c1 = c1->super;\n      c0 = c0->super;\n    }\n    c1->super = mrb_class_ptr(mrb_obj_dup(mrb, mrb_obj_value(c0)));\n    c1->super->flags |= MRB_FLAG_IS_ORIGIN;\n  }\n  if (sc->mt) {\n    dc->mt = kh_copy(mt, mrb, sc->mt);\n  }\n  else {\n    dc->mt = kh_init(mt, mrb);\n  }\n  dc->super = sc->super;\n  MRB_SET_INSTANCE_TT(dc, MRB_INSTANCE_TT(sc));\n}\n\nstatic void\ninit_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}\n\n/* 15.3.1.3.8  */\n/*\n *  call-seq:\n *     obj.clone -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference. Copies\n *  the frozen state of <i>obj</i>. See also the discussion\n *  under <code>Object#dup</code>.\n *\n *     class Klass\n *        attr_accessor :str\n *     end\n *     s1 = Klass.new      #=> #<Klass:0x401b3a38>\n *     s1.str = \"Hello\"    #=> \"Hello\"\n *     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n *     s2.str[1,4] = \"i\"   #=> \"i\"\n *     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n *     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n *\n *  Some Class(True False Nil Symbol Fixnum Float) Object  cannot clone.\n */\nMRB_API mrb_value\nmrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n\n  return clone;\n}\n\n/* 15.3.1.3.9  */\n/*\n *  call-seq:\n *     obj.dup -> an_object\n *\n *  Produces a shallow copy of <i>obj</i>---the instance variables of\n *  <i>obj</i> are copied, but not the objects they reference.\n *  <code>dup</code> copies the frozen state of <i>obj</i>. See also\n *  the discussion under <code>Object#clone</code>. In general,\n *  <code>clone</code> and <code>dup</code> may have different semantics\n *  in descendant classes. While <code>clone</code> is used to duplicate\n *  an object, including its internal state, <code>dup</code> typically\n *  uses the class of the descendant object to create the new instance.\n *\n *  This method may have class-specific behavior.  If so, that\n *  behavior will be documented under the #+initialize_copy+ method of\n *  the class.\n */\n\nMRB_API mrb_value\nmrb_obj_dup(mrb_state *mrb, mrb_value obj)\n{\n  struct RBasic *p;\n  mrb_value dup;\n\n  if (mrb_immediate_p(obj)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't dup %S\", obj);\n  }\n  if (mrb_type(obj) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't dup singleton class\");\n  }\n  p = mrb_obj_alloc(mrb, mrb_type(obj), mrb_obj_class(mrb, obj));\n  dup = mrb_obj_value(p);\n  init_copy(mrb, dup, obj);\n\n  return dup;\n}\n\nstatic mrb_value\nmrb_obj_extend(mrb_state *mrb, mrb_int argc, mrb_value *argv, mrb_value obj)\n{\n  mrb_int i;\n\n  if (argc == 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments (at least 1)\");\n  }\n  for (i = 0; i < argc; i++) {\n    mrb_check_type(mrb, argv[i], MRB_TT_MODULE);\n  }\n  while (argc--) {\n    mrb_funcall(mrb, argv[argc], \"extend_object\", 1, obj);\n    mrb_funcall(mrb, argv[argc], \"extended\", 1, obj);\n  }\n  return obj;\n}\n\n/* 15.3.1.3.13 */\n/*\n *  call-seq:\n *     obj.extend(module, ...)    -> obj\n *\n *  Adds to _obj_ the instance methods from each module given as a\n *  parameter.\n *\n *     module Mod\n *       def hello\n *         \"Hello from Mod.\\n\"\n *       end\n *     end\n *\n *     class Klass\n *       def hello\n *         \"Hello from Klass.\\n\"\n *       end\n *     end\n *\n *     k = Klass.new\n *     k.hello         #=> \"Hello from Klass.\\n\"\n *     k.extend(Mod)   #=> #<Klass:0x401b3bc8>\n *     k.hello         #=> \"Hello from Mod.\\n\"\n */\nstatic mrb_value\nmrb_obj_extend_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value *argv;\n  mrb_int argc;\n\n  mrb_get_args(mrb, \"*\", &argv, &argc);\n  return mrb_obj_extend(mrb, argc, argv, self);\n}\n\nstatic mrb_value\nmrb_obj_freeze(mrb_state *mrb, mrb_value self)\n{\n  struct RBasic *b;\n\n  switch (mrb_type(self)) {\n    case MRB_TT_FALSE:\n    case MRB_TT_TRUE:\n    case MRB_TT_FIXNUM:\n    case MRB_TT_SYMBOL:\n#ifndef MRB_WITHOUT_FLOAT\n    case MRB_TT_FLOAT:\n#endif\n      return self;\n    default:\n      break;\n  }\n\n  b = mrb_basic_ptr(self);\n  if (!MRB_FROZEN_P(b)) {\n    MRB_SET_FROZEN_FLAG(b);\n  }\n  return self;\n}\n\nstatic mrb_value\nmrb_obj_frozen(mrb_state *mrb, mrb_value self)\n{\n  struct RBasic *b;\n\n  switch (mrb_type(self)) {\n    case MRB_TT_FALSE:\n    case MRB_TT_TRUE:\n    case MRB_TT_FIXNUM:\n    case MRB_TT_SYMBOL:\n#ifndef MRB_WITHOUT_FLOAT\n    case MRB_TT_FLOAT:\n#endif\n      return mrb_true_value();\n    default:\n      break;\n  }\n\n  b = mrb_basic_ptr(self);\n  if (!MRB_FROZEN_P(b)) {\n    return mrb_false_value();\n  }\n  return mrb_true_value();\n}\n\n/* 15.3.1.3.15 */\n/*\n *  call-seq:\n *     obj.hash    -> fixnum\n *\n *  Generates a <code>Fixnum</code> hash value for this object. This\n *  function must have the property that <code>a.eql?(b)</code> implies\n *  <code>a.hash == b.hash</code>. The hash value is used by class\n *  <code>Hash</code>. Any hash value that exceeds the capacity of a\n *  <code>Fixnum</code> will be truncated before being used.\n */\nMRB_API mrb_value\nmrb_obj_hash(mrb_state *mrb, mrb_value self)\n{\n  return mrb_fixnum_value(mrb_obj_id(self));\n}\n\n/* 15.3.1.3.16 */\nstatic mrb_value\nmrb_obj_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value orig;\n\n  mrb_get_args(mrb, \"o\", &orig);\n  if (mrb_obj_equal(mrb, self, orig)) return self;\n  if ((mrb_type(self) != mrb_type(orig)) || (mrb_obj_class(mrb, self) != mrb_obj_class(mrb, orig))) {\n      mrb_raise(mrb, E_TYPE_ERROR, \"initialize_copy should take same class object\");\n  }\n  return self;\n}\n\n\nMRB_API mrb_bool\nmrb_obj_is_instance_of(mrb_state *mrb, mrb_value obj, struct RClass* c)\n{\n  if (mrb_obj_class(mrb, obj) == c) return TRUE;\n  return FALSE;\n}\n\n/* 15.3.1.3.19 */\n/*\n *  call-seq:\n *     obj.instance_of?(class)    -> true or false\n *\n *  Returns <code>true</code> if <i>obj</i> is an instance of the given\n *  class. See also <code>Object#kind_of?</code>.\n */\nstatic mrb_value\nobj_is_instance_of(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"C\", &arg);\n\n  return mrb_bool_value(mrb_obj_is_instance_of(mrb, self, mrb_class_ptr(arg)));\n}\n\n/* 15.3.1.3.20 */\n/*\n *  call-seq:\n *     obj.instance_variable_defined?(symbol)    -> true or false\n *\n *  Returns <code>true</code> if the given instance variable is\n *  defined in <i>obj</i>.\n *\n *     class Fred\n *       def initialize(p1, p2)\n *         @a, @b = p1, p2\n *       end\n *     end\n *     fred = Fred.new('cat', 99)\n *     fred.instance_variable_defined?(:@a)    #=> true\n *     fred.instance_variable_defined?(\"@b\")   #=> true\n *     fred.instance_variable_defined?(\"@c\")   #=> false\n */\nstatic mrb_value\nmrb_obj_ivar_defined(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym sym;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb_iv_check(mrb, sym);\n  return mrb_bool_value(mrb_iv_defined(mrb, self, sym));\n}\n\n/* 15.3.1.3.21 */\n/*\n *  call-seq:\n *     obj.instance_variable_get(symbol)    -> obj\n *\n *  Returns the value of the given instance variable, or nil if the\n *  instance variable is not set. The <code>@</code> part of the\n *  variable name should be included for regular instance\n *  variables. Throws a <code>NameError</code> exception if the\n *  supplied symbol is not valid as an instance variable name.\n *\n *     class Fred\n *       def initialize(p1, p2)\n *         @a, @b = p1, p2\n *       end\n *     end\n *     fred = Fred.new('cat', 99)\n *     fred.instance_variable_get(:@a)    #=> \"cat\"\n *     fred.instance_variable_get(\"@b\")   #=> 99\n */\nstatic mrb_value\nmrb_obj_ivar_get(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym iv_name;\n\n  mrb_get_args(mrb, \"n\", &iv_name);\n  mrb_iv_check(mrb, iv_name);\n  return mrb_iv_get(mrb, self, iv_name);\n}\n\n/* 15.3.1.3.22 */\n/*\n *  call-seq:\n *     obj.instance_variable_set(symbol, obj)    -> obj\n *\n *  Sets the instance variable names by <i>symbol</i> to\n *  <i>object</i>, thereby frustrating the efforts of the class's\n *  author to attempt to provide proper encapsulation. The variable\n *  did not have to exist prior to this call.\n *\n *     class Fred\n *       def initialize(p1, p2)\n *         @a, @b = p1, p2\n *       end\n *     end\n *     fred = Fred.new('cat', 99)\n *     fred.instance_variable_set(:@a, 'dog')   #=> \"dog\"\n *     fred.instance_variable_set(:@c, 'cat')   #=> \"cat\"\n *     fred.inspect                             #=> \"#<Fred:0x401b3da8 @a=\\\"dog\\\", @b=99, @c=\\\"cat\\\">\"\n */\nstatic mrb_value\nmrb_obj_ivar_set(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym iv_name;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"no\", &iv_name, &val);\n  mrb_iv_check(mrb, iv_name);\n  mrb_iv_set(mrb, self, iv_name, val);\n  return val;\n}\n\n/* 15.3.1.3.24 */\n/* 15.3.1.3.26 */\n/*\n *  call-seq:\n *     obj.is_a?(class)       -> true or false\n *     obj.kind_of?(class)    -> true or false\n *\n *  Returns <code>true</code> if <i>class</i> is the class of\n *  <i>obj</i>, or if <i>class</i> is one of the superclasses of\n *  <i>obj</i> or modules included in <i>obj</i>.\n *\n *     module M;    end\n *     class A\n *       include M\n *     end\n *     class B < A; end\n *     class C < B; end\n *     b = B.new\n *     b.instance_of? A   #=> false\n *     b.instance_of? B   #=> true\n *     b.instance_of? C   #=> false\n *     b.instance_of? M   #=> false\n *     b.kind_of? A       #=> true\n *     b.kind_of? B       #=> true\n *     b.kind_of? C       #=> false\n *     b.kind_of? M       #=> true\n */\nstatic mrb_value\nmrb_obj_is_kind_of_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_value arg;\n\n  mrb_get_args(mrb, \"C\", &arg);\n\n  return mrb_bool_value(mrb_obj_is_kind_of(mrb, self, mrb_class_ptr(arg)));\n}\n\nKHASH_DECLARE(st, mrb_sym, char, FALSE)\nKHASH_DEFINE(st, mrb_sym, char, FALSE, kh_int_hash_func, kh_int_hash_equal)\n\nstatic void\nmethod_entry_loop(mrb_state *mrb, struct RClass* klass, khash_t(st)* set)\n{\n  khint_t i;\n\n  khash_t(mt) *h = klass->mt;\n  if (!h || kh_size(h) == 0) return;\n  for (i=0;i<kh_end(h);i++) {\n    if (kh_exist(h, i)) {\n      mrb_method_t m = kh_value(h, i);\n      if (MRB_METHOD_UNDEF_P(m)) continue;\n      kh_put(st, mrb, set, kh_key(h, i));\n    }\n  }\n}\n\nmrb_value\nmrb_class_instance_method_list(mrb_state *mrb, mrb_bool recur, struct RClass* klass, int obj)\n{\n  khint_t i;\n  mrb_value ary;\n  mrb_bool prepended = FALSE;\n  struct RClass* oldklass;\n  khash_t(st)* set = kh_init(st, mrb);\n\n  if (!recur && (klass->flags & MRB_FLAG_IS_PREPENDED)) {\n    MRB_CLASS_ORIGIN(klass);\n    prepended = TRUE;\n  }\n\n  oldklass = 0;\n  while (klass && (klass != oldklass)) {\n    method_entry_loop(mrb, klass, set);\n    if ((klass->tt == MRB_TT_ICLASS && !prepended) ||\n        (klass->tt == MRB_TT_SCLASS)) {\n    }\n    else {\n      if (!recur) break;\n    }\n    oldklass = klass;\n    klass = klass->super;\n  }\n\n  ary = mrb_ary_new_capa(mrb, kh_size(set));\n  for (i=0;i<kh_end(set);i++) {\n    if (kh_exist(set, i)) {\n      mrb_ary_push(mrb, ary, mrb_symbol_value(kh_key(set, i)));\n    }\n  }\n  kh_destroy(st, mrb, set);\n\n  return ary;\n}\n\nstatic mrb_value\nmrb_obj_singleton_methods(mrb_state *mrb, mrb_bool recur, mrb_value obj)\n{\n  khint_t i;\n  mrb_value ary;\n  struct RClass* klass;\n  khash_t(st)* set = kh_init(st, mrb);\n\n  klass = mrb_class(mrb, obj);\n\n  if (klass && (klass->tt == MRB_TT_SCLASS)) {\n      method_entry_loop(mrb, klass, set);\n      klass = klass->super;\n  }\n  if (recur) {\n      while (klass && ((klass->tt == MRB_TT_SCLASS) || (klass->tt == MRB_TT_ICLASS))) {\n        method_entry_loop(mrb, klass, set);\n        klass = klass->super;\n      }\n  }\n\n  ary = mrb_ary_new(mrb);\n  for (i=0;i<kh_end(set);i++) {\n    if (kh_exist(set, i)) {\n      mrb_ary_push(mrb, ary, mrb_symbol_value(kh_key(set, i)));\n    }\n  }\n  kh_destroy(st, mrb, set);\n\n  return ary;\n}\n\nstatic mrb_value\nmrb_obj_methods(mrb_state *mrb, mrb_bool recur, mrb_value obj, mrb_method_flag_t flag)\n{\n  return mrb_class_instance_method_list(mrb, recur, mrb_class(mrb, obj), 0);\n}\n/* 15.3.1.3.31 */\n/*\n *  call-seq:\n *     obj.methods    -> array\n *\n *  Returns a list of the names of methods publicly accessible in\n *  <i>obj</i>. This will include all the methods accessible in\n *  <i>obj</i>'s ancestors.\n *\n *     class Klass\n *       def kMethod()\n *       end\n *     end\n *     k = Klass.new\n *     k.methods[0..9]    #=> [:kMethod, :respond_to?, :nil?, :is_a?,\n *                        #    :class, :instance_variable_set,\n *                        #    :methods, :extend, :__send__, :instance_eval]\n *     k.methods.length   #=> 42\n */\nstatic mrb_value\nmrb_obj_methods_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, (mrb_method_flag_t)0); /* everything but private */\n}\n\n/* 15.3.1.3.32 */\n/*\n * call_seq:\n *   nil.nil?               -> true\n *   <anything_else>.nil?   -> false\n *\n * Only the object <i>nil</i> responds <code>true</code> to <code>nil?</code>.\n */\nstatic mrb_value\nmrb_false(mrb_state *mrb, mrb_value self)\n{\n  return mrb_false_value();\n}\n\n/* 15.3.1.3.36 */\n/*\n *  call-seq:\n *     obj.private_methods(all=true)   -> array\n *\n *  Returns the list of private methods accessible to <i>obj</i>. If\n *  the <i>all</i> parameter is set to <code>false</code>, only those methods\n *  in the receiver will be listed.\n */\nstatic mrb_value\nmrb_obj_private_methods(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, NOEX_PRIVATE); /* private attribute not define */\n}\n\n/* 15.3.1.3.37 */\n/*\n *  call-seq:\n *     obj.protected_methods(all=true)   -> array\n *\n *  Returns the list of protected methods accessible to <i>obj</i>. If\n *  the <i>all</i> parameter is set to <code>false</code>, only those methods\n *  in the receiver will be listed.\n */\nstatic mrb_value\nmrb_obj_protected_methods(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, NOEX_PROTECTED); /* protected attribute not define */\n}\n\n/* 15.3.1.3.38 */\n/*\n *  call-seq:\n *     obj.public_methods(all=true)   -> array\n *\n *  Returns the list of public methods accessible to <i>obj</i>. If\n *  the <i>all</i> parameter is set to <code>false</code>, only those methods\n *  in the receiver will be listed.\n */\nstatic mrb_value\nmrb_obj_public_methods(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_methods(mrb, recur, self, NOEX_PUBLIC); /* public attribute not define */\n}\n\n/* 15.3.1.2.12  */\n/* 15.3.1.3.40 */\n/*\n *  call-seq:\n *     raise\n *     raise(string)\n *     raise(exception [, string])\n *\n *  With no arguments, raises a <code>RuntimeError</code>\n *  With a single +String+ argument, raises a\n *  +RuntimeError+ with the string as a message. Otherwise,\n *  the first parameter should be the name of an +Exception+\n *  class (or an object that returns an +Exception+ object when sent\n *  an +exception+ message). The optional second parameter sets the\n *  message associated with the exception, and the third parameter is an\n *  array of callback information. Exceptions are caught by the\n *  +rescue+ clause of <code>begin...end</code> blocks.\n *\n *     raise \"Failed to create socket\"\n *     raise ArgumentError, \"No parameters\", caller\n */\nMRB_API mrb_value\nmrb_f_raise(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a[2], exc;\n  mrb_int argc;\n\n\n  argc = mrb_get_args(mrb, \"|oo\", &a[0], &a[1]);\n  switch (argc) {\n  case 0:\n    mrb_raise(mrb, E_RUNTIME_ERROR, \"\");\n    break;\n  case 1:\n    if (mrb_string_p(a[0])) {\n      a[1] = a[0];\n      argc = 2;\n      a[0] = mrb_obj_value(E_RUNTIME_ERROR);\n    }\n    /* fall through */\n  default:\n    exc = mrb_make_exception(mrb, argc, a);\n    mrb_exc_raise(mrb, exc);\n    break;\n  }\n  return mrb_nil_value();            /* not reached */\n}\n\nstatic mrb_value\nmrb_krn_class_defined(mrb_state *mrb, mrb_value self)\n{\n  mrb_value str;\n\n  mrb_get_args(mrb, \"S\", &str);\n  return mrb_bool_value(mrb_class_defined(mrb, RSTRING_PTR(str)));\n}\n\n\n/* 15.3.1.3.41 */\n/*\n *  call-seq:\n *     obj.remove_instance_variable(symbol)    -> obj\n *\n *  Removes the named instance variable from <i>obj</i>, returning that\n *  variable's value.\n *\n *     class Dummy\n *       attr_reader :var\n *       def initialize\n *         @var = 99\n *       end\n *       def remove\n *         remove_instance_variable(:@var)\n *       end\n *     end\n *     d = Dummy.new\n *     d.var      #=> 99\n *     d.remove   #=> 99\n *     d.var      #=> nil\n */\nstatic mrb_value\nmrb_obj_remove_instance_variable(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym sym;\n  mrb_value val;\n\n  mrb_get_args(mrb, \"n\", &sym);\n  mrb_iv_check(mrb, sym);\n  val = mrb_iv_remove(mrb, self, sym);\n  if (mrb_undef_p(val)) {\n    mrb_name_error(mrb, sym, \"instance variable %S not defined\", mrb_sym2str(mrb, sym));\n  }\n  return val;\n}\n\nvoid\nmrb_method_missing(mrb_state *mrb, mrb_sym name, mrb_value self, mrb_value args)\n{\n  mrb_no_method_error(mrb, name, args, \"undefined method '%S'\", mrb_sym2str(mrb, name));\n}\n\n/* 15.3.1.3.30 */\n/*\n *  call-seq:\n *     obj.method_missing(symbol [, *args] )   -> result\n *\n *  Invoked by Ruby when <i>obj</i> is sent a message it cannot handle.\n *  <i>symbol</i> is the symbol for the method called, and <i>args</i>\n *  are any arguments that were passed to it. By default, the interpreter\n *  raises an error when this method is called. However, it is possible\n *  to override the method to provide more dynamic behavior.\n *  If it is decided that a particular method should not be handled, then\n *  <i>super</i> should be called, so that ancestors can pick up the\n *  missing method.\n *  The example below creates\n *  a class <code>Roman</code>, which responds to methods with names\n *  consisting of roman numerals, returning the corresponding integer\n *  values.\n *\n *     class Roman\n *       def romanToInt(str)\n *         # ...\n *       end\n *       def method_missing(methId)\n *         str = methId.id2name\n *         romanToInt(str)\n *       end\n *     end\n *\n *     r = Roman.new\n *     r.iv      #=> 4\n *     r.xxiii   #=> 23\n *     r.mm      #=> 2000\n */\n#ifdef MRB_DEFAULT_METHOD_MISSING\nstatic mrb_value\nmrb_obj_missing(mrb_state *mrb, mrb_value mod)\n{\n  mrb_sym name;\n  mrb_value *a;\n  mrb_int alen;\n\n  mrb_get_args(mrb, \"n*!\", &name, &a, &alen);\n  mrb_method_missing(mrb, name, mod, mrb_ary_new_from_values(mrb, alen, a));\n  /* not reached */\n  return mrb_nil_value();\n}\n#endif\n\nstatic inline mrb_bool\nbasic_obj_respond_to(mrb_state *mrb, mrb_value obj, mrb_sym id, int pub)\n{\n  return mrb_respond_to(mrb, obj, id);\n}\n/* 15.3.1.3.43 */\n/*\n *  call-seq:\n *     obj.respond_to?(symbol, include_private=false) -> true or false\n *\n *  Returns +true+ if _obj_ responds to the given\n *  method. Private methods are included in the search only if the\n *  optional second parameter evaluates to +true+.\n *\n *  If the method is not implemented,\n *  as Process.fork on Windows, File.lchmod on GNU/Linux, etc.,\n *  false is returned.\n *\n *  If the method is not defined, <code>respond_to_missing?</code>\n *  method is called and the result is returned.\n */\nstatic mrb_value\nobj_respond_to(mrb_state *mrb, mrb_value self)\n{\n  mrb_value mid;\n  mrb_sym id, rtm_id;\n  mrb_bool priv = FALSE, respond_to_p = TRUE;\n\n  mrb_get_args(mrb, \"o|b\", &mid, &priv);\n\n  if (mrb_symbol_p(mid)) {\n    id = mrb_symbol(mid);\n  }\n  else {\n    mrb_value tmp;\n    if (mrb_string_p(mid)) {\n      tmp = mrb_check_intern_str(mrb, mid);\n    }\n    else {\n      tmp = mrb_check_string_type(mrb, mid);\n      if (mrb_nil_p(tmp)) {\n        tmp = mrb_inspect(mrb, mid);\n        mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a symbol\", tmp);\n      }\n      tmp = mrb_check_intern_str(mrb, tmp);\n    }\n    if (mrb_nil_p(tmp)) {\n      respond_to_p = FALSE;\n    }\n    else {\n      id = mrb_symbol(tmp);\n    }\n  }\n\n  if (respond_to_p) {\n    respond_to_p = basic_obj_respond_to(mrb, self, id, !priv);\n  }\n\n  if (!respond_to_p) {\n    rtm_id = mrb_intern_lit(mrb, \"respond_to_missing?\");\n    if (basic_obj_respond_to(mrb, self, rtm_id, !priv)) {\n      mrb_value args[2], v;\n      args[0] = mid;\n      args[1] = mrb_bool_value(priv);\n      v = mrb_funcall_argv(mrb, self, rtm_id, 2, args);\n      return mrb_bool_value(mrb_bool(v));\n    }\n  }\n  return mrb_bool_value(respond_to_p);\n}\n\n/* 15.3.1.3.45 */\n/*\n *  call-seq:\n *     obj.singleton_methods(all=true)    -> array\n *\n *  Returns an array of the names of singleton methods for <i>obj</i>.\n *  If the optional <i>all</i> parameter is true, the list will include\n *  methods in modules included in <i>obj</i>.\n *  Only public and protected singleton methods are returned.\n *\n *     module Other\n *       def three() end\n *     end\n *\n *     class Single\n *       def Single.four() end\n *     end\n *\n *     a = Single.new\n *\n *     def a.one()\n *     end\n *\n *     class << a\n *       include Other\n *       def two()\n *       end\n *     end\n *\n *     Single.singleton_methods    #=> [:four]\n *     a.singleton_methods(false)  #=> [:two, :one]\n *     a.singleton_methods         #=> [:two, :one, :three]\n */\nstatic mrb_value\nmrb_obj_singleton_methods_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_obj_singleton_methods(mrb, recur, self);\n}\n\nstatic mrb_value\nmod_define_singleton_method(mrb_state *mrb, mrb_value self)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value blk = mrb_nil_value();\n\n  mrb_get_args(mrb, \"n&\", &mid, &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = (struct RProc*)mrb_obj_alloc(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, mrb_class_ptr(mrb_singleton_class(mrb, self)), mid, m);\n  return mrb_symbol_value(mid);\n}\n\nstatic mrb_value\nmrb_obj_ceqq(mrb_state *mrb, mrb_value self)\n{\n  mrb_value v;\n  mrb_int i, len;\n  mrb_sym eqq = mrb_intern_lit(mrb, \"===\");\n  mrb_value ary = mrb_ary_splat(mrb, self);\n\n  mrb_get_args(mrb, \"o\", &v);\n  len = RARRAY_LEN(ary);\n  for (i=0; i<len; i++) {\n    mrb_value c = mrb_funcall_argv(mrb, mrb_ary_entry(ary, i), eqq, 1, &v);\n    if (mrb_test(c)) return mrb_true_value();\n  }\n  return mrb_false_value();\n}\n\n/* 15.3.1.2.7 */\n/*\n *  call-seq:\n *     local_variables   -> array\n *\n *  Returns the names of local variables in the current scope.\n *\n *  [mruby limitation]\n *  If variable symbol information was stripped out from\n *  compiled binary files using `mruby-strip -l`, this\n *  method always returns an empty array.\n */\nstatic mrb_value\nmrb_local_variables(mrb_state *mrb, mrb_value self)\n{\n  struct RProc *proc;\n  mrb_irep *irep;\n  mrb_value vars;\n  size_t i;\n\n  proc = mrb->c->ci[-1].proc;\n\n  if (MRB_PROC_CFUNC_P(proc)) {\n    return mrb_ary_new(mrb);\n  }\n  vars = mrb_hash_new(mrb);\n  while (proc) {\n    if (MRB_PROC_CFUNC_P(proc)) break;\n    irep = proc->body.irep;\n    if (!irep->lv) break;\n    for (i = 0; i + 1 < irep->nlocals; ++i) {\n      if (irep->lv[i].name) {\n        mrb_hash_set(mrb, vars, mrb_symbol_value(irep->lv[i].name), mrb_true_value());\n      }\n    }\n    if (!MRB_PROC_ENV_P(proc)) break;\n    proc = proc->upper;\n    //if (MRB_PROC_SCOPE_P(proc)) break;\n    if (!proc->c) break;\n  }\n\n  return mrb_hash_keys(mrb, vars);\n}\n\nmrb_value mrb_obj_equal_m(mrb_state *mrb, mrb_value);\nvoid\nmrb_init_kernel(mrb_state *mrb)\n{\n  struct RClass *krn;\n\n  mrb->kernel_module = krn = mrb_define_module(mrb, \"Kernel\");                                                    /* 15.3.1 */\n  mrb_define_class_method(mrb, krn, \"block_given?\",         mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.2.2  */\n  mrb_define_class_method(mrb, krn, \"global_variables\",     mrb_f_global_variables,          MRB_ARGS_NONE());    /* 15.3.1.2.4  */\n  mrb_define_class_method(mrb, krn, \"iterator?\",            mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.2.5  */\n  mrb_define_class_method(mrb, krn, \"local_variables\",      mrb_local_variables,             MRB_ARGS_NONE());    /* 15.3.1.2.7  */\n;     /* 15.3.1.2.11 */\n  mrb_define_class_method(mrb, krn, \"raise\",                mrb_f_raise,                     MRB_ARGS_OPT(2));    /* 15.3.1.2.12 */\n\n  mrb_define_method(mrb, krn, \"singleton_class\",            mrb_singleton_class,             MRB_ARGS_NONE());\n\n  mrb_define_method(mrb, krn, \"===\",                        mrb_equal_m,                     MRB_ARGS_REQ(1));    /* 15.3.1.3.2  */\n  mrb_define_method(mrb, krn, \"block_given?\",               mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.3.6  */\n  mrb_define_method(mrb, krn, \"class\",                      mrb_obj_class_m,                 MRB_ARGS_NONE());    /* 15.3.1.3.7  */\n  mrb_define_method(mrb, krn, \"clone\",                      mrb_obj_clone,                   MRB_ARGS_NONE());    /* 15.3.1.3.8  */\n  mrb_define_method(mrb, krn, \"dup\",                        mrb_obj_dup,                     MRB_ARGS_NONE());    /* 15.3.1.3.9  */\n  mrb_define_method(mrb, krn, \"eql?\",                       mrb_obj_equal_m,                 MRB_ARGS_REQ(1));    /* 15.3.1.3.10 */\n  mrb_define_method(mrb, krn, \"equal?\",                     mrb_obj_equal_m,                 MRB_ARGS_REQ(1));    /* 15.3.1.3.11 */\n  mrb_define_method(mrb, krn, \"extend\",                     mrb_obj_extend_m,                MRB_ARGS_ANY());     /* 15.3.1.3.13 */\n  mrb_define_method(mrb, krn, \"freeze\",                     mrb_obj_freeze,                  MRB_ARGS_NONE());\n  mrb_define_method(mrb, krn, \"frozen?\",                    mrb_obj_frozen,                  MRB_ARGS_NONE());\n  mrb_define_method(mrb, krn, \"global_variables\",           mrb_f_global_variables,          MRB_ARGS_NONE());    /* 15.3.1.3.14 */\n  mrb_define_method(mrb, krn, \"hash\",                       mrb_obj_hash,                    MRB_ARGS_NONE());    /* 15.3.1.3.15 */\n  mrb_define_method(mrb, krn, \"initialize_copy\",            mrb_obj_init_copy,               MRB_ARGS_REQ(1));    /* 15.3.1.3.16 */\n  mrb_define_method(mrb, krn, \"inspect\",                    mrb_obj_inspect,                 MRB_ARGS_NONE());    /* 15.3.1.3.17 */\n  mrb_define_method(mrb, krn, \"instance_of?\",               obj_is_instance_of,              MRB_ARGS_REQ(1));    /* 15.3.1.3.19 */\n  mrb_define_method(mrb, krn, \"instance_variable_defined?\", mrb_obj_ivar_defined,            MRB_ARGS_REQ(1));    /* 15.3.1.3.20 */\n  mrb_define_method(mrb, krn, \"instance_variable_get\",      mrb_obj_ivar_get,                MRB_ARGS_REQ(1));    /* 15.3.1.3.21 */\n  mrb_define_method(mrb, krn, \"instance_variable_set\",      mrb_obj_ivar_set,                MRB_ARGS_REQ(2));    /* 15.3.1.3.22 */\n  mrb_define_method(mrb, krn, \"instance_variables\",         mrb_obj_instance_variables,      MRB_ARGS_NONE());    /* 15.3.1.3.23 */\n  mrb_define_method(mrb, krn, \"is_a?\",                      mrb_obj_is_kind_of_m,            MRB_ARGS_REQ(1));    /* 15.3.1.3.24 */\n  mrb_define_method(mrb, krn, \"iterator?\",                  mrb_f_block_given_p_m,           MRB_ARGS_NONE());    /* 15.3.1.3.25 */\n  mrb_define_method(mrb, krn, \"kind_of?\",                   mrb_obj_is_kind_of_m,            MRB_ARGS_REQ(1));    /* 15.3.1.3.26 */\n  mrb_define_method(mrb, krn, \"local_variables\",            mrb_local_variables,             MRB_ARGS_NONE());    /* 15.3.1.3.28 */\n#ifdef MRB_DEFAULT_METHOD_MISSING\n  mrb_define_method(mrb, krn, \"method_missing\",             mrb_obj_missing,                 MRB_ARGS_ANY());     /* 15.3.1.3.30 */\n#endif\n  mrb_define_method(mrb, krn, \"methods\",                    mrb_obj_methods_m,               MRB_ARGS_OPT(1));    /* 15.3.1.3.31 */\n  mrb_define_method(mrb, krn, \"nil?\",                       mrb_false,                       MRB_ARGS_NONE());    /* 15.3.1.3.32 */\n  mrb_define_method(mrb, krn, \"object_id\",                  mrb_obj_id_m,                    MRB_ARGS_NONE());    /* 15.3.1.3.33 */\n  mrb_define_method(mrb, krn, \"private_methods\",            mrb_obj_private_methods,         MRB_ARGS_OPT(1));    /* 15.3.1.3.36 */\n  mrb_define_method(mrb, krn, \"protected_methods\",          mrb_obj_protected_methods,       MRB_ARGS_OPT(1));    /* 15.3.1.3.37 */\n  mrb_define_method(mrb, krn, \"public_methods\",             mrb_obj_public_methods,          MRB_ARGS_OPT(1));    /* 15.3.1.3.38 */\n  mrb_define_method(mrb, krn, \"raise\",                      mrb_f_raise,                     MRB_ARGS_ANY());     /* 15.3.1.3.40 */\n  mrb_define_method(mrb, krn, \"remove_instance_variable\",   mrb_obj_remove_instance_variable,MRB_ARGS_REQ(1));    /* 15.3.1.3.41 */\n  mrb_define_method(mrb, krn, \"respond_to?\",                obj_respond_to,                  MRB_ARGS_ANY());     /* 15.3.1.3.43 */\n  mrb_define_method(mrb, krn, \"send\",                       mrb_f_send,                      MRB_ARGS_ANY());     /* 15.3.1.3.44 */\n  mrb_define_method(mrb, krn, \"singleton_methods\",          mrb_obj_singleton_methods_m,     MRB_ARGS_OPT(1));    /* 15.3.1.3.45 */\n  mrb_define_method(mrb, krn, \"define_singleton_method\",    mod_define_singleton_method,     MRB_ARGS_ANY());\n  mrb_define_method(mrb, krn, \"to_s\",                       mrb_any_to_s,                    MRB_ARGS_NONE());    /* 15.3.1.3.46 */\n  mrb_define_method(mrb, krn, \"__case_eqq\",                 mrb_obj_ceqq,                    MRB_ARGS_REQ(1));    /* internal */\n\n  mrb_define_method(mrb, krn, \"class_defined?\",             mrb_krn_class_defined,           MRB_ARGS_REQ(1));\n\n  mrb_include_module(mrb, mrb->object_class, mrb->kernel_module);\n  mrb_alias_method(mrb, mrb->module_class, mrb_intern_lit(mrb, \"dup\"), mrb_intern_lit(mrb, \"clone\"));\n}\n"], "filenames": ["src/kernel.c"], "buggy_code_start_loc": [351], "buggy_code_end_loc": [352], "fixing_code_start_loc": [351], "fixing_code_end_loc": [352], "type": "CWE-476", "message": "An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class, related to certain .clone usage, because mrb_obj_clone in kernel.c copies flags other than the MRB_FLAG_IS_FROZEN flag (e.g., the embedded flag).", "other": {"cve": {"id": "CVE-2018-12247", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-12T14:29:00.320", "lastModified": "2018-08-01T12:08:29.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class, related to certain .clone usage, because mrb_obj_clone in kernel.c copies flags other than the MRB_FLAG_IS_FROZEN flag (e.g., the embedded flag)."}, {"lang": "es", "value": "Se ha descubierto un problema en mruby 1.4.1. Hay una desreferencia de puntero NULL en mrb_class, relacionada con cierto uso de .clone. Esto se debe a que mrb_obj_clone en kernel.c copia flags diferentes a MRB_FLAG_IS_FROZEN (por ejemplo, el flag embebido)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "C4A86E77-13CC-41B4-AB91-4A7C513791BC"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/55edae0226409de25e59922807cb09acb45731a2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mruby/mruby/issues/4036", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/55edae0226409de25e59922807cb09acb45731a2"}}