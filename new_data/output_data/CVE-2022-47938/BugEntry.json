{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include \"glob.h\"\n#include \"nterr.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"mgmt/user_session.h\"\n#include \"connection.h\"\n\nstatic int check_smb2_hdr(struct smb2_hdr *hdr)\n{\n\t/*\n\t * Make sure that this really is an SMB, that it is a response.\n\t */\n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n *  The following table defines the expected \"StructureSize\" of SMB2 requests\n *  in order by SMB2 command.  This is similar to \"wct\" in SMB/CIFS requests.\n *\n *  Note that commands are defined in smb2pdu.h in le16 but the array below is\n *  indexed by command in host byte order\n */\nstatic const __le16 smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ cpu_to_le16(36),\n\t/* SMB2_SESSION_SETUP */ cpu_to_le16(25),\n\t/* SMB2_LOGOFF */ cpu_to_le16(4),\n\t/* SMB2_TREE_CONNECT */ cpu_to_le16(9),\n\t/* SMB2_TREE_DISCONNECT */ cpu_to_le16(4),\n\t/* SMB2_CREATE */ cpu_to_le16(57),\n\t/* SMB2_CLOSE */ cpu_to_le16(24),\n\t/* SMB2_FLUSH */ cpu_to_le16(24),\n\t/* SMB2_READ */ cpu_to_le16(49),\n\t/* SMB2_WRITE */ cpu_to_le16(49),\n\t/* SMB2_LOCK */ cpu_to_le16(48),\n\t/* SMB2_IOCTL */ cpu_to_le16(57),\n\t/* SMB2_CANCEL */ cpu_to_le16(4),\n\t/* SMB2_ECHO */ cpu_to_le16(4),\n\t/* SMB2_QUERY_DIRECTORY */ cpu_to_le16(33),\n\t/* SMB2_CHANGE_NOTIFY */ cpu_to_le16(32),\n\t/* SMB2_QUERY_INFO */ cpu_to_le16(41),\n\t/* SMB2_SET_INFO */ cpu_to_le16(33),\n\t/* use 44 for lease break */\n\t/* SMB2_OPLOCK_BREAK */ cpu_to_le16(36)\n};\n\n/*\n * The size of the variable area depends on the offset and length fields\n * located in different fields for various SMB2 requests. SMB2 requests\n * with no variable length info, show an offset of zero for the offset field.\n */\nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\ttrue,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ true,\n\t/* SMB2_LOCK */\ttrue,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ false,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ true,\n\t/* SMB2_OPLOCK_BREAK */ false\n};\n\n/*\n * Set length of the data area and the offset to arguments.\n * if they are invalid, return error.\n */\nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/* error reqeusts do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) == SMB2_ERROR_STRUCTURE_SIZE2_LE)\n\t\treturn ret;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Calculate the size of the SMB message based on the fixed header\n * portion, the number of word parameters and the data portion of the message.\n */\nstatic int smb2_calc_size(void *buf, unsigned int *len)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)buf;\n\tstruct smb2_hdr *hdr = &pdu->hdr;\n\tunsigned int offset; /* the offset from the beginning of SMB to data area */\n\tunsigned int data_length; /* the length of the variable length data area */\n\tint ret;\n\n\t/* Structure Size has already been checked to make sure it is 64 */\n\t*len = le16_to_cpu(hdr->StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\t*len += le16_to_cpu(pdu->StructureSize2);\n\t/*\n\t * StructureSize2 of smb2_lock pdu is set to 48, indicating\n\t * the size of smb2 lock request with single smb2_lock_element\n\t * regardless of number of locks. Subtract single\n\t * smb2_lock_element for correct buffer size check.\n\t */\n\tif (hdr->Command == SMB2_LOCK)\n\t\t*len -= sizeof(struct smb2_lock_element);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tret = smb2_get_data_area_len(&offset, &data_length, hdr);\n\tif (ret)\n\t\treturn ret;\n\tksmbd_debug(SMB, \"SMB2 data length %u offset %u\\n\", data_length,\n\t\t    offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation.\n\t\t */\n\t\tif (offset + 1 < *len) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"data area offset %d overlaps SMB2 header %u\\n\",\n\t\t\t\t    offset + 1, *len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = offset + data_length;\n\t}\n\ncalc_size_exit:\n\tksmbd_debug(SMB, \"SMB2 len %u\\n\", *len);\n\treturn 0;\n}\n\nstatic inline int smb2_query_info_req_len(struct smb2_query_info_req *h)\n{\n\treturn le32_to_cpu(h->InputBufferLength) +\n\t\tle32_to_cpu(h->OutputBufferLength);\n}\n\nstatic inline int smb2_set_info_req_len(struct smb2_set_info_req *h)\n{\n\treturn le32_to_cpu(h->BufferLength);\n}\n\nstatic inline int smb2_read_req_len(struct smb2_read_req *h)\n{\n\treturn le32_to_cpu(h->Length);\n}\n\nstatic inline int smb2_write_req_len(struct smb2_write_req *h)\n{\n\treturn le32_to_cpu(h->Length);\n}\n\nstatic inline int smb2_query_dir_req_len(struct smb2_query_directory_req *h)\n{\n\treturn le32_to_cpu(h->OutputBufferLength);\n}\n\nstatic inline int smb2_ioctl_req_len(struct smb2_ioctl_req *h)\n{\n\treturn le32_to_cpu(h->InputCount) +\n\t\tle32_to_cpu(h->OutputCount);\n}\n\nstatic inline int smb2_ioctl_resp_len(struct smb2_ioctl_req *h)\n{\n\treturn le32_to_cpu(h->MaxInputResponse) +\n\t\tle32_to_cpu(h->MaxOutputResponse);\n}\n\nstatic int smb2_validate_credit_charge(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_hdr *hdr)\n{\n\tunsigned int req_len = 0, expect_resp_len = 0, calc_credit_num, max_len;\n\tunsigned short credit_charge = le16_to_cpu(hdr->CreditCharge);\n\tvoid *__hdr = hdr;\n\tint ret = 0;\n\n\tswitch (hdr->Command) {\n\tcase SMB2_QUERY_INFO:\n\t\treq_len = smb2_query_info_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\treq_len = smb2_set_info_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\treq_len = smb2_read_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\treq_len = smb2_write_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\treq_len = smb2_query_dir_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\treq_len = smb2_ioctl_req_len(__hdr);\n\t\texpect_resp_len = smb2_ioctl_resp_len(__hdr);\n\t\tbreak;\n\tcase SMB2_CANCEL:\n\t\treturn 0;\n\tdefault:\n\t\treq_len = 1;\n\t\tbreak;\n\t}\n\n\tcredit_charge = max_t(unsigned short, credit_charge, 1);\n\tmax_len = max_t(unsigned int, req_len, expect_resp_len);\n\tcalc_credit_num = DIV_ROUND_UP(max_len, SMB2_MAX_BUFFER_SIZE);\n\n\tif (credit_charge < calc_credit_num) {\n\t\tksmbd_debug(SMB, \"Insufficient credit charge, given: %d, needed: %d\\n\",\n\t\t\t    credit_charge, calc_credit_num);\n\t\treturn 1;\n\t} else if (credit_charge > conn->vals->max_credits) {\n\t\tksmbd_debug(SMB, \"Too large credit charge: %d\\n\", credit_charge);\n\t\treturn 1;\n\t}\n\n\tspin_lock(&conn->credits_lock);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\tret = 1;\n\t}\n\n\tif ((u64)conn->outstanding_credits + credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Limits exceeding the maximum allowable outstanding requests, given : %u, pending : %u\\n\",\n\t\t\t    credit_charge, conn->outstanding_credits);\n\t\tret = 1;\n\t} else\n\t\tconn->outstanding_credits += credit_charge;\n\n\tspin_unlock(&conn->credits_lock);\n\n\treturn ret;\n}\n\nint ksmbd_smb2_check_message(struct ksmbd_work *work)\n{\n\tstruct smb2_pdu *pdu = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = &pdu->hdr;\n\tint command;\n\t__u32 clc_len;  /* calculated length */\n\t__u32 len = get_rfc1002_len(work->request_buf);\n\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse if (work->next_smb2_rcv_hdr_off)\n\t\tlen -= work->next_smb2_rcv_hdr_off;\n\n\tif (check_smb2_hdr(hdr))\n\t\treturn 1;\n\n\tif (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tksmbd_debug(SMB, \"Illegal structure size %u\\n\",\n\t\t\t    le16_to_cpu(hdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(hdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tksmbd_debug(SMB, \"Illegal SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_req_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE &&\n\t\t    (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Illegal request size %u for command %d\\n\",\n\t\t\t\t    le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE &&\n\t\t\t   hdr->Status == 0 &&\n\t\t\t   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&\n\t\t\t   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Illegal request size %d for oplock break\\n\",\n\t\t\t\t    le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (smb2_calc_size(hdr, &clc_len))\n\t\treturn 1;\n\n\tif (len != clc_len) {\n\t\t/* client can return one byte more due to implied bcc[0] */\n\t\tif (clc_len == len + 1)\n\t\t\tgoto validate_credit;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(clc_len, 8) == len)\n\t\t\tgoto validate_credit;\n\n\t\t/*\n\t\t * windows client also pad up to 8 bytes when compounding.\n\t\t * If pad is longer than eight bytes, log the server behavior\n\t\t * (once), since may indicate a problem but allow it and\n\t\t * continue since the frame is parseable.\n\t\t */\n\t\tif (clc_len < len) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"cli req padded more than expected. Length %d not %d for cmd:%d mid:%llu\\n\",\n\t\t\t\t    len, clc_len, command,\n\t\t\t\t    le64_to_cpu(hdr->MessageId));\n\t\t\tgoto validate_credit;\n\t\t}\n\n\t\tksmbd_debug(SMB,\n\t\t\t    \"cli req too short, len %d not %d. cmd:%d mid:%llu\\n\",\n\t\t\t    len, clc_len, command,\n\t\t\t    le64_to_cpu(hdr->MessageId));\n\n\t\treturn 1;\n\t}\n\nvalidate_credit:\n\tif ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) &&\n\t    smb2_validate_credit_charge(work->conn, hdr)) {\n\t\twork->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint smb2_negotiate_request(struct ksmbd_work *work)\n{\n\treturn ksmbd_smb_negotiate_common(work, SMB2_NEGOTIATE_HE);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2018 Samsung Electronics Co., Ltd.\n */\n\n#include \"glob.h\"\n#include \"nterr.h\"\n#include \"smb_common.h\"\n#include \"smbstatus.h\"\n#include \"mgmt/user_session.h\"\n#include \"connection.h\"\n\nstatic int check_smb2_hdr(struct smb2_hdr *hdr)\n{\n\t/*\n\t * Make sure that this really is an SMB, that it is a response.\n\t */\n\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n *  The following table defines the expected \"StructureSize\" of SMB2 requests\n *  in order by SMB2 command.  This is similar to \"wct\" in SMB/CIFS requests.\n *\n *  Note that commands are defined in smb2pdu.h in le16 but the array below is\n *  indexed by command in host byte order\n */\nstatic const __le16 smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ cpu_to_le16(36),\n\t/* SMB2_SESSION_SETUP */ cpu_to_le16(25),\n\t/* SMB2_LOGOFF */ cpu_to_le16(4),\n\t/* SMB2_TREE_CONNECT */ cpu_to_le16(9),\n\t/* SMB2_TREE_DISCONNECT */ cpu_to_le16(4),\n\t/* SMB2_CREATE */ cpu_to_le16(57),\n\t/* SMB2_CLOSE */ cpu_to_le16(24),\n\t/* SMB2_FLUSH */ cpu_to_le16(24),\n\t/* SMB2_READ */ cpu_to_le16(49),\n\t/* SMB2_WRITE */ cpu_to_le16(49),\n\t/* SMB2_LOCK */ cpu_to_le16(48),\n\t/* SMB2_IOCTL */ cpu_to_le16(57),\n\t/* SMB2_CANCEL */ cpu_to_le16(4),\n\t/* SMB2_ECHO */ cpu_to_le16(4),\n\t/* SMB2_QUERY_DIRECTORY */ cpu_to_le16(33),\n\t/* SMB2_CHANGE_NOTIFY */ cpu_to_le16(32),\n\t/* SMB2_QUERY_INFO */ cpu_to_le16(41),\n\t/* SMB2_SET_INFO */ cpu_to_le16(33),\n\t/* use 44 for lease break */\n\t/* SMB2_OPLOCK_BREAK */ cpu_to_le16(36)\n};\n\n/*\n * The size of the variable area depends on the offset and length fields\n * located in different fields for various SMB2 requests. SMB2 requests\n * with no variable length info, show an offset of zero for the offset field.\n */\nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\ttrue,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ true,\n\t/* SMB2_LOCK */\ttrue,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ false,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ true,\n\t/* SMB2_OPLOCK_BREAK */ false\n};\n\n/*\n * Set length of the data area and the offset to arguments.\n * if they are invalid, return error.\n */\nstatic int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tint lock_count;\n\n\t\t/*\n\t\t * smb2_lock request size is 48 included single\n\t\t * smb2_lock_element structure size.\n\t\t */\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount) - 1;\n\t\tif (lock_count > 0) {\n\t\t\t*off = __SMB2_HEADER_STRUCTURE_SIZE + 48;\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Calculate the size of the SMB message based on the fixed header\n * portion, the number of word parameters and the data portion of the message.\n */\nstatic int smb2_calc_size(void *buf, unsigned int *len)\n{\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)buf;\n\tstruct smb2_hdr *hdr = &pdu->hdr;\n\tunsigned int offset; /* the offset from the beginning of SMB to data area */\n\tunsigned int data_length; /* the length of the variable length data area */\n\tint ret;\n\n\t/* Structure Size has already been checked to make sure it is 64 */\n\t*len = le16_to_cpu(hdr->StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\t*len += le16_to_cpu(pdu->StructureSize2);\n\t/*\n\t * StructureSize2 of smb2_lock pdu is set to 48, indicating\n\t * the size of smb2 lock request with single smb2_lock_element\n\t * regardless of number of locks. Subtract single\n\t * smb2_lock_element for correct buffer size check.\n\t */\n\tif (hdr->Command == SMB2_LOCK)\n\t\t*len -= sizeof(struct smb2_lock_element);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tret = smb2_get_data_area_len(&offset, &data_length, hdr);\n\tif (ret)\n\t\treturn ret;\n\tksmbd_debug(SMB, \"SMB2 data length %u offset %u\\n\", data_length,\n\t\t    offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation.\n\t\t */\n\t\tif (offset + 1 < *len) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"data area offset %d overlaps SMB2 header %u\\n\",\n\t\t\t\t    offset + 1, *len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = offset + data_length;\n\t}\n\ncalc_size_exit:\n\tksmbd_debug(SMB, \"SMB2 len %u\\n\", *len);\n\treturn 0;\n}\n\nstatic inline int smb2_query_info_req_len(struct smb2_query_info_req *h)\n{\n\treturn le32_to_cpu(h->InputBufferLength) +\n\t\tle32_to_cpu(h->OutputBufferLength);\n}\n\nstatic inline int smb2_set_info_req_len(struct smb2_set_info_req *h)\n{\n\treturn le32_to_cpu(h->BufferLength);\n}\n\nstatic inline int smb2_read_req_len(struct smb2_read_req *h)\n{\n\treturn le32_to_cpu(h->Length);\n}\n\nstatic inline int smb2_write_req_len(struct smb2_write_req *h)\n{\n\treturn le32_to_cpu(h->Length);\n}\n\nstatic inline int smb2_query_dir_req_len(struct smb2_query_directory_req *h)\n{\n\treturn le32_to_cpu(h->OutputBufferLength);\n}\n\nstatic inline int smb2_ioctl_req_len(struct smb2_ioctl_req *h)\n{\n\treturn le32_to_cpu(h->InputCount) +\n\t\tle32_to_cpu(h->OutputCount);\n}\n\nstatic inline int smb2_ioctl_resp_len(struct smb2_ioctl_req *h)\n{\n\treturn le32_to_cpu(h->MaxInputResponse) +\n\t\tle32_to_cpu(h->MaxOutputResponse);\n}\n\nstatic int smb2_validate_credit_charge(struct ksmbd_conn *conn,\n\t\t\t\t       struct smb2_hdr *hdr)\n{\n\tunsigned int req_len = 0, expect_resp_len = 0, calc_credit_num, max_len;\n\tunsigned short credit_charge = le16_to_cpu(hdr->CreditCharge);\n\tvoid *__hdr = hdr;\n\tint ret = 0;\n\n\tswitch (hdr->Command) {\n\tcase SMB2_QUERY_INFO:\n\t\treq_len = smb2_query_info_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\treq_len = smb2_set_info_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\treq_len = smb2_read_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\treq_len = smb2_write_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\treq_len = smb2_query_dir_req_len(__hdr);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\treq_len = smb2_ioctl_req_len(__hdr);\n\t\texpect_resp_len = smb2_ioctl_resp_len(__hdr);\n\t\tbreak;\n\tcase SMB2_CANCEL:\n\t\treturn 0;\n\tdefault:\n\t\treq_len = 1;\n\t\tbreak;\n\t}\n\n\tcredit_charge = max_t(unsigned short, credit_charge, 1);\n\tmax_len = max_t(unsigned int, req_len, expect_resp_len);\n\tcalc_credit_num = DIV_ROUND_UP(max_len, SMB2_MAX_BUFFER_SIZE);\n\n\tif (credit_charge < calc_credit_num) {\n\t\tksmbd_debug(SMB, \"Insufficient credit charge, given: %d, needed: %d\\n\",\n\t\t\t    credit_charge, calc_credit_num);\n\t\treturn 1;\n\t} else if (credit_charge > conn->vals->max_credits) {\n\t\tksmbd_debug(SMB, \"Too large credit charge: %d\\n\", credit_charge);\n\t\treturn 1;\n\t}\n\n\tspin_lock(&conn->credits_lock);\n\tif (credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Insufficient credits granted, given: %u, granted: %u\\n\",\n\t\t\t    credit_charge, conn->total_credits);\n\t\tret = 1;\n\t}\n\n\tif ((u64)conn->outstanding_credits + credit_charge > conn->total_credits) {\n\t\tksmbd_debug(SMB, \"Limits exceeding the maximum allowable outstanding requests, given : %u, pending : %u\\n\",\n\t\t\t    credit_charge, conn->outstanding_credits);\n\t\tret = 1;\n\t} else\n\t\tconn->outstanding_credits += credit_charge;\n\n\tspin_unlock(&conn->credits_lock);\n\n\treturn ret;\n}\n\nint ksmbd_smb2_check_message(struct ksmbd_work *work)\n{\n\tstruct smb2_pdu *pdu = ksmbd_req_buf_next(work);\n\tstruct smb2_hdr *hdr = &pdu->hdr;\n\tint command;\n\t__u32 clc_len;  /* calculated length */\n\t__u32 len = get_rfc1002_len(work->request_buf);\n\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tlen = le32_to_cpu(hdr->NextCommand);\n\telse if (work->next_smb2_rcv_hdr_off)\n\t\tlen -= work->next_smb2_rcv_hdr_off;\n\n\tif (check_smb2_hdr(hdr))\n\t\treturn 1;\n\n\tif (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tksmbd_debug(SMB, \"Illegal structure size %u\\n\",\n\t\t\t    le16_to_cpu(hdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(hdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tksmbd_debug(SMB, \"Illegal SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_req_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE &&\n\t\t    (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Illegal request size %u for command %d\\n\",\n\t\t\t\t    le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE &&\n\t\t\t   hdr->Status == 0 &&\n\t\t\t   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&\n\t\t\t   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"Illegal request size %d for oplock break\\n\",\n\t\t\t\t    le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (smb2_calc_size(hdr, &clc_len))\n\t\treturn 1;\n\n\tif (len != clc_len) {\n\t\t/* client can return one byte more due to implied bcc[0] */\n\t\tif (clc_len == len + 1)\n\t\t\tgoto validate_credit;\n\n\t\t/*\n\t\t * Some windows servers (win2016) will pad also the final\n\t\t * PDU in a compound to 8 bytes.\n\t\t */\n\t\tif (ALIGN(clc_len, 8) == len)\n\t\t\tgoto validate_credit;\n\n\t\t/*\n\t\t * windows client also pad up to 8 bytes when compounding.\n\t\t * If pad is longer than eight bytes, log the server behavior\n\t\t * (once), since may indicate a problem but allow it and\n\t\t * continue since the frame is parseable.\n\t\t */\n\t\tif (clc_len < len) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"cli req padded more than expected. Length %d not %d for cmd:%d mid:%llu\\n\",\n\t\t\t\t    len, clc_len, command,\n\t\t\t\t    le64_to_cpu(hdr->MessageId));\n\t\t\tgoto validate_credit;\n\t\t}\n\n\t\tksmbd_debug(SMB,\n\t\t\t    \"cli req too short, len %d not %d. cmd:%d mid:%llu\\n\",\n\t\t\t    len, clc_len, command,\n\t\t\t    le64_to_cpu(hdr->MessageId));\n\n\t\treturn 1;\n\t}\n\nvalidate_credit:\n\tif ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) &&\n\t    smb2_validate_credit_charge(work->conn, hdr)) {\n\t\twork->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint smb2_negotiate_request(struct ksmbd_work *work)\n{\n\treturn ksmbd_smb_negotiate_common(work, SMB2_NEGOTIATE_HE);\n}\n"], "filenames": ["fs/ksmbd/smb2misc.c"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [98], "fixing_code_start_loc": [92], "fixing_code_end_loc": [92], "type": "CWE-125", "message": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2misc.c has an out-of-bounds read and OOPS for SMB2_TREE_CONNECT.", "other": {"cve": {"id": "CVE-2022-47938", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-23T16:15:12.020", "lastModified": "2023-01-23T18:55:50.117", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2misc.c has an out-of-bounds read and OOPS for SMB2_TREE_CONNECT."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.15", "versionEndExcluding": "5.19.2", "matchCriteriaId": "ADD77CA1-C3A0-455D-A3FD-DA80DE3555B3"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/12/23/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.19.2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=824d4f64c20093275f72fc8101394d75ff6a249e", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/824d4f64c20093275f72fc8101394d75ff6a249e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.zerodayinitiative.com/advisories/ZDI-22-1689/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/824d4f64c20093275f72fc8101394d75ff6a249e"}}