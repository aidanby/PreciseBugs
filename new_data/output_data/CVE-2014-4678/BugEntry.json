{"buggy_code": ["# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport pwd\nimport sys\nimport ConfigParser\nfrom string import ascii_letters, digits\n\n# copied from utils, avoid circular reference fun :)\ndef mk_boolean(value):\n    if value is None:\n        return False\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False):\n    ''' return a configuration variable with casting '''\n    value = _get_config(p, section, key, env_var, default)\n    if boolean:\n        return mk_boolean(value)\n    if value and integer:\n        return int(value)\n    if value and floating:\n        return float(value)\n    return value\n\ndef _get_config(p, section, key, env_var, default):\n    ''' helper function for get_config '''\n    if env_var is not None:\n        value = os.environ.get(env_var, None)\n        if value is not None:\n            return value\n    if p is not None:\n        try:\n            return p.get(section, key, raw=True)\n        except:\n            return default\n    return default\n\ndef load_config_file():\n    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''\n\n    p = ConfigParser.ConfigParser()\n\n    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)\n    if path0 is not None:\n        path0 = os.path.expanduser(path0)\n    path1 = os.getcwd() + \"/ansible.cfg\"\n    path2 = os.path.expanduser(\"~/.ansible.cfg\")\n    path3 = \"/etc/ansible/ansible.cfg\"\n\n    for path in [path0, path1, path2, path3]:\n        if path is not None and os.path.exists(path):\n            p.read(path)\n            return p\n    return None\n\ndef shell_expand_path(path):\n    ''' shell_expand_path is needed as os.path.expanduser does not work\n        when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE '''\n    if path:\n        path = os.path.expanduser(path)\n    return path\n\np = load_config_file()\n\nactive_user   = pwd.getpwuid(os.geteuid())[0]\n\n# Needed so the RPM can call setup.py and have modules land in the\n# correct location. See #1277 for discussion\nif getattr(sys, \"real_prefix\", None):\n    # in a virtualenv\n    DIST_MODULE_PATH = os.path.join(sys.prefix, 'share/ansible/')\nelse:\n    DIST_MODULE_PATH = '/usr/share/ansible/'\n\n# check all of these extensions when looking for yaml files for things like\n# group variables -- really anything we can load\nYAML_FILENAME_EXTENSIONS = [ \"\", \".yml\", \".yaml\", \".json\" ]\n\n# sections in config file\nDEFAULTS='defaults'\n\n# configurable things\nDEFAULT_HOST_LIST         = shell_expand_path(get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS', '/etc/ansible/hosts'))\nDEFAULT_MODULE_PATH       = get_config(p, DEFAULTS, 'library',          'ANSIBLE_LIBRARY',          DIST_MODULE_PATH)\nDEFAULT_ROLES_PATH        = shell_expand_path(get_config(p, DEFAULTS, 'roles_path',       'ANSIBLE_ROLES_PATH',       '/etc/ansible/roles'))\nDEFAULT_REMOTE_TMP        = shell_expand_path(get_config(p, DEFAULTS, 'remote_tmp',       'ANSIBLE_REMOTE_TEMP',      '$HOME/.ansible/tmp'))\nDEFAULT_MODULE_NAME       = get_config(p, DEFAULTS, 'module_name',      None,                       'command')\nDEFAULT_PATTERN           = get_config(p, DEFAULTS, 'pattern',          None,                       '*')\nDEFAULT_FORKS             = get_config(p, DEFAULTS, 'forks',            'ANSIBLE_FORKS',            5, integer=True)\nDEFAULT_MODULE_ARGS       = get_config(p, DEFAULTS, 'module_args',      'ANSIBLE_MODULE_ARGS',      '')\nDEFAULT_MODULE_LANG       = get_config(p, DEFAULTS, 'module_lang',      'ANSIBLE_MODULE_LANG',      'en_US.UTF-8')\nDEFAULT_TIMEOUT           = get_config(p, DEFAULTS, 'timeout',          'ANSIBLE_TIMEOUT',          10, integer=True)\nDEFAULT_POLL_INTERVAL     = get_config(p, DEFAULTS, 'poll_interval',    'ANSIBLE_POLL_INTERVAL',    15, integer=True)\nDEFAULT_REMOTE_USER       = get_config(p, DEFAULTS, 'remote_user',      'ANSIBLE_REMOTE_USER',      active_user)\nDEFAULT_ASK_PASS          = get_config(p, DEFAULTS, 'ask_pass',  'ANSIBLE_ASK_PASS',    False, boolean=True)\nDEFAULT_PRIVATE_KEY_FILE  = shell_expand_path(get_config(p, DEFAULTS, 'private_key_file', 'ANSIBLE_PRIVATE_KEY_FILE', None))\nDEFAULT_SUDO_USER         = get_config(p, DEFAULTS, 'sudo_user',        'ANSIBLE_SUDO_USER',        'root')\nDEFAULT_ASK_SUDO_PASS     = get_config(p, DEFAULTS, 'ask_sudo_pass',    'ANSIBLE_ASK_SUDO_PASS',    False, boolean=True)\nDEFAULT_REMOTE_PORT       = get_config(p, DEFAULTS, 'remote_port',      'ANSIBLE_REMOTE_PORT',      None, integer=True)\nDEFAULT_ASK_VAULT_PASS    = get_config(p, DEFAULTS, 'ask_vault_pass',    'ANSIBLE_ASK_VAULT_PASS',    False, boolean=True)\nDEFAULT_TRANSPORT         = get_config(p, DEFAULTS, 'transport',        'ANSIBLE_TRANSPORT',        'smart')\nDEFAULT_SCP_IF_SSH        = get_config(p, 'ssh_connection', 'scp_if_ssh',       'ANSIBLE_SCP_IF_SSH',       False, boolean=True)\nDEFAULT_MANAGED_STR       = get_config(p, DEFAULTS, 'ansible_managed',  None,           'Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}')\nDEFAULT_SYSLOG_FACILITY   = get_config(p, DEFAULTS, 'syslog_facility',  'ANSIBLE_SYSLOG_FACILITY', 'LOG_USER')\nDEFAULT_KEEP_REMOTE_FILES = get_config(p, DEFAULTS, 'keep_remote_files', 'ANSIBLE_KEEP_REMOTE_FILES', False, boolean=True)\nDEFAULT_SUDO              = get_config(p, DEFAULTS, 'sudo', 'ANSIBLE_SUDO', False, boolean=True)\nDEFAULT_SUDO_EXE          = get_config(p, DEFAULTS, 'sudo_exe', 'ANSIBLE_SUDO_EXE', 'sudo')\nDEFAULT_SUDO_FLAGS        = get_config(p, DEFAULTS, 'sudo_flags', 'ANSIBLE_SUDO_FLAGS', '-H')\nDEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')\nDEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)\nDEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')\nDEFAULT_SU_EXE = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', 'su')\nDEFAULT_SU = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, boolean=True)\nDEFAULT_SU_FLAGS = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', '')\nDEFAULT_SU_USER = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')\nDEFAULT_ASK_SU_PASS = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, boolean=True)\nDEFAULT_GATHERING = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()\n\nDEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '/usr/share/ansible_plugins/action_plugins')\nDEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '/usr/share/ansible_plugins/callback_plugins')\nDEFAULT_CONNECTION_PLUGIN_PATH = get_config(p, DEFAULTS, 'connection_plugins', 'ANSIBLE_CONNECTION_PLUGINS', '/usr/share/ansible_plugins/connection_plugins')\nDEFAULT_LOOKUP_PLUGIN_PATH     = get_config(p, DEFAULTS, 'lookup_plugins',     'ANSIBLE_LOOKUP_PLUGINS', '/usr/share/ansible_plugins/lookup_plugins')\nDEFAULT_VARS_PLUGIN_PATH       = get_config(p, DEFAULTS, 'vars_plugins',       'ANSIBLE_VARS_PLUGINS', '/usr/share/ansible_plugins/vars_plugins')\nDEFAULT_FILTER_PLUGIN_PATH     = get_config(p, DEFAULTS, 'filter_plugins',     'ANSIBLE_FILTER_PLUGINS', '/usr/share/ansible_plugins/filter_plugins')\nDEFAULT_LOG_PATH               = shell_expand_path(get_config(p, DEFAULTS, 'log_path',           'ANSIBLE_LOG_PATH', ''))\n\nANSIBLE_FORCE_COLOR            = get_config(p, DEFAULTS, 'force_color', 'ANSIBLE_FORCE_COLOR', None, boolean=True)\nANSIBLE_NOCOLOR                = get_config(p, DEFAULTS, 'nocolor', 'ANSIBLE_NOCOLOR', None, boolean=True)\nANSIBLE_NOCOWS                 = get_config(p, DEFAULTS, 'nocows', 'ANSIBLE_NOCOWS', None, boolean=True)\nDISPLAY_SKIPPED_HOSTS          = get_config(p, DEFAULTS, 'display_skipped_hosts', 'DISPLAY_SKIPPED_HOSTS', True, boolean=True)\nDEFAULT_UNDEFINED_VAR_BEHAVIOR = get_config(p, DEFAULTS, 'error_on_undefined_vars', 'ANSIBLE_ERROR_ON_UNDEFINED_VARS', True, boolean=True)\nHOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, boolean=True)\nSYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, boolean=True)\nDEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, boolean=True)\n\n# CONNECTION RELATED\nANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', None)\nANSIBLE_SSH_CONTROL_PATH       = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH', \"%(directory)s/ansible-ssh-%%h-%%p-%%r\")\nANSIBLE_SSH_PIPELINING         = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, boolean=True)\nPARAMIKO_RECORD_HOST_KEYS      = get_config(p, 'paramiko_connection', 'record_host_keys', 'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, boolean=True)\n# obsolete -- will be formally removed in 1.6\nZEROMQ_PORT                    = get_config(p, 'fireball_connection', 'zeromq_port', 'ANSIBLE_ZEROMQ_PORT', 5099, integer=True)\nACCELERATE_PORT                = get_config(p, 'accelerate', 'accelerate_port', 'ACCELERATE_PORT', 5099, integer=True)\nACCELERATE_TIMEOUT             = get_config(p, 'accelerate', 'accelerate_timeout', 'ACCELERATE_TIMEOUT', 30, integer=True)\nACCELERATE_CONNECT_TIMEOUT     = get_config(p, 'accelerate', 'accelerate_connect_timeout', 'ACCELERATE_CONNECT_TIMEOUT', 1.0, floating=True)\nACCELERATE_DAEMON_TIMEOUT      = get_config(p, 'accelerate', 'accelerate_daemon_timeout', 'ACCELERATE_DAEMON_TIMEOUT', 30, integer=True)\nACCELERATE_KEYS_DIR            = get_config(p, 'accelerate', 'accelerate_keys_dir', 'ACCELERATE_KEYS_DIR', '~/.fireball.keys')\nACCELERATE_KEYS_DIR_PERMS      = get_config(p, 'accelerate', 'accelerate_keys_dir_perms', 'ACCELERATE_KEYS_DIR_PERMS', '700')\nACCELERATE_KEYS_FILE_PERMS     = get_config(p, 'accelerate', 'accelerate_keys_file_perms', 'ACCELERATE_KEYS_FILE_PERMS', '600')\nACCELERATE_MULTI_KEY           = get_config(p, 'accelerate', 'accelerate_multi_key', 'ACCELERATE_MULTI_KEY', False, boolean=True)\nPARAMIKO_PTY                   = get_config(p, 'paramiko_connection', 'pty', 'ANSIBLE_PARAMIKO_PTY', True, boolean=True)\n\n# characters included in auto-generated passwords\nDEFAULT_PASSWORD_CHARS = ascii_letters + digits + \".,:-_\"\n\n# non-configurable things\nDEFAULT_SUDO_PASS         = None\nDEFAULT_REMOTE_PASS       = None\nDEFAULT_SUBSET            = None\nDEFAULT_SU_PASS           = None\nVAULT_VERSION_MIN         = 1.0\nVAULT_VERSION_MAX         = 1.0\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\n#import vault\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef parse_json(raw_data):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        return json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n        return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, None if file is not present or a directory. '''\n\n    if not os.path.exists(filename) or os.path.isdir(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[Pp]assword: ?$'\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s -c \"%s -c %s\"' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Expression,\n            ast.Compare,\n            ast.Str,\n            ast.List,\n            ast.Tuple,\n            ast.Dict,\n            ast.Call,\n            ast.Load,\n            ast.BinOp,\n            ast.UnaryOp,\n            ast.Num,\n            ast.Name,\n            ast.Add,\n            ast.Sub,\n            ast.Mult,\n            ast.Div,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    # builtin functions that are not safe to call\n    INVALID_CALLS = (\n       'classmethod', 'compile', 'delattr', 'eval', 'execfile', 'file',\n       'filter', 'help', 'input', 'object', 'open', 'raw_input', 'reduce',\n       'reload', 'repr', 'setattr', 'staticmethod', 'super', 'type',\n    )\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node):\n            if type(node) not in SAFE_NODES:\n                #raise Exception(\"invalid expression (%s) type=%s\" % (expr, type(node)))\n                raise Exception(\"invalid expression (%s)\" % expr)\n            super(CleansingNodeVisitor, self).generic_visit(node)\n        def visit_Call(self, call):\n            if call.func.id in INVALID_CALLS:\n                raise Exception(\"invalid function: %s\" % call.func.id)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv = CleansingNodeVisitor()\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n"], "fixing_code": ["# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport pwd\nimport sys\nimport ConfigParser\nfrom string import ascii_letters, digits\n\n# copied from utils, avoid circular reference fun :)\ndef mk_boolean(value):\n    if value is None:\n        return False\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef get_config(p, section, key, env_var, default, boolean=False, integer=False, floating=False, islist=False):\n    ''' return a configuration variable with casting '''\n    value = _get_config(p, section, key, env_var, default)\n    if boolean:\n        return mk_boolean(value)\n    if value and integer:\n        return int(value)\n    if value and floating:\n        return float(value)\n    if value and islist:\n        return [x.strip() for x in value.split(',')]\n    return value\n\ndef _get_config(p, section, key, env_var, default):\n    ''' helper function for get_config '''\n    if env_var is not None:\n        value = os.environ.get(env_var, None)\n        if value is not None:\n            return value\n    if p is not None:\n        try:\n            return p.get(section, key, raw=True)\n        except:\n            return default\n    return default\n\ndef load_config_file():\n    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''\n\n    p = ConfigParser.ConfigParser()\n\n    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)\n    if path0 is not None:\n        path0 = os.path.expanduser(path0)\n    path1 = os.getcwd() + \"/ansible.cfg\"\n    path2 = os.path.expanduser(\"~/.ansible.cfg\")\n    path3 = \"/etc/ansible/ansible.cfg\"\n\n    for path in [path0, path1, path2, path3]:\n        if path is not None and os.path.exists(path):\n            p.read(path)\n            return p\n    return None\n\ndef shell_expand_path(path):\n    ''' shell_expand_path is needed as os.path.expanduser does not work\n        when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE '''\n    if path:\n        path = os.path.expanduser(path)\n    return path\n\np = load_config_file()\n\nactive_user   = pwd.getpwuid(os.geteuid())[0]\n\n# Needed so the RPM can call setup.py and have modules land in the\n# correct location. See #1277 for discussion\nif getattr(sys, \"real_prefix\", None):\n    # in a virtualenv\n    DIST_MODULE_PATH = os.path.join(sys.prefix, 'share/ansible/')\nelse:\n    DIST_MODULE_PATH = '/usr/share/ansible/'\n\n# check all of these extensions when looking for yaml files for things like\n# group variables -- really anything we can load\nYAML_FILENAME_EXTENSIONS = [ \"\", \".yml\", \".yaml\", \".json\" ]\n\n# sections in config file\nDEFAULTS='defaults'\n\n# configurable things\nDEFAULT_HOST_LIST         = shell_expand_path(get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS', '/etc/ansible/hosts'))\nDEFAULT_MODULE_PATH       = get_config(p, DEFAULTS, 'library',          'ANSIBLE_LIBRARY',          DIST_MODULE_PATH)\nDEFAULT_ROLES_PATH        = shell_expand_path(get_config(p, DEFAULTS, 'roles_path',       'ANSIBLE_ROLES_PATH',       '/etc/ansible/roles'))\nDEFAULT_REMOTE_TMP        = shell_expand_path(get_config(p, DEFAULTS, 'remote_tmp',       'ANSIBLE_REMOTE_TEMP',      '$HOME/.ansible/tmp'))\nDEFAULT_MODULE_NAME       = get_config(p, DEFAULTS, 'module_name',      None,                       'command')\nDEFAULT_PATTERN           = get_config(p, DEFAULTS, 'pattern',          None,                       '*')\nDEFAULT_FORKS             = get_config(p, DEFAULTS, 'forks',            'ANSIBLE_FORKS',            5, integer=True)\nDEFAULT_MODULE_ARGS       = get_config(p, DEFAULTS, 'module_args',      'ANSIBLE_MODULE_ARGS',      '')\nDEFAULT_MODULE_LANG       = get_config(p, DEFAULTS, 'module_lang',      'ANSIBLE_MODULE_LANG',      'en_US.UTF-8')\nDEFAULT_TIMEOUT           = get_config(p, DEFAULTS, 'timeout',          'ANSIBLE_TIMEOUT',          10, integer=True)\nDEFAULT_POLL_INTERVAL     = get_config(p, DEFAULTS, 'poll_interval',    'ANSIBLE_POLL_INTERVAL',    15, integer=True)\nDEFAULT_REMOTE_USER       = get_config(p, DEFAULTS, 'remote_user',      'ANSIBLE_REMOTE_USER',      active_user)\nDEFAULT_ASK_PASS          = get_config(p, DEFAULTS, 'ask_pass',  'ANSIBLE_ASK_PASS',    False, boolean=True)\nDEFAULT_PRIVATE_KEY_FILE  = shell_expand_path(get_config(p, DEFAULTS, 'private_key_file', 'ANSIBLE_PRIVATE_KEY_FILE', None))\nDEFAULT_SUDO_USER         = get_config(p, DEFAULTS, 'sudo_user',        'ANSIBLE_SUDO_USER',        'root')\nDEFAULT_ASK_SUDO_PASS     = get_config(p, DEFAULTS, 'ask_sudo_pass',    'ANSIBLE_ASK_SUDO_PASS',    False, boolean=True)\nDEFAULT_REMOTE_PORT       = get_config(p, DEFAULTS, 'remote_port',      'ANSIBLE_REMOTE_PORT',      None, integer=True)\nDEFAULT_ASK_VAULT_PASS    = get_config(p, DEFAULTS, 'ask_vault_pass',    'ANSIBLE_ASK_VAULT_PASS',    False, boolean=True)\nDEFAULT_TRANSPORT         = get_config(p, DEFAULTS, 'transport',        'ANSIBLE_TRANSPORT',        'smart')\nDEFAULT_SCP_IF_SSH        = get_config(p, 'ssh_connection', 'scp_if_ssh',       'ANSIBLE_SCP_IF_SSH',       False, boolean=True)\nDEFAULT_MANAGED_STR       = get_config(p, DEFAULTS, 'ansible_managed',  None,           'Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}')\nDEFAULT_SYSLOG_FACILITY   = get_config(p, DEFAULTS, 'syslog_facility',  'ANSIBLE_SYSLOG_FACILITY', 'LOG_USER')\nDEFAULT_KEEP_REMOTE_FILES = get_config(p, DEFAULTS, 'keep_remote_files', 'ANSIBLE_KEEP_REMOTE_FILES', False, boolean=True)\nDEFAULT_SUDO              = get_config(p, DEFAULTS, 'sudo', 'ANSIBLE_SUDO', False, boolean=True)\nDEFAULT_SUDO_EXE          = get_config(p, DEFAULTS, 'sudo_exe', 'ANSIBLE_SUDO_EXE', 'sudo')\nDEFAULT_SUDO_FLAGS        = get_config(p, DEFAULTS, 'sudo_flags', 'ANSIBLE_SUDO_FLAGS', '-H')\nDEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')\nDEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)\nDEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')\nDEFAULT_SU_EXE            = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', 'su')\nDEFAULT_SU                = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, boolean=True)\nDEFAULT_SU_FLAGS          = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', '')\nDEFAULT_SU_USER           = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')\nDEFAULT_ASK_SU_PASS       = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, boolean=True)\nDEFAULT_GATHERING         = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()\n\nDEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '/usr/share/ansible_plugins/action_plugins')\nDEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '/usr/share/ansible_plugins/callback_plugins')\nDEFAULT_CONNECTION_PLUGIN_PATH = get_config(p, DEFAULTS, 'connection_plugins', 'ANSIBLE_CONNECTION_PLUGINS', '/usr/share/ansible_plugins/connection_plugins')\nDEFAULT_LOOKUP_PLUGIN_PATH     = get_config(p, DEFAULTS, 'lookup_plugins',     'ANSIBLE_LOOKUP_PLUGINS', '/usr/share/ansible_plugins/lookup_plugins')\nDEFAULT_VARS_PLUGIN_PATH       = get_config(p, DEFAULTS, 'vars_plugins',       'ANSIBLE_VARS_PLUGINS', '/usr/share/ansible_plugins/vars_plugins')\nDEFAULT_FILTER_PLUGIN_PATH     = get_config(p, DEFAULTS, 'filter_plugins',     'ANSIBLE_FILTER_PLUGINS', '/usr/share/ansible_plugins/filter_plugins')\nDEFAULT_LOG_PATH               = shell_expand_path(get_config(p, DEFAULTS, 'log_path',           'ANSIBLE_LOG_PATH', ''))\n\nANSIBLE_FORCE_COLOR            = get_config(p, DEFAULTS, 'force_color', 'ANSIBLE_FORCE_COLOR', None, boolean=True)\nANSIBLE_NOCOLOR                = get_config(p, DEFAULTS, 'nocolor', 'ANSIBLE_NOCOLOR', None, boolean=True)\nANSIBLE_NOCOWS                 = get_config(p, DEFAULTS, 'nocows', 'ANSIBLE_NOCOWS', None, boolean=True)\nDISPLAY_SKIPPED_HOSTS          = get_config(p, DEFAULTS, 'display_skipped_hosts', 'DISPLAY_SKIPPED_HOSTS', True, boolean=True)\nDEFAULT_UNDEFINED_VAR_BEHAVIOR = get_config(p, DEFAULTS, 'error_on_undefined_vars', 'ANSIBLE_ERROR_ON_UNDEFINED_VARS', True, boolean=True)\nHOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, boolean=True)\nSYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, boolean=True)\nDEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, boolean=True)\nDEFAULT_CALLABLE_WHITELIST     = get_config(p, DEFAULTS, 'callable_whitelist', 'ANSIBLE_CALLABLE_WHITELIST', [], islist=True)\n\n# CONNECTION RELATED\nANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', None)\nANSIBLE_SSH_CONTROL_PATH       = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH', \"%(directory)s/ansible-ssh-%%h-%%p-%%r\")\nANSIBLE_SSH_PIPELINING         = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, boolean=True)\nPARAMIKO_RECORD_HOST_KEYS      = get_config(p, 'paramiko_connection', 'record_host_keys', 'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, boolean=True)\n# obsolete -- will be formally removed in 1.6\nZEROMQ_PORT                    = get_config(p, 'fireball_connection', 'zeromq_port', 'ANSIBLE_ZEROMQ_PORT', 5099, integer=True)\nACCELERATE_PORT                = get_config(p, 'accelerate', 'accelerate_port', 'ACCELERATE_PORT', 5099, integer=True)\nACCELERATE_TIMEOUT             = get_config(p, 'accelerate', 'accelerate_timeout', 'ACCELERATE_TIMEOUT', 30, integer=True)\nACCELERATE_CONNECT_TIMEOUT     = get_config(p, 'accelerate', 'accelerate_connect_timeout', 'ACCELERATE_CONNECT_TIMEOUT', 1.0, floating=True)\nACCELERATE_DAEMON_TIMEOUT      = get_config(p, 'accelerate', 'accelerate_daemon_timeout', 'ACCELERATE_DAEMON_TIMEOUT', 30, integer=True)\nACCELERATE_KEYS_DIR            = get_config(p, 'accelerate', 'accelerate_keys_dir', 'ACCELERATE_KEYS_DIR', '~/.fireball.keys')\nACCELERATE_KEYS_DIR_PERMS      = get_config(p, 'accelerate', 'accelerate_keys_dir_perms', 'ACCELERATE_KEYS_DIR_PERMS', '700')\nACCELERATE_KEYS_FILE_PERMS     = get_config(p, 'accelerate', 'accelerate_keys_file_perms', 'ACCELERATE_KEYS_FILE_PERMS', '600')\nACCELERATE_MULTI_KEY           = get_config(p, 'accelerate', 'accelerate_multi_key', 'ACCELERATE_MULTI_KEY', False, boolean=True)\nPARAMIKO_PTY                   = get_config(p, 'paramiko_connection', 'pty', 'ANSIBLE_PARAMIKO_PTY', True, boolean=True)\n\n# characters included in auto-generated passwords\nDEFAULT_PASSWORD_CHARS = ascii_letters + digits + \".,:-_\"\n\n# non-configurable things\nDEFAULT_SUDO_PASS         = None\nDEFAULT_REMOTE_PASS       = None\nDEFAULT_SUBSET            = None\nDEFAULT_SU_PASS           = None\nVAULT_VERSION_MIN         = 1.0\nVAULT_VERSION_MAX         = 1.0\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\n#import vault\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef parse_json(raw_data):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        return json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n        return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, None if file is not present or a directory. '''\n\n    if not os.path.exists(filename) or os.path.isdir(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[Pp]assword: ?$'\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s -c \"%s -c %s\"' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Expression,\n            ast.Compare,\n            ast.Str,\n            ast.List,\n            ast.Tuple,\n            ast.Dict,\n            ast.Call,\n            ast.Load,\n            ast.BinOp,\n            ast.UnaryOp,\n            ast.Num,\n            ast.Name,\n            ast.Add,\n            ast.Sub,\n            ast.Mult,\n            ast.Div,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    # builtin functions that are safe to call\n    BUILTIN_WHITELIST = [\n        'abs', 'all', 'any', 'basestring', 'bin', 'bool', 'buffer', 'bytearray',\n        'bytes', 'callable', 'chr', 'cmp', 'coerce', 'complex', 'copyright', 'credits',\n        'dict', 'dir', 'divmod', 'enumerate', 'exit', 'float', 'format', 'frozenset',\n        'getattr', 'globals', 'hasattr', 'hash', 'hex', 'id', 'int', 'intern',\n        'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long',\n        'map', 'max', 'memoryview', 'min', 'next', 'oct', 'ord', 'pow', 'print',\n        'property', 'quit', 'range', 'reversed', 'round', 'set', 'slice', 'sorted',\n        'str', 'sum', 'tuple', 'unichr', 'unicode', 'vars', 'xrange', 'zip',\n    ]\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    CALL_WHITELIST = BUILTIN_WHITELIST + filter_list + C.DEFAULT_CALLABLE_WHITELIST\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            super(CleansingNodeVisitor, self).generic_visit(node)\n        def visit_Call(self, call):\n            if call.func.id not in CALL_WHITELIST:\n                raise Exception(\"invalid function: %s\" % call.func.id)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv = CleansingNodeVisitor()\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n"], "filenames": ["lib/ansible/constants.py", "lib/ansible/utils/__init__.py"], "buggy_code_start_loc": [34, 1068], "buggy_code_end_loc": [154, 1083], "fixing_code_start_loc": [34, 1068], "fixing_code_end_loc": [158, 1093], "type": "CWE-74", "message": "The safe_eval function in Ansible before 1.6.4 does not properly restrict the code subset, which allows remote attackers to execute arbitrary code via crafted instructions. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-4657.", "other": {"cve": {"id": "CVE-2014-4678", "sourceIdentifier": "secalert@redhat.com", "published": "2020-02-20T03:15:10.717", "lastModified": "2020-02-25T16:12:49.647", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The safe_eval function in Ansible before 1.6.4 does not properly restrict the code subset, which allows remote attackers to execute arbitrary code via crafted instructions. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-4657."}, {"lang": "es", "value": "La funci\u00f3n safe_eval en Ansible versiones anteriores a 1.6.4, no restringe apropiadamente el subconjunto de c\u00f3digos, lo que permite a atacantes remotos ejecutar c\u00f3digo arbitrario por medio de instrucciones dise\u00f1adas. NOTA: esta vulnerabilidad se presenta debido a una correcci\u00f3n incompleta del CVE-2014-4657."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.4", "matchCriteriaId": "84D2716E-AD3A-43CB-8EAC-817CC7A7601F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/ansible/ansible/commit/5429b85b9f6c2e640074176f36ff05fd5e4d1916", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/message/raw?msg=ansible-announce/ieV1vZvcTXU/5Q93ThkY9rIJ", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2014-4678", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2014/06/26/30", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2014/07/02/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.rapid7.com/db/vulnerabilities/freebsd-vid-2c493ac8-205e-11e5-a4a5-002590263bf5", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.rapid7.com/db/vulnerabilities/gentoo-linux-cve-2014-4678", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ansible/ansible/commit/5429b85b9f6c2e640074176f36ff05fd5e4d1916"}}