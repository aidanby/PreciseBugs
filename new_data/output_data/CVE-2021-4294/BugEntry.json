{"buggy_code": ["package osin\n\n// Client information\ntype Client interface {\n\t// Client id\n\tGetId() string\n\n\t// Client secret\n\tGetSecret() string\n\n\t// Base client uri\n\tGetRedirectUri() string\n\n\t// Data to be passed to storage. Not used by the library.\n\tGetUserData() interface{}\n}\n\n// ClientSecretMatcher is an optional interface clients can implement\n// which allows them to be the one to determine if a secret matches.\n// If a Client implements ClientSecretMatcher, the framework will never call GetSecret\ntype ClientSecretMatcher interface {\n\t// SecretMatches returns true if the given secret matches\n\tClientSecretMatches(secret string) bool\n}\n\n// DefaultClient stores all data in struct variables\ntype DefaultClient struct {\n\tId          string\n\tSecret      string\n\tRedirectUri string\n\tUserData    interface{}\n}\n\nfunc (d *DefaultClient) GetId() string {\n\treturn d.Id\n}\n\nfunc (d *DefaultClient) GetSecret() string {\n\treturn d.Secret\n}\n\nfunc (d *DefaultClient) GetRedirectUri() string {\n\treturn d.RedirectUri\n}\n\nfunc (d *DefaultClient) GetUserData() interface{} {\n\treturn d.UserData\n}\n\n// Implement the ClientSecretMatcher interface\nfunc (d *DefaultClient) ClientSecretMatches(secret string) bool {\n\treturn d.Secret == secret\n}\n\nfunc (d *DefaultClient) CopyFrom(client Client) {\n\td.Id = client.GetId()\n\td.Secret = client.GetSecret()\n\td.RedirectUri = client.GetRedirectUri()\n\td.UserData = client.GetUserData()\n}\n", "package osin\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// Parse basic authentication header\ntype BasicAuth struct {\n\tUsername string\n\tPassword string\n}\n\n// Parse bearer authentication header\ntype BearerAuth struct {\n\tCode string\n}\n\n// CheckClientSecret determines whether the given secret matches a secret held by the client.\n// Public clients return true for a secret of \"\"\nfunc CheckClientSecret(client Client, secret string) bool {\n\tswitch client := client.(type) {\n\tcase ClientSecretMatcher:\n\t\t// Prefer the more secure method of giving the secret to the client for comparison\n\t\treturn client.ClientSecretMatches(secret)\n\tdefault:\n\t\t// Fallback to the less secure method of extracting the plain text secret from the client for comparison\n\t\treturn client.GetSecret() == secret\n\t}\n}\n\n// Return authorization header data\nfunc CheckBasicAuth(r *http.Request) (*BasicAuth, error) {\n\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\treturn nil, nil\n\t}\n\n\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\tif len(s) != 2 || s[0] != \"Basic\" {\n\t\treturn nil, errors.New(\"Invalid authorization header\")\n\t}\n\n\tb, err := base64.StdEncoding.DecodeString(s[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpair := strings.SplitN(string(b), \":\", 2)\n\tif len(pair) != 2 {\n\t\treturn nil, errors.New(\"Invalid authorization message\")\n\t}\n\n\t// Decode the client_id and client_secret pairs as per\n\t// https://tools.ietf.org/html/rfc6749#section-2.3.1\n\n\tusername, err := url.QueryUnescape(pair[0])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpassword, err := url.QueryUnescape(pair[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &BasicAuth{Username: username, Password: password}, nil\n}\n\n// Return \"Bearer\" token from request. The header has precedence over query string.\nfunc CheckBearerAuth(r *http.Request) *BearerAuth {\n\tauthHeader := r.Header.Get(\"Authorization\")\n\tauthForm := r.FormValue(\"code\")\n\tif authHeader == \"\" && authForm == \"\" {\n\t\treturn nil\n\t}\n\ttoken := authForm\n\tif authHeader != \"\" {\n\t\ts := strings.SplitN(authHeader, \" \", 2)\n\t\tif (len(s) != 2 || strings.ToLower(s[0]) != \"bearer\") && token == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t//Use authorization header token only if token type is bearer else query string access token would be returned\n\t\tif len(s) > 0 && strings.ToLower(s[0]) == \"bearer\" {\n\t\t\ttoken = s[1]\n\t\t}\n\t}\n\treturn &BearerAuth{Code: token}\n}\n\n// getClientAuth checks client basic authentication in params if allowed,\n// otherwise gets it from the header.\n// Sets an error on the response if no auth is present or a server error occurs.\nfunc (s Server) getClientAuth(w *Response, r *http.Request, allowQueryParams bool) *BasicAuth {\n\n\tif allowQueryParams {\n\t\t// Allow for auth without password\n\t\tif _, hasSecret := r.Form[\"client_secret\"]; hasSecret {\n\t\t\tauth := &BasicAuth{\n\t\t\t\tUsername: r.FormValue(\"client_id\"),\n\t\t\t\tPassword: r.FormValue(\"client_secret\"),\n\t\t\t}\n\t\t\tif auth.Username != \"\" {\n\t\t\t\treturn auth\n\t\t\t}\n\t\t}\n\t}\n\n\tauth, err := CheckBasicAuth(r)\n\tif err != nil {\n\t\ts.setErrorAndLog(w, E_INVALID_REQUEST, err, \"get_client_auth=%s\", \"check auth error\")\n\t\treturn nil\n\t}\n\tif auth == nil {\n\t\ts.setErrorAndLog(w, E_INVALID_REQUEST, errors.New(\"Client authentication not sent\"), \"get_client_auth=%s\", \"client authentication not sent\")\n\t\treturn nil\n\t}\n\treturn auth\n}\n"], "fixing_code": ["package osin\n\nimport \"crypto/subtle\"\n\n// Client information\ntype Client interface {\n\t// Client id\n\tGetId() string\n\n\t// Client secret\n\tGetSecret() string\n\n\t// Base client uri\n\tGetRedirectUri() string\n\n\t// Data to be passed to storage. Not used by the library.\n\tGetUserData() interface{}\n}\n\n// ClientSecretMatcher is an optional interface clients can implement\n// which allows them to be the one to determine if a secret matches.\n// If a Client implements ClientSecretMatcher, the framework will never call GetSecret\ntype ClientSecretMatcher interface {\n\t// SecretMatches returns true if the given secret matches\n\tClientSecretMatches(secret string) bool\n}\n\n// DefaultClient stores all data in struct variables\ntype DefaultClient struct {\n\tId          string\n\tSecret      string\n\tRedirectUri string\n\tUserData    interface{}\n}\n\nfunc (d *DefaultClient) GetId() string {\n\treturn d.Id\n}\n\nfunc (d *DefaultClient) GetSecret() string {\n\treturn d.Secret\n}\n\nfunc (d *DefaultClient) GetRedirectUri() string {\n\treturn d.RedirectUri\n}\n\nfunc (d *DefaultClient) GetUserData() interface{} {\n\treturn d.UserData\n}\n\n// Implement the ClientSecretMatcher interface\nfunc (d *DefaultClient) ClientSecretMatches(secret string) bool {\n\treturn subtle.ConstantTimeCompare([]byte(d.Secret), []byte(secret)) == 1\n}\n\nfunc (d *DefaultClient) CopyFrom(client Client) {\n\td.Id = client.GetId()\n\td.Secret = client.GetSecret()\n\td.RedirectUri = client.GetRedirectUri()\n\td.UserData = client.GetUserData()\n}\n", "package osin\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// Parse basic authentication header\ntype BasicAuth struct {\n\tUsername string\n\tPassword string\n}\n\n// Parse bearer authentication header\ntype BearerAuth struct {\n\tCode string\n}\n\n// CheckClientSecret determines whether the given secret matches a secret held by the client.\n// Public clients return true for a secret of \"\"\nfunc CheckClientSecret(client Client, secret string) bool {\n\tswitch client := client.(type) {\n\tcase ClientSecretMatcher:\n\t\t// Prefer the more secure method of giving the secret to the client for comparison\n\t\treturn client.ClientSecretMatches(secret)\n\tdefault:\n\t\t// Fallback to the less secure method of extracting the plain text secret from the client for comparison\n\t\treturn subtle.ConstantTimeCompare([]byte(client.GetSecret()), []byte(secret)) == 1\n\t}\n}\n\n// Return authorization header data\nfunc CheckBasicAuth(r *http.Request) (*BasicAuth, error) {\n\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\treturn nil, nil\n\t}\n\n\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\tif len(s) != 2 || s[0] != \"Basic\" {\n\t\treturn nil, errors.New(\"Invalid authorization header\")\n\t}\n\n\tb, err := base64.StdEncoding.DecodeString(s[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpair := strings.SplitN(string(b), \":\", 2)\n\tif len(pair) != 2 {\n\t\treturn nil, errors.New(\"Invalid authorization message\")\n\t}\n\n\t// Decode the client_id and client_secret pairs as per\n\t// https://tools.ietf.org/html/rfc6749#section-2.3.1\n\n\tusername, err := url.QueryUnescape(pair[0])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpassword, err := url.QueryUnescape(pair[1])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &BasicAuth{Username: username, Password: password}, nil\n}\n\n// Return \"Bearer\" token from request. The header has precedence over query string.\nfunc CheckBearerAuth(r *http.Request) *BearerAuth {\n\tauthHeader := r.Header.Get(\"Authorization\")\n\tauthForm := r.FormValue(\"code\")\n\tif authHeader == \"\" && authForm == \"\" {\n\t\treturn nil\n\t}\n\ttoken := authForm\n\tif authHeader != \"\" {\n\t\ts := strings.SplitN(authHeader, \" \", 2)\n\t\tif (len(s) != 2 || strings.ToLower(s[0]) != \"bearer\") && token == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t//Use authorization header token only if token type is bearer else query string access token would be returned\n\t\tif len(s) > 0 && strings.ToLower(s[0]) == \"bearer\" {\n\t\t\ttoken = s[1]\n\t\t}\n\t}\n\treturn &BearerAuth{Code: token}\n}\n\n// getClientAuth checks client basic authentication in params if allowed,\n// otherwise gets it from the header.\n// Sets an error on the response if no auth is present or a server error occurs.\nfunc (s Server) getClientAuth(w *Response, r *http.Request, allowQueryParams bool) *BasicAuth {\n\n\tif allowQueryParams {\n\t\t// Allow for auth without password\n\t\tif _, hasSecret := r.Form[\"client_secret\"]; hasSecret {\n\t\t\tauth := &BasicAuth{\n\t\t\t\tUsername: r.FormValue(\"client_id\"),\n\t\t\t\tPassword: r.FormValue(\"client_secret\"),\n\t\t\t}\n\t\t\tif auth.Username != \"\" {\n\t\t\t\treturn auth\n\t\t\t}\n\t\t}\n\t}\n\n\tauth, err := CheckBasicAuth(r)\n\tif err != nil {\n\t\ts.setErrorAndLog(w, E_INVALID_REQUEST, err, \"get_client_auth=%s\", \"check auth error\")\n\t\treturn nil\n\t}\n\tif auth == nil {\n\t\ts.setErrorAndLog(w, E_INVALID_REQUEST, errors.New(\"Client authentication not sent\"), \"get_client_auth=%s\", \"client authentication not sent\")\n\t\treturn nil\n\t}\n\treturn auth\n}\n"], "filenames": ["client.go", "util.go"], "buggy_code_start_loc": [1, 3], "buggy_code_end_loc": [53, 32], "fixing_code_start_loc": [2, 4], "fixing_code_end_loc": [55, 33], "type": "CWE-203", "message": "A vulnerability was found in OpenShift OSIN. It has been classified as problematic. This affects the function ClientSecretMatches/CheckClientSecret. The manipulation of the argument secret leads to observable timing discrepancy. The name of the patch is 8612686d6dda34ae9ef6b5a974e4b7accb4fea29. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216987.", "other": {"cve": {"id": "CVE-2021-4294", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-28T17:15:09.067", "lastModified": "2023-01-06T20:34:11.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in OpenShift OSIN. It has been classified as problematic. This affects the function ClientSecretMatches/CheckClientSecret. The manipulation of the argument secret leads to observable timing discrepancy. The name of the patch is 8612686d6dda34ae9ef6b5a974e4b7accb4fea29. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216987."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_osin:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "E014C6CF-3910-416E-812E-F987273190C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_osin:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7C147329-7FD3-4F9E-AC5E-AA70CB45AEFD"}]}]}], "references": [{"url": "https://github.com/openshift/osin/commit/8612686d6dda34ae9ef6b5a974e4b7accb4fea29", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openshift/osin/pull/200", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216987", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216987", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openshift/osin/commit/8612686d6dda34ae9ef6b5a974e4b7accb4fea29"}}