{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * All Rights Reserved.\n */\n#ifndef __XFS_FORMAT_H__\n#define __XFS_FORMAT_H__\n\n/*\n * XFS On Disk Format Definitions\n *\n * This header file defines all the on-disk format definitions for \n * general XFS objects. Directory and attribute related objects are defined in\n * xfs_da_format.h, which log and log item formats are defined in\n * xfs_log_format.h. Everything else goes here.\n */\n\nstruct xfs_mount;\nstruct xfs_trans;\nstruct xfs_inode;\nstruct xfs_buf;\nstruct xfs_ifork;\n\n/*\n * Super block\n * Fits into a sector-sized buffer at address 0 of each allocation group.\n * Only the first of these is ever updated except during growfs.\n */\n#define\tXFS_SB_MAGIC\t\t0x58465342\t/* 'XFSB' */\n#define\tXFS_SB_VERSION_1\t1\t\t/* 5.3, 6.0.1, 6.1 */\n#define\tXFS_SB_VERSION_2\t2\t\t/* 6.2 - attributes */\n#define\tXFS_SB_VERSION_3\t3\t\t/* 6.2 - new inode version */\n#define\tXFS_SB_VERSION_4\t4\t\t/* 6.2+ - bitmask version */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n#define\tXFS_SB_VERSION_NUMBITS\t\t0x000f\n#define\tXFS_SB_VERSION_ALLFBITS\t\t0xfff0\n#define\tXFS_SB_VERSION_ATTRBIT\t\t0x0010\n#define\tXFS_SB_VERSION_NLINKBIT\t\t0x0020\n#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080\n#define\tXFS_SB_VERSION_DALIGNBIT\t0x0100\n#define\tXFS_SB_VERSION_SHAREDBIT\t0x0200\n#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define XFS_SB_VERSION_SECTORBIT\t0x0800\n#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_DIRV2BIT\t\t0x2000\n#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */\n#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000\n\n/*\n * The size of a single extended attribute on disk is limited by\n * the size of index values within the attribute entries themselves.\n * These are be16 fields, so we can only support attribute data\n * sizes up to 2^16 bytes in length.\n */\n#define XFS_XATTR_SIZE_MAX (1 << 16)\n\n/*\n * Supported feature bit list is just all bits in the versionnum field because\n * we've used them all up and understand them all. Except, of course, for the\n * shared superblock bit, which nobody knows what it does and so is unsupported.\n */\n#define\tXFS_SB_VERSION_OKBITS\t\t\\\n\t((XFS_SB_VERSION_NUMBITS | XFS_SB_VERSION_ALLFBITS) & \\\n\t\t~XFS_SB_VERSION_SHAREDBIT)\n\n/*\n * There are two words to hold XFS \"feature\" bits: the original\n * word, sb_versionnum, and sb_features2.  Whenever a bit is set in\n * sb_features2, the feature bit XFS_SB_VERSION_MOREBITSBIT must be set.\n *\n * These defines represent bits in sb_features2.\n */\n#define XFS_SB_VERSION2_RESERVED1BIT\t0x00000001\n#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define XFS_SB_VERSION2_RESERVED4BIT\t0x00000004\n#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define XFS_SB_VERSION2_PARENTBIT\t0x00000010\t/* parent pointers */\n#define XFS_SB_VERSION2_PROJID32BIT\t0x00000080\t/* 32 bit project id */\n#define XFS_SB_VERSION2_CRCBIT\t\t0x00000100\t/* metadata CRCs */\n#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */\n\n#define\tXFS_SB_VERSION2_OKBITS\t\t\\\n\t(XFS_SB_VERSION2_LAZYSBCOUNTBIT\t| \\\n\t XFS_SB_VERSION2_ATTR2BIT\t| \\\n\t XFS_SB_VERSION2_PROJID32BIT\t| \\\n\t XFS_SB_VERSION2_FTYPE)\n\n/* Maximum size of the xfs filesystem label, no terminating NULL */\n#define XFSLABEL_MAX\t\t\t12\n\n/*\n * Superblock - in core version.  Must match the ondisk version below.\n * Must be padded to 64 bit alignment.\n */\ntypedef struct xfs_sb {\n\tuint32_t\tsb_magicnum;\t/* magic number == XFS_SB_MAGIC */\n\tuint32_t\tsb_blocksize;\t/* logical block size, bytes */\n\txfs_rfsblock_t\tsb_dblocks;\t/* number of data blocks */\n\txfs_rfsblock_t\tsb_rblocks;\t/* number of realtime blocks */\n\txfs_rtblock_t\tsb_rextents;\t/* number of realtime extents */\n\tuuid_t\t\tsb_uuid;\t/* user-visible file system unique id */\n\txfs_fsblock_t\tsb_logstart;\t/* starting block of log if internal */\n\txfs_ino_t\tsb_rootino;\t/* root inode number */\n\txfs_ino_t\tsb_rbmino;\t/* bitmap inode for realtime extents */\n\txfs_ino_t\tsb_rsumino;\t/* summary inode for rt bitmap */\n\txfs_agblock_t\tsb_rextsize;\t/* realtime extent size, blocks */\n\txfs_agblock_t\tsb_agblocks;\t/* size of an allocation group */\n\txfs_agnumber_t\tsb_agcount;\t/* number of allocation groups */\n\txfs_extlen_t\tsb_rbmblocks;\t/* number of rt bitmap blocks */\n\txfs_extlen_t\tsb_logblocks;\t/* number of log blocks */\n\tuint16_t\tsb_versionnum;\t/* header version == XFS_SB_VERSION */\n\tuint16_t\tsb_sectsize;\t/* volume sector size, bytes */\n\tuint16_t\tsb_inodesize;\t/* inode size, bytes */\n\tuint16_t\tsb_inopblock;\t/* inodes per block */\n\tchar\t\tsb_fname[XFSLABEL_MAX]; /* file system name */\n\tuint8_t\t\tsb_blocklog;\t/* log2 of sb_blocksize */\n\tuint8_t\t\tsb_sectlog;\t/* log2 of sb_sectsize */\n\tuint8_t\t\tsb_inodelog;\t/* log2 of sb_inodesize */\n\tuint8_t\t\tsb_inopblog;\t/* log2 of sb_inopblock */\n\tuint8_t\t\tsb_agblklog;\t/* log2 of sb_agblocks (rounded up) */\n\tuint8_t\t\tsb_rextslog;\t/* log2 of sb_rextents */\n\tuint8_t\t\tsb_inprogress;\t/* mkfs is in progress, don't mount */\n\tuint8_t\t\tsb_imax_pct;\t/* max % of fs for inode space */\n\t\t\t\t\t/* statistics */\n\t/*\n\t * These fields must remain contiguous.  If you really\n\t * want to change their layout, make sure you fix the\n\t * code in xfs_trans_apply_sb_deltas().\n\t */\n\tuint64_t\tsb_icount;\t/* allocated inodes */\n\tuint64_t\tsb_ifree;\t/* free inodes */\n\tuint64_t\tsb_fdblocks;\t/* free data blocks */\n\tuint64_t\tsb_frextents;\t/* free realtime extents */\n\t/*\n\t * End contiguous fields.\n\t */\n\txfs_ino_t\tsb_uquotino;\t/* user quota inode */\n\txfs_ino_t\tsb_gquotino;\t/* group quota inode */\n\tuint16_t\tsb_qflags;\t/* quota flags */\n\tuint8_t\t\tsb_flags;\t/* misc. flags */\n\tuint8_t\t\tsb_shared_vn;\t/* shared version number */\n\txfs_extlen_t\tsb_inoalignmt;\t/* inode chunk alignment, fsblocks */\n\tuint32_t\tsb_unit;\t/* stripe or raid unit */\n\tuint32_t\tsb_width;\t/* stripe or raid width */\n\tuint8_t\t\tsb_dirblklog;\t/* log2 of dir block size (fsbs) */\n\tuint8_t\t\tsb_logsectlog;\t/* log2 of the log sector size */\n\tuint16_t\tsb_logsectsize;\t/* sector size for the log, bytes */\n\tuint32_t\tsb_logsunit;\t/* stripe unit size for the log */\n\tuint32_t\tsb_features2;\t/* additional feature bits */\n\n\t/*\n\t * bad features2 field as a result of failing to pad the sb structure to\n\t * 64 bits. Some machines will be using this field for features2 bits.\n\t * Easiest just to mark it bad and not use it for anything else.\n\t *\n\t * This is not kept up to date in memory; it is always overwritten by\n\t * the value in sb_features2 when formatting the incore superblock to\n\t * the disk buffer.\n\t */\n\tuint32_t\tsb_bad_features2;\n\n\t/* version 5 superblock fields start here */\n\n\t/* feature masks */\n\tuint32_t\tsb_features_compat;\n\tuint32_t\tsb_features_ro_compat;\n\tuint32_t\tsb_features_incompat;\n\tuint32_t\tsb_features_log_incompat;\n\n\tuint32_t\tsb_crc;\t\t/* superblock crc */\n\txfs_extlen_t\tsb_spino_align;\t/* sparse inode chunk alignment */\n\n\txfs_ino_t\tsb_pquotino;\t/* project quota inode */\n\txfs_lsn_t\tsb_lsn;\t\t/* last write sequence */\n\tuuid_t\t\tsb_meta_uuid;\t/* metadata file system unique id */\n\n\t/* must be padded to 64 bit alignment */\n} xfs_sb_t;\n\n#define XFS_SB_CRC_OFF\t\toffsetof(struct xfs_sb, sb_crc)\n\n/*\n * Superblock - on disk version.  Must match the in core version above.\n * Must be padded to 64 bit alignment.\n */\ntypedef struct xfs_dsb {\n\t__be32\t\tsb_magicnum;\t/* magic number == XFS_SB_MAGIC */\n\t__be32\t\tsb_blocksize;\t/* logical block size, bytes */\n\t__be64\t\tsb_dblocks;\t/* number of data blocks */\n\t__be64\t\tsb_rblocks;\t/* number of realtime blocks */\n\t__be64\t\tsb_rextents;\t/* number of realtime extents */\n\tuuid_t\t\tsb_uuid;\t/* user-visible file system unique id */\n\t__be64\t\tsb_logstart;\t/* starting block of log if internal */\n\t__be64\t\tsb_rootino;\t/* root inode number */\n\t__be64\t\tsb_rbmino;\t/* bitmap inode for realtime extents */\n\t__be64\t\tsb_rsumino;\t/* summary inode for rt bitmap */\n\t__be32\t\tsb_rextsize;\t/* realtime extent size, blocks */\n\t__be32\t\tsb_agblocks;\t/* size of an allocation group */\n\t__be32\t\tsb_agcount;\t/* number of allocation groups */\n\t__be32\t\tsb_rbmblocks;\t/* number of rt bitmap blocks */\n\t__be32\t\tsb_logblocks;\t/* number of log blocks */\n\t__be16\t\tsb_versionnum;\t/* header version == XFS_SB_VERSION */\n\t__be16\t\tsb_sectsize;\t/* volume sector size, bytes */\n\t__be16\t\tsb_inodesize;\t/* inode size, bytes */\n\t__be16\t\tsb_inopblock;\t/* inodes per block */\n\tchar\t\tsb_fname[XFSLABEL_MAX]; /* file system name */\n\t__u8\t\tsb_blocklog;\t/* log2 of sb_blocksize */\n\t__u8\t\tsb_sectlog;\t/* log2 of sb_sectsize */\n\t__u8\t\tsb_inodelog;\t/* log2 of sb_inodesize */\n\t__u8\t\tsb_inopblog;\t/* log2 of sb_inopblock */\n\t__u8\t\tsb_agblklog;\t/* log2 of sb_agblocks (rounded up) */\n\t__u8\t\tsb_rextslog;\t/* log2 of sb_rextents */\n\t__u8\t\tsb_inprogress;\t/* mkfs is in progress, don't mount */\n\t__u8\t\tsb_imax_pct;\t/* max % of fs for inode space */\n\t\t\t\t\t/* statistics */\n\t/*\n\t * These fields must remain contiguous.  If you really\n\t * want to change their layout, make sure you fix the\n\t * code in xfs_trans_apply_sb_deltas().\n\t */\n\t__be64\t\tsb_icount;\t/* allocated inodes */\n\t__be64\t\tsb_ifree;\t/* free inodes */\n\t__be64\t\tsb_fdblocks;\t/* free data blocks */\n\t__be64\t\tsb_frextents;\t/* free realtime extents */\n\t/*\n\t * End contiguous fields.\n\t */\n\t__be64\t\tsb_uquotino;\t/* user quota inode */\n\t__be64\t\tsb_gquotino;\t/* group quota inode */\n\t__be16\t\tsb_qflags;\t/* quota flags */\n\t__u8\t\tsb_flags;\t/* misc. flags */\n\t__u8\t\tsb_shared_vn;\t/* shared version number */\n\t__be32\t\tsb_inoalignmt;\t/* inode chunk alignment, fsblocks */\n\t__be32\t\tsb_unit;\t/* stripe or raid unit */\n\t__be32\t\tsb_width;\t/* stripe or raid width */\n\t__u8\t\tsb_dirblklog;\t/* log2 of dir block size (fsbs) */\n\t__u8\t\tsb_logsectlog;\t/* log2 of the log sector size */\n\t__be16\t\tsb_logsectsize;\t/* sector size for the log, bytes */\n\t__be32\t\tsb_logsunit;\t/* stripe unit size for the log */\n\t__be32\t\tsb_features2;\t/* additional feature bits */\n\t/*\n\t * bad features2 field as a result of failing to pad the sb\n\t * structure to 64 bits. Some machines will be using this field\n\t * for features2 bits. Easiest just to mark it bad and not use\n\t * it for anything else.\n\t */\n\t__be32\t\tsb_bad_features2;\n\n\t/* version 5 superblock fields start here */\n\n\t/* feature masks */\n\t__be32\t\tsb_features_compat;\n\t__be32\t\tsb_features_ro_compat;\n\t__be32\t\tsb_features_incompat;\n\t__be32\t\tsb_features_log_incompat;\n\n\t__le32\t\tsb_crc;\t\t/* superblock crc */\n\t__be32\t\tsb_spino_align;\t/* sparse inode chunk alignment */\n\n\t__be64\t\tsb_pquotino;\t/* project quota inode */\n\t__be64\t\tsb_lsn;\t\t/* last write sequence */\n\tuuid_t\t\tsb_meta_uuid;\t/* metadata file system unique id */\n\n\t/* must be padded to 64 bit alignment */\n} xfs_dsb_t;\n\n\n/*\n * Misc. Flags - warning - these will be cleared by xfs_repair unless\n * a feature bit is set when the flag is used.\n */\n#define XFS_SBF_NOFLAGS\t\t0x00\t/* no flags set */\n#define XFS_SBF_READONLY\t0x01\t/* only read-only mounts allowed */\n\n/*\n * define max. shared version we can interoperate with\n */\n#define XFS_SB_MAX_SHARED_VN\t0\n\n#define\tXFS_SB_VERSION_NUM(sbp)\t((sbp)->sb_versionnum & XFS_SB_VERSION_NUMBITS)\n\n/*\n * The first XFS version we support is a v4 superblock with V2 directories.\n */\nstatic inline bool xfs_sb_good_v4_features(struct xfs_sb *sbp)\n{\n\tif (!(sbp->sb_versionnum & XFS_SB_VERSION_DIRV2BIT))\n\t\treturn false;\n\n\t/* check for unknown features in the fs */\n\tif ((sbp->sb_versionnum & ~XFS_SB_VERSION_OKBITS) ||\n\t    ((sbp->sb_versionnum & XFS_SB_VERSION_MOREBITSBIT) &&\n\t     (sbp->sb_features2 & ~XFS_SB_VERSION2_OKBITS)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool xfs_sb_good_version(struct xfs_sb *sbp)\n{\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5)\n\t\treturn true;\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_4)\n\t\treturn xfs_sb_good_v4_features(sbp);\n\treturn false;\n}\n\nstatic inline bool xfs_sb_version_hasrealtime(struct xfs_sb *sbp)\n{\n\treturn sbp->sb_rblocks > 0;\n}\n\n/*\n * Detect a mismatched features2 field.  Older kernels read/wrote\n * this into the wrong slot, so to be safe we keep them in sync.\n */\nstatic inline bool xfs_sb_has_mismatched_features2(struct xfs_sb *sbp)\n{\n\treturn sbp->sb_bad_features2 != sbp->sb_features2;\n}\n\nstatic inline bool xfs_sb_version_hasattr(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_ATTRBIT);\n}\n\nstatic inline void xfs_sb_version_addattr(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_ATTRBIT;\n}\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}\n\nstatic inline void xfs_sb_version_addquota(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_QUOTABIT;\n}\n\nstatic inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}\n\nstatic inline bool xfs_sb_version_hasdalign(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT);\n}\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}\n\nstatic inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}\n\nstatic inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}\n\nstatic inline bool xfs_sb_version_hasmorebits(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_MOREBITSBIT);\n}\n\n/*\n * sb_features2 bit version macros.\n */\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}\n\nstatic inline void xfs_sb_version_addattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_ATTR2BIT;\n}\n\nstatic inline void xfs_sb_version_removeattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_features2 &= ~XFS_SB_VERSION2_ATTR2BIT;\n\tif (!sbp->sb_features2)\n\t\tsbp->sb_versionnum &= ~XFS_SB_VERSION_MOREBITSBIT;\n}\n\nstatic inline bool xfs_sb_version_hasprojid32bit(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT));\n}\n\nstatic inline void xfs_sb_version_addprojid32bit(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_PROJID32BIT;\n}\n\n/*\n * Extended v5 superblock feature masks. These are to be used for new v5\n * superblock features only.\n *\n * Compat features are new features that old kernels will not notice or affect\n * and so can mount read-write without issues.\n *\n * RO-Compat (read only) are features that old kernels can read but will break\n * if they write. Hence only read-only mounts of such filesystems are allowed on\n * kernels that don't support the feature bit.\n *\n * InCompat features are features which old kernels will not understand and so\n * must not mount.\n *\n * Log-InCompat features are for changes to log formats or new transactions that\n * can't be replayed on older kernels. The fields are set when the filesystem is\n * mounted, and a clean unmount clears the fields.\n */\n#define XFS_SB_FEAT_COMPAT_ALL 0\n#define XFS_SB_FEAT_COMPAT_UNKNOWN\t~XFS_SB_FEAT_COMPAT_ALL\nstatic inline bool\nxfs_sb_has_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_compat & feature) != 0;\n}\n\n#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define XFS_SB_FEAT_RO_COMPAT_RMAPBT   (1 << 1)\t\t/* reverse map btree */\n#define XFS_SB_FEAT_RO_COMPAT_REFLINK  (1 << 2)\t\t/* reflinked files */\n#define XFS_SB_FEAT_RO_COMPAT_ALL \\\n\t\t(XFS_SB_FEAT_RO_COMPAT_FINOBT | \\\n\t\t XFS_SB_FEAT_RO_COMPAT_RMAPBT | \\\n\t\t XFS_SB_FEAT_RO_COMPAT_REFLINK)\n#define XFS_SB_FEAT_RO_COMPAT_UNKNOWN\t~XFS_SB_FEAT_RO_COMPAT_ALL\nstatic inline bool\nxfs_sb_has_ro_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_ro_compat & feature) != 0;\n}\n\n#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */\n#define XFS_SB_FEAT_INCOMPAT_SPINODES\t(1 << 1)\t/* sparse inode chunks */\n#define XFS_SB_FEAT_INCOMPAT_META_UUID\t(1 << 2)\t/* metadata UUID */\n#define XFS_SB_FEAT_INCOMPAT_ALL \\\n\t\t(XFS_SB_FEAT_INCOMPAT_FTYPE|\t\\\n\t\t XFS_SB_FEAT_INCOMPAT_SPINODES|\t\\\n\t\t XFS_SB_FEAT_INCOMPAT_META_UUID)\n\n#define XFS_SB_FEAT_INCOMPAT_UNKNOWN\t~XFS_SB_FEAT_INCOMPAT_ALL\nstatic inline bool\nxfs_sb_has_incompat_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_incompat & feature) != 0;\n}\n\n#define XFS_SB_FEAT_INCOMPAT_LOG_ALL 0\n#define XFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN\t~XFS_SB_FEAT_INCOMPAT_LOG_ALL\nstatic inline bool\nxfs_sb_has_incompat_log_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_log_incompat & feature) != 0;\n}\n\n/*\n * V5 superblock specific feature checks\n */\nstatic inline bool xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}\n\nstatic inline bool xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}\n\nstatic inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}\n\nstatic inline bool xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}\n\nstatic inline bool xfs_sb_version_hassparseinodes(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_SPINODES);\n}\n\n/*\n * XFS_SB_FEAT_INCOMPAT_META_UUID indicates that the metadata UUID\n * is stored separately from the user-visible UUID; this allows the\n * user-visible UUID to be changed on V5 filesystems which have a\n * filesystem UUID stamped into every piece of metadata.\n */\nstatic inline bool xfs_sb_version_hasmetauuid(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_META_UUID);\n}\n\nstatic inline bool xfs_sb_version_hasrmapbt(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_RMAPBT);\n}\n\nstatic inline bool xfs_sb_version_hasreflink(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_REFLINK);\n}\n\n/*\n * end of superblock version macros\n */\n\nstatic inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}\n\n#define XFS_SB_DADDR\t\t((xfs_daddr_t)0) /* daddr in filesystem/ag */\n#define\tXFS_SB_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_SB_DADDR)\n#define XFS_BUF_TO_SBP(bp)\t((xfs_dsb_t *)((bp)->b_addr))\n\n#define\tXFS_HDR_BLOCK(mp,d)\t((xfs_agblock_t)XFS_BB_TO_FSBT(mp,d))\n#define\tXFS_DADDR_TO_FSB(mp,d)\tXFS_AGB_TO_FSB(mp, \\\n\t\t\txfs_daddr_to_agno(mp,d), xfs_daddr_to_agbno(mp,d))\n#define\tXFS_FSB_TO_DADDR(mp,fsbno)\tXFS_AGB_TO_DADDR(mp, \\\n\t\t\tXFS_FSB_TO_AGNO(mp,fsbno), XFS_FSB_TO_AGBNO(mp,fsbno))\n\n/*\n * File system sector to basic block conversions.\n */\n#define XFS_FSS_TO_BB(mp,sec)\t((sec) << (mp)->m_sectbb_log)\n\n/*\n * File system block to basic block conversions.\n */\n#define\tXFS_FSB_TO_BB(mp,fsbno)\t((fsbno) << (mp)->m_blkbb_log)\n#define\tXFS_BB_TO_FSB(mp,bb)\t\\\n\t(((bb) + (XFS_FSB_TO_BB(mp,1) - 1)) >> (mp)->m_blkbb_log)\n#define\tXFS_BB_TO_FSBT(mp,bb)\t((bb) >> (mp)->m_blkbb_log)\n\n/*\n * File system block to byte conversions.\n */\n#define XFS_FSB_TO_B(mp,fsbno)\t((xfs_fsize_t)(fsbno) << (mp)->m_sb.sb_blocklog)\n#define XFS_B_TO_FSB(mp,b)\t\\\n\t((((uint64_t)(b)) + (mp)->m_blockmask) >> (mp)->m_sb.sb_blocklog)\n#define XFS_B_TO_FSBT(mp,b)\t(((uint64_t)(b)) >> (mp)->m_sb.sb_blocklog)\n#define XFS_B_FSB_OFFSET(mp,b)\t((b) & (mp)->m_blockmask)\n\n/*\n * Allocation group header\n *\n * This is divided into three structures, placed in sequential 512-byte\n * buffers after a copy of the superblock (also in a 512-byte buffer).\n */\n#define\tXFS_AGF_MAGIC\t0x58414746\t/* 'XAGF' */\n#define\tXFS_AGI_MAGIC\t0x58414749\t/* 'XAGI' */\n#define\tXFS_AGFL_MAGIC\t0x5841464c\t/* 'XAFL' */\n#define\tXFS_AGF_VERSION\t1\n#define\tXFS_AGI_VERSION\t1\n\n#define\tXFS_AGF_GOOD_VERSION(v)\t((v) == XFS_AGF_VERSION)\n#define\tXFS_AGI_GOOD_VERSION(v)\t((v) == XFS_AGI_VERSION)\n\n/*\n * Btree number 0 is bno, 1 is cnt, 2 is rmap. This value gives the size of the\n * arrays below.\n */\n#define\tXFS_BTNUM_AGF\t((int)XFS_BTNUM_RMAPi + 1)\n\n/*\n * The second word of agf_levels in the first a.g. overlaps the EFS\n * superblock's magic number.  Since the magic numbers valid for EFS\n * are > 64k, our value cannot be confused for an EFS superblock's.\n */\n\ntypedef struct xfs_agf {\n\t/*\n\t * Common allocation group header information\n\t */\n\t__be32\t\tagf_magicnum;\t/* magic number == XFS_AGF_MAGIC */\n\t__be32\t\tagf_versionnum;\t/* header version == XFS_AGF_VERSION */\n\t__be32\t\tagf_seqno;\t/* sequence # starting from 0 */\n\t__be32\t\tagf_length;\t/* size in blocks of a.g. */\n\t/*\n\t * Freespace and rmap information\n\t */\n\t__be32\t\tagf_roots[XFS_BTNUM_AGF];\t/* root blocks */\n\t__be32\t\tagf_levels[XFS_BTNUM_AGF];\t/* btree levels */\n\n\t__be32\t\tagf_flfirst;\t/* first freelist block's index */\n\t__be32\t\tagf_fllast;\t/* last freelist block's index */\n\t__be32\t\tagf_flcount;\t/* count of blocks in freelist */\n\t__be32\t\tagf_freeblks;\t/* total free blocks */\n\n\t__be32\t\tagf_longest;\t/* longest free space */\n\t__be32\t\tagf_btreeblks;\t/* # of blocks held in AGF btrees */\n\tuuid_t\t\tagf_uuid;\t/* uuid of filesystem */\n\n\t__be32\t\tagf_rmap_blocks;\t/* rmapbt blocks used */\n\t__be32\t\tagf_refcount_blocks;\t/* refcountbt blocks used */\n\n\t__be32\t\tagf_refcount_root;\t/* refcount tree root block */\n\t__be32\t\tagf_refcount_level;\t/* refcount btree levels */\n\n\t/*\n\t * reserve some contiguous space for future logged fields before we add\n\t * the unlogged fields. This makes the range logging via flags and\n\t * structure offsets much simpler.\n\t */\n\t__be64\t\tagf_spare64[14];\n\n\t/* unlogged fields, written during buffer writeback. */\n\t__be64\t\tagf_lsn;\t/* last write sequence */\n\t__be32\t\tagf_crc;\t/* crc of agf sector */\n\t__be32\t\tagf_spare2;\n\n\t/* structure must be padded to 64 bit alignment */\n} xfs_agf_t;\n\n#define XFS_AGF_CRC_OFF\t\toffsetof(struct xfs_agf, agf_crc)\n\n#define\tXFS_AGF_MAGICNUM\t0x00000001\n#define\tXFS_AGF_VERSIONNUM\t0x00000002\n#define\tXFS_AGF_SEQNO\t\t0x00000004\n#define\tXFS_AGF_LENGTH\t\t0x00000008\n#define\tXFS_AGF_ROOTS\t\t0x00000010\n#define\tXFS_AGF_LEVELS\t\t0x00000020\n#define\tXFS_AGF_FLFIRST\t\t0x00000040\n#define\tXFS_AGF_FLLAST\t\t0x00000080\n#define\tXFS_AGF_FLCOUNT\t\t0x00000100\n#define\tXFS_AGF_FREEBLKS\t0x00000200\n#define\tXFS_AGF_LONGEST\t\t0x00000400\n#define\tXFS_AGF_BTREEBLKS\t0x00000800\n#define\tXFS_AGF_UUID\t\t0x00001000\n#define\tXFS_AGF_RMAP_BLOCKS\t0x00002000\n#define\tXFS_AGF_REFCOUNT_BLOCKS\t0x00004000\n#define\tXFS_AGF_REFCOUNT_ROOT\t0x00008000\n#define\tXFS_AGF_REFCOUNT_LEVEL\t0x00010000\n#define\tXFS_AGF_SPARE64\t\t0x00020000\n#define\tXFS_AGF_NUM_BITS\t18\n#define\tXFS_AGF_ALL_BITS\t((1 << XFS_AGF_NUM_BITS) - 1)\n\n#define XFS_AGF_FLAGS \\\n\t{ XFS_AGF_MAGICNUM,\t\"MAGICNUM\" }, \\\n\t{ XFS_AGF_VERSIONNUM,\t\"VERSIONNUM\" }, \\\n\t{ XFS_AGF_SEQNO,\t\"SEQNO\" }, \\\n\t{ XFS_AGF_LENGTH,\t\"LENGTH\" }, \\\n\t{ XFS_AGF_ROOTS,\t\"ROOTS\" }, \\\n\t{ XFS_AGF_LEVELS,\t\"LEVELS\" }, \\\n\t{ XFS_AGF_FLFIRST,\t\"FLFIRST\" }, \\\n\t{ XFS_AGF_FLLAST,\t\"FLLAST\" }, \\\n\t{ XFS_AGF_FLCOUNT,\t\"FLCOUNT\" }, \\\n\t{ XFS_AGF_FREEBLKS,\t\"FREEBLKS\" }, \\\n\t{ XFS_AGF_LONGEST,\t\"LONGEST\" }, \\\n\t{ XFS_AGF_BTREEBLKS,\t\"BTREEBLKS\" }, \\\n\t{ XFS_AGF_UUID,\t\t\"UUID\" }, \\\n\t{ XFS_AGF_RMAP_BLOCKS,\t\"RMAP_BLOCKS\" }, \\\n\t{ XFS_AGF_REFCOUNT_BLOCKS,\t\"REFCOUNT_BLOCKS\" }, \\\n\t{ XFS_AGF_REFCOUNT_ROOT,\t\"REFCOUNT_ROOT\" }, \\\n\t{ XFS_AGF_REFCOUNT_LEVEL,\t\"REFCOUNT_LEVEL\" }, \\\n\t{ XFS_AGF_SPARE64,\t\"SPARE64\" }\n\n/* disk block (xfs_daddr_t) in the AG */\n#define XFS_AGF_DADDR(mp)\t((xfs_daddr_t)(1 << (mp)->m_sectbb_log))\n#define\tXFS_AGF_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_AGF_DADDR(mp))\n#define\tXFS_BUF_TO_AGF(bp)\t((xfs_agf_t *)((bp)->b_addr))\n\n/*\n * Size of the unlinked inode hash table in the agi.\n */\n#define\tXFS_AGI_UNLINKED_BUCKETS\t64\n\ntypedef struct xfs_agi {\n\t/*\n\t * Common allocation group header information\n\t */\n\t__be32\t\tagi_magicnum;\t/* magic number == XFS_AGI_MAGIC */\n\t__be32\t\tagi_versionnum;\t/* header version == XFS_AGI_VERSION */\n\t__be32\t\tagi_seqno;\t/* sequence # starting from 0 */\n\t__be32\t\tagi_length;\t/* size in blocks of a.g. */\n\t/*\n\t * Inode information\n\t * Inodes are mapped by interpreting the inode number, so no\n\t * mapping data is needed here.\n\t */\n\t__be32\t\tagi_count;\t/* count of allocated inodes */\n\t__be32\t\tagi_root;\t/* root of inode btree */\n\t__be32\t\tagi_level;\t/* levels in inode btree */\n\t__be32\t\tagi_freecount;\t/* number of free inodes */\n\n\t__be32\t\tagi_newino;\t/* new inode just allocated */\n\t__be32\t\tagi_dirino;\t/* last directory inode chunk */\n\t/*\n\t * Hash table of inodes which have been unlinked but are\n\t * still being referenced.\n\t */\n\t__be32\t\tagi_unlinked[XFS_AGI_UNLINKED_BUCKETS];\n\t/*\n\t * This marks the end of logging region 1 and start of logging region 2.\n\t */\n\tuuid_t\t\tagi_uuid;\t/* uuid of filesystem */\n\t__be32\t\tagi_crc;\t/* crc of agi sector */\n\t__be32\t\tagi_pad32;\n\t__be64\t\tagi_lsn;\t/* last write sequence */\n\n\t__be32\t\tagi_free_root; /* root of the free inode btree */\n\t__be32\t\tagi_free_level;/* levels in free inode btree */\n\n\t/* structure must be padded to 64 bit alignment */\n} xfs_agi_t;\n\n#define XFS_AGI_CRC_OFF\t\toffsetof(struct xfs_agi, agi_crc)\n\n#define\tXFS_AGI_MAGICNUM\t(1 << 0)\n#define\tXFS_AGI_VERSIONNUM\t(1 << 1)\n#define\tXFS_AGI_SEQNO\t\t(1 << 2)\n#define\tXFS_AGI_LENGTH\t\t(1 << 3)\n#define\tXFS_AGI_COUNT\t\t(1 << 4)\n#define\tXFS_AGI_ROOT\t\t(1 << 5)\n#define\tXFS_AGI_LEVEL\t\t(1 << 6)\n#define\tXFS_AGI_FREECOUNT\t(1 << 7)\n#define\tXFS_AGI_NEWINO\t\t(1 << 8)\n#define\tXFS_AGI_DIRINO\t\t(1 << 9)\n#define\tXFS_AGI_UNLINKED\t(1 << 10)\n#define\tXFS_AGI_NUM_BITS_R1\t11\t/* end of the 1st agi logging region */\n#define\tXFS_AGI_ALL_BITS_R1\t((1 << XFS_AGI_NUM_BITS_R1) - 1)\n#define\tXFS_AGI_FREE_ROOT\t(1 << 11)\n#define\tXFS_AGI_FREE_LEVEL\t(1 << 12)\n#define\tXFS_AGI_NUM_BITS_R2\t13\n\n/* disk block (xfs_daddr_t) in the AG */\n#define XFS_AGI_DADDR(mp)\t((xfs_daddr_t)(2 << (mp)->m_sectbb_log))\n#define\tXFS_AGI_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_AGI_DADDR(mp))\n#define\tXFS_BUF_TO_AGI(bp)\t((xfs_agi_t *)((bp)->b_addr))\n\n/*\n * The third a.g. block contains the a.g. freelist, an array\n * of block pointers to blocks owned by the allocation btree code.\n */\n#define XFS_AGFL_DADDR(mp)\t((xfs_daddr_t)(3 << (mp)->m_sectbb_log))\n#define\tXFS_AGFL_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_AGFL_DADDR(mp))\n#define\tXFS_BUF_TO_AGFL(bp)\t((xfs_agfl_t *)((bp)->b_addr))\n\n#define XFS_BUF_TO_AGFL_BNO(mp, bp) \\\n\t(xfs_sb_version_hascrc(&((mp)->m_sb)) ? \\\n\t\t&(XFS_BUF_TO_AGFL(bp)->agfl_bno[0]) : \\\n\t\t(__be32 *)(bp)->b_addr)\n\ntypedef struct xfs_agfl {\n\t__be32\t\tagfl_magicnum;\n\t__be32\t\tagfl_seqno;\n\tuuid_t\t\tagfl_uuid;\n\t__be64\t\tagfl_lsn;\n\t__be32\t\tagfl_crc;\n\t__be32\t\tagfl_bno[];\t/* actually xfs_agfl_size(mp) */\n} __attribute__((packed)) xfs_agfl_t;\n\n#define XFS_AGFL_CRC_OFF\toffsetof(struct xfs_agfl, agfl_crc)\n\n#define XFS_AGB_TO_FSB(mp,agno,agbno)\t\\\n\t(((xfs_fsblock_t)(agno) << (mp)->m_sb.sb_agblklog) | (agbno))\n#define\tXFS_FSB_TO_AGNO(mp,fsbno)\t\\\n\t((xfs_agnumber_t)((fsbno) >> (mp)->m_sb.sb_agblklog))\n#define\tXFS_FSB_TO_AGBNO(mp,fsbno)\t\\\n\t((xfs_agblock_t)((fsbno) & xfs_mask32lo((mp)->m_sb.sb_agblklog)))\n#define\tXFS_AGB_TO_DADDR(mp,agno,agbno)\t\\\n\t((xfs_daddr_t)XFS_FSB_TO_BB(mp, \\\n\t\t(xfs_fsblock_t)(agno) * (mp)->m_sb.sb_agblocks + (agbno)))\n#define\tXFS_AG_DADDR(mp,agno,d)\t\t(XFS_AGB_TO_DADDR(mp, agno, 0) + (d))\n\n/*\n * For checking for bad ranges of xfs_daddr_t's, covering multiple\n * allocation groups or a single xfs_daddr_t that's a superblock copy.\n */\n#define\tXFS_AG_CHECK_DADDR(mp,d,len)\t\\\n\t((len) == 1 ? \\\n\t    ASSERT((d) == XFS_SB_DADDR || \\\n\t\t   xfs_daddr_to_agbno(mp, d) != XFS_SB_DADDR) : \\\n\t    ASSERT(xfs_daddr_to_agno(mp, d) == \\\n\t\t   xfs_daddr_to_agno(mp, (d) + (len) - 1)))\n\ntypedef struct xfs_timestamp {\n\t__be32\t\tt_sec;\t\t/* timestamp seconds */\n\t__be32\t\tt_nsec;\t\t/* timestamp nanoseconds */\n} xfs_timestamp_t;\n\n/*\n * On-disk inode structure.\n *\n * This is just the header or \"dinode core\", the inode is expanded to fill a\n * variable size the leftover area split into a data and an attribute fork.\n * The format of the data and attribute fork depends on the format of the\n * inode as indicated by di_format and di_aformat.  To access the data and\n * attribute use the XFS_DFORK_DPTR, XFS_DFORK_APTR, and XFS_DFORK_PTR macros\n * below.\n *\n * There is a very similar struct icdinode in xfs_inode which matches the\n * layout of the first 96 bytes of this structure, but is kept in native\n * format instead of big endian.\n *\n * Note: di_flushiter is only used by v1/2 inodes - it's effectively a zeroed\n * padding field for v3 inodes.\n */\n#define\tXFS_DINODE_MAGIC\t\t0x494e\t/* 'IN' */\ntypedef struct xfs_dinode {\n\t__be16\t\tdi_magic;\t/* inode magic # = XFS_DINODE_MAGIC */\n\t__be16\t\tdi_mode;\t/* mode and type of file */\n\t__u8\t\tdi_version;\t/* inode version */\n\t__u8\t\tdi_format;\t/* format of di_c data */\n\t__be16\t\tdi_onlink;\t/* old number of links to file */\n\t__be32\t\tdi_uid;\t\t/* owner's user id */\n\t__be32\t\tdi_gid;\t\t/* owner's group id */\n\t__be32\t\tdi_nlink;\t/* number of links to file */\n\t__be16\t\tdi_projid_lo;\t/* lower part of owner's project id */\n\t__be16\t\tdi_projid_hi;\t/* higher part owner's project id */\n\t__u8\t\tdi_pad[6];\t/* unused, zeroed space */\n\t__be16\t\tdi_flushiter;\t/* incremented on flush */\n\txfs_timestamp_t\tdi_atime;\t/* time last accessed */\n\txfs_timestamp_t\tdi_mtime;\t/* time last modified */\n\txfs_timestamp_t\tdi_ctime;\t/* time created/inode modified */\n\t__be64\t\tdi_size;\t/* number of bytes in file */\n\t__be64\t\tdi_nblocks;\t/* # of direct & btree blocks used */\n\t__be32\t\tdi_extsize;\t/* basic/minimum extent size for file */\n\t__be32\t\tdi_nextents;\t/* number of extents in data fork */\n\t__be16\t\tdi_anextents;\t/* number of extents in attribute fork*/\n\t__u8\t\tdi_forkoff;\t/* attr fork offs, <<3 for 64b align */\n\t__s8\t\tdi_aformat;\t/* format of attr fork's data */\n\t__be32\t\tdi_dmevmask;\t/* DMIG event mask */\n\t__be16\t\tdi_dmstate;\t/* DMIG state info */\n\t__be16\t\tdi_flags;\t/* random flags, XFS_DIFLAG_... */\n\t__be32\t\tdi_gen;\t\t/* generation number */\n\n\t/* di_next_unlinked is the only non-core field in the old dinode */\n\t__be32\t\tdi_next_unlinked;/* agi unlinked list ptr */\n\n\t/* start of the extended dinode, writable fields */\n\t__le32\t\tdi_crc;\t\t/* CRC of the inode */\n\t__be64\t\tdi_changecount;\t/* number of attribute changes */\n\t__be64\t\tdi_lsn;\t\t/* flush sequence */\n\t__be64\t\tdi_flags2;\t/* more random flags */\n\t__be32\t\tdi_cowextsize;\t/* basic cow extent size for file */\n\t__u8\t\tdi_pad2[12];\t/* more padding for future expansion */\n\n\t/* fields only written to during inode creation */\n\txfs_timestamp_t\tdi_crtime;\t/* time created */\n\t__be64\t\tdi_ino;\t\t/* inode number */\n\tuuid_t\t\tdi_uuid;\t/* UUID of the filesystem */\n\n\t/* structure must be padded to 64 bit alignment */\n} xfs_dinode_t;\n\n#define XFS_DINODE_CRC_OFF\toffsetof(struct xfs_dinode, di_crc)\n\n#define DI_MAX_FLUSH 0xffff\n\n/*\n * Size of the core inode on disk.  Version 1 and 2 inodes have\n * the same size, but version 3 has grown a few additional fields.\n */\nstatic inline uint xfs_dinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_dinode);\n\treturn offsetof(struct xfs_dinode, di_crc);\n}\n\n/*\n * The 32 bit link count in the inode theoretically maxes out at UINT_MAX.\n * Since the pathconf interface is signed, we use 2^31 - 1 instead.\n */\n#define\tXFS_MAXLINK\t\t((1U << 31) - 1U)\n\n/*\n * Values for di_format\n */\ntypedef enum xfs_dinode_fmt {\n\tXFS_DINODE_FMT_DEV,\t\t/* xfs_dev_t */\n\tXFS_DINODE_FMT_LOCAL,\t\t/* bulk data */\n\tXFS_DINODE_FMT_EXTENTS,\t\t/* struct xfs_bmbt_rec */\n\tXFS_DINODE_FMT_BTREE,\t\t/* struct xfs_bmdr_block */\n\tXFS_DINODE_FMT_UUID\t\t/* added long ago, but never used */\n} xfs_dinode_fmt_t;\n\n/*\n * Inode minimum and maximum sizes.\n */\n#define\tXFS_DINODE_MIN_LOG\t8\n#define\tXFS_DINODE_MAX_LOG\t11\n#define\tXFS_DINODE_MIN_SIZE\t(1 << XFS_DINODE_MIN_LOG)\n#define\tXFS_DINODE_MAX_SIZE\t(1 << XFS_DINODE_MAX_LOG)\n\n/*\n * Inode size for given fs.\n */\n#define XFS_LITINO(mp, version) \\\n\t((int)(((mp)->m_sb.sb_inodesize) - xfs_dinode_size(version)))\n\n/*\n * Inode data & attribute fork sizes, per inode.\n */\n#define XFS_DFORK_Q(dip)\t\t((dip)->di_forkoff != 0)\n#define XFS_DFORK_BOFF(dip)\t\t((int)((dip)->di_forkoff << 3))\n\n#define XFS_DFORK_DSIZE(dip,mp) \\\n\t(XFS_DFORK_Q(dip) ? \\\n\t\tXFS_DFORK_BOFF(dip) : \\\n\t\tXFS_LITINO(mp, (dip)->di_version))\n#define XFS_DFORK_ASIZE(dip,mp) \\\n\t(XFS_DFORK_Q(dip) ? \\\n\t\tXFS_LITINO(mp, (dip)->di_version) - XFS_DFORK_BOFF(dip) : \\\n\t\t0)\n#define XFS_DFORK_SIZE(dip,mp,w) \\\n\t((w) == XFS_DATA_FORK ? \\\n\t\tXFS_DFORK_DSIZE(dip, mp) : \\\n\t\tXFS_DFORK_ASIZE(dip, mp))\n\n/*\n * Return pointers to the data or attribute forks.\n */\n#define XFS_DFORK_DPTR(dip) \\\n\t((char *)dip + xfs_dinode_size(dip->di_version))\n#define XFS_DFORK_APTR(dip)\t\\\n\t(XFS_DFORK_DPTR(dip) + XFS_DFORK_BOFF(dip))\n#define XFS_DFORK_PTR(dip,w)\t\\\n\t((w) == XFS_DATA_FORK ? XFS_DFORK_DPTR(dip) : XFS_DFORK_APTR(dip))\n\n#define XFS_DFORK_FORMAT(dip,w) \\\n\t((w) == XFS_DATA_FORK ? \\\n\t\t(dip)->di_format : \\\n\t\t(dip)->di_aformat)\n#define XFS_DFORK_NEXTENTS(dip,w) \\\n\t((w) == XFS_DATA_FORK ? \\\n\t\tbe32_to_cpu((dip)->di_nextents) : \\\n\t\tbe16_to_cpu((dip)->di_anextents))\n\n/*\n * For block and character special files the 32bit dev_t is stored at the\n * beginning of the data fork.\n */\nstatic inline xfs_dev_t xfs_dinode_get_rdev(struct xfs_dinode *dip)\n{\n\treturn be32_to_cpu(*(__be32 *)XFS_DFORK_DPTR(dip));\n}\n\nstatic inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)\n{\n\t*(__be32 *)XFS_DFORK_DPTR(dip) = cpu_to_be32(rdev);\n}\n\n/*\n * Values for di_flags\n */\n#define XFS_DIFLAG_REALTIME_BIT  0\t/* file's blocks come from rt area */\n#define XFS_DIFLAG_PREALLOC_BIT  1\t/* file space has been preallocated */\n#define XFS_DIFLAG_NEWRTBM_BIT   2\t/* for rtbitmap inode, new format */\n#define XFS_DIFLAG_IMMUTABLE_BIT 3\t/* inode is immutable */\n#define XFS_DIFLAG_APPEND_BIT    4\t/* inode is append-only */\n#define XFS_DIFLAG_SYNC_BIT      5\t/* inode is written synchronously */\n#define XFS_DIFLAG_NOATIME_BIT   6\t/* do not update atime */\n#define XFS_DIFLAG_NODUMP_BIT    7\t/* do not dump */\n#define XFS_DIFLAG_RTINHERIT_BIT 8\t/* create with realtime bit set */\n#define XFS_DIFLAG_PROJINHERIT_BIT   9\t/* create with parents projid */\n#define XFS_DIFLAG_NOSYMLINKS_BIT   10\t/* disallow symlink creation */\n#define XFS_DIFLAG_EXTSIZE_BIT      11\t/* inode extent size allocator hint */\n#define XFS_DIFLAG_EXTSZINHERIT_BIT 12\t/* inherit inode extent size */\n#define XFS_DIFLAG_NODEFRAG_BIT     13\t/* do not reorganize/defragment */\n#define XFS_DIFLAG_FILESTREAM_BIT   14  /* use filestream allocator */\n#define XFS_DIFLAG_REALTIME      (1 << XFS_DIFLAG_REALTIME_BIT)\n#define XFS_DIFLAG_PREALLOC      (1 << XFS_DIFLAG_PREALLOC_BIT)\n#define XFS_DIFLAG_NEWRTBM       (1 << XFS_DIFLAG_NEWRTBM_BIT)\n#define XFS_DIFLAG_IMMUTABLE     (1 << XFS_DIFLAG_IMMUTABLE_BIT)\n#define XFS_DIFLAG_APPEND        (1 << XFS_DIFLAG_APPEND_BIT)\n#define XFS_DIFLAG_SYNC          (1 << XFS_DIFLAG_SYNC_BIT)\n#define XFS_DIFLAG_NOATIME       (1 << XFS_DIFLAG_NOATIME_BIT)\n#define XFS_DIFLAG_NODUMP        (1 << XFS_DIFLAG_NODUMP_BIT)\n#define XFS_DIFLAG_RTINHERIT     (1 << XFS_DIFLAG_RTINHERIT_BIT)\n#define XFS_DIFLAG_PROJINHERIT   (1 << XFS_DIFLAG_PROJINHERIT_BIT)\n#define XFS_DIFLAG_NOSYMLINKS    (1 << XFS_DIFLAG_NOSYMLINKS_BIT)\n#define XFS_DIFLAG_EXTSIZE       (1 << XFS_DIFLAG_EXTSIZE_BIT)\n#define XFS_DIFLAG_EXTSZINHERIT  (1 << XFS_DIFLAG_EXTSZINHERIT_BIT)\n#define XFS_DIFLAG_NODEFRAG      (1 << XFS_DIFLAG_NODEFRAG_BIT)\n#define XFS_DIFLAG_FILESTREAM    (1 << XFS_DIFLAG_FILESTREAM_BIT)\n\n#define XFS_DIFLAG_ANY \\\n\t(XFS_DIFLAG_REALTIME | XFS_DIFLAG_PREALLOC | XFS_DIFLAG_NEWRTBM | \\\n\t XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND | XFS_DIFLAG_SYNC | \\\n\t XFS_DIFLAG_NOATIME | XFS_DIFLAG_NODUMP | XFS_DIFLAG_RTINHERIT | \\\n\t XFS_DIFLAG_PROJINHERIT | XFS_DIFLAG_NOSYMLINKS | XFS_DIFLAG_EXTSIZE | \\\n\t XFS_DIFLAG_EXTSZINHERIT | XFS_DIFLAG_NODEFRAG | XFS_DIFLAG_FILESTREAM)\n\n/*\n * Values for di_flags2 These start by being exposed to userspace in the upper\n * 16 bits of the XFS_XFLAG_s range.\n */\n#define XFS_DIFLAG2_DAX_BIT\t0\t/* use DAX for this inode */\n#define XFS_DIFLAG2_REFLINK_BIT\t1\t/* file's blocks may be shared */\n#define XFS_DIFLAG2_COWEXTSIZE_BIT   2  /* copy on write extent size hint */\n#define XFS_DIFLAG2_DAX\t\t(1 << XFS_DIFLAG2_DAX_BIT)\n#define XFS_DIFLAG2_REFLINK     (1 << XFS_DIFLAG2_REFLINK_BIT)\n#define XFS_DIFLAG2_COWEXTSIZE  (1 << XFS_DIFLAG2_COWEXTSIZE_BIT)\n\n#define XFS_DIFLAG2_ANY \\\n\t(XFS_DIFLAG2_DAX | XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)\n\n/*\n * Inode number format:\n * low inopblog bits - offset in block\n * next agblklog bits - block number in ag\n * next agno_log bits - ag number\n * high agno_log-agblklog-inopblog bits - 0\n */\n#define\tXFS_INO_MASK(k)\t\t\t(uint32_t)((1ULL << (k)) - 1)\n#define\tXFS_INO_OFFSET_BITS(mp)\t\t(mp)->m_sb.sb_inopblog\n#define\tXFS_INO_AGBNO_BITS(mp)\t\t(mp)->m_sb.sb_agblklog\n#define\tXFS_INO_AGINO_BITS(mp)\t\t(mp)->m_agino_log\n#define\tXFS_INO_AGNO_BITS(mp)\t\t(mp)->m_agno_log\n#define\tXFS_INO_BITS(mp)\t\t\\\n\tXFS_INO_AGNO_BITS(mp) + XFS_INO_AGINO_BITS(mp)\n#define\tXFS_INO_TO_AGNO(mp,i)\t\t\\\n\t((xfs_agnumber_t)((i) >> XFS_INO_AGINO_BITS(mp)))\n#define\tXFS_INO_TO_AGINO(mp,i)\t\t\\\n\t((xfs_agino_t)(i) & XFS_INO_MASK(XFS_INO_AGINO_BITS(mp)))\n#define\tXFS_INO_TO_AGBNO(mp,i)\t\t\\\n\t(((xfs_agblock_t)(i) >> XFS_INO_OFFSET_BITS(mp)) & \\\n\t\tXFS_INO_MASK(XFS_INO_AGBNO_BITS(mp)))\n#define\tXFS_INO_TO_OFFSET(mp,i)\t\t\\\n\t((int)(i) & XFS_INO_MASK(XFS_INO_OFFSET_BITS(mp)))\n#define\tXFS_INO_TO_FSB(mp,i)\t\t\\\n\tXFS_AGB_TO_FSB(mp, XFS_INO_TO_AGNO(mp,i), XFS_INO_TO_AGBNO(mp,i))\n#define\tXFS_AGINO_TO_INO(mp,a,i)\t\\\n\t(((xfs_ino_t)(a) << XFS_INO_AGINO_BITS(mp)) | (i))\n#define\tXFS_AGINO_TO_AGBNO(mp,i)\t((i) >> XFS_INO_OFFSET_BITS(mp))\n#define\tXFS_AGINO_TO_OFFSET(mp,i)\t\\\n\t((i) & XFS_INO_MASK(XFS_INO_OFFSET_BITS(mp)))\n#define\tXFS_OFFBNO_TO_AGINO(mp,b,o)\t\\\n\t((xfs_agino_t)(((b) << XFS_INO_OFFSET_BITS(mp)) | (o)))\n\n#define\tXFS_MAXINUMBER\t\t((xfs_ino_t)((1ULL << 56) - 1ULL))\n#define\tXFS_MAXINUMBER_32\t((xfs_ino_t)((1ULL << 32) - 1ULL))\n\n/*\n * RealTime Device format definitions\n */\n\n/* Min and max rt extent sizes, specified in bytes */\n#define\tXFS_MAX_RTEXTSIZE\t(1024 * 1024 * 1024)\t/* 1GB */\n#define\tXFS_DFL_RTEXTSIZE\t(64 * 1024)\t        /* 64kB */\n#define\tXFS_MIN_RTEXTSIZE\t(4 * 1024)\t\t/* 4kB */\n\n#define\tXFS_BLOCKSIZE(mp)\t((mp)->m_sb.sb_blocksize)\n#define\tXFS_BLOCKMASK(mp)\t((mp)->m_blockmask)\n#define\tXFS_BLOCKWSIZE(mp)\t((mp)->m_blockwsize)\n#define\tXFS_BLOCKWMASK(mp)\t((mp)->m_blockwmask)\n\n/*\n * RT Summary and bit manipulation macros.\n */\n#define\tXFS_SUMOFFS(mp,ls,bb)\t((int)((ls) * (mp)->m_sb.sb_rbmblocks + (bb)))\n#define\tXFS_SUMOFFSTOBLOCK(mp,s)\t\\\n\t(((s) * (uint)sizeof(xfs_suminfo_t)) >> (mp)->m_sb.sb_blocklog)\n#define\tXFS_SUMPTR(mp,bp,so)\t\\\n\t((xfs_suminfo_t *)((bp)->b_addr + \\\n\t\t(((so) * (uint)sizeof(xfs_suminfo_t)) & XFS_BLOCKMASK(mp))))\n\n#define\tXFS_BITTOBLOCK(mp,bi)\t((bi) >> (mp)->m_blkbit_log)\n#define\tXFS_BLOCKTOBIT(mp,bb)\t((bb) << (mp)->m_blkbit_log)\n#define\tXFS_BITTOWORD(mp,bi)\t\\\n\t((int)(((bi) >> XFS_NBWORDLOG) & XFS_BLOCKWMASK(mp)))\n\n#define\tXFS_RTMIN(a,b)\t((a) < (b) ? (a) : (b))\n#define\tXFS_RTMAX(a,b)\t((a) > (b) ? (a) : (b))\n\n#define\tXFS_RTLOBIT(w)\txfs_lowbit32(w)\n#define\tXFS_RTHIBIT(w)\txfs_highbit32(w)\n\n#define\tXFS_RTBLOCKLOG(b)\txfs_highbit64(b)\n\n/*\n * Dquot and dquot block format definitions\n */\n#define XFS_DQUOT_MAGIC\t\t0x4451\t\t/* 'DQ' */\n#define XFS_DQUOT_VERSION\t(uint8_t)0x01\t/* latest version number */\n\n/*\n * This is the main portion of the on-disk representation of quota\n * information for a user. This is the q_core of the xfs_dquot_t that\n * is kept in kernel memory. We pad this with some more expansion room\n * to construct the on disk structure.\n */\ntypedef struct\txfs_disk_dquot {\n\t__be16\t\td_magic;\t/* dquot magic = XFS_DQUOT_MAGIC */\n\t__u8\t\td_version;\t/* dquot version */\n\t__u8\t\td_flags;\t/* XFS_DQ_USER/PROJ/GROUP */\n\t__be32\t\td_id;\t\t/* user,project,group id */\n\t__be64\t\td_blk_hardlimit;/* absolute limit on disk blks */\n\t__be64\t\td_blk_softlimit;/* preferred limit on disk blks */\n\t__be64\t\td_ino_hardlimit;/* maximum # allocated inodes */\n\t__be64\t\td_ino_softlimit;/* preferred inode limit */\n\t__be64\t\td_bcount;\t/* disk blocks owned by the user */\n\t__be64\t\td_icount;\t/* inodes owned by the user */\n\t__be32\t\td_itimer;\t/* zero if within inode limits if not,\n\t\t\t\t\t   this is when we refuse service */\n\t__be32\t\td_btimer;\t/* similar to above; for disk blocks */\n\t__be16\t\td_iwarns;\t/* warnings issued wrt num inodes */\n\t__be16\t\td_bwarns;\t/* warnings issued wrt disk blocks */\n\t__be32\t\td_pad0;\t\t/* 64 bit align */\n\t__be64\t\td_rtb_hardlimit;/* absolute limit on realtime blks */\n\t__be64\t\td_rtb_softlimit;/* preferred limit on RT disk blks */\n\t__be64\t\td_rtbcount;\t/* realtime blocks owned */\n\t__be32\t\td_rtbtimer;\t/* similar to above; for RT disk blocks */\n\t__be16\t\td_rtbwarns;\t/* warnings issued wrt RT disk blocks */\n\t__be16\t\td_pad;\n} xfs_disk_dquot_t;\n\n/*\n * This is what goes on disk. This is separated from the xfs_disk_dquot because\n * carrying the unnecessary padding would be a waste of memory.\n */\ntypedef struct xfs_dqblk {\n\txfs_disk_dquot_t  dd_diskdq;\t/* portion that lives incore as well */\n\tchar\t\t  dd_fill[4];\t/* filling for posterity */\n\n\t/*\n\t * These two are only present on filesystems with the CRC bits set.\n\t */\n\t__be32\t\t  dd_crc;\t/* checksum */\n\t__be64\t\t  dd_lsn;\t/* last modification in log */\n\tuuid_t\t\t  dd_uuid;\t/* location information */\n} xfs_dqblk_t;\n\n#define XFS_DQUOT_CRC_OFF\toffsetof(struct xfs_dqblk, dd_crc)\n\n/*\n * Remote symlink format and access functions.\n */\n#define XFS_SYMLINK_MAGIC\t0x58534c4d\t/* XSLM */\n\nstruct xfs_dsymlink_hdr {\n\t__be32\tsl_magic;\n\t__be32\tsl_offset;\n\t__be32\tsl_bytes;\n\t__be32\tsl_crc;\n\tuuid_t\tsl_uuid;\n\t__be64\tsl_owner;\n\t__be64\tsl_blkno;\n\t__be64\tsl_lsn;\n};\n\n#define XFS_SYMLINK_CRC_OFF\toffsetof(struct xfs_dsymlink_hdr, sl_crc)\n\n#define XFS_SYMLINK_MAXLEN\t1024\n/*\n * The maximum pathlen is 1024 bytes. Since the minimum file system\n * blocksize is 512 bytes, we can get a max of 3 extents back from\n * bmapi when crc headers are taken into account.\n */\n#define XFS_SYMLINK_MAPS 3\n\n#define XFS_SYMLINK_BUF_SPACE(mp, bufsize)\t\\\n\t((bufsize) - (xfs_sb_version_hascrc(&(mp)->m_sb) ? \\\n\t\t\tsizeof(struct xfs_dsymlink_hdr) : 0))\n\n\n/*\n * Allocation Btree format definitions\n *\n * There are two on-disk btrees, one sorted by blockno and one sorted\n * by blockcount and blockno.  All blocks look the same to make the code\n * simpler; if we have time later, we'll make the optimizations.\n */\n#define\tXFS_ABTB_MAGIC\t\t0x41425442\t/* 'ABTB' for bno tree */\n#define\tXFS_ABTB_CRC_MAGIC\t0x41423342\t/* 'AB3B' */\n#define\tXFS_ABTC_MAGIC\t\t0x41425443\t/* 'ABTC' for cnt tree */\n#define\tXFS_ABTC_CRC_MAGIC\t0x41423343\t/* 'AB3C' */\n\n/*\n * Data record/key structure\n */\ntypedef struct xfs_alloc_rec {\n\t__be32\t\tar_startblock;\t/* starting block number */\n\t__be32\t\tar_blockcount;\t/* count of free blocks */\n} xfs_alloc_rec_t, xfs_alloc_key_t;\n\ntypedef struct xfs_alloc_rec_incore {\n\txfs_agblock_t\tar_startblock;\t/* starting block number */\n\txfs_extlen_t\tar_blockcount;\t/* count of free blocks */\n} xfs_alloc_rec_incore_t;\n\n/* btree pointer type */\ntypedef __be32 xfs_alloc_ptr_t;\n\n/*\n * Block numbers in the AG:\n * SB is sector 0, AGF is sector 1, AGI is sector 2, AGFL is sector 3.\n */\n#define\tXFS_BNO_BLOCK(mp)\t((xfs_agblock_t)(XFS_AGFL_BLOCK(mp) + 1))\n#define\tXFS_CNT_BLOCK(mp)\t((xfs_agblock_t)(XFS_BNO_BLOCK(mp) + 1))\n\n\n/*\n * Inode Allocation Btree format definitions\n *\n * There is a btree for the inode map per allocation group.\n */\n#define\tXFS_IBT_MAGIC\t\t0x49414254\t/* 'IABT' */\n#define\tXFS_IBT_CRC_MAGIC\t0x49414233\t/* 'IAB3' */\n#define\tXFS_FIBT_MAGIC\t\t0x46494254\t/* 'FIBT' */\n#define\tXFS_FIBT_CRC_MAGIC\t0x46494233\t/* 'FIB3' */\n\ntypedef uint64_t\txfs_inofree_t;\n#define\tXFS_INODES_PER_CHUNK\t\t(NBBY * sizeof(xfs_inofree_t))\n#define\tXFS_INODES_PER_CHUNK_LOG\t(XFS_NBBYLOG + 3)\n#define\tXFS_INOBT_ALL_FREE\t\t((xfs_inofree_t)-1)\n#define\tXFS_INOBT_MASK(i)\t\t((xfs_inofree_t)1 << (i))\n\n#define XFS_INOBT_HOLEMASK_FULL\t\t0\t/* holemask for full chunk */\n#define XFS_INOBT_HOLEMASK_BITS\t\t(NBBY * sizeof(uint16_t))\n#define XFS_INODES_PER_HOLEMASK_BIT\t\\\n\t(XFS_INODES_PER_CHUNK / (NBBY * sizeof(uint16_t)))\n\nstatic inline xfs_inofree_t xfs_inobt_maskn(int i, int n)\n{\n\treturn ((n >= XFS_INODES_PER_CHUNK ? 0 : XFS_INOBT_MASK(n)) - 1) << i;\n}\n\n/*\n * The on-disk inode record structure has two formats. The original \"full\"\n * format uses a 4-byte freecount. The \"sparse\" format uses a 1-byte freecount\n * and replaces the 3 high-order freecount bytes wth the holemask and inode\n * count.\n *\n * The holemask of the sparse record format allows an inode chunk to have holes\n * that refer to blocks not owned by the inode record. This facilitates inode\n * allocation in the event of severe free space fragmentation.\n */\ntypedef struct xfs_inobt_rec {\n\t__be32\t\tir_startino;\t/* starting inode number */\n\tunion {\n\t\tstruct {\n\t\t\t__be32\tir_freecount;\t/* count of free inodes */\n\t\t} f;\n\t\tstruct {\n\t\t\t__be16\tir_holemask;/* hole mask for sparse chunks */\n\t\t\t__u8\tir_count;\t/* total inode count */\n\t\t\t__u8\tir_freecount;\t/* count of free inodes */\n\t\t} sp;\n\t} ir_u;\n\t__be64\t\tir_free;\t/* free inode mask */\n} xfs_inobt_rec_t;\n\ntypedef struct xfs_inobt_rec_incore {\n\txfs_agino_t\tir_startino;\t/* starting inode number */\n\tuint16_t\tir_holemask;\t/* hole mask for sparse chunks */\n\tuint8_t\t\tir_count;\t/* total inode count */\n\tuint8_t\t\tir_freecount;\t/* count of free inodes (set bits) */\n\txfs_inofree_t\tir_free;\t/* free inode mask */\n} xfs_inobt_rec_incore_t;\n\nstatic inline bool xfs_inobt_issparse(uint16_t holemask)\n{\n\t/* non-zero holemask represents a sparse rec. */\n\treturn holemask;\n}\n\n/*\n * Key structure\n */\ntypedef struct xfs_inobt_key {\n\t__be32\t\tir_startino;\t/* starting inode number */\n} xfs_inobt_key_t;\n\n/* btree pointer type */\ntypedef __be32 xfs_inobt_ptr_t;\n\n/*\n * block numbers in the AG.\n */\n#define\tXFS_IBT_BLOCK(mp)\t\t((xfs_agblock_t)(XFS_CNT_BLOCK(mp) + 1))\n#define\tXFS_FIBT_BLOCK(mp)\t\t((xfs_agblock_t)(XFS_IBT_BLOCK(mp) + 1))\n\n/*\n * Reverse mapping btree format definitions\n *\n * There is a btree for the reverse map per allocation group\n */\n#define\tXFS_RMAP_CRC_MAGIC\t0x524d4233\t/* 'RMB3' */\n\n/*\n * Ownership info for an extent.  This is used to create reverse-mapping\n * entries.\n */\n#define XFS_OWNER_INFO_ATTR_FORK\t(1 << 0)\n#define XFS_OWNER_INFO_BMBT_BLOCK\t(1 << 1)\nstruct xfs_owner_info {\n\tuint64_t\t\toi_owner;\n\txfs_fileoff_t\t\toi_offset;\n\tunsigned int\t\toi_flags;\n};\n\n/*\n * Special owner types.\n *\n * Seeing as we only support up to 8EB, we have the upper bit of the owner field\n * to tell us we have a special owner value. We use these for static metadata\n * allocated at mkfs/growfs time, as well as for freespace management metadata.\n */\n#define XFS_RMAP_OWN_NULL\t(-1ULL)\t/* No owner, for growfs */\n#define XFS_RMAP_OWN_UNKNOWN\t(-2ULL)\t/* Unknown owner, for EFI recovery */\n#define XFS_RMAP_OWN_FS\t\t(-3ULL)\t/* static fs metadata */\n#define XFS_RMAP_OWN_LOG\t(-4ULL)\t/* static fs metadata */\n#define XFS_RMAP_OWN_AG\t\t(-5ULL)\t/* AG freespace btree blocks */\n#define XFS_RMAP_OWN_INOBT\t(-6ULL)\t/* Inode btree blocks */\n#define XFS_RMAP_OWN_INODES\t(-7ULL)\t/* Inode chunk */\n#define XFS_RMAP_OWN_REFC\t(-8ULL) /* refcount tree */\n#define XFS_RMAP_OWN_COW\t(-9ULL) /* cow allocations */\n#define XFS_RMAP_OWN_MIN\t(-10ULL) /* guard */\n\n#define XFS_RMAP_NON_INODE_OWNER(owner)\t(!!((owner) & (1ULL << 63)))\n\n/*\n * Data record structure\n */\nstruct xfs_rmap_rec {\n\t__be32\t\trm_startblock;\t/* extent start block */\n\t__be32\t\trm_blockcount;\t/* extent length */\n\t__be64\t\trm_owner;\t/* extent owner */\n\t__be64\t\trm_offset;\t/* offset within the owner */\n};\n\n/*\n * rmap btree record\n *  rm_offset:63 is the attribute fork flag\n *  rm_offset:62 is the bmbt block flag\n *  rm_offset:61 is the unwritten extent flag (same as l0:63 in bmbt)\n *  rm_offset:54-60 aren't used and should be zero\n *  rm_offset:0-53 is the block offset within the inode\n */\n#define XFS_RMAP_OFF_ATTR_FORK\t((uint64_t)1ULL << 63)\n#define XFS_RMAP_OFF_BMBT_BLOCK\t((uint64_t)1ULL << 62)\n#define XFS_RMAP_OFF_UNWRITTEN\t((uint64_t)1ULL << 61)\n\n#define XFS_RMAP_LEN_MAX\t((uint32_t)~0U)\n#define XFS_RMAP_OFF_FLAGS\t(XFS_RMAP_OFF_ATTR_FORK | \\\n\t\t\t\t XFS_RMAP_OFF_BMBT_BLOCK | \\\n\t\t\t\t XFS_RMAP_OFF_UNWRITTEN)\n#define XFS_RMAP_OFF_MASK\t((uint64_t)0x3FFFFFFFFFFFFFULL)\n\n#define XFS_RMAP_OFF(off)\t\t((off) & XFS_RMAP_OFF_MASK)\n\n#define XFS_RMAP_IS_BMBT_BLOCK(off)\t(!!((off) & XFS_RMAP_OFF_BMBT_BLOCK))\n#define XFS_RMAP_IS_ATTR_FORK(off)\t(!!((off) & XFS_RMAP_OFF_ATTR_FORK))\n#define XFS_RMAP_IS_UNWRITTEN(len)\t(!!((off) & XFS_RMAP_OFF_UNWRITTEN))\n\n#define RMAPBT_STARTBLOCK_BITLEN\t32\n#define RMAPBT_BLOCKCOUNT_BITLEN\t32\n#define RMAPBT_OWNER_BITLEN\t\t64\n#define RMAPBT_ATTRFLAG_BITLEN\t\t1\n#define RMAPBT_BMBTFLAG_BITLEN\t\t1\n#define RMAPBT_EXNTFLAG_BITLEN\t\t1\n#define RMAPBT_UNUSED_OFFSET_BITLEN\t7\n#define RMAPBT_OFFSET_BITLEN\t\t54\n\n#define XFS_RMAP_ATTR_FORK\t\t(1 << 0)\n#define XFS_RMAP_BMBT_BLOCK\t\t(1 << 1)\n#define XFS_RMAP_UNWRITTEN\t\t(1 << 2)\n#define XFS_RMAP_KEY_FLAGS\t\t(XFS_RMAP_ATTR_FORK | \\\n\t\t\t\t\t XFS_RMAP_BMBT_BLOCK)\n#define XFS_RMAP_REC_FLAGS\t\t(XFS_RMAP_UNWRITTEN)\nstruct xfs_rmap_irec {\n\txfs_agblock_t\trm_startblock;\t/* extent start block */\n\txfs_extlen_t\trm_blockcount;\t/* extent length */\n\tuint64_t\trm_owner;\t/* extent owner */\n\tuint64_t\trm_offset;\t/* offset within the owner */\n\tunsigned int\trm_flags;\t/* state flags */\n};\n\n/*\n * Key structure\n *\n * We don't use the length for lookups\n */\nstruct xfs_rmap_key {\n\t__be32\t\trm_startblock;\t/* extent start block */\n\t__be64\t\trm_owner;\t/* extent owner */\n\t__be64\t\trm_offset;\t/* offset within the owner */\n} __attribute__((packed));\n\n/* btree pointer type */\ntypedef __be32 xfs_rmap_ptr_t;\n\n#define\tXFS_RMAP_BLOCK(mp) \\\n\t(xfs_sb_version_hasfinobt(&((mp)->m_sb)) ? \\\n\t XFS_FIBT_BLOCK(mp) + 1 : \\\n\t XFS_IBT_BLOCK(mp) + 1)\n\n/*\n * Reference Count Btree format definitions\n *\n */\n#define\tXFS_REFC_CRC_MAGIC\t0x52334643\t/* 'R3FC' */\n\nunsigned int xfs_refc_block(struct xfs_mount *mp);\n\n/*\n * Data record/key structure\n *\n * Each record associates a range of physical blocks (starting at\n * rc_startblock and ending rc_blockcount blocks later) with a reference\n * count (rc_refcount).  Extents that are being used to stage a copy on\n * write (CoW) operation are recorded in the refcount btree with a\n * refcount of 1.  All other records must have a refcount > 1 and must\n * track an extent mapped only by file data forks.\n *\n * Extents with a single owner (attributes, metadata, non-shared file\n * data) are not tracked here.  Free space is also not tracked here.\n * This is consistent with pre-reflink XFS.\n */\n\n/*\n * Extents that are being used to stage a copy on write are stored\n * in the refcount btree with a refcount of 1 and the upper bit set\n * on the startblock.  This speeds up mount time deletion of stale\n * staging extents because they're all at the right side of the tree.\n */\n#define XFS_REFC_COW_START\t\t((xfs_agblock_t)(1U << 31))\n#define REFCNTBT_COWFLAG_BITLEN\t\t1\n#define REFCNTBT_AGBLOCK_BITLEN\t\t31\n\nstruct xfs_refcount_rec {\n\t__be32\t\trc_startblock;\t/* starting block number */\n\t__be32\t\trc_blockcount;\t/* count of blocks */\n\t__be32\t\trc_refcount;\t/* number of inodes linked here */\n};\n\nstruct xfs_refcount_key {\n\t__be32\t\trc_startblock;\t/* starting block number */\n};\n\nstruct xfs_refcount_irec {\n\txfs_agblock_t\trc_startblock;\t/* starting block number */\n\txfs_extlen_t\trc_blockcount;\t/* count of free blocks */\n\txfs_nlink_t\trc_refcount;\t/* number of inodes linked here */\n};\n\n#define MAXREFCOUNT\t((xfs_nlink_t)~0U)\n#define MAXREFCEXTLEN\t((xfs_extlen_t)~0U)\n\n/* btree pointer type */\ntypedef __be32 xfs_refcount_ptr_t;\n\n\n/*\n * BMAP Btree format definitions\n *\n * This includes both the root block definition that sits inside an inode fork\n * and the record/pointer formats for the leaf/node in the blocks.\n */\n#define XFS_BMAP_MAGIC\t\t0x424d4150\t/* 'BMAP' */\n#define XFS_BMAP_CRC_MAGIC\t0x424d4133\t/* 'BMA3' */\n\n/*\n * Bmap root header, on-disk form only.\n */\ntypedef struct xfs_bmdr_block {\n\t__be16\t\tbb_level;\t/* 0 is a leaf */\n\t__be16\t\tbb_numrecs;\t/* current # of data records */\n} xfs_bmdr_block_t;\n\n/*\n * Bmap btree record and extent descriptor.\n *  l0:63 is an extent flag (value 1 indicates non-normal).\n *  l0:9-62 are startoff.\n *  l0:0-8 and l1:21-63 are startblock.\n *  l1:0-20 are blockcount.\n */\n#define BMBT_EXNTFLAG_BITLEN\t1\n#define BMBT_STARTOFF_BITLEN\t54\n#define BMBT_STARTBLOCK_BITLEN\t52\n#define BMBT_BLOCKCOUNT_BITLEN\t21\n\ntypedef struct xfs_bmbt_rec {\n\t__be64\t\t\tl0, l1;\n} xfs_bmbt_rec_t;\n\ntypedef uint64_t\txfs_bmbt_rec_base_t;\t/* use this for casts */\ntypedef xfs_bmbt_rec_t xfs_bmdr_rec_t;\n\n/*\n * Values and macros for delayed-allocation startblock fields.\n */\n#define STARTBLOCKVALBITS\t17\n#define STARTBLOCKMASKBITS\t(15 + 20)\n#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}\n\nstatic inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}\n\nstatic inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}\n\n/*\n * Key structure for non-leaf levels of the tree.\n */\ntypedef struct xfs_bmbt_key {\n\t__be64\t\tbr_startoff;\t/* starting file offset */\n} xfs_bmbt_key_t, xfs_bmdr_key_t;\n\n/* btree pointer type */\ntypedef __be64 xfs_bmbt_ptr_t, xfs_bmdr_ptr_t;\n\n\n/*\n * Generic Btree block format definitions\n *\n * This is a combination of the actual format used on disk for short and long\n * format btrees.  The first three fields are shared by both format, but the\n * pointers are different and should be used with care.\n *\n * To get the size of the actual short or long form headers please use the size\n * macros below.  Never use sizeof(xfs_btree_block).\n *\n * The blkno, crc, lsn, owner and uuid fields are only available in filesystems\n * with the crc feature bit, and all accesses to them must be conditional on\n * that flag.\n */\n/* short form block header */\nstruct xfs_btree_block_shdr {\n\t__be32\t\tbb_leftsib;\n\t__be32\t\tbb_rightsib;\n\n\t__be64\t\tbb_blkno;\n\t__be64\t\tbb_lsn;\n\tuuid_t\t\tbb_uuid;\n\t__be32\t\tbb_owner;\n\t__le32\t\tbb_crc;\n};\n\n/* long form block header */\nstruct xfs_btree_block_lhdr {\n\t__be64\t\tbb_leftsib;\n\t__be64\t\tbb_rightsib;\n\n\t__be64\t\tbb_blkno;\n\t__be64\t\tbb_lsn;\n\tuuid_t\t\tbb_uuid;\n\t__be64\t\tbb_owner;\n\t__le32\t\tbb_crc;\n\t__be32\t\tbb_pad; /* padding for alignment */\n};\n\nstruct xfs_btree_block {\n\t__be32\t\tbb_magic;\t/* magic number for block type */\n\t__be16\t\tbb_level;\t/* 0 is a leaf */\n\t__be16\t\tbb_numrecs;\t/* current # of data records */\n\tunion {\n\t\tstruct xfs_btree_block_shdr s;\n\t\tstruct xfs_btree_block_lhdr l;\n\t} bb_u;\t\t\t\t/* rest */\n};\n\n/* size of a short form block */\n#define XFS_BTREE_SBLOCK_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t offsetof(struct xfs_btree_block_shdr, bb_blkno))\n/* size of a long form block */\n#define XFS_BTREE_LBLOCK_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t offsetof(struct xfs_btree_block_lhdr, bb_blkno))\n\n/* sizes of CRC enabled btree blocks */\n#define XFS_BTREE_SBLOCK_CRC_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t sizeof(struct xfs_btree_block_shdr))\n#define XFS_BTREE_LBLOCK_CRC_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t sizeof(struct xfs_btree_block_lhdr))\n\n#define XFS_BTREE_SBLOCK_CRC_OFF \\\n\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc)\n#define XFS_BTREE_LBLOCK_CRC_OFF \\\n\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc)\n\n/*\n * On-disk XFS access control list structure.\n */\nstruct xfs_acl_entry {\n\t__be32\tae_tag;\n\t__be32\tae_id;\n\t__be16\tae_perm;\n\t__be16\tae_pad;\t\t/* fill the implicit hole in the structure */\n};\n\nstruct xfs_acl {\n\t__be32\t\t\tacl_cnt;\n\tstruct xfs_acl_entry\tacl_entry[0];\n};\n\n/*\n * The number of ACL entries allowed is defined by the on-disk format.\n * For v4 superblocks, that is limited to 25 entries. For v5 superblocks, it is\n * limited only by the maximum size of the xattr that stores the information.\n */\n#define XFS_ACL_MAX_ENTRIES(mp)\t\\\n\t(xfs_sb_version_hascrc(&mp->m_sb) \\\n\t\t?  (XFS_XATTR_SIZE_MAX - sizeof(struct xfs_acl)) / \\\n\t\t\t\t\t\tsizeof(struct xfs_acl_entry) \\\n\t\t: 25)\n\n#define XFS_ACL_SIZE(cnt) \\\n\t(sizeof(struct xfs_acl) + \\\n\t\tsizeof(struct xfs_acl_entry) * cnt)\n\n#define XFS_ACL_MAX_SIZE(mp) \\\n\tXFS_ACL_SIZE(XFS_ACL_MAX_ENTRIES((mp)))\n\n\n/* On-disk XFS extended attribute names */\n#define SGI_ACL_FILE\t\t\"SGI_ACL_FILE\"\n#define SGI_ACL_DEFAULT\t\t\"SGI_ACL_DEFAULT\"\n#define SGI_ACL_FILE_SIZE\t(sizeof(SGI_ACL_FILE)-1)\n#define SGI_ACL_DEFAULT_SIZE\t(sizeof(SGI_ACL_DEFAULT)-1)\n\n#endif /* __XFS_FORMAT_H__ */\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2006 Silicon Graphics, Inc.\n * All Rights Reserved.\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n\n#include <linux/iversion.h>\n\n/*\n * Check that none of the inode's in the buffer have a next\n * unlinked field of 0.\n */\n#if defined(DEBUG)\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = xfs_buf_offset(bp, i * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}\n#endif\n\nbool\nxfs_dinode_good_version(\n\tstruct xfs_mount *mp,\n\t__u8\t\tversion)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn version == 3;\n\n\treturn version == 1 || version == 2;\n}\n\n/*\n * If we are doing readahead on an inode buffer, we might be in log recovery\n * reading an inode allocation buffer that hasn't yet been replayed, and hence\n * has not had the inode cores stamped into it. Hence for readahead, the buffer\n * may be potentially invalid.\n *\n * If the readahead buffer is invalid, we need to mark it with an error and\n * clear the DONE status of the buffer so that a followup read will re-read it\n * from disk. We don't report the error otherwise to avoid warnings during log\n * recovery and we don't get unnecssary panics on debug kernels. We use EIO here\n * because all we want to do is say readahead failed; there is no-one to report\n * the error to, so this will distinguish it from a non-ra verifier failure.\n * Changes to this readahead error behavour also need to be reflected in\n * xfs_dquot_buf_readahead_verify().\n */\nstatic void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\txfs_agnumber_t\tagno;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tagno = xfs_daddr_to_agno(mp, XFS_BUF_ADDR(bp));\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\t\txfs_agino_t\tunlinked_ino;\n\n\t\tdip = xfs_buf_offset(bp, (i << mp->m_sb.sb_inodelog));\n\t\tunlinked_ino = be32_to_cpu(dip->di_next_unlinked);\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\txfs_dinode_good_version(mp, dip->di_version) &&\n\t\t\t(unlinked_ino == NULLAGINO ||\n\t\t\t xfs_verify_agino(mp, agno, unlinked_ino));\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\txfs_buf_ioerror(bp, -EIO);\n\t\t\t\treturn;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t\txfs_buf_verifier_error(bp, -EFSCORRUPTED,\n\t\t\t\t\t__func__, dip, sizeof(*dip),\n\t\t\t\t\tNULL);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nstatic void\nxfs_inode_buf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}\n\nstatic void\nxfs_inode_buf_readahead_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, true);\n}\n\nstatic void\nxfs_inode_buf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.name = \"xfs_inode\",\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nconst struct xfs_buf_ops xfs_inode_buf_ra_ops = {\n\t.name = \"xxfs_inode_ra\",\n\t.verify_read = xfs_inode_buf_readahead_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\n\n/*\n * This routine is called to map an inode to the buffer containing the on-disk\n * version of the inode.  It returns a pointer to the buffer containing the\n * on-disk inode in the bpp parameter, and in the dipp parameter it returns a\n * pointer to the on-disk inode within that buffer.\n *\n * If a non-zero error is returned, then the contents of bpp and dipp are\n * undefined.\n */\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}\n\nvoid\nxfs_inode_from_disk(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*from)\n{\n\tstruct xfs_icdinode\t*to = &ip->i_d;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\n\t/*\n\t * Convert v1 inodes immediately to v2 inode format as this is the\n\t * minimum inode version format we support in the rest of the code.\n\t */\n\tto->di_version = from->di_version;\n\tif (to->di_version == 1) {\n\t\tset_nlink(inode, be16_to_cpu(from->di_onlink));\n\t\tto->di_projid_lo = 0;\n\t\tto->di_projid_hi = 0;\n\t\tto->di_version = 2;\n\t} else {\n\t\tset_nlink(inode, be32_to_cpu(from->di_nlink));\n\t\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\t\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\t}\n\n\tto->di_format = from->di_format;\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\n\t/*\n\t * Time is signed, so need to convert to signed 32 bit before\n\t * storing in inode timestamp which may be 64 bit. Otherwise\n\t * a time before epoch is converted to a time long after epoch\n\t * on 64 bit systems.\n\t */\n\tinode->i_atime.tv_sec = (int)be32_to_cpu(from->di_atime.t_sec);\n\tinode->i_atime.tv_nsec = (int)be32_to_cpu(from->di_atime.t_nsec);\n\tinode->i_mtime.tv_sec = (int)be32_to_cpu(from->di_mtime.t_sec);\n\tinode->i_mtime.tv_nsec = (int)be32_to_cpu(from->di_mtime.t_nsec);\n\tinode->i_ctime.tv_sec = (int)be32_to_cpu(from->di_ctime.t_sec);\n\tinode->i_ctime.tv_nsec = (int)be32_to_cpu(from->di_ctime.t_nsec);\n\tinode->i_generation = be32_to_cpu(from->di_gen);\n\tinode->i_mode = be16_to_cpu(from->di_mode);\n\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\n\tif (to->di_version == 3) {\n\t\tinode_set_iversion_queried(inode,\n\t\t\t\t\t   be64_to_cpu(from->di_changecount));\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_cowextsize = be32_to_cpu(from->di_cowextsize);\n\t}\n}\n\nvoid\nxfs_inode_to_disk(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*to,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_icdinode\t*from = &ip->i_d;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tto->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\tto->di_onlink = 0;\n\n\tto->di_version = from->di_version;\n\tto->di_format = from->di_format;\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\n\tmemset(to->di_pad, 0, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(inode->i_atime.tv_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(inode->i_atime.tv_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(inode->i_mtime.tv_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(inode->i_mtime.tv_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(inode->i_ctime.tv_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(inode->i_ctime.tv_nsec);\n\tto->di_nlink = cpu_to_be32(inode->i_nlink);\n\tto->di_gen = cpu_to_be32(inode->i_generation);\n\tto->di_mode = cpu_to_be16(inode->i_mode);\n\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(inode_peek_iversion(inode));\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_cowextsize = cpu_to_be32(from->di_cowextsize);\n\t\tto->di_ino = cpu_to_be64(ip->i_ino);\n\t\tto->di_lsn = cpu_to_be64(lsn);\n\t\tmemset(to->di_pad2, 0, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &ip->i_mount->m_sb.sb_meta_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}\n\nvoid\nxfs_log_dinode_to_disk(\n\tstruct xfs_log_dinode\t*from,\n\tstruct xfs_dinode\t*to)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = 0;\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_cowextsize = cpu_to_be32(from->di_cowextsize);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}\n\nxfs_failaddr_t\nxfs_dinode_verify(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_failaddr_t\t\tfa;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tflags;\n\tuint64_t\t\tflags2;\n\tuint64_t\t\tdi_size;\n\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn __this_address;\n\n\t/* Verify v3 integrity information first */\n\tif (dip->di_version >= 3) {\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn __this_address;\n\t\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t\t      XFS_DINODE_CRC_OFF))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(dip->di_ino) != ino)\n\t\t\treturn __this_address;\n\t\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t}\n\n\t/* don't allow invalid i_size */\n\tdi_size = be64_to_cpu(dip->di_size);\n\tif (di_size & (1ULL << 63))\n\t\treturn __this_address;\n\n\tmode = be16_to_cpu(dip->di_mode);\n\tif (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)\n\t\treturn __this_address;\n\n\t/* No zero-length symlinks/dirs. */\n\tif ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)\n\t\treturn __this_address;\n\n\t/* Fork checks carried over from xfs_iformat_fork */\n\tif (mode &&\n\t    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >\n\t\t\tbe64_to_cpu(dip->di_nblocks))\n\t\treturn __this_address;\n\n\tif (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)\n\t\treturn __this_address;\n\n\tflags = be16_to_cpu(dip->di_flags);\n\n\tif (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\treturn __this_address;\n\n\t/* Do we have appropriate data fork formats for the mode? */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (dip->di_format != XFS_DINODE_FMT_DEV)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (S_ISREG(mode))\n\t\t\t\treturn __this_address;\n\t\t\tif (di_size > XFS_DFORK_DSIZE(dip, mp))\n\t\t\t\treturn __this_address;\n\t\t\tif (dip->di_nextents)\n\t\t\t\treturn __this_address;\n\t\t\t/* fall through */\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\t/* Uninitialized inode ok. */\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\n\tif (XFS_DFORK_Q(dip)) {\n\t\tswitch (dip->di_aformat) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\tif (dip->di_anextents)\n\t\t\t\treturn __this_address;\n\t\t/* fall through */\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If there is no fork offset, this may be a freshly-made inode\n\t\t * in a new disk cluster, in which case di_aformat is zeroed.\n\t\t * Otherwise, such an inode must be in EXTENTS format; this goes\n\t\t * for freed inodes as well.\n\t\t */\n\t\tswitch (dip->di_aformat) {\n\t\tcase 0:\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t\tif (dip->di_anextents)\n\t\t\treturn __this_address;\n\t}\n\n\t/* extent size hint validation */\n\tfa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),\n\t\t\tmode, flags);\n\tif (fa)\n\t\treturn fa;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn NULL;\n\n\tflags2 = be64_to_cpu(dip->di_flags2);\n\n\t/* don't allow reflink/cowextsize if we don't have reflink */\n\tif ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&\n\t     !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\t/* only regular files get reflink */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)\n\t\treturn __this_address;\n\n\t/* don't let reflink and realtime mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))\n\t\treturn __this_address;\n\n\t/* don't let reflink and dax mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))\n\t\treturn __this_address;\n\n\t/* COW extent size hint validation */\n\tfa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),\n\t\t\tmode, flags, flags2);\n\tif (fa)\n\t\treturn fa;\n\n\treturn NULL;\n}\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\tuint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum_update((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}\n\n/*\n * Read the disk inode attributes into the in-core inode structure.\n *\n * For version 5 superblocks, if we are initialising a new inode and we are not\n * utilising the XFS_MOUNT_IKEEP inode cluster mode, we can simple build the new\n * inode core with a random generation number. If we are keeping inodes around,\n * we need to read the inode cluster to get the existing generation number off\n * disk. Further, if we are using version 4 superblocks (i.e. v1/v2 inode\n * format) then log recovery is dependent on the di_flushiter field being\n * initialised from the current on-disk value and hence we must also read the\n * inode off disk.\n */\nint\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tiget_flags)\n{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\txfs_failaddr_t\tfa;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* shortcut IO on inode allocation if possible */\n\tif ((iget_flags & XFS_IGET_CREATE) &&\n\t    xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\t/* initialise the on-disk inode core */\n\t\tmemset(&ip->i_d, 0, sizeof(ip->i_d));\n\t\tVFS_I(ip)->i_generation = prandom_u32();\n\t\tip->i_d.di_version = 3;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &bp, 0, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* even unallocated inodes are verified */\n\tfa = xfs_dinode_verify(mp, ip->i_ino, dip);\n\tif (fa) {\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, \"dinode\", dip,\n\t\t\t\tsizeof(*dip), fa);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat_fork() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_inode_from_disk(ip, dip);\n\t\terror = xfs_iformat_fork(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_alert(mp, \"%s: xfs_iformat() returned error %d\",\n\t\t\t\t__func__, error);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Partial initialisation of the in-core inode. Just the bits\n\t\t * that xfs_ialloc won't overwrite or relies on being correct.\n\t\t */\n\t\tip->i_d.di_version = dip->di_version;\n\t\tVFS_I(ip)->i_generation = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tVFS_I(ip)->i_mode = 0;\n\t}\n\n\tASSERT(ip->i_d.di_version >= 2);\n\tip->i_delayed_blks = 0;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\txfs_buf_set_ref(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the on-disk\n\t * inode, because it was acquired with xfs_trans_read_buf() in\n\t * xfs_imap_to_bp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be locking the\n\t * new in-core inode before putting it in the cache where other\n\t * processes can find it.  Thus we don't have to worry about the inode\n\t * being changed just because we released the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}\n\n/*\n * Validate di_extsize hint.\n *\n * The rules are documented at xfs_ioctl_setattr_check_extsize().\n * These functions must be kept in sync with each other.\n */\nxfs_failaddr_t\nxfs_inode_validate_extsize(\n\tstruct xfs_mount\t\t*mp,\n\tuint32_t\t\t\textsize,\n\tuint16_t\t\t\tmode,\n\tuint16_t\t\t\tflags)\n{\n\tbool\t\t\t\trt_flag;\n\tbool\t\t\t\thint_flag;\n\tbool\t\t\t\tinherit_flag;\n\tuint32_t\t\t\textsize_bytes;\n\tuint32_t\t\t\tblocksize_bytes;\n\n\trt_flag = (flags & XFS_DIFLAG_REALTIME);\n\thint_flag = (flags & XFS_DIFLAG_EXTSIZE);\n\tinherit_flag = (flags & XFS_DIFLAG_EXTSZINHERIT);\n\textsize_bytes = XFS_FSB_TO_B(mp, extsize);\n\n\tif (rt_flag)\n\t\tblocksize_bytes = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\n\telse\n\t\tblocksize_bytes = mp->m_sb.sb_blocksize;\n\n\tif ((hint_flag || inherit_flag) && !(S_ISDIR(mode) || S_ISREG(mode)))\n\t\treturn __this_address;\n\n\tif (hint_flag && !S_ISREG(mode))\n\t\treturn __this_address;\n\n\tif (inherit_flag && !S_ISDIR(mode))\n\t\treturn __this_address;\n\n\tif ((hint_flag || inherit_flag) && extsize == 0)\n\t\treturn __this_address;\n\n\tif (!(hint_flag || inherit_flag) && extsize != 0)\n\t\treturn __this_address;\n\n\tif (extsize_bytes % blocksize_bytes)\n\t\treturn __this_address;\n\n\tif (extsize > MAXEXTLEN)\n\t\treturn __this_address;\n\n\tif (!rt_flag && extsize > mp->m_sb.sb_agblocks / 2)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\n/*\n * Validate di_cowextsize hint.\n *\n * The rules are documented at xfs_ioctl_setattr_check_cowextsize().\n * These functions must be kept in sync with each other.\n */\nxfs_failaddr_t\nxfs_inode_validate_cowextsize(\n\tstruct xfs_mount\t\t*mp,\n\tuint32_t\t\t\tcowextsize,\n\tuint16_t\t\t\tmode,\n\tuint16_t\t\t\tflags,\n\tuint64_t\t\t\tflags2)\n{\n\tbool\t\t\t\trt_flag;\n\tbool\t\t\t\thint_flag;\n\tuint32_t\t\t\tcowextsize_bytes;\n\n\trt_flag = (flags & XFS_DIFLAG_REALTIME);\n\thint_flag = (flags2 & XFS_DIFLAG2_COWEXTSIZE);\n\tcowextsize_bytes = XFS_FSB_TO_B(mp, cowextsize);\n\n\tif (hint_flag && !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\tif (hint_flag && !(S_ISDIR(mode) || S_ISREG(mode)))\n\t\treturn __this_address;\n\n\tif (hint_flag && cowextsize == 0)\n\t\treturn __this_address;\n\n\tif (!hint_flag && cowextsize != 0)\n\t\treturn __this_address;\n\n\tif (hint_flag && rt_flag)\n\t\treturn __this_address;\n\n\tif (cowextsize_bytes % mp->m_sb.sb_blocksize)\n\t\treturn __this_address;\n\n\tif (cowextsize > MAXEXTLEN)\n\t\treturn __this_address;\n\n\tif (cowextsize > mp->m_sb.sb_agblocks / 2)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * All Rights Reserved.\n */\n#ifndef __XFS_FORMAT_H__\n#define __XFS_FORMAT_H__\n\n/*\n * XFS On Disk Format Definitions\n *\n * This header file defines all the on-disk format definitions for \n * general XFS objects. Directory and attribute related objects are defined in\n * xfs_da_format.h, which log and log item formats are defined in\n * xfs_log_format.h. Everything else goes here.\n */\n\nstruct xfs_mount;\nstruct xfs_trans;\nstruct xfs_inode;\nstruct xfs_buf;\nstruct xfs_ifork;\n\n/*\n * Super block\n * Fits into a sector-sized buffer at address 0 of each allocation group.\n * Only the first of these is ever updated except during growfs.\n */\n#define\tXFS_SB_MAGIC\t\t0x58465342\t/* 'XFSB' */\n#define\tXFS_SB_VERSION_1\t1\t\t/* 5.3, 6.0.1, 6.1 */\n#define\tXFS_SB_VERSION_2\t2\t\t/* 6.2 - attributes */\n#define\tXFS_SB_VERSION_3\t3\t\t/* 6.2 - new inode version */\n#define\tXFS_SB_VERSION_4\t4\t\t/* 6.2+ - bitmask version */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n#define\tXFS_SB_VERSION_NUMBITS\t\t0x000f\n#define\tXFS_SB_VERSION_ALLFBITS\t\t0xfff0\n#define\tXFS_SB_VERSION_ATTRBIT\t\t0x0010\n#define\tXFS_SB_VERSION_NLINKBIT\t\t0x0020\n#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n#define\tXFS_SB_VERSION_ALIGNBIT\t\t0x0080\n#define\tXFS_SB_VERSION_DALIGNBIT\t0x0100\n#define\tXFS_SB_VERSION_SHAREDBIT\t0x0200\n#define XFS_SB_VERSION_LOGV2BIT\t\t0x0400\n#define XFS_SB_VERSION_SECTORBIT\t0x0800\n#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_DIRV2BIT\t\t0x2000\n#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */\n#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000\n\n/*\n * The size of a single extended attribute on disk is limited by\n * the size of index values within the attribute entries themselves.\n * These are be16 fields, so we can only support attribute data\n * sizes up to 2^16 bytes in length.\n */\n#define XFS_XATTR_SIZE_MAX (1 << 16)\n\n/*\n * Supported feature bit list is just all bits in the versionnum field because\n * we've used them all up and understand them all. Except, of course, for the\n * shared superblock bit, which nobody knows what it does and so is unsupported.\n */\n#define\tXFS_SB_VERSION_OKBITS\t\t\\\n\t((XFS_SB_VERSION_NUMBITS | XFS_SB_VERSION_ALLFBITS) & \\\n\t\t~XFS_SB_VERSION_SHAREDBIT)\n\n/*\n * There are two words to hold XFS \"feature\" bits: the original\n * word, sb_versionnum, and sb_features2.  Whenever a bit is set in\n * sb_features2, the feature bit XFS_SB_VERSION_MOREBITSBIT must be set.\n *\n * These defines represent bits in sb_features2.\n */\n#define XFS_SB_VERSION2_RESERVED1BIT\t0x00000001\n#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define XFS_SB_VERSION2_RESERVED4BIT\t0x00000004\n#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define XFS_SB_VERSION2_PARENTBIT\t0x00000010\t/* parent pointers */\n#define XFS_SB_VERSION2_PROJID32BIT\t0x00000080\t/* 32 bit project id */\n#define XFS_SB_VERSION2_CRCBIT\t\t0x00000100\t/* metadata CRCs */\n#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */\n\n#define\tXFS_SB_VERSION2_OKBITS\t\t\\\n\t(XFS_SB_VERSION2_LAZYSBCOUNTBIT\t| \\\n\t XFS_SB_VERSION2_ATTR2BIT\t| \\\n\t XFS_SB_VERSION2_PROJID32BIT\t| \\\n\t XFS_SB_VERSION2_FTYPE)\n\n/* Maximum size of the xfs filesystem label, no terminating NULL */\n#define XFSLABEL_MAX\t\t\t12\n\n/*\n * Superblock - in core version.  Must match the ondisk version below.\n * Must be padded to 64 bit alignment.\n */\ntypedef struct xfs_sb {\n\tuint32_t\tsb_magicnum;\t/* magic number == XFS_SB_MAGIC */\n\tuint32_t\tsb_blocksize;\t/* logical block size, bytes */\n\txfs_rfsblock_t\tsb_dblocks;\t/* number of data blocks */\n\txfs_rfsblock_t\tsb_rblocks;\t/* number of realtime blocks */\n\txfs_rtblock_t\tsb_rextents;\t/* number of realtime extents */\n\tuuid_t\t\tsb_uuid;\t/* user-visible file system unique id */\n\txfs_fsblock_t\tsb_logstart;\t/* starting block of log if internal */\n\txfs_ino_t\tsb_rootino;\t/* root inode number */\n\txfs_ino_t\tsb_rbmino;\t/* bitmap inode for realtime extents */\n\txfs_ino_t\tsb_rsumino;\t/* summary inode for rt bitmap */\n\txfs_agblock_t\tsb_rextsize;\t/* realtime extent size, blocks */\n\txfs_agblock_t\tsb_agblocks;\t/* size of an allocation group */\n\txfs_agnumber_t\tsb_agcount;\t/* number of allocation groups */\n\txfs_extlen_t\tsb_rbmblocks;\t/* number of rt bitmap blocks */\n\txfs_extlen_t\tsb_logblocks;\t/* number of log blocks */\n\tuint16_t\tsb_versionnum;\t/* header version == XFS_SB_VERSION */\n\tuint16_t\tsb_sectsize;\t/* volume sector size, bytes */\n\tuint16_t\tsb_inodesize;\t/* inode size, bytes */\n\tuint16_t\tsb_inopblock;\t/* inodes per block */\n\tchar\t\tsb_fname[XFSLABEL_MAX]; /* file system name */\n\tuint8_t\t\tsb_blocklog;\t/* log2 of sb_blocksize */\n\tuint8_t\t\tsb_sectlog;\t/* log2 of sb_sectsize */\n\tuint8_t\t\tsb_inodelog;\t/* log2 of sb_inodesize */\n\tuint8_t\t\tsb_inopblog;\t/* log2 of sb_inopblock */\n\tuint8_t\t\tsb_agblklog;\t/* log2 of sb_agblocks (rounded up) */\n\tuint8_t\t\tsb_rextslog;\t/* log2 of sb_rextents */\n\tuint8_t\t\tsb_inprogress;\t/* mkfs is in progress, don't mount */\n\tuint8_t\t\tsb_imax_pct;\t/* max % of fs for inode space */\n\t\t\t\t\t/* statistics */\n\t/*\n\t * These fields must remain contiguous.  If you really\n\t * want to change their layout, make sure you fix the\n\t * code in xfs_trans_apply_sb_deltas().\n\t */\n\tuint64_t\tsb_icount;\t/* allocated inodes */\n\tuint64_t\tsb_ifree;\t/* free inodes */\n\tuint64_t\tsb_fdblocks;\t/* free data blocks */\n\tuint64_t\tsb_frextents;\t/* free realtime extents */\n\t/*\n\t * End contiguous fields.\n\t */\n\txfs_ino_t\tsb_uquotino;\t/* user quota inode */\n\txfs_ino_t\tsb_gquotino;\t/* group quota inode */\n\tuint16_t\tsb_qflags;\t/* quota flags */\n\tuint8_t\t\tsb_flags;\t/* misc. flags */\n\tuint8_t\t\tsb_shared_vn;\t/* shared version number */\n\txfs_extlen_t\tsb_inoalignmt;\t/* inode chunk alignment, fsblocks */\n\tuint32_t\tsb_unit;\t/* stripe or raid unit */\n\tuint32_t\tsb_width;\t/* stripe or raid width */\n\tuint8_t\t\tsb_dirblklog;\t/* log2 of dir block size (fsbs) */\n\tuint8_t\t\tsb_logsectlog;\t/* log2 of the log sector size */\n\tuint16_t\tsb_logsectsize;\t/* sector size for the log, bytes */\n\tuint32_t\tsb_logsunit;\t/* stripe unit size for the log */\n\tuint32_t\tsb_features2;\t/* additional feature bits */\n\n\t/*\n\t * bad features2 field as a result of failing to pad the sb structure to\n\t * 64 bits. Some machines will be using this field for features2 bits.\n\t * Easiest just to mark it bad and not use it for anything else.\n\t *\n\t * This is not kept up to date in memory; it is always overwritten by\n\t * the value in sb_features2 when formatting the incore superblock to\n\t * the disk buffer.\n\t */\n\tuint32_t\tsb_bad_features2;\n\n\t/* version 5 superblock fields start here */\n\n\t/* feature masks */\n\tuint32_t\tsb_features_compat;\n\tuint32_t\tsb_features_ro_compat;\n\tuint32_t\tsb_features_incompat;\n\tuint32_t\tsb_features_log_incompat;\n\n\tuint32_t\tsb_crc;\t\t/* superblock crc */\n\txfs_extlen_t\tsb_spino_align;\t/* sparse inode chunk alignment */\n\n\txfs_ino_t\tsb_pquotino;\t/* project quota inode */\n\txfs_lsn_t\tsb_lsn;\t\t/* last write sequence */\n\tuuid_t\t\tsb_meta_uuid;\t/* metadata file system unique id */\n\n\t/* must be padded to 64 bit alignment */\n} xfs_sb_t;\n\n#define XFS_SB_CRC_OFF\t\toffsetof(struct xfs_sb, sb_crc)\n\n/*\n * Superblock - on disk version.  Must match the in core version above.\n * Must be padded to 64 bit alignment.\n */\ntypedef struct xfs_dsb {\n\t__be32\t\tsb_magicnum;\t/* magic number == XFS_SB_MAGIC */\n\t__be32\t\tsb_blocksize;\t/* logical block size, bytes */\n\t__be64\t\tsb_dblocks;\t/* number of data blocks */\n\t__be64\t\tsb_rblocks;\t/* number of realtime blocks */\n\t__be64\t\tsb_rextents;\t/* number of realtime extents */\n\tuuid_t\t\tsb_uuid;\t/* user-visible file system unique id */\n\t__be64\t\tsb_logstart;\t/* starting block of log if internal */\n\t__be64\t\tsb_rootino;\t/* root inode number */\n\t__be64\t\tsb_rbmino;\t/* bitmap inode for realtime extents */\n\t__be64\t\tsb_rsumino;\t/* summary inode for rt bitmap */\n\t__be32\t\tsb_rextsize;\t/* realtime extent size, blocks */\n\t__be32\t\tsb_agblocks;\t/* size of an allocation group */\n\t__be32\t\tsb_agcount;\t/* number of allocation groups */\n\t__be32\t\tsb_rbmblocks;\t/* number of rt bitmap blocks */\n\t__be32\t\tsb_logblocks;\t/* number of log blocks */\n\t__be16\t\tsb_versionnum;\t/* header version == XFS_SB_VERSION */\n\t__be16\t\tsb_sectsize;\t/* volume sector size, bytes */\n\t__be16\t\tsb_inodesize;\t/* inode size, bytes */\n\t__be16\t\tsb_inopblock;\t/* inodes per block */\n\tchar\t\tsb_fname[XFSLABEL_MAX]; /* file system name */\n\t__u8\t\tsb_blocklog;\t/* log2 of sb_blocksize */\n\t__u8\t\tsb_sectlog;\t/* log2 of sb_sectsize */\n\t__u8\t\tsb_inodelog;\t/* log2 of sb_inodesize */\n\t__u8\t\tsb_inopblog;\t/* log2 of sb_inopblock */\n\t__u8\t\tsb_agblklog;\t/* log2 of sb_agblocks (rounded up) */\n\t__u8\t\tsb_rextslog;\t/* log2 of sb_rextents */\n\t__u8\t\tsb_inprogress;\t/* mkfs is in progress, don't mount */\n\t__u8\t\tsb_imax_pct;\t/* max % of fs for inode space */\n\t\t\t\t\t/* statistics */\n\t/*\n\t * These fields must remain contiguous.  If you really\n\t * want to change their layout, make sure you fix the\n\t * code in xfs_trans_apply_sb_deltas().\n\t */\n\t__be64\t\tsb_icount;\t/* allocated inodes */\n\t__be64\t\tsb_ifree;\t/* free inodes */\n\t__be64\t\tsb_fdblocks;\t/* free data blocks */\n\t__be64\t\tsb_frextents;\t/* free realtime extents */\n\t/*\n\t * End contiguous fields.\n\t */\n\t__be64\t\tsb_uquotino;\t/* user quota inode */\n\t__be64\t\tsb_gquotino;\t/* group quota inode */\n\t__be16\t\tsb_qflags;\t/* quota flags */\n\t__u8\t\tsb_flags;\t/* misc. flags */\n\t__u8\t\tsb_shared_vn;\t/* shared version number */\n\t__be32\t\tsb_inoalignmt;\t/* inode chunk alignment, fsblocks */\n\t__be32\t\tsb_unit;\t/* stripe or raid unit */\n\t__be32\t\tsb_width;\t/* stripe or raid width */\n\t__u8\t\tsb_dirblklog;\t/* log2 of dir block size (fsbs) */\n\t__u8\t\tsb_logsectlog;\t/* log2 of the log sector size */\n\t__be16\t\tsb_logsectsize;\t/* sector size for the log, bytes */\n\t__be32\t\tsb_logsunit;\t/* stripe unit size for the log */\n\t__be32\t\tsb_features2;\t/* additional feature bits */\n\t/*\n\t * bad features2 field as a result of failing to pad the sb\n\t * structure to 64 bits. Some machines will be using this field\n\t * for features2 bits. Easiest just to mark it bad and not use\n\t * it for anything else.\n\t */\n\t__be32\t\tsb_bad_features2;\n\n\t/* version 5 superblock fields start here */\n\n\t/* feature masks */\n\t__be32\t\tsb_features_compat;\n\t__be32\t\tsb_features_ro_compat;\n\t__be32\t\tsb_features_incompat;\n\t__be32\t\tsb_features_log_incompat;\n\n\t__le32\t\tsb_crc;\t\t/* superblock crc */\n\t__be32\t\tsb_spino_align;\t/* sparse inode chunk alignment */\n\n\t__be64\t\tsb_pquotino;\t/* project quota inode */\n\t__be64\t\tsb_lsn;\t\t/* last write sequence */\n\tuuid_t\t\tsb_meta_uuid;\t/* metadata file system unique id */\n\n\t/* must be padded to 64 bit alignment */\n} xfs_dsb_t;\n\n\n/*\n * Misc. Flags - warning - these will be cleared by xfs_repair unless\n * a feature bit is set when the flag is used.\n */\n#define XFS_SBF_NOFLAGS\t\t0x00\t/* no flags set */\n#define XFS_SBF_READONLY\t0x01\t/* only read-only mounts allowed */\n\n/*\n * define max. shared version we can interoperate with\n */\n#define XFS_SB_MAX_SHARED_VN\t0\n\n#define\tXFS_SB_VERSION_NUM(sbp)\t((sbp)->sb_versionnum & XFS_SB_VERSION_NUMBITS)\n\n/*\n * The first XFS version we support is a v4 superblock with V2 directories.\n */\nstatic inline bool xfs_sb_good_v4_features(struct xfs_sb *sbp)\n{\n\tif (!(sbp->sb_versionnum & XFS_SB_VERSION_DIRV2BIT))\n\t\treturn false;\n\n\t/* check for unknown features in the fs */\n\tif ((sbp->sb_versionnum & ~XFS_SB_VERSION_OKBITS) ||\n\t    ((sbp->sb_versionnum & XFS_SB_VERSION_MOREBITSBIT) &&\n\t     (sbp->sb_features2 & ~XFS_SB_VERSION2_OKBITS)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool xfs_sb_good_version(struct xfs_sb *sbp)\n{\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5)\n\t\treturn true;\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_4)\n\t\treturn xfs_sb_good_v4_features(sbp);\n\treturn false;\n}\n\nstatic inline bool xfs_sb_version_hasrealtime(struct xfs_sb *sbp)\n{\n\treturn sbp->sb_rblocks > 0;\n}\n\n/*\n * Detect a mismatched features2 field.  Older kernels read/wrote\n * this into the wrong slot, so to be safe we keep them in sync.\n */\nstatic inline bool xfs_sb_has_mismatched_features2(struct xfs_sb *sbp)\n{\n\treturn sbp->sb_bad_features2 != sbp->sb_features2;\n}\n\nstatic inline bool xfs_sb_version_hasattr(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_ATTRBIT);\n}\n\nstatic inline void xfs_sb_version_addattr(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_ATTRBIT;\n}\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}\n\nstatic inline void xfs_sb_version_addquota(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_QUOTABIT;\n}\n\nstatic inline bool xfs_sb_version_hasalign(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t\t(sbp->sb_versionnum & XFS_SB_VERSION_ALIGNBIT));\n}\n\nstatic inline bool xfs_sb_version_hasdalign(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_DALIGNBIT);\n}\n\nstatic inline bool xfs_sb_version_haslogv2(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_LOGV2BIT);\n}\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}\n\nstatic inline bool xfs_sb_version_hassector(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_SECTORBIT);\n}\n\nstatic inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}\n\nstatic inline bool xfs_sb_version_hasmorebits(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_MOREBITSBIT);\n}\n\n/*\n * sb_features2 bit version macros.\n */\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}\n\nstatic inline void xfs_sb_version_addattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_ATTR2BIT;\n}\n\nstatic inline void xfs_sb_version_removeattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_features2 &= ~XFS_SB_VERSION2_ATTR2BIT;\n\tif (!sbp->sb_features2)\n\t\tsbp->sb_versionnum &= ~XFS_SB_VERSION_MOREBITSBIT;\n}\n\nstatic inline bool xfs_sb_version_hasprojid32bit(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_PROJID32BIT));\n}\n\nstatic inline void xfs_sb_version_addprojid32bit(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_PROJID32BIT;\n}\n\n/*\n * Extended v5 superblock feature masks. These are to be used for new v5\n * superblock features only.\n *\n * Compat features are new features that old kernels will not notice or affect\n * and so can mount read-write without issues.\n *\n * RO-Compat (read only) are features that old kernels can read but will break\n * if they write. Hence only read-only mounts of such filesystems are allowed on\n * kernels that don't support the feature bit.\n *\n * InCompat features are features which old kernels will not understand and so\n * must not mount.\n *\n * Log-InCompat features are for changes to log formats or new transactions that\n * can't be replayed on older kernels. The fields are set when the filesystem is\n * mounted, and a clean unmount clears the fields.\n */\n#define XFS_SB_FEAT_COMPAT_ALL 0\n#define XFS_SB_FEAT_COMPAT_UNKNOWN\t~XFS_SB_FEAT_COMPAT_ALL\nstatic inline bool\nxfs_sb_has_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_compat & feature) != 0;\n}\n\n#define XFS_SB_FEAT_RO_COMPAT_FINOBT   (1 << 0)\t\t/* free inode btree */\n#define XFS_SB_FEAT_RO_COMPAT_RMAPBT   (1 << 1)\t\t/* reverse map btree */\n#define XFS_SB_FEAT_RO_COMPAT_REFLINK  (1 << 2)\t\t/* reflinked files */\n#define XFS_SB_FEAT_RO_COMPAT_ALL \\\n\t\t(XFS_SB_FEAT_RO_COMPAT_FINOBT | \\\n\t\t XFS_SB_FEAT_RO_COMPAT_RMAPBT | \\\n\t\t XFS_SB_FEAT_RO_COMPAT_REFLINK)\n#define XFS_SB_FEAT_RO_COMPAT_UNKNOWN\t~XFS_SB_FEAT_RO_COMPAT_ALL\nstatic inline bool\nxfs_sb_has_ro_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_ro_compat & feature) != 0;\n}\n\n#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */\n#define XFS_SB_FEAT_INCOMPAT_SPINODES\t(1 << 1)\t/* sparse inode chunks */\n#define XFS_SB_FEAT_INCOMPAT_META_UUID\t(1 << 2)\t/* metadata UUID */\n#define XFS_SB_FEAT_INCOMPAT_ALL \\\n\t\t(XFS_SB_FEAT_INCOMPAT_FTYPE|\t\\\n\t\t XFS_SB_FEAT_INCOMPAT_SPINODES|\t\\\n\t\t XFS_SB_FEAT_INCOMPAT_META_UUID)\n\n#define XFS_SB_FEAT_INCOMPAT_UNKNOWN\t~XFS_SB_FEAT_INCOMPAT_ALL\nstatic inline bool\nxfs_sb_has_incompat_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_incompat & feature) != 0;\n}\n\n#define XFS_SB_FEAT_INCOMPAT_LOG_ALL 0\n#define XFS_SB_FEAT_INCOMPAT_LOG_UNKNOWN\t~XFS_SB_FEAT_INCOMPAT_LOG_ALL\nstatic inline bool\nxfs_sb_has_incompat_log_feature(\n\tstruct xfs_sb\t*sbp,\n\tuint32_t\tfeature)\n{\n\treturn (sbp->sb_features_log_incompat & feature) != 0;\n}\n\n/*\n * V5 superblock specific feature checks\n */\nstatic inline bool xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}\n\nstatic inline bool xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}\n\nstatic inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}\n\nstatic inline bool xfs_sb_version_hasfinobt(xfs_sb_t *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_FINOBT);\n}\n\nstatic inline bool xfs_sb_version_hassparseinodes(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_SPINODES);\n}\n\n/*\n * XFS_SB_FEAT_INCOMPAT_META_UUID indicates that the metadata UUID\n * is stored separately from the user-visible UUID; this allows the\n * user-visible UUID to be changed on V5 filesystems which have a\n * filesystem UUID stamped into every piece of metadata.\n */\nstatic inline bool xfs_sb_version_hasmetauuid(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_incompat & XFS_SB_FEAT_INCOMPAT_META_UUID);\n}\n\nstatic inline bool xfs_sb_version_hasrmapbt(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_RMAPBT);\n}\n\nstatic inline bool xfs_sb_version_hasreflink(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\t(sbp->sb_features_ro_compat & XFS_SB_FEAT_RO_COMPAT_REFLINK);\n}\n\n/*\n * end of superblock version macros\n */\n\nstatic inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}\n\n#define XFS_SB_DADDR\t\t((xfs_daddr_t)0) /* daddr in filesystem/ag */\n#define\tXFS_SB_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_SB_DADDR)\n#define XFS_BUF_TO_SBP(bp)\t((xfs_dsb_t *)((bp)->b_addr))\n\n#define\tXFS_HDR_BLOCK(mp,d)\t((xfs_agblock_t)XFS_BB_TO_FSBT(mp,d))\n#define\tXFS_DADDR_TO_FSB(mp,d)\tXFS_AGB_TO_FSB(mp, \\\n\t\t\txfs_daddr_to_agno(mp,d), xfs_daddr_to_agbno(mp,d))\n#define\tXFS_FSB_TO_DADDR(mp,fsbno)\tXFS_AGB_TO_DADDR(mp, \\\n\t\t\tXFS_FSB_TO_AGNO(mp,fsbno), XFS_FSB_TO_AGBNO(mp,fsbno))\n\n/*\n * File system sector to basic block conversions.\n */\n#define XFS_FSS_TO_BB(mp,sec)\t((sec) << (mp)->m_sectbb_log)\n\n/*\n * File system block to basic block conversions.\n */\n#define\tXFS_FSB_TO_BB(mp,fsbno)\t((fsbno) << (mp)->m_blkbb_log)\n#define\tXFS_BB_TO_FSB(mp,bb)\t\\\n\t(((bb) + (XFS_FSB_TO_BB(mp,1) - 1)) >> (mp)->m_blkbb_log)\n#define\tXFS_BB_TO_FSBT(mp,bb)\t((bb) >> (mp)->m_blkbb_log)\n\n/*\n * File system block to byte conversions.\n */\n#define XFS_FSB_TO_B(mp,fsbno)\t((xfs_fsize_t)(fsbno) << (mp)->m_sb.sb_blocklog)\n#define XFS_B_TO_FSB(mp,b)\t\\\n\t((((uint64_t)(b)) + (mp)->m_blockmask) >> (mp)->m_sb.sb_blocklog)\n#define XFS_B_TO_FSBT(mp,b)\t(((uint64_t)(b)) >> (mp)->m_sb.sb_blocklog)\n#define XFS_B_FSB_OFFSET(mp,b)\t((b) & (mp)->m_blockmask)\n\n/*\n * Allocation group header\n *\n * This is divided into three structures, placed in sequential 512-byte\n * buffers after a copy of the superblock (also in a 512-byte buffer).\n */\n#define\tXFS_AGF_MAGIC\t0x58414746\t/* 'XAGF' */\n#define\tXFS_AGI_MAGIC\t0x58414749\t/* 'XAGI' */\n#define\tXFS_AGFL_MAGIC\t0x5841464c\t/* 'XAFL' */\n#define\tXFS_AGF_VERSION\t1\n#define\tXFS_AGI_VERSION\t1\n\n#define\tXFS_AGF_GOOD_VERSION(v)\t((v) == XFS_AGF_VERSION)\n#define\tXFS_AGI_GOOD_VERSION(v)\t((v) == XFS_AGI_VERSION)\n\n/*\n * Btree number 0 is bno, 1 is cnt, 2 is rmap. This value gives the size of the\n * arrays below.\n */\n#define\tXFS_BTNUM_AGF\t((int)XFS_BTNUM_RMAPi + 1)\n\n/*\n * The second word of agf_levels in the first a.g. overlaps the EFS\n * superblock's magic number.  Since the magic numbers valid for EFS\n * are > 64k, our value cannot be confused for an EFS superblock's.\n */\n\ntypedef struct xfs_agf {\n\t/*\n\t * Common allocation group header information\n\t */\n\t__be32\t\tagf_magicnum;\t/* magic number == XFS_AGF_MAGIC */\n\t__be32\t\tagf_versionnum;\t/* header version == XFS_AGF_VERSION */\n\t__be32\t\tagf_seqno;\t/* sequence # starting from 0 */\n\t__be32\t\tagf_length;\t/* size in blocks of a.g. */\n\t/*\n\t * Freespace and rmap information\n\t */\n\t__be32\t\tagf_roots[XFS_BTNUM_AGF];\t/* root blocks */\n\t__be32\t\tagf_levels[XFS_BTNUM_AGF];\t/* btree levels */\n\n\t__be32\t\tagf_flfirst;\t/* first freelist block's index */\n\t__be32\t\tagf_fllast;\t/* last freelist block's index */\n\t__be32\t\tagf_flcount;\t/* count of blocks in freelist */\n\t__be32\t\tagf_freeblks;\t/* total free blocks */\n\n\t__be32\t\tagf_longest;\t/* longest free space */\n\t__be32\t\tagf_btreeblks;\t/* # of blocks held in AGF btrees */\n\tuuid_t\t\tagf_uuid;\t/* uuid of filesystem */\n\n\t__be32\t\tagf_rmap_blocks;\t/* rmapbt blocks used */\n\t__be32\t\tagf_refcount_blocks;\t/* refcountbt blocks used */\n\n\t__be32\t\tagf_refcount_root;\t/* refcount tree root block */\n\t__be32\t\tagf_refcount_level;\t/* refcount btree levels */\n\n\t/*\n\t * reserve some contiguous space for future logged fields before we add\n\t * the unlogged fields. This makes the range logging via flags and\n\t * structure offsets much simpler.\n\t */\n\t__be64\t\tagf_spare64[14];\n\n\t/* unlogged fields, written during buffer writeback. */\n\t__be64\t\tagf_lsn;\t/* last write sequence */\n\t__be32\t\tagf_crc;\t/* crc of agf sector */\n\t__be32\t\tagf_spare2;\n\n\t/* structure must be padded to 64 bit alignment */\n} xfs_agf_t;\n\n#define XFS_AGF_CRC_OFF\t\toffsetof(struct xfs_agf, agf_crc)\n\n#define\tXFS_AGF_MAGICNUM\t0x00000001\n#define\tXFS_AGF_VERSIONNUM\t0x00000002\n#define\tXFS_AGF_SEQNO\t\t0x00000004\n#define\tXFS_AGF_LENGTH\t\t0x00000008\n#define\tXFS_AGF_ROOTS\t\t0x00000010\n#define\tXFS_AGF_LEVELS\t\t0x00000020\n#define\tXFS_AGF_FLFIRST\t\t0x00000040\n#define\tXFS_AGF_FLLAST\t\t0x00000080\n#define\tXFS_AGF_FLCOUNT\t\t0x00000100\n#define\tXFS_AGF_FREEBLKS\t0x00000200\n#define\tXFS_AGF_LONGEST\t\t0x00000400\n#define\tXFS_AGF_BTREEBLKS\t0x00000800\n#define\tXFS_AGF_UUID\t\t0x00001000\n#define\tXFS_AGF_RMAP_BLOCKS\t0x00002000\n#define\tXFS_AGF_REFCOUNT_BLOCKS\t0x00004000\n#define\tXFS_AGF_REFCOUNT_ROOT\t0x00008000\n#define\tXFS_AGF_REFCOUNT_LEVEL\t0x00010000\n#define\tXFS_AGF_SPARE64\t\t0x00020000\n#define\tXFS_AGF_NUM_BITS\t18\n#define\tXFS_AGF_ALL_BITS\t((1 << XFS_AGF_NUM_BITS) - 1)\n\n#define XFS_AGF_FLAGS \\\n\t{ XFS_AGF_MAGICNUM,\t\"MAGICNUM\" }, \\\n\t{ XFS_AGF_VERSIONNUM,\t\"VERSIONNUM\" }, \\\n\t{ XFS_AGF_SEQNO,\t\"SEQNO\" }, \\\n\t{ XFS_AGF_LENGTH,\t\"LENGTH\" }, \\\n\t{ XFS_AGF_ROOTS,\t\"ROOTS\" }, \\\n\t{ XFS_AGF_LEVELS,\t\"LEVELS\" }, \\\n\t{ XFS_AGF_FLFIRST,\t\"FLFIRST\" }, \\\n\t{ XFS_AGF_FLLAST,\t\"FLLAST\" }, \\\n\t{ XFS_AGF_FLCOUNT,\t\"FLCOUNT\" }, \\\n\t{ XFS_AGF_FREEBLKS,\t\"FREEBLKS\" }, \\\n\t{ XFS_AGF_LONGEST,\t\"LONGEST\" }, \\\n\t{ XFS_AGF_BTREEBLKS,\t\"BTREEBLKS\" }, \\\n\t{ XFS_AGF_UUID,\t\t\"UUID\" }, \\\n\t{ XFS_AGF_RMAP_BLOCKS,\t\"RMAP_BLOCKS\" }, \\\n\t{ XFS_AGF_REFCOUNT_BLOCKS,\t\"REFCOUNT_BLOCKS\" }, \\\n\t{ XFS_AGF_REFCOUNT_ROOT,\t\"REFCOUNT_ROOT\" }, \\\n\t{ XFS_AGF_REFCOUNT_LEVEL,\t\"REFCOUNT_LEVEL\" }, \\\n\t{ XFS_AGF_SPARE64,\t\"SPARE64\" }\n\n/* disk block (xfs_daddr_t) in the AG */\n#define XFS_AGF_DADDR(mp)\t((xfs_daddr_t)(1 << (mp)->m_sectbb_log))\n#define\tXFS_AGF_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_AGF_DADDR(mp))\n#define\tXFS_BUF_TO_AGF(bp)\t((xfs_agf_t *)((bp)->b_addr))\n\n/*\n * Size of the unlinked inode hash table in the agi.\n */\n#define\tXFS_AGI_UNLINKED_BUCKETS\t64\n\ntypedef struct xfs_agi {\n\t/*\n\t * Common allocation group header information\n\t */\n\t__be32\t\tagi_magicnum;\t/* magic number == XFS_AGI_MAGIC */\n\t__be32\t\tagi_versionnum;\t/* header version == XFS_AGI_VERSION */\n\t__be32\t\tagi_seqno;\t/* sequence # starting from 0 */\n\t__be32\t\tagi_length;\t/* size in blocks of a.g. */\n\t/*\n\t * Inode information\n\t * Inodes are mapped by interpreting the inode number, so no\n\t * mapping data is needed here.\n\t */\n\t__be32\t\tagi_count;\t/* count of allocated inodes */\n\t__be32\t\tagi_root;\t/* root of inode btree */\n\t__be32\t\tagi_level;\t/* levels in inode btree */\n\t__be32\t\tagi_freecount;\t/* number of free inodes */\n\n\t__be32\t\tagi_newino;\t/* new inode just allocated */\n\t__be32\t\tagi_dirino;\t/* last directory inode chunk */\n\t/*\n\t * Hash table of inodes which have been unlinked but are\n\t * still being referenced.\n\t */\n\t__be32\t\tagi_unlinked[XFS_AGI_UNLINKED_BUCKETS];\n\t/*\n\t * This marks the end of logging region 1 and start of logging region 2.\n\t */\n\tuuid_t\t\tagi_uuid;\t/* uuid of filesystem */\n\t__be32\t\tagi_crc;\t/* crc of agi sector */\n\t__be32\t\tagi_pad32;\n\t__be64\t\tagi_lsn;\t/* last write sequence */\n\n\t__be32\t\tagi_free_root; /* root of the free inode btree */\n\t__be32\t\tagi_free_level;/* levels in free inode btree */\n\n\t/* structure must be padded to 64 bit alignment */\n} xfs_agi_t;\n\n#define XFS_AGI_CRC_OFF\t\toffsetof(struct xfs_agi, agi_crc)\n\n#define\tXFS_AGI_MAGICNUM\t(1 << 0)\n#define\tXFS_AGI_VERSIONNUM\t(1 << 1)\n#define\tXFS_AGI_SEQNO\t\t(1 << 2)\n#define\tXFS_AGI_LENGTH\t\t(1 << 3)\n#define\tXFS_AGI_COUNT\t\t(1 << 4)\n#define\tXFS_AGI_ROOT\t\t(1 << 5)\n#define\tXFS_AGI_LEVEL\t\t(1 << 6)\n#define\tXFS_AGI_FREECOUNT\t(1 << 7)\n#define\tXFS_AGI_NEWINO\t\t(1 << 8)\n#define\tXFS_AGI_DIRINO\t\t(1 << 9)\n#define\tXFS_AGI_UNLINKED\t(1 << 10)\n#define\tXFS_AGI_NUM_BITS_R1\t11\t/* end of the 1st agi logging region */\n#define\tXFS_AGI_ALL_BITS_R1\t((1 << XFS_AGI_NUM_BITS_R1) - 1)\n#define\tXFS_AGI_FREE_ROOT\t(1 << 11)\n#define\tXFS_AGI_FREE_LEVEL\t(1 << 12)\n#define\tXFS_AGI_NUM_BITS_R2\t13\n\n/* disk block (xfs_daddr_t) in the AG */\n#define XFS_AGI_DADDR(mp)\t((xfs_daddr_t)(2 << (mp)->m_sectbb_log))\n#define\tXFS_AGI_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_AGI_DADDR(mp))\n#define\tXFS_BUF_TO_AGI(bp)\t((xfs_agi_t *)((bp)->b_addr))\n\n/*\n * The third a.g. block contains the a.g. freelist, an array\n * of block pointers to blocks owned by the allocation btree code.\n */\n#define XFS_AGFL_DADDR(mp)\t((xfs_daddr_t)(3 << (mp)->m_sectbb_log))\n#define\tXFS_AGFL_BLOCK(mp)\tXFS_HDR_BLOCK(mp, XFS_AGFL_DADDR(mp))\n#define\tXFS_BUF_TO_AGFL(bp)\t((xfs_agfl_t *)((bp)->b_addr))\n\n#define XFS_BUF_TO_AGFL_BNO(mp, bp) \\\n\t(xfs_sb_version_hascrc(&((mp)->m_sb)) ? \\\n\t\t&(XFS_BUF_TO_AGFL(bp)->agfl_bno[0]) : \\\n\t\t(__be32 *)(bp)->b_addr)\n\ntypedef struct xfs_agfl {\n\t__be32\t\tagfl_magicnum;\n\t__be32\t\tagfl_seqno;\n\tuuid_t\t\tagfl_uuid;\n\t__be64\t\tagfl_lsn;\n\t__be32\t\tagfl_crc;\n\t__be32\t\tagfl_bno[];\t/* actually xfs_agfl_size(mp) */\n} __attribute__((packed)) xfs_agfl_t;\n\n#define XFS_AGFL_CRC_OFF\toffsetof(struct xfs_agfl, agfl_crc)\n\n#define XFS_AGB_TO_FSB(mp,agno,agbno)\t\\\n\t(((xfs_fsblock_t)(agno) << (mp)->m_sb.sb_agblklog) | (agbno))\n#define\tXFS_FSB_TO_AGNO(mp,fsbno)\t\\\n\t((xfs_agnumber_t)((fsbno) >> (mp)->m_sb.sb_agblklog))\n#define\tXFS_FSB_TO_AGBNO(mp,fsbno)\t\\\n\t((xfs_agblock_t)((fsbno) & xfs_mask32lo((mp)->m_sb.sb_agblklog)))\n#define\tXFS_AGB_TO_DADDR(mp,agno,agbno)\t\\\n\t((xfs_daddr_t)XFS_FSB_TO_BB(mp, \\\n\t\t(xfs_fsblock_t)(agno) * (mp)->m_sb.sb_agblocks + (agbno)))\n#define\tXFS_AG_DADDR(mp,agno,d)\t\t(XFS_AGB_TO_DADDR(mp, agno, 0) + (d))\n\n/*\n * For checking for bad ranges of xfs_daddr_t's, covering multiple\n * allocation groups or a single xfs_daddr_t that's a superblock copy.\n */\n#define\tXFS_AG_CHECK_DADDR(mp,d,len)\t\\\n\t((len) == 1 ? \\\n\t    ASSERT((d) == XFS_SB_DADDR || \\\n\t\t   xfs_daddr_to_agbno(mp, d) != XFS_SB_DADDR) : \\\n\t    ASSERT(xfs_daddr_to_agno(mp, d) == \\\n\t\t   xfs_daddr_to_agno(mp, (d) + (len) - 1)))\n\ntypedef struct xfs_timestamp {\n\t__be32\t\tt_sec;\t\t/* timestamp seconds */\n\t__be32\t\tt_nsec;\t\t/* timestamp nanoseconds */\n} xfs_timestamp_t;\n\n/*\n * On-disk inode structure.\n *\n * This is just the header or \"dinode core\", the inode is expanded to fill a\n * variable size the leftover area split into a data and an attribute fork.\n * The format of the data and attribute fork depends on the format of the\n * inode as indicated by di_format and di_aformat.  To access the data and\n * attribute use the XFS_DFORK_DPTR, XFS_DFORK_APTR, and XFS_DFORK_PTR macros\n * below.\n *\n * There is a very similar struct icdinode in xfs_inode which matches the\n * layout of the first 96 bytes of this structure, but is kept in native\n * format instead of big endian.\n *\n * Note: di_flushiter is only used by v1/2 inodes - it's effectively a zeroed\n * padding field for v3 inodes.\n */\n#define\tXFS_DINODE_MAGIC\t\t0x494e\t/* 'IN' */\ntypedef struct xfs_dinode {\n\t__be16\t\tdi_magic;\t/* inode magic # = XFS_DINODE_MAGIC */\n\t__be16\t\tdi_mode;\t/* mode and type of file */\n\t__u8\t\tdi_version;\t/* inode version */\n\t__u8\t\tdi_format;\t/* format of di_c data */\n\t__be16\t\tdi_onlink;\t/* old number of links to file */\n\t__be32\t\tdi_uid;\t\t/* owner's user id */\n\t__be32\t\tdi_gid;\t\t/* owner's group id */\n\t__be32\t\tdi_nlink;\t/* number of links to file */\n\t__be16\t\tdi_projid_lo;\t/* lower part of owner's project id */\n\t__be16\t\tdi_projid_hi;\t/* higher part owner's project id */\n\t__u8\t\tdi_pad[6];\t/* unused, zeroed space */\n\t__be16\t\tdi_flushiter;\t/* incremented on flush */\n\txfs_timestamp_t\tdi_atime;\t/* time last accessed */\n\txfs_timestamp_t\tdi_mtime;\t/* time last modified */\n\txfs_timestamp_t\tdi_ctime;\t/* time created/inode modified */\n\t__be64\t\tdi_size;\t/* number of bytes in file */\n\t__be64\t\tdi_nblocks;\t/* # of direct & btree blocks used */\n\t__be32\t\tdi_extsize;\t/* basic/minimum extent size for file */\n\t__be32\t\tdi_nextents;\t/* number of extents in data fork */\n\t__be16\t\tdi_anextents;\t/* number of extents in attribute fork*/\n\t__u8\t\tdi_forkoff;\t/* attr fork offs, <<3 for 64b align */\n\t__s8\t\tdi_aformat;\t/* format of attr fork's data */\n\t__be32\t\tdi_dmevmask;\t/* DMIG event mask */\n\t__be16\t\tdi_dmstate;\t/* DMIG state info */\n\t__be16\t\tdi_flags;\t/* random flags, XFS_DIFLAG_... */\n\t__be32\t\tdi_gen;\t\t/* generation number */\n\n\t/* di_next_unlinked is the only non-core field in the old dinode */\n\t__be32\t\tdi_next_unlinked;/* agi unlinked list ptr */\n\n\t/* start of the extended dinode, writable fields */\n\t__le32\t\tdi_crc;\t\t/* CRC of the inode */\n\t__be64\t\tdi_changecount;\t/* number of attribute changes */\n\t__be64\t\tdi_lsn;\t\t/* flush sequence */\n\t__be64\t\tdi_flags2;\t/* more random flags */\n\t__be32\t\tdi_cowextsize;\t/* basic cow extent size for file */\n\t__u8\t\tdi_pad2[12];\t/* more padding for future expansion */\n\n\t/* fields only written to during inode creation */\n\txfs_timestamp_t\tdi_crtime;\t/* time created */\n\t__be64\t\tdi_ino;\t\t/* inode number */\n\tuuid_t\t\tdi_uuid;\t/* UUID of the filesystem */\n\n\t/* structure must be padded to 64 bit alignment */\n} xfs_dinode_t;\n\n#define XFS_DINODE_CRC_OFF\toffsetof(struct xfs_dinode, di_crc)\n\n#define DI_MAX_FLUSH 0xffff\n\n/*\n * Size of the core inode on disk.  Version 1 and 2 inodes have\n * the same size, but version 3 has grown a few additional fields.\n */\nstatic inline uint xfs_dinode_size(int version)\n{\n\tif (version == 3)\n\t\treturn sizeof(struct xfs_dinode);\n\treturn offsetof(struct xfs_dinode, di_crc);\n}\n\n/*\n * The 32 bit link count in the inode theoretically maxes out at UINT_MAX.\n * Since the pathconf interface is signed, we use 2^31 - 1 instead.\n */\n#define\tXFS_MAXLINK\t\t((1U << 31) - 1U)\n\n/*\n * Values for di_format\n */\ntypedef enum xfs_dinode_fmt {\n\tXFS_DINODE_FMT_DEV,\t\t/* xfs_dev_t */\n\tXFS_DINODE_FMT_LOCAL,\t\t/* bulk data */\n\tXFS_DINODE_FMT_EXTENTS,\t\t/* struct xfs_bmbt_rec */\n\tXFS_DINODE_FMT_BTREE,\t\t/* struct xfs_bmdr_block */\n\tXFS_DINODE_FMT_UUID\t\t/* added long ago, but never used */\n} xfs_dinode_fmt_t;\n\n/*\n * Inode minimum and maximum sizes.\n */\n#define\tXFS_DINODE_MIN_LOG\t8\n#define\tXFS_DINODE_MAX_LOG\t11\n#define\tXFS_DINODE_MIN_SIZE\t(1 << XFS_DINODE_MIN_LOG)\n#define\tXFS_DINODE_MAX_SIZE\t(1 << XFS_DINODE_MAX_LOG)\n\n/*\n * Inode size for given fs.\n */\n#define XFS_LITINO(mp, version) \\\n\t((int)(((mp)->m_sb.sb_inodesize) - xfs_dinode_size(version)))\n\n/*\n * Inode data & attribute fork sizes, per inode.\n */\n#define XFS_DFORK_Q(dip)\t\t((dip)->di_forkoff != 0)\n#define XFS_DFORK_BOFF(dip)\t\t((int)((dip)->di_forkoff << 3))\n\n#define XFS_DFORK_DSIZE(dip,mp) \\\n\t(XFS_DFORK_Q(dip) ? \\\n\t\tXFS_DFORK_BOFF(dip) : \\\n\t\tXFS_LITINO(mp, (dip)->di_version))\n#define XFS_DFORK_ASIZE(dip,mp) \\\n\t(XFS_DFORK_Q(dip) ? \\\n\t\tXFS_LITINO(mp, (dip)->di_version) - XFS_DFORK_BOFF(dip) : \\\n\t\t0)\n#define XFS_DFORK_SIZE(dip,mp,w) \\\n\t((w) == XFS_DATA_FORK ? \\\n\t\tXFS_DFORK_DSIZE(dip, mp) : \\\n\t\tXFS_DFORK_ASIZE(dip, mp))\n\n#define XFS_DFORK_MAXEXT(dip, mp, w) \\\n\t(XFS_DFORK_SIZE(dip, mp, w) / sizeof(struct xfs_bmbt_rec))\n\n/*\n * Return pointers to the data or attribute forks.\n */\n#define XFS_DFORK_DPTR(dip) \\\n\t((char *)dip + xfs_dinode_size(dip->di_version))\n#define XFS_DFORK_APTR(dip)\t\\\n\t(XFS_DFORK_DPTR(dip) + XFS_DFORK_BOFF(dip))\n#define XFS_DFORK_PTR(dip,w)\t\\\n\t((w) == XFS_DATA_FORK ? XFS_DFORK_DPTR(dip) : XFS_DFORK_APTR(dip))\n\n#define XFS_DFORK_FORMAT(dip,w) \\\n\t((w) == XFS_DATA_FORK ? \\\n\t\t(dip)->di_format : \\\n\t\t(dip)->di_aformat)\n#define XFS_DFORK_NEXTENTS(dip,w) \\\n\t((w) == XFS_DATA_FORK ? \\\n\t\tbe32_to_cpu((dip)->di_nextents) : \\\n\t\tbe16_to_cpu((dip)->di_anextents))\n\n/*\n * For block and character special files the 32bit dev_t is stored at the\n * beginning of the data fork.\n */\nstatic inline xfs_dev_t xfs_dinode_get_rdev(struct xfs_dinode *dip)\n{\n\treturn be32_to_cpu(*(__be32 *)XFS_DFORK_DPTR(dip));\n}\n\nstatic inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)\n{\n\t*(__be32 *)XFS_DFORK_DPTR(dip) = cpu_to_be32(rdev);\n}\n\n/*\n * Values for di_flags\n */\n#define XFS_DIFLAG_REALTIME_BIT  0\t/* file's blocks come from rt area */\n#define XFS_DIFLAG_PREALLOC_BIT  1\t/* file space has been preallocated */\n#define XFS_DIFLAG_NEWRTBM_BIT   2\t/* for rtbitmap inode, new format */\n#define XFS_DIFLAG_IMMUTABLE_BIT 3\t/* inode is immutable */\n#define XFS_DIFLAG_APPEND_BIT    4\t/* inode is append-only */\n#define XFS_DIFLAG_SYNC_BIT      5\t/* inode is written synchronously */\n#define XFS_DIFLAG_NOATIME_BIT   6\t/* do not update atime */\n#define XFS_DIFLAG_NODUMP_BIT    7\t/* do not dump */\n#define XFS_DIFLAG_RTINHERIT_BIT 8\t/* create with realtime bit set */\n#define XFS_DIFLAG_PROJINHERIT_BIT   9\t/* create with parents projid */\n#define XFS_DIFLAG_NOSYMLINKS_BIT   10\t/* disallow symlink creation */\n#define XFS_DIFLAG_EXTSIZE_BIT      11\t/* inode extent size allocator hint */\n#define XFS_DIFLAG_EXTSZINHERIT_BIT 12\t/* inherit inode extent size */\n#define XFS_DIFLAG_NODEFRAG_BIT     13\t/* do not reorganize/defragment */\n#define XFS_DIFLAG_FILESTREAM_BIT   14  /* use filestream allocator */\n#define XFS_DIFLAG_REALTIME      (1 << XFS_DIFLAG_REALTIME_BIT)\n#define XFS_DIFLAG_PREALLOC      (1 << XFS_DIFLAG_PREALLOC_BIT)\n#define XFS_DIFLAG_NEWRTBM       (1 << XFS_DIFLAG_NEWRTBM_BIT)\n#define XFS_DIFLAG_IMMUTABLE     (1 << XFS_DIFLAG_IMMUTABLE_BIT)\n#define XFS_DIFLAG_APPEND        (1 << XFS_DIFLAG_APPEND_BIT)\n#define XFS_DIFLAG_SYNC          (1 << XFS_DIFLAG_SYNC_BIT)\n#define XFS_DIFLAG_NOATIME       (1 << XFS_DIFLAG_NOATIME_BIT)\n#define XFS_DIFLAG_NODUMP        (1 << XFS_DIFLAG_NODUMP_BIT)\n#define XFS_DIFLAG_RTINHERIT     (1 << XFS_DIFLAG_RTINHERIT_BIT)\n#define XFS_DIFLAG_PROJINHERIT   (1 << XFS_DIFLAG_PROJINHERIT_BIT)\n#define XFS_DIFLAG_NOSYMLINKS    (1 << XFS_DIFLAG_NOSYMLINKS_BIT)\n#define XFS_DIFLAG_EXTSIZE       (1 << XFS_DIFLAG_EXTSIZE_BIT)\n#define XFS_DIFLAG_EXTSZINHERIT  (1 << XFS_DIFLAG_EXTSZINHERIT_BIT)\n#define XFS_DIFLAG_NODEFRAG      (1 << XFS_DIFLAG_NODEFRAG_BIT)\n#define XFS_DIFLAG_FILESTREAM    (1 << XFS_DIFLAG_FILESTREAM_BIT)\n\n#define XFS_DIFLAG_ANY \\\n\t(XFS_DIFLAG_REALTIME | XFS_DIFLAG_PREALLOC | XFS_DIFLAG_NEWRTBM | \\\n\t XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND | XFS_DIFLAG_SYNC | \\\n\t XFS_DIFLAG_NOATIME | XFS_DIFLAG_NODUMP | XFS_DIFLAG_RTINHERIT | \\\n\t XFS_DIFLAG_PROJINHERIT | XFS_DIFLAG_NOSYMLINKS | XFS_DIFLAG_EXTSIZE | \\\n\t XFS_DIFLAG_EXTSZINHERIT | XFS_DIFLAG_NODEFRAG | XFS_DIFLAG_FILESTREAM)\n\n/*\n * Values for di_flags2 These start by being exposed to userspace in the upper\n * 16 bits of the XFS_XFLAG_s range.\n */\n#define XFS_DIFLAG2_DAX_BIT\t0\t/* use DAX for this inode */\n#define XFS_DIFLAG2_REFLINK_BIT\t1\t/* file's blocks may be shared */\n#define XFS_DIFLAG2_COWEXTSIZE_BIT   2  /* copy on write extent size hint */\n#define XFS_DIFLAG2_DAX\t\t(1 << XFS_DIFLAG2_DAX_BIT)\n#define XFS_DIFLAG2_REFLINK     (1 << XFS_DIFLAG2_REFLINK_BIT)\n#define XFS_DIFLAG2_COWEXTSIZE  (1 << XFS_DIFLAG2_COWEXTSIZE_BIT)\n\n#define XFS_DIFLAG2_ANY \\\n\t(XFS_DIFLAG2_DAX | XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)\n\n/*\n * Inode number format:\n * low inopblog bits - offset in block\n * next agblklog bits - block number in ag\n * next agno_log bits - ag number\n * high agno_log-agblklog-inopblog bits - 0\n */\n#define\tXFS_INO_MASK(k)\t\t\t(uint32_t)((1ULL << (k)) - 1)\n#define\tXFS_INO_OFFSET_BITS(mp)\t\t(mp)->m_sb.sb_inopblog\n#define\tXFS_INO_AGBNO_BITS(mp)\t\t(mp)->m_sb.sb_agblklog\n#define\tXFS_INO_AGINO_BITS(mp)\t\t(mp)->m_agino_log\n#define\tXFS_INO_AGNO_BITS(mp)\t\t(mp)->m_agno_log\n#define\tXFS_INO_BITS(mp)\t\t\\\n\tXFS_INO_AGNO_BITS(mp) + XFS_INO_AGINO_BITS(mp)\n#define\tXFS_INO_TO_AGNO(mp,i)\t\t\\\n\t((xfs_agnumber_t)((i) >> XFS_INO_AGINO_BITS(mp)))\n#define\tXFS_INO_TO_AGINO(mp,i)\t\t\\\n\t((xfs_agino_t)(i) & XFS_INO_MASK(XFS_INO_AGINO_BITS(mp)))\n#define\tXFS_INO_TO_AGBNO(mp,i)\t\t\\\n\t(((xfs_agblock_t)(i) >> XFS_INO_OFFSET_BITS(mp)) & \\\n\t\tXFS_INO_MASK(XFS_INO_AGBNO_BITS(mp)))\n#define\tXFS_INO_TO_OFFSET(mp,i)\t\t\\\n\t((int)(i) & XFS_INO_MASK(XFS_INO_OFFSET_BITS(mp)))\n#define\tXFS_INO_TO_FSB(mp,i)\t\t\\\n\tXFS_AGB_TO_FSB(mp, XFS_INO_TO_AGNO(mp,i), XFS_INO_TO_AGBNO(mp,i))\n#define\tXFS_AGINO_TO_INO(mp,a,i)\t\\\n\t(((xfs_ino_t)(a) << XFS_INO_AGINO_BITS(mp)) | (i))\n#define\tXFS_AGINO_TO_AGBNO(mp,i)\t((i) >> XFS_INO_OFFSET_BITS(mp))\n#define\tXFS_AGINO_TO_OFFSET(mp,i)\t\\\n\t((i) & XFS_INO_MASK(XFS_INO_OFFSET_BITS(mp)))\n#define\tXFS_OFFBNO_TO_AGINO(mp,b,o)\t\\\n\t((xfs_agino_t)(((b) << XFS_INO_OFFSET_BITS(mp)) | (o)))\n\n#define\tXFS_MAXINUMBER\t\t((xfs_ino_t)((1ULL << 56) - 1ULL))\n#define\tXFS_MAXINUMBER_32\t((xfs_ino_t)((1ULL << 32) - 1ULL))\n\n/*\n * RealTime Device format definitions\n */\n\n/* Min and max rt extent sizes, specified in bytes */\n#define\tXFS_MAX_RTEXTSIZE\t(1024 * 1024 * 1024)\t/* 1GB */\n#define\tXFS_DFL_RTEXTSIZE\t(64 * 1024)\t        /* 64kB */\n#define\tXFS_MIN_RTEXTSIZE\t(4 * 1024)\t\t/* 4kB */\n\n#define\tXFS_BLOCKSIZE(mp)\t((mp)->m_sb.sb_blocksize)\n#define\tXFS_BLOCKMASK(mp)\t((mp)->m_blockmask)\n#define\tXFS_BLOCKWSIZE(mp)\t((mp)->m_blockwsize)\n#define\tXFS_BLOCKWMASK(mp)\t((mp)->m_blockwmask)\n\n/*\n * RT Summary and bit manipulation macros.\n */\n#define\tXFS_SUMOFFS(mp,ls,bb)\t((int)((ls) * (mp)->m_sb.sb_rbmblocks + (bb)))\n#define\tXFS_SUMOFFSTOBLOCK(mp,s)\t\\\n\t(((s) * (uint)sizeof(xfs_suminfo_t)) >> (mp)->m_sb.sb_blocklog)\n#define\tXFS_SUMPTR(mp,bp,so)\t\\\n\t((xfs_suminfo_t *)((bp)->b_addr + \\\n\t\t(((so) * (uint)sizeof(xfs_suminfo_t)) & XFS_BLOCKMASK(mp))))\n\n#define\tXFS_BITTOBLOCK(mp,bi)\t((bi) >> (mp)->m_blkbit_log)\n#define\tXFS_BLOCKTOBIT(mp,bb)\t((bb) << (mp)->m_blkbit_log)\n#define\tXFS_BITTOWORD(mp,bi)\t\\\n\t((int)(((bi) >> XFS_NBWORDLOG) & XFS_BLOCKWMASK(mp)))\n\n#define\tXFS_RTMIN(a,b)\t((a) < (b) ? (a) : (b))\n#define\tXFS_RTMAX(a,b)\t((a) > (b) ? (a) : (b))\n\n#define\tXFS_RTLOBIT(w)\txfs_lowbit32(w)\n#define\tXFS_RTHIBIT(w)\txfs_highbit32(w)\n\n#define\tXFS_RTBLOCKLOG(b)\txfs_highbit64(b)\n\n/*\n * Dquot and dquot block format definitions\n */\n#define XFS_DQUOT_MAGIC\t\t0x4451\t\t/* 'DQ' */\n#define XFS_DQUOT_VERSION\t(uint8_t)0x01\t/* latest version number */\n\n/*\n * This is the main portion of the on-disk representation of quota\n * information for a user. This is the q_core of the xfs_dquot_t that\n * is kept in kernel memory. We pad this with some more expansion room\n * to construct the on disk structure.\n */\ntypedef struct\txfs_disk_dquot {\n\t__be16\t\td_magic;\t/* dquot magic = XFS_DQUOT_MAGIC */\n\t__u8\t\td_version;\t/* dquot version */\n\t__u8\t\td_flags;\t/* XFS_DQ_USER/PROJ/GROUP */\n\t__be32\t\td_id;\t\t/* user,project,group id */\n\t__be64\t\td_blk_hardlimit;/* absolute limit on disk blks */\n\t__be64\t\td_blk_softlimit;/* preferred limit on disk blks */\n\t__be64\t\td_ino_hardlimit;/* maximum # allocated inodes */\n\t__be64\t\td_ino_softlimit;/* preferred inode limit */\n\t__be64\t\td_bcount;\t/* disk blocks owned by the user */\n\t__be64\t\td_icount;\t/* inodes owned by the user */\n\t__be32\t\td_itimer;\t/* zero if within inode limits if not,\n\t\t\t\t\t   this is when we refuse service */\n\t__be32\t\td_btimer;\t/* similar to above; for disk blocks */\n\t__be16\t\td_iwarns;\t/* warnings issued wrt num inodes */\n\t__be16\t\td_bwarns;\t/* warnings issued wrt disk blocks */\n\t__be32\t\td_pad0;\t\t/* 64 bit align */\n\t__be64\t\td_rtb_hardlimit;/* absolute limit on realtime blks */\n\t__be64\t\td_rtb_softlimit;/* preferred limit on RT disk blks */\n\t__be64\t\td_rtbcount;\t/* realtime blocks owned */\n\t__be32\t\td_rtbtimer;\t/* similar to above; for RT disk blocks */\n\t__be16\t\td_rtbwarns;\t/* warnings issued wrt RT disk blocks */\n\t__be16\t\td_pad;\n} xfs_disk_dquot_t;\n\n/*\n * This is what goes on disk. This is separated from the xfs_disk_dquot because\n * carrying the unnecessary padding would be a waste of memory.\n */\ntypedef struct xfs_dqblk {\n\txfs_disk_dquot_t  dd_diskdq;\t/* portion that lives incore as well */\n\tchar\t\t  dd_fill[4];\t/* filling for posterity */\n\n\t/*\n\t * These two are only present on filesystems with the CRC bits set.\n\t */\n\t__be32\t\t  dd_crc;\t/* checksum */\n\t__be64\t\t  dd_lsn;\t/* last modification in log */\n\tuuid_t\t\t  dd_uuid;\t/* location information */\n} xfs_dqblk_t;\n\n#define XFS_DQUOT_CRC_OFF\toffsetof(struct xfs_dqblk, dd_crc)\n\n/*\n * Remote symlink format and access functions.\n */\n#define XFS_SYMLINK_MAGIC\t0x58534c4d\t/* XSLM */\n\nstruct xfs_dsymlink_hdr {\n\t__be32\tsl_magic;\n\t__be32\tsl_offset;\n\t__be32\tsl_bytes;\n\t__be32\tsl_crc;\n\tuuid_t\tsl_uuid;\n\t__be64\tsl_owner;\n\t__be64\tsl_blkno;\n\t__be64\tsl_lsn;\n};\n\n#define XFS_SYMLINK_CRC_OFF\toffsetof(struct xfs_dsymlink_hdr, sl_crc)\n\n#define XFS_SYMLINK_MAXLEN\t1024\n/*\n * The maximum pathlen is 1024 bytes. Since the minimum file system\n * blocksize is 512 bytes, we can get a max of 3 extents back from\n * bmapi when crc headers are taken into account.\n */\n#define XFS_SYMLINK_MAPS 3\n\n#define XFS_SYMLINK_BUF_SPACE(mp, bufsize)\t\\\n\t((bufsize) - (xfs_sb_version_hascrc(&(mp)->m_sb) ? \\\n\t\t\tsizeof(struct xfs_dsymlink_hdr) : 0))\n\n\n/*\n * Allocation Btree format definitions\n *\n * There are two on-disk btrees, one sorted by blockno and one sorted\n * by blockcount and blockno.  All blocks look the same to make the code\n * simpler; if we have time later, we'll make the optimizations.\n */\n#define\tXFS_ABTB_MAGIC\t\t0x41425442\t/* 'ABTB' for bno tree */\n#define\tXFS_ABTB_CRC_MAGIC\t0x41423342\t/* 'AB3B' */\n#define\tXFS_ABTC_MAGIC\t\t0x41425443\t/* 'ABTC' for cnt tree */\n#define\tXFS_ABTC_CRC_MAGIC\t0x41423343\t/* 'AB3C' */\n\n/*\n * Data record/key structure\n */\ntypedef struct xfs_alloc_rec {\n\t__be32\t\tar_startblock;\t/* starting block number */\n\t__be32\t\tar_blockcount;\t/* count of free blocks */\n} xfs_alloc_rec_t, xfs_alloc_key_t;\n\ntypedef struct xfs_alloc_rec_incore {\n\txfs_agblock_t\tar_startblock;\t/* starting block number */\n\txfs_extlen_t\tar_blockcount;\t/* count of free blocks */\n} xfs_alloc_rec_incore_t;\n\n/* btree pointer type */\ntypedef __be32 xfs_alloc_ptr_t;\n\n/*\n * Block numbers in the AG:\n * SB is sector 0, AGF is sector 1, AGI is sector 2, AGFL is sector 3.\n */\n#define\tXFS_BNO_BLOCK(mp)\t((xfs_agblock_t)(XFS_AGFL_BLOCK(mp) + 1))\n#define\tXFS_CNT_BLOCK(mp)\t((xfs_agblock_t)(XFS_BNO_BLOCK(mp) + 1))\n\n\n/*\n * Inode Allocation Btree format definitions\n *\n * There is a btree for the inode map per allocation group.\n */\n#define\tXFS_IBT_MAGIC\t\t0x49414254\t/* 'IABT' */\n#define\tXFS_IBT_CRC_MAGIC\t0x49414233\t/* 'IAB3' */\n#define\tXFS_FIBT_MAGIC\t\t0x46494254\t/* 'FIBT' */\n#define\tXFS_FIBT_CRC_MAGIC\t0x46494233\t/* 'FIB3' */\n\ntypedef uint64_t\txfs_inofree_t;\n#define\tXFS_INODES_PER_CHUNK\t\t(NBBY * sizeof(xfs_inofree_t))\n#define\tXFS_INODES_PER_CHUNK_LOG\t(XFS_NBBYLOG + 3)\n#define\tXFS_INOBT_ALL_FREE\t\t((xfs_inofree_t)-1)\n#define\tXFS_INOBT_MASK(i)\t\t((xfs_inofree_t)1 << (i))\n\n#define XFS_INOBT_HOLEMASK_FULL\t\t0\t/* holemask for full chunk */\n#define XFS_INOBT_HOLEMASK_BITS\t\t(NBBY * sizeof(uint16_t))\n#define XFS_INODES_PER_HOLEMASK_BIT\t\\\n\t(XFS_INODES_PER_CHUNK / (NBBY * sizeof(uint16_t)))\n\nstatic inline xfs_inofree_t xfs_inobt_maskn(int i, int n)\n{\n\treturn ((n >= XFS_INODES_PER_CHUNK ? 0 : XFS_INOBT_MASK(n)) - 1) << i;\n}\n\n/*\n * The on-disk inode record structure has two formats. The original \"full\"\n * format uses a 4-byte freecount. The \"sparse\" format uses a 1-byte freecount\n * and replaces the 3 high-order freecount bytes wth the holemask and inode\n * count.\n *\n * The holemask of the sparse record format allows an inode chunk to have holes\n * that refer to blocks not owned by the inode record. This facilitates inode\n * allocation in the event of severe free space fragmentation.\n */\ntypedef struct xfs_inobt_rec {\n\t__be32\t\tir_startino;\t/* starting inode number */\n\tunion {\n\t\tstruct {\n\t\t\t__be32\tir_freecount;\t/* count of free inodes */\n\t\t} f;\n\t\tstruct {\n\t\t\t__be16\tir_holemask;/* hole mask for sparse chunks */\n\t\t\t__u8\tir_count;\t/* total inode count */\n\t\t\t__u8\tir_freecount;\t/* count of free inodes */\n\t\t} sp;\n\t} ir_u;\n\t__be64\t\tir_free;\t/* free inode mask */\n} xfs_inobt_rec_t;\n\ntypedef struct xfs_inobt_rec_incore {\n\txfs_agino_t\tir_startino;\t/* starting inode number */\n\tuint16_t\tir_holemask;\t/* hole mask for sparse chunks */\n\tuint8_t\t\tir_count;\t/* total inode count */\n\tuint8_t\t\tir_freecount;\t/* count of free inodes (set bits) */\n\txfs_inofree_t\tir_free;\t/* free inode mask */\n} xfs_inobt_rec_incore_t;\n\nstatic inline bool xfs_inobt_issparse(uint16_t holemask)\n{\n\t/* non-zero holemask represents a sparse rec. */\n\treturn holemask;\n}\n\n/*\n * Key structure\n */\ntypedef struct xfs_inobt_key {\n\t__be32\t\tir_startino;\t/* starting inode number */\n} xfs_inobt_key_t;\n\n/* btree pointer type */\ntypedef __be32 xfs_inobt_ptr_t;\n\n/*\n * block numbers in the AG.\n */\n#define\tXFS_IBT_BLOCK(mp)\t\t((xfs_agblock_t)(XFS_CNT_BLOCK(mp) + 1))\n#define\tXFS_FIBT_BLOCK(mp)\t\t((xfs_agblock_t)(XFS_IBT_BLOCK(mp) + 1))\n\n/*\n * Reverse mapping btree format definitions\n *\n * There is a btree for the reverse map per allocation group\n */\n#define\tXFS_RMAP_CRC_MAGIC\t0x524d4233\t/* 'RMB3' */\n\n/*\n * Ownership info for an extent.  This is used to create reverse-mapping\n * entries.\n */\n#define XFS_OWNER_INFO_ATTR_FORK\t(1 << 0)\n#define XFS_OWNER_INFO_BMBT_BLOCK\t(1 << 1)\nstruct xfs_owner_info {\n\tuint64_t\t\toi_owner;\n\txfs_fileoff_t\t\toi_offset;\n\tunsigned int\t\toi_flags;\n};\n\n/*\n * Special owner types.\n *\n * Seeing as we only support up to 8EB, we have the upper bit of the owner field\n * to tell us we have a special owner value. We use these for static metadata\n * allocated at mkfs/growfs time, as well as for freespace management metadata.\n */\n#define XFS_RMAP_OWN_NULL\t(-1ULL)\t/* No owner, for growfs */\n#define XFS_RMAP_OWN_UNKNOWN\t(-2ULL)\t/* Unknown owner, for EFI recovery */\n#define XFS_RMAP_OWN_FS\t\t(-3ULL)\t/* static fs metadata */\n#define XFS_RMAP_OWN_LOG\t(-4ULL)\t/* static fs metadata */\n#define XFS_RMAP_OWN_AG\t\t(-5ULL)\t/* AG freespace btree blocks */\n#define XFS_RMAP_OWN_INOBT\t(-6ULL)\t/* Inode btree blocks */\n#define XFS_RMAP_OWN_INODES\t(-7ULL)\t/* Inode chunk */\n#define XFS_RMAP_OWN_REFC\t(-8ULL) /* refcount tree */\n#define XFS_RMAP_OWN_COW\t(-9ULL) /* cow allocations */\n#define XFS_RMAP_OWN_MIN\t(-10ULL) /* guard */\n\n#define XFS_RMAP_NON_INODE_OWNER(owner)\t(!!((owner) & (1ULL << 63)))\n\n/*\n * Data record structure\n */\nstruct xfs_rmap_rec {\n\t__be32\t\trm_startblock;\t/* extent start block */\n\t__be32\t\trm_blockcount;\t/* extent length */\n\t__be64\t\trm_owner;\t/* extent owner */\n\t__be64\t\trm_offset;\t/* offset within the owner */\n};\n\n/*\n * rmap btree record\n *  rm_offset:63 is the attribute fork flag\n *  rm_offset:62 is the bmbt block flag\n *  rm_offset:61 is the unwritten extent flag (same as l0:63 in bmbt)\n *  rm_offset:54-60 aren't used and should be zero\n *  rm_offset:0-53 is the block offset within the inode\n */\n#define XFS_RMAP_OFF_ATTR_FORK\t((uint64_t)1ULL << 63)\n#define XFS_RMAP_OFF_BMBT_BLOCK\t((uint64_t)1ULL << 62)\n#define XFS_RMAP_OFF_UNWRITTEN\t((uint64_t)1ULL << 61)\n\n#define XFS_RMAP_LEN_MAX\t((uint32_t)~0U)\n#define XFS_RMAP_OFF_FLAGS\t(XFS_RMAP_OFF_ATTR_FORK | \\\n\t\t\t\t XFS_RMAP_OFF_BMBT_BLOCK | \\\n\t\t\t\t XFS_RMAP_OFF_UNWRITTEN)\n#define XFS_RMAP_OFF_MASK\t((uint64_t)0x3FFFFFFFFFFFFFULL)\n\n#define XFS_RMAP_OFF(off)\t\t((off) & XFS_RMAP_OFF_MASK)\n\n#define XFS_RMAP_IS_BMBT_BLOCK(off)\t(!!((off) & XFS_RMAP_OFF_BMBT_BLOCK))\n#define XFS_RMAP_IS_ATTR_FORK(off)\t(!!((off) & XFS_RMAP_OFF_ATTR_FORK))\n#define XFS_RMAP_IS_UNWRITTEN(len)\t(!!((off) & XFS_RMAP_OFF_UNWRITTEN))\n\n#define RMAPBT_STARTBLOCK_BITLEN\t32\n#define RMAPBT_BLOCKCOUNT_BITLEN\t32\n#define RMAPBT_OWNER_BITLEN\t\t64\n#define RMAPBT_ATTRFLAG_BITLEN\t\t1\n#define RMAPBT_BMBTFLAG_BITLEN\t\t1\n#define RMAPBT_EXNTFLAG_BITLEN\t\t1\n#define RMAPBT_UNUSED_OFFSET_BITLEN\t7\n#define RMAPBT_OFFSET_BITLEN\t\t54\n\n#define XFS_RMAP_ATTR_FORK\t\t(1 << 0)\n#define XFS_RMAP_BMBT_BLOCK\t\t(1 << 1)\n#define XFS_RMAP_UNWRITTEN\t\t(1 << 2)\n#define XFS_RMAP_KEY_FLAGS\t\t(XFS_RMAP_ATTR_FORK | \\\n\t\t\t\t\t XFS_RMAP_BMBT_BLOCK)\n#define XFS_RMAP_REC_FLAGS\t\t(XFS_RMAP_UNWRITTEN)\nstruct xfs_rmap_irec {\n\txfs_agblock_t\trm_startblock;\t/* extent start block */\n\txfs_extlen_t\trm_blockcount;\t/* extent length */\n\tuint64_t\trm_owner;\t/* extent owner */\n\tuint64_t\trm_offset;\t/* offset within the owner */\n\tunsigned int\trm_flags;\t/* state flags */\n};\n\n/*\n * Key structure\n *\n * We don't use the length for lookups\n */\nstruct xfs_rmap_key {\n\t__be32\t\trm_startblock;\t/* extent start block */\n\t__be64\t\trm_owner;\t/* extent owner */\n\t__be64\t\trm_offset;\t/* offset within the owner */\n} __attribute__((packed));\n\n/* btree pointer type */\ntypedef __be32 xfs_rmap_ptr_t;\n\n#define\tXFS_RMAP_BLOCK(mp) \\\n\t(xfs_sb_version_hasfinobt(&((mp)->m_sb)) ? \\\n\t XFS_FIBT_BLOCK(mp) + 1 : \\\n\t XFS_IBT_BLOCK(mp) + 1)\n\n/*\n * Reference Count Btree format definitions\n *\n */\n#define\tXFS_REFC_CRC_MAGIC\t0x52334643\t/* 'R3FC' */\n\nunsigned int xfs_refc_block(struct xfs_mount *mp);\n\n/*\n * Data record/key structure\n *\n * Each record associates a range of physical blocks (starting at\n * rc_startblock and ending rc_blockcount blocks later) with a reference\n * count (rc_refcount).  Extents that are being used to stage a copy on\n * write (CoW) operation are recorded in the refcount btree with a\n * refcount of 1.  All other records must have a refcount > 1 and must\n * track an extent mapped only by file data forks.\n *\n * Extents with a single owner (attributes, metadata, non-shared file\n * data) are not tracked here.  Free space is also not tracked here.\n * This is consistent with pre-reflink XFS.\n */\n\n/*\n * Extents that are being used to stage a copy on write are stored\n * in the refcount btree with a refcount of 1 and the upper bit set\n * on the startblock.  This speeds up mount time deletion of stale\n * staging extents because they're all at the right side of the tree.\n */\n#define XFS_REFC_COW_START\t\t((xfs_agblock_t)(1U << 31))\n#define REFCNTBT_COWFLAG_BITLEN\t\t1\n#define REFCNTBT_AGBLOCK_BITLEN\t\t31\n\nstruct xfs_refcount_rec {\n\t__be32\t\trc_startblock;\t/* starting block number */\n\t__be32\t\trc_blockcount;\t/* count of blocks */\n\t__be32\t\trc_refcount;\t/* number of inodes linked here */\n};\n\nstruct xfs_refcount_key {\n\t__be32\t\trc_startblock;\t/* starting block number */\n};\n\nstruct xfs_refcount_irec {\n\txfs_agblock_t\trc_startblock;\t/* starting block number */\n\txfs_extlen_t\trc_blockcount;\t/* count of free blocks */\n\txfs_nlink_t\trc_refcount;\t/* number of inodes linked here */\n};\n\n#define MAXREFCOUNT\t((xfs_nlink_t)~0U)\n#define MAXREFCEXTLEN\t((xfs_extlen_t)~0U)\n\n/* btree pointer type */\ntypedef __be32 xfs_refcount_ptr_t;\n\n\n/*\n * BMAP Btree format definitions\n *\n * This includes both the root block definition that sits inside an inode fork\n * and the record/pointer formats for the leaf/node in the blocks.\n */\n#define XFS_BMAP_MAGIC\t\t0x424d4150\t/* 'BMAP' */\n#define XFS_BMAP_CRC_MAGIC\t0x424d4133\t/* 'BMA3' */\n\n/*\n * Bmap root header, on-disk form only.\n */\ntypedef struct xfs_bmdr_block {\n\t__be16\t\tbb_level;\t/* 0 is a leaf */\n\t__be16\t\tbb_numrecs;\t/* current # of data records */\n} xfs_bmdr_block_t;\n\n/*\n * Bmap btree record and extent descriptor.\n *  l0:63 is an extent flag (value 1 indicates non-normal).\n *  l0:9-62 are startoff.\n *  l0:0-8 and l1:21-63 are startblock.\n *  l1:0-20 are blockcount.\n */\n#define BMBT_EXNTFLAG_BITLEN\t1\n#define BMBT_STARTOFF_BITLEN\t54\n#define BMBT_STARTBLOCK_BITLEN\t52\n#define BMBT_BLOCKCOUNT_BITLEN\t21\n\ntypedef struct xfs_bmbt_rec {\n\t__be64\t\t\tl0, l1;\n} xfs_bmbt_rec_t;\n\ntypedef uint64_t\txfs_bmbt_rec_base_t;\t/* use this for casts */\ntypedef xfs_bmbt_rec_t xfs_bmdr_rec_t;\n\n/*\n * Values and macros for delayed-allocation startblock fields.\n */\n#define STARTBLOCKVALBITS\t17\n#define STARTBLOCKMASKBITS\t(15 + 20)\n#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}\n\nstatic inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}\n\nstatic inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}\n\n/*\n * Key structure for non-leaf levels of the tree.\n */\ntypedef struct xfs_bmbt_key {\n\t__be64\t\tbr_startoff;\t/* starting file offset */\n} xfs_bmbt_key_t, xfs_bmdr_key_t;\n\n/* btree pointer type */\ntypedef __be64 xfs_bmbt_ptr_t, xfs_bmdr_ptr_t;\n\n\n/*\n * Generic Btree block format definitions\n *\n * This is a combination of the actual format used on disk for short and long\n * format btrees.  The first three fields are shared by both format, but the\n * pointers are different and should be used with care.\n *\n * To get the size of the actual short or long form headers please use the size\n * macros below.  Never use sizeof(xfs_btree_block).\n *\n * The blkno, crc, lsn, owner and uuid fields are only available in filesystems\n * with the crc feature bit, and all accesses to them must be conditional on\n * that flag.\n */\n/* short form block header */\nstruct xfs_btree_block_shdr {\n\t__be32\t\tbb_leftsib;\n\t__be32\t\tbb_rightsib;\n\n\t__be64\t\tbb_blkno;\n\t__be64\t\tbb_lsn;\n\tuuid_t\t\tbb_uuid;\n\t__be32\t\tbb_owner;\n\t__le32\t\tbb_crc;\n};\n\n/* long form block header */\nstruct xfs_btree_block_lhdr {\n\t__be64\t\tbb_leftsib;\n\t__be64\t\tbb_rightsib;\n\n\t__be64\t\tbb_blkno;\n\t__be64\t\tbb_lsn;\n\tuuid_t\t\tbb_uuid;\n\t__be64\t\tbb_owner;\n\t__le32\t\tbb_crc;\n\t__be32\t\tbb_pad; /* padding for alignment */\n};\n\nstruct xfs_btree_block {\n\t__be32\t\tbb_magic;\t/* magic number for block type */\n\t__be16\t\tbb_level;\t/* 0 is a leaf */\n\t__be16\t\tbb_numrecs;\t/* current # of data records */\n\tunion {\n\t\tstruct xfs_btree_block_shdr s;\n\t\tstruct xfs_btree_block_lhdr l;\n\t} bb_u;\t\t\t\t/* rest */\n};\n\n/* size of a short form block */\n#define XFS_BTREE_SBLOCK_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t offsetof(struct xfs_btree_block_shdr, bb_blkno))\n/* size of a long form block */\n#define XFS_BTREE_LBLOCK_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t offsetof(struct xfs_btree_block_lhdr, bb_blkno))\n\n/* sizes of CRC enabled btree blocks */\n#define XFS_BTREE_SBLOCK_CRC_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t sizeof(struct xfs_btree_block_shdr))\n#define XFS_BTREE_LBLOCK_CRC_LEN \\\n\t(offsetof(struct xfs_btree_block, bb_u) + \\\n\t sizeof(struct xfs_btree_block_lhdr))\n\n#define XFS_BTREE_SBLOCK_CRC_OFF \\\n\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc)\n#define XFS_BTREE_LBLOCK_CRC_OFF \\\n\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc)\n\n/*\n * On-disk XFS access control list structure.\n */\nstruct xfs_acl_entry {\n\t__be32\tae_tag;\n\t__be32\tae_id;\n\t__be16\tae_perm;\n\t__be16\tae_pad;\t\t/* fill the implicit hole in the structure */\n};\n\nstruct xfs_acl {\n\t__be32\t\t\tacl_cnt;\n\tstruct xfs_acl_entry\tacl_entry[0];\n};\n\n/*\n * The number of ACL entries allowed is defined by the on-disk format.\n * For v4 superblocks, that is limited to 25 entries. For v5 superblocks, it is\n * limited only by the maximum size of the xattr that stores the information.\n */\n#define XFS_ACL_MAX_ENTRIES(mp)\t\\\n\t(xfs_sb_version_hascrc(&mp->m_sb) \\\n\t\t?  (XFS_XATTR_SIZE_MAX - sizeof(struct xfs_acl)) / \\\n\t\t\t\t\t\tsizeof(struct xfs_acl_entry) \\\n\t\t: 25)\n\n#define XFS_ACL_SIZE(cnt) \\\n\t(sizeof(struct xfs_acl) + \\\n\t\tsizeof(struct xfs_acl_entry) * cnt)\n\n#define XFS_ACL_MAX_SIZE(mp) \\\n\tXFS_ACL_SIZE(XFS_ACL_MAX_ENTRIES((mp)))\n\n\n/* On-disk XFS extended attribute names */\n#define SGI_ACL_FILE\t\t\"SGI_ACL_FILE\"\n#define SGI_ACL_DEFAULT\t\t\"SGI_ACL_DEFAULT\"\n#define SGI_ACL_FILE_SIZE\t(sizeof(SGI_ACL_FILE)-1)\n#define SGI_ACL_DEFAULT_SIZE\t(sizeof(SGI_ACL_DEFAULT)-1)\n\n#endif /* __XFS_FORMAT_H__ */\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2006 Silicon Graphics, Inc.\n * All Rights Reserved.\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_defer.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_error.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n\n#include <linux/iversion.h>\n\n/*\n * Check that none of the inode's in the buffer have a next\n * unlinked field of 0.\n */\n#if defined(DEBUG)\nvoid\nxfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = xfs_buf_offset(bp, i * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}\n#endif\n\nbool\nxfs_dinode_good_version(\n\tstruct xfs_mount *mp,\n\t__u8\t\tversion)\n{\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn version == 3;\n\n\treturn version == 1 || version == 2;\n}\n\n/*\n * If we are doing readahead on an inode buffer, we might be in log recovery\n * reading an inode allocation buffer that hasn't yet been replayed, and hence\n * has not had the inode cores stamped into it. Hence for readahead, the buffer\n * may be potentially invalid.\n *\n * If the readahead buffer is invalid, we need to mark it with an error and\n * clear the DONE status of the buffer so that a followup read will re-read it\n * from disk. We don't report the error otherwise to avoid warnings during log\n * recovery and we don't get unnecssary panics on debug kernels. We use EIO here\n * because all we want to do is say readahead failed; there is no-one to report\n * the error to, so this will distinguish it from a non-ra verifier failure.\n * Changes to this readahead error behavour also need to be reflected in\n * xfs_dquot_buf_readahead_verify().\n */\nstatic void\nxfs_inode_buf_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\treadahead)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\txfs_agnumber_t\tagno;\n\tint\t\ti;\n\tint\t\tni;\n\n\t/*\n\t * Validate the magic number and version of every inode in the buffer\n\t */\n\tagno = xfs_daddr_to_agno(mp, XFS_BUF_ADDR(bp));\n\tni = XFS_BB_TO_FSB(mp, bp->b_length) * mp->m_sb.sb_inopblock;\n\tfor (i = 0; i < ni; i++) {\n\t\tint\t\tdi_ok;\n\t\txfs_dinode_t\t*dip;\n\t\txfs_agino_t\tunlinked_ino;\n\n\t\tdip = xfs_buf_offset(bp, (i << mp->m_sb.sb_inodelog));\n\t\tunlinked_ino = be32_to_cpu(dip->di_next_unlinked);\n\t\tdi_ok = dip->di_magic == cpu_to_be16(XFS_DINODE_MAGIC) &&\n\t\t\txfs_dinode_good_version(mp, dip->di_version) &&\n\t\t\t(unlinked_ino == NULLAGINO ||\n\t\t\t xfs_verify_agino(mp, agno, unlinked_ino));\n\t\tif (unlikely(XFS_TEST_ERROR(!di_ok, mp,\n\t\t\t\t\t\tXFS_ERRTAG_ITOBP_INOTOBP))) {\n\t\t\tif (readahead) {\n\t\t\t\tbp->b_flags &= ~XBF_DONE;\n\t\t\t\txfs_buf_ioerror(bp, -EIO);\n\t\t\t\treturn;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\txfs_alert(mp,\n\t\t\t\t\"bad inode magic/vsn daddr %lld #%d (magic=%x)\",\n\t\t\t\t(unsigned long long)bp->b_bn, i,\n\t\t\t\tbe16_to_cpu(dip->di_magic));\n#endif\n\t\t\txfs_buf_verifier_error(bp, -EFSCORRUPTED,\n\t\t\t\t\t__func__, dip, sizeof(*dip),\n\t\t\t\t\tNULL);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nstatic void\nxfs_inode_buf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}\n\nstatic void\nxfs_inode_buf_readahead_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, true);\n}\n\nstatic void\nxfs_inode_buf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\txfs_inode_buf_verify(bp, false);\n}\n\nconst struct xfs_buf_ops xfs_inode_buf_ops = {\n\t.name = \"xfs_inode\",\n\t.verify_read = xfs_inode_buf_read_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\nconst struct xfs_buf_ops xfs_inode_buf_ra_ops = {\n\t.name = \"xxfs_inode_ra\",\n\t.verify_read = xfs_inode_buf_readahead_verify,\n\t.verify_write = xfs_inode_buf_write_verify,\n};\n\n\n/*\n * This routine is called to map an inode to the buffer containing the on-disk\n * version of the inode.  It returns a pointer to the buffer containing the\n * on-disk inode in the bpp parameter, and in the dipp parameter it returns a\n * pointer to the on-disk inode within that buffer.\n *\n * If a non-zero error is returned, then the contents of bpp and dipp are\n * undefined.\n */\nint\nxfs_imap_to_bp(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_imap\t\t*imap,\n\tstruct xfs_dinode       **dipp,\n\tstruct xfs_buf\t\t**bpp,\n\tuint\t\t\tbuf_flags,\n\tuint\t\t\tiget_flags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tbuf_flags |= XBF_UNMAPPED;\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, imap->im_blkno,\n\t\t\t\t   (int)imap->im_len, buf_flags, &bp,\n\t\t\t\t   &xfs_inode_buf_ops);\n\tif (error) {\n\t\tif (error == -EAGAIN) {\n\t\t\tASSERT(buf_flags & XBF_TRYLOCK);\n\t\t\treturn error;\n\t\t}\n\t\txfs_warn(mp, \"%s: xfs_trans_read_buf() returned error %d.\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\t*dipp = xfs_buf_offset(bp, imap->im_boffset);\n\treturn 0;\n}\n\nvoid\nxfs_inode_from_disk(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*from)\n{\n\tstruct xfs_icdinode\t*to = &ip->i_d;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\n\t/*\n\t * Convert v1 inodes immediately to v2 inode format as this is the\n\t * minimum inode version format we support in the rest of the code.\n\t */\n\tto->di_version = from->di_version;\n\tif (to->di_version == 1) {\n\t\tset_nlink(inode, be16_to_cpu(from->di_onlink));\n\t\tto->di_projid_lo = 0;\n\t\tto->di_projid_hi = 0;\n\t\tto->di_version = 2;\n\t} else {\n\t\tset_nlink(inode, be32_to_cpu(from->di_nlink));\n\t\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\t\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\t}\n\n\tto->di_format = from->di_format;\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\n\t/*\n\t * Time is signed, so need to convert to signed 32 bit before\n\t * storing in inode timestamp which may be 64 bit. Otherwise\n\t * a time before epoch is converted to a time long after epoch\n\t * on 64 bit systems.\n\t */\n\tinode->i_atime.tv_sec = (int)be32_to_cpu(from->di_atime.t_sec);\n\tinode->i_atime.tv_nsec = (int)be32_to_cpu(from->di_atime.t_nsec);\n\tinode->i_mtime.tv_sec = (int)be32_to_cpu(from->di_mtime.t_sec);\n\tinode->i_mtime.tv_nsec = (int)be32_to_cpu(from->di_mtime.t_nsec);\n\tinode->i_ctime.tv_sec = (int)be32_to_cpu(from->di_ctime.t_sec);\n\tinode->i_ctime.tv_nsec = (int)be32_to_cpu(from->di_ctime.t_nsec);\n\tinode->i_generation = be32_to_cpu(from->di_gen);\n\tinode->i_mode = be16_to_cpu(from->di_mode);\n\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\n\tif (to->di_version == 3) {\n\t\tinode_set_iversion_queried(inode,\n\t\t\t\t\t   be64_to_cpu(from->di_changecount));\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_cowextsize = be32_to_cpu(from->di_cowextsize);\n\t}\n}\n\nvoid\nxfs_inode_to_disk(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*to,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_icdinode\t*from = &ip->i_d;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tto->di_magic = cpu_to_be16(XFS_DINODE_MAGIC);\n\tto->di_onlink = 0;\n\n\tto->di_version = from->di_version;\n\tto->di_format = from->di_format;\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\n\tmemset(to->di_pad, 0, sizeof(to->di_pad));\n\tto->di_atime.t_sec = cpu_to_be32(inode->i_atime.tv_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(inode->i_atime.tv_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(inode->i_mtime.tv_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(inode->i_mtime.tv_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(inode->i_ctime.tv_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(inode->i_ctime.tv_nsec);\n\tto->di_nlink = cpu_to_be32(inode->i_nlink);\n\tto->di_gen = cpu_to_be32(inode->i_generation);\n\tto->di_mode = cpu_to_be16(inode->i_mode);\n\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(inode_peek_iversion(inode));\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_cowextsize = cpu_to_be32(from->di_cowextsize);\n\t\tto->di_ino = cpu_to_be64(ip->i_ino);\n\t\tto->di_lsn = cpu_to_be64(lsn);\n\t\tmemset(to->di_pad2, 0, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &ip->i_mount->m_sb.sb_meta_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}\n\nvoid\nxfs_log_dinode_to_disk(\n\tstruct xfs_log_dinode\t*from,\n\tstruct xfs_dinode\t*to)\n{\n\tto->di_magic = cpu_to_be16(from->di_magic);\n\tto->di_mode = cpu_to_be16(from->di_mode);\n\tto->di_version = from->di_version;\n\tto->di_format = from->di_format;\n\tto->di_onlink = 0;\n\tto->di_uid = cpu_to_be32(from->di_uid);\n\tto->di_gid = cpu_to_be32(from->di_gid);\n\tto->di_nlink = cpu_to_be32(from->di_nlink);\n\tto->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n\tto->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n\tmemcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n\n\tto->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n\tto->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n\tto->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n\tto->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n\tto->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n\tto->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n\n\tto->di_size = cpu_to_be64(from->di_size);\n\tto->di_nblocks = cpu_to_be64(from->di_nblocks);\n\tto->di_extsize = cpu_to_be32(from->di_extsize);\n\tto->di_nextents = cpu_to_be32(from->di_nextents);\n\tto->di_anextents = cpu_to_be16(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat = from->di_aformat;\n\tto->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n\tto->di_dmstate = cpu_to_be16(from->di_dmstate);\n\tto->di_flags = cpu_to_be16(from->di_flags);\n\tto->di_gen = cpu_to_be32(from->di_gen);\n\n\tif (from->di_version == 3) {\n\t\tto->di_changecount = cpu_to_be64(from->di_changecount);\n\t\tto->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = cpu_to_be64(from->di_flags2);\n\t\tto->di_cowextsize = cpu_to_be32(from->di_cowextsize);\n\t\tto->di_ino = cpu_to_be64(from->di_ino);\n\t\tto->di_lsn = cpu_to_be64(from->di_lsn);\n\t\tmemcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n\t\tuuid_copy(&to->di_uuid, &from->di_uuid);\n\t\tto->di_flushiter = 0;\n\t} else {\n\t\tto->di_flushiter = cpu_to_be16(from->di_flushiter);\n\t}\n}\n\nstatic xfs_failaddr_t\nxfs_dinode_verify_fork(\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_mount\t*mp,\n\tint\t\t\twhichfork)\n{\n\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n\n\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\t/*\n\t\t * no local regular files yet\n\t\t */\n\t\tif (whichfork == XFS_DATA_FORK) {\n\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n\t\t\t\treturn __this_address;\n\t\t\tif (be64_to_cpu(dip->di_size) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (di_nextents)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (whichfork == XFS_ATTR_FORK) {\n\t\t\tif (di_nextents > MAXAEXTNUM)\n\t\t\t\treturn __this_address;\n\t\t} else if (di_nextents > MAXEXTNUM) {\n\t\t\treturn __this_address;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\treturn NULL;\n}\n\nxfs_failaddr_t\nxfs_dinode_verify(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_dinode\t*dip)\n{\n\txfs_failaddr_t\t\tfa;\n\tuint16_t\t\tmode;\n\tuint16_t\t\tflags;\n\tuint64_t\t\tflags2;\n\tuint64_t\t\tdi_size;\n\n\tif (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))\n\t\treturn __this_address;\n\n\t/* Verify v3 integrity information first */\n\tif (dip->di_version >= 3) {\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn __this_address;\n\t\tif (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t\t      XFS_DINODE_CRC_OFF))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(dip->di_ino) != ino)\n\t\t\treturn __this_address;\n\t\tif (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t}\n\n\t/* don't allow invalid i_size */\n\tdi_size = be64_to_cpu(dip->di_size);\n\tif (di_size & (1ULL << 63))\n\t\treturn __this_address;\n\n\tmode = be16_to_cpu(dip->di_mode);\n\tif (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)\n\t\treturn __this_address;\n\n\t/* No zero-length symlinks/dirs. */\n\tif ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)\n\t\treturn __this_address;\n\n\t/* Fork checks carried over from xfs_iformat_fork */\n\tif (mode &&\n\t    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >\n\t\t\tbe64_to_cpu(dip->di_nblocks))\n\t\treturn __this_address;\n\n\tif (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)\n\t\treturn __this_address;\n\n\tflags = be16_to_cpu(dip->di_flags);\n\n\tif (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)\n\t\treturn __this_address;\n\n\t/* Do we have appropriate data fork formats for the mode? */\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (dip->di_format != XFS_DINODE_FMT_DEV)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);\n\t\tif (fa)\n\t\t\treturn fa;\n\t\tbreak;\n\tcase 0:\n\t\t/* Uninitialized inode ok. */\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\n\tif (XFS_DFORK_Q(dip)) {\n\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);\n\t\tif (fa)\n\t\t\treturn fa;\n\t} else {\n\t\t/*\n\t\t * If there is no fork offset, this may be a freshly-made inode\n\t\t * in a new disk cluster, in which case di_aformat is zeroed.\n\t\t * Otherwise, such an inode must be in EXTENTS format; this goes\n\t\t * for freed inodes as well.\n\t\t */\n\t\tswitch (dip->di_aformat) {\n\t\tcase 0:\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn __this_address;\n\t\t}\n\t\tif (dip->di_anextents)\n\t\t\treturn __this_address;\n\t}\n\n\t/* extent size hint validation */\n\tfa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),\n\t\t\tmode, flags);\n\tif (fa)\n\t\treturn fa;\n\n\t/* only version 3 or greater inodes are extensively verified here */\n\tif (dip->di_version < 3)\n\t\treturn NULL;\n\n\tflags2 = be64_to_cpu(dip->di_flags2);\n\n\t/* don't allow reflink/cowextsize if we don't have reflink */\n\tif ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&\n\t     !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\t/* only regular files get reflink */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)\n\t\treturn __this_address;\n\n\t/* don't let reflink and realtime mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))\n\t\treturn __this_address;\n\n\t/* don't let reflink and dax mix */\n\tif ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))\n\t\treturn __this_address;\n\n\t/* COW extent size hint validation */\n\tfa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),\n\t\t\tmode, flags, flags2);\n\tif (fa)\n\t\treturn fa;\n\n\treturn NULL;\n}\n\nvoid\nxfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\tuint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum_update((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}\n\n/*\n * Read the disk inode attributes into the in-core inode structure.\n *\n * For version 5 superblocks, if we are initialising a new inode and we are not\n * utilising the XFS_MOUNT_IKEEP inode cluster mode, we can simple build the new\n * inode core with a random generation number. If we are keeping inodes around,\n * we need to read the inode cluster to get the existing generation number off\n * disk. Further, if we are using version 4 superblocks (i.e. v1/v2 inode\n * format) then log recovery is dependent on the di_flushiter field being\n * initialised from the current on-disk value and hence we must also read the\n * inode off disk.\n */\nint\nxfs_iread(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tiget_flags)\n{\n\txfs_buf_t\t*bp;\n\txfs_dinode_t\t*dip;\n\txfs_failaddr_t\tfa;\n\tint\t\terror;\n\n\t/*\n\t * Fill in the location information in the in-core inode.\n\t */\n\terror = xfs_imap(mp, tp, ip->i_ino, &ip->i_imap, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* shortcut IO on inode allocation if possible */\n\tif ((iget_flags & XFS_IGET_CREATE) &&\n\t    xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !(mp->m_flags & XFS_MOUNT_IKEEP)) {\n\t\t/* initialise the on-disk inode core */\n\t\tmemset(&ip->i_d, 0, sizeof(ip->i_d));\n\t\tVFS_I(ip)->i_generation = prandom_u32();\n\t\tip->i_d.di_version = 3;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get pointers to the on-disk inode and the buffer containing it.\n\t */\n\terror = xfs_imap_to_bp(mp, tp, &ip->i_imap, &dip, &bp, 0, iget_flags);\n\tif (error)\n\t\treturn error;\n\n\t/* even unallocated inodes are verified */\n\tfa = xfs_dinode_verify(mp, ip->i_ino, dip);\n\tif (fa) {\n\t\txfs_inode_verifier_error(ip, -EFSCORRUPTED, \"dinode\", dip,\n\t\t\t\tsizeof(*dip), fa);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_brelse;\n\t}\n\n\t/*\n\t * If the on-disk inode is already linked to a directory\n\t * entry, copy all of the inode into the in-core inode.\n\t * xfs_iformat_fork() handles copying in the inode format\n\t * specific information.\n\t * Otherwise, just get the truly permanent information.\n\t */\n\tif (dip->di_mode) {\n\t\txfs_inode_from_disk(ip, dip);\n\t\terror = xfs_iformat_fork(ip, dip);\n\t\tif (error)  {\n#ifdef DEBUG\n\t\t\txfs_alert(mp, \"%s: xfs_iformat() returned error %d\",\n\t\t\t\t__func__, error);\n#endif /* DEBUG */\n\t\t\tgoto out_brelse;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Partial initialisation of the in-core inode. Just the bits\n\t\t * that xfs_ialloc won't overwrite or relies on being correct.\n\t\t */\n\t\tip->i_d.di_version = dip->di_version;\n\t\tVFS_I(ip)->i_generation = be32_to_cpu(dip->di_gen);\n\t\tip->i_d.di_flushiter = be16_to_cpu(dip->di_flushiter);\n\n\t\t/*\n\t\t * Make sure to pull in the mode here as well in\n\t\t * case the inode is released without being used.\n\t\t * This ensures that xfs_inactive() will see that\n\t\t * the inode is already free and not try to mess\n\t\t * with the uninitialized part of it.\n\t\t */\n\t\tVFS_I(ip)->i_mode = 0;\n\t}\n\n\tASSERT(ip->i_d.di_version >= 2);\n\tip->i_delayed_blks = 0;\n\n\t/*\n\t * Mark the buffer containing the inode as something to keep\n\t * around for a while.  This helps to keep recently accessed\n\t * meta-data in-core longer.\n\t */\n\txfs_buf_set_ref(bp, XFS_INO_REF);\n\n\t/*\n\t * Use xfs_trans_brelse() to release the buffer containing the on-disk\n\t * inode, because it was acquired with xfs_trans_read_buf() in\n\t * xfs_imap_to_bp() above.  If tp is NULL, this is just a normal\n\t * brelse().  If we're within a transaction, then xfs_trans_brelse()\n\t * will only release the buffer if it is not dirty within the\n\t * transaction.  It will be OK to release the buffer in this case,\n\t * because inodes on disk are never destroyed and we will be locking the\n\t * new in-core inode before putting it in the cache where other\n\t * processes can find it.  Thus we don't have to worry about the inode\n\t * being changed just because we released the buffer.\n\t */\n out_brelse:\n\txfs_trans_brelse(tp, bp);\n\treturn error;\n}\n\n/*\n * Validate di_extsize hint.\n *\n * The rules are documented at xfs_ioctl_setattr_check_extsize().\n * These functions must be kept in sync with each other.\n */\nxfs_failaddr_t\nxfs_inode_validate_extsize(\n\tstruct xfs_mount\t\t*mp,\n\tuint32_t\t\t\textsize,\n\tuint16_t\t\t\tmode,\n\tuint16_t\t\t\tflags)\n{\n\tbool\t\t\t\trt_flag;\n\tbool\t\t\t\thint_flag;\n\tbool\t\t\t\tinherit_flag;\n\tuint32_t\t\t\textsize_bytes;\n\tuint32_t\t\t\tblocksize_bytes;\n\n\trt_flag = (flags & XFS_DIFLAG_REALTIME);\n\thint_flag = (flags & XFS_DIFLAG_EXTSIZE);\n\tinherit_flag = (flags & XFS_DIFLAG_EXTSZINHERIT);\n\textsize_bytes = XFS_FSB_TO_B(mp, extsize);\n\n\tif (rt_flag)\n\t\tblocksize_bytes = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;\n\telse\n\t\tblocksize_bytes = mp->m_sb.sb_blocksize;\n\n\tif ((hint_flag || inherit_flag) && !(S_ISDIR(mode) || S_ISREG(mode)))\n\t\treturn __this_address;\n\n\tif (hint_flag && !S_ISREG(mode))\n\t\treturn __this_address;\n\n\tif (inherit_flag && !S_ISDIR(mode))\n\t\treturn __this_address;\n\n\tif ((hint_flag || inherit_flag) && extsize == 0)\n\t\treturn __this_address;\n\n\tif (!(hint_flag || inherit_flag) && extsize != 0)\n\t\treturn __this_address;\n\n\tif (extsize_bytes % blocksize_bytes)\n\t\treturn __this_address;\n\n\tif (extsize > MAXEXTLEN)\n\t\treturn __this_address;\n\n\tif (!rt_flag && extsize > mp->m_sb.sb_agblocks / 2)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\n/*\n * Validate di_cowextsize hint.\n *\n * The rules are documented at xfs_ioctl_setattr_check_cowextsize().\n * These functions must be kept in sync with each other.\n */\nxfs_failaddr_t\nxfs_inode_validate_cowextsize(\n\tstruct xfs_mount\t\t*mp,\n\tuint32_t\t\t\tcowextsize,\n\tuint16_t\t\t\tmode,\n\tuint16_t\t\t\tflags,\n\tuint64_t\t\t\tflags2)\n{\n\tbool\t\t\t\trt_flag;\n\tbool\t\t\t\thint_flag;\n\tuint32_t\t\t\tcowextsize_bytes;\n\n\trt_flag = (flags & XFS_DIFLAG_REALTIME);\n\thint_flag = (flags2 & XFS_DIFLAG2_COWEXTSIZE);\n\tcowextsize_bytes = XFS_FSB_TO_B(mp, cowextsize);\n\n\tif (hint_flag && !xfs_sb_version_hasreflink(&mp->m_sb))\n\t\treturn __this_address;\n\n\tif (hint_flag && !(S_ISDIR(mode) || S_ISREG(mode)))\n\t\treturn __this_address;\n\n\tif (hint_flag && cowextsize == 0)\n\t\treturn __this_address;\n\n\tif (!hint_flag && cowextsize != 0)\n\t\treturn __this_address;\n\n\tif (hint_flag && rt_flag)\n\t\treturn __this_address;\n\n\tif (cowextsize_bytes % mp->m_sb.sb_blocksize)\n\t\treturn __this_address;\n\n\tif (cowextsize > MAXEXTLEN)\n\t\treturn __this_address;\n\n\tif (cowextsize > mp->m_sb.sb_agblocks / 2)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n"], "filenames": ["fs/xfs/libxfs/xfs_format.h", "fs/xfs/libxfs/xfs_inode_buf.c"], "buggy_code_start_loc": [964, 376], "buggy_code_end_loc": [964, 482], "fixing_code_start_loc": [965, 377], "fixing_code_end_loc": [968, 500], "type": "CWE-787", "message": "An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork.", "other": {"cve": {"id": "CVE-2018-13095", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-03T10:29:00.333", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork."}, {"lang": "es", "value": "Se ha descubierto un problema en fs/xfs/libxfs/xfs_inode_buf.c en el kernel de Linux hasta la versi\u00f3n 4.17.3. Puede ocurrir una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria y BUG) para una imagen xfs corrupta despu\u00e9s de encontrarse con un inode con formato extendido, pero tiene m\u00e1s extensiones que cabr\u00edan en el fork inode."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.17.3", "matchCriteriaId": "C6ECF5D0-AFCC-470A-9D01-4A372C09556D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:1350", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=199915", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/fs/xfs/xfs-linux.git/commit/?h=for-next&id=23fcb3340d033d9f081e21e6c12c2db7eaa541d3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3"}}