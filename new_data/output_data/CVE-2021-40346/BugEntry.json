{"buggy_code": ["/*\n * include/haproxy/htx.h\n * This file defines everything related to the internal HTTP messages.\n *\n * Copyright (C) 2018 HAProxy Technologies, Christopher Faulet <cfaulet@haproxy.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, version 2.1\n * exclusively.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef _HAPROXY_HTX_H\n#define _HAPROXY_HTX_H\n\n#include <import/ist.h>\n#include <haproxy/api.h>\n#include <haproxy/buf.h>\n#include <haproxy/chunk.h>\n#include <haproxy/http-hdr-t.h>\n#include <haproxy/http-t.h>\n#include <haproxy/htx-t.h>\n\nextern struct htx htx_empty;\n\nstruct htx_blk *htx_defrag(struct htx *htx, struct htx_blk *blk, uint32_t info);\nstruct htx_blk *htx_add_blk(struct htx *htx, enum htx_blk_type type, uint32_t blksz);\nstruct htx_blk *htx_remove_blk(struct htx *htx, struct htx_blk *blk);\nstruct htx_ret htx_find_offset(struct htx *htx, uint32_t offset);\nvoid htx_truncate(struct htx *htx, uint32_t offset);\nstruct htx_ret htx_drain(struct htx *htx, uint32_t max);\n\nstruct htx_blk *htx_replace_blk_value(struct htx *htx, struct htx_blk *blk,\n\t\t\t\t      const struct ist old, const struct ist new);\nstruct htx_ret htx_xfer_blks(struct htx *dst, struct htx *src, uint32_t count,\n\t\t\t     enum htx_blk_type mark);\n\nstruct htx_sl *htx_replace_stline(struct htx *htx, struct htx_blk *blk, const struct ist p1,\n\t\t\t\t  const struct ist p2, const struct ist p3);\n\nstruct htx_blk *htx_replace_header(struct htx *htx, struct htx_blk *blk,\n\t\t\t\t   const struct ist name, const struct ist value);\n\nstruct htx_ret htx_reserve_max_data(struct htx *htx);\nstruct htx_blk *htx_add_data_atonce(struct htx *htx, struct ist data);\nsize_t htx_add_data(struct htx *htx, const struct ist data);\nstruct htx_blk *htx_add_last_data(struct htx *htx, struct ist data);\nvoid htx_move_blk_before(struct htx *htx, struct htx_blk **blk, struct htx_blk **ref);\nint htx_append_msg(struct htx *dst, const struct htx *src);\n\n/* Functions and macros to get parts of the start-line or length of these\n * parts. Request and response start-lines are both composed of 3 parts.\n */\n#define HTX_SL_LEN(sl) ((sl)->len[0] + (sl)->len[1] + (sl)->len[2])\n\n#define HTX_SL_P1_LEN(sl) ((sl)->len[0])\n#define HTX_SL_P2_LEN(sl) ((sl)->len[1])\n#define HTX_SL_P3_LEN(sl) ((sl)->len[2])\n#define HTX_SL_P1_PTR(sl) ((sl)->l)\n#define HTX_SL_P2_PTR(sl) (HTX_SL_P1_PTR(sl) + HTX_SL_P1_LEN(sl))\n#define HTX_SL_P3_PTR(sl) (HTX_SL_P2_PTR(sl) + HTX_SL_P2_LEN(sl))\n\n#define HTX_SL_REQ_MLEN(sl) HTX_SL_P1_LEN(sl)\n#define HTX_SL_REQ_ULEN(sl) HTX_SL_P2_LEN(sl)\n#define HTX_SL_REQ_VLEN(sl) HTX_SL_P3_LEN(sl)\n#define HTX_SL_REQ_MPTR(sl) HTX_SL_P1_PTR(sl)\n#define HTX_SL_REQ_UPTR(sl) HTX_SL_P2_PTR(sl)\n#define HTX_SL_REQ_VPTR(sl) HTX_SL_P3_PTR(sl)\n\n#define HTX_SL_RES_VLEN(sl) HTX_SL_P1_LEN(sl)\n#define HTX_SL_RES_CLEN(sl) HTX_SL_P2_LEN(sl)\n#define HTX_SL_RES_RLEN(sl) HTX_SL_P3_LEN(sl)\n#define HTX_SL_RES_VPTR(sl) HTX_SL_P1_PTR(sl)\n#define HTX_SL_RES_CPTR(sl) HTX_SL_P2_PTR(sl)\n#define HTX_SL_RES_RPTR(sl) HTX_SL_P3_PTR(sl)\n\nstatic inline struct ist htx_sl_p1(const struct htx_sl *sl)\n{\n\treturn ist2(HTX_SL_P1_PTR(sl), HTX_SL_P1_LEN(sl));\n}\n\nstatic inline struct ist htx_sl_p2(const struct htx_sl *sl)\n{\n\treturn ist2(HTX_SL_P2_PTR(sl), HTX_SL_P2_LEN(sl));\n}\n\nstatic inline struct ist htx_sl_p3(const struct htx_sl *sl)\n{\n\treturn ist2(HTX_SL_P3_PTR(sl), HTX_SL_P3_LEN(sl));\n}\n\nstatic inline struct ist htx_sl_req_meth(const struct htx_sl *sl)\n{\n\treturn htx_sl_p1(sl);\n}\n\nstatic inline struct ist htx_sl_req_uri(const struct htx_sl *sl)\n{\n\treturn htx_sl_p2(sl);\n}\n\nstatic inline struct ist htx_sl_req_vsn(const struct htx_sl *sl)\n{\n\treturn htx_sl_p3(sl);\n}\n\n\nstatic inline struct ist htx_sl_res_vsn(const struct htx_sl *sl)\n{\n\treturn htx_sl_p1(sl);\n}\n\nstatic inline struct ist htx_sl_res_code(const struct htx_sl *sl)\n{\n\treturn htx_sl_p2(sl);\n}\n\nstatic inline struct ist htx_sl_res_reason(const struct htx_sl *sl)\n{\n\treturn htx_sl_p3(sl);\n}\n\n/* Converts a position to the corresponding relative address */\nstatic inline uint32_t htx_pos_to_addr(const struct htx *htx, uint32_t pos)\n{\n\treturn htx->size - (pos + 1) * sizeof(struct htx_blk);\n}\n\n/* Returns the position of the block <blk>. It is the caller responsibility to\n * be sure <blk> is part of <htx>. */\nstatic inline uint32_t htx_get_blk_pos(const struct htx *htx, const struct htx_blk *blk)\n{\n\treturn ((htx->blocks + htx->size - (char *)blk) / sizeof(struct htx_blk) - 1);\n}\n\n/* Returns the block at the position <pos>. It is the caller responsibility to\n * be sure the block at the position <pos> exists. */\nstatic inline struct htx_blk *htx_get_blk(const struct htx *htx, uint32_t pos)\n{\n\treturn (struct htx_blk *)(htx->blocks + htx_pos_to_addr(htx, pos));\n}\n\n/* Returns the type of the block <blk> */\nstatic inline enum htx_blk_type htx_get_blk_type(const struct htx_blk *blk)\n{\n\treturn (blk->info >> 28);\n}\n\n/* Returns the size of the block <blk>, depending of its type */\nstatic inline uint32_t htx_get_blksz(const struct htx_blk *blk)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\t/*       name.length       +        value.length        */\n\t\t\treturn ((blk->info & 0xff) + ((blk->info >> 8) & 0xfffff));\n\t\tdefault:\n\t\t\t/*         value.length      */\n\t\t\treturn (blk->info & 0xfffffff);\n\t}\n}\n\n/* Returns the position of the oldest entry (head). It returns a signed 32-bits\n * integer, -1 means the HTX message is empty.\n */\nstatic inline int32_t htx_get_head(const struct htx *htx)\n{\n\treturn htx->head;\n}\n\n/* Returns the oldest HTX block (head) if the HTX message is not\n * empty. Otherwise it returns NULL.\n */\nstatic inline struct htx_blk *htx_get_head_blk(const struct htx *htx)\n{\n\tint32_t head = htx_get_head(htx);\n\n\treturn ((head == -1) ? NULL : htx_get_blk(htx, head));\n}\n\n/* Returns the type of the oldest HTX block (head) if the HTX message is not\n * empty. Otherwise it returns HTX_BLK_UNUSED.\n */\nstatic inline enum htx_blk_type htx_get_head_type(const struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_head_blk(htx);\n\n\treturn (blk ? htx_get_blk_type(blk) : HTX_BLK_UNUSED);\n}\n\n/* Returns the position of the newest entry (tail).  It returns a signed 32-bits\n * integer, -1 means the HTX message is empty.\n */\nstatic inline int32_t htx_get_tail(const struct htx *htx)\n{\n\treturn htx->tail;\n}\n\n/* Returns the newest HTX block (tail) if the HTX message is not\n * empty. Otherwise it returns NULL.\n */\nstatic inline struct htx_blk *htx_get_tail_blk(const struct htx *htx)\n{\n\tint32_t tail = htx_get_tail(htx);\n\n\treturn ((tail == -1) ? NULL : htx_get_blk(htx, tail));\n}\n\n/* Returns the type of the newest HTX block (tail) if the HTX message is not\n * empty. Otherwise it returns HTX_BLK_UNUSED.\n */\nstatic inline enum htx_blk_type htx_get_tail_type(const struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_tail_blk(htx);\n\n\treturn (blk ? htx_get_blk_type(blk) : HTX_BLK_UNUSED);\n}\n\n/* Returns the position of the first block in the HTX message <htx>. -1 means\n * the first block is unset or the HTS is empty.\n */\nstatic inline int32_t htx_get_first(const struct htx *htx)\n{\n\treturn htx->first;\n}\n\n/* Returns the first HTX block in the HTX message <htx>. If unset or if <htx> is\n * empty, NULL returned.\n */\nstatic inline struct htx_blk *htx_get_first_blk(const struct htx *htx)\n{\n\tint32_t pos;\n\n\tpos = htx_get_first(htx);\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}\n\n/* Returns the type of the first block in the HTX message <htx>. If unset or if\n * <htx> is empty, HTX_BLK_UNUSED is returned.\n */\nstatic inline enum htx_blk_type htx_get_first_type(const struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_first_blk(htx);\n\n\treturn (blk ? htx_get_blk_type(blk) : HTX_BLK_UNUSED);\n}\n\n/* Returns the position of block immediately before the one pointed by <pos>. If\n * the message is empty or if <pos> is the position of the head, -1 returned.\n */\nstatic inline int32_t htx_get_prev(const struct htx *htx, uint32_t pos)\n{\n\tif (htx->head == -1 || pos == htx->head)\n\t\treturn -1;\n\treturn (pos - 1);\n}\n\n/* Returns the HTX block before <blk> in the HTX message <htx>. If <blk> is the\n * head, NULL returned.\n */\nstatic inline struct htx_blk *htx_get_prev_blk(const struct htx *htx,\n\t\t\t\t\t       const struct htx_blk *blk)\n{\n\tint32_t pos;\n\n\tpos = htx_get_prev(htx, htx_get_blk_pos(htx, blk));\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}\n\n/* Returns the position of block immediately after the one pointed by <pos>. If\n * the message is empty or if <pos> is the position of the tail, -1 returned.\n */\nstatic inline int32_t htx_get_next(const struct htx *htx, uint32_t pos)\n{\n\tif (htx->tail == -1 || pos == htx->tail)\n\t\treturn -1;\n\treturn (pos + 1);\n\n}\n\n/* Returns the HTX block after <blk> in the HTX message <htx>. If <blk> is the\n * tail, NULL returned.\n */\nstatic inline struct htx_blk *htx_get_next_blk(const struct htx *htx,\n\t\t\t\t\t       const struct htx_blk *blk)\n{\n\tint32_t pos;\n\n\tpos = htx_get_next(htx, htx_get_blk_pos(htx, blk));\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}\n\n/* Returns 1 if <blk> is the block is the only one inside the HTX message <htx>,\n * excluding all unused blocks. Otherwise, it returns 0. If 1 is returned, this\n * means that there is only <blk> and eventually some unused ones in <htx>.\n */\nstatic inline int htx_is_unique_blk(const struct htx *htx,\n\t\t\t\t    const struct htx_blk *blk)\n{\n\treturn (htx_get_blksz(blk) == htx->data);\n}\n\n/* Changes the size of the value. It is the caller responsibility to change the\n * value itself, make sure there is enough space and update allocated\n * value. This function updates the HTX message accordingly.\n */\nstatic inline void htx_change_blk_value_len(struct htx *htx, struct htx_blk *blk, uint32_t newlen)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\tuint32_t oldlen, sz;\n\tint32_t delta;\n\n\tsz = htx_get_blksz(blk);\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\toldlen = (blk->info >> 8) & 0xfffff;\n\t\t\tblk->info = (type << 28) + (newlen << 8) + (blk->info & 0xff);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toldlen = blk->info & 0xfffffff;\n\t\t\tblk->info = (type << 28) + newlen;\n\t\t\tbreak;\n\t}\n\n\t/* Update HTTP message */\n\tdelta = (newlen - oldlen);\n\thtx->data += delta;\n\tif (blk->addr+sz == htx->tail_addr)\n\t\thtx->tail_addr += delta;\n\telse if (blk->addr+sz == htx->head_addr)\n\t\thtx->head_addr += delta;\n}\n\n/* Changes the size of the value. It is the caller responsibility to change the\n * value itself, make sure there is enough space and update allocated\n * value. Unlike the function htx_change_blk_value_len(), this one does not\n * update the HTX message. So it should be used with caution.\n */\nstatic inline void htx_set_blk_value_len(struct htx_blk *blk, uint32_t vlen)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\tblk->info = (type << 28) + (vlen << 8) + (blk->info & 0xff);\n\t\t\tbreak;\n\t\tcase HTX_BLK_REQ_SL:\n\t\tcase HTX_BLK_RES_SL:\n\t\tcase HTX_BLK_DATA:\n\t\t\tblk->info = (type << 28) + vlen;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected case */\n\t\t\tbreak;\n\t}\n}\n\n/* Returns the data pointer of the block <blk> */\nstatic inline void *htx_get_blk_ptr(const struct htx *htx, const struct htx_blk *blk)\n{\n\treturn ((void *)htx->blocks + blk->addr);\n}\n\n/* Returns the name of the block <blk>, only if it is a header or a\n * trailer. Otherwise it returns an empty string.\n */\nstatic inline struct ist htx_get_blk_name(const struct htx *htx, const struct htx_blk *blk)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\tstruct ist ret;\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\tret.ptr = htx_get_blk_ptr(htx, blk);\n\t\t\tret.len = blk->info & 0xff;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn ist(\"\");\n\t}\n\treturn ret;\n}\n\n\n/* Returns the value of the block <blk>, depending on its type. If there is no\n * value (for end-of blocks), an empty one is returned.\n */\nstatic inline struct ist htx_get_blk_value(const struct htx *htx, const struct htx_blk *blk)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\tstruct ist ret;\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\tret.ptr = htx_get_blk_ptr(htx, blk) + (blk->info & 0xff);\n\t\t\tret.len = (blk->info >> 8) & 0xfffff;\n\t\t\tbreak;\n\n\t\tcase HTX_BLK_REQ_SL:\n\t\tcase HTX_BLK_RES_SL:\n\t\tcase HTX_BLK_DATA:\n\t\t\tret.ptr = htx_get_blk_ptr(htx, blk);\n\t\t\tret.len = blk->info & 0xfffffff;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn ist(\"\");\n\t}\n\treturn ret;\n}\n\n/* Add a new start-line. It returns it on success, otherwise it returns NULL. It\n * is the caller responsibility to set sl->info, if necessary.\n */\nstatic inline struct htx_sl *htx_add_stline(struct htx *htx, enum htx_blk_type type, unsigned int flags,\n\t\t\t\t\t    const struct ist p1, const struct ist p2, const struct ist p3)\n{\n\tstruct htx_blk *blk;\n\tstruct htx_sl  *sl;\n\tuint32_t size;\n\n\tif (type != HTX_BLK_REQ_SL && type != HTX_BLK_RES_SL)\n\t\treturn NULL;\n\n\tsize = sizeof(*sl) + p1.len + p2.len + p3.len;\n\n\tblk = htx_add_blk(htx, type, size);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += size;\n\n\tsl = htx_get_blk_ptr(htx, blk);\n\tsl->flags = flags;\n\n\tHTX_SL_P1_LEN(sl) = p1.len;\n\tHTX_SL_P2_LEN(sl) = p2.len;\n\tHTX_SL_P3_LEN(sl) = p3.len;\n\n\tmemcpy(HTX_SL_P1_PTR(sl), p1.ptr, p1.len);\n\tmemcpy(HTX_SL_P2_PTR(sl), p2.ptr, p2.len);\n\tmemcpy(HTX_SL_P3_PTR(sl), p3.ptr, p3.len);\n\n\treturn sl;\n}\n\n/* Adds an HTX block of type HDR in <htx>. It returns the new block on\n * success. Otherwise, it returns NULL. The header name is always lower cased.\n */\nstatic inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}\n\n/* Adds an HTX block of type TLR in <htx>. It returns the new block on\n * success. Otherwise, it returns NULL. The trailer name is always lower cased.\n */\nstatic inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\t/* FIXME: check name.len (< 256B) and value.len (< 1MB) */\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}\n\n/* Adds an HTX block of type EOH or EOT in <htx>. It returns the new block on\n * success. Otherwise, it returns NULL.\n */\nstatic inline struct htx_blk *htx_add_endof(struct htx *htx, enum htx_blk_type type)\n{\n\tstruct htx_blk *blk;\n\n\tblk = htx_add_blk(htx, type, 1);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += 1;\n\treturn blk;\n}\n\n/* Add all headers from the list <hdrs> into the HTX message <htx>, followed by\n * the EOH. On success, it returns the last block inserted (the EOH), otherwise\n * NULL is returned. */\nstatic inline struct htx_blk *htx_add_all_headers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_header(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOH);\n}\n\n/* Add all trailers from the list <hdrs> into the HTX message <htx>, followed by\n * the EOT. On success, it returns the last block inserted (the EOT), otherwise\n * NULL is returned. */\nstatic inline struct htx_blk *htx_add_all_trailers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_trailer(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOT);\n}\n\n/* Removes <n> bytes from the beginning of DATA block <blk>. The block's start\n * address and its length are adjusted, and the htx's total data count is\n * updated. This is used to mark that part of some data were transferred\n * from a DATA block without removing this DATA block. No sanity check is\n * performed, the caller is responsible for doing this exclusively on DATA\n * blocks, and never removing more than the block's size.\n */\nstatic inline void htx_cut_data_blk(struct htx *htx, struct htx_blk *blk, uint32_t n)\n{\n\tif (blk->addr == htx->end_addr)\n\t\thtx->end_addr += n;\n\tblk->addr += n;\n\tblk->info -= n;\n\thtx->data -= n;\n}\n\n/* Returns the space used by metadata in <htx>. */\nstatic inline uint32_t htx_meta_space(const struct htx *htx)\n{\n\tif (htx->tail == -1)\n\t\treturn 0;\n\n\treturn ((htx->tail + 1 - htx->head) * sizeof(struct htx_blk));\n}\n\n/* Returns the space used (payload + metadata) in <htx> */\nstatic inline uint32_t htx_used_space(const struct htx *htx)\n{\n\treturn (htx->data + htx_meta_space(htx));\n}\n\n/* Returns the free space in <htx> */\nstatic inline uint32_t htx_free_space(const struct htx *htx)\n{\n\treturn (htx->size - htx_used_space(htx));\n}\n\n/* Returns the maximum size available to store some data in <htx> if a new block\n * is reserved.\n */\nstatic inline uint32_t htx_free_data_space(const struct htx *htx)\n{\n\tuint32_t free = htx_free_space(htx);\n\n\tif (free < sizeof(struct htx_blk))\n\t\treturn 0;\n\treturn (free - sizeof(struct htx_blk));\n}\n\n/* Returns the maximum size for a block, not exceeding <max> bytes. <max> may be\n * set to -1 to have no limit.\n */\nstatic inline uint32_t htx_get_max_blksz(const struct htx *htx, int32_t max)\n{\n\tuint32_t free = htx_free_space(htx);\n\n\tif (max != -1 && free > max)\n\t\tfree = max;\n\tif (free < sizeof(struct htx_blk))\n\t\treturn 0;\n\treturn (free - sizeof(struct htx_blk));\n}\n\n/* Returns 1 if the message has less than 1/4 of its capacity free, otherwise 0 */\nstatic inline int htx_almost_full(const struct htx *htx)\n{\n\tif (!htx->size || htx_free_space(htx) < htx->size / 4)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Resets an HTX message */\nstatic inline void htx_reset(struct htx *htx)\n{\n\thtx->tail = htx->head  = htx->first = -1;\n\thtx->data = 0;\n\thtx->tail_addr = htx->head_addr = htx->end_addr = 0;\n\thtx->extra = 0;\n\thtx->flags = HTX_FL_NONE;\n}\n\n/* Returns the available room for raw data in buffer <buf> once HTX overhead is\n * taken into account (one HTX header and two blocks). The purpose is to figure\n * the optimal fill length to avoid copies.\n */\nstatic inline size_t buf_room_for_htx_data(const struct buffer *buf)\n{\n\tsize_t room;\n\n\troom = b_room(buf);\n\tif (room <= sizeof(struct htx) + 2 * sizeof(struct htx_blk))\n\t\troom = 0;\n\telse\n\t\troom -= sizeof(struct htx) + 2 * sizeof(struct htx_blk);\n\n\treturn room;\n}\n\n\n/* Returns an HTX message using the buffer <buf>. Unlike htx_from_buf(), this\n * function does not update the buffer. So if the HTX message is updated, the\n * caller must call htx_to_buf() to be sure to also update the underlying buffer\n * accordingly.  Note that it always returns a valid pointer, either to an\n * initialized buffer or to the empty buffer. This function must always be\n * called with a buffer containing an HTX message (or an empty buffer).\n */\nstatic inline struct htx *htxbuf(const struct buffer *buf)\n{\n\tstruct htx *htx;\n\n\tif (b_is_null(buf))\n\t\treturn &htx_empty;\n\thtx = ((struct htx *)(buf->area));\n\tif (!b_data(buf)) {\n\t\thtx->size = buf->size - sizeof(*htx);\n\t\thtx_reset(htx);\n\t}\n\treturn htx;\n}\n\n/* Returns an HTX message using the buffer <buf>. <buf> is updated to appear as\n * full. It should be used when you want to add something into the HTX message,\n * so the call to htx_to_buf() may be skipped. But, it is the caller\n * responsibility to call htx_to_buf() to reset <buf> if it is relevant. The\n * returned pointer is always valid. This function must always be called with a\n * buffer containing an HTX message (or an empty buffer).\n *\n * The caller can call htxbuf() function to avoid any update of the buffer.\n */\nstatic inline struct htx *htx_from_buf(struct buffer *buf)\n{\n\tstruct htx *htx = htxbuf(buf);\n\n\tb_set_data(buf, b_size(buf));\n\treturn htx;\n}\n\n/* Update <buf> accordingly to the HTX message <htx> */\nstatic inline void htx_to_buf(struct htx *htx, struct buffer *buf)\n{\n\tif ((htx->head == -1) &&\n\t    !(htx->flags & (HTX_FL_PARSING_ERROR|HTX_FL_PROCESSING_ERROR))) {\n\t\thtx_reset(htx);\n\t\tb_set_data(buf, 0);\n\t}\n\telse\n\t\tb_set_data(buf, b_size(buf));\n}\n\n/* Returns 1 if the message is empty, otherwise it returns 0. Note that it is\n * illegal to call this with htx == NULL.\n */\nstatic inline int htx_is_empty(const struct htx *htx)\n{\n\treturn (htx->head == -1);\n}\n\n/* Returns 1 if the message is not empty, otherwise it returns 0. Note that it\n * is illegal to call this with htx == NULL.\n */\nstatic inline int htx_is_not_empty(const struct htx *htx)\n{\n\treturn (htx->head != -1);\n}\n\n/* Returns 1 if no more data are expected for the message <htx>. Otherwise it\n * returns 0. Note that it is illegal to call this with htx == NULL. This\n * function relies on the HTX_FL_EOM flags. It means tunneled data are not\n * considered here.\n */\nstatic inline int htx_expect_more(const struct htx *htx)\n{\n\treturn !(htx->flags & HTX_FL_EOM);\n}\n\n/* Copy an HTX message stored in the buffer <msg> to <htx>. We take care to\n * not overwrite existing data. All the message is copied or nothing. It returns\n * 1 on success and 0 on error.\n */\nstatic inline int htx_copy_msg(struct htx *htx, const struct buffer *msg)\n{\n\t/* The destination HTX message is empty, we can do a raw copy */\n\tif (htx_is_empty(htx)) {\n\t\tmemcpy(htx, msg->area, msg->size);\n\t\treturn 1;\n\t}\n\n\t/* Otherwise, we need to append the HTX message */\n\treturn htx_append_msg(htx, htxbuf(msg));\n}\n\n/* Remove all blocks except headers. Trailers will also be removed too. */\nstatic inline void htx_skip_msg_payload(struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_first_blk(htx);\n\n\twhile (blk) {\n\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\tblk = ((type > HTX_BLK_EOH)\n\t\t       ? htx_remove_blk(htx, blk)\n\t\t       : htx_get_next_blk(htx, blk));\n\t}\n}\n\n/* Returns the number of used blocks in the HTX message <htx>. Note that it is\n * illegal to call this function with htx == NULL. Note also blocks of type\n * HTX_BLK_UNUSED are part of used blocks.\n */\nstatic inline int htx_nbblks(const struct htx *htx)\n{\n\treturn ((htx->head != -1) ? (htx->tail + 1 - htx->head) : 0);\n}\n/* For debugging purpose */\nstatic inline const char *htx_blk_type_str(enum htx_blk_type type)\n{\n\tswitch (type) {\n\t\tcase HTX_BLK_REQ_SL: return \"HTX_BLK_REQ_SL\";\n\t\tcase HTX_BLK_RES_SL: return \"HTX_BLK_RES_SL\";\n\t\tcase HTX_BLK_HDR:    return \"HTX_BLK_HDR\";\n\t\tcase HTX_BLK_EOH:    return \"HTX_BLK_EOH\";\n\t\tcase HTX_BLK_DATA:   return \"HTX_BLK_DATA\";\n\t\tcase HTX_BLK_TLR:    return \"HTX_BLK_TLR\";\n\t\tcase HTX_BLK_EOT:    return \"HTX_BLK_EOT\";\n\t\tcase HTX_BLK_UNUSED: return \"HTX_BLK_UNUSED\";\n\t\tdefault:             return \"HTX_BLK_???\";\n\t};\n}\n\n/* For debugging purpose */\nstatic inline void htx_dump(struct buffer *chunk, const struct htx *htx, int full)\n{\n\tint32_t pos;\n\n\tchunk_appendf(chunk, \" htx=%p(size=%u,data=%u,used=%u,wrap=%s,flags=0x%08x,extra=%llu,\"\n\t\t      \"first=%d,head=%d,tail=%d,tail_addr=%d,head_addr=%d,end_addr=%d)\",\n\t\t      htx, htx->size, htx->data, htx_nbblks(htx), (!htx->head_addr) ? \"NO\" : \"YES\",\n\t\t      htx->flags, (unsigned long long)htx->extra, htx->first, htx->head, htx->tail,\n\t\t      htx->tail_addr, htx->head_addr, htx->end_addr);\n\n\tif (!full || !htx_nbblks(htx))\n\t\treturn;\n\tchunk_memcat(chunk, \"\\n\", 1);\n\n\tfor (pos = htx_get_head(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\tstruct htx_sl     *sl;\n\t\tstruct htx_blk    *blk  = htx_get_blk(htx, pos);\n\t\tenum htx_blk_type  type = htx_get_blk_type(blk);\n\t\tuint32_t           sz   = htx_get_blksz(blk);\n\t\tstruct ist         n, v;\n\n\t\tn = htx_get_blk_name(htx, blk);\n\t\tv = htx_get_blk_value(htx, blk);\n\n\t\tif (type == HTX_BLK_REQ_SL || type == HTX_BLK_RES_SL) {\n\t\t\tsl = htx_get_blk_ptr(htx, blk);\n\t\t\tchunk_appendf(chunk, \"\\t\\t[%u] type=%-17s - size=%-6u - addr=%-6u\\t%.*s %.*s %.*s\\n\",\n\t\t\t\t      pos, htx_blk_type_str(type), sz, blk->addr,\n\t\t\t\t      HTX_SL_P1_LEN(sl), HTX_SL_P1_PTR(sl),\n\t\t\t\t      HTX_SL_P2_LEN(sl), HTX_SL_P2_PTR(sl),\n\t\t\t\t      HTX_SL_P3_LEN(sl), HTX_SL_P3_PTR(sl));\n\t\t}\n\t\telse if (type == HTX_BLK_HDR || type == HTX_BLK_TLR)\n\t\t\tchunk_appendf(chunk, \"\\t\\t[%u] type=%-17s - size=%-6u - addr=%-6u\\t%.*s: %.*s\\n\",\n\t\t\t\t      pos, htx_blk_type_str(type), sz, blk->addr,\n\t\t\t\t      (int)MIN(n.len, 32), n.ptr,\n\t\t\t\t      (int)MIN(v.len, 64), v.ptr);\n\t\telse\n\t\t\tchunk_appendf(chunk, \"\\t\\t[%u] type=%-17s - size=%-6u - addr=%-6u%s\\n\",\n\t\t\t\t      pos, htx_blk_type_str(type), sz, blk->addr,\n\t\t\t\t      (!v.len ? \"\\t<empty>\" : \"\"));\n\t}\n}\n\n#endif /* _HAPROXY_HTX_H */\n\n/*\n * Local variables:\n *  c-indent-level: 8\n *  c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n * include/haproxy/htx.h\n * This file defines everything related to the internal HTTP messages.\n *\n * Copyright (C) 2018 HAProxy Technologies, Christopher Faulet <cfaulet@haproxy.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, version 2.1\n * exclusively.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef _HAPROXY_HTX_H\n#define _HAPROXY_HTX_H\n\n#include <import/ist.h>\n#include <haproxy/api.h>\n#include <haproxy/buf.h>\n#include <haproxy/chunk.h>\n#include <haproxy/http-hdr-t.h>\n#include <haproxy/http-t.h>\n#include <haproxy/htx-t.h>\n\nextern struct htx htx_empty;\n\nstruct htx_blk *htx_defrag(struct htx *htx, struct htx_blk *blk, uint32_t info);\nstruct htx_blk *htx_add_blk(struct htx *htx, enum htx_blk_type type, uint32_t blksz);\nstruct htx_blk *htx_remove_blk(struct htx *htx, struct htx_blk *blk);\nstruct htx_ret htx_find_offset(struct htx *htx, uint32_t offset);\nvoid htx_truncate(struct htx *htx, uint32_t offset);\nstruct htx_ret htx_drain(struct htx *htx, uint32_t max);\n\nstruct htx_blk *htx_replace_blk_value(struct htx *htx, struct htx_blk *blk,\n\t\t\t\t      const struct ist old, const struct ist new);\nstruct htx_ret htx_xfer_blks(struct htx *dst, struct htx *src, uint32_t count,\n\t\t\t     enum htx_blk_type mark);\n\nstruct htx_sl *htx_replace_stline(struct htx *htx, struct htx_blk *blk, const struct ist p1,\n\t\t\t\t  const struct ist p2, const struct ist p3);\n\nstruct htx_blk *htx_replace_header(struct htx *htx, struct htx_blk *blk,\n\t\t\t\t   const struct ist name, const struct ist value);\n\nstruct htx_ret htx_reserve_max_data(struct htx *htx);\nstruct htx_blk *htx_add_data_atonce(struct htx *htx, struct ist data);\nsize_t htx_add_data(struct htx *htx, const struct ist data);\nstruct htx_blk *htx_add_last_data(struct htx *htx, struct ist data);\nvoid htx_move_blk_before(struct htx *htx, struct htx_blk **blk, struct htx_blk **ref);\nint htx_append_msg(struct htx *dst, const struct htx *src);\n\n/* Functions and macros to get parts of the start-line or length of these\n * parts. Request and response start-lines are both composed of 3 parts.\n */\n#define HTX_SL_LEN(sl) ((sl)->len[0] + (sl)->len[1] + (sl)->len[2])\n\n#define HTX_SL_P1_LEN(sl) ((sl)->len[0])\n#define HTX_SL_P2_LEN(sl) ((sl)->len[1])\n#define HTX_SL_P3_LEN(sl) ((sl)->len[2])\n#define HTX_SL_P1_PTR(sl) ((sl)->l)\n#define HTX_SL_P2_PTR(sl) (HTX_SL_P1_PTR(sl) + HTX_SL_P1_LEN(sl))\n#define HTX_SL_P3_PTR(sl) (HTX_SL_P2_PTR(sl) + HTX_SL_P2_LEN(sl))\n\n#define HTX_SL_REQ_MLEN(sl) HTX_SL_P1_LEN(sl)\n#define HTX_SL_REQ_ULEN(sl) HTX_SL_P2_LEN(sl)\n#define HTX_SL_REQ_VLEN(sl) HTX_SL_P3_LEN(sl)\n#define HTX_SL_REQ_MPTR(sl) HTX_SL_P1_PTR(sl)\n#define HTX_SL_REQ_UPTR(sl) HTX_SL_P2_PTR(sl)\n#define HTX_SL_REQ_VPTR(sl) HTX_SL_P3_PTR(sl)\n\n#define HTX_SL_RES_VLEN(sl) HTX_SL_P1_LEN(sl)\n#define HTX_SL_RES_CLEN(sl) HTX_SL_P2_LEN(sl)\n#define HTX_SL_RES_RLEN(sl) HTX_SL_P3_LEN(sl)\n#define HTX_SL_RES_VPTR(sl) HTX_SL_P1_PTR(sl)\n#define HTX_SL_RES_CPTR(sl) HTX_SL_P2_PTR(sl)\n#define HTX_SL_RES_RPTR(sl) HTX_SL_P3_PTR(sl)\n\nstatic inline struct ist htx_sl_p1(const struct htx_sl *sl)\n{\n\treturn ist2(HTX_SL_P1_PTR(sl), HTX_SL_P1_LEN(sl));\n}\n\nstatic inline struct ist htx_sl_p2(const struct htx_sl *sl)\n{\n\treturn ist2(HTX_SL_P2_PTR(sl), HTX_SL_P2_LEN(sl));\n}\n\nstatic inline struct ist htx_sl_p3(const struct htx_sl *sl)\n{\n\treturn ist2(HTX_SL_P3_PTR(sl), HTX_SL_P3_LEN(sl));\n}\n\nstatic inline struct ist htx_sl_req_meth(const struct htx_sl *sl)\n{\n\treturn htx_sl_p1(sl);\n}\n\nstatic inline struct ist htx_sl_req_uri(const struct htx_sl *sl)\n{\n\treturn htx_sl_p2(sl);\n}\n\nstatic inline struct ist htx_sl_req_vsn(const struct htx_sl *sl)\n{\n\treturn htx_sl_p3(sl);\n}\n\n\nstatic inline struct ist htx_sl_res_vsn(const struct htx_sl *sl)\n{\n\treturn htx_sl_p1(sl);\n}\n\nstatic inline struct ist htx_sl_res_code(const struct htx_sl *sl)\n{\n\treturn htx_sl_p2(sl);\n}\n\nstatic inline struct ist htx_sl_res_reason(const struct htx_sl *sl)\n{\n\treturn htx_sl_p3(sl);\n}\n\n/* Converts a position to the corresponding relative address */\nstatic inline uint32_t htx_pos_to_addr(const struct htx *htx, uint32_t pos)\n{\n\treturn htx->size - (pos + 1) * sizeof(struct htx_blk);\n}\n\n/* Returns the position of the block <blk>. It is the caller responsibility to\n * be sure <blk> is part of <htx>. */\nstatic inline uint32_t htx_get_blk_pos(const struct htx *htx, const struct htx_blk *blk)\n{\n\treturn ((htx->blocks + htx->size - (char *)blk) / sizeof(struct htx_blk) - 1);\n}\n\n/* Returns the block at the position <pos>. It is the caller responsibility to\n * be sure the block at the position <pos> exists. */\nstatic inline struct htx_blk *htx_get_blk(const struct htx *htx, uint32_t pos)\n{\n\treturn (struct htx_blk *)(htx->blocks + htx_pos_to_addr(htx, pos));\n}\n\n/* Returns the type of the block <blk> */\nstatic inline enum htx_blk_type htx_get_blk_type(const struct htx_blk *blk)\n{\n\treturn (blk->info >> 28);\n}\n\n/* Returns the size of the block <blk>, depending of its type */\nstatic inline uint32_t htx_get_blksz(const struct htx_blk *blk)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\t/*       name.length       +        value.length        */\n\t\t\treturn ((blk->info & 0xff) + ((blk->info >> 8) & 0xfffff));\n\t\tdefault:\n\t\t\t/*         value.length      */\n\t\t\treturn (blk->info & 0xfffffff);\n\t}\n}\n\n/* Returns the position of the oldest entry (head). It returns a signed 32-bits\n * integer, -1 means the HTX message is empty.\n */\nstatic inline int32_t htx_get_head(const struct htx *htx)\n{\n\treturn htx->head;\n}\n\n/* Returns the oldest HTX block (head) if the HTX message is not\n * empty. Otherwise it returns NULL.\n */\nstatic inline struct htx_blk *htx_get_head_blk(const struct htx *htx)\n{\n\tint32_t head = htx_get_head(htx);\n\n\treturn ((head == -1) ? NULL : htx_get_blk(htx, head));\n}\n\n/* Returns the type of the oldest HTX block (head) if the HTX message is not\n * empty. Otherwise it returns HTX_BLK_UNUSED.\n */\nstatic inline enum htx_blk_type htx_get_head_type(const struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_head_blk(htx);\n\n\treturn (blk ? htx_get_blk_type(blk) : HTX_BLK_UNUSED);\n}\n\n/* Returns the position of the newest entry (tail).  It returns a signed 32-bits\n * integer, -1 means the HTX message is empty.\n */\nstatic inline int32_t htx_get_tail(const struct htx *htx)\n{\n\treturn htx->tail;\n}\n\n/* Returns the newest HTX block (tail) if the HTX message is not\n * empty. Otherwise it returns NULL.\n */\nstatic inline struct htx_blk *htx_get_tail_blk(const struct htx *htx)\n{\n\tint32_t tail = htx_get_tail(htx);\n\n\treturn ((tail == -1) ? NULL : htx_get_blk(htx, tail));\n}\n\n/* Returns the type of the newest HTX block (tail) if the HTX message is not\n * empty. Otherwise it returns HTX_BLK_UNUSED.\n */\nstatic inline enum htx_blk_type htx_get_tail_type(const struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_tail_blk(htx);\n\n\treturn (blk ? htx_get_blk_type(blk) : HTX_BLK_UNUSED);\n}\n\n/* Returns the position of the first block in the HTX message <htx>. -1 means\n * the first block is unset or the HTS is empty.\n */\nstatic inline int32_t htx_get_first(const struct htx *htx)\n{\n\treturn htx->first;\n}\n\n/* Returns the first HTX block in the HTX message <htx>. If unset or if <htx> is\n * empty, NULL returned.\n */\nstatic inline struct htx_blk *htx_get_first_blk(const struct htx *htx)\n{\n\tint32_t pos;\n\n\tpos = htx_get_first(htx);\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}\n\n/* Returns the type of the first block in the HTX message <htx>. If unset or if\n * <htx> is empty, HTX_BLK_UNUSED is returned.\n */\nstatic inline enum htx_blk_type htx_get_first_type(const struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_first_blk(htx);\n\n\treturn (blk ? htx_get_blk_type(blk) : HTX_BLK_UNUSED);\n}\n\n/* Returns the position of block immediately before the one pointed by <pos>. If\n * the message is empty or if <pos> is the position of the head, -1 returned.\n */\nstatic inline int32_t htx_get_prev(const struct htx *htx, uint32_t pos)\n{\n\tif (htx->head == -1 || pos == htx->head)\n\t\treturn -1;\n\treturn (pos - 1);\n}\n\n/* Returns the HTX block before <blk> in the HTX message <htx>. If <blk> is the\n * head, NULL returned.\n */\nstatic inline struct htx_blk *htx_get_prev_blk(const struct htx *htx,\n\t\t\t\t\t       const struct htx_blk *blk)\n{\n\tint32_t pos;\n\n\tpos = htx_get_prev(htx, htx_get_blk_pos(htx, blk));\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}\n\n/* Returns the position of block immediately after the one pointed by <pos>. If\n * the message is empty or if <pos> is the position of the tail, -1 returned.\n */\nstatic inline int32_t htx_get_next(const struct htx *htx, uint32_t pos)\n{\n\tif (htx->tail == -1 || pos == htx->tail)\n\t\treturn -1;\n\treturn (pos + 1);\n\n}\n\n/* Returns the HTX block after <blk> in the HTX message <htx>. If <blk> is the\n * tail, NULL returned.\n */\nstatic inline struct htx_blk *htx_get_next_blk(const struct htx *htx,\n\t\t\t\t\t       const struct htx_blk *blk)\n{\n\tint32_t pos;\n\n\tpos = htx_get_next(htx, htx_get_blk_pos(htx, blk));\n\treturn ((pos == -1) ? NULL : htx_get_blk(htx, pos));\n}\n\n/* Returns 1 if <blk> is the block is the only one inside the HTX message <htx>,\n * excluding all unused blocks. Otherwise, it returns 0. If 1 is returned, this\n * means that there is only <blk> and eventually some unused ones in <htx>.\n */\nstatic inline int htx_is_unique_blk(const struct htx *htx,\n\t\t\t\t    const struct htx_blk *blk)\n{\n\treturn (htx_get_blksz(blk) == htx->data);\n}\n\n/* Changes the size of the value. It is the caller responsibility to change the\n * value itself, make sure there is enough space and update allocated\n * value. This function updates the HTX message accordingly.\n */\nstatic inline void htx_change_blk_value_len(struct htx *htx, struct htx_blk *blk, uint32_t newlen)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\tuint32_t oldlen, sz;\n\tint32_t delta;\n\n\tsz = htx_get_blksz(blk);\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\toldlen = (blk->info >> 8) & 0xfffff;\n\t\t\tblk->info = (type << 28) + (newlen << 8) + (blk->info & 0xff);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toldlen = blk->info & 0xfffffff;\n\t\t\tblk->info = (type << 28) + newlen;\n\t\t\tbreak;\n\t}\n\n\t/* Update HTTP message */\n\tdelta = (newlen - oldlen);\n\thtx->data += delta;\n\tif (blk->addr+sz == htx->tail_addr)\n\t\thtx->tail_addr += delta;\n\telse if (blk->addr+sz == htx->head_addr)\n\t\thtx->head_addr += delta;\n}\n\n/* Changes the size of the value. It is the caller responsibility to change the\n * value itself, make sure there is enough space and update allocated\n * value. Unlike the function htx_change_blk_value_len(), this one does not\n * update the HTX message. So it should be used with caution.\n */\nstatic inline void htx_set_blk_value_len(struct htx_blk *blk, uint32_t vlen)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\tblk->info = (type << 28) + (vlen << 8) + (blk->info & 0xff);\n\t\t\tbreak;\n\t\tcase HTX_BLK_REQ_SL:\n\t\tcase HTX_BLK_RES_SL:\n\t\tcase HTX_BLK_DATA:\n\t\t\tblk->info = (type << 28) + vlen;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected case */\n\t\t\tbreak;\n\t}\n}\n\n/* Returns the data pointer of the block <blk> */\nstatic inline void *htx_get_blk_ptr(const struct htx *htx, const struct htx_blk *blk)\n{\n\treturn ((void *)htx->blocks + blk->addr);\n}\n\n/* Returns the name of the block <blk>, only if it is a header or a\n * trailer. Otherwise it returns an empty string.\n */\nstatic inline struct ist htx_get_blk_name(const struct htx *htx, const struct htx_blk *blk)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\tstruct ist ret;\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\tret.ptr = htx_get_blk_ptr(htx, blk);\n\t\t\tret.len = blk->info & 0xff;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn ist(\"\");\n\t}\n\treturn ret;\n}\n\n\n/* Returns the value of the block <blk>, depending on its type. If there is no\n * value (for end-of blocks), an empty one is returned.\n */\nstatic inline struct ist htx_get_blk_value(const struct htx *htx, const struct htx_blk *blk)\n{\n\tenum htx_blk_type type = htx_get_blk_type(blk);\n\tstruct ist ret;\n\n\tswitch (type) {\n\t\tcase HTX_BLK_HDR:\n\t\tcase HTX_BLK_TLR:\n\t\t\tret.ptr = htx_get_blk_ptr(htx, blk) + (blk->info & 0xff);\n\t\t\tret.len = (blk->info >> 8) & 0xfffff;\n\t\t\tbreak;\n\n\t\tcase HTX_BLK_REQ_SL:\n\t\tcase HTX_BLK_RES_SL:\n\t\tcase HTX_BLK_DATA:\n\t\t\tret.ptr = htx_get_blk_ptr(htx, blk);\n\t\t\tret.len = blk->info & 0xfffffff;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn ist(\"\");\n\t}\n\treturn ret;\n}\n\n/* Add a new start-line. It returns it on success, otherwise it returns NULL. It\n * is the caller responsibility to set sl->info, if necessary.\n */\nstatic inline struct htx_sl *htx_add_stline(struct htx *htx, enum htx_blk_type type, unsigned int flags,\n\t\t\t\t\t    const struct ist p1, const struct ist p2, const struct ist p3)\n{\n\tstruct htx_blk *blk;\n\tstruct htx_sl  *sl;\n\tuint32_t size;\n\n\tif (type != HTX_BLK_REQ_SL && type != HTX_BLK_RES_SL)\n\t\treturn NULL;\n\n\tsize = sizeof(*sl) + p1.len + p2.len + p3.len;\n\n\tblk = htx_add_blk(htx, type, size);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += size;\n\n\tsl = htx_get_blk_ptr(htx, blk);\n\tsl->flags = flags;\n\n\tHTX_SL_P1_LEN(sl) = p1.len;\n\tHTX_SL_P2_LEN(sl) = p2.len;\n\tHTX_SL_P3_LEN(sl) = p3.len;\n\n\tmemcpy(HTX_SL_P1_PTR(sl), p1.ptr, p1.len);\n\tmemcpy(HTX_SL_P2_PTR(sl), p2.ptr, p2.len);\n\tmemcpy(HTX_SL_P3_PTR(sl), p3.ptr, p3.len);\n\n\treturn sl;\n}\n\n/* Adds an HTX block of type HDR in <htx>. It returns the new block on\n * success. Otherwise, it returns NULL. The header name is always lower cased.\n */\nstatic inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tif (name.len > 255 || value.len > 1048575)\n\t\treturn NULL;\n\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}\n\n/* Adds an HTX block of type TLR in <htx>. It returns the new block on\n * success. Otherwise, it returns NULL. The trailer name is always lower cased.\n */\nstatic inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tif (name.len > 255 || value.len > 1048575)\n\t\treturn NULL;\n\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}\n\n/* Adds an HTX block of type EOH or EOT in <htx>. It returns the new block on\n * success. Otherwise, it returns NULL.\n */\nstatic inline struct htx_blk *htx_add_endof(struct htx *htx, enum htx_blk_type type)\n{\n\tstruct htx_blk *blk;\n\n\tblk = htx_add_blk(htx, type, 1);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += 1;\n\treturn blk;\n}\n\n/* Add all headers from the list <hdrs> into the HTX message <htx>, followed by\n * the EOH. On success, it returns the last block inserted (the EOH), otherwise\n * NULL is returned. */\nstatic inline struct htx_blk *htx_add_all_headers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_header(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOH);\n}\n\n/* Add all trailers from the list <hdrs> into the HTX message <htx>, followed by\n * the EOT. On success, it returns the last block inserted (the EOT), otherwise\n * NULL is returned. */\nstatic inline struct htx_blk *htx_add_all_trailers(struct htx *htx, const struct http_hdr *hdrs)\n{\n\tint i;\n\n\tfor (i = 0; hdrs[i].n.len; i++) {\n\t\tif (!htx_add_trailer(htx, hdrs[i].n, hdrs[i].v))\n\t\t\treturn NULL;\n\t}\n\treturn htx_add_endof(htx, HTX_BLK_EOT);\n}\n\n/* Removes <n> bytes from the beginning of DATA block <blk>. The block's start\n * address and its length are adjusted, and the htx's total data count is\n * updated. This is used to mark that part of some data were transferred\n * from a DATA block without removing this DATA block. No sanity check is\n * performed, the caller is responsible for doing this exclusively on DATA\n * blocks, and never removing more than the block's size.\n */\nstatic inline void htx_cut_data_blk(struct htx *htx, struct htx_blk *blk, uint32_t n)\n{\n\tif (blk->addr == htx->end_addr)\n\t\thtx->end_addr += n;\n\tblk->addr += n;\n\tblk->info -= n;\n\thtx->data -= n;\n}\n\n/* Returns the space used by metadata in <htx>. */\nstatic inline uint32_t htx_meta_space(const struct htx *htx)\n{\n\tif (htx->tail == -1)\n\t\treturn 0;\n\n\treturn ((htx->tail + 1 - htx->head) * sizeof(struct htx_blk));\n}\n\n/* Returns the space used (payload + metadata) in <htx> */\nstatic inline uint32_t htx_used_space(const struct htx *htx)\n{\n\treturn (htx->data + htx_meta_space(htx));\n}\n\n/* Returns the free space in <htx> */\nstatic inline uint32_t htx_free_space(const struct htx *htx)\n{\n\treturn (htx->size - htx_used_space(htx));\n}\n\n/* Returns the maximum size available to store some data in <htx> if a new block\n * is reserved.\n */\nstatic inline uint32_t htx_free_data_space(const struct htx *htx)\n{\n\tuint32_t free = htx_free_space(htx);\n\n\tif (free < sizeof(struct htx_blk))\n\t\treturn 0;\n\treturn (free - sizeof(struct htx_blk));\n}\n\n/* Returns the maximum size for a block, not exceeding <max> bytes. <max> may be\n * set to -1 to have no limit.\n */\nstatic inline uint32_t htx_get_max_blksz(const struct htx *htx, int32_t max)\n{\n\tuint32_t free = htx_free_space(htx);\n\n\tif (max != -1 && free > max)\n\t\tfree = max;\n\tif (free < sizeof(struct htx_blk))\n\t\treturn 0;\n\treturn (free - sizeof(struct htx_blk));\n}\n\n/* Returns 1 if the message has less than 1/4 of its capacity free, otherwise 0 */\nstatic inline int htx_almost_full(const struct htx *htx)\n{\n\tif (!htx->size || htx_free_space(htx) < htx->size / 4)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Resets an HTX message */\nstatic inline void htx_reset(struct htx *htx)\n{\n\thtx->tail = htx->head  = htx->first = -1;\n\thtx->data = 0;\n\thtx->tail_addr = htx->head_addr = htx->end_addr = 0;\n\thtx->extra = 0;\n\thtx->flags = HTX_FL_NONE;\n}\n\n/* Returns the available room for raw data in buffer <buf> once HTX overhead is\n * taken into account (one HTX header and two blocks). The purpose is to figure\n * the optimal fill length to avoid copies.\n */\nstatic inline size_t buf_room_for_htx_data(const struct buffer *buf)\n{\n\tsize_t room;\n\n\troom = b_room(buf);\n\tif (room <= sizeof(struct htx) + 2 * sizeof(struct htx_blk))\n\t\troom = 0;\n\telse\n\t\troom -= sizeof(struct htx) + 2 * sizeof(struct htx_blk);\n\n\treturn room;\n}\n\n\n/* Returns an HTX message using the buffer <buf>. Unlike htx_from_buf(), this\n * function does not update the buffer. So if the HTX message is updated, the\n * caller must call htx_to_buf() to be sure to also update the underlying buffer\n * accordingly.  Note that it always returns a valid pointer, either to an\n * initialized buffer or to the empty buffer. This function must always be\n * called with a buffer containing an HTX message (or an empty buffer).\n */\nstatic inline struct htx *htxbuf(const struct buffer *buf)\n{\n\tstruct htx *htx;\n\n\tif (b_is_null(buf))\n\t\treturn &htx_empty;\n\thtx = ((struct htx *)(buf->area));\n\tif (!b_data(buf)) {\n\t\thtx->size = buf->size - sizeof(*htx);\n\t\thtx_reset(htx);\n\t}\n\treturn htx;\n}\n\n/* Returns an HTX message using the buffer <buf>. <buf> is updated to appear as\n * full. It should be used when you want to add something into the HTX message,\n * so the call to htx_to_buf() may be skipped. But, it is the caller\n * responsibility to call htx_to_buf() to reset <buf> if it is relevant. The\n * returned pointer is always valid. This function must always be called with a\n * buffer containing an HTX message (or an empty buffer).\n *\n * The caller can call htxbuf() function to avoid any update of the buffer.\n */\nstatic inline struct htx *htx_from_buf(struct buffer *buf)\n{\n\tstruct htx *htx = htxbuf(buf);\n\n\tb_set_data(buf, b_size(buf));\n\treturn htx;\n}\n\n/* Update <buf> accordingly to the HTX message <htx> */\nstatic inline void htx_to_buf(struct htx *htx, struct buffer *buf)\n{\n\tif ((htx->head == -1) &&\n\t    !(htx->flags & (HTX_FL_PARSING_ERROR|HTX_FL_PROCESSING_ERROR))) {\n\t\thtx_reset(htx);\n\t\tb_set_data(buf, 0);\n\t}\n\telse\n\t\tb_set_data(buf, b_size(buf));\n}\n\n/* Returns 1 if the message is empty, otherwise it returns 0. Note that it is\n * illegal to call this with htx == NULL.\n */\nstatic inline int htx_is_empty(const struct htx *htx)\n{\n\treturn (htx->head == -1);\n}\n\n/* Returns 1 if the message is not empty, otherwise it returns 0. Note that it\n * is illegal to call this with htx == NULL.\n */\nstatic inline int htx_is_not_empty(const struct htx *htx)\n{\n\treturn (htx->head != -1);\n}\n\n/* Returns 1 if no more data are expected for the message <htx>. Otherwise it\n * returns 0. Note that it is illegal to call this with htx == NULL. This\n * function relies on the HTX_FL_EOM flags. It means tunneled data are not\n * considered here.\n */\nstatic inline int htx_expect_more(const struct htx *htx)\n{\n\treturn !(htx->flags & HTX_FL_EOM);\n}\n\n/* Copy an HTX message stored in the buffer <msg> to <htx>. We take care to\n * not overwrite existing data. All the message is copied or nothing. It returns\n * 1 on success and 0 on error.\n */\nstatic inline int htx_copy_msg(struct htx *htx, const struct buffer *msg)\n{\n\t/* The destination HTX message is empty, we can do a raw copy */\n\tif (htx_is_empty(htx)) {\n\t\tmemcpy(htx, msg->area, msg->size);\n\t\treturn 1;\n\t}\n\n\t/* Otherwise, we need to append the HTX message */\n\treturn htx_append_msg(htx, htxbuf(msg));\n}\n\n/* Remove all blocks except headers. Trailers will also be removed too. */\nstatic inline void htx_skip_msg_payload(struct htx *htx)\n{\n\tstruct htx_blk *blk = htx_get_first_blk(htx);\n\n\twhile (blk) {\n\t\tenum htx_blk_type type = htx_get_blk_type(blk);\n\n\t\tblk = ((type > HTX_BLK_EOH)\n\t\t       ? htx_remove_blk(htx, blk)\n\t\t       : htx_get_next_blk(htx, blk));\n\t}\n}\n\n/* Returns the number of used blocks in the HTX message <htx>. Note that it is\n * illegal to call this function with htx == NULL. Note also blocks of type\n * HTX_BLK_UNUSED are part of used blocks.\n */\nstatic inline int htx_nbblks(const struct htx *htx)\n{\n\treturn ((htx->head != -1) ? (htx->tail + 1 - htx->head) : 0);\n}\n/* For debugging purpose */\nstatic inline const char *htx_blk_type_str(enum htx_blk_type type)\n{\n\tswitch (type) {\n\t\tcase HTX_BLK_REQ_SL: return \"HTX_BLK_REQ_SL\";\n\t\tcase HTX_BLK_RES_SL: return \"HTX_BLK_RES_SL\";\n\t\tcase HTX_BLK_HDR:    return \"HTX_BLK_HDR\";\n\t\tcase HTX_BLK_EOH:    return \"HTX_BLK_EOH\";\n\t\tcase HTX_BLK_DATA:   return \"HTX_BLK_DATA\";\n\t\tcase HTX_BLK_TLR:    return \"HTX_BLK_TLR\";\n\t\tcase HTX_BLK_EOT:    return \"HTX_BLK_EOT\";\n\t\tcase HTX_BLK_UNUSED: return \"HTX_BLK_UNUSED\";\n\t\tdefault:             return \"HTX_BLK_???\";\n\t};\n}\n\n/* For debugging purpose */\nstatic inline void htx_dump(struct buffer *chunk, const struct htx *htx, int full)\n{\n\tint32_t pos;\n\n\tchunk_appendf(chunk, \" htx=%p(size=%u,data=%u,used=%u,wrap=%s,flags=0x%08x,extra=%llu,\"\n\t\t      \"first=%d,head=%d,tail=%d,tail_addr=%d,head_addr=%d,end_addr=%d)\",\n\t\t      htx, htx->size, htx->data, htx_nbblks(htx), (!htx->head_addr) ? \"NO\" : \"YES\",\n\t\t      htx->flags, (unsigned long long)htx->extra, htx->first, htx->head, htx->tail,\n\t\t      htx->tail_addr, htx->head_addr, htx->end_addr);\n\n\tif (!full || !htx_nbblks(htx))\n\t\treturn;\n\tchunk_memcat(chunk, \"\\n\", 1);\n\n\tfor (pos = htx_get_head(htx); pos != -1; pos = htx_get_next(htx, pos)) {\n\t\tstruct htx_sl     *sl;\n\t\tstruct htx_blk    *blk  = htx_get_blk(htx, pos);\n\t\tenum htx_blk_type  type = htx_get_blk_type(blk);\n\t\tuint32_t           sz   = htx_get_blksz(blk);\n\t\tstruct ist         n, v;\n\n\t\tn = htx_get_blk_name(htx, blk);\n\t\tv = htx_get_blk_value(htx, blk);\n\n\t\tif (type == HTX_BLK_REQ_SL || type == HTX_BLK_RES_SL) {\n\t\t\tsl = htx_get_blk_ptr(htx, blk);\n\t\t\tchunk_appendf(chunk, \"\\t\\t[%u] type=%-17s - size=%-6u - addr=%-6u\\t%.*s %.*s %.*s\\n\",\n\t\t\t\t      pos, htx_blk_type_str(type), sz, blk->addr,\n\t\t\t\t      HTX_SL_P1_LEN(sl), HTX_SL_P1_PTR(sl),\n\t\t\t\t      HTX_SL_P2_LEN(sl), HTX_SL_P2_PTR(sl),\n\t\t\t\t      HTX_SL_P3_LEN(sl), HTX_SL_P3_PTR(sl));\n\t\t}\n\t\telse if (type == HTX_BLK_HDR || type == HTX_BLK_TLR)\n\t\t\tchunk_appendf(chunk, \"\\t\\t[%u] type=%-17s - size=%-6u - addr=%-6u\\t%.*s: %.*s\\n\",\n\t\t\t\t      pos, htx_blk_type_str(type), sz, blk->addr,\n\t\t\t\t      (int)MIN(n.len, 32), n.ptr,\n\t\t\t\t      (int)MIN(v.len, 64), v.ptr);\n\t\telse\n\t\t\tchunk_appendf(chunk, \"\\t\\t[%u] type=%-17s - size=%-6u - addr=%-6u%s\\n\",\n\t\t\t\t      pos, htx_blk_type_str(type), sz, blk->addr,\n\t\t\t\t      (!v.len ? \"\\t<empty>\" : \"\"));\n\t}\n}\n\n#endif /* _HAPROXY_HTX_H */\n\n/*\n * Local variables:\n *  c-indent-level: 8\n *  c-basic-offset: 8\n * End:\n */\n"], "filenames": ["include/haproxy/htx.h"], "buggy_code_start_loc": [469], "buggy_code_end_loc": [489], "fixing_code_start_loc": [469], "fixing_code_end_loc": [493], "type": "CWE-190", "message": "An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs.", "other": {"cve": {"id": "CVE-2021-40346", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-08T17:15:12.457", "lastModified": "2021-12-02T20:43:17.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An integer overflow exists in HAProxy 2.0 through 2.5 in htx_add_header that can be exploited to perform an HTTP request smuggling attack, allowing an attacker to bypass all configured http-request HAProxy ACLs and possibly other ACLs."}, {"lang": "es", "value": "Se presenta un desbordamiento de enteros en HAProxy versiones 2.0 a 2.5, en la funci\u00f3n htx_add_header() que puede ser explotada para llevar a cabo un ataque de contrabando de peticiones HTTP, permitiendo a un atacante omitir todas las ACLs configuradas de HAProxy de peticiones http y posiblemente otras ACLs"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.25", "matchCriteriaId": "2050D7B9-9E52-4564-9136-ABDB74F447A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.17", "matchCriteriaId": "4F0B3A48-87CC-490D-8C45-8BD6CCC01F80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.14", "matchCriteriaId": "677D5326-42B8-4DF5-A4C3-AEA5EBBA2164"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.4", "matchCriteriaId": "CED60B4E-A8D6-47C8-8E62-FB1E8224E51F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev0:*:*:*:*:*:*", "matchCriteriaId": "4FC0BDE1-8904-4E26-B218-9F5FFF0F6F5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev1:*:*:*:*:*:*", "matchCriteriaId": "2325B4E6-F5FE-4978-8AD7-9FDBF8D0355C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev2:*:*:*:*:*:*", "matchCriteriaId": "CD24FF4B-8E71-4111-AA2E-DC4DBC7D4961"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev3:*:*:*:*:*:*", "matchCriteriaId": "4589E520-FABF-438D-A7FB-EEDFD6EF75E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev4:*:*:*:*:*:*", "matchCriteriaId": "3F9374A2-4E60-4BD7-81B0-53A8CE8019D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev5:*:*:*:*:*:*", "matchCriteriaId": "D2291792-4194-4708-93E8-762B920B6DB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:2.5:dev6:*:*:*:*:*:*", "matchCriteriaId": "42A575A1-A115-4AE7-8FEF-40356A9B17CD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://git.haproxy.org/?p=haproxy.git", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jfrog.com/blog/critical-vulnerability-in-haproxy-cve-2021-40346-integer-overflow-enables-http-smuggling/", "source": "cve@mitre.org", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r284567dd7523f5823e2ce995f787ccd37b1cc4108779c50a97c79120@%3Cdev.cloudstack.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r8a58fd7a29808e5d27ee56877745e58dc4bb041b9af94601554e2a5a@%3Cdev.cloudstack.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A7V2IYO22LWVBGUNZWVKNTMDV4KINLFO/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MXTSBY2TEAXWZVFQM3CXHJFRONX7PEMN/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4968", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mail-archive.com/haproxy@formilux.org", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mail-archive.com/haproxy@formilux.org/msg41114.html", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/haproxy/haproxy/commit/3b69886f7dcc3cfb3d166309018e6cfec9ce2c95"}}