{"buggy_code": ["{\n    \"name\": \"posthog-js\",\n    \"version\": \"1.57.1\",\n    \"description\": \"Posthog-js allows you to automatically capture usage and send events to PostHog.\",\n    \"repository\": \"https://github.com/PostHog/posthog-js\",\n    \"author\": \"hey@posthog.com\",\n    \"license\": \"MIT\",\n    \"scripts\": {\n        \"start\": \"yarn build-rollup -w\",\n        \"build\": \"yarn build-rollup && yarn build-react\",\n        \"build-rollup\": \"yarn build:prepare-types && rollup -c\",\n        \"build-react\": \"cd react; yarn; yarn build;\",\n        \"lint\": \"eslint src\",\n        \"build:prepare-types\": \"yarn build:prepare-types:tsc && yarn build:prepare-types:copy && yarn build:prepare-types:fix && yarn build:prepare-types:rename-1 && yarn build:prepare-types:rename-2 && yarn build:prepare-types:rename-3 && yarn build:prepare-types:rename-4 && yarn build:prepare-types:rename-5 && yarn build:prepare-types:rename-6\",\n        \"build:prepare-types:tsc\": \"rm -rf lib && tsc -b\",\n        \"build:prepare-types:copy\": \"rm -rf lib/rrweb && rm -rf lib/rrweb-snapshot && cp -a node_modules/rrweb lib/rrweb; cp -a node_modules/rrweb-snapshot/typings lib/rrweb-snapshot\",\n        \"build:prepare-types:fix\": \"cd lib/rrweb/typings/replay && cat index.d.ts |grep -v 'styles/style.css' > x && mv x index.d.ts\",\n        \"build:prepare-types:rename-1\": \"cd lib/rrweb/typings/record && sed 's/rrweb-snapshot/..\\\\/..\\\\/..\\\\/rrweb-snapshot/g' iframe-manager.d.ts > x && mv x iframe-manager.d.ts\",\n        \"build:prepare-types:rename-2\": \"cd lib/rrweb/typings/replay && sed 's/rrweb-snapshot/..\\\\/..\\\\/..\\\\/rrweb-snapshot/g' virtual-styles.d.ts > x && mv x virtual-styles.d.ts\",\n        \"build:prepare-types:rename-3\": \"cd lib/rrweb/typings && sed 's/rrweb-snapshot/..\\\\/..\\\\/rrweb-snapshot/g' types.d.ts > x && mv x types.d.ts\",\n        \"build:prepare-types:rename-4\": \"cd lib/rrweb/typings && sed 's/rrweb-snapshot/..\\\\/..\\\\/rrweb-snapshot/g' utils.d.ts > x && mv x utils.d.ts\",\n        \"build:prepare-types:rename-5\": \"cd lib/src/extensions && sed 's/rrweb\\\\/typings/..\\\\/..\\\\/rrweb\\\\/typings/g' sessionrecording.d.ts > x && mv x sessionrecording.d.ts\",\n        \"build:prepare-types:rename-6\": \"cd lib/src && sed 's/rrweb-snapshot/..\\\\/rrweb-snapshot/g' types.d.ts > x && mv x types.d.ts\",\n        \"prettier\": \"prettier --write src/**/*\",\n        \"prepublishOnly\": \"yarn lint && yarn test && yarn build && yarn test-react\",\n        \"test\": \"jest src\",\n        \"test-react\": \"cd react; yarn test\",\n        \"test-watch\": \"jest --watch src\",\n        \"cypress\": \"cypress open\",\n        \"prepare\": \"husky install\"\n    },\n    \"main\": \"dist/module.js\",\n    \"module\": \"dist/es.js\",\n    \"types\": \"dist/module.d.ts\",\n    \"files\": [\n        \"lib/*\",\n        \"dist/*\",\n        \"react/dist/*\",\n        \"react/package.json\"\n    ],\n    \"dependencies\": {\n        \"fflate\": \"^0.4.1\",\n        \"rrweb-snapshot\": \"^1.1.14\"\n    },\n    \"devDependencies\": {\n        \"@babel/core\": \"7.18.9\",\n        \"@babel/preset-env\": \"7.18.9\",\n        \"@babel/preset-typescript\": \"^7.18.6\",\n        \"@rollup/plugin-babel\": \"^5.3.1\",\n        \"@rollup/plugin-json\": \"^4.1.0\",\n        \"@rollup/plugin-node-resolve\": \"^13.3.0\",\n        \"@rollup/plugin-terser\": \"^0.4.0\",\n        \"@rollup/plugin-typescript\": \"^8.3.3\",\n        \"@sentry/types\": \"7.37.2\",\n        \"@types/jest\": \"^29.5.1\",\n        \"@types/react-dom\": \"^18.0.10\",\n        \"@typescript-eslint/eslint-plugin\": \"^5.30.7\",\n        \"@typescript-eslint/parser\": \"^5.30.7\",\n        \"babel-eslint\": \"10.1.0\",\n        \"babel-jest\": \"^26.6.3\",\n        \"cypress\": \"10.3.1\",\n        \"eslint\": \"8.20.0\",\n        \"eslint-config-prettier\": \"^8.5.0\",\n        \"eslint-plugin-prettier\": \"^4.2.1\",\n        \"eslint-plugin-react\": \"^7.30.1\",\n        \"eslint-plugin-react-hooks\": \"^4.6.0\",\n        \"express\": \"^4.18.2\",\n        \"fast-check\": \"^2.17.0\",\n        \"given2\": \"^2.1.7\",\n        \"husky\": \"^8.0.1\",\n        \"jest\": \"^27.5.1\",\n        \"jsdom\": \"16.5.0\",\n        \"jsdom-global\": \"3.0.2\",\n        \"lint-staged\": \"^10.2.11\",\n        \"localStorage\": \"1.0.4\",\n        \"node-fetch\": \"^2.6.1\",\n        \"posthog-js\": \"link:.\",\n        \"prettier\": \"^2.7.1\",\n        \"rollup\": \"^2.77.0\",\n        \"rollup-plugin-dts\": \"^4.2.2\",\n        \"rrweb\": \"^1.1.3\",\n        \"rrweb2\": \"npm:rrweb@2.0.0-alpha.8\",\n        \"sinon\": \"9.0.2\",\n        \"testcafe\": \"^1.19.0\",\n        \"testcafe-browser-provider-browserstack\": \"^1.14.0\",\n        \"tslib\": \"^2.4.0\",\n        \"typescript\": \"^4.7.4\"\n    },\n    \"lint-staged\": {\n        \"*.{ts,tsx,js,json}\": \"prettier --write\",\n        \"*.js\": \"eslint src --fix\",\n        \"*.{ts,tsx}\": [\n            \"eslint src --fix\"\n        ]\n    }\n}\n", "import { Toolbar } from '../../extensions/toolbar'\nimport { loadScript } from '../../utils'\n\njest.mock('../../utils', () => ({\n    ...jest.requireActual('../../utils'),\n    loadScript: jest.fn((path, callback) => callback()),\n}))\n\ndescribe('Toolbar', () => {\n    given('toolbar', () => new Toolbar(given.lib))\n\n    given('lib', () => ({\n        get_config: jest.fn().mockImplementation((key) => given.config[key]),\n        set_config: jest.fn(),\n    }))\n\n    given('config', () => ({\n        api_host: 'http://api.example.com',\n        token: 'test_token',\n    }))\n\n    beforeEach(() => {\n        loadScript.mockImplementation((path, callback) => callback())\n        window.ph_load_toolbar = jest.fn()\n        delete window['_postHogToolbarLoaded']\n    })\n\n    describe('maybeLoadToolbar', () => {\n        given('subject', () => () => given.toolbar.maybeLoadToolbar(given.location, given.localStorage, given.history))\n\n        given('location', () => ({\n            hash: `#${given.hash}`,\n            pathname: 'pathname',\n            search: '?search',\n        }))\n\n        given('localStorage', () => ({\n            getItem: jest.fn().mockImplementation(() => given.storedEditorParams),\n            setItem: jest.fn(),\n        }))\n\n        given('history', () => ({ replaceState: jest.fn() }))\n\n        given('hash', () =>\n            Object.keys(given.hashParams)\n                .map((k) => `${k}=${given.hashParams[k]}`)\n                .join('&')\n        )\n\n        given('hashState', () => ({\n            action: 'ph_authorize',\n            desiredHash: '#myhash',\n            projectId: 3,\n            projectOwnerId: 722725,\n            readOnly: false,\n            token: 'test_token',\n            userFlags: {\n                flag_1: 0,\n                flag_2: 1,\n            },\n            userId: 12345,\n        }))\n        given('hashParams', () => ({\n            access_token: given.accessToken,\n            state: encodeURIComponent(JSON.stringify(given.hashState)),\n            expires_in: 3600,\n        }))\n\n        given('toolbarParams', () => ({\n            action: 'ph_authorize',\n            desiredHash: '#myhash',\n            projectId: 3,\n            projectOwnerId: 722725,\n            readOnly: false,\n            token: 'test_token',\n            userFlags: {\n                flag_1: 0,\n                flag_2: 1,\n            },\n            userId: 12345,\n            apiURL: given.config.api_host,\n            ...given.toolbarParamsOverrides,\n        }))\n\n        beforeEach(() => {\n            jest.spyOn(given.toolbar, 'loadToolbar').mockImplementation(() => {})\n        })\n\n        it('should initialize the toolbar when the hash state contains action \"ph_authorize\"', () => {\n            given('toolbarParamsOverrides', () => ({\n                action: 'ph_authorize',\n            }))\n\n            given.subject()\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({ ...given.toolbarParams, source: 'url' })\n        })\n\n        it('should initialize the toolbar when there are editor params in the session', () => {\n            given('storedEditorParams', () => JSON.stringify(toolbarParams))\n\n            given.subject()\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({ ...given.toolbarParams, source: 'url' })\n        })\n\n        it('should NOT initialize the toolbar when the activation query param does not exist', () => {\n            given('hash', () => '')\n\n            expect(given.subject()).toEqual(false)\n            expect(given.toolbar.loadToolbar).not.toHaveBeenCalled()\n        })\n\n        it('should return false when parsing invalid JSON from fragment state', () => {\n            given('hashParams', () => ({\n                access_token: 'test_access_token',\n                state: 'literally',\n                expires_in: 3600,\n            }))\n\n            expect(given.subject()).toEqual(false)\n            expect(given.toolbar.loadToolbar).not.toHaveBeenCalled()\n        })\n\n        it('should work if calling toolbar params `__posthog`', () => {\n            given('hashParams', () => ({\n                access_token: given.accessToken,\n                __posthog: encodeURIComponent(JSON.stringify(given.toolbarParams)),\n                expires_in: 3600,\n            }))\n\n            given.subject()\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({ ...given.toolbarParams, source: 'url' })\n        })\n\n        it('should use the apiURL in the hash if available', () => {\n            given.hashState.apiURL = 'blabla'\n\n            given.toolbar.maybeLoadToolbar(given.location, given.localStorage, given.history)\n\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({\n                ...given.toolbarParams,\n                apiURL: 'blabla',\n                source: 'url',\n            })\n        })\n    })\n\n    describe('load and close toolbar', () => {\n        given('subject', () => () => given.toolbar.loadToolbar(given.toolbarParams))\n\n        given('toolbarParams', () => ({\n            accessToken: 'accessToken',\n            token: 'public_token',\n            expiresAt: 'expiresAt',\n            apiKey: 'apiKey',\n            apiURL: 'http://localhost:8000',\n            jsURL: 'http://localhost:8000',\n        }))\n\n        it('should persist for next time', () => {\n            expect(given.subject()).toBe(true)\n            expect(JSON.parse(window.localStorage.getItem('_postHogToolbarParams'))).toEqual(given.toolbarParams)\n        })\n\n        it('should load if not previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(window.ph_load_toolbar).toHaveBeenCalledWith(given.toolbarParams, given.lib)\n        })\n\n        it('should NOT load if previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(given.subject()).toBe(false)\n        })\n    })\n\n    describe('load and close toolbar with minimal params', () => {\n        given('subject', () => () => given.toolbar.loadToolbar(given.toolbarParams))\n\n        given('toolbarParams', () => ({\n            accessToken: 'accessToken',\n        }))\n\n        it('should load if not previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(window.ph_load_toolbar).toHaveBeenCalledWith(\n                {\n                    ...given.toolbarParams,\n                    jsURL: 'http://api.example.com',\n                    apiURL: 'http://api.example.com',\n                    token: 'test_token',\n                },\n                given.lib\n            )\n        })\n\n        it('should NOT load if previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(given.subject()).toBe(false)\n        })\n    })\n})\n", "import { _getHashParam, _register_event, loadScript, logger } from '../utils'\nimport { PostHog } from '../posthog-core'\nimport { DecideResponse, ToolbarParams } from '../types'\nimport { POSTHOG_MANAGED_HOSTS } from './cloud'\n\nexport class Toolbar {\n    instance: PostHog\n    constructor(instance: PostHog) {\n        this.instance = instance\n    }\n\n    afterDecideResponse(response: DecideResponse) {\n        const toolbarParams: ToolbarParams =\n            response['toolbarParams'] ||\n            response['editorParams'] ||\n            (response['toolbarVersion'] ? { toolbarVersion: response['toolbarVersion'] } : {})\n        if (\n            response['isAuthenticated'] &&\n            toolbarParams['toolbarVersion'] &&\n            toolbarParams['toolbarVersion'].indexOf('toolbar') === 0\n        ) {\n            this.loadToolbar({\n                ...toolbarParams,\n                apiURL: this.instance.get_config('api_host'),\n            })\n        }\n    }\n\n    /**\n     * To load the toolbar, we need an access token and other state. That state comes from one of three places:\n     * 1. In the URL hash params\n     * 2. From session storage under the key `toolbarParams` if the toolbar was initialized on a previous page\n     */\n    maybeLoadToolbar(\n        location = window.location,\n        localStorage: Storage | undefined = undefined,\n        history = window.history\n    ): boolean {\n        try {\n            // Before running the code we check if we can access localStorage, if not we opt-out\n            if (!localStorage) {\n                try {\n                    window.localStorage.setItem('test', 'test')\n                    window.localStorage.removeItem('test')\n                } catch (error) {\n                    return false\n                }\n\n                // If localStorage was undefined, and localStorage is supported we set the default value\n                localStorage = window.localStorage\n            }\n\n            const stateHash = _getHashParam(location.hash, '__posthog') || _getHashParam(location.hash, 'state')\n            const state = stateHash ? JSON.parse(decodeURIComponent(stateHash)) : null\n            const parseFromUrl = state && state['action'] === 'ph_authorize'\n            let toolbarParams: ToolbarParams\n\n            if (parseFromUrl) {\n                // happens if they are initializing the toolbar using an old snippet\n                toolbarParams = state\n                toolbarParams.source = 'url'\n\n                if (toolbarParams && Object.keys(toolbarParams).length > 0) {\n                    if (state['desiredHash']) {\n                        // hash that was in the url before the redirect\n                        location.hash = state['desiredHash']\n                    } else if (history) {\n                        history.replaceState('', document.title, location.pathname + location.search) // completely remove hash\n                    } else {\n                        location.hash = '' // clear hash (but leaves # unfortunately)\n                    }\n                }\n            } else {\n                // get credentials from localStorage from a previous initialzation\n                toolbarParams = JSON.parse(localStorage.getItem('_postHogToolbarParams') || '{}')\n                toolbarParams.source = 'localstorage'\n\n                // delete \"add-action\" or other intent from toolbarParams, otherwise we'll have the same intent\n                // every time we open the page (e.g. you just visiting your own site an hour later)\n                delete toolbarParams.userIntent\n            }\n\n            if (!toolbarParams.apiURL) {\n                toolbarParams.apiURL = this.instance.get_config('api_host')\n            }\n\n            if (toolbarParams['token'] && this.instance.get_config('token') === toolbarParams['token']) {\n                this.loadToolbar(toolbarParams)\n                return true\n            } else {\n                return false\n            }\n        } catch (e) {\n            return false\n        }\n    }\n\n    loadToolbar(params?: ToolbarParams): boolean {\n        if ((window as any)['_postHogToolbarLoaded']) {\n            return false\n        }\n        // only load the toolbar once, even if there are multiple instances of PostHogLib\n        ;(window as any)['_postHogToolbarLoaded'] = true\n\n        // the toolbar does not use the `jsURL` as that route is cached for 24 hours.\n        // By design array.js, recorder.js, and toolbar.js are served from Django with no or limited caching, not from our CDN\n        // Django respects the query params for caching, returning a 304 if appropriate\n        const host = params?.['apiURL'] || this.instance.get_config('api_host')\n        const timestampToNearestThirtySeconds = Math.floor(Date.now() / 30000) * 30000\n        const toolbarUrl = `${host}${\n            host.endsWith('/') ? '' : '/'\n        }static/toolbar.js?_ts=${timestampToNearestThirtySeconds}`\n        const disableToolbarMetrics =\n            !POSTHOG_MANAGED_HOSTS.includes(this.instance.get_config('api_host')) &&\n            this.instance.get_config('advanced_disable_toolbar_metrics')\n\n        const toolbarParams = {\n            apiURL: host, // defaults to api_host from the instance config if nothing else set\n            jsURL: host, // defaults to api_host from the instance config if nothing else set\n            token: this.instance.get_config('token'),\n            ...params,\n            ...(disableToolbarMetrics ? { instrument: false } : {}),\n        }\n\n        const { source: _discard, ...paramsToPersist } = toolbarParams // eslint-disable-line\n        window.localStorage.setItem('_postHogToolbarParams', JSON.stringify(paramsToPersist))\n\n        loadScript(toolbarUrl, (err) => {\n            if (err) {\n                logger.error('Failed to load toolbar', err)\n                return\n            }\n            ;((window as any)['ph_load_toolbar'] || (window as any)['ph_load_editor'])(toolbarParams, this.instance)\n        })\n        // Turbolinks doesn't fire an onload event but does replace the entire body, including the toolbar.\n        // Thus, we ensure the toolbar is only loaded inside the body, and then reloaded on turbolinks:load.\n        _register_event(window, 'turbolinks:load', () => {\n            ;(window as any)['_postHogToolbarLoaded'] = false\n            this.loadToolbar(toolbarParams)\n        })\n        return true\n    }\n\n    /** @deprecated Use \"loadToolbar\" instead. */\n    _loadEditor(params: ToolbarParams): boolean {\n        return this.loadToolbar(params)\n    }\n\n    /** @deprecated Use \"maybeLoadToolbar\" instead. */\n    maybeLoadEditor(\n        location = window.location,\n        localStorage: Storage | undefined = undefined,\n        history = window.history\n    ): boolean {\n        return this.maybeLoadToolbar(location, localStorage, history)\n    }\n}\n", "import type { MaskInputOptions, SlimDOMOptions } from 'rrweb-snapshot'\nimport { PostHog } from './posthog-core'\nimport { CaptureMetrics } from './capture-metrics'\nimport { RetryQueue } from './retry-queue'\n\nexport type Property = any\nexport type Properties = Record<string, Property>\nexport interface CaptureResult {\n    event: string\n    properties: Properties\n    $set?: Properties\n    $set_once?: Properties\n    timestamp?: Date\n}\nexport type CaptureCallback = (response: any, data: any) => void\n\nexport type AutocaptureCompatibleElement = 'a' | 'button' | 'form' | 'input' | 'select' | 'textarea' | 'label'\nexport type DomAutocaptureEvents = 'click' | 'change' | 'submit'\n\n/**\n * If an array is passed for an allowlist, autocapture events will only be sent for elements matching\n * at least one of the elements in the array. Multiple allowlists can be used\n */\nexport interface AutocaptureConfig {\n    /**\n     * List of URLs to allow autocapture on, can be strings to match\n     * or regexes e.g. ['https://example.com', 'test.com/.*']\n     */\n    url_allowlist?: (string | RegExp)[]\n\n    /**\n     * List of DOM events to allow autocapture on  e.g. ['click', 'change', 'submit']\n     */\n    dom_event_allowlist?: DomAutocaptureEvents[]\n\n    /**\n     * List of DOM elements to allow autocapture on\n     * e.g. ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']\n     */\n    element_allowlist?: AutocaptureCompatibleElement[]\n\n    /**\n     * List of CSS selectors to allow autocapture on\n     * e.g. ['[ph-capture]']\n     */\n    css_selector_allowlist?: string[]\n}\n\nexport interface PostHogConfig {\n    api_host: string\n    api_method: string\n    api_transport: string\n    ui_host: string | null\n    token: string\n    autocapture: boolean | AutocaptureConfig\n    rageclick: boolean\n    cross_subdomain_cookie: boolean\n    persistence: 'localStorage' | 'cookie' | 'memory' | 'localStorage+cookie' | 'sessionStorage'\n    persistence_name: string\n    cookie_name: string\n    loaded: (posthog_instance: PostHog) => void\n    store_google: boolean\n    custom_campaign_params: string[]\n    save_referrer: boolean\n    test: boolean\n    verbose: boolean\n    img: boolean\n    capture_pageview: boolean\n    capture_pageleave: boolean\n    debug: boolean\n    cookie_expiration: number\n    upgrade: boolean\n    disable_session_recording: boolean\n    disable_persistence: boolean\n    disable_cookie: boolean\n    enable_recording_console_log?: boolean\n    secure_cookie: boolean\n    ip: boolean\n    opt_out_capturing_by_default: boolean\n    opt_out_persistence_by_default: boolean\n    opt_out_capturing_persistence_type: 'localStorage' | 'cookie'\n    opt_out_capturing_cookie_prefix: string | null\n    opt_in_site_apps: boolean\n    respect_dnt: boolean\n    property_blacklist: string[]\n    xhr_headers: { [header_name: string]: string }\n    on_xhr_error: (failedRequest: XMLHttpRequest) => void\n    inapp_protocol: string\n    inapp_link_new_window: boolean\n    request_batching: boolean\n    sanitize_properties: ((properties: Properties, event_name: string) => Properties) | null\n    properties_string_max_length: number\n    session_recording: SessionRecordingOptions\n    mask_all_element_attributes: boolean\n    mask_all_text: boolean\n    advanced_disable_decide: boolean\n    advanced_disable_toolbar_metrics: boolean\n    get_device_id: (uuid: string) => string\n    name: string\n    callback_fn: string\n    _onCapture: (eventName: string, eventData: CaptureResult) => void\n    _capture_metrics: boolean\n    capture_performance?: boolean\n    // Should only be used for testing. Could negatively impact performance.\n    disable_compression: boolean\n    bootstrap: {\n        distinctID?: string\n        isIdentifiedID?: boolean\n        featureFlags?: Record<string, boolean | string>\n        featureFlagPayloads?: Record<string, JsonType>\n    }\n    segment?: any\n}\n\nexport interface OptInOutCapturingOptions {\n    capture: (event: string, properties: Properties, options: CaptureOptions) => void\n    capture_event_name: string\n    capture_properties: Properties\n    enable_persistence: boolean\n    clear_persistence: boolean\n    persistence_type: 'cookie' | 'localStorage' | 'localStorage+cookie'\n    cookie_prefix: string\n    cookie_expiration: number\n    cross_subdomain_cookie: boolean\n    secure_cookie: boolean\n}\n\nexport interface isFeatureEnabledOptions {\n    send_event: boolean\n}\n\nexport interface SessionRecordingOptions {\n    blockClass?: string | RegExp\n    blockSelector?: string | null\n    ignoreClass?: string\n    maskTextClass?: string | RegExp\n    maskTextSelector?: string | null\n    maskAllInputs?: boolean\n    maskInputOptions?: MaskInputOptions\n    maskInputFn?: ((text: string, element?: HTMLElement) => string) | null\n    /** Modify the network request before it is captured. Returning null stops it being captured */\n    maskNetworkRequestFn?: ((url: NetworkRequest) => NetworkRequest | null | undefined) | null\n    slimDOMOptions?: SlimDOMOptions | 'all' | true\n    collectFonts?: boolean\n    inlineStylesheet?: boolean\n    recorderVersion?: 'v1' | 'v2'\n}\n\nexport enum Compression {\n    GZipJS = 'gzip-js',\n    LZ64 = 'lz64',\n    Base64 = 'base64',\n}\n\nexport interface XHROptions {\n    transport?: 'XHR' | 'sendBeacon'\n    method?: 'POST' | 'GET'\n    urlQueryArgs?: { compression: Compression }\n    verbose?: boolean\n    blob?: boolean\n    sendBeacon?: boolean\n}\n\nexport interface CaptureOptions extends XHROptions {\n    $set?: Properties /** used with $identify */\n    $set_once?: Properties /** used with $identify */\n    _batchKey?: string /** key of queue, e.g. 'sessionRecording' vs 'event' */\n    _metrics?: Properties\n    _noTruncate?: boolean /** if set, overrides and disables config.properties_string_max_length */\n    endpoint?: string /** defaults to '/e/' */\n    send_instantly?: boolean /** if set skips the batched queue */\n    timestamp?: Date\n}\n\nexport interface RetryQueueElement {\n    retryAt: Date\n    requestData: QueuedRequestData\n}\nexport interface QueuedRequestData {\n    url: string\n    data: Properties\n    options: CaptureOptions\n    headers?: Properties\n    callback?: RequestCallback\n    retriesPerformedSoFar?: number\n}\n\nexport interface XHRParams extends QueuedRequestData {\n    captureMetrics: CaptureMetrics\n    retryQueue: RetryQueue\n    onXHRError: (req: XMLHttpRequest) => void\n    timeout?: number\n}\n\nexport interface DecideResponse {\n    status: number\n    supportedCompression: Compression[]\n    config: {\n        enable_collect_everything: boolean\n    }\n    custom_properties: AutoCaptureCustomProperty[] // TODO: delete, not sent\n    featureFlags: Record<string, string | boolean>\n    featureFlagPayloads: Record<string, JsonType>\n    errorsWhileComputingFlags: boolean\n    autocapture_opt_out?: boolean\n    capturePerformance?: boolean\n    sessionRecording?: {\n        endpoint?: string\n        consoleLogRecordingEnabled?: boolean\n        recorderVersion?: 'v1' | 'v2'\n    }\n    toolbarParams: ToolbarParams\n    editorParams?: ToolbarParams /** @deprecated, renamed to toolbarParams, still present on older API responses */\n    toolbarVersion: 'toolbar' /** @deprecated, moved to toolbarParams */\n    isAuthenticated: boolean\n    siteApps: { id: number; url: string }[]\n}\n\nexport type FeatureFlagsCallback = (flags: string[], variants: Record<string, string | boolean>) => void\n\n// TODO: delete custom_properties after changeless typescript refactor\nexport interface AutoCaptureCustomProperty {\n    name: string\n    css_selector: string\n    event_selectors: string[]\n}\n\nexport interface CompressionData {\n    data: string\n    compression?: Compression\n}\n\nexport interface GDPROptions {\n    capture?: (\n        event: string,\n        properties: Properties,\n        options: CaptureOptions\n    ) => void /** function used for capturing a PostHog event to record the opt-in action */\n    captureEventName?: string /** event name to be used for capturing the opt-in action */\n    captureProperties?: Properties /** set of properties to be captured along with the opt-in action */\n    /** persistence mechanism used */\n    persistenceType?: 'cookie' | 'localStorage' | 'localStorage+cookie'\n    persistencePrefix?: string /** [__ph_opt_in_out] - custom prefix to be used in the cookie/localstorage name */\n    cookieExpiration?: number /** number of days until the opt-in cookie expires */\n    crossSubdomainCookie?: boolean /** whether the opt-in cookie is set as cross-subdomain or not */\n    secureCookie?: boolean /** whether the opt-in cookie is set as secure or not */\n    respectDnt?: boolean\n    window?: Window\n}\n\nexport type RequestCallback = (response: Record<string, any>, data?: Properties) => void\n\nexport interface PersistentStore {\n    is_supported: () => boolean\n    error: (error: any) => void\n    parse: (name: string) => any\n    get: (name: string) => any\n    set: (name: string, value: any, expire_days?: number | null, cross_subdomain?: boolean, secure?: boolean) => void\n    remove: (name: string, cross_subdomain?: boolean) => void\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Breaker = {}\nexport type EventHandler = (event: Event) => boolean | void\n\nexport type ToolbarUserIntent = 'add-action' | 'edit-action'\nexport type ToolbarSource = 'url' | 'localstorage'\nexport type ToolbarVersion = 'toolbar'\n\n/* sync with posthog */\nexport interface ToolbarParams {\n    apiURL?: string\n    jsURL?: string\n    token?: string /** public posthog-js token */\n    temporaryToken?: string /** private temporary user token */\n    actionId?: number\n    userIntent?: ToolbarUserIntent\n    source?: ToolbarSource\n    toolbarVersion?: ToolbarVersion\n    instrument?: boolean\n    distinctId?: string\n    userEmail?: string\n    dataAttributes?: string[]\n    featureFlags?: Record<string, string | boolean>\n}\n\nexport interface PostData {\n    buffer?: BlobPart\n    compression?: Compression\n    data?: string\n}\n\nexport interface JSC {\n    (): void\n    [key: string]: (response: any) => void\n}\n\nexport type SnippetArrayItem = [method: string, ...args: any[]]\n\nexport type JsonType = string | number | boolean | null | { [key: string]: JsonType } | Array<JsonType>\n\n/** A feature that isn't publicly available yet.*/\nexport interface EarlyAccessFeature {\n    // Sync this with the backend's EarlyAccessFeatureSerializer!\n    name: string\n    description: string\n    stage: 'concept' | 'alpha' | 'beta'\n    documentationUrl: string | null\n    flagKey: string | null\n}\n\nexport type EarlyAccessFeatureCallback = (earlyAccessFeatures: EarlyAccessFeature[]) => void\n\nexport interface EarlyAccessFeatureResponse {\n    earlyAccessFeatures: EarlyAccessFeature[]\n}\n\nexport type NetworkRequest = {\n    url: string\n}\n"], "fixing_code": ["{\n    \"name\": \"posthog-js\",\n    \"version\": \"1.57.2-alpha.0\",\n    \"description\": \"Posthog-js allows you to automatically capture usage and send events to PostHog.\",\n    \"repository\": \"https://github.com/PostHog/posthog-js\",\n    \"author\": \"hey@posthog.com\",\n    \"license\": \"MIT\",\n    \"scripts\": {\n        \"start\": \"yarn build-rollup -w\",\n        \"build\": \"yarn build-rollup && yarn build-react\",\n        \"build-rollup\": \"yarn build:prepare-types && rollup -c\",\n        \"build-react\": \"cd react; yarn; yarn build;\",\n        \"lint\": \"eslint src\",\n        \"build:prepare-types\": \"yarn build:prepare-types:tsc && yarn build:prepare-types:copy && yarn build:prepare-types:fix && yarn build:prepare-types:rename-1 && yarn build:prepare-types:rename-2 && yarn build:prepare-types:rename-3 && yarn build:prepare-types:rename-4 && yarn build:prepare-types:rename-5 && yarn build:prepare-types:rename-6\",\n        \"build:prepare-types:tsc\": \"rm -rf lib && tsc -b\",\n        \"build:prepare-types:copy\": \"rm -rf lib/rrweb && rm -rf lib/rrweb-snapshot && cp -a node_modules/rrweb lib/rrweb; cp -a node_modules/rrweb-snapshot/typings lib/rrweb-snapshot\",\n        \"build:prepare-types:fix\": \"cd lib/rrweb/typings/replay && cat index.d.ts |grep -v 'styles/style.css' > x && mv x index.d.ts\",\n        \"build:prepare-types:rename-1\": \"cd lib/rrweb/typings/record && sed 's/rrweb-snapshot/..\\\\/..\\\\/..\\\\/rrweb-snapshot/g' iframe-manager.d.ts > x && mv x iframe-manager.d.ts\",\n        \"build:prepare-types:rename-2\": \"cd lib/rrweb/typings/replay && sed 's/rrweb-snapshot/..\\\\/..\\\\/..\\\\/rrweb-snapshot/g' virtual-styles.d.ts > x && mv x virtual-styles.d.ts\",\n        \"build:prepare-types:rename-3\": \"cd lib/rrweb/typings && sed 's/rrweb-snapshot/..\\\\/..\\\\/rrweb-snapshot/g' types.d.ts > x && mv x types.d.ts\",\n        \"build:prepare-types:rename-4\": \"cd lib/rrweb/typings && sed 's/rrweb-snapshot/..\\\\/..\\\\/rrweb-snapshot/g' utils.d.ts > x && mv x utils.d.ts\",\n        \"build:prepare-types:rename-5\": \"cd lib/src/extensions && sed 's/rrweb\\\\/typings/..\\\\/..\\\\/rrweb\\\\/typings/g' sessionrecording.d.ts > x && mv x sessionrecording.d.ts\",\n        \"build:prepare-types:rename-6\": \"cd lib/src && sed 's/rrweb-snapshot/..\\\\/rrweb-snapshot/g' types.d.ts > x && mv x types.d.ts\",\n        \"prettier\": \"prettier --write src/**/*\",\n        \"prepublishOnly\": \"yarn lint && yarn test && yarn build && yarn test-react\",\n        \"test\": \"jest src\",\n        \"test-react\": \"cd react; yarn test\",\n        \"test-watch\": \"jest --watch src\",\n        \"cypress\": \"cypress open\",\n        \"prepare\": \"husky install\"\n    },\n    \"main\": \"dist/module.js\",\n    \"module\": \"dist/es.js\",\n    \"types\": \"dist/module.d.ts\",\n    \"files\": [\n        \"lib/*\",\n        \"dist/*\",\n        \"react/dist/*\",\n        \"react/package.json\"\n    ],\n    \"dependencies\": {\n        \"fflate\": \"^0.4.1\",\n        \"rrweb-snapshot\": \"^1.1.14\"\n    },\n    \"devDependencies\": {\n        \"@babel/core\": \"7.18.9\",\n        \"@babel/preset-env\": \"7.18.9\",\n        \"@babel/preset-typescript\": \"^7.18.6\",\n        \"@rollup/plugin-babel\": \"^5.3.1\",\n        \"@rollup/plugin-json\": \"^4.1.0\",\n        \"@rollup/plugin-node-resolve\": \"^13.3.0\",\n        \"@rollup/plugin-terser\": \"^0.4.0\",\n        \"@rollup/plugin-typescript\": \"^8.3.3\",\n        \"@sentry/types\": \"7.37.2\",\n        \"@types/jest\": \"^29.5.1\",\n        \"@types/react-dom\": \"^18.0.10\",\n        \"@typescript-eslint/eslint-plugin\": \"^5.30.7\",\n        \"@typescript-eslint/parser\": \"^5.30.7\",\n        \"babel-eslint\": \"10.1.0\",\n        \"babel-jest\": \"^26.6.3\",\n        \"cypress\": \"10.3.1\",\n        \"eslint\": \"8.20.0\",\n        \"eslint-config-prettier\": \"^8.5.0\",\n        \"eslint-plugin-prettier\": \"^4.2.1\",\n        \"eslint-plugin-react\": \"^7.30.1\",\n        \"eslint-plugin-react-hooks\": \"^4.6.0\",\n        \"express\": \"^4.18.2\",\n        \"fast-check\": \"^2.17.0\",\n        \"given2\": \"^2.1.7\",\n        \"husky\": \"^8.0.1\",\n        \"jest\": \"^27.5.1\",\n        \"jsdom\": \"16.5.0\",\n        \"jsdom-global\": \"3.0.2\",\n        \"lint-staged\": \"^10.2.11\",\n        \"localStorage\": \"1.0.4\",\n        \"node-fetch\": \"^2.6.1\",\n        \"posthog-js\": \"link:.\",\n        \"prettier\": \"^2.7.1\",\n        \"rollup\": \"^2.77.0\",\n        \"rollup-plugin-dts\": \"^4.2.2\",\n        \"rrweb\": \"^1.1.3\",\n        \"rrweb2\": \"npm:rrweb@2.0.0-alpha.8\",\n        \"sinon\": \"9.0.2\",\n        \"testcafe\": \"^1.19.0\",\n        \"testcafe-browser-provider-browserstack\": \"^1.14.0\",\n        \"tslib\": \"^2.4.0\",\n        \"typescript\": \"^4.7.4\"\n    },\n    \"lint-staged\": {\n        \"*.{ts,tsx,js,json}\": \"prettier --write\",\n        \"*.js\": \"eslint src --fix\",\n        \"*.{ts,tsx}\": [\n            \"eslint src --fix\"\n        ]\n    }\n}\n", "import { Toolbar } from '../../extensions/toolbar'\nimport { loadScript } from '../../utils'\n\njest.mock('../../utils', () => ({\n    ...jest.requireActual('../../utils'),\n    loadScript: jest.fn((path, callback) => callback()),\n}))\n\ndescribe('Toolbar', () => {\n    given('toolbar', () => new Toolbar(given.lib))\n\n    given('lib', () => ({\n        get_config: jest.fn().mockImplementation((key) => given.config[key]),\n        set_config: jest.fn(),\n    }))\n\n    given('config', () => ({\n        api_host: 'http://api.example.com',\n        token: 'test_token',\n    }))\n\n    beforeEach(() => {\n        loadScript.mockImplementation((path, callback) => callback())\n        window.ph_load_toolbar = jest.fn()\n        delete window['_postHogToolbarLoaded']\n    })\n\n    describe('maybeLoadToolbar', () => {\n        given('subject', () => () => given.toolbar.maybeLoadToolbar(given.location, given.localStorage, given.history))\n\n        given('location', () => ({\n            hash: `#${given.hash}`,\n            pathname: 'pathname',\n            search: '?search',\n        }))\n\n        given('localStorage', () => ({\n            getItem: jest.fn().mockImplementation(() => given.storedEditorParams),\n            setItem: jest.fn(),\n        }))\n\n        given('history', () => ({ replaceState: jest.fn() }))\n\n        given('hash', () =>\n            Object.keys(given.hashParams)\n                .map((k) => `${k}=${given.hashParams[k]}`)\n                .join('&')\n        )\n\n        given('hashState', () => ({\n            action: 'ph_authorize',\n            desiredHash: '#myhash',\n            projectId: 3,\n            projectOwnerId: 722725,\n            readOnly: false,\n            token: 'test_token',\n            userFlags: {\n                flag_1: 0,\n                flag_2: 1,\n            },\n            userId: 12345,\n        }))\n        given('hashParams', () => ({\n            access_token: given.accessToken,\n            state: encodeURIComponent(JSON.stringify(given.hashState)),\n            expires_in: 3600,\n        }))\n\n        given('toolbarParams', () => ({\n            action: 'ph_authorize',\n            desiredHash: '#myhash',\n            projectId: 3,\n            projectOwnerId: 722725,\n            readOnly: false,\n            token: 'test_token',\n            userFlags: {\n                flag_1: 0,\n                flag_2: 1,\n            },\n            userId: 12345,\n            ...given.toolbarParamsOverrides,\n        }))\n\n        beforeEach(() => {\n            jest.spyOn(given.toolbar, 'loadToolbar').mockImplementation(() => {})\n        })\n\n        it('should initialize the toolbar when the hash state contains action \"ph_authorize\"', () => {\n            given('toolbarParamsOverrides', () => ({\n                action: 'ph_authorize',\n            }))\n\n            given.subject()\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({\n                ...given.toolbarParams,\n                source: 'url',\n            })\n        })\n\n        it('should initialize the toolbar when there are editor params in the session', () => {\n            given('storedEditorParams', () => JSON.stringify(toolbarParams))\n\n            given.subject()\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({\n                ...given.toolbarParams,\n                source: 'url',\n            })\n        })\n\n        it('should NOT initialize the toolbar when the activation query param does not exist', () => {\n            given('hash', () => '')\n\n            expect(given.subject()).toEqual(false)\n            expect(given.toolbar.loadToolbar).not.toHaveBeenCalled()\n        })\n\n        it('should return false when parsing invalid JSON from fragment state', () => {\n            given('hashParams', () => ({\n                access_token: 'test_access_token',\n                state: 'literally',\n                expires_in: 3600,\n            }))\n\n            expect(given.subject()).toEqual(false)\n            expect(given.toolbar.loadToolbar).not.toHaveBeenCalled()\n        })\n\n        it('should work if calling toolbar params `__posthog`', () => {\n            given('hashParams', () => ({\n                access_token: given.accessToken,\n                __posthog: encodeURIComponent(JSON.stringify(given.toolbarParams)),\n                expires_in: 3600,\n            }))\n\n            given.subject()\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({ ...given.toolbarParams, source: 'url' })\n        })\n\n        it('should use the apiURL in the hash if available', () => {\n            given.hashState.apiURL = 'blabla'\n\n            given.toolbar.maybeLoadToolbar(given.location, given.localStorage, given.history)\n\n            expect(given.toolbar.loadToolbar).toHaveBeenCalledWith({\n                ...given.toolbarParams,\n                apiURL: 'blabla',\n                source: 'url',\n            })\n        })\n    })\n\n    describe('load and close toolbar', () => {\n        given('subject', () => () => given.toolbar.loadToolbar(given.toolbarParams))\n\n        given('toolbarParams', () => ({\n            accessToken: 'accessToken',\n            token: 'public_token',\n            expiresAt: 'expiresAt',\n            apiKey: 'apiKey',\n        }))\n\n        it('should persist for next time', () => {\n            expect(given.subject()).toBe(true)\n            expect(JSON.parse(window.localStorage.getItem('_postHogToolbarParams'))).toEqual({\n                ...given.toolbarParams,\n                apiURL: 'http://api.example.com',\n            })\n        })\n\n        it('should load if not previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(window.ph_load_toolbar).toHaveBeenCalledWith(\n                { ...given.toolbarParams, apiURL: 'http://api.example.com' },\n                given.lib\n            )\n        })\n\n        it('should NOT load if previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(given.subject()).toBe(false)\n        })\n    })\n\n    describe('load and close toolbar with minimal params', () => {\n        given('subject', () => () => given.toolbar.loadToolbar(given.toolbarParams))\n\n        given('toolbarParams', () => ({\n            accessToken: 'accessToken',\n        }))\n\n        it('should load if not previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(window.ph_load_toolbar).toHaveBeenCalledWith(\n                {\n                    ...given.toolbarParams,\n                    apiURL: 'http://api.example.com',\n                    token: 'test_token',\n                },\n                given.lib\n            )\n        })\n\n        it('should NOT load if previously loaded', () => {\n            expect(given.subject()).toBe(true)\n            expect(given.subject()).toBe(false)\n        })\n    })\n})\n", "import { _getHashParam, _register_event, loadScript, logger } from '../utils'\nimport { PostHog } from '../posthog-core'\nimport { DecideResponse, ToolbarParams } from '../types'\nimport { POSTHOG_MANAGED_HOSTS } from './cloud'\n\nexport class Toolbar {\n    instance: PostHog\n    constructor(instance: PostHog) {\n        this.instance = instance\n    }\n\n    afterDecideResponse(response: DecideResponse) {\n        const toolbarParams: ToolbarParams =\n            response['toolbarParams'] ||\n            response['editorParams'] ||\n            (response['toolbarVersion'] ? { toolbarVersion: response['toolbarVersion'] } : {})\n        if (\n            response['isAuthenticated'] &&\n            toolbarParams['toolbarVersion'] &&\n            toolbarParams['toolbarVersion'].indexOf('toolbar') === 0\n        ) {\n            this.loadToolbar({\n                ...toolbarParams,\n            })\n        }\n    }\n\n    /**\n     * To load the toolbar, we need an access token and other state. That state comes from one of three places:\n     * 1. In the URL hash params\n     * 2. From session storage under the key `toolbarParams` if the toolbar was initialized on a previous page\n     */\n    maybeLoadToolbar(\n        location = window.location,\n        localStorage: Storage | undefined = undefined,\n        history = window.history\n    ): boolean {\n        try {\n            // Before running the code we check if we can access localStorage, if not we opt-out\n            if (!localStorage) {\n                try {\n                    window.localStorage.setItem('test', 'test')\n                    window.localStorage.removeItem('test')\n                } catch (error) {\n                    return false\n                }\n\n                // If localStorage was undefined, and localStorage is supported we set the default value\n                localStorage = window.localStorage\n            }\n\n            const stateHash = _getHashParam(location.hash, '__posthog') || _getHashParam(location.hash, 'state')\n            const state = stateHash ? JSON.parse(decodeURIComponent(stateHash)) : null\n            const parseFromUrl = state && state['action'] === 'ph_authorize'\n            let toolbarParams: ToolbarParams\n\n            if (parseFromUrl) {\n                // happens if they are initializing the toolbar using an old snippet\n                toolbarParams = state\n                toolbarParams.source = 'url'\n\n                if (toolbarParams && Object.keys(toolbarParams).length > 0) {\n                    if (state['desiredHash']) {\n                        // hash that was in the url before the redirect\n                        location.hash = state['desiredHash']\n                    } else if (history) {\n                        history.replaceState('', document.title, location.pathname + location.search) // completely remove hash\n                    } else {\n                        location.hash = '' // clear hash (but leaves # unfortunately)\n                    }\n                }\n            } else {\n                // get credentials from localStorage from a previous initialzation\n                toolbarParams = JSON.parse(localStorage.getItem('_postHogToolbarParams') || '{}')\n                toolbarParams.source = 'localstorage'\n\n                // delete \"add-action\" or other intent from toolbarParams, otherwise we'll have the same intent\n                // every time we open the page (e.g. you just visiting your own site an hour later)\n                delete toolbarParams.userIntent\n            }\n\n            if (toolbarParams['token'] && this.instance.get_config('token') === toolbarParams['token']) {\n                this.loadToolbar(toolbarParams)\n                return true\n            } else {\n                return false\n            }\n        } catch (e) {\n            return false\n        }\n    }\n\n    loadToolbar(params?: ToolbarParams): boolean {\n        if ((window as any)['_postHogToolbarLoaded']) {\n            return false\n        }\n        // only load the toolbar once, even if there are multiple instances of PostHogLib\n        ;(window as any)['_postHogToolbarLoaded'] = true\n\n        // By design array.js, recorder.js, and toolbar.js are served from Django with no or limited caching, not from our CDN\n        // Django respects the query params for caching, returning a 304 if appropriate\n        const host = this.instance.get_config('api_host')\n        const timestampToNearestThirtySeconds = Math.floor(Date.now() / 30000) * 30000\n        const toolbarUrl = `${host}${\n            host.endsWith('/') ? '' : '/'\n        }static/toolbar.js?_ts=${timestampToNearestThirtySeconds}`\n        const disableToolbarMetrics =\n            !POSTHOG_MANAGED_HOSTS.includes(this.instance.get_config('api_host')) &&\n            this.instance.get_config('advanced_disable_toolbar_metrics')\n\n        const toolbarParams = {\n            token: this.instance.get_config('token'),\n            ...params,\n            apiURL: host, // defaults to api_host from the instance config if nothing else set\n            ...(disableToolbarMetrics ? { instrument: false } : {}),\n        }\n\n        const { source: _discard, ...paramsToPersist } = toolbarParams // eslint-disable-line\n        window.localStorage.setItem('_postHogToolbarParams', JSON.stringify(paramsToPersist))\n\n        loadScript(toolbarUrl, (err) => {\n            if (err) {\n                logger.error('Failed to load toolbar', err)\n                return\n            }\n            ;((window as any)['ph_load_toolbar'] || (window as any)['ph_load_editor'])(toolbarParams, this.instance)\n        })\n        // Turbolinks doesn't fire an onload event but does replace the entire body, including the toolbar.\n        // Thus, we ensure the toolbar is only loaded inside the body, and then reloaded on turbolinks:load.\n        _register_event(window, 'turbolinks:load', () => {\n            ;(window as any)['_postHogToolbarLoaded'] = false\n            this.loadToolbar(toolbarParams)\n        })\n        return true\n    }\n\n    /** @deprecated Use \"loadToolbar\" instead. */\n    _loadEditor(params: ToolbarParams): boolean {\n        return this.loadToolbar(params)\n    }\n\n    /** @deprecated Use \"maybeLoadToolbar\" instead. */\n    maybeLoadEditor(\n        location = window.location,\n        localStorage: Storage | undefined = undefined,\n        history = window.history\n    ): boolean {\n        return this.maybeLoadToolbar(location, localStorage, history)\n    }\n}\n", "import type { MaskInputOptions, SlimDOMOptions } from 'rrweb-snapshot'\nimport { PostHog } from './posthog-core'\nimport { CaptureMetrics } from './capture-metrics'\nimport { RetryQueue } from './retry-queue'\n\nexport type Property = any\nexport type Properties = Record<string, Property>\nexport interface CaptureResult {\n    event: string\n    properties: Properties\n    $set?: Properties\n    $set_once?: Properties\n    timestamp?: Date\n}\nexport type CaptureCallback = (response: any, data: any) => void\n\nexport type AutocaptureCompatibleElement = 'a' | 'button' | 'form' | 'input' | 'select' | 'textarea' | 'label'\nexport type DomAutocaptureEvents = 'click' | 'change' | 'submit'\n\n/**\n * If an array is passed for an allowlist, autocapture events will only be sent for elements matching\n * at least one of the elements in the array. Multiple allowlists can be used\n */\nexport interface AutocaptureConfig {\n    /**\n     * List of URLs to allow autocapture on, can be strings to match\n     * or regexes e.g. ['https://example.com', 'test.com/.*']\n     */\n    url_allowlist?: (string | RegExp)[]\n\n    /**\n     * List of DOM events to allow autocapture on  e.g. ['click', 'change', 'submit']\n     */\n    dom_event_allowlist?: DomAutocaptureEvents[]\n\n    /**\n     * List of DOM elements to allow autocapture on\n     * e.g. ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']\n     */\n    element_allowlist?: AutocaptureCompatibleElement[]\n\n    /**\n     * List of CSS selectors to allow autocapture on\n     * e.g. ['[ph-capture]']\n     */\n    css_selector_allowlist?: string[]\n}\n\nexport interface PostHogConfig {\n    api_host: string\n    api_method: string\n    api_transport: string\n    ui_host: string | null\n    token: string\n    autocapture: boolean | AutocaptureConfig\n    rageclick: boolean\n    cross_subdomain_cookie: boolean\n    persistence: 'localStorage' | 'cookie' | 'memory' | 'localStorage+cookie' | 'sessionStorage'\n    persistence_name: string\n    cookie_name: string\n    loaded: (posthog_instance: PostHog) => void\n    store_google: boolean\n    custom_campaign_params: string[]\n    save_referrer: boolean\n    test: boolean\n    verbose: boolean\n    img: boolean\n    capture_pageview: boolean\n    capture_pageleave: boolean\n    debug: boolean\n    cookie_expiration: number\n    upgrade: boolean\n    disable_session_recording: boolean\n    disable_persistence: boolean\n    disable_cookie: boolean\n    enable_recording_console_log?: boolean\n    secure_cookie: boolean\n    ip: boolean\n    opt_out_capturing_by_default: boolean\n    opt_out_persistence_by_default: boolean\n    opt_out_capturing_persistence_type: 'localStorage' | 'cookie'\n    opt_out_capturing_cookie_prefix: string | null\n    opt_in_site_apps: boolean\n    respect_dnt: boolean\n    property_blacklist: string[]\n    xhr_headers: { [header_name: string]: string }\n    on_xhr_error: (failedRequest: XMLHttpRequest) => void\n    inapp_protocol: string\n    inapp_link_new_window: boolean\n    request_batching: boolean\n    sanitize_properties: ((properties: Properties, event_name: string) => Properties) | null\n    properties_string_max_length: number\n    session_recording: SessionRecordingOptions\n    mask_all_element_attributes: boolean\n    mask_all_text: boolean\n    advanced_disable_decide: boolean\n    advanced_disable_toolbar_metrics: boolean\n    get_device_id: (uuid: string) => string\n    name: string\n    callback_fn: string\n    _onCapture: (eventName: string, eventData: CaptureResult) => void\n    _capture_metrics: boolean\n    capture_performance?: boolean\n    // Should only be used for testing. Could negatively impact performance.\n    disable_compression: boolean\n    bootstrap: {\n        distinctID?: string\n        isIdentifiedID?: boolean\n        featureFlags?: Record<string, boolean | string>\n        featureFlagPayloads?: Record<string, JsonType>\n    }\n    segment?: any\n}\n\nexport interface OptInOutCapturingOptions {\n    capture: (event: string, properties: Properties, options: CaptureOptions) => void\n    capture_event_name: string\n    capture_properties: Properties\n    enable_persistence: boolean\n    clear_persistence: boolean\n    persistence_type: 'cookie' | 'localStorage' | 'localStorage+cookie'\n    cookie_prefix: string\n    cookie_expiration: number\n    cross_subdomain_cookie: boolean\n    secure_cookie: boolean\n}\n\nexport interface isFeatureEnabledOptions {\n    send_event: boolean\n}\n\nexport interface SessionRecordingOptions {\n    blockClass?: string | RegExp\n    blockSelector?: string | null\n    ignoreClass?: string\n    maskTextClass?: string | RegExp\n    maskTextSelector?: string | null\n    maskAllInputs?: boolean\n    maskInputOptions?: MaskInputOptions\n    maskInputFn?: ((text: string, element?: HTMLElement) => string) | null\n    /** Modify the network request before it is captured. Returning null stops it being captured */\n    maskNetworkRequestFn?: ((url: NetworkRequest) => NetworkRequest | null | undefined) | null\n    slimDOMOptions?: SlimDOMOptions | 'all' | true\n    collectFonts?: boolean\n    inlineStylesheet?: boolean\n    recorderVersion?: 'v1' | 'v2'\n}\n\nexport enum Compression {\n    GZipJS = 'gzip-js',\n    LZ64 = 'lz64',\n    Base64 = 'base64',\n}\n\nexport interface XHROptions {\n    transport?: 'XHR' | 'sendBeacon'\n    method?: 'POST' | 'GET'\n    urlQueryArgs?: { compression: Compression }\n    verbose?: boolean\n    blob?: boolean\n    sendBeacon?: boolean\n}\n\nexport interface CaptureOptions extends XHROptions {\n    $set?: Properties /** used with $identify */\n    $set_once?: Properties /** used with $identify */\n    _batchKey?: string /** key of queue, e.g. 'sessionRecording' vs 'event' */\n    _metrics?: Properties\n    _noTruncate?: boolean /** if set, overrides and disables config.properties_string_max_length */\n    endpoint?: string /** defaults to '/e/' */\n    send_instantly?: boolean /** if set skips the batched queue */\n    timestamp?: Date\n}\n\nexport interface RetryQueueElement {\n    retryAt: Date\n    requestData: QueuedRequestData\n}\nexport interface QueuedRequestData {\n    url: string\n    data: Properties\n    options: CaptureOptions\n    headers?: Properties\n    callback?: RequestCallback\n    retriesPerformedSoFar?: number\n}\n\nexport interface XHRParams extends QueuedRequestData {\n    captureMetrics: CaptureMetrics\n    retryQueue: RetryQueue\n    onXHRError: (req: XMLHttpRequest) => void\n    timeout?: number\n}\n\nexport interface DecideResponse {\n    status: number\n    supportedCompression: Compression[]\n    config: {\n        enable_collect_everything: boolean\n    }\n    custom_properties: AutoCaptureCustomProperty[] // TODO: delete, not sent\n    featureFlags: Record<string, string | boolean>\n    featureFlagPayloads: Record<string, JsonType>\n    errorsWhileComputingFlags: boolean\n    autocapture_opt_out?: boolean\n    capturePerformance?: boolean\n    sessionRecording?: {\n        endpoint?: string\n        consoleLogRecordingEnabled?: boolean\n        recorderVersion?: 'v1' | 'v2'\n    }\n    toolbarParams: ToolbarParams\n    editorParams?: ToolbarParams /** @deprecated, renamed to toolbarParams, still present on older API responses */\n    toolbarVersion: 'toolbar' /** @deprecated, moved to toolbarParams */\n    isAuthenticated: boolean\n    siteApps: { id: number; url: string }[]\n}\n\nexport type FeatureFlagsCallback = (flags: string[], variants: Record<string, string | boolean>) => void\n\n// TODO: delete custom_properties after changeless typescript refactor\nexport interface AutoCaptureCustomProperty {\n    name: string\n    css_selector: string\n    event_selectors: string[]\n}\n\nexport interface CompressionData {\n    data: string\n    compression?: Compression\n}\n\nexport interface GDPROptions {\n    capture?: (\n        event: string,\n        properties: Properties,\n        options: CaptureOptions\n    ) => void /** function used for capturing a PostHog event to record the opt-in action */\n    captureEventName?: string /** event name to be used for capturing the opt-in action */\n    captureProperties?: Properties /** set of properties to be captured along with the opt-in action */\n    /** persistence mechanism used */\n    persistenceType?: 'cookie' | 'localStorage' | 'localStorage+cookie'\n    persistencePrefix?: string /** [__ph_opt_in_out] - custom prefix to be used in the cookie/localstorage name */\n    cookieExpiration?: number /** number of days until the opt-in cookie expires */\n    crossSubdomainCookie?: boolean /** whether the opt-in cookie is set as cross-subdomain or not */\n    secureCookie?: boolean /** whether the opt-in cookie is set as secure or not */\n    respectDnt?: boolean\n    window?: Window\n}\n\nexport type RequestCallback = (response: Record<string, any>, data?: Properties) => void\n\nexport interface PersistentStore {\n    is_supported: () => boolean\n    error: (error: any) => void\n    parse: (name: string) => any\n    get: (name: string) => any\n    set: (name: string, value: any, expire_days?: number | null, cross_subdomain?: boolean, secure?: boolean) => void\n    remove: (name: string, cross_subdomain?: boolean) => void\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Breaker = {}\nexport type EventHandler = (event: Event) => boolean | void\n\nexport type ToolbarUserIntent = 'add-action' | 'edit-action'\nexport type ToolbarSource = 'url' | 'localstorage'\nexport type ToolbarVersion = 'toolbar'\n\n/* sync with posthog */\nexport interface ToolbarParams {\n    token?: string /** public posthog-js token */\n    temporaryToken?: string /** private temporary user token */\n    actionId?: number\n    userIntent?: ToolbarUserIntent\n    source?: ToolbarSource\n    toolbarVersion?: ToolbarVersion\n    instrument?: boolean\n    distinctId?: string\n    userEmail?: string\n    dataAttributes?: string[]\n    featureFlags?: Record<string, string | boolean>\n}\n\nexport interface PostData {\n    buffer?: BlobPart\n    compression?: Compression\n    data?: string\n}\n\nexport interface JSC {\n    (): void\n    [key: string]: (response: any) => void\n}\n\nexport type SnippetArrayItem = [method: string, ...args: any[]]\n\nexport type JsonType = string | number | boolean | null | { [key: string]: JsonType } | Array<JsonType>\n\n/** A feature that isn't publicly available yet.*/\nexport interface EarlyAccessFeature {\n    // Sync this with the backend's EarlyAccessFeatureSerializer!\n    name: string\n    description: string\n    stage: 'concept' | 'alpha' | 'beta'\n    documentationUrl: string | null\n    flagKey: string | null\n}\n\nexport type EarlyAccessFeatureCallback = (earlyAccessFeatures: EarlyAccessFeature[]) => void\n\nexport interface EarlyAccessFeatureResponse {\n    earlyAccessFeatures: EarlyAccessFeature[]\n}\n\nexport type NetworkRequest = {\n    url: string\n}\n"], "filenames": ["package.json", "src/__tests__/extensions/toolbar.js", "src/extensions/toolbar.ts", "src/types.ts"], "buggy_code_start_loc": [3, 81, 24, 272], "buggy_code_end_loc": [4, 188, 121, 274], "fixing_code_start_loc": [3, 80, 23, 271], "fixing_code_end_loc": [4, 195, 115, 271], "type": "CWE-79", "message": "PostHog-js is a library to interface with the PostHog analytics tool. Versions prior to 1.57.2 have the potential for cross-site scripting. Problem has been patched in 1.57.2. Users are advised to upgrade. Users unable to upgrade should ensure that their Content Security Policy is in place.", "other": {"cve": {"id": "CVE-2023-32325", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-27T00:15:09.600", "lastModified": "2023-06-03T03:54:19.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PostHog-js is a library to interface with the PostHog analytics tool. Versions prior to 1.57.2 have the potential for cross-site scripting. Problem has been patched in 1.57.2. Users are advised to upgrade. Users unable to upgrade should ensure that their Content Security Policy is in place."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:posthog:posthog-js:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.57.2", "matchCriteriaId": "119806F3-197A-4D09-9FC3-E858514A6075"}]}]}], "references": [{"url": "https://github.com/PostHog/posthog-js/commit/67e07eb8bb271a3a6f4aa251382e4d25abb385a0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PostHog/posthog-js/security/advisories/GHSA-8775-5hwv-wr6v", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/PostHog/posthog-js/commit/67e07eb8bb271a3a6f4aa251382e4d25abb385a0"}}