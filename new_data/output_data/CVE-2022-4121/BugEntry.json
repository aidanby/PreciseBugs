{"buggy_code": ["/*\n * libEtPan! -- a mail stuff library\n *\n * Copyright (C) 2001, 2005 - DINH Viet Hoa\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the libEtPan! project nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * $Id: mailimap_types.c,v 1.31 2011/03/16 22:40:04 hoa Exp $\n */\n\n#ifdef HAVE_CONFIG_H\n#\tinclude <config.h>\n#endif\n\n#include \"mailimap_types.h\"\n#include \"mmapstring.h\"\n#include \"mail.h\"\n#include \"mailimap_extension.h\"\n#include \"mailimap.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n\n\n\n\n\n\n/* from parser */\n\n\nLIBETPAN_EXPORT\nuint32_t * mailimap_number_alloc_new(uint32_t number)\n{\n  uint32_t * pnumber;\n\n  pnumber = malloc(sizeof(* pnumber));\n  if (pnumber == NULL)\n    return NULL;\n\n  * pnumber = number;\n\n  return pnumber;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_number_alloc_free(uint32_t * pnumber)\n{\n  free(pnumber);\n}\n\n\n/* ************************************************************************* */\n\n\nLIBETPAN_EXPORT\nstruct mailimap_address *\nmailimap_address_new(char * ad_personal_name, char * ad_source_route,\n\t\t     char * ad_mailbox_name, char * ad_host_name)\n{\n  struct mailimap_address * addr;\n\n  addr = malloc(sizeof(* addr));\n  if (addr == NULL)\n    return NULL;\n\n  addr->ad_personal_name = ad_personal_name;\n  addr->ad_source_route = ad_source_route;\n  addr->ad_mailbox_name = ad_mailbox_name;\n  addr->ad_host_name = ad_host_name;\n\n  return addr;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_address_free(struct mailimap_address * addr)\n{\n  mailimap_addr_host_free(addr->ad_host_name);\n  mailimap_addr_mailbox_free(addr->ad_mailbox_name);\n  mailimap_addr_adl_free(addr->ad_source_route);\n  mailimap_addr_name_free(addr->ad_personal_name);\n  free(addr);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_host_free(char * addr_host)\n{\n  mailimap_nstring_free(addr_host);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_mailbox_free(char * addr_mailbox)\n{\n  mailimap_nstring_free(addr_mailbox);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_adl_free(char * addr_adl)\n{\n  mailimap_nstring_free(addr_adl);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_name_free(char * addr_name)\n{\n  mailimap_nstring_free(addr_name);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_astring_free(char * astring)\n{\n  if (mmap_string_unref(astring) != 0)\n    free(astring);\n}\n\nstatic void mailimap_custom_string_free(char * str)\n{\n  free(str);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_atom_free(char * atom)\n{\n  free(atom);\n}\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_auth_type_free(char * auth_type)\n{\n  mailimap_atom_free(auth_type);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_base64_free(char * base64)\n{\n  free(base64);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body *\nmailimap_body_new(int bd_type,\n\t\t  struct mailimap_body_type_1part * bd_body_1part,\n\t\t  struct mailimap_body_type_mpart * bd_body_mpart)\n{\n  struct mailimap_body * body;\n  \n  body = malloc(sizeof(* body));\n  if (body == NULL)\n    return NULL;\n\n  body->bd_type = bd_type;\n  switch (bd_type) {\n  case MAILIMAP_BODY_1PART:\n    body->bd_data.bd_body_1part = bd_body_1part;\n    break;\n  case MAILIMAP_BODY_MPART:\n    body->bd_data.bd_body_mpart = bd_body_mpart;\n    break;\n  }\n  \n  return body;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_free(struct mailimap_body * body)\n{\n  switch (body->bd_type) {\n  case MAILIMAP_BODY_1PART:\n    mailimap_body_type_1part_free(body->bd_data.bd_body_1part);\n    break;\n  case MAILIMAP_BODY_MPART:\n    mailimap_body_type_mpart_free(body->bd_data.bd_body_mpart);\n    break;\n  }\n  free(body);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_extension *\nmailimap_body_extension_new(int ext_type, char * ext_nstring,\n\t\t\t    uint32_t ext_number,\n    clist * ext_body_extension_list)\n{\n  struct mailimap_body_extension * body_extension;\n\n  body_extension = malloc(sizeof(* body_extension));\n  if (body_extension == NULL)\n    return NULL;\n\n  body_extension->ext_type = ext_type;\n  switch (ext_type) {\n  case MAILIMAP_BODY_EXTENSION_NSTRING:\n    body_extension->ext_data.ext_nstring = ext_nstring;\n    break;\n  case MAILIMAP_BODY_EXTENSION_NUMBER:\n    body_extension->ext_data.ext_number = ext_number;\n    break;\n  case MAILIMAP_BODY_EXTENSION_LIST:\n    body_extension->ext_data.ext_body_extension_list = ext_body_extension_list;\n    break;\n  }\n  \n  return body_extension;\n}\n\nstatic void\nmailimap_body_ext_list_free(clist * body_ext_list);\n\nLIBETPAN_EXPORT\nvoid mailimap_body_extension_free(struct mailimap_body_extension * be)\n{\n  switch (be->ext_type) {\n  case MAILIMAP_BODY_EXTENSION_NSTRING:\n    mailimap_nstring_free(be->ext_data.ext_nstring);\n    break;\n  case MAILIMAP_BODY_EXTENSION_LIST:\n    mailimap_body_ext_list_free(be->ext_data.ext_body_extension_list);\n    break;\n  }\n  \n  free(be);\n}\n\n\nstatic void\nmailimap_body_ext_list_free(clist * body_ext_list)\n{\n  clist_foreach(body_ext_list, (clist_func) mailimap_body_extension_free,\n\t\tNULL);\n  clist_free(body_ext_list);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_ext_1part *\nmailimap_body_ext_1part_new(char * bd_md5,\n\t\t\t    struct mailimap_body_fld_dsp * bd_disposition,\n\t\t\t    struct mailimap_body_fld_lang * bd_language,\n          char * bd_loc,\n\t\t\t    clist * bd_extension_list)\n{\n  struct mailimap_body_ext_1part * body_ext_1part;\n  \n  body_ext_1part = malloc(sizeof(* body_ext_1part));\n  if (body_ext_1part == NULL)\n    return NULL;\n\n  body_ext_1part->bd_md5 = bd_md5;\n  body_ext_1part->bd_disposition = bd_disposition;\n  body_ext_1part->bd_language = bd_language;\n  body_ext_1part->bd_loc = bd_loc;\n  body_ext_1part->bd_extension_list = bd_extension_list;\n\n  return body_ext_1part;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_ext_1part_free(struct mailimap_body_ext_1part * body_ext_1part)\n{\n  mailimap_body_fld_md5_free(body_ext_1part->bd_md5);\n  if (body_ext_1part->bd_disposition)\n    mailimap_body_fld_dsp_free(body_ext_1part->bd_disposition);\n  if (body_ext_1part->bd_language)\n    mailimap_body_fld_lang_free(body_ext_1part->bd_language);\n  if (body_ext_1part->bd_extension_list)\n    mailimap_body_ext_list_free(body_ext_1part->bd_extension_list);\n  mailimap_body_fld_loc_free(body_ext_1part->bd_loc);\n\n  free(body_ext_1part);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_body_ext_mpart *\nmailimap_body_ext_mpart_new(struct mailimap_body_fld_param * bd_parameter,\n                            struct mailimap_body_fld_dsp * bd_disposition,\n                            struct mailimap_body_fld_lang * bd_language,\n                            char * bd_loc,\n                            clist * bd_extension_list)\n{\n  struct mailimap_body_ext_mpart * body_ext_mpart;\n\n  body_ext_mpart = malloc(sizeof(* body_ext_mpart));\n  if (body_ext_mpart == NULL)\n    return NULL;\n\n  body_ext_mpart->bd_parameter = bd_parameter;\n  body_ext_mpart->bd_disposition = bd_disposition;\n  body_ext_mpart->bd_language = bd_language;\n  body_ext_mpart->bd_extension_list = bd_extension_list;\n  body_ext_mpart->bd_loc = bd_loc;\n\n  return body_ext_mpart;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_ext_mpart_free(struct mailimap_body_ext_mpart * body_ext_mpart)\n{\n  if (body_ext_mpart->bd_parameter != NULL)\n    mailimap_body_fld_param_free(body_ext_mpart->bd_parameter);\n  if (body_ext_mpart->bd_disposition)\n    mailimap_body_fld_dsp_free(body_ext_mpart->bd_disposition);\n  if (body_ext_mpart->bd_language)\n    mailimap_body_fld_lang_free(body_ext_mpart->bd_language);\n  if (body_ext_mpart->bd_extension_list)\n    mailimap_body_ext_list_free(body_ext_mpart->bd_extension_list);\n  mailimap_body_fld_loc_free(body_ext_mpart->bd_loc);\n  free(body_ext_mpart);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fields *\nmailimap_body_fields_new(struct mailimap_body_fld_param * bd_parameter,\n\t\t\t char * bd_id,\n\t\t\t char * bd_description,\n\t\t\t struct mailimap_body_fld_enc * bd_encoding,\n\t\t\t uint32_t bd_size)\n{\n  struct mailimap_body_fields * body_fields;\n\n  body_fields = malloc(sizeof(* body_fields));\n  if (body_fields == NULL)\n    return NULL;\n  body_fields->bd_parameter = bd_parameter;\n  body_fields->bd_id = bd_id;\n  body_fields->bd_description = bd_description;\n  body_fields->bd_encoding = bd_encoding;\n  body_fields->bd_size = bd_size;\n\n  return body_fields;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_fields_free(struct mailimap_body_fields * body_fields)\n{\n  if (body_fields->bd_parameter != NULL)\n    mailimap_body_fld_param_free(body_fields->bd_parameter);\n  mailimap_body_fld_id_free(body_fields->bd_id);\n  mailimap_body_fld_desc_free(body_fields->bd_description);\n  mailimap_body_fld_enc_free(body_fields->bd_encoding);\n  free(body_fields);\n}\n\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_desc_free(char * body_fld_desc)\n{\n  mailimap_nstring_free(body_fld_desc);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_dsp *\nmailimap_body_fld_dsp_new(char * dsp_type,\n    struct mailimap_body_fld_param * dsp_attributes)\n{\n  struct mailimap_body_fld_dsp * body_fld_dsp;\n\n  body_fld_dsp = malloc(sizeof(* body_fld_dsp));\n  if (body_fld_dsp == NULL)\n    return NULL;\n\n  body_fld_dsp->dsp_type = dsp_type;\n  body_fld_dsp->dsp_attributes = dsp_attributes;\n\n  return body_fld_dsp;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_dsp_free(struct mailimap_body_fld_dsp * bfd)\n{\n  if (bfd->dsp_type != NULL)\n    mailimap_string_free(bfd->dsp_type);\n  if (bfd->dsp_attributes != NULL)\n    mailimap_body_fld_param_free(bfd->dsp_attributes);\n  free(bfd);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_enc *\nmailimap_body_fld_enc_new(int enc_type, char * enc_value)\n{\n  struct mailimap_body_fld_enc * body_fld_enc;\n\n  body_fld_enc = malloc(sizeof(* body_fld_enc));\n  if (body_fld_enc == NULL)\n    return NULL;\n  \n  body_fld_enc->enc_type = enc_type;\n  body_fld_enc->enc_value = enc_value;\n\n  return body_fld_enc;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_enc_free(struct mailimap_body_fld_enc * bfe)\n{\n  if (bfe->enc_value)\n    mailimap_string_free(bfe->enc_value);\n  free(bfe);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_id_free(char * body_fld_id)\n{\n  mailimap_nstring_free(body_fld_id);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_lang *\nmailimap_body_fld_lang_new(int lg_type, char * lg_single, clist * lg_list)\n{\n  struct mailimap_body_fld_lang * fld_lang;\n\n  fld_lang = malloc(sizeof(* fld_lang));\n  if (fld_lang == NULL)\n    return NULL;\n  \n  fld_lang->lg_type = lg_type;\n  switch (lg_type) {\n  case MAILIMAP_BODY_FLD_LANG_SINGLE:\n    fld_lang->lg_data.lg_single = lg_single;\n    break;\n  case MAILIMAP_BODY_FLD_LANG_LIST:\n    fld_lang->lg_data.lg_list = lg_list;\n    break;\n  }\n\n  return fld_lang;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_fld_lang_free(struct mailimap_body_fld_lang * fld_lang)\n{\n  switch (fld_lang->lg_type) {\n  case MAILIMAP_BODY_FLD_LANG_SINGLE:\n    mailimap_nstring_free(fld_lang->lg_data.lg_single);\n    break;\n  case MAILIMAP_BODY_FLD_LANG_LIST:\n    clist_foreach(fld_lang->lg_data.lg_list,\n        (clist_func) mailimap_string_free, NULL);\n    clist_free(fld_lang->lg_data.lg_list);\n    break;\n  }\n  free(fld_lang);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_md5_free(char * body_fld_md5)\n{\n  mailimap_nstring_free(body_fld_md5);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_loc_free(char * body_fld_loc)\n{\n  mailimap_nstring_free(body_fld_loc);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_single_body_fld_param *\nmailimap_single_body_fld_param_new(char * pa_name, char * pa_value)\n{\n  struct mailimap_single_body_fld_param * param;\n\n  param = malloc(sizeof(* param));\n  if (param == NULL)\n    return NULL;\n  param->pa_name = pa_name;\n  param->pa_value = pa_value;\n\n  return param;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_single_body_fld_param_free(struct mailimap_single_body_fld_param * p)\n{\n  mailimap_string_free(p->pa_name);\n  mailimap_string_free(p->pa_value);\n  free(p);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_param *\nmailimap_body_fld_param_new(clist * pa_list)\n{\n  struct mailimap_body_fld_param * fld_param;\n\n  fld_param = malloc(sizeof(* fld_param));\n  if (fld_param == NULL)\n    return NULL;\n  fld_param->pa_list = pa_list;\n\n  return fld_param;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_fld_param_free(struct mailimap_body_fld_param * fld_param)\n{\n  clist_foreach(fld_param->pa_list,\n\t\t(clist_func) mailimap_single_body_fld_param_free, NULL);\n  clist_free(fld_param->pa_list);\n  free(fld_param);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_1part *\nmailimap_body_type_1part_new(int bd_type,\n\t\t\t     struct mailimap_body_type_basic * bd_type_basic,\n\t\t\t     struct mailimap_body_type_msg * bd_type_msg,\n\t\t\t     struct mailimap_body_type_text * bd_type_text,\n\t\t\t     struct mailimap_body_ext_1part * bd_ext_1part)\n{\n  struct mailimap_body_type_1part * body_type_1part;\n\n  body_type_1part = malloc(sizeof(* body_type_1part));\n  if (body_type_1part == NULL)\n    return NULL;\n  \n  body_type_1part->bd_type = bd_type;\n  switch (bd_type) {\n  case MAILIMAP_BODY_TYPE_1PART_BASIC:\n    body_type_1part->bd_data.bd_type_basic = bd_type_basic;\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_MSG:\n    body_type_1part->bd_data.bd_type_msg = bd_type_msg;\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_TEXT:\n    body_type_1part->bd_data.bd_type_text = bd_type_text;\n    break;\n  }\n  body_type_1part->bd_ext_1part = bd_ext_1part;\n\n  return body_type_1part;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_type_1part_free(struct mailimap_body_type_1part * bt1p)\n{\n  switch (bt1p->bd_type) {\n  case MAILIMAP_BODY_TYPE_1PART_BASIC:\n    mailimap_body_type_basic_free(bt1p->bd_data.bd_type_basic);\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_MSG:\n    mailimap_body_type_msg_free(bt1p->bd_data.bd_type_msg);\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_TEXT:\n    mailimap_body_type_text_free(bt1p->bd_data.bd_type_text);\n    break;\n  }\n  if (bt1p->bd_ext_1part)\n    mailimap_body_ext_1part_free(bt1p->bd_ext_1part);\n\n  free(bt1p);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_basic *\nmailimap_body_type_basic_new(struct mailimap_media_basic * bd_media_basic,\n\t\t\t     struct mailimap_body_fields * bd_fields)\n{\n  struct mailimap_body_type_basic * body_type_basic;\n\n  body_type_basic = malloc(sizeof(* body_type_basic));\n  if (body_type_basic == NULL)\n    return NULL;\n\n  body_type_basic->bd_media_basic = bd_media_basic;\n  body_type_basic->bd_fields = bd_fields;\n \n  return body_type_basic;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_type_basic_free(struct mailimap_body_type_basic *\n    body_type_basic)\n{\n  mailimap_media_basic_free(body_type_basic->bd_media_basic);\n  mailimap_body_fields_free(body_type_basic->bd_fields);\n  free(body_type_basic);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_mpart *\nmailimap_body_type_mpart_new(clist * bd_list, char * bd_media_subtype,\n\t\t\t     struct mailimap_body_ext_mpart * bd_ext_mpart)\n{\n  struct mailimap_body_type_mpart * body_type_mpart;\n\n  body_type_mpart = malloc(sizeof(* body_type_mpart));\n  if (body_type_mpart == NULL)\n    return NULL;\n\n  body_type_mpart->bd_list = bd_list;\n  body_type_mpart->bd_media_subtype = bd_media_subtype;\n  body_type_mpart->bd_ext_mpart = bd_ext_mpart;\n\n  return body_type_mpart;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_type_mpart_free(struct mailimap_body_type_mpart *\n\t\t\t\t   body_type_mpart)\n{\n  clist_foreach(body_type_mpart->bd_list,\n\t\t(clist_func) mailimap_body_free, NULL);\n  clist_free(body_type_mpart->bd_list);\n  mailimap_media_subtype_free(body_type_mpart->bd_media_subtype);\n  if (body_type_mpart->bd_ext_mpart)\n    mailimap_body_ext_mpart_free(body_type_mpart->bd_ext_mpart);\n\n  free(body_type_mpart);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_msg *\nmailimap_body_type_msg_new(struct mailimap_body_fields * bd_fields,\n\t\t\t   struct mailimap_envelope * bd_envelope,\n\t\t\t   struct mailimap_body * bd_body,\n\t\t\t   uint32_t bd_lines)\n{\n  struct mailimap_body_type_msg * body_type_msg;\n\n  body_type_msg = malloc(sizeof(* body_type_msg));\n  if (body_type_msg == NULL)\n    return NULL;\n\n  body_type_msg->bd_fields = bd_fields;\n  body_type_msg->bd_envelope = bd_envelope;\n  body_type_msg->bd_body = bd_body;\n  body_type_msg->bd_lines = bd_lines;\n\n  return body_type_msg;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_type_msg_free(struct mailimap_body_type_msg * body_type_msg)\n{\n  mailimap_body_fields_free(body_type_msg->bd_fields);\n  mailimap_envelope_free(body_type_msg->bd_envelope);\n  mailimap_body_free(body_type_msg->bd_body);\n  free(body_type_msg);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_text *\nmailimap_body_type_text_new(char * bd_media_text,\n\t\t\t    struct mailimap_body_fields * bd_fields,\n\t\t\t    uint32_t bd_lines)\n{\n  struct mailimap_body_type_text * body_type_text;\n\n  body_type_text = malloc(sizeof(* body_type_text));\n  if (body_type_text == NULL)\n    return NULL;\n\n  body_type_text->bd_media_text = bd_media_text;\n  body_type_text->bd_fields = bd_fields;\n  body_type_text->bd_lines = bd_lines;\n\n  return body_type_text;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_type_text_free(struct mailimap_body_type_text * body_type_text)\n{\n  mailimap_media_text_free(body_type_text->bd_media_text);\n  mailimap_body_fields_free(body_type_text->bd_fields);\n  free(body_type_text);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_capability *\nmailimap_capability_new(int cap_type, char * cap_auth_type, char * cap_name)\n{\n  struct mailimap_capability * cap;\n\n  cap = malloc(sizeof(* cap));\n  if (cap == NULL)\n    return NULL;\n  cap->cap_type = cap_type;\n  switch (cap_type) {\n  case MAILIMAP_CAPABILITY_AUTH_TYPE:\n    cap->cap_data.cap_auth_type = cap_auth_type;\n    break;\n  case MAILIMAP_CAPABILITY_NAME:\n    cap->cap_data.cap_name = cap_name;\n    break;\n  }\n  \n  return cap;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_capability_free(struct mailimap_capability * c)\n{\n  switch (c->cap_type) {\n  case MAILIMAP_CAPABILITY_AUTH_TYPE:\n    free(c->cap_data.cap_auth_type);\n    break;\n  case MAILIMAP_CAPABILITY_NAME:\n    free(c->cap_data.cap_name);\n    break;\n  }\n  free(c);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_capability_data *\nmailimap_capability_data_new(clist * cap_list)\n{\n  struct mailimap_capability_data * cap_data;\n\n  cap_data = malloc(sizeof(* cap_data));\n  if (cap_data == NULL)\n    return NULL;\n\n  cap_data->cap_list = cap_list;\n\n  return cap_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_capability_data_free(struct mailimap_capability_data * cap_data)\n{\n  if (cap_data->cap_list) {\n    clist_foreach(cap_data->cap_list,\n        (clist_func) mailimap_capability_free, NULL);\n    clist_free(cap_data->cap_list);\n  }\n  free(cap_data);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_continue_req *\nmailimap_continue_req_new(int cr_type, struct mailimap_resp_text * cr_text,\n    char * cr_base64)\n{\n  struct mailimap_continue_req * cont_req;\n\n  cont_req = malloc(sizeof(* cont_req));\n  if (cont_req == NULL)\n    return NULL;\n  cont_req->cr_type = cr_type;\n  switch (cr_type) {\n  case MAILIMAP_CONTINUE_REQ_TEXT:\n    cont_req->cr_data.cr_text = cr_text;\n    break;\n  case MAILIMAP_CONTINUE_REQ_BASE64:\n    cont_req->cr_data.cr_base64 = cr_base64;\n    break;\n  }\n  \n  return cont_req;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_continue_req_free(struct mailimap_continue_req * cont_req)\n{\n  switch (cont_req->cr_type) {\n  case MAILIMAP_CONTINUE_REQ_TEXT:\n    mailimap_resp_text_free(cont_req->cr_data.cr_text);\n    break;\n  case MAILIMAP_CONTINUE_REQ_BASE64:\n    mailimap_base64_free(cont_req->cr_data.cr_base64);\n    break;\n  }\n  free(cont_req);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_date_time *\nmailimap_date_time_new(int dt_day, int dt_month, int dt_year, int dt_hour,\n    int dt_min, int dt_sec, int dt_zone)\n{\n  struct mailimap_date_time * date_time;\n\n  date_time = malloc(sizeof(* date_time));\n  if (date_time == NULL)\n    return NULL;\n\n  date_time->dt_day = dt_day;\n  date_time->dt_month = dt_month;\n  date_time->dt_year = dt_year;\n  date_time->dt_hour = dt_hour;\n  date_time->dt_min = dt_min;\n  date_time->dt_sec = dt_sec;\n  date_time->dt_zone = dt_zone;\n\n  return date_time;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_date_time_free(struct mailimap_date_time * date_time)\n{\n  free(date_time);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_envelope *\nmailimap_envelope_new(char * env_date, char * env_subject,\n\t\t      struct mailimap_env_from * env_from,\n\t\t      struct mailimap_env_sender * env_sender,\n\t\t      struct mailimap_env_reply_to * env_reply_to,\n\t\t      struct mailimap_env_to * env_to,\n\t\t      struct mailimap_env_cc* env_cc,\n\t\t      struct mailimap_env_bcc * env_bcc,\n\t\t      char * env_in_reply_to, char * env_message_id)\n{\n  struct mailimap_envelope * env;\n\n  env = malloc(sizeof(* env));\n  if (env == NULL)\n    return NULL;\n\n  env->env_date = env_date;\n  env->env_subject = env_subject;\n  env->env_from = env_from;\n  env->env_sender = env_sender;\n  env->env_reply_to = env_reply_to;\n  env->env_to = env_to;\n  env->env_cc = env_cc;\n  env->env_bcc = env_bcc;\n  env->env_in_reply_to = env_in_reply_to;\n  env->env_message_id = env_message_id;\n\n  return env;\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_envelope_free(struct mailimap_envelope * env)\n{\n  if (env->env_date)\n    mailimap_env_date_free(env->env_date);\n  if (env->env_subject)\n    mailimap_env_subject_free(env->env_subject);\n  if (env->env_from)\n    mailimap_env_from_free(env->env_from);\n  if (env->env_sender)\n    mailimap_env_sender_free(env->env_sender);\n  if (env->env_reply_to)\n    mailimap_env_reply_to_free(env->env_reply_to);\n  if (env->env_to)\n    mailimap_env_to_free(env->env_to);\n  if (env->env_cc)\n    mailimap_env_cc_free(env->env_cc);\n  if (env->env_bcc)\n    mailimap_env_bcc_free(env->env_bcc);\n  if (env->env_in_reply_to)\n    mailimap_env_in_reply_to_free(env->env_in_reply_to);\n  if (env->env_message_id)\n    mailimap_env_message_id_free(env->env_message_id);\n\n  free(env);\n}\n\n\nstatic void mailimap_address_list_free(clist * addr_list)\n{\n  if (addr_list != NULL) {\n    clist_foreach(addr_list, (clist_func) mailimap_address_free, NULL);\n    clist_free(addr_list);\n  }\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_env_bcc * mailimap_env_bcc_new(clist * bcc_list)\n{\n  struct mailimap_env_bcc * env_bcc;\n\n  env_bcc = malloc(sizeof(* env_bcc));\n  if (env_bcc == NULL)\n    return NULL;\n  env_bcc->bcc_list = bcc_list;\n\n  return env_bcc;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_bcc_free(struct mailimap_env_bcc * env_bcc)\n{\n  mailimap_address_list_free(env_bcc->bcc_list);\n  free(env_bcc);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_env_cc * mailimap_env_cc_new(clist * cc_list)\n{\n  struct mailimap_env_cc * env_cc;\n\n  env_cc = malloc(sizeof(* env_cc));\n  if (env_cc == NULL)\n    return NULL;\n  env_cc->cc_list = cc_list;\n\n  return env_cc;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_cc_free(struct mailimap_env_cc * env_cc)\n{\n  mailimap_address_list_free(env_cc->cc_list);\n  free(env_cc);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_env_date_free(char * date)\n{\n  mailimap_nstring_free(date);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_env_from * mailimap_env_from_new(clist * frm_list)\n{\n  struct mailimap_env_from * env_from;\n\n  env_from = malloc(sizeof(* env_from));\n  if (env_from == NULL)\n    return NULL;\n  env_from->frm_list = frm_list;\n\n  return env_from;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_from_free(struct mailimap_env_from * env_from)\n{\n  mailimap_address_list_free(env_from->frm_list);\n  free(env_from);\n}\n\n\nvoid mailimap_env_in_reply_to_free(char * in_reply_to)\n{\n  mailimap_nstring_free(in_reply_to);\n}\n\nvoid mailimap_env_message_id_free(char * message_id)\n{\n  mailimap_nstring_free(message_id);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_env_reply_to * mailimap_env_reply_to_new(clist * rt_list)\n{\n  struct mailimap_env_reply_to * env_reply_to;\n\n  env_reply_to = malloc(sizeof(* env_reply_to));\n  if (env_reply_to == NULL)\n    return NULL;\n  env_reply_to->rt_list = rt_list;\n\n  return env_reply_to;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_env_reply_to_free(struct mailimap_env_reply_to * env_reply_to)\n{\n  mailimap_address_list_free(env_reply_to->rt_list);\n  free(env_reply_to);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_env_sender * mailimap_env_sender_new(clist * snd_list)\n{\n  struct mailimap_env_sender * env_sender;\n\n  env_sender = malloc(sizeof(* env_sender));\n  if (env_sender == NULL)\n    return NULL;\n  env_sender->snd_list = snd_list;\n\n  return env_sender;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_sender_free(struct mailimap_env_sender * env_sender)\n{\n  mailimap_address_list_free(env_sender->snd_list);\n  free(env_sender);\n}\n\nvoid mailimap_env_subject_free(char * subject)\n{\n  mailimap_nstring_free(subject);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_env_to * mailimap_env_to_new(clist * to_list)\n{\n  struct mailimap_env_to * env_to;\n\n  env_to = malloc(sizeof(* env_to));\n  if (env_to == NULL)\n    return NULL;\n  env_to->to_list = to_list;\n\n  return env_to;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_to_free(struct mailimap_env_to * env_to)\n{\n  mailimap_address_list_free(env_to->to_list);\n  free(env_to);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag * mailimap_flag_new(int fl_type,\n    char * fl_keyword, char * fl_extension)\n{\n  struct mailimap_flag * f;\n\n  f = malloc(sizeof(* f));\n  if (f == NULL)\n    return NULL;\n  f->fl_type = fl_type;\n  switch (fl_type) {\n  case MAILIMAP_FLAG_KEYWORD:\n    f->fl_data.fl_keyword = fl_keyword;\n    break;\n  case MAILIMAP_FLAG_EXTENSION:\n    f->fl_data.fl_extension = fl_extension;\n    break;\n  }\n\n  return f;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_free(struct mailimap_flag * f)\n{\n  switch (f->fl_type) {\n  case MAILIMAP_FLAG_KEYWORD:\n    mailimap_flag_keyword_free(f->fl_data.fl_keyword);\n    break;\n  case MAILIMAP_FLAG_EXTENSION:\n    mailimap_flag_extension_free(f->fl_data.fl_extension);\n    break;\n  }\n  free(f);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_extension_free(char * flag_extension)\n{\n  mailimap_atom_free(flag_extension);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag_fetch *\nmailimap_flag_fetch_new(int fl_type, struct mailimap_flag * fl_flag)\n{\n  struct mailimap_flag_fetch * flag_fetch;\n\n  flag_fetch = malloc(sizeof(* flag_fetch));\n  if (flag_fetch == NULL)\n    return NULL;\n\n  flag_fetch->fl_type = fl_type;\n  flag_fetch->fl_flag = fl_flag;\n\n  return flag_fetch;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_fetch_free(struct mailimap_flag_fetch * flag_fetch)\n{\n  if (flag_fetch->fl_flag)\n    mailimap_flag_free(flag_fetch->fl_flag);\n  free(flag_fetch);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_keyword_free(char * flag_keyword)\n{\n  mailimap_atom_free(flag_keyword);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag_list *\nmailimap_flag_list_new(clist * fl_list)\n{\n  struct mailimap_flag_list * flag_list;\n\n  flag_list = malloc(sizeof(* flag_list));\n  if (flag_list == NULL)\n    return NULL;\n  flag_list->fl_list = fl_list;\n\n  return flag_list;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_list_free(struct mailimap_flag_list * flag_list)\n{\n  if (flag_list->fl_list) {\n    clist_foreach(flag_list->fl_list, (clist_func) mailimap_flag_free, NULL);\n    clist_free(flag_list->fl_list);\n  }\n  free(flag_list);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag_perm *\nmailimap_flag_perm_new(int fl_type, struct mailimap_flag * fl_flag)\n{\n  struct mailimap_flag_perm * flag_perm;\n\n  flag_perm = malloc(sizeof(* flag_perm));\n  if (flag_perm == NULL)\n    return NULL;\n\n  flag_perm->fl_type = fl_type;\n  flag_perm->fl_flag = fl_flag;\n\n  return flag_perm;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_perm_free(struct mailimap_flag_perm * flag_perm)\n{\n  if (flag_perm->fl_flag != NULL)\n    mailimap_flag_free(flag_perm->fl_flag);\n  free(flag_perm);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_greeting *\nmailimap_greeting_new(int gr_type,\n    struct mailimap_resp_cond_auth * gr_auth,\n    struct mailimap_resp_cond_bye * gr_bye)\n{\n  struct mailimap_greeting * greeting;\n\n  greeting = malloc(sizeof(* greeting));\n  if (greeting == NULL)\n    return NULL;\n  greeting->gr_type = gr_type;\n  switch (gr_type) {\n  case MAILIMAP_GREETING_RESP_COND_AUTH:\n    greeting->gr_data.gr_auth = gr_auth;\n    break;\n  case MAILIMAP_GREETING_RESP_COND_BYE:\n    greeting->gr_data.gr_bye = gr_bye;\n    break;\n  }\n  \n  return greeting;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_greeting_free(struct mailimap_greeting * greeting)\n{\n  switch (greeting->gr_type) {\n  case MAILIMAP_GREETING_RESP_COND_AUTH:\n    mailimap_resp_cond_auth_free(greeting->gr_data.gr_auth);\n    break;\n  case MAILIMAP_GREETING_RESP_COND_BYE:\n    mailimap_resp_cond_bye_free(greeting->gr_data.gr_bye);\n    break;\n  }\n  free(greeting);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_header_fld_name_free(char * header_fld_name)\n{\n  mailimap_astring_free(header_fld_name);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_header_list *\nmailimap_header_list_new(clist * hdr_list)\n{\n  struct mailimap_header_list * header_list;\n\n  header_list = malloc(sizeof(* header_list));\n  if (header_list == NULL)\n    return NULL;\n\n  header_list->hdr_list = hdr_list;\n\n  return header_list;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_header_list_free(struct mailimap_header_list * header_list)\n{\n  clist_foreach(header_list->hdr_list,\n      (clist_func) mailimap_header_fld_name_free,\n      NULL);\n  clist_free(header_list->hdr_list);\n  free(header_list);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_literal_free(char * literal)\n{\n  /*  free(literal); */\n  mmap_string_unref(literal);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_mailbox_free(char * mb)\n{\n  mailimap_astring_free(mb);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_status_info *\nmailimap_status_info_new(int st_att, uint32_t st_value,\n  struct mailimap_extension_data * st_ext_data)\n{\n  struct mailimap_status_info * info;\n\n  info = malloc(sizeof(* info));\n  if (info == NULL)\n    return NULL;\n  info->st_att = st_att;\n  info->st_value = st_value;\n  info->st_ext_data = st_ext_data;\n\n  return info;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_status_info_free(struct mailimap_status_info * info)\n{\n  if (info->st_ext_data != NULL) {\n    mailimap_extension_data_free(info->st_ext_data);\n  }\n  free(info);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mailbox_data_status *\nmailimap_mailbox_data_status_new(char * st_mailbox,\n    clist * st_info_list)\n{\n  struct mailimap_mailbox_data_status * mb_data_status;\n\n  mb_data_status = malloc(sizeof(* mb_data_status));\n  if (mb_data_status == NULL)\n    return NULL;\n  mb_data_status->st_mailbox = st_mailbox;\n  mb_data_status->st_info_list = st_info_list;\n\n  return mb_data_status;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_data_search_free(clist * data_search)\n{\n  clist_foreach(data_search, (clist_func) mailimap_number_alloc_free, NULL);\n  clist_free(data_search);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n\t\t NULL);\n  clist_free(info->st_info_list);\n  free(info);\n}\n\n\nstatic void\nmailimap_mailbox_data_flags_free(struct mailimap_flag_list * flag_list)\n{\n  mailimap_flag_list_free(flag_list);\n}\n\nstatic void\nmailimap_mailbox_data_list_free(struct mailimap_mailbox_list * mb_list)\n{\n  mailimap_mailbox_list_free(mb_list);\n}\n\nstatic void\nmailimap_mailbox_data_lsub_free(struct mailimap_mailbox_list * mb_lsub)\n{\n  mailimap_mailbox_list_free(mb_lsub);\n}\n\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mailbox_data *\nmailimap_mailbox_data_new(int mbd_type, struct mailimap_flag_list * mbd_flags,\n    struct mailimap_mailbox_list * mbd_list,\n    struct mailimap_mailbox_list * mbd_lsub,\n    clist * mbd_search,\n    struct mailimap_mailbox_data_status * mbd_status,\n    uint32_t mbd_exists,\n    uint32_t mbd_recent,\n    struct mailimap_extension_data * mbd_extension)\n{\n  struct mailimap_mailbox_data * data;\n\n  data = malloc(sizeof(* data));\n  if (data == NULL)\n    return NULL;\n\n  data->mbd_type = mbd_type;\n  switch (mbd_type) {\n  case MAILIMAP_MAILBOX_DATA_FLAGS:\n    data->mbd_data.mbd_flags = mbd_flags;\n    break;\n  case MAILIMAP_MAILBOX_DATA_LIST:\n    data->mbd_data.mbd_list = mbd_list;\n    break;\n  case MAILIMAP_MAILBOX_DATA_LSUB:\n    data->mbd_data.mbd_lsub = mbd_lsub;\n    break;\n  case MAILIMAP_MAILBOX_DATA_SEARCH:\n    data->mbd_data.mbd_search = mbd_search;\n    break;\n  case MAILIMAP_MAILBOX_DATA_STATUS:\n    data->mbd_data.mbd_status = mbd_status;\n    break;\n  case MAILIMAP_MAILBOX_DATA_EXISTS:\n    data->mbd_data.mbd_exists = mbd_exists;\n    break;\n  case MAILIMAP_MAILBOX_DATA_RECENT:\n    data->mbd_data.mbd_recent = mbd_recent;\n    break;\n  case MAILIMAP_MAILBOX_DATA_EXTENSION_DATA:\n    data->mbd_data.mbd_extension = mbd_extension;\n    break;\n  }\n  \n  return data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_data_free(struct mailimap_mailbox_data * mb_data)\n{\n  switch (mb_data->mbd_type) {\n  case MAILIMAP_MAILBOX_DATA_FLAGS:\n    if (mb_data->mbd_data.mbd_flags != NULL)\n      mailimap_mailbox_data_flags_free(mb_data->mbd_data.mbd_flags);\n    break;\n  case MAILIMAP_MAILBOX_DATA_LIST:\n    if (mb_data->mbd_data.mbd_list != NULL)\n      mailimap_mailbox_data_list_free(mb_data->mbd_data.mbd_list);\n    break;\n  case MAILIMAP_MAILBOX_DATA_LSUB:\n    if (mb_data->mbd_data.mbd_lsub != NULL)\n      mailimap_mailbox_data_lsub_free(mb_data->mbd_data.mbd_lsub);\n    break;\n  case MAILIMAP_MAILBOX_DATA_SEARCH:\n    if (mb_data->mbd_data.mbd_search != NULL)\n      mailimap_mailbox_data_search_free(mb_data->mbd_data.mbd_search);\n    break;\n  case MAILIMAP_MAILBOX_DATA_STATUS:\n    if (mb_data->mbd_data.mbd_status != NULL)\n      mailimap_mailbox_data_status_free(mb_data->mbd_data.mbd_status);\n    break;\n  case MAILIMAP_MAILBOX_DATA_EXTENSION_DATA:\n    if (mb_data->mbd_data.mbd_extension != NULL)\n      mailimap_extension_data_free(mb_data->mbd_data.mbd_extension);\n    break;\n  }\n  free(mb_data);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mbx_list_flags *\nmailimap_mbx_list_flags_new(int mbf_type, clist * mbf_oflags,\n\t\t\t    int mbf_sflag)\n{\n  struct mailimap_mbx_list_flags * mbx_list_flags;\n\n  mbx_list_flags = malloc(sizeof(* mbx_list_flags));\n  if (mbx_list_flags == NULL)\n    return NULL;\n\n  mbx_list_flags->mbf_type = mbf_type;\n  mbx_list_flags->mbf_oflags = mbf_oflags;\n  mbx_list_flags->mbf_sflag = mbf_sflag;\n  \n  return mbx_list_flags;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mbx_list_flags_free(struct mailimap_mbx_list_flags * mbx_list_flags)\n{\n  clist_foreach(mbx_list_flags->mbf_oflags,\n      (clist_func) mailimap_mbx_list_oflag_free,\n      NULL);\n  clist_free(mbx_list_flags->mbf_oflags);\n  \n  free(mbx_list_flags);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mbx_list_oflag *\nmailimap_mbx_list_oflag_new(int of_type, char * of_flag_ext)\n{\n  struct mailimap_mbx_list_oflag * oflag;\n\n  oflag = malloc(sizeof(* oflag));\n  if (oflag == NULL)\n    return NULL;\n\n  oflag->of_type = of_type;\n  oflag->of_flag_ext = of_flag_ext;\n\n  return oflag;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mbx_list_oflag_free(struct mailimap_mbx_list_oflag * oflag)\n{\n  if (oflag->of_flag_ext != NULL)\n    mailimap_flag_extension_free(oflag->of_flag_ext);\n  free(oflag);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mailbox_list *\nmailimap_mailbox_list_new(struct mailimap_mbx_list_flags * mbx_flags,\n\t\t\t  char mb_delimiter, char * mb_name)\n{\n  struct mailimap_mailbox_list * mb_list;\n\n  mb_list = malloc(sizeof(* mb_list));\n  if (mb_list == NULL)\n    return NULL;\n  \n  mb_list->mb_flag = mbx_flags;\n  mb_list->mb_delimiter = mb_delimiter;\n  mb_list->mb_name = mb_name;\n\n  return mb_list;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_list_free(struct mailimap_mailbox_list * mb_list)\n{\n  if (mb_list->mb_flag != NULL)\n    mailimap_mbx_list_flags_free(mb_list->mb_flag);\n  if (mb_list->mb_name != NULL)\n    mailimap_mailbox_free(mb_list->mb_name);\n  free(mb_list);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_media_basic *\nmailimap_media_basic_new(int med_type,\n    char * med_basic_type, char * med_subtype)\n{\n  struct mailimap_media_basic * media_basic;\n\n  media_basic = malloc(sizeof(* media_basic));\n  if (media_basic == NULL)\n    return NULL;\n  media_basic->med_type = med_type;\n  media_basic->med_basic_type = med_basic_type;\n  media_basic->med_subtype = med_subtype;\n\n  return media_basic;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_media_basic_free(struct mailimap_media_basic * media_basic)\n{\n  mailimap_string_free(media_basic->med_basic_type);\n  mailimap_media_subtype_free(media_basic->med_subtype);\n  free(media_basic);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_media_subtype_free(char * media_subtype)\n{\n  mmap_string_unref(media_subtype);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_media_text_free(char * media_text)\n{\n  mailimap_media_subtype_free(media_text);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_message_data *\nmailimap_message_data_new(uint32_t mdt_number, int mdt_type,\n\t\t\t  struct mailimap_msg_att * mdt_msg_att)\n{\n  struct mailimap_message_data * msg_data;\n\n  msg_data = malloc(sizeof(* msg_data));\n  if (msg_data == NULL) {\n    return NULL;\n  }\n\n  msg_data->mdt_number = mdt_number;\n  msg_data->mdt_type = mdt_type;\n  msg_data->mdt_msg_att = mdt_msg_att;\n\n  return msg_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_message_data_free(struct mailimap_message_data * msg_data)\n{\n  if (msg_data->mdt_msg_att != NULL)\n    mailimap_msg_att_free(msg_data->mdt_msg_att);\n  free(msg_data);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_item *\nmailimap_msg_att_item_new(int att_type,\n\t\t\t  struct mailimap_msg_att_dynamic * att_dyn,\n\t\t\t  struct mailimap_msg_att_static * att_static,\n        struct mailimap_extension_data * att_extension_data)\n{\n  struct mailimap_msg_att_item * item;\n\n  item = malloc(sizeof(* item));\n  if (item == NULL)\n    return item;\n\n  item->att_type = att_type;\n  switch (att_type) {\n  case MAILIMAP_MSG_ATT_ITEM_DYNAMIC:\n    item->att_data.att_dyn = att_dyn;\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_STATIC:\n    item->att_data.att_static = att_static;\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_EXTENSION:\n    item->att_data.att_extension_data = att_extension_data;\n    break;\n  }\n\n  return item;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_item_free(struct mailimap_msg_att_item * item)\n{\n  switch (item->att_type) {\n  case MAILIMAP_MSG_ATT_ITEM_DYNAMIC:\n    mailimap_msg_att_dynamic_free(item->att_data.att_dyn);\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_STATIC:\n    mailimap_msg_att_static_free(item->att_data.att_static);\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_EXTENSION:\n    mailimap_extension_data_free(item->att_data.att_extension_data);\n    break;\n  }\n  free(item);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att *\nmailimap_msg_att_new(clist * att_list)\n{\n  struct mailimap_msg_att * msg_att;\n\n  msg_att = malloc(sizeof(* msg_att));\n  if (msg_att == NULL)\n    return NULL;\n\n  msg_att->att_list = att_list;\n  msg_att->att_number = 0;\n\n  return msg_att;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_msg_att_free(struct mailimap_msg_att * msg_att)\n{\n  clist_foreach(msg_att->att_list,\n      (clist_func) mailimap_msg_att_item_free, NULL);\n  clist_free(msg_att->att_list);\n  free(msg_att);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_dynamic *\nmailimap_msg_att_dynamic_new(clist * att_list)\n{\n  struct mailimap_msg_att_dynamic * msg_att_dyn;\n\n  msg_att_dyn = malloc(sizeof(* msg_att_dyn));\n  if (msg_att_dyn == NULL)\n    return NULL;\n\n  msg_att_dyn->att_list = att_list;\n  \n  return msg_att_dyn;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_dynamic_free(struct mailimap_msg_att_dynamic * msg_att_dyn)\n{\n  if (msg_att_dyn->att_list != NULL) {\n    clist_foreach(msg_att_dyn->att_list,\n        (clist_func) mailimap_flag_fetch_free,\n        NULL);\n    clist_free(msg_att_dyn->att_list);\n  }\n  free(msg_att_dyn);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_body_section *\nmailimap_msg_att_body_section_new(struct mailimap_section * sec_section,\n\t\t\t\t  uint32_t sec_origin_octet,\n\t\t\t\t  char * sec_body_part,\n\t\t\t\t  size_t sec_length)\n{\n  struct mailimap_msg_att_body_section * msg_att_body_section;\n\n  msg_att_body_section = malloc(sizeof(* msg_att_body_section));\n  if (msg_att_body_section == NULL)\n    return NULL;\n\n  msg_att_body_section->sec_section = sec_section;\n  msg_att_body_section->sec_origin_octet = sec_origin_octet;\n  msg_att_body_section->sec_body_part = sec_body_part;\n  msg_att_body_section->sec_length = sec_length;\n\n  return msg_att_body_section;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_body_section_free(struct mailimap_msg_att_body_section * \n    msg_att_body_section)\n{\n  if (msg_att_body_section->sec_section != NULL)\n    mailimap_section_free(msg_att_body_section->sec_section);\n  if (msg_att_body_section->sec_body_part != NULL)\n    mailimap_nstring_free(msg_att_body_section->sec_body_part);\n  free(msg_att_body_section);\n}\n\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_msg_att_envelope_free(struct mailimap_envelope * env)\n{\n  mailimap_envelope_free(env);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_internaldate_free(struct mailimap_date_time * date_time)\n{\n  mailimap_date_time_free(date_time);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_rfc822_free(char * str)\n{\n  mailimap_nstring_free(str);\n}\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_rfc822_header_free(char * str)\n{\n  mailimap_nstring_free(str);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_rfc822_text_free(char * str)\n{\n  mailimap_nstring_free(str);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_body_free(struct mailimap_body * body)\n{\n  mailimap_body_free(body);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_bodystructure_free(struct mailimap_body * body)\n{\n  mailimap_body_free(body);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_static *\nmailimap_msg_att_static_new(int att_type, struct mailimap_envelope * att_env,\n    struct mailimap_date_time * att_internal_date,\n    char * att_rfc822,\n    char * att_rfc822_header,\n    char * att_rfc822_text,\n    size_t att_length,\n    uint32_t att_rfc822_size,\n    struct mailimap_body * att_bodystructure,\n    struct mailimap_body * att_body,\n    struct mailimap_msg_att_body_section * att_body_section,\n    uint32_t att_uid)\n{\n  struct mailimap_msg_att_static * item;\n\n  item = malloc(sizeof(* item));\n  if (item == NULL)\n    return FALSE;\n\n  item->att_type = att_type;\n  switch (att_type) {\n  case MAILIMAP_MSG_ATT_ENVELOPE:\n    item->att_data.att_env = att_env;\n    break;\n  case MAILIMAP_MSG_ATT_INTERNALDATE:\n    item->att_data.att_internal_date = att_internal_date;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822:\n    item->att_data.att_rfc822.att_content = att_rfc822;\n    item->att_data.att_rfc822.att_length = att_length;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_HEADER:\n    item->att_data.att_rfc822_header.att_content = att_rfc822_header;\n    item->att_data.att_rfc822_header.att_length = att_length;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_TEXT:\n    item->att_data.att_rfc822_text.att_content = att_rfc822_text;\n    item->att_data.att_rfc822_text.att_length = att_length;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_SIZE:\n    item->att_data.att_rfc822_size = att_rfc822_size;\n    break;\n  case MAILIMAP_MSG_ATT_BODY:\n    item->att_data.att_body = att_body;\n    break;\n  case MAILIMAP_MSG_ATT_BODYSTRUCTURE:\n    item->att_data.att_bodystructure = att_bodystructure;\n    break;\n  case MAILIMAP_MSG_ATT_BODY_SECTION:\n    item->att_data.att_body_section = att_body_section;\n    break;\n  case MAILIMAP_MSG_ATT_UID:\n    item->att_data.att_uid = att_uid;\n    break;\n  }\n\n  return item;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_static_free(struct mailimap_msg_att_static * item)\n{\n  switch (item->att_type) {\n  case MAILIMAP_MSG_ATT_ENVELOPE:\n    if (item->att_data.att_env != NULL)\n      mailimap_msg_att_envelope_free(item->att_data.att_env);\n    break;\n  case MAILIMAP_MSG_ATT_INTERNALDATE:\n    if (item->att_data.att_internal_date != NULL)\n      mailimap_msg_att_internaldate_free(item->att_data.att_internal_date);\n    break;\n  case MAILIMAP_MSG_ATT_RFC822:\n    if (item->att_data.att_rfc822.att_content != NULL)\n      mailimap_msg_att_rfc822_free(item->att_data.att_rfc822.att_content);\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_HEADER:\n    if (item->att_data.att_rfc822_header.att_content != NULL)\n      mailimap_msg_att_rfc822_header_free(item->att_data.att_rfc822_header.att_content);\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_TEXT:\n    if (item->att_data.att_rfc822_text.att_content != NULL)\n      mailimap_msg_att_rfc822_text_free(item->att_data.att_rfc822_text.att_content);\n    break;\n  case MAILIMAP_MSG_ATT_BODYSTRUCTURE:\n    if (item->att_data.att_bodystructure != NULL)\n      mailimap_msg_att_bodystructure_free(item->att_data.att_bodystructure);\n    break;\n  case MAILIMAP_MSG_ATT_BODY:\n    if (item->att_data.att_body != NULL)\n      mailimap_msg_att_body_free(item->att_data.att_body);\n    break;\n  case MAILIMAP_MSG_ATT_BODY_SECTION:\n    if (item->att_data.att_body_section != NULL)\n      mailimap_msg_att_body_section_free(item->att_data.att_body_section);\n    break;\n  }\n  free(item);\n}\n \n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_nstring_free(char * str)\n{\n  if (str != NULL)\n    mailimap_string_free(str);\n}\n\n\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_cont_req_or_resp_data *\nmailimap_cont_req_or_resp_data_new(int rsp_type,\n    struct mailimap_continue_req * rsp_cont_req,\n    struct mailimap_response_data * rsp_resp_data)\n{\n  struct mailimap_cont_req_or_resp_data * cont_req_or_resp_data;\n\n  cont_req_or_resp_data = malloc(sizeof(* cont_req_or_resp_data));\n  if (cont_req_or_resp_data == NULL)\n    return NULL;\n\n  cont_req_or_resp_data->rsp_type = rsp_type;\n  switch (rsp_type) {\n  case MAILIMAP_RESP_CONT_REQ:\n    cont_req_or_resp_data->rsp_data.rsp_cont_req = rsp_cont_req;\n    break;\n  case MAILIMAP_RESP_RESP_DATA:\n    cont_req_or_resp_data->rsp_data.rsp_resp_data = rsp_resp_data;\n    break;\n  }\n  \n  return cont_req_or_resp_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_cont_req_or_resp_data_free(struct mailimap_cont_req_or_resp_data *\n\t\t\t\t    cont_req_or_resp_data)\n{\n  switch (cont_req_or_resp_data->rsp_type) {\n  case MAILIMAP_RESP_CONT_REQ:\n    if (cont_req_or_resp_data->rsp_data.rsp_cont_req != NULL)\n      mailimap_continue_req_free(cont_req_or_resp_data->rsp_data.rsp_cont_req);\n    break;\n  case MAILIMAP_RESP_RESP_DATA:\n    if (cont_req_or_resp_data->rsp_data.rsp_resp_data != NULL)\n      mailimap_response_data_free(cont_req_or_resp_data->rsp_data.rsp_resp_data);\n    break;\n  }\n  free(cont_req_or_resp_data);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_response *\nmailimap_response_new(clist * rsp_cont_req_or_resp_data_list,\n    struct mailimap_response_done * rsp_resp_done)\n{\n  struct mailimap_response * resp;\n\n  resp = malloc(sizeof(* resp));\n  if (resp == NULL)\n    return NULL;\n\n  resp->rsp_cont_req_or_resp_data_list = rsp_cont_req_or_resp_data_list;\n  resp->rsp_resp_done = rsp_resp_done;\n\n  return resp;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_free(struct mailimap_response * resp)\n{\n  if (resp->rsp_cont_req_or_resp_data_list != NULL) {\n    clist_foreach(resp->rsp_cont_req_or_resp_data_list,\n        (clist_func) mailimap_cont_req_or_resp_data_free, NULL);\n    clist_free(resp->rsp_cont_req_or_resp_data_list);\n  }\n  mailimap_response_done_free(resp->rsp_resp_done);\n  free(resp);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_response_data *\nmailimap_response_data_new(int rsp_type,\n    struct mailimap_resp_cond_state * rsp_cond_state,\n    struct mailimap_resp_cond_bye * rsp_bye,\n    struct mailimap_mailbox_data * rsp_mailbox_data,\n    struct mailimap_message_data * rsp_message_data,\n    struct mailimap_capability_data * rsp_capability_data,\n    struct mailimap_extension_data * rsp_extension_data)\n{\n  struct mailimap_response_data * resp_data;\n\n  resp_data = malloc(sizeof(* resp_data));\n  if (resp_data == NULL)\n    return NULL;\n  resp_data->rsp_type = rsp_type;\n\n  switch (rsp_type) {\n  case MAILIMAP_RESP_DATA_TYPE_COND_STATE:\n    resp_data->rsp_data.rsp_cond_state = rsp_cond_state;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_COND_BYE:\n    resp_data->rsp_data.rsp_bye = rsp_bye;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MAILBOX_DATA:\n    resp_data->rsp_data.rsp_mailbox_data = rsp_mailbox_data;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MESSAGE_DATA:\n    resp_data->rsp_data.rsp_message_data = rsp_message_data;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_CAPABILITY_DATA:\n    resp_data->rsp_data.rsp_capability_data = rsp_capability_data;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_EXTENSION_DATA:\n    resp_data->rsp_data.rsp_extension_data = rsp_extension_data;\n    break;\n  }\n  \n  return resp_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_data_free(struct mailimap_response_data * resp_data)\n{\n  switch (resp_data->rsp_type) {\n  case MAILIMAP_RESP_DATA_TYPE_COND_STATE:\n    if (resp_data->rsp_data.rsp_cond_state != NULL)\n      mailimap_resp_cond_state_free(resp_data->rsp_data.rsp_cond_state);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_COND_BYE:\n    if (resp_data->rsp_data.rsp_bye != NULL)\n      mailimap_resp_cond_bye_free(resp_data->rsp_data.rsp_bye);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MAILBOX_DATA:\n    if (resp_data->rsp_data.rsp_mailbox_data != NULL)\n      mailimap_mailbox_data_free(resp_data->rsp_data.rsp_mailbox_data);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MESSAGE_DATA:\n    if (resp_data->rsp_data.rsp_message_data != NULL)\n      mailimap_message_data_free(resp_data->rsp_data.rsp_message_data);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_CAPABILITY_DATA:\n    if (resp_data->rsp_data.rsp_capability_data != NULL)\n      mailimap_capability_data_free(resp_data->rsp_data.rsp_capability_data);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_EXTENSION_DATA:\n    if (resp_data->rsp_data.rsp_extension_data != NULL)\n      mailimap_extension_data_free(resp_data->rsp_data.rsp_extension_data);\n    break;\n  }\n  free(resp_data);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_response_done *\nmailimap_response_done_new(int rsp_type,\n    struct mailimap_response_tagged * rsp_tagged,\n    struct mailimap_response_fatal * rsp_fatal)\n{\n  struct mailimap_response_done * resp_done;\n    \n  resp_done = malloc(sizeof(* resp_done));\n  if (resp_done == NULL)\n    return NULL;\n\n  resp_done->rsp_type = rsp_type;\n  switch (rsp_type) {\n  case MAILIMAP_RESP_DONE_TYPE_TAGGED:\n    resp_done->rsp_data.rsp_tagged = rsp_tagged;\n    break;\n  case MAILIMAP_RESP_DONE_TYPE_FATAL:\n    resp_done->rsp_data.rsp_fatal = rsp_fatal;\n    break;\n  }\n\n  return resp_done;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_response_done_free(struct mailimap_response_done *\n\t\t\t\t resp_done)\n{\n  switch (resp_done->rsp_type) {\n  case MAILIMAP_RESP_DONE_TYPE_TAGGED:\n    mailimap_response_tagged_free(resp_done->rsp_data.rsp_tagged);\n    break;\n  case MAILIMAP_RESP_DONE_TYPE_FATAL:\n    mailimap_response_fatal_free(resp_done->rsp_data.rsp_fatal);\n    break;\n  }\n  free(resp_done);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_response_fatal *\nmailimap_response_fatal_new(struct mailimap_resp_cond_bye * rsp_bye)\n{\n  struct mailimap_response_fatal * resp_fatal;\n\n  resp_fatal = malloc(sizeof(* resp_fatal));\n  if (resp_fatal == NULL)\n    return NULL;\n\n  resp_fatal->rsp_bye = rsp_bye;\n\n  return resp_fatal;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_response_fatal_free(struct mailimap_response_fatal * resp_fatal)\n{\n  mailimap_resp_cond_bye_free(resp_fatal->rsp_bye);\n  free(resp_fatal);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_response_tagged *\nmailimap_response_tagged_new(char * rsp_tag,\n    struct mailimap_resp_cond_state * rsp_cond_state)\n{\n  struct mailimap_response_tagged * resp_tagged;\n\n  resp_tagged = malloc(sizeof(* resp_tagged));\n  if (resp_tagged == NULL)\n    return NULL;\n\n  resp_tagged->rsp_tag = rsp_tag;\n  resp_tagged->rsp_cond_state = rsp_cond_state;\n\n  return resp_tagged;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_tagged_free(struct mailimap_response_tagged * tagged)\n{\n  mailimap_tag_free(tagged->rsp_tag);\n  mailimap_resp_cond_state_free(tagged->rsp_cond_state);\n  free(tagged);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_cond_auth *\nmailimap_resp_cond_auth_new(int rsp_type,\n    struct mailimap_resp_text * rsp_text)\n{\n  struct mailimap_resp_cond_auth * cond_auth;\n\n  cond_auth = malloc(sizeof(* cond_auth));\n  if (cond_auth == NULL)\n    return NULL;\n\n  cond_auth->rsp_type = rsp_type;\n  cond_auth->rsp_text = rsp_text;\n\n  return cond_auth;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_cond_auth_free(struct mailimap_resp_cond_auth * cond_auth)\n{\n  mailimap_resp_text_free(cond_auth->rsp_text);\n  free(cond_auth);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_cond_bye *\nmailimap_resp_cond_bye_new(struct mailimap_resp_text * rsp_text)\n{\n  struct mailimap_resp_cond_bye * cond_bye;\n\n  cond_bye = malloc(sizeof(* cond_bye));\n  if (cond_bye == NULL)\n    return NULL;\n\n  cond_bye->rsp_text = rsp_text;\n\n  return cond_bye;\n}\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_cond_bye_free(struct mailimap_resp_cond_bye * cond_bye)\n{\n  mailimap_resp_text_free(cond_bye->rsp_text);\n  free(cond_bye);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_cond_state *\nmailimap_resp_cond_state_new(int rsp_type,\n    struct mailimap_resp_text * rsp_text)\n{\n  struct mailimap_resp_cond_state * cond_state;\n\n  cond_state = malloc(sizeof(* cond_state));\n  if (cond_state == NULL)\n    return NULL;\n\n  cond_state->rsp_type = rsp_type;\n  cond_state->rsp_text = rsp_text;\n\n  return cond_state;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_cond_state_free(struct mailimap_resp_cond_state * cond_state)\n{\n  mailimap_resp_text_free(cond_state->rsp_text);\n  free(cond_state);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_text *\nmailimap_resp_text_new(struct mailimap_resp_text_code * rsp_code,\n    char * rsp_text)\n{\n  struct mailimap_resp_text * resp_text;\n\n  resp_text = malloc(sizeof(* resp_text));\n  if (resp_text == NULL)\n    return NULL;\n\n  resp_text->rsp_code = rsp_code;\n  resp_text->rsp_text = rsp_text;\n\n  return resp_text;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_resp_text_free(struct mailimap_resp_text * resp_text)\n{\n  if (resp_text->rsp_code)\n    mailimap_resp_text_code_free(resp_text->rsp_code);\n  if (resp_text->rsp_text)\n    mailimap_text_free(resp_text->rsp_text);\n  free(resp_text);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_text_code *\nmailimap_resp_text_code_new(int rc_type, clist * rc_badcharset,\n    struct mailimap_capability_data * rc_cap_data,\n    clist * rc_perm_flags,\n    uint32_t rc_uidnext, uint32_t rc_uidvalidity,\n    uint32_t rc_first_unseen, char * rc_atom, char * rc_atom_value,\n    struct mailimap_extension_data * rc_ext_data)\n{\n  struct mailimap_resp_text_code * resp_text_code;\n\n  resp_text_code = malloc(sizeof(* resp_text_code));\n  if (resp_text_code == NULL)\n    return NULL;\n\n  resp_text_code->rc_type = rc_type;\n  switch (rc_type) {\n  case MAILIMAP_RESP_TEXT_CODE_BADCHARSET:\n    resp_text_code->rc_data.rc_badcharset = rc_badcharset;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_CAPABILITY_DATA:\n    resp_text_code->rc_data.rc_cap_data = rc_cap_data;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_PERMANENTFLAGS:\n    resp_text_code->rc_data.rc_perm_flags = rc_perm_flags;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_UIDNEXT:\n    resp_text_code->rc_data.rc_uidnext = rc_uidnext;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_UIDVALIDITY:\n    resp_text_code->rc_data.rc_uidvalidity = rc_uidvalidity;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_UNSEEN:\n    resp_text_code->rc_data.rc_first_unseen = rc_first_unseen;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_OTHER:\n    resp_text_code->rc_data.rc_atom.atom_name = rc_atom;\n    resp_text_code->rc_data.rc_atom.atom_value = rc_atom_value;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_EXTENSION:\n    resp_text_code->rc_data.rc_ext_data = rc_ext_data;\n    break;\n  }\n\n  return resp_text_code;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_text_code_free(struct mailimap_resp_text_code * resp_text_code)\n{\n  switch (resp_text_code->rc_type) {\n  case MAILIMAP_RESP_TEXT_CODE_BADCHARSET:\n    if (resp_text_code->rc_data.rc_badcharset != NULL) {\n      clist_foreach(resp_text_code->rc_data.rc_badcharset,\n          (clist_func) mailimap_astring_free,\n          NULL);\n      clist_free(resp_text_code->rc_data.rc_badcharset);\n    }\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_CAPABILITY_DATA:\n    if (resp_text_code->rc_data.rc_cap_data != NULL)\n      mailimap_capability_data_free(resp_text_code->rc_data.rc_cap_data);\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_PERMANENTFLAGS:\n    if (resp_text_code->rc_data.rc_perm_flags != NULL) {\n      clist_foreach(resp_text_code->rc_data.rc_perm_flags,\n          (clist_func) mailimap_flag_perm_free, NULL);\n      clist_free(resp_text_code->rc_data.rc_perm_flags);\n    }\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_OTHER:\n    if (resp_text_code->rc_data.rc_atom.atom_name != NULL)\n      mailimap_atom_free(resp_text_code->rc_data.rc_atom.atom_name);\n    if (resp_text_code->rc_data.rc_atom.atom_value != NULL)\n      mailimap_custom_string_free(resp_text_code->rc_data.rc_atom.atom_value);\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_EXTENSION:\n    if (resp_text_code->rc_data.rc_ext_data != NULL)\n      mailimap_extension_data_free(resp_text_code->rc_data.rc_ext_data);\n    break;\n  }\n  free(resp_text_code);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section *\nmailimap_section_new(struct mailimap_section_spec * sec_spec)\n{\n  struct mailimap_section * section;\n\n  section = malloc(sizeof(* section));\n  if (section == NULL)\n    return NULL;\n  \n  section->sec_spec = sec_spec;\n\n  return section;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_section_free(struct mailimap_section * section)\n{\n  if (section->sec_spec != NULL)\n    mailimap_section_spec_free(section->sec_spec);\n  free(section);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_msgtext *\nmailimap_section_msgtext_new(int sec_type,\n    struct mailimap_header_list * sec_header_list)\n{\n  struct mailimap_section_msgtext * msgtext;\n\n  msgtext = malloc(sizeof(* msgtext));\n  if (msgtext == NULL)\n    return FALSE;\n\n  msgtext->sec_type = sec_type;\n  msgtext->sec_header_list = sec_header_list;\n\n  return msgtext;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_msgtext_free(struct mailimap_section_msgtext * msgtext)\n{\n  if (msgtext->sec_header_list != NULL)\n    mailimap_header_list_free(msgtext->sec_header_list);\n  free(msgtext);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_part *\nmailimap_section_part_new(clist * sec_id)\n{\n  struct mailimap_section_part * section_part;\n\n  section_part = malloc(sizeof(* section_part));\n  if (section_part == NULL)\n    return NULL;\n\n  section_part->sec_id = sec_id;\n\n  return section_part;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_part_free(struct mailimap_section_part * section_part)\n{\n  clist_foreach(section_part->sec_id,\n      (clist_func) mailimap_number_alloc_free, NULL);\n  clist_free(section_part->sec_id);\n  free(section_part);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_spec *\nmailimap_section_spec_new(int sec_type,\n    struct mailimap_section_msgtext * sec_msgtext,\n    struct mailimap_section_part * sec_part,\n    struct mailimap_section_text * sec_text)\n{\n  struct mailimap_section_spec * section_spec;\n\n  section_spec = malloc(sizeof(* section_spec));\n  if (section_spec == NULL)\n    return NULL;\n\n  section_spec->sec_type = sec_type;\n  switch (sec_type) {\n  case MAILIMAP_SECTION_SPEC_SECTION_MSGTEXT:\n    section_spec->sec_data.sec_msgtext = sec_msgtext;\n    break;\n  case MAILIMAP_SECTION_SPEC_SECTION_PART:\n    section_spec->sec_data.sec_part = sec_part;\n    break;\n  }\n  section_spec->sec_text = sec_text;\n\n  return section_spec;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_spec_free(struct mailimap_section_spec * section_spec)\n{\n  if (section_spec->sec_text)\n    mailimap_section_text_free(section_spec->sec_text);\n  \n  switch (section_spec->sec_type) {\n  case MAILIMAP_SECTION_SPEC_SECTION_PART:\n    if (section_spec->sec_data.sec_part != NULL)\n      mailimap_section_part_free(section_spec->sec_data.sec_part);\n    break;\n  case MAILIMAP_SECTION_SPEC_SECTION_MSGTEXT:\n    /* handle case where it can be detached */\n    if (section_spec->sec_data.sec_msgtext != NULL)\n      mailimap_section_msgtext_free(section_spec->sec_data.sec_msgtext);\n    break;\n  }\n  free(section_spec);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_text *\nmailimap_section_text_new(int sec_type,\n    struct mailimap_section_msgtext * sec_msgtext)\n{\n  struct mailimap_section_text * section_text;\n  \n  section_text = malloc(sizeof(* section_text));\n  if (section_text == NULL)\n    return NULL;\n\n  section_text->sec_type = sec_type;\n  section_text->sec_msgtext = sec_msgtext;\n  \n  return section_text;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_text_free(struct mailimap_section_text * section_text)\n{\n  if (section_text->sec_msgtext != NULL)\n    mailimap_section_msgtext_free(section_text->sec_msgtext);\n  free(section_text);\n}\n\n\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_string_free(char * str)\n{\n  mmap_string_unref(str);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_tag_free(char * tag)\n{\n  mailimap_custom_string_free(tag);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_text_free(char * text)\n{\n  mailimap_custom_string_free(text);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n\n\n\n\n\n\n/* sender only */\n\n\n/* COPY FETCH SEARCH STORE */\n/* set */\n\nLIBETPAN_EXPORT\nstruct mailimap_set_item *\nmailimap_set_item_new(uint32_t set_first, uint32_t set_last)\n{\n  struct mailimap_set_item * item;\n\n  item = malloc(sizeof(* item));\n  if (item == NULL)\n    return NULL;\n\n  item->set_first = set_first;\n  item->set_last = set_last;\n\n  return item;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_set_item_free(struct mailimap_set_item * set_item)\n{\n  free(set_item);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_set * mailimap_set_new(clist * set_list)\n{\n  struct mailimap_set * set;\n\n  set = malloc(sizeof(* set));\n  if (set == NULL)\n    return NULL;\n\n  set->set_list = set_list;\n\n  return set;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_set_free(struct mailimap_set * set)\n{\n  clist_foreach(set->set_list, (clist_func) mailimap_set_item_free, NULL);\n  clist_free(set->set_list);\n  free(set);\n}\n\n/* SEARCH with date key */\n/* date */\n\nLIBETPAN_EXPORT\nstruct mailimap_date *\nmailimap_date_new(int dt_day, int dt_month, int dt_year)\n{\n  struct mailimap_date * date;\n\n  date = malloc(sizeof(* date));\n  if (date == NULL)\n    return NULL;\n\n  date->dt_day = dt_day;\n  date->dt_month = dt_month;\n  date->dt_year = dt_year;\n\n  return date;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_date_free(struct mailimap_date * date)\n{\n  free(date);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_fetch_att *\nmailimap_fetch_att_new(int att_type, struct mailimap_section * att_section,\n                       uint32_t att_offset, uint32_t att_size, char * att_extension)\n{\n  struct mailimap_fetch_att * fetch_att;\n\n  fetch_att = malloc(sizeof(* fetch_att));\n  if (fetch_att == NULL)\n    return NULL;\n  fetch_att->att_type = att_type;\n  fetch_att->att_section = att_section;\n  fetch_att->att_offset = att_offset;\n  fetch_att->att_size = att_size;\n  fetch_att->att_extension = att_extension;\n\n  return fetch_att;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_fetch_att_free(struct mailimap_fetch_att * fetch_att)\n{\n  if (fetch_att->att_extension != NULL)\n    free(fetch_att->att_extension);\n  if (fetch_att->att_section != NULL)\n    mailimap_section_free(fetch_att->att_section);\n  free(fetch_att);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_fetch_type *\nmailimap_fetch_type_new(int ft_type,\n    struct mailimap_fetch_att * ft_fetch_att,\n    clist * ft_fetch_att_list)\n{\n  struct mailimap_fetch_type * fetch_type;\n\n  fetch_type = malloc(sizeof(* fetch_type));\n  if (fetch_type == NULL)\n    return NULL;\n  fetch_type->ft_type = ft_type;\n  switch (ft_type) {\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT:\n    fetch_type->ft_data.ft_fetch_att = ft_fetch_att;\n    break;\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT_LIST:\n    fetch_type->ft_data.ft_fetch_att_list = ft_fetch_att_list;\n    break;\n  }\n  \n  return fetch_type;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_fetch_type_free(struct mailimap_fetch_type * fetch_type)\n{\n  switch (fetch_type->ft_type) {\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT:\n    mailimap_fetch_att_free(fetch_type->ft_data.ft_fetch_att);\n    break;\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT_LIST:\n    clist_foreach(fetch_type->ft_data.ft_fetch_att_list,\n        (clist_func) mailimap_fetch_att_free, NULL);\n    clist_free(fetch_type->ft_data.ft_fetch_att_list);\n    break;\n  }\n  free(fetch_type);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_store_att_flags *\nmailimap_store_att_flags_new(int fl_sign, int fl_silent,\n    struct mailimap_flag_list * fl_flag_list)\n{\n  struct mailimap_store_att_flags * store_att_flags;\n\n  store_att_flags = malloc(sizeof(* store_att_flags));\n  if (store_att_flags == NULL)\n    return NULL;\n\n  store_att_flags->fl_sign = fl_sign;\n  store_att_flags->fl_silent = fl_silent;\n  store_att_flags->fl_flag_list = fl_flag_list;\n  \n  return store_att_flags;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_store_att_flags_free(struct mailimap_store_att_flags *\n\t\t\t\t   store_att_flags)\n{\n  mailimap_flag_list_free(store_att_flags->fl_flag_list);\n  free(store_att_flags);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new(int sk_type,\n    char * sk_bcc, struct mailimap_date * sk_before, char * sk_body,\n    char * sk_cc, char * sk_from, char * sk_keyword,\n    struct mailimap_date * sk_on, struct mailimap_date * sk_since,\n    char * sk_subject, char * sk_text, char * sk_to,\n    char * sk_unkeyword, char * sk_header_name,\n    char * sk_header_value, uint32_t sk_larger,\n    struct mailimap_search_key * sk_not,\n    struct mailimap_search_key * sk_or1,\n    struct mailimap_search_key * sk_or2,\n    struct mailimap_date * sk_sentbefore,\n    struct mailimap_date * sk_senton,\n    struct mailimap_date * sk_sentsince,\n    uint32_t sk_smaller, struct mailimap_set * sk_uid,\n    struct mailimap_set * sk_set, clist * sk_multiple)\n{\n  struct mailimap_search_key * key;\n\n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = sk_type;\n  switch (sk_type) {\n  case MAILIMAP_SEARCH_KEY_BCC:\n    key->sk_data.sk_bcc = sk_bcc;\n    break;\n  case MAILIMAP_SEARCH_KEY_BEFORE:\n    key->sk_data.sk_before = sk_before;\n    break;\n  case MAILIMAP_SEARCH_KEY_BODY:\n    key->sk_data.sk_body = sk_body;\n    break;\n  case MAILIMAP_SEARCH_KEY_CC:\n    key->sk_data.sk_cc = sk_cc;\n    break;\n  case MAILIMAP_SEARCH_KEY_FROM:\n    key->sk_data.sk_from = sk_from;\n    break;\n  case MAILIMAP_SEARCH_KEY_KEYWORD:\n    key->sk_data.sk_keyword = sk_keyword;\n    break;\n  case MAILIMAP_SEARCH_KEY_ON:\n    key->sk_data.sk_on = sk_on;\n    break;\n  case MAILIMAP_SEARCH_KEY_SINCE:\n    key->sk_data.sk_since = sk_since;\n    break;\n  case MAILIMAP_SEARCH_KEY_SUBJECT:\n    key->sk_data.sk_subject = sk_subject;\n    break;\n  case MAILIMAP_SEARCH_KEY_TEXT:\n    key->sk_data.sk_text = sk_text;\n    break;\n  case MAILIMAP_SEARCH_KEY_TO:\n    key->sk_data.sk_to = sk_to;\n    break;\n  case MAILIMAP_SEARCH_KEY_UNKEYWORD:\n    key->sk_data.sk_unkeyword = sk_unkeyword;\n    break;\n  case MAILIMAP_SEARCH_KEY_HEADER:\n    key->sk_data.sk_header.sk_header_name = sk_header_name;\n    key->sk_data.sk_header.sk_header_value = sk_header_value;\n    break;\n  case MAILIMAP_SEARCH_KEY_LARGER:\n    key->sk_data.sk_larger = sk_larger;\n    break;\n  case MAILIMAP_SEARCH_KEY_NOT:\n    key->sk_data.sk_not = sk_not;\n    break;\n  case MAILIMAP_SEARCH_KEY_OR:\n    key->sk_data.sk_or.sk_or1 = sk_or1;\n    key->sk_data.sk_or.sk_or2 = sk_or2;\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTBEFORE:\n    key->sk_data.sk_sentbefore = sk_sentbefore;\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTON:\n    key->sk_data.sk_senton = sk_senton;\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTSINCE:\n    key->sk_data.sk_sentsince = sk_sentsince;\n    break;\n  case MAILIMAP_SEARCH_KEY_SMALLER:\n    key->sk_data.sk_smaller = sk_smaller;\n    break;\n  case MAILIMAP_SEARCH_KEY_UID:\n    key->sk_data.sk_uid = sk_uid;\n    break;\n  case MAILIMAP_SEARCH_KEY_SET:\n    key->sk_data.sk_set = sk_set;\n    break;\n  case MAILIMAP_SEARCH_KEY_MULTIPLE:\n    key->sk_data.sk_multiple = sk_multiple;\n    break;\n  }\n  return key;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new_xgmthrid(uint64_t sk_xgmthrid)\n{\n  struct mailimap_search_key * key;\n  \n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = MAILIMAP_SEARCH_KEY_XGMTHRID;\n  key->sk_data.sk_xgmthrid = sk_xgmthrid;\n\n  return key;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new_xgmmsgid(uint64_t sk_xgmmsgid)\n{\n  struct mailimap_search_key * key;\n  \n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = MAILIMAP_SEARCH_KEY_XGMMSGID;\n  key->sk_data.sk_xgmmsgid = sk_xgmmsgid;\n  \n  return key;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new_xgmraw(char * sk_xgmraw)\n{\n  struct mailimap_search_key * key;\n  \n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = MAILIMAP_SEARCH_KEY_XGMRAW;\n  key->sk_data.sk_xgmraw = sk_xgmraw;\n  \n  return key;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_search_key_free(struct mailimap_search_key * key)\n{\n  switch (key->sk_type) {\n  case MAILIMAP_SEARCH_KEY_BCC:\n    mailimap_astring_free(key->sk_data.sk_bcc);\n    break;\n  case MAILIMAP_SEARCH_KEY_BEFORE:\n    mailimap_date_free(key->sk_data.sk_before);\n    break;\n  case MAILIMAP_SEARCH_KEY_BODY:\n    mailimap_astring_free(key->sk_data.sk_body);\n    break;\n  case MAILIMAP_SEARCH_KEY_CC:\n    mailimap_astring_free(key->sk_data.sk_cc);\n    break;\n  case MAILIMAP_SEARCH_KEY_FROM:\n    mailimap_astring_free(key->sk_data.sk_from);\n    break;\n  case MAILIMAP_SEARCH_KEY_KEYWORD:\n    mailimap_flag_keyword_free(key->sk_data.sk_keyword);\n    break;\n  case MAILIMAP_SEARCH_KEY_ON:\n    mailimap_date_free(key->sk_data.sk_on);\n    break;\n  case MAILIMAP_SEARCH_KEY_SINCE:\n    mailimap_date_free(key->sk_data.sk_since);\n    break;\n  case MAILIMAP_SEARCH_KEY_SUBJECT:\n    mailimap_astring_free(key->sk_data.sk_subject);\n    break;\n  case MAILIMAP_SEARCH_KEY_TEXT:\n    mailimap_astring_free(key->sk_data.sk_text);\n    break;\n  case MAILIMAP_SEARCH_KEY_TO:\n    mailimap_astring_free(key->sk_data.sk_to);\n    break;\n  case MAILIMAP_SEARCH_KEY_UNKEYWORD:\n    mailimap_flag_keyword_free(key->sk_data.sk_unkeyword);\n    break;\n  case MAILIMAP_SEARCH_KEY_HEADER:\n    mailimap_header_fld_name_free(key->sk_data.sk_header.sk_header_name);\n    mailimap_astring_free(key->sk_data.sk_header.sk_header_value);\n    break;\n  case MAILIMAP_SEARCH_KEY_NOT:\n    mailimap_search_key_free(key->sk_data.sk_not);\n    break;\n  case MAILIMAP_SEARCH_KEY_OR:\n    mailimap_search_key_free(key->sk_data.sk_or.sk_or1);\n    mailimap_search_key_free(key->sk_data.sk_or.sk_or2);\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTBEFORE:\n    mailimap_date_free(key->sk_data.sk_sentbefore);\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTON:\n    mailimap_date_free(key->sk_data.sk_senton);\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTSINCE:\n    mailimap_date_free(key->sk_data.sk_sentsince);\n    break;\n  case MAILIMAP_SEARCH_KEY_UID:\n    mailimap_set_free(key->sk_data.sk_uid);\n    break;\n  case MAILIMAP_SEARCH_KEY_SET:\n    mailimap_set_free(key->sk_data.sk_set);\n    break;\n  case MAILIMAP_SEARCH_KEY_MULTIPLE:\n    clist_foreach(key->sk_data.sk_multiple,\n        (clist_func) mailimap_search_key_free, NULL);\n    clist_free(key->sk_data.sk_multiple);\n    break;\n  case MAILIMAP_SEARCH_KEY_MODSEQ:\n    if (key->sk_data.sk_modseq.sk_entry_name != NULL) {\n      mailimap_flag_free(key->sk_data.sk_modseq.sk_entry_name);\n    }\n    break;\n  case MAILIMAP_SEARCH_KEY_XGMRAW:\n    mailimap_astring_free(key->sk_data.sk_xgmraw);\n    break;\n  }\n  \n  free(key);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_status_att_list *\nmailimap_status_att_list_new(clist * att_list)\n{\n  struct mailimap_status_att_list * status_att_list;\n\n  status_att_list = malloc(sizeof(* status_att_list));\n  if (status_att_list == NULL)\n    return NULL;\n  status_att_list->att_list = att_list;\n\n  return status_att_list;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_status_att_list_free(struct mailimap_status_att_list *\n\t\t\t\t   status_att_list)\n{\n  clist_foreach(status_att_list->att_list, (clist_func) free, NULL);\n  clist_free(status_att_list->att_list);\n  free(status_att_list);\n}\n\n\n\n\n/* main */\n\n\nLIBETPAN_EXPORT\nstruct mailimap_selection_info *\nmailimap_selection_info_new(void)\n{\n  struct mailimap_selection_info * sel_info;\n\n  sel_info = malloc(sizeof(* sel_info));\n  if (sel_info == NULL)\n    return NULL;\n\n  sel_info->sel_perm_flags = NULL;\n  sel_info->sel_perm = MAILIMAP_MAILBOX_READWRITE;\n  sel_info->sel_uidnext = 0;\n  sel_info->sel_uidvalidity = 0;\n  sel_info->sel_first_unseen = 0;\n  sel_info->sel_flags = NULL;\n  sel_info->sel_exists = 0;\n  sel_info->sel_recent = 0;\n  sel_info->sel_unseen = 0;\n  sel_info->sel_has_exists = 0;\n  sel_info->sel_has_recent = 0 ;\n\n  return sel_info;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_selection_info_free(struct mailimap_selection_info * sel_info)\n{\n  if (sel_info->sel_perm_flags != NULL) {\n    clist_foreach(sel_info->sel_perm_flags,\n        (clist_func) mailimap_flag_perm_free, NULL);\n    clist_free(sel_info->sel_perm_flags);\n  }\n  if (sel_info->sel_flags)\n    mailimap_flag_list_free(sel_info->sel_flags);\n\n  free(sel_info);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_connection_info *\nmailimap_connection_info_new(void)\n{\n  struct mailimap_connection_info * conn_info;\n\n  conn_info = malloc(sizeof(* conn_info));\n  if (conn_info == NULL)\n    return NULL;\n  \n  conn_info->imap_capability = NULL;\n\n  return conn_info;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_connection_info_free(struct mailimap_connection_info * conn_info)\n{\n  if (conn_info->imap_capability != NULL)\n    mailimap_capability_data_free(conn_info->imap_capability);\n  free(conn_info);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_response_info *\nmailimap_response_info_new(void)\n{\n  struct mailimap_response_info * resp_info;\n\n  resp_info = malloc(sizeof(* resp_info));\n  if (resp_info == NULL)\n    goto err;\n\n  resp_info->rsp_alert = NULL;\n  resp_info->rsp_parse = NULL;\n  resp_info->rsp_badcharset = NULL;\n  resp_info->rsp_trycreate = FALSE;\n  resp_info->rsp_mailbox_list = clist_new();\n  if (resp_info->rsp_mailbox_list == NULL)\n    goto free;\n  resp_info->rsp_extension_list = clist_new();\n  if (resp_info->rsp_extension_list == NULL)\n    goto free_mb_list;\n  resp_info->rsp_mailbox_lsub = clist_new();\n  if (resp_info->rsp_mailbox_lsub == NULL)\n    goto free_extension_list;\n  resp_info->rsp_search_result = clist_new();\n  if (resp_info->rsp_search_result == NULL)\n    goto free_mb_lsub;\n  resp_info->rsp_status = NULL;\n  resp_info->rsp_expunged = clist_new();\n  if (resp_info->rsp_expunged == NULL)\n    goto free_search_result;\n  resp_info->rsp_fetch_list = clist_new();\n  if (resp_info->rsp_fetch_list == NULL)\n    goto free_expunged;\n  resp_info->rsp_atom = NULL;\n  resp_info->rsp_value = NULL;\n  \n  return resp_info;\n\n free_expunged:\n  clist_free(resp_info->rsp_expunged);\n free_search_result:\n  clist_free(resp_info->rsp_search_result);\n free_mb_lsub:\n  clist_free(resp_info->rsp_mailbox_lsub);\n free_extension_list:\n  clist_free(resp_info->rsp_extension_list);\n free_mb_list:\n  clist_free(resp_info->rsp_mailbox_list);\n free:\n  free(resp_info);\n err:\n  return NULL;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_info_free(struct mailimap_response_info * resp_info)\n{\n  free(resp_info->rsp_value);\n  free(resp_info->rsp_atom);\n  if (resp_info->rsp_alert != NULL)\n    free(resp_info->rsp_alert);\n  if (resp_info->rsp_parse != NULL)\n    free(resp_info->rsp_parse);\n  if (resp_info->rsp_badcharset != NULL) {\n    clist_foreach(resp_info->rsp_badcharset,\n        (clist_func) mailimap_astring_free, NULL);\n    clist_free(resp_info->rsp_badcharset);\n  }\n  if (resp_info->rsp_mailbox_list != NULL) {\n    clist_foreach(resp_info->rsp_mailbox_list,\n        (clist_func) mailimap_mailbox_list_free, NULL);\n    clist_free(resp_info->rsp_mailbox_list);\n  }\n  if (resp_info->rsp_extension_list != NULL) {\n    clist_foreach(resp_info->rsp_extension_list,\n      (clist_func) mailimap_extension_data_free, NULL);\n    clist_free(resp_info->rsp_extension_list);\n  }\n  if (resp_info->rsp_mailbox_lsub != NULL) {\n    clist_foreach(resp_info->rsp_mailbox_lsub,\n        (clist_func) mailimap_mailbox_list_free, NULL);\n    clist_free(resp_info->rsp_mailbox_lsub);\n  }\n  if (resp_info->rsp_search_result != NULL)\n    mailimap_mailbox_data_search_free(resp_info->rsp_search_result);\n  if (resp_info->rsp_status != NULL)\n    mailimap_mailbox_data_status_free(resp_info->rsp_status);\n  if (resp_info->rsp_expunged != NULL) {\n    clist_foreach(resp_info->rsp_expunged,\n\t\t   (clist_func) mailimap_number_alloc_free, NULL);\n    clist_free(resp_info->rsp_expunged);\n  }\n  if (resp_info->rsp_fetch_list != NULL) {\n    clist_foreach(resp_info->rsp_fetch_list,\n\t\t  (clist_func) mailimap_msg_att_free, NULL);\n    clist_free(resp_info->rsp_fetch_list);\n  }\n\n  free(resp_info);\n}\n\n\nLIBETPAN_EXPORT\nint\nmailimap_parser_context_is_rambler_workaround_enabled(struct mailimap_parser_context * parser_ctx)\n{\n  return parser_ctx != NULL && parser_ctx->is_rambler_workaround_enabled;\n}\n\nLIBETPAN_EXPORT\nint\nmailimap_parser_context_is_qip_workaround_enabled(struct mailimap_parser_context * parser_ctx)\n{\n  return parser_ctx != NULL && parser_ctx->is_qip_workaround_enabled;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_parser_context *\nmailimap_parser_context_new(mailimap * session)\n{\n  struct mailimap_parser_context * ctx;\n\n  ctx = malloc(sizeof(* ctx));\n  if (ctx == NULL)\n    goto err;\n\n  ctx->is_rambler_workaround_enabled = mailimap_is_rambler_workaround_enabled(session);\n  ctx->is_qip_workaround_enabled = mailimap_is_qip_workaround_enabled(session);\n\n  ctx->msg_body_handler = session->imap_msg_body_handler;\n  ctx->msg_body_handler_context = session->imap_msg_body_handler_context;\n  ctx->msg_body_parse_in_progress = false;\n  ctx->msg_body_section = NULL;\n  ctx->msg_body_att_type = 0;\n\n  return ctx;\n\nerr:\n  return NULL;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_parser_context_free(struct mailimap_parser_context * ctx)\n{\n  free(ctx);\n}\n"], "fixing_code": ["/*\n * libEtPan! -- a mail stuff library\n *\n * Copyright (C) 2001, 2005 - DINH Viet Hoa\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the libEtPan! project nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * $Id: mailimap_types.c,v 1.31 2011/03/16 22:40:04 hoa Exp $\n */\n\n#ifdef HAVE_CONFIG_H\n#\tinclude <config.h>\n#endif\n\n#include \"mailimap_types.h\"\n#include \"mmapstring.h\"\n#include \"mail.h\"\n#include \"mailimap_extension.h\"\n#include \"mailimap.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n\n\n\n\n\n\n/* from parser */\n\n\nLIBETPAN_EXPORT\nuint32_t * mailimap_number_alloc_new(uint32_t number)\n{\n  uint32_t * pnumber;\n\n  pnumber = malloc(sizeof(* pnumber));\n  if (pnumber == NULL)\n    return NULL;\n\n  * pnumber = number;\n\n  return pnumber;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_number_alloc_free(uint32_t * pnumber)\n{\n  free(pnumber);\n}\n\n\n/* ************************************************************************* */\n\n\nLIBETPAN_EXPORT\nstruct mailimap_address *\nmailimap_address_new(char * ad_personal_name, char * ad_source_route,\n\t\t     char * ad_mailbox_name, char * ad_host_name)\n{\n  struct mailimap_address * addr;\n\n  addr = malloc(sizeof(* addr));\n  if (addr == NULL)\n    return NULL;\n\n  addr->ad_personal_name = ad_personal_name;\n  addr->ad_source_route = ad_source_route;\n  addr->ad_mailbox_name = ad_mailbox_name;\n  addr->ad_host_name = ad_host_name;\n\n  return addr;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_address_free(struct mailimap_address * addr)\n{\n  mailimap_addr_host_free(addr->ad_host_name);\n  mailimap_addr_mailbox_free(addr->ad_mailbox_name);\n  mailimap_addr_adl_free(addr->ad_source_route);\n  mailimap_addr_name_free(addr->ad_personal_name);\n  free(addr);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_host_free(char * addr_host)\n{\n  mailimap_nstring_free(addr_host);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_mailbox_free(char * addr_mailbox)\n{\n  mailimap_nstring_free(addr_mailbox);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_adl_free(char * addr_adl)\n{\n  mailimap_nstring_free(addr_adl);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_addr_name_free(char * addr_name)\n{\n  mailimap_nstring_free(addr_name);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_astring_free(char * astring)\n{\n  if (mmap_string_unref(astring) != 0)\n    free(astring);\n}\n\nstatic void mailimap_custom_string_free(char * str)\n{\n  free(str);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_atom_free(char * atom)\n{\n  free(atom);\n}\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_auth_type_free(char * auth_type)\n{\n  mailimap_atom_free(auth_type);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_base64_free(char * base64)\n{\n  free(base64);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body *\nmailimap_body_new(int bd_type,\n\t\t  struct mailimap_body_type_1part * bd_body_1part,\n\t\t  struct mailimap_body_type_mpart * bd_body_mpart)\n{\n  struct mailimap_body * body;\n  \n  body = malloc(sizeof(* body));\n  if (body == NULL)\n    return NULL;\n\n  body->bd_type = bd_type;\n  switch (bd_type) {\n  case MAILIMAP_BODY_1PART:\n    body->bd_data.bd_body_1part = bd_body_1part;\n    break;\n  case MAILIMAP_BODY_MPART:\n    body->bd_data.bd_body_mpart = bd_body_mpart;\n    break;\n  }\n  \n  return body;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_free(struct mailimap_body * body)\n{\n  switch (body->bd_type) {\n  case MAILIMAP_BODY_1PART:\n    mailimap_body_type_1part_free(body->bd_data.bd_body_1part);\n    break;\n  case MAILIMAP_BODY_MPART:\n    mailimap_body_type_mpart_free(body->bd_data.bd_body_mpart);\n    break;\n  }\n  free(body);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_extension *\nmailimap_body_extension_new(int ext_type, char * ext_nstring,\n\t\t\t    uint32_t ext_number,\n    clist * ext_body_extension_list)\n{\n  struct mailimap_body_extension * body_extension;\n\n  body_extension = malloc(sizeof(* body_extension));\n  if (body_extension == NULL)\n    return NULL;\n\n  body_extension->ext_type = ext_type;\n  switch (ext_type) {\n  case MAILIMAP_BODY_EXTENSION_NSTRING:\n    body_extension->ext_data.ext_nstring = ext_nstring;\n    break;\n  case MAILIMAP_BODY_EXTENSION_NUMBER:\n    body_extension->ext_data.ext_number = ext_number;\n    break;\n  case MAILIMAP_BODY_EXTENSION_LIST:\n    body_extension->ext_data.ext_body_extension_list = ext_body_extension_list;\n    break;\n  }\n  \n  return body_extension;\n}\n\nstatic void\nmailimap_body_ext_list_free(clist * body_ext_list);\n\nLIBETPAN_EXPORT\nvoid mailimap_body_extension_free(struct mailimap_body_extension * be)\n{\n  switch (be->ext_type) {\n  case MAILIMAP_BODY_EXTENSION_NSTRING:\n    mailimap_nstring_free(be->ext_data.ext_nstring);\n    break;\n  case MAILIMAP_BODY_EXTENSION_LIST:\n    mailimap_body_ext_list_free(be->ext_data.ext_body_extension_list);\n    break;\n  }\n  \n  free(be);\n}\n\n\nstatic void\nmailimap_body_ext_list_free(clist * body_ext_list)\n{\n  clist_foreach(body_ext_list, (clist_func) mailimap_body_extension_free,\n\t\tNULL);\n  clist_free(body_ext_list);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_ext_1part *\nmailimap_body_ext_1part_new(char * bd_md5,\n\t\t\t    struct mailimap_body_fld_dsp * bd_disposition,\n\t\t\t    struct mailimap_body_fld_lang * bd_language,\n          char * bd_loc,\n\t\t\t    clist * bd_extension_list)\n{\n  struct mailimap_body_ext_1part * body_ext_1part;\n  \n  body_ext_1part = malloc(sizeof(* body_ext_1part));\n  if (body_ext_1part == NULL)\n    return NULL;\n\n  body_ext_1part->bd_md5 = bd_md5;\n  body_ext_1part->bd_disposition = bd_disposition;\n  body_ext_1part->bd_language = bd_language;\n  body_ext_1part->bd_loc = bd_loc;\n  body_ext_1part->bd_extension_list = bd_extension_list;\n\n  return body_ext_1part;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_ext_1part_free(struct mailimap_body_ext_1part * body_ext_1part)\n{\n  mailimap_body_fld_md5_free(body_ext_1part->bd_md5);\n  if (body_ext_1part->bd_disposition)\n    mailimap_body_fld_dsp_free(body_ext_1part->bd_disposition);\n  if (body_ext_1part->bd_language)\n    mailimap_body_fld_lang_free(body_ext_1part->bd_language);\n  if (body_ext_1part->bd_extension_list)\n    mailimap_body_ext_list_free(body_ext_1part->bd_extension_list);\n  mailimap_body_fld_loc_free(body_ext_1part->bd_loc);\n\n  free(body_ext_1part);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_body_ext_mpart *\nmailimap_body_ext_mpart_new(struct mailimap_body_fld_param * bd_parameter,\n                            struct mailimap_body_fld_dsp * bd_disposition,\n                            struct mailimap_body_fld_lang * bd_language,\n                            char * bd_loc,\n                            clist * bd_extension_list)\n{\n  struct mailimap_body_ext_mpart * body_ext_mpart;\n\n  body_ext_mpart = malloc(sizeof(* body_ext_mpart));\n  if (body_ext_mpart == NULL)\n    return NULL;\n\n  body_ext_mpart->bd_parameter = bd_parameter;\n  body_ext_mpart->bd_disposition = bd_disposition;\n  body_ext_mpart->bd_language = bd_language;\n  body_ext_mpart->bd_extension_list = bd_extension_list;\n  body_ext_mpart->bd_loc = bd_loc;\n\n  return body_ext_mpart;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_ext_mpart_free(struct mailimap_body_ext_mpart * body_ext_mpart)\n{\n  if (body_ext_mpart->bd_parameter != NULL)\n    mailimap_body_fld_param_free(body_ext_mpart->bd_parameter);\n  if (body_ext_mpart->bd_disposition)\n    mailimap_body_fld_dsp_free(body_ext_mpart->bd_disposition);\n  if (body_ext_mpart->bd_language)\n    mailimap_body_fld_lang_free(body_ext_mpart->bd_language);\n  if (body_ext_mpart->bd_extension_list)\n    mailimap_body_ext_list_free(body_ext_mpart->bd_extension_list);\n  mailimap_body_fld_loc_free(body_ext_mpart->bd_loc);\n  free(body_ext_mpart);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fields *\nmailimap_body_fields_new(struct mailimap_body_fld_param * bd_parameter,\n\t\t\t char * bd_id,\n\t\t\t char * bd_description,\n\t\t\t struct mailimap_body_fld_enc * bd_encoding,\n\t\t\t uint32_t bd_size)\n{\n  struct mailimap_body_fields * body_fields;\n\n  body_fields = malloc(sizeof(* body_fields));\n  if (body_fields == NULL)\n    return NULL;\n  body_fields->bd_parameter = bd_parameter;\n  body_fields->bd_id = bd_id;\n  body_fields->bd_description = bd_description;\n  body_fields->bd_encoding = bd_encoding;\n  body_fields->bd_size = bd_size;\n\n  return body_fields;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_fields_free(struct mailimap_body_fields * body_fields)\n{\n  if (body_fields->bd_parameter != NULL)\n    mailimap_body_fld_param_free(body_fields->bd_parameter);\n  mailimap_body_fld_id_free(body_fields->bd_id);\n  mailimap_body_fld_desc_free(body_fields->bd_description);\n  mailimap_body_fld_enc_free(body_fields->bd_encoding);\n  free(body_fields);\n}\n\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_desc_free(char * body_fld_desc)\n{\n  mailimap_nstring_free(body_fld_desc);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_dsp *\nmailimap_body_fld_dsp_new(char * dsp_type,\n    struct mailimap_body_fld_param * dsp_attributes)\n{\n  struct mailimap_body_fld_dsp * body_fld_dsp;\n\n  body_fld_dsp = malloc(sizeof(* body_fld_dsp));\n  if (body_fld_dsp == NULL)\n    return NULL;\n\n  body_fld_dsp->dsp_type = dsp_type;\n  body_fld_dsp->dsp_attributes = dsp_attributes;\n\n  return body_fld_dsp;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_dsp_free(struct mailimap_body_fld_dsp * bfd)\n{\n  if (bfd->dsp_type != NULL)\n    mailimap_string_free(bfd->dsp_type);\n  if (bfd->dsp_attributes != NULL)\n    mailimap_body_fld_param_free(bfd->dsp_attributes);\n  free(bfd);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_enc *\nmailimap_body_fld_enc_new(int enc_type, char * enc_value)\n{\n  struct mailimap_body_fld_enc * body_fld_enc;\n\n  body_fld_enc = malloc(sizeof(* body_fld_enc));\n  if (body_fld_enc == NULL)\n    return NULL;\n  \n  body_fld_enc->enc_type = enc_type;\n  body_fld_enc->enc_value = enc_value;\n\n  return body_fld_enc;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_enc_free(struct mailimap_body_fld_enc * bfe)\n{\n  if (bfe->enc_value)\n    mailimap_string_free(bfe->enc_value);\n  free(bfe);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_id_free(char * body_fld_id)\n{\n  mailimap_nstring_free(body_fld_id);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_lang *\nmailimap_body_fld_lang_new(int lg_type, char * lg_single, clist * lg_list)\n{\n  struct mailimap_body_fld_lang * fld_lang;\n\n  fld_lang = malloc(sizeof(* fld_lang));\n  if (fld_lang == NULL)\n    return NULL;\n  \n  fld_lang->lg_type = lg_type;\n  switch (lg_type) {\n  case MAILIMAP_BODY_FLD_LANG_SINGLE:\n    fld_lang->lg_data.lg_single = lg_single;\n    break;\n  case MAILIMAP_BODY_FLD_LANG_LIST:\n    fld_lang->lg_data.lg_list = lg_list;\n    break;\n  }\n\n  return fld_lang;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_fld_lang_free(struct mailimap_body_fld_lang * fld_lang)\n{\n  switch (fld_lang->lg_type) {\n  case MAILIMAP_BODY_FLD_LANG_SINGLE:\n    mailimap_nstring_free(fld_lang->lg_data.lg_single);\n    break;\n  case MAILIMAP_BODY_FLD_LANG_LIST:\n    clist_foreach(fld_lang->lg_data.lg_list,\n        (clist_func) mailimap_string_free, NULL);\n    clist_free(fld_lang->lg_data.lg_list);\n    break;\n  }\n  free(fld_lang);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_md5_free(char * body_fld_md5)\n{\n  mailimap_nstring_free(body_fld_md5);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_fld_loc_free(char * body_fld_loc)\n{\n  mailimap_nstring_free(body_fld_loc);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_single_body_fld_param *\nmailimap_single_body_fld_param_new(char * pa_name, char * pa_value)\n{\n  struct mailimap_single_body_fld_param * param;\n\n  param = malloc(sizeof(* param));\n  if (param == NULL)\n    return NULL;\n  param->pa_name = pa_name;\n  param->pa_value = pa_value;\n\n  return param;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_single_body_fld_param_free(struct mailimap_single_body_fld_param * p)\n{\n  mailimap_string_free(p->pa_name);\n  mailimap_string_free(p->pa_value);\n  free(p);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_fld_param *\nmailimap_body_fld_param_new(clist * pa_list)\n{\n  struct mailimap_body_fld_param * fld_param;\n\n  fld_param = malloc(sizeof(* fld_param));\n  if (fld_param == NULL)\n    return NULL;\n  fld_param->pa_list = pa_list;\n\n  return fld_param;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_fld_param_free(struct mailimap_body_fld_param * fld_param)\n{\n  clist_foreach(fld_param->pa_list,\n\t\t(clist_func) mailimap_single_body_fld_param_free, NULL);\n  clist_free(fld_param->pa_list);\n  free(fld_param);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_1part *\nmailimap_body_type_1part_new(int bd_type,\n\t\t\t     struct mailimap_body_type_basic * bd_type_basic,\n\t\t\t     struct mailimap_body_type_msg * bd_type_msg,\n\t\t\t     struct mailimap_body_type_text * bd_type_text,\n\t\t\t     struct mailimap_body_ext_1part * bd_ext_1part)\n{\n  struct mailimap_body_type_1part * body_type_1part;\n\n  body_type_1part = malloc(sizeof(* body_type_1part));\n  if (body_type_1part == NULL)\n    return NULL;\n  \n  body_type_1part->bd_type = bd_type;\n  switch (bd_type) {\n  case MAILIMAP_BODY_TYPE_1PART_BASIC:\n    body_type_1part->bd_data.bd_type_basic = bd_type_basic;\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_MSG:\n    body_type_1part->bd_data.bd_type_msg = bd_type_msg;\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_TEXT:\n    body_type_1part->bd_data.bd_type_text = bd_type_text;\n    break;\n  }\n  body_type_1part->bd_ext_1part = bd_ext_1part;\n\n  return body_type_1part;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_type_1part_free(struct mailimap_body_type_1part * bt1p)\n{\n  switch (bt1p->bd_type) {\n  case MAILIMAP_BODY_TYPE_1PART_BASIC:\n    mailimap_body_type_basic_free(bt1p->bd_data.bd_type_basic);\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_MSG:\n    mailimap_body_type_msg_free(bt1p->bd_data.bd_type_msg);\n    break;\n  case MAILIMAP_BODY_TYPE_1PART_TEXT:\n    mailimap_body_type_text_free(bt1p->bd_data.bd_type_text);\n    break;\n  }\n  if (bt1p->bd_ext_1part)\n    mailimap_body_ext_1part_free(bt1p->bd_ext_1part);\n\n  free(bt1p);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_basic *\nmailimap_body_type_basic_new(struct mailimap_media_basic * bd_media_basic,\n\t\t\t     struct mailimap_body_fields * bd_fields)\n{\n  struct mailimap_body_type_basic * body_type_basic;\n\n  body_type_basic = malloc(sizeof(* body_type_basic));\n  if (body_type_basic == NULL)\n    return NULL;\n\n  body_type_basic->bd_media_basic = bd_media_basic;\n  body_type_basic->bd_fields = bd_fields;\n \n  return body_type_basic;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_type_basic_free(struct mailimap_body_type_basic *\n    body_type_basic)\n{\n  mailimap_media_basic_free(body_type_basic->bd_media_basic);\n  mailimap_body_fields_free(body_type_basic->bd_fields);\n  free(body_type_basic);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_mpart *\nmailimap_body_type_mpart_new(clist * bd_list, char * bd_media_subtype,\n\t\t\t     struct mailimap_body_ext_mpart * bd_ext_mpart)\n{\n  struct mailimap_body_type_mpart * body_type_mpart;\n\n  body_type_mpart = malloc(sizeof(* body_type_mpart));\n  if (body_type_mpart == NULL)\n    return NULL;\n\n  body_type_mpart->bd_list = bd_list;\n  body_type_mpart->bd_media_subtype = bd_media_subtype;\n  body_type_mpart->bd_ext_mpart = bd_ext_mpart;\n\n  return body_type_mpart;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_body_type_mpart_free(struct mailimap_body_type_mpart *\n\t\t\t\t   body_type_mpart)\n{\n  clist_foreach(body_type_mpart->bd_list,\n\t\t(clist_func) mailimap_body_free, NULL);\n  clist_free(body_type_mpart->bd_list);\n  mailimap_media_subtype_free(body_type_mpart->bd_media_subtype);\n  if (body_type_mpart->bd_ext_mpart)\n    mailimap_body_ext_mpart_free(body_type_mpart->bd_ext_mpart);\n\n  free(body_type_mpart);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_msg *\nmailimap_body_type_msg_new(struct mailimap_body_fields * bd_fields,\n\t\t\t   struct mailimap_envelope * bd_envelope,\n\t\t\t   struct mailimap_body * bd_body,\n\t\t\t   uint32_t bd_lines)\n{\n  struct mailimap_body_type_msg * body_type_msg;\n\n  body_type_msg = malloc(sizeof(* body_type_msg));\n  if (body_type_msg == NULL)\n    return NULL;\n\n  body_type_msg->bd_fields = bd_fields;\n  body_type_msg->bd_envelope = bd_envelope;\n  body_type_msg->bd_body = bd_body;\n  body_type_msg->bd_lines = bd_lines;\n\n  return body_type_msg;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_type_msg_free(struct mailimap_body_type_msg * body_type_msg)\n{\n  mailimap_body_fields_free(body_type_msg->bd_fields);\n  mailimap_envelope_free(body_type_msg->bd_envelope);\n  mailimap_body_free(body_type_msg->bd_body);\n  free(body_type_msg);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_body_type_text *\nmailimap_body_type_text_new(char * bd_media_text,\n\t\t\t    struct mailimap_body_fields * bd_fields,\n\t\t\t    uint32_t bd_lines)\n{\n  struct mailimap_body_type_text * body_type_text;\n\n  body_type_text = malloc(sizeof(* body_type_text));\n  if (body_type_text == NULL)\n    return NULL;\n\n  body_type_text->bd_media_text = bd_media_text;\n  body_type_text->bd_fields = bd_fields;\n  body_type_text->bd_lines = bd_lines;\n\n  return body_type_text;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_body_type_text_free(struct mailimap_body_type_text * body_type_text)\n{\n  mailimap_media_text_free(body_type_text->bd_media_text);\n  mailimap_body_fields_free(body_type_text->bd_fields);\n  free(body_type_text);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_capability *\nmailimap_capability_new(int cap_type, char * cap_auth_type, char * cap_name)\n{\n  struct mailimap_capability * cap;\n\n  cap = malloc(sizeof(* cap));\n  if (cap == NULL)\n    return NULL;\n  cap->cap_type = cap_type;\n  switch (cap_type) {\n  case MAILIMAP_CAPABILITY_AUTH_TYPE:\n    cap->cap_data.cap_auth_type = cap_auth_type;\n    break;\n  case MAILIMAP_CAPABILITY_NAME:\n    cap->cap_data.cap_name = cap_name;\n    break;\n  }\n  \n  return cap;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_capability_free(struct mailimap_capability * c)\n{\n  switch (c->cap_type) {\n  case MAILIMAP_CAPABILITY_AUTH_TYPE:\n    free(c->cap_data.cap_auth_type);\n    break;\n  case MAILIMAP_CAPABILITY_NAME:\n    free(c->cap_data.cap_name);\n    break;\n  }\n  free(c);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_capability_data *\nmailimap_capability_data_new(clist * cap_list)\n{\n  struct mailimap_capability_data * cap_data;\n\n  cap_data = malloc(sizeof(* cap_data));\n  if (cap_data == NULL)\n    return NULL;\n\n  cap_data->cap_list = cap_list;\n\n  return cap_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_capability_data_free(struct mailimap_capability_data * cap_data)\n{\n  if (cap_data->cap_list) {\n    clist_foreach(cap_data->cap_list,\n        (clist_func) mailimap_capability_free, NULL);\n    clist_free(cap_data->cap_list);\n  }\n  free(cap_data);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_continue_req *\nmailimap_continue_req_new(int cr_type, struct mailimap_resp_text * cr_text,\n    char * cr_base64)\n{\n  struct mailimap_continue_req * cont_req;\n\n  cont_req = malloc(sizeof(* cont_req));\n  if (cont_req == NULL)\n    return NULL;\n  cont_req->cr_type = cr_type;\n  switch (cr_type) {\n  case MAILIMAP_CONTINUE_REQ_TEXT:\n    cont_req->cr_data.cr_text = cr_text;\n    break;\n  case MAILIMAP_CONTINUE_REQ_BASE64:\n    cont_req->cr_data.cr_base64 = cr_base64;\n    break;\n  }\n  \n  return cont_req;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_continue_req_free(struct mailimap_continue_req * cont_req)\n{\n  switch (cont_req->cr_type) {\n  case MAILIMAP_CONTINUE_REQ_TEXT:\n    mailimap_resp_text_free(cont_req->cr_data.cr_text);\n    break;\n  case MAILIMAP_CONTINUE_REQ_BASE64:\n    mailimap_base64_free(cont_req->cr_data.cr_base64);\n    break;\n  }\n  free(cont_req);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_date_time *\nmailimap_date_time_new(int dt_day, int dt_month, int dt_year, int dt_hour,\n    int dt_min, int dt_sec, int dt_zone)\n{\n  struct mailimap_date_time * date_time;\n\n  date_time = malloc(sizeof(* date_time));\n  if (date_time == NULL)\n    return NULL;\n\n  date_time->dt_day = dt_day;\n  date_time->dt_month = dt_month;\n  date_time->dt_year = dt_year;\n  date_time->dt_hour = dt_hour;\n  date_time->dt_min = dt_min;\n  date_time->dt_sec = dt_sec;\n  date_time->dt_zone = dt_zone;\n\n  return date_time;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_date_time_free(struct mailimap_date_time * date_time)\n{\n  free(date_time);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_envelope *\nmailimap_envelope_new(char * env_date, char * env_subject,\n\t\t      struct mailimap_env_from * env_from,\n\t\t      struct mailimap_env_sender * env_sender,\n\t\t      struct mailimap_env_reply_to * env_reply_to,\n\t\t      struct mailimap_env_to * env_to,\n\t\t      struct mailimap_env_cc* env_cc,\n\t\t      struct mailimap_env_bcc * env_bcc,\n\t\t      char * env_in_reply_to, char * env_message_id)\n{\n  struct mailimap_envelope * env;\n\n  env = malloc(sizeof(* env));\n  if (env == NULL)\n    return NULL;\n\n  env->env_date = env_date;\n  env->env_subject = env_subject;\n  env->env_from = env_from;\n  env->env_sender = env_sender;\n  env->env_reply_to = env_reply_to;\n  env->env_to = env_to;\n  env->env_cc = env_cc;\n  env->env_bcc = env_bcc;\n  env->env_in_reply_to = env_in_reply_to;\n  env->env_message_id = env_message_id;\n\n  return env;\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_envelope_free(struct mailimap_envelope * env)\n{\n  if (env->env_date)\n    mailimap_env_date_free(env->env_date);\n  if (env->env_subject)\n    mailimap_env_subject_free(env->env_subject);\n  if (env->env_from)\n    mailimap_env_from_free(env->env_from);\n  if (env->env_sender)\n    mailimap_env_sender_free(env->env_sender);\n  if (env->env_reply_to)\n    mailimap_env_reply_to_free(env->env_reply_to);\n  if (env->env_to)\n    mailimap_env_to_free(env->env_to);\n  if (env->env_cc)\n    mailimap_env_cc_free(env->env_cc);\n  if (env->env_bcc)\n    mailimap_env_bcc_free(env->env_bcc);\n  if (env->env_in_reply_to)\n    mailimap_env_in_reply_to_free(env->env_in_reply_to);\n  if (env->env_message_id)\n    mailimap_env_message_id_free(env->env_message_id);\n\n  free(env);\n}\n\n\nstatic void mailimap_address_list_free(clist * addr_list)\n{\n  if (addr_list != NULL) {\n    clist_foreach(addr_list, (clist_func) mailimap_address_free, NULL);\n    clist_free(addr_list);\n  }\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_env_bcc * mailimap_env_bcc_new(clist * bcc_list)\n{\n  struct mailimap_env_bcc * env_bcc;\n\n  env_bcc = malloc(sizeof(* env_bcc));\n  if (env_bcc == NULL)\n    return NULL;\n  env_bcc->bcc_list = bcc_list;\n\n  return env_bcc;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_bcc_free(struct mailimap_env_bcc * env_bcc)\n{\n  mailimap_address_list_free(env_bcc->bcc_list);\n  free(env_bcc);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_env_cc * mailimap_env_cc_new(clist * cc_list)\n{\n  struct mailimap_env_cc * env_cc;\n\n  env_cc = malloc(sizeof(* env_cc));\n  if (env_cc == NULL)\n    return NULL;\n  env_cc->cc_list = cc_list;\n\n  return env_cc;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_cc_free(struct mailimap_env_cc * env_cc)\n{\n  mailimap_address_list_free(env_cc->cc_list);\n  free(env_cc);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_env_date_free(char * date)\n{\n  mailimap_nstring_free(date);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_env_from * mailimap_env_from_new(clist * frm_list)\n{\n  struct mailimap_env_from * env_from;\n\n  env_from = malloc(sizeof(* env_from));\n  if (env_from == NULL)\n    return NULL;\n  env_from->frm_list = frm_list;\n\n  return env_from;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_from_free(struct mailimap_env_from * env_from)\n{\n  mailimap_address_list_free(env_from->frm_list);\n  free(env_from);\n}\n\n\nvoid mailimap_env_in_reply_to_free(char * in_reply_to)\n{\n  mailimap_nstring_free(in_reply_to);\n}\n\nvoid mailimap_env_message_id_free(char * message_id)\n{\n  mailimap_nstring_free(message_id);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_env_reply_to * mailimap_env_reply_to_new(clist * rt_list)\n{\n  struct mailimap_env_reply_to * env_reply_to;\n\n  env_reply_to = malloc(sizeof(* env_reply_to));\n  if (env_reply_to == NULL)\n    return NULL;\n  env_reply_to->rt_list = rt_list;\n\n  return env_reply_to;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_env_reply_to_free(struct mailimap_env_reply_to * env_reply_to)\n{\n  mailimap_address_list_free(env_reply_to->rt_list);\n  free(env_reply_to);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_env_sender * mailimap_env_sender_new(clist * snd_list)\n{\n  struct mailimap_env_sender * env_sender;\n\n  env_sender = malloc(sizeof(* env_sender));\n  if (env_sender == NULL)\n    return NULL;\n  env_sender->snd_list = snd_list;\n\n  return env_sender;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_sender_free(struct mailimap_env_sender * env_sender)\n{\n  mailimap_address_list_free(env_sender->snd_list);\n  free(env_sender);\n}\n\nvoid mailimap_env_subject_free(char * subject)\n{\n  mailimap_nstring_free(subject);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_env_to * mailimap_env_to_new(clist * to_list)\n{\n  struct mailimap_env_to * env_to;\n\n  env_to = malloc(sizeof(* env_to));\n  if (env_to == NULL)\n    return NULL;\n  env_to->to_list = to_list;\n\n  return env_to;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_env_to_free(struct mailimap_env_to * env_to)\n{\n  mailimap_address_list_free(env_to->to_list);\n  free(env_to);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag * mailimap_flag_new(int fl_type,\n    char * fl_keyword, char * fl_extension)\n{\n  struct mailimap_flag * f;\n\n  f = malloc(sizeof(* f));\n  if (f == NULL)\n    return NULL;\n  f->fl_type = fl_type;\n  switch (fl_type) {\n  case MAILIMAP_FLAG_KEYWORD:\n    f->fl_data.fl_keyword = fl_keyword;\n    break;\n  case MAILIMAP_FLAG_EXTENSION:\n    f->fl_data.fl_extension = fl_extension;\n    break;\n  }\n\n  return f;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_free(struct mailimap_flag * f)\n{\n  switch (f->fl_type) {\n  case MAILIMAP_FLAG_KEYWORD:\n    mailimap_flag_keyword_free(f->fl_data.fl_keyword);\n    break;\n  case MAILIMAP_FLAG_EXTENSION:\n    mailimap_flag_extension_free(f->fl_data.fl_extension);\n    break;\n  }\n  free(f);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_extension_free(char * flag_extension)\n{\n  mailimap_atom_free(flag_extension);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag_fetch *\nmailimap_flag_fetch_new(int fl_type, struct mailimap_flag * fl_flag)\n{\n  struct mailimap_flag_fetch * flag_fetch;\n\n  flag_fetch = malloc(sizeof(* flag_fetch));\n  if (flag_fetch == NULL)\n    return NULL;\n\n  flag_fetch->fl_type = fl_type;\n  flag_fetch->fl_flag = fl_flag;\n\n  return flag_fetch;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_fetch_free(struct mailimap_flag_fetch * flag_fetch)\n{\n  if (flag_fetch->fl_flag)\n    mailimap_flag_free(flag_fetch->fl_flag);\n  free(flag_fetch);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_keyword_free(char * flag_keyword)\n{\n  mailimap_atom_free(flag_keyword);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag_list *\nmailimap_flag_list_new(clist * fl_list)\n{\n  struct mailimap_flag_list * flag_list;\n\n  flag_list = malloc(sizeof(* flag_list));\n  if (flag_list == NULL)\n    return NULL;\n  flag_list->fl_list = fl_list;\n\n  return flag_list;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_list_free(struct mailimap_flag_list * flag_list)\n{\n  if (flag_list->fl_list) {\n    clist_foreach(flag_list->fl_list, (clist_func) mailimap_flag_free, NULL);\n    clist_free(flag_list->fl_list);\n  }\n  free(flag_list);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_flag_perm *\nmailimap_flag_perm_new(int fl_type, struct mailimap_flag * fl_flag)\n{\n  struct mailimap_flag_perm * flag_perm;\n\n  flag_perm = malloc(sizeof(* flag_perm));\n  if (flag_perm == NULL)\n    return NULL;\n\n  flag_perm->fl_type = fl_type;\n  flag_perm->fl_flag = fl_flag;\n\n  return flag_perm;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_flag_perm_free(struct mailimap_flag_perm * flag_perm)\n{\n  if (flag_perm->fl_flag != NULL)\n    mailimap_flag_free(flag_perm->fl_flag);\n  free(flag_perm);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_greeting *\nmailimap_greeting_new(int gr_type,\n    struct mailimap_resp_cond_auth * gr_auth,\n    struct mailimap_resp_cond_bye * gr_bye)\n{\n  struct mailimap_greeting * greeting;\n\n  greeting = malloc(sizeof(* greeting));\n  if (greeting == NULL)\n    return NULL;\n  greeting->gr_type = gr_type;\n  switch (gr_type) {\n  case MAILIMAP_GREETING_RESP_COND_AUTH:\n    greeting->gr_data.gr_auth = gr_auth;\n    break;\n  case MAILIMAP_GREETING_RESP_COND_BYE:\n    greeting->gr_data.gr_bye = gr_bye;\n    break;\n  }\n  \n  return greeting;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_greeting_free(struct mailimap_greeting * greeting)\n{\n  switch (greeting->gr_type) {\n  case MAILIMAP_GREETING_RESP_COND_AUTH:\n    mailimap_resp_cond_auth_free(greeting->gr_data.gr_auth);\n    break;\n  case MAILIMAP_GREETING_RESP_COND_BYE:\n    mailimap_resp_cond_bye_free(greeting->gr_data.gr_bye);\n    break;\n  }\n  free(greeting);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_header_fld_name_free(char * header_fld_name)\n{\n  mailimap_astring_free(header_fld_name);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_header_list *\nmailimap_header_list_new(clist * hdr_list)\n{\n  struct mailimap_header_list * header_list;\n\n  header_list = malloc(sizeof(* header_list));\n  if (header_list == NULL)\n    return NULL;\n\n  header_list->hdr_list = hdr_list;\n\n  return header_list;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_header_list_free(struct mailimap_header_list * header_list)\n{\n  clist_foreach(header_list->hdr_list,\n      (clist_func) mailimap_header_fld_name_free,\n      NULL);\n  clist_free(header_list->hdr_list);\n  free(header_list);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_literal_free(char * literal)\n{\n  /*  free(literal); */\n  mmap_string_unref(literal);\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_mailbox_free(char * mb)\n{\n  mailimap_astring_free(mb);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_status_info *\nmailimap_status_info_new(int st_att, uint32_t st_value,\n  struct mailimap_extension_data * st_ext_data)\n{\n  struct mailimap_status_info * info;\n\n  info = malloc(sizeof(* info));\n  if (info == NULL)\n    return NULL;\n  info->st_att = st_att;\n  info->st_value = st_value;\n  info->st_ext_data = st_ext_data;\n\n  return info;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_status_info_free(struct mailimap_status_info * info)\n{\n  if (info->st_ext_data != NULL) {\n    mailimap_extension_data_free(info->st_ext_data);\n  }\n  free(info);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mailbox_data_status *\nmailimap_mailbox_data_status_new(char * st_mailbox,\n    clist * st_info_list)\n{\n  struct mailimap_mailbox_data_status * mb_data_status;\n\n  mb_data_status = malloc(sizeof(* mb_data_status));\n  if (mb_data_status == NULL)\n    return NULL;\n  mb_data_status->st_mailbox = st_mailbox;\n  mb_data_status->st_info_list = st_info_list;\n\n  return mb_data_status;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_data_search_free(clist * data_search)\n{\n  clist_foreach(data_search, (clist_func) mailimap_number_alloc_free, NULL);\n  clist_free(data_search);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  if (info->st_info_list != NULL) {\n    clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n      NULL);\n    clist_free(info->st_info_list);\n  }\n  free(info);\n}\n\n\nstatic void\nmailimap_mailbox_data_flags_free(struct mailimap_flag_list * flag_list)\n{\n  mailimap_flag_list_free(flag_list);\n}\n\nstatic void\nmailimap_mailbox_data_list_free(struct mailimap_mailbox_list * mb_list)\n{\n  mailimap_mailbox_list_free(mb_list);\n}\n\nstatic void\nmailimap_mailbox_data_lsub_free(struct mailimap_mailbox_list * mb_lsub)\n{\n  mailimap_mailbox_list_free(mb_lsub);\n}\n\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mailbox_data *\nmailimap_mailbox_data_new(int mbd_type, struct mailimap_flag_list * mbd_flags,\n    struct mailimap_mailbox_list * mbd_list,\n    struct mailimap_mailbox_list * mbd_lsub,\n    clist * mbd_search,\n    struct mailimap_mailbox_data_status * mbd_status,\n    uint32_t mbd_exists,\n    uint32_t mbd_recent,\n    struct mailimap_extension_data * mbd_extension)\n{\n  struct mailimap_mailbox_data * data;\n\n  data = malloc(sizeof(* data));\n  if (data == NULL)\n    return NULL;\n\n  data->mbd_type = mbd_type;\n  switch (mbd_type) {\n  case MAILIMAP_MAILBOX_DATA_FLAGS:\n    data->mbd_data.mbd_flags = mbd_flags;\n    break;\n  case MAILIMAP_MAILBOX_DATA_LIST:\n    data->mbd_data.mbd_list = mbd_list;\n    break;\n  case MAILIMAP_MAILBOX_DATA_LSUB:\n    data->mbd_data.mbd_lsub = mbd_lsub;\n    break;\n  case MAILIMAP_MAILBOX_DATA_SEARCH:\n    data->mbd_data.mbd_search = mbd_search;\n    break;\n  case MAILIMAP_MAILBOX_DATA_STATUS:\n    data->mbd_data.mbd_status = mbd_status;\n    break;\n  case MAILIMAP_MAILBOX_DATA_EXISTS:\n    data->mbd_data.mbd_exists = mbd_exists;\n    break;\n  case MAILIMAP_MAILBOX_DATA_RECENT:\n    data->mbd_data.mbd_recent = mbd_recent;\n    break;\n  case MAILIMAP_MAILBOX_DATA_EXTENSION_DATA:\n    data->mbd_data.mbd_extension = mbd_extension;\n    break;\n  }\n  \n  return data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_data_free(struct mailimap_mailbox_data * mb_data)\n{\n  switch (mb_data->mbd_type) {\n  case MAILIMAP_MAILBOX_DATA_FLAGS:\n    if (mb_data->mbd_data.mbd_flags != NULL)\n      mailimap_mailbox_data_flags_free(mb_data->mbd_data.mbd_flags);\n    break;\n  case MAILIMAP_MAILBOX_DATA_LIST:\n    if (mb_data->mbd_data.mbd_list != NULL)\n      mailimap_mailbox_data_list_free(mb_data->mbd_data.mbd_list);\n    break;\n  case MAILIMAP_MAILBOX_DATA_LSUB:\n    if (mb_data->mbd_data.mbd_lsub != NULL)\n      mailimap_mailbox_data_lsub_free(mb_data->mbd_data.mbd_lsub);\n    break;\n  case MAILIMAP_MAILBOX_DATA_SEARCH:\n    if (mb_data->mbd_data.mbd_search != NULL)\n      mailimap_mailbox_data_search_free(mb_data->mbd_data.mbd_search);\n    break;\n  case MAILIMAP_MAILBOX_DATA_STATUS:\n    if (mb_data->mbd_data.mbd_status != NULL)\n      mailimap_mailbox_data_status_free(mb_data->mbd_data.mbd_status);\n    break;\n  case MAILIMAP_MAILBOX_DATA_EXTENSION_DATA:\n    if (mb_data->mbd_data.mbd_extension != NULL)\n      mailimap_extension_data_free(mb_data->mbd_data.mbd_extension);\n    break;\n  }\n  free(mb_data);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mbx_list_flags *\nmailimap_mbx_list_flags_new(int mbf_type, clist * mbf_oflags,\n\t\t\t    int mbf_sflag)\n{\n  struct mailimap_mbx_list_flags * mbx_list_flags;\n\n  mbx_list_flags = malloc(sizeof(* mbx_list_flags));\n  if (mbx_list_flags == NULL)\n    return NULL;\n\n  mbx_list_flags->mbf_type = mbf_type;\n  mbx_list_flags->mbf_oflags = mbf_oflags;\n  mbx_list_flags->mbf_sflag = mbf_sflag;\n  \n  return mbx_list_flags;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mbx_list_flags_free(struct mailimap_mbx_list_flags * mbx_list_flags)\n{\n  clist_foreach(mbx_list_flags->mbf_oflags,\n      (clist_func) mailimap_mbx_list_oflag_free,\n      NULL);\n  clist_free(mbx_list_flags->mbf_oflags);\n  \n  free(mbx_list_flags);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mbx_list_oflag *\nmailimap_mbx_list_oflag_new(int of_type, char * of_flag_ext)\n{\n  struct mailimap_mbx_list_oflag * oflag;\n\n  oflag = malloc(sizeof(* oflag));\n  if (oflag == NULL)\n    return NULL;\n\n  oflag->of_type = of_type;\n  oflag->of_flag_ext = of_flag_ext;\n\n  return oflag;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mbx_list_oflag_free(struct mailimap_mbx_list_oflag * oflag)\n{\n  if (oflag->of_flag_ext != NULL)\n    mailimap_flag_extension_free(oflag->of_flag_ext);\n  free(oflag);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_mailbox_list *\nmailimap_mailbox_list_new(struct mailimap_mbx_list_flags * mbx_flags,\n\t\t\t  char mb_delimiter, char * mb_name)\n{\n  struct mailimap_mailbox_list * mb_list;\n\n  mb_list = malloc(sizeof(* mb_list));\n  if (mb_list == NULL)\n    return NULL;\n  \n  mb_list->mb_flag = mbx_flags;\n  mb_list->mb_delimiter = mb_delimiter;\n  mb_list->mb_name = mb_name;\n\n  return mb_list;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_mailbox_list_free(struct mailimap_mailbox_list * mb_list)\n{\n  if (mb_list->mb_flag != NULL)\n    mailimap_mbx_list_flags_free(mb_list->mb_flag);\n  if (mb_list->mb_name != NULL)\n    mailimap_mailbox_free(mb_list->mb_name);\n  free(mb_list);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_media_basic *\nmailimap_media_basic_new(int med_type,\n    char * med_basic_type, char * med_subtype)\n{\n  struct mailimap_media_basic * media_basic;\n\n  media_basic = malloc(sizeof(* media_basic));\n  if (media_basic == NULL)\n    return NULL;\n  media_basic->med_type = med_type;\n  media_basic->med_basic_type = med_basic_type;\n  media_basic->med_subtype = med_subtype;\n\n  return media_basic;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_media_basic_free(struct mailimap_media_basic * media_basic)\n{\n  mailimap_string_free(media_basic->med_basic_type);\n  mailimap_media_subtype_free(media_basic->med_subtype);\n  free(media_basic);\n}\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_media_subtype_free(char * media_subtype)\n{\n  mmap_string_unref(media_subtype);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_media_text_free(char * media_text)\n{\n  mailimap_media_subtype_free(media_text);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_message_data *\nmailimap_message_data_new(uint32_t mdt_number, int mdt_type,\n\t\t\t  struct mailimap_msg_att * mdt_msg_att)\n{\n  struct mailimap_message_data * msg_data;\n\n  msg_data = malloc(sizeof(* msg_data));\n  if (msg_data == NULL) {\n    return NULL;\n  }\n\n  msg_data->mdt_number = mdt_number;\n  msg_data->mdt_type = mdt_type;\n  msg_data->mdt_msg_att = mdt_msg_att;\n\n  return msg_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_message_data_free(struct mailimap_message_data * msg_data)\n{\n  if (msg_data->mdt_msg_att != NULL)\n    mailimap_msg_att_free(msg_data->mdt_msg_att);\n  free(msg_data);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_item *\nmailimap_msg_att_item_new(int att_type,\n\t\t\t  struct mailimap_msg_att_dynamic * att_dyn,\n\t\t\t  struct mailimap_msg_att_static * att_static,\n        struct mailimap_extension_data * att_extension_data)\n{\n  struct mailimap_msg_att_item * item;\n\n  item = malloc(sizeof(* item));\n  if (item == NULL)\n    return item;\n\n  item->att_type = att_type;\n  switch (att_type) {\n  case MAILIMAP_MSG_ATT_ITEM_DYNAMIC:\n    item->att_data.att_dyn = att_dyn;\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_STATIC:\n    item->att_data.att_static = att_static;\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_EXTENSION:\n    item->att_data.att_extension_data = att_extension_data;\n    break;\n  }\n\n  return item;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_item_free(struct mailimap_msg_att_item * item)\n{\n  switch (item->att_type) {\n  case MAILIMAP_MSG_ATT_ITEM_DYNAMIC:\n    mailimap_msg_att_dynamic_free(item->att_data.att_dyn);\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_STATIC:\n    mailimap_msg_att_static_free(item->att_data.att_static);\n    break;\n  case MAILIMAP_MSG_ATT_ITEM_EXTENSION:\n    mailimap_extension_data_free(item->att_data.att_extension_data);\n    break;\n  }\n  free(item);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att *\nmailimap_msg_att_new(clist * att_list)\n{\n  struct mailimap_msg_att * msg_att;\n\n  msg_att = malloc(sizeof(* msg_att));\n  if (msg_att == NULL)\n    return NULL;\n\n  msg_att->att_list = att_list;\n  msg_att->att_number = 0;\n\n  return msg_att;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_msg_att_free(struct mailimap_msg_att * msg_att)\n{\n  clist_foreach(msg_att->att_list,\n      (clist_func) mailimap_msg_att_item_free, NULL);\n  clist_free(msg_att->att_list);\n  free(msg_att);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_dynamic *\nmailimap_msg_att_dynamic_new(clist * att_list)\n{\n  struct mailimap_msg_att_dynamic * msg_att_dyn;\n\n  msg_att_dyn = malloc(sizeof(* msg_att_dyn));\n  if (msg_att_dyn == NULL)\n    return NULL;\n\n  msg_att_dyn->att_list = att_list;\n  \n  return msg_att_dyn;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_dynamic_free(struct mailimap_msg_att_dynamic * msg_att_dyn)\n{\n  if (msg_att_dyn->att_list != NULL) {\n    clist_foreach(msg_att_dyn->att_list,\n        (clist_func) mailimap_flag_fetch_free,\n        NULL);\n    clist_free(msg_att_dyn->att_list);\n  }\n  free(msg_att_dyn);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_body_section *\nmailimap_msg_att_body_section_new(struct mailimap_section * sec_section,\n\t\t\t\t  uint32_t sec_origin_octet,\n\t\t\t\t  char * sec_body_part,\n\t\t\t\t  size_t sec_length)\n{\n  struct mailimap_msg_att_body_section * msg_att_body_section;\n\n  msg_att_body_section = malloc(sizeof(* msg_att_body_section));\n  if (msg_att_body_section == NULL)\n    return NULL;\n\n  msg_att_body_section->sec_section = sec_section;\n  msg_att_body_section->sec_origin_octet = sec_origin_octet;\n  msg_att_body_section->sec_body_part = sec_body_part;\n  msg_att_body_section->sec_length = sec_length;\n\n  return msg_att_body_section;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_body_section_free(struct mailimap_msg_att_body_section * \n    msg_att_body_section)\n{\n  if (msg_att_body_section->sec_section != NULL)\n    mailimap_section_free(msg_att_body_section->sec_section);\n  if (msg_att_body_section->sec_body_part != NULL)\n    mailimap_nstring_free(msg_att_body_section->sec_body_part);\n  free(msg_att_body_section);\n}\n\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_msg_att_envelope_free(struct mailimap_envelope * env)\n{\n  mailimap_envelope_free(env);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_internaldate_free(struct mailimap_date_time * date_time)\n{\n  mailimap_date_time_free(date_time);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_rfc822_free(char * str)\n{\n  mailimap_nstring_free(str);\n}\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_rfc822_header_free(char * str)\n{\n  mailimap_nstring_free(str);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_rfc822_text_free(char * str)\n{\n  mailimap_nstring_free(str);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_body_free(struct mailimap_body * body)\n{\n  mailimap_body_free(body);\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_bodystructure_free(struct mailimap_body * body)\n{\n  mailimap_body_free(body);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_msg_att_static *\nmailimap_msg_att_static_new(int att_type, struct mailimap_envelope * att_env,\n    struct mailimap_date_time * att_internal_date,\n    char * att_rfc822,\n    char * att_rfc822_header,\n    char * att_rfc822_text,\n    size_t att_length,\n    uint32_t att_rfc822_size,\n    struct mailimap_body * att_bodystructure,\n    struct mailimap_body * att_body,\n    struct mailimap_msg_att_body_section * att_body_section,\n    uint32_t att_uid)\n{\n  struct mailimap_msg_att_static * item;\n\n  item = malloc(sizeof(* item));\n  if (item == NULL)\n    return FALSE;\n\n  item->att_type = att_type;\n  switch (att_type) {\n  case MAILIMAP_MSG_ATT_ENVELOPE:\n    item->att_data.att_env = att_env;\n    break;\n  case MAILIMAP_MSG_ATT_INTERNALDATE:\n    item->att_data.att_internal_date = att_internal_date;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822:\n    item->att_data.att_rfc822.att_content = att_rfc822;\n    item->att_data.att_rfc822.att_length = att_length;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_HEADER:\n    item->att_data.att_rfc822_header.att_content = att_rfc822_header;\n    item->att_data.att_rfc822_header.att_length = att_length;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_TEXT:\n    item->att_data.att_rfc822_text.att_content = att_rfc822_text;\n    item->att_data.att_rfc822_text.att_length = att_length;\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_SIZE:\n    item->att_data.att_rfc822_size = att_rfc822_size;\n    break;\n  case MAILIMAP_MSG_ATT_BODY:\n    item->att_data.att_body = att_body;\n    break;\n  case MAILIMAP_MSG_ATT_BODYSTRUCTURE:\n    item->att_data.att_bodystructure = att_bodystructure;\n    break;\n  case MAILIMAP_MSG_ATT_BODY_SECTION:\n    item->att_data.att_body_section = att_body_section;\n    break;\n  case MAILIMAP_MSG_ATT_UID:\n    item->att_data.att_uid = att_uid;\n    break;\n  }\n\n  return item;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_msg_att_static_free(struct mailimap_msg_att_static * item)\n{\n  switch (item->att_type) {\n  case MAILIMAP_MSG_ATT_ENVELOPE:\n    if (item->att_data.att_env != NULL)\n      mailimap_msg_att_envelope_free(item->att_data.att_env);\n    break;\n  case MAILIMAP_MSG_ATT_INTERNALDATE:\n    if (item->att_data.att_internal_date != NULL)\n      mailimap_msg_att_internaldate_free(item->att_data.att_internal_date);\n    break;\n  case MAILIMAP_MSG_ATT_RFC822:\n    if (item->att_data.att_rfc822.att_content != NULL)\n      mailimap_msg_att_rfc822_free(item->att_data.att_rfc822.att_content);\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_HEADER:\n    if (item->att_data.att_rfc822_header.att_content != NULL)\n      mailimap_msg_att_rfc822_header_free(item->att_data.att_rfc822_header.att_content);\n    break;\n  case MAILIMAP_MSG_ATT_RFC822_TEXT:\n    if (item->att_data.att_rfc822_text.att_content != NULL)\n      mailimap_msg_att_rfc822_text_free(item->att_data.att_rfc822_text.att_content);\n    break;\n  case MAILIMAP_MSG_ATT_BODYSTRUCTURE:\n    if (item->att_data.att_bodystructure != NULL)\n      mailimap_msg_att_bodystructure_free(item->att_data.att_bodystructure);\n    break;\n  case MAILIMAP_MSG_ATT_BODY:\n    if (item->att_data.att_body != NULL)\n      mailimap_msg_att_body_free(item->att_data.att_body);\n    break;\n  case MAILIMAP_MSG_ATT_BODY_SECTION:\n    if (item->att_data.att_body_section != NULL)\n      mailimap_msg_att_body_section_free(item->att_data.att_body_section);\n    break;\n  }\n  free(item);\n}\n \n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_nstring_free(char * str)\n{\n  if (str != NULL)\n    mailimap_string_free(str);\n}\n\n\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_cont_req_or_resp_data *\nmailimap_cont_req_or_resp_data_new(int rsp_type,\n    struct mailimap_continue_req * rsp_cont_req,\n    struct mailimap_response_data * rsp_resp_data)\n{\n  struct mailimap_cont_req_or_resp_data * cont_req_or_resp_data;\n\n  cont_req_or_resp_data = malloc(sizeof(* cont_req_or_resp_data));\n  if (cont_req_or_resp_data == NULL)\n    return NULL;\n\n  cont_req_or_resp_data->rsp_type = rsp_type;\n  switch (rsp_type) {\n  case MAILIMAP_RESP_CONT_REQ:\n    cont_req_or_resp_data->rsp_data.rsp_cont_req = rsp_cont_req;\n    break;\n  case MAILIMAP_RESP_RESP_DATA:\n    cont_req_or_resp_data->rsp_data.rsp_resp_data = rsp_resp_data;\n    break;\n  }\n  \n  return cont_req_or_resp_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_cont_req_or_resp_data_free(struct mailimap_cont_req_or_resp_data *\n\t\t\t\t    cont_req_or_resp_data)\n{\n  switch (cont_req_or_resp_data->rsp_type) {\n  case MAILIMAP_RESP_CONT_REQ:\n    if (cont_req_or_resp_data->rsp_data.rsp_cont_req != NULL)\n      mailimap_continue_req_free(cont_req_or_resp_data->rsp_data.rsp_cont_req);\n    break;\n  case MAILIMAP_RESP_RESP_DATA:\n    if (cont_req_or_resp_data->rsp_data.rsp_resp_data != NULL)\n      mailimap_response_data_free(cont_req_or_resp_data->rsp_data.rsp_resp_data);\n    break;\n  }\n  free(cont_req_or_resp_data);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_response *\nmailimap_response_new(clist * rsp_cont_req_or_resp_data_list,\n    struct mailimap_response_done * rsp_resp_done)\n{\n  struct mailimap_response * resp;\n\n  resp = malloc(sizeof(* resp));\n  if (resp == NULL)\n    return NULL;\n\n  resp->rsp_cont_req_or_resp_data_list = rsp_cont_req_or_resp_data_list;\n  resp->rsp_resp_done = rsp_resp_done;\n\n  return resp;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_free(struct mailimap_response * resp)\n{\n  if (resp->rsp_cont_req_or_resp_data_list != NULL) {\n    clist_foreach(resp->rsp_cont_req_or_resp_data_list,\n        (clist_func) mailimap_cont_req_or_resp_data_free, NULL);\n    clist_free(resp->rsp_cont_req_or_resp_data_list);\n  }\n  mailimap_response_done_free(resp->rsp_resp_done);\n  free(resp);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_response_data *\nmailimap_response_data_new(int rsp_type,\n    struct mailimap_resp_cond_state * rsp_cond_state,\n    struct mailimap_resp_cond_bye * rsp_bye,\n    struct mailimap_mailbox_data * rsp_mailbox_data,\n    struct mailimap_message_data * rsp_message_data,\n    struct mailimap_capability_data * rsp_capability_data,\n    struct mailimap_extension_data * rsp_extension_data)\n{\n  struct mailimap_response_data * resp_data;\n\n  resp_data = malloc(sizeof(* resp_data));\n  if (resp_data == NULL)\n    return NULL;\n  resp_data->rsp_type = rsp_type;\n\n  switch (rsp_type) {\n  case MAILIMAP_RESP_DATA_TYPE_COND_STATE:\n    resp_data->rsp_data.rsp_cond_state = rsp_cond_state;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_COND_BYE:\n    resp_data->rsp_data.rsp_bye = rsp_bye;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MAILBOX_DATA:\n    resp_data->rsp_data.rsp_mailbox_data = rsp_mailbox_data;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MESSAGE_DATA:\n    resp_data->rsp_data.rsp_message_data = rsp_message_data;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_CAPABILITY_DATA:\n    resp_data->rsp_data.rsp_capability_data = rsp_capability_data;\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_EXTENSION_DATA:\n    resp_data->rsp_data.rsp_extension_data = rsp_extension_data;\n    break;\n  }\n  \n  return resp_data;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_data_free(struct mailimap_response_data * resp_data)\n{\n  switch (resp_data->rsp_type) {\n  case MAILIMAP_RESP_DATA_TYPE_COND_STATE:\n    if (resp_data->rsp_data.rsp_cond_state != NULL)\n      mailimap_resp_cond_state_free(resp_data->rsp_data.rsp_cond_state);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_COND_BYE:\n    if (resp_data->rsp_data.rsp_bye != NULL)\n      mailimap_resp_cond_bye_free(resp_data->rsp_data.rsp_bye);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MAILBOX_DATA:\n    if (resp_data->rsp_data.rsp_mailbox_data != NULL)\n      mailimap_mailbox_data_free(resp_data->rsp_data.rsp_mailbox_data);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_MESSAGE_DATA:\n    if (resp_data->rsp_data.rsp_message_data != NULL)\n      mailimap_message_data_free(resp_data->rsp_data.rsp_message_data);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_CAPABILITY_DATA:\n    if (resp_data->rsp_data.rsp_capability_data != NULL)\n      mailimap_capability_data_free(resp_data->rsp_data.rsp_capability_data);\n    break;\n  case MAILIMAP_RESP_DATA_TYPE_EXTENSION_DATA:\n    if (resp_data->rsp_data.rsp_extension_data != NULL)\n      mailimap_extension_data_free(resp_data->rsp_data.rsp_extension_data);\n    break;\n  }\n  free(resp_data);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_response_done *\nmailimap_response_done_new(int rsp_type,\n    struct mailimap_response_tagged * rsp_tagged,\n    struct mailimap_response_fatal * rsp_fatal)\n{\n  struct mailimap_response_done * resp_done;\n    \n  resp_done = malloc(sizeof(* resp_done));\n  if (resp_done == NULL)\n    return NULL;\n\n  resp_done->rsp_type = rsp_type;\n  switch (rsp_type) {\n  case MAILIMAP_RESP_DONE_TYPE_TAGGED:\n    resp_done->rsp_data.rsp_tagged = rsp_tagged;\n    break;\n  case MAILIMAP_RESP_DONE_TYPE_FATAL:\n    resp_done->rsp_data.rsp_fatal = rsp_fatal;\n    break;\n  }\n\n  return resp_done;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_response_done_free(struct mailimap_response_done *\n\t\t\t\t resp_done)\n{\n  switch (resp_done->rsp_type) {\n  case MAILIMAP_RESP_DONE_TYPE_TAGGED:\n    mailimap_response_tagged_free(resp_done->rsp_data.rsp_tagged);\n    break;\n  case MAILIMAP_RESP_DONE_TYPE_FATAL:\n    mailimap_response_fatal_free(resp_done->rsp_data.rsp_fatal);\n    break;\n  }\n  free(resp_done);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_response_fatal *\nmailimap_response_fatal_new(struct mailimap_resp_cond_bye * rsp_bye)\n{\n  struct mailimap_response_fatal * resp_fatal;\n\n  resp_fatal = malloc(sizeof(* resp_fatal));\n  if (resp_fatal == NULL)\n    return NULL;\n\n  resp_fatal->rsp_bye = rsp_bye;\n\n  return resp_fatal;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_response_fatal_free(struct mailimap_response_fatal * resp_fatal)\n{\n  mailimap_resp_cond_bye_free(resp_fatal->rsp_bye);\n  free(resp_fatal);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_response_tagged *\nmailimap_response_tagged_new(char * rsp_tag,\n    struct mailimap_resp_cond_state * rsp_cond_state)\n{\n  struct mailimap_response_tagged * resp_tagged;\n\n  resp_tagged = malloc(sizeof(* resp_tagged));\n  if (resp_tagged == NULL)\n    return NULL;\n\n  resp_tagged->rsp_tag = rsp_tag;\n  resp_tagged->rsp_cond_state = rsp_cond_state;\n\n  return resp_tagged;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_tagged_free(struct mailimap_response_tagged * tagged)\n{\n  mailimap_tag_free(tagged->rsp_tag);\n  mailimap_resp_cond_state_free(tagged->rsp_cond_state);\n  free(tagged);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_cond_auth *\nmailimap_resp_cond_auth_new(int rsp_type,\n    struct mailimap_resp_text * rsp_text)\n{\n  struct mailimap_resp_cond_auth * cond_auth;\n\n  cond_auth = malloc(sizeof(* cond_auth));\n  if (cond_auth == NULL)\n    return NULL;\n\n  cond_auth->rsp_type = rsp_type;\n  cond_auth->rsp_text = rsp_text;\n\n  return cond_auth;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_cond_auth_free(struct mailimap_resp_cond_auth * cond_auth)\n{\n  mailimap_resp_text_free(cond_auth->rsp_text);\n  free(cond_auth);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_cond_bye *\nmailimap_resp_cond_bye_new(struct mailimap_resp_text * rsp_text)\n{\n  struct mailimap_resp_cond_bye * cond_bye;\n\n  cond_bye = malloc(sizeof(* cond_bye));\n  if (cond_bye == NULL)\n    return NULL;\n\n  cond_bye->rsp_text = rsp_text;\n\n  return cond_bye;\n}\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_cond_bye_free(struct mailimap_resp_cond_bye * cond_bye)\n{\n  mailimap_resp_text_free(cond_bye->rsp_text);\n  free(cond_bye);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_cond_state *\nmailimap_resp_cond_state_new(int rsp_type,\n    struct mailimap_resp_text * rsp_text)\n{\n  struct mailimap_resp_cond_state * cond_state;\n\n  cond_state = malloc(sizeof(* cond_state));\n  if (cond_state == NULL)\n    return NULL;\n\n  cond_state->rsp_type = rsp_type;\n  cond_state->rsp_text = rsp_text;\n\n  return cond_state;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_cond_state_free(struct mailimap_resp_cond_state * cond_state)\n{\n  mailimap_resp_text_free(cond_state->rsp_text);\n  free(cond_state);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_text *\nmailimap_resp_text_new(struct mailimap_resp_text_code * rsp_code,\n    char * rsp_text)\n{\n  struct mailimap_resp_text * resp_text;\n\n  resp_text = malloc(sizeof(* resp_text));\n  if (resp_text == NULL)\n    return NULL;\n\n  resp_text->rsp_code = rsp_code;\n  resp_text->rsp_text = rsp_text;\n\n  return resp_text;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_resp_text_free(struct mailimap_resp_text * resp_text)\n{\n  if (resp_text->rsp_code)\n    mailimap_resp_text_code_free(resp_text->rsp_code);\n  if (resp_text->rsp_text)\n    mailimap_text_free(resp_text->rsp_text);\n  free(resp_text);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_resp_text_code *\nmailimap_resp_text_code_new(int rc_type, clist * rc_badcharset,\n    struct mailimap_capability_data * rc_cap_data,\n    clist * rc_perm_flags,\n    uint32_t rc_uidnext, uint32_t rc_uidvalidity,\n    uint32_t rc_first_unseen, char * rc_atom, char * rc_atom_value,\n    struct mailimap_extension_data * rc_ext_data)\n{\n  struct mailimap_resp_text_code * resp_text_code;\n\n  resp_text_code = malloc(sizeof(* resp_text_code));\n  if (resp_text_code == NULL)\n    return NULL;\n\n  resp_text_code->rc_type = rc_type;\n  switch (rc_type) {\n  case MAILIMAP_RESP_TEXT_CODE_BADCHARSET:\n    resp_text_code->rc_data.rc_badcharset = rc_badcharset;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_CAPABILITY_DATA:\n    resp_text_code->rc_data.rc_cap_data = rc_cap_data;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_PERMANENTFLAGS:\n    resp_text_code->rc_data.rc_perm_flags = rc_perm_flags;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_UIDNEXT:\n    resp_text_code->rc_data.rc_uidnext = rc_uidnext;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_UIDVALIDITY:\n    resp_text_code->rc_data.rc_uidvalidity = rc_uidvalidity;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_UNSEEN:\n    resp_text_code->rc_data.rc_first_unseen = rc_first_unseen;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_OTHER:\n    resp_text_code->rc_data.rc_atom.atom_name = rc_atom;\n    resp_text_code->rc_data.rc_atom.atom_value = rc_atom_value;\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_EXTENSION:\n    resp_text_code->rc_data.rc_ext_data = rc_ext_data;\n    break;\n  }\n\n  return resp_text_code;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_resp_text_code_free(struct mailimap_resp_text_code * resp_text_code)\n{\n  switch (resp_text_code->rc_type) {\n  case MAILIMAP_RESP_TEXT_CODE_BADCHARSET:\n    if (resp_text_code->rc_data.rc_badcharset != NULL) {\n      clist_foreach(resp_text_code->rc_data.rc_badcharset,\n          (clist_func) mailimap_astring_free,\n          NULL);\n      clist_free(resp_text_code->rc_data.rc_badcharset);\n    }\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_CAPABILITY_DATA:\n    if (resp_text_code->rc_data.rc_cap_data != NULL)\n      mailimap_capability_data_free(resp_text_code->rc_data.rc_cap_data);\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_PERMANENTFLAGS:\n    if (resp_text_code->rc_data.rc_perm_flags != NULL) {\n      clist_foreach(resp_text_code->rc_data.rc_perm_flags,\n          (clist_func) mailimap_flag_perm_free, NULL);\n      clist_free(resp_text_code->rc_data.rc_perm_flags);\n    }\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_OTHER:\n    if (resp_text_code->rc_data.rc_atom.atom_name != NULL)\n      mailimap_atom_free(resp_text_code->rc_data.rc_atom.atom_name);\n    if (resp_text_code->rc_data.rc_atom.atom_value != NULL)\n      mailimap_custom_string_free(resp_text_code->rc_data.rc_atom.atom_value);\n    break;\n  case MAILIMAP_RESP_TEXT_CODE_EXTENSION:\n    if (resp_text_code->rc_data.rc_ext_data != NULL)\n      mailimap_extension_data_free(resp_text_code->rc_data.rc_ext_data);\n    break;\n  }\n  free(resp_text_code);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section *\nmailimap_section_new(struct mailimap_section_spec * sec_spec)\n{\n  struct mailimap_section * section;\n\n  section = malloc(sizeof(* section));\n  if (section == NULL)\n    return NULL;\n  \n  section->sec_spec = sec_spec;\n\n  return section;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_section_free(struct mailimap_section * section)\n{\n  if (section->sec_spec != NULL)\n    mailimap_section_spec_free(section->sec_spec);\n  free(section);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_msgtext *\nmailimap_section_msgtext_new(int sec_type,\n    struct mailimap_header_list * sec_header_list)\n{\n  struct mailimap_section_msgtext * msgtext;\n\n  msgtext = malloc(sizeof(* msgtext));\n  if (msgtext == NULL)\n    return FALSE;\n\n  msgtext->sec_type = sec_type;\n  msgtext->sec_header_list = sec_header_list;\n\n  return msgtext;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_msgtext_free(struct mailimap_section_msgtext * msgtext)\n{\n  if (msgtext->sec_header_list != NULL)\n    mailimap_header_list_free(msgtext->sec_header_list);\n  free(msgtext);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_part *\nmailimap_section_part_new(clist * sec_id)\n{\n  struct mailimap_section_part * section_part;\n\n  section_part = malloc(sizeof(* section_part));\n  if (section_part == NULL)\n    return NULL;\n\n  section_part->sec_id = sec_id;\n\n  return section_part;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_part_free(struct mailimap_section_part * section_part)\n{\n  clist_foreach(section_part->sec_id,\n      (clist_func) mailimap_number_alloc_free, NULL);\n  clist_free(section_part->sec_id);\n  free(section_part);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_spec *\nmailimap_section_spec_new(int sec_type,\n    struct mailimap_section_msgtext * sec_msgtext,\n    struct mailimap_section_part * sec_part,\n    struct mailimap_section_text * sec_text)\n{\n  struct mailimap_section_spec * section_spec;\n\n  section_spec = malloc(sizeof(* section_spec));\n  if (section_spec == NULL)\n    return NULL;\n\n  section_spec->sec_type = sec_type;\n  switch (sec_type) {\n  case MAILIMAP_SECTION_SPEC_SECTION_MSGTEXT:\n    section_spec->sec_data.sec_msgtext = sec_msgtext;\n    break;\n  case MAILIMAP_SECTION_SPEC_SECTION_PART:\n    section_spec->sec_data.sec_part = sec_part;\n    break;\n  }\n  section_spec->sec_text = sec_text;\n\n  return section_spec;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_spec_free(struct mailimap_section_spec * section_spec)\n{\n  if (section_spec->sec_text)\n    mailimap_section_text_free(section_spec->sec_text);\n  \n  switch (section_spec->sec_type) {\n  case MAILIMAP_SECTION_SPEC_SECTION_PART:\n    if (section_spec->sec_data.sec_part != NULL)\n      mailimap_section_part_free(section_spec->sec_data.sec_part);\n    break;\n  case MAILIMAP_SECTION_SPEC_SECTION_MSGTEXT:\n    /* handle case where it can be detached */\n    if (section_spec->sec_data.sec_msgtext != NULL)\n      mailimap_section_msgtext_free(section_spec->sec_data.sec_msgtext);\n    break;\n  }\n  free(section_spec);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_section_text *\nmailimap_section_text_new(int sec_type,\n    struct mailimap_section_msgtext * sec_msgtext)\n{\n  struct mailimap_section_text * section_text;\n  \n  section_text = malloc(sizeof(* section_text));\n  if (section_text == NULL)\n    return NULL;\n\n  section_text->sec_type = sec_type;\n  section_text->sec_msgtext = sec_msgtext;\n  \n  return section_text;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_section_text_free(struct mailimap_section_text * section_text)\n{\n  if (section_text->sec_msgtext != NULL)\n    mailimap_section_msgtext_free(section_text->sec_msgtext);\n  free(section_text);\n}\n\n\n\n\nLIBETPAN_EXPORT\nvoid\nmailimap_string_free(char * str)\n{\n  mmap_string_unref(str);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nvoid mailimap_tag_free(char * tag)\n{\n  mailimap_custom_string_free(tag);\n}\n\n\nLIBETPAN_EXPORT\nvoid mailimap_text_free(char * text)\n{\n  mailimap_custom_string_free(text);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n/* ************************************************************************* */\n\n\n\n\n\n\n/* sender only */\n\n\n/* COPY FETCH SEARCH STORE */\n/* set */\n\nLIBETPAN_EXPORT\nstruct mailimap_set_item *\nmailimap_set_item_new(uint32_t set_first, uint32_t set_last)\n{\n  struct mailimap_set_item * item;\n\n  item = malloc(sizeof(* item));\n  if (item == NULL)\n    return NULL;\n\n  item->set_first = set_first;\n  item->set_last = set_last;\n\n  return item;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_set_item_free(struct mailimap_set_item * set_item)\n{\n  free(set_item);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_set * mailimap_set_new(clist * set_list)\n{\n  struct mailimap_set * set;\n\n  set = malloc(sizeof(* set));\n  if (set == NULL)\n    return NULL;\n\n  set->set_list = set_list;\n\n  return set;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_set_free(struct mailimap_set * set)\n{\n  clist_foreach(set->set_list, (clist_func) mailimap_set_item_free, NULL);\n  clist_free(set->set_list);\n  free(set);\n}\n\n/* SEARCH with date key */\n/* date */\n\nLIBETPAN_EXPORT\nstruct mailimap_date *\nmailimap_date_new(int dt_day, int dt_month, int dt_year)\n{\n  struct mailimap_date * date;\n\n  date = malloc(sizeof(* date));\n  if (date == NULL)\n    return NULL;\n\n  date->dt_day = dt_day;\n  date->dt_month = dt_month;\n  date->dt_year = dt_year;\n\n  return date;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_date_free(struct mailimap_date * date)\n{\n  free(date);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_fetch_att *\nmailimap_fetch_att_new(int att_type, struct mailimap_section * att_section,\n                       uint32_t att_offset, uint32_t att_size, char * att_extension)\n{\n  struct mailimap_fetch_att * fetch_att;\n\n  fetch_att = malloc(sizeof(* fetch_att));\n  if (fetch_att == NULL)\n    return NULL;\n  fetch_att->att_type = att_type;\n  fetch_att->att_section = att_section;\n  fetch_att->att_offset = att_offset;\n  fetch_att->att_size = att_size;\n  fetch_att->att_extension = att_extension;\n\n  return fetch_att;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_fetch_att_free(struct mailimap_fetch_att * fetch_att)\n{\n  if (fetch_att->att_extension != NULL)\n    free(fetch_att->att_extension);\n  if (fetch_att->att_section != NULL)\n    mailimap_section_free(fetch_att->att_section);\n  free(fetch_att);\n}\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_fetch_type *\nmailimap_fetch_type_new(int ft_type,\n    struct mailimap_fetch_att * ft_fetch_att,\n    clist * ft_fetch_att_list)\n{\n  struct mailimap_fetch_type * fetch_type;\n\n  fetch_type = malloc(sizeof(* fetch_type));\n  if (fetch_type == NULL)\n    return NULL;\n  fetch_type->ft_type = ft_type;\n  switch (ft_type) {\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT:\n    fetch_type->ft_data.ft_fetch_att = ft_fetch_att;\n    break;\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT_LIST:\n    fetch_type->ft_data.ft_fetch_att_list = ft_fetch_att_list;\n    break;\n  }\n  \n  return fetch_type;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_fetch_type_free(struct mailimap_fetch_type * fetch_type)\n{\n  switch (fetch_type->ft_type) {\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT:\n    mailimap_fetch_att_free(fetch_type->ft_data.ft_fetch_att);\n    break;\n  case MAILIMAP_FETCH_TYPE_FETCH_ATT_LIST:\n    clist_foreach(fetch_type->ft_data.ft_fetch_att_list,\n        (clist_func) mailimap_fetch_att_free, NULL);\n    clist_free(fetch_type->ft_data.ft_fetch_att_list);\n    break;\n  }\n  free(fetch_type);\n}\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_store_att_flags *\nmailimap_store_att_flags_new(int fl_sign, int fl_silent,\n    struct mailimap_flag_list * fl_flag_list)\n{\n  struct mailimap_store_att_flags * store_att_flags;\n\n  store_att_flags = malloc(sizeof(* store_att_flags));\n  if (store_att_flags == NULL)\n    return NULL;\n\n  store_att_flags->fl_sign = fl_sign;\n  store_att_flags->fl_silent = fl_silent;\n  store_att_flags->fl_flag_list = fl_flag_list;\n  \n  return store_att_flags;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_store_att_flags_free(struct mailimap_store_att_flags *\n\t\t\t\t   store_att_flags)\n{\n  mailimap_flag_list_free(store_att_flags->fl_flag_list);\n  free(store_att_flags);\n}\n\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new(int sk_type,\n    char * sk_bcc, struct mailimap_date * sk_before, char * sk_body,\n    char * sk_cc, char * sk_from, char * sk_keyword,\n    struct mailimap_date * sk_on, struct mailimap_date * sk_since,\n    char * sk_subject, char * sk_text, char * sk_to,\n    char * sk_unkeyword, char * sk_header_name,\n    char * sk_header_value, uint32_t sk_larger,\n    struct mailimap_search_key * sk_not,\n    struct mailimap_search_key * sk_or1,\n    struct mailimap_search_key * sk_or2,\n    struct mailimap_date * sk_sentbefore,\n    struct mailimap_date * sk_senton,\n    struct mailimap_date * sk_sentsince,\n    uint32_t sk_smaller, struct mailimap_set * sk_uid,\n    struct mailimap_set * sk_set, clist * sk_multiple)\n{\n  struct mailimap_search_key * key;\n\n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = sk_type;\n  switch (sk_type) {\n  case MAILIMAP_SEARCH_KEY_BCC:\n    key->sk_data.sk_bcc = sk_bcc;\n    break;\n  case MAILIMAP_SEARCH_KEY_BEFORE:\n    key->sk_data.sk_before = sk_before;\n    break;\n  case MAILIMAP_SEARCH_KEY_BODY:\n    key->sk_data.sk_body = sk_body;\n    break;\n  case MAILIMAP_SEARCH_KEY_CC:\n    key->sk_data.sk_cc = sk_cc;\n    break;\n  case MAILIMAP_SEARCH_KEY_FROM:\n    key->sk_data.sk_from = sk_from;\n    break;\n  case MAILIMAP_SEARCH_KEY_KEYWORD:\n    key->sk_data.sk_keyword = sk_keyword;\n    break;\n  case MAILIMAP_SEARCH_KEY_ON:\n    key->sk_data.sk_on = sk_on;\n    break;\n  case MAILIMAP_SEARCH_KEY_SINCE:\n    key->sk_data.sk_since = sk_since;\n    break;\n  case MAILIMAP_SEARCH_KEY_SUBJECT:\n    key->sk_data.sk_subject = sk_subject;\n    break;\n  case MAILIMAP_SEARCH_KEY_TEXT:\n    key->sk_data.sk_text = sk_text;\n    break;\n  case MAILIMAP_SEARCH_KEY_TO:\n    key->sk_data.sk_to = sk_to;\n    break;\n  case MAILIMAP_SEARCH_KEY_UNKEYWORD:\n    key->sk_data.sk_unkeyword = sk_unkeyword;\n    break;\n  case MAILIMAP_SEARCH_KEY_HEADER:\n    key->sk_data.sk_header.sk_header_name = sk_header_name;\n    key->sk_data.sk_header.sk_header_value = sk_header_value;\n    break;\n  case MAILIMAP_SEARCH_KEY_LARGER:\n    key->sk_data.sk_larger = sk_larger;\n    break;\n  case MAILIMAP_SEARCH_KEY_NOT:\n    key->sk_data.sk_not = sk_not;\n    break;\n  case MAILIMAP_SEARCH_KEY_OR:\n    key->sk_data.sk_or.sk_or1 = sk_or1;\n    key->sk_data.sk_or.sk_or2 = sk_or2;\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTBEFORE:\n    key->sk_data.sk_sentbefore = sk_sentbefore;\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTON:\n    key->sk_data.sk_senton = sk_senton;\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTSINCE:\n    key->sk_data.sk_sentsince = sk_sentsince;\n    break;\n  case MAILIMAP_SEARCH_KEY_SMALLER:\n    key->sk_data.sk_smaller = sk_smaller;\n    break;\n  case MAILIMAP_SEARCH_KEY_UID:\n    key->sk_data.sk_uid = sk_uid;\n    break;\n  case MAILIMAP_SEARCH_KEY_SET:\n    key->sk_data.sk_set = sk_set;\n    break;\n  case MAILIMAP_SEARCH_KEY_MULTIPLE:\n    key->sk_data.sk_multiple = sk_multiple;\n    break;\n  }\n  return key;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new_xgmthrid(uint64_t sk_xgmthrid)\n{\n  struct mailimap_search_key * key;\n  \n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = MAILIMAP_SEARCH_KEY_XGMTHRID;\n  key->sk_data.sk_xgmthrid = sk_xgmthrid;\n\n  return key;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new_xgmmsgid(uint64_t sk_xgmmsgid)\n{\n  struct mailimap_search_key * key;\n  \n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = MAILIMAP_SEARCH_KEY_XGMMSGID;\n  key->sk_data.sk_xgmmsgid = sk_xgmmsgid;\n  \n  return key;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_search_key *\nmailimap_search_key_new_xgmraw(char * sk_xgmraw)\n{\n  struct mailimap_search_key * key;\n  \n  key = malloc(sizeof(* key));\n  if (key == NULL)\n    return NULL;\n  \n  key->sk_type = MAILIMAP_SEARCH_KEY_XGMRAW;\n  key->sk_data.sk_xgmraw = sk_xgmraw;\n  \n  return key;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_search_key_free(struct mailimap_search_key * key)\n{\n  switch (key->sk_type) {\n  case MAILIMAP_SEARCH_KEY_BCC:\n    mailimap_astring_free(key->sk_data.sk_bcc);\n    break;\n  case MAILIMAP_SEARCH_KEY_BEFORE:\n    mailimap_date_free(key->sk_data.sk_before);\n    break;\n  case MAILIMAP_SEARCH_KEY_BODY:\n    mailimap_astring_free(key->sk_data.sk_body);\n    break;\n  case MAILIMAP_SEARCH_KEY_CC:\n    mailimap_astring_free(key->sk_data.sk_cc);\n    break;\n  case MAILIMAP_SEARCH_KEY_FROM:\n    mailimap_astring_free(key->sk_data.sk_from);\n    break;\n  case MAILIMAP_SEARCH_KEY_KEYWORD:\n    mailimap_flag_keyword_free(key->sk_data.sk_keyword);\n    break;\n  case MAILIMAP_SEARCH_KEY_ON:\n    mailimap_date_free(key->sk_data.sk_on);\n    break;\n  case MAILIMAP_SEARCH_KEY_SINCE:\n    mailimap_date_free(key->sk_data.sk_since);\n    break;\n  case MAILIMAP_SEARCH_KEY_SUBJECT:\n    mailimap_astring_free(key->sk_data.sk_subject);\n    break;\n  case MAILIMAP_SEARCH_KEY_TEXT:\n    mailimap_astring_free(key->sk_data.sk_text);\n    break;\n  case MAILIMAP_SEARCH_KEY_TO:\n    mailimap_astring_free(key->sk_data.sk_to);\n    break;\n  case MAILIMAP_SEARCH_KEY_UNKEYWORD:\n    mailimap_flag_keyword_free(key->sk_data.sk_unkeyword);\n    break;\n  case MAILIMAP_SEARCH_KEY_HEADER:\n    mailimap_header_fld_name_free(key->sk_data.sk_header.sk_header_name);\n    mailimap_astring_free(key->sk_data.sk_header.sk_header_value);\n    break;\n  case MAILIMAP_SEARCH_KEY_NOT:\n    mailimap_search_key_free(key->sk_data.sk_not);\n    break;\n  case MAILIMAP_SEARCH_KEY_OR:\n    mailimap_search_key_free(key->sk_data.sk_or.sk_or1);\n    mailimap_search_key_free(key->sk_data.sk_or.sk_or2);\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTBEFORE:\n    mailimap_date_free(key->sk_data.sk_sentbefore);\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTON:\n    mailimap_date_free(key->sk_data.sk_senton);\n    break;\n  case MAILIMAP_SEARCH_KEY_SENTSINCE:\n    mailimap_date_free(key->sk_data.sk_sentsince);\n    break;\n  case MAILIMAP_SEARCH_KEY_UID:\n    mailimap_set_free(key->sk_data.sk_uid);\n    break;\n  case MAILIMAP_SEARCH_KEY_SET:\n    mailimap_set_free(key->sk_data.sk_set);\n    break;\n  case MAILIMAP_SEARCH_KEY_MULTIPLE:\n    clist_foreach(key->sk_data.sk_multiple,\n        (clist_func) mailimap_search_key_free, NULL);\n    clist_free(key->sk_data.sk_multiple);\n    break;\n  case MAILIMAP_SEARCH_KEY_MODSEQ:\n    if (key->sk_data.sk_modseq.sk_entry_name != NULL) {\n      mailimap_flag_free(key->sk_data.sk_modseq.sk_entry_name);\n    }\n    break;\n  case MAILIMAP_SEARCH_KEY_XGMRAW:\n    mailimap_astring_free(key->sk_data.sk_xgmraw);\n    break;\n  }\n  \n  free(key);\n}\n\n\n\n\n\nLIBETPAN_EXPORT\nstruct mailimap_status_att_list *\nmailimap_status_att_list_new(clist * att_list)\n{\n  struct mailimap_status_att_list * status_att_list;\n\n  status_att_list = malloc(sizeof(* status_att_list));\n  if (status_att_list == NULL)\n    return NULL;\n  status_att_list->att_list = att_list;\n\n  return status_att_list;\n}\n\nLIBETPAN_EXPORT\nvoid mailimap_status_att_list_free(struct mailimap_status_att_list *\n\t\t\t\t   status_att_list)\n{\n  clist_foreach(status_att_list->att_list, (clist_func) free, NULL);\n  clist_free(status_att_list->att_list);\n  free(status_att_list);\n}\n\n\n\n\n/* main */\n\n\nLIBETPAN_EXPORT\nstruct mailimap_selection_info *\nmailimap_selection_info_new(void)\n{\n  struct mailimap_selection_info * sel_info;\n\n  sel_info = malloc(sizeof(* sel_info));\n  if (sel_info == NULL)\n    return NULL;\n\n  sel_info->sel_perm_flags = NULL;\n  sel_info->sel_perm = MAILIMAP_MAILBOX_READWRITE;\n  sel_info->sel_uidnext = 0;\n  sel_info->sel_uidvalidity = 0;\n  sel_info->sel_first_unseen = 0;\n  sel_info->sel_flags = NULL;\n  sel_info->sel_exists = 0;\n  sel_info->sel_recent = 0;\n  sel_info->sel_unseen = 0;\n  sel_info->sel_has_exists = 0;\n  sel_info->sel_has_recent = 0 ;\n\n  return sel_info;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_selection_info_free(struct mailimap_selection_info * sel_info)\n{\n  if (sel_info->sel_perm_flags != NULL) {\n    clist_foreach(sel_info->sel_perm_flags,\n        (clist_func) mailimap_flag_perm_free, NULL);\n    clist_free(sel_info->sel_perm_flags);\n  }\n  if (sel_info->sel_flags)\n    mailimap_flag_list_free(sel_info->sel_flags);\n\n  free(sel_info);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_connection_info *\nmailimap_connection_info_new(void)\n{\n  struct mailimap_connection_info * conn_info;\n\n  conn_info = malloc(sizeof(* conn_info));\n  if (conn_info == NULL)\n    return NULL;\n  \n  conn_info->imap_capability = NULL;\n\n  return conn_info;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_connection_info_free(struct mailimap_connection_info * conn_info)\n{\n  if (conn_info->imap_capability != NULL)\n    mailimap_capability_data_free(conn_info->imap_capability);\n  free(conn_info);\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_response_info *\nmailimap_response_info_new(void)\n{\n  struct mailimap_response_info * resp_info;\n\n  resp_info = malloc(sizeof(* resp_info));\n  if (resp_info == NULL)\n    goto err;\n\n  resp_info->rsp_alert = NULL;\n  resp_info->rsp_parse = NULL;\n  resp_info->rsp_badcharset = NULL;\n  resp_info->rsp_trycreate = FALSE;\n  resp_info->rsp_mailbox_list = clist_new();\n  if (resp_info->rsp_mailbox_list == NULL)\n    goto free;\n  resp_info->rsp_extension_list = clist_new();\n  if (resp_info->rsp_extension_list == NULL)\n    goto free_mb_list;\n  resp_info->rsp_mailbox_lsub = clist_new();\n  if (resp_info->rsp_mailbox_lsub == NULL)\n    goto free_extension_list;\n  resp_info->rsp_search_result = clist_new();\n  if (resp_info->rsp_search_result == NULL)\n    goto free_mb_lsub;\n  resp_info->rsp_status = NULL;\n  resp_info->rsp_expunged = clist_new();\n  if (resp_info->rsp_expunged == NULL)\n    goto free_search_result;\n  resp_info->rsp_fetch_list = clist_new();\n  if (resp_info->rsp_fetch_list == NULL)\n    goto free_expunged;\n  resp_info->rsp_atom = NULL;\n  resp_info->rsp_value = NULL;\n  \n  return resp_info;\n\n free_expunged:\n  clist_free(resp_info->rsp_expunged);\n free_search_result:\n  clist_free(resp_info->rsp_search_result);\n free_mb_lsub:\n  clist_free(resp_info->rsp_mailbox_lsub);\n free_extension_list:\n  clist_free(resp_info->rsp_extension_list);\n free_mb_list:\n  clist_free(resp_info->rsp_mailbox_list);\n free:\n  free(resp_info);\n err:\n  return NULL;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_response_info_free(struct mailimap_response_info * resp_info)\n{\n  free(resp_info->rsp_value);\n  free(resp_info->rsp_atom);\n  if (resp_info->rsp_alert != NULL)\n    free(resp_info->rsp_alert);\n  if (resp_info->rsp_parse != NULL)\n    free(resp_info->rsp_parse);\n  if (resp_info->rsp_badcharset != NULL) {\n    clist_foreach(resp_info->rsp_badcharset,\n        (clist_func) mailimap_astring_free, NULL);\n    clist_free(resp_info->rsp_badcharset);\n  }\n  if (resp_info->rsp_mailbox_list != NULL) {\n    clist_foreach(resp_info->rsp_mailbox_list,\n        (clist_func) mailimap_mailbox_list_free, NULL);\n    clist_free(resp_info->rsp_mailbox_list);\n  }\n  if (resp_info->rsp_extension_list != NULL) {\n    clist_foreach(resp_info->rsp_extension_list,\n      (clist_func) mailimap_extension_data_free, NULL);\n    clist_free(resp_info->rsp_extension_list);\n  }\n  if (resp_info->rsp_mailbox_lsub != NULL) {\n    clist_foreach(resp_info->rsp_mailbox_lsub,\n        (clist_func) mailimap_mailbox_list_free, NULL);\n    clist_free(resp_info->rsp_mailbox_lsub);\n  }\n  if (resp_info->rsp_search_result != NULL)\n    mailimap_mailbox_data_search_free(resp_info->rsp_search_result);\n  if (resp_info->rsp_status != NULL)\n    mailimap_mailbox_data_status_free(resp_info->rsp_status);\n  if (resp_info->rsp_expunged != NULL) {\n    clist_foreach(resp_info->rsp_expunged,\n\t\t   (clist_func) mailimap_number_alloc_free, NULL);\n    clist_free(resp_info->rsp_expunged);\n  }\n  if (resp_info->rsp_fetch_list != NULL) {\n    clist_foreach(resp_info->rsp_fetch_list,\n\t\t  (clist_func) mailimap_msg_att_free, NULL);\n    clist_free(resp_info->rsp_fetch_list);\n  }\n\n  free(resp_info);\n}\n\n\nLIBETPAN_EXPORT\nint\nmailimap_parser_context_is_rambler_workaround_enabled(struct mailimap_parser_context * parser_ctx)\n{\n  return parser_ctx != NULL && parser_ctx->is_rambler_workaround_enabled;\n}\n\nLIBETPAN_EXPORT\nint\nmailimap_parser_context_is_qip_workaround_enabled(struct mailimap_parser_context * parser_ctx)\n{\n  return parser_ctx != NULL && parser_ctx->is_qip_workaround_enabled;\n}\n\nLIBETPAN_EXPORT\nstruct mailimap_parser_context *\nmailimap_parser_context_new(mailimap * session)\n{\n  struct mailimap_parser_context * ctx;\n\n  ctx = malloc(sizeof(* ctx));\n  if (ctx == NULL)\n    goto err;\n\n  ctx->is_rambler_workaround_enabled = mailimap_is_rambler_workaround_enabled(session);\n  ctx->is_qip_workaround_enabled = mailimap_is_qip_workaround_enabled(session);\n\n  ctx->msg_body_handler = session->imap_msg_body_handler;\n  ctx->msg_body_handler_context = session->imap_msg_body_handler_context;\n  ctx->msg_body_parse_in_progress = false;\n  ctx->msg_body_section = NULL;\n  ctx->msg_body_att_type = 0;\n\n  return ctx;\n\nerr:\n  return NULL;\n}\n\nLIBETPAN_EXPORT\nvoid\nmailimap_parser_context_free(struct mailimap_parser_context * ctx)\n{\n  free(ctx);\n}\n"], "filenames": ["src/low-level/imap/mailimap_types.c"], "buggy_code_start_loc": [1392], "buggy_code_end_loc": [1395], "fixing_code_start_loc": [1392], "fixing_code_end_loc": [1397], "type": "CWE-476", "message": "In libetpan a null pointer dereference in mailimap_mailbox_data_status_free in low-level/imap/mailimap_types.c was found that could lead to a remote denial of service or other potential consequences.", "other": {"cve": {"id": "CVE-2022-4121", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2023-01-17T18:15:11.583", "lastModified": "2023-01-23T19:32:11.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libetpan a null pointer dereference in mailimap_mailbox_data_status_free in low-level/imap/mailimap_types.c was found that could lead to a remote denial of service or other potential consequences."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libetpan_project:libetpan:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A0D1B29-C9D4-41DF-BC27-693F54591519"}]}]}], "references": [{"url": "https://github.com/dinhvh/libetpan/commit/5c9eb6b6ba64c4eb927d7a902317410181aacbba", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dinhvh/libetpan/issues/420", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dinhvh/libetpan/commit/5c9eb6b6ba64c4eb927d7a902317410181aacbba"}}