{"buggy_code": ["/*\n\tmount.c (22.10.09)\n\texFAT file system implementation library.\n\n\tFree exFAT implementation.\n\tCopyright (C) 2010-2015  Andrew Nayenko\n\n\tThis program is free software; you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 2 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License along\n\twith this program; if not, write to the Free Software Foundation, Inc.,\n\t51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"exfat.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nstatic uint64_t rootdir_size(const struct exfat* ef)\n{\n\tuint64_t clusters = 0;\n\tcluster_t rootdir_cluster = le32_to_cpu(ef->sb->rootdir_cluster);\n\n\twhile (!CLUSTER_INVALID(rootdir_cluster))\n\t{\n\t\tclusters++;\n\t\t/* root directory cannot be contiguous because there is no flag\n\t\t   to indicate this */\n\t\trootdir_cluster = exfat_next_cluster(ef, ef->root, rootdir_cluster);\n\t}\n\tif (rootdir_cluster != EXFAT_CLUSTER_END)\n\t{\n\t\texfat_error(\"bad cluster %#x while reading root directory\",\n\t\t\t\trootdir_cluster);\n\t\treturn 0;\n\t}\n\treturn clusters * CLUSTER_SIZE(*ef->sb);\n}\n\nstatic const char* get_option(const char* options, const char* option_name)\n{\n\tconst char* p;\n\tsize_t length = strlen(option_name);\n\n\tfor (p = strstr(options, option_name); p; p = strstr(p + 1, option_name))\n\t\tif ((p == options || p[-1] == ',') && p[length] == '=')\n\t\t\treturn p + length + 1;\n\treturn NULL;\n}\n\nstatic int get_int_option(const char* options, const char* option_name,\n\t\tint base, int default_value)\n{\n\tconst char* p = get_option(options, option_name);\n\n\tif (p == NULL)\n\t\treturn default_value;\n\treturn strtol(p, NULL, base);\n}\n\nstatic bool match_option(const char* options, const char* option_name)\n{\n\tconst char* p;\n\tsize_t length = strlen(option_name);\n\n\tfor (p = strstr(options, option_name); p; p = strstr(p + 1, option_name))\n\t\tif ((p == options || p[-1] == ',') &&\n\t\t\t\t(p[length] == ',' || p[length] == '\\0'))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic void parse_options(struct exfat* ef, const char* options)\n{\n\tint opt_umask;\n\n\topt_umask = get_int_option(options, \"umask\", 8, 0);\n\tef->dmask = get_int_option(options, \"dmask\", 8, opt_umask);\n\tef->fmask = get_int_option(options, \"fmask\", 8, opt_umask);\n\n\tef->uid = get_int_option(options, \"uid\", 10, geteuid());\n\tef->gid = get_int_option(options, \"gid\", 10, getegid());\n\n\tef->noatime = match_option(options, \"noatime\");\n}\n\nstatic bool verify_vbr_checksum(struct exfat_dev* dev, void* sector,\n\t\toff_t sector_size)\n{\n\tuint32_t vbr_checksum;\n\tint i;\n\n\tif (exfat_pread(dev, sector, sector_size, 0) < 0)\n\t{\n\t\texfat_error(\"failed to read boot sector\");\n\t\treturn false;\n\t}\n\tvbr_checksum = exfat_vbr_start_checksum(sector, sector_size);\n\tfor (i = 1; i < 11; i++)\n\t{\n\t\tif (exfat_pread(dev, sector, sector_size, i * sector_size) < 0)\n\t\t{\n\t\t\texfat_error(\"failed to read VBR sector\");\n\t\t\treturn false;\n\t\t}\n\t\tvbr_checksum = exfat_vbr_add_checksum(sector, sector_size,\n\t\t\t\tvbr_checksum);\n\t}\n\tif (exfat_pread(dev, sector, sector_size, i * sector_size) < 0)\n\t{\n\t\texfat_error(\"failed to read VBR checksum sector\");\n\t\treturn false;\n\t}\n\tfor (i = 0; i < sector_size / sizeof(vbr_checksum); i++)\n\t\tif (le32_to_cpu(((const le32_t*) sector)[i]) != vbr_checksum)\n\t\t{\n\t\t\texfat_error(\"invalid VBR checksum 0x%x (expected 0x%x)\",\n\t\t\t\t\tle32_to_cpu(((const le32_t*) sector)[i]), vbr_checksum);\n\t\t\treturn false;\n\t\t}\n\treturn true;\n}\n\nstatic int commit_super_block(const struct exfat* ef)\n{\n\tif (exfat_pwrite(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)\n\t{\n\t\texfat_error(\"failed to write super block\");\n\t\treturn 1;\n\t}\n\treturn exfat_fsync(ef->dev);\n}\n\nstatic int prepare_super_block(const struct exfat* ef)\n{\n\tif (le16_to_cpu(ef->sb->volume_state) & EXFAT_STATE_MOUNTED)\n\t\texfat_warn(\"volume was not unmounted cleanly\");\n\n\tif (ef->ro)\n\t\treturn 0;\n\n\tef->sb->volume_state = cpu_to_le16(\n\t\t\tle16_to_cpu(ef->sb->volume_state) | EXFAT_STATE_MOUNTED);\n\treturn commit_super_block(ef);\n}\n\nint exfat_mount(struct exfat* ef, const char* spec, const char* options)\n{\n\tint rc;\n\tenum exfat_mode mode;\n\n\texfat_tzset();\n\tmemset(ef, 0, sizeof(struct exfat));\n\n\tparse_options(ef, options);\n\n\tif (match_option(options, \"ro\"))\n\t\tmode = EXFAT_MODE_RO;\n\telse if (match_option(options, \"ro_fallback\"))\n\t\tmode = EXFAT_MODE_ANY;\n\telse\n\t\tmode = EXFAT_MODE_RW;\n\tef->dev = exfat_open(spec, mode);\n\tif (ef->dev == NULL)\n\t\treturn -EIO;\n\tif (exfat_get_mode(ef->dev) == EXFAT_MODE_RO)\n\t{\n\t\tif (mode == EXFAT_MODE_ANY)\n\t\t\tef->ro = -1;\n\t\telse\n\t\t\tef->ro = 1;\n\t}\n\n\tef->sb = malloc(sizeof(struct exfat_super_block));\n\tif (ef->sb == NULL)\n\t{\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"failed to allocate memory for the super block\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ef->sb, 0, sizeof(struct exfat_super_block));\n\n\tif (exfat_pread(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)\n\t{\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"failed to read boot sector\");\n\t\treturn -EIO;\n\t}\n\tif (memcmp(ef->sb->oem_name, \"EXFAT   \", 8) != 0)\n\t{\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"exFAT file system is not found\");\n\t\treturn -EIO;\n\t}\n\tef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));\n\tif (ef->zero_cluster == NULL)\n\t{\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"failed to allocate zero sector\");\n\t\treturn -ENOMEM;\n\t}\n\t/* use zero_cluster as a temporary buffer for VBR checksum verification */\n\tif (!verify_vbr_checksum(ef->dev, ef->zero_cluster, SECTOR_SIZE(*ef->sb)))\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tmemset(ef->zero_cluster, 0, CLUSTER_SIZE(*ef->sb));\n\tif (ef->sb->version.major != 1 || ef->sb->version.minor != 0)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"unsupported exFAT version: %hhu.%hhu\",\n\t\t\t\tef->sb->version.major, ef->sb->version.minor);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tif (ef->sb->fat_count != 1)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"unsupported FAT count: %hhu\", ef->sb->fat_count);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\t/* officially exFAT supports cluster size up to 32 MB */\n\tif ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"too big cluster size: 2^%d\",\n\t\t\t\t(int) ef->sb->sector_bits + (int) ef->sb->spc_bits);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tif (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >\n\t\t\texfat_get_size(ef->dev))\n\t{\n\t\t/* this can cause I/O errors later but we don't fail mounting to let\n\t\t   user rescue data */\n\t\texfat_warn(\"file system is larger than underlying device: \"\n\t\t\t\t\"%\"PRIu64\" > %\"PRIu64,\n\t\t\t\tle64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb),\n\t\t\t\texfat_get_size(ef->dev));\n\t}\n\n\tef->root = malloc(sizeof(struct exfat_node));\n\tif (ef->root == NULL)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"failed to allocate root node\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ef->root, 0, sizeof(struct exfat_node));\n\tef->root->flags = EXFAT_ATTRIB_DIR;\n\tef->root->start_cluster = le32_to_cpu(ef->sb->rootdir_cluster);\n\tef->root->fptr_cluster = ef->root->start_cluster;\n\tef->root->name[0] = cpu_to_le16('\\0');\n\tef->root->size = rootdir_size(ef);\n\tif (ef->root->size == 0)\n\t{\n\t\tfree(ef->root);\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\t/* exFAT does not have time attributes for the root directory */\n\tef->root->mtime = 0;\n\tef->root->atime = 0;\n\t/* always keep at least 1 reference to the root node */\n\texfat_get_node(ef->root);\n\n\trc = exfat_cache_directory(ef, ef->root);\n\tif (rc != 0)\n\t\tgoto error;\n\tif (ef->upcase == NULL)\n\t{\n\t\texfat_error(\"upcase table is not found\");\n\t\tgoto error;\n\t}\n\tif (ef->cmap.chunk == NULL)\n\t{\n\t\texfat_error(\"clusters bitmap is not found\");\n\t\tgoto error;\n\t}\n\n\tif (prepare_super_block(ef) != 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\texfat_put_node(ef, ef->root);\n\texfat_reset_cache(ef);\n\tfree(ef->root);\n\tfree(ef->zero_cluster);\n\texfat_close(ef->dev);\n\tfree(ef->sb);\n\treturn -EIO;\n}\n\nstatic void finalize_super_block(struct exfat* ef)\n{\n\tif (ef->ro)\n\t\treturn;\n\n\tef->sb->volume_state = cpu_to_le16(\n\t\t\tle16_to_cpu(ef->sb->volume_state) & ~EXFAT_STATE_MOUNTED);\n\n\t/* Some implementations set the percentage of allocated space to 0xff\n\t   on FS creation and never update it. In this case leave it as is. */\n\tif (ef->sb->allocated_percent != 0xff)\n\t{\n\t\tuint32_t free, total;\n\n\t\tfree = exfat_count_free_clusters(ef);\n\t\ttotal = le32_to_cpu(ef->sb->cluster_count);\n\t\tef->sb->allocated_percent = ((total - free) * 100 + total / 2) / total;\n\t}\n\n\tcommit_super_block(ef);\t/* ignore return code */\n}\n\nvoid exfat_unmount(struct exfat* ef)\n{\n\texfat_flush(ef);\t/* ignore return code */\n\texfat_put_node(ef, ef->root);\n\texfat_reset_cache(ef);\n\tfree(ef->root);\n\tef->root = NULL;\n\tfinalize_super_block(ef);\n\texfat_close(ef->dev);\t/* close descriptor immediately after fsync */\n\tef->dev = NULL;\n\tfree(ef->zero_cluster);\n\tef->zero_cluster = NULL;\n\tfree(ef->cmap.chunk);\n\tef->cmap.chunk = NULL;\n\tfree(ef->sb);\n\tef->sb = NULL;\n\tfree(ef->upcase);\n\tef->upcase = NULL;\n\tef->upcase_chars = 0;\n}\n"], "fixing_code": ["/*\n\tmount.c (22.10.09)\n\texFAT file system implementation library.\n\n\tFree exFAT implementation.\n\tCopyright (C) 2010-2015  Andrew Nayenko\n\n\tThis program is free software; you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 2 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License along\n\twith this program; if not, write to the Free Software Foundation, Inc.,\n\t51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"exfat.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <unistd.h>\n#include <sys/types.h>\n\nstatic uint64_t rootdir_size(const struct exfat* ef)\n{\n\tuint64_t clusters = 0;\n\tcluster_t rootdir_cluster = le32_to_cpu(ef->sb->rootdir_cluster);\n\n\twhile (!CLUSTER_INVALID(rootdir_cluster))\n\t{\n\t\tclusters++;\n\t\t/* root directory cannot be contiguous because there is no flag\n\t\t   to indicate this */\n\t\trootdir_cluster = exfat_next_cluster(ef, ef->root, rootdir_cluster);\n\t}\n\tif (rootdir_cluster != EXFAT_CLUSTER_END)\n\t{\n\t\texfat_error(\"bad cluster %#x while reading root directory\",\n\t\t\t\trootdir_cluster);\n\t\treturn 0;\n\t}\n\treturn clusters * CLUSTER_SIZE(*ef->sb);\n}\n\nstatic const char* get_option(const char* options, const char* option_name)\n{\n\tconst char* p;\n\tsize_t length = strlen(option_name);\n\n\tfor (p = strstr(options, option_name); p; p = strstr(p + 1, option_name))\n\t\tif ((p == options || p[-1] == ',') && p[length] == '=')\n\t\t\treturn p + length + 1;\n\treturn NULL;\n}\n\nstatic int get_int_option(const char* options, const char* option_name,\n\t\tint base, int default_value)\n{\n\tconst char* p = get_option(options, option_name);\n\n\tif (p == NULL)\n\t\treturn default_value;\n\treturn strtol(p, NULL, base);\n}\n\nstatic bool match_option(const char* options, const char* option_name)\n{\n\tconst char* p;\n\tsize_t length = strlen(option_name);\n\n\tfor (p = strstr(options, option_name); p; p = strstr(p + 1, option_name))\n\t\tif ((p == options || p[-1] == ',') &&\n\t\t\t\t(p[length] == ',' || p[length] == '\\0'))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic void parse_options(struct exfat* ef, const char* options)\n{\n\tint opt_umask;\n\n\topt_umask = get_int_option(options, \"umask\", 8, 0);\n\tef->dmask = get_int_option(options, \"dmask\", 8, opt_umask);\n\tef->fmask = get_int_option(options, \"fmask\", 8, opt_umask);\n\n\tef->uid = get_int_option(options, \"uid\", 10, geteuid());\n\tef->gid = get_int_option(options, \"gid\", 10, getegid());\n\n\tef->noatime = match_option(options, \"noatime\");\n}\n\nstatic bool verify_vbr_checksum(struct exfat_dev* dev, void* sector,\n\t\toff_t sector_size)\n{\n\tuint32_t vbr_checksum;\n\tint i;\n\n\tif (exfat_pread(dev, sector, sector_size, 0) < 0)\n\t{\n\t\texfat_error(\"failed to read boot sector\");\n\t\treturn false;\n\t}\n\tvbr_checksum = exfat_vbr_start_checksum(sector, sector_size);\n\tfor (i = 1; i < 11; i++)\n\t{\n\t\tif (exfat_pread(dev, sector, sector_size, i * sector_size) < 0)\n\t\t{\n\t\t\texfat_error(\"failed to read VBR sector\");\n\t\t\treturn false;\n\t\t}\n\t\tvbr_checksum = exfat_vbr_add_checksum(sector, sector_size,\n\t\t\t\tvbr_checksum);\n\t}\n\tif (exfat_pread(dev, sector, sector_size, i * sector_size) < 0)\n\t{\n\t\texfat_error(\"failed to read VBR checksum sector\");\n\t\treturn false;\n\t}\n\tfor (i = 0; i < sector_size / sizeof(vbr_checksum); i++)\n\t\tif (le32_to_cpu(((const le32_t*) sector)[i]) != vbr_checksum)\n\t\t{\n\t\t\texfat_error(\"invalid VBR checksum 0x%x (expected 0x%x)\",\n\t\t\t\t\tle32_to_cpu(((const le32_t*) sector)[i]), vbr_checksum);\n\t\t\treturn false;\n\t\t}\n\treturn true;\n}\n\nstatic int commit_super_block(const struct exfat* ef)\n{\n\tif (exfat_pwrite(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)\n\t{\n\t\texfat_error(\"failed to write super block\");\n\t\treturn 1;\n\t}\n\treturn exfat_fsync(ef->dev);\n}\n\nstatic int prepare_super_block(const struct exfat* ef)\n{\n\tif (le16_to_cpu(ef->sb->volume_state) & EXFAT_STATE_MOUNTED)\n\t\texfat_warn(\"volume was not unmounted cleanly\");\n\n\tif (ef->ro)\n\t\treturn 0;\n\n\tef->sb->volume_state = cpu_to_le16(\n\t\t\tle16_to_cpu(ef->sb->volume_state) | EXFAT_STATE_MOUNTED);\n\treturn commit_super_block(ef);\n}\n\nint exfat_mount(struct exfat* ef, const char* spec, const char* options)\n{\n\tint rc;\n\tenum exfat_mode mode;\n\n\texfat_tzset();\n\tmemset(ef, 0, sizeof(struct exfat));\n\n\tparse_options(ef, options);\n\n\tif (match_option(options, \"ro\"))\n\t\tmode = EXFAT_MODE_RO;\n\telse if (match_option(options, \"ro_fallback\"))\n\t\tmode = EXFAT_MODE_ANY;\n\telse\n\t\tmode = EXFAT_MODE_RW;\n\tef->dev = exfat_open(spec, mode);\n\tif (ef->dev == NULL)\n\t\treturn -EIO;\n\tif (exfat_get_mode(ef->dev) == EXFAT_MODE_RO)\n\t{\n\t\tif (mode == EXFAT_MODE_ANY)\n\t\t\tef->ro = -1;\n\t\telse\n\t\t\tef->ro = 1;\n\t}\n\n\tef->sb = malloc(sizeof(struct exfat_super_block));\n\tif (ef->sb == NULL)\n\t{\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"failed to allocate memory for the super block\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ef->sb, 0, sizeof(struct exfat_super_block));\n\n\tif (exfat_pread(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)\n\t{\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"failed to read boot sector\");\n\t\treturn -EIO;\n\t}\n\tif (memcmp(ef->sb->oem_name, \"EXFAT   \", 8) != 0)\n\t{\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"exFAT file system is not found\");\n\t\treturn -EIO;\n\t}\n\t/* sector cannot be smaller than 512 bytes */\n\tif (ef->sb->sector_bits < 9)\n\t{\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"too small sector size: 2^%hhd\", ef->sb->sector_bits);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\t/* officially exFAT supports cluster size up to 32 MB */\n\tif ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)\n\t{\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"too big cluster size: 2^(%hhd+%hhd)\",\n\t\t\t\tef->sb->sector_bits, ef->sb->spc_bits);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));\n\tif (ef->zero_cluster == NULL)\n\t{\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"failed to allocate zero sector\");\n\t\treturn -ENOMEM;\n\t}\n\t/* use zero_cluster as a temporary buffer for VBR checksum verification */\n\tif (!verify_vbr_checksum(ef->dev, ef->zero_cluster, SECTOR_SIZE(*ef->sb)))\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tmemset(ef->zero_cluster, 0, CLUSTER_SIZE(*ef->sb));\n\tif (ef->sb->version.major != 1 || ef->sb->version.minor != 0)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"unsupported exFAT version: %hhu.%hhu\",\n\t\t\t\tef->sb->version.major, ef->sb->version.minor);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tif (ef->sb->fat_count != 1)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\texfat_error(\"unsupported FAT count: %hhu\", ef->sb->fat_count);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\tif (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >\n\t\t\texfat_get_size(ef->dev))\n\t{\n\t\t/* this can cause I/O errors later but we don't fail mounting to let\n\t\t   user rescue data */\n\t\texfat_warn(\"file system is larger than underlying device: \"\n\t\t\t\t\"%\"PRIu64\" > %\"PRIu64,\n\t\t\t\tle64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb),\n\t\t\t\texfat_get_size(ef->dev));\n\t}\n\n\tef->root = malloc(sizeof(struct exfat_node));\n\tif (ef->root == NULL)\n\t{\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\texfat_error(\"failed to allocate root node\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ef->root, 0, sizeof(struct exfat_node));\n\tef->root->flags = EXFAT_ATTRIB_DIR;\n\tef->root->start_cluster = le32_to_cpu(ef->sb->rootdir_cluster);\n\tef->root->fptr_cluster = ef->root->start_cluster;\n\tef->root->name[0] = cpu_to_le16('\\0');\n\tef->root->size = rootdir_size(ef);\n\tif (ef->root->size == 0)\n\t{\n\t\tfree(ef->root);\n\t\tfree(ef->zero_cluster);\n\t\texfat_close(ef->dev);\n\t\tfree(ef->sb);\n\t\treturn -EIO;\n\t}\n\t/* exFAT does not have time attributes for the root directory */\n\tef->root->mtime = 0;\n\tef->root->atime = 0;\n\t/* always keep at least 1 reference to the root node */\n\texfat_get_node(ef->root);\n\n\trc = exfat_cache_directory(ef, ef->root);\n\tif (rc != 0)\n\t\tgoto error;\n\tif (ef->upcase == NULL)\n\t{\n\t\texfat_error(\"upcase table is not found\");\n\t\tgoto error;\n\t}\n\tif (ef->cmap.chunk == NULL)\n\t{\n\t\texfat_error(\"clusters bitmap is not found\");\n\t\tgoto error;\n\t}\n\n\tif (prepare_super_block(ef) != 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\texfat_put_node(ef, ef->root);\n\texfat_reset_cache(ef);\n\tfree(ef->root);\n\tfree(ef->zero_cluster);\n\texfat_close(ef->dev);\n\tfree(ef->sb);\n\treturn -EIO;\n}\n\nstatic void finalize_super_block(struct exfat* ef)\n{\n\tif (ef->ro)\n\t\treturn;\n\n\tef->sb->volume_state = cpu_to_le16(\n\t\t\tle16_to_cpu(ef->sb->volume_state) & ~EXFAT_STATE_MOUNTED);\n\n\t/* Some implementations set the percentage of allocated space to 0xff\n\t   on FS creation and never update it. In this case leave it as is. */\n\tif (ef->sb->allocated_percent != 0xff)\n\t{\n\t\tuint32_t free, total;\n\n\t\tfree = exfat_count_free_clusters(ef);\n\t\ttotal = le32_to_cpu(ef->sb->cluster_count);\n\t\tef->sb->allocated_percent = ((total - free) * 100 + total / 2) / total;\n\t}\n\n\tcommit_super_block(ef);\t/* ignore return code */\n}\n\nvoid exfat_unmount(struct exfat* ef)\n{\n\texfat_flush(ef);\t/* ignore return code */\n\texfat_put_node(ef, ef->root);\n\texfat_reset_cache(ef);\n\tfree(ef->root);\n\tef->root = NULL;\n\tfinalize_super_block(ef);\n\texfat_close(ef->dev);\t/* close descriptor immediately after fsync */\n\tef->dev = NULL;\n\tfree(ef->zero_cluster);\n\tef->zero_cluster = NULL;\n\tfree(ef->cmap.chunk);\n\tef->cmap.chunk = NULL;\n\tfree(ef->sb);\n\tef->sb = NULL;\n\tfree(ef->upcase);\n\tef->upcase = NULL;\n\tef->upcase_chars = 0;\n}\n"], "filenames": ["libexfat/mount.c"], "buggy_code_start_loc": [208], "buggy_code_end_loc": [250], "fixing_code_start_loc": [209], "fixing_code_end_loc": [256], "type": "CWE-119", "message": "Heap-based buffer overflow in the verify_vbr_checksum function in exfatfsck in exfat-utils before 1.2.1 allows remote attackers to cause a denial of service (infinite loop) or possibly execute arbitrary code via a crafted filesystem.", "other": {"cve": {"id": "CVE-2015-8026", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-27T15:59:00.170", "lastModified": "2021-06-03T19:47:50.067", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the verify_vbr_checksum function in exfatfsck in exfat-utils before 1.2.1 allows remote attackers to cause a denial of service (infinite loop) or possibly execute arbitrary code via a crafted filesystem."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n verify_vbr_checksum en exfatfsck en exfat-utils en versiones anteriores a 1.2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (bucle infinito) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de un sistema de archivos manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exfat_project:exfat:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "96104A66-4DF9-4D68-BB4D-F542C13360FD"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/10/29/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/77307", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blog.fuzzing-project.org/25-Heap-overflow-and-endless-loop-in-exfatfsck-exfat-utils.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/relan/exfat/commit/2e86ae5f81da11f11673d0546efb525af02b7786", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/relan/exfat/issues/5", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201612-31", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/relan/exfat/commit/2e86ae5f81da11f11673d0546efb525af02b7786"}}