{"buggy_code": ["en:\n  site_settings:\n    poll_enabled: \"Allow polls?\"\n    poll_maximum_options: \"Maximum number of options allowed in a poll.\"\n    poll_edit_window_mins: \"Number of minutes after post creation during which polls can be edited.\"\n    poll_minimum_trust_level_to_create: \"Define the minimum trust level needed to create polls.\"\n    poll_groupable_user_fields: \"A set of user field names that can be used to group and filter poll results.\"\n    poll_export_data_explorer_query_id: \"ID of the Data Explorer Query to use for exporting poll results (0 to disable).\"\n\n  poll:\n    poll: \"poll\"\n    invalid_argument: \"Invalid value '%{value}' for argument '%{argument}'.\"\n\n    multiple_polls_without_name: \"There are multiple polls without a name. Use the '<code>name</code>' attribute to uniquely identify your polls.\"\n    multiple_polls_with_same_name: \"There are multiple polls with the same name: <strong>%{name}</strong>. Use the '<code>name</code>' attribute to uniquely identify your polls.\"\n\n    default_poll_must_have_at_least_1_option: \"Poll must have at least 1 option.\"\n    named_poll_must_have_at_least_1_option: \"Poll named <strong>%{name}</strong> must have at least 1 option.\"\n\n    default_poll_must_have_less_options:\n      one: \"Poll must have less than %{count} option.\"\n      other: \"Poll must have less than %{count} options.\"\n    named_poll_must_have_less_options:\n      one: \"Poll named <strong>%{name}</strong> must have less than %{count} option.\"\n      other: \"Poll named <strong>%{name}</strong> must have less than %{count} options.\"\n\n    default_poll_must_have_different_options: \"Poll must have different options.\"\n    named_poll_must_have_different_options: \"Poll named <strong>%{name}</strong> must have different options.\"\n\n    default_poll_must_not_have_any_empty_options: \"Poll must not have any empty options.\"\n    named_poll_must_not_have_any_empty_options: \"Poll named <strong>%{name}</strong> must not have any empty options.\"\n\n    default_poll_with_multiple_choices_has_invalid_parameters: \"Poll with multiple choices has invalid parameters.\"\n    named_poll_with_multiple_choices_has_invalid_parameters: \"Poll named <strong>%{name}</strong> with multiple choice has invalid parameters.\"\n\n    requires_at_least_1_valid_option: \"You must select at least 1 valid option.\"\n\n    edit_window_expired:\n      cannot_edit_default_poll_with_votes: \"You cannot change a poll after the first %{minutes} minutes.\"\n      cannot_edit_named_poll_with_votes: \"You cannot change the poll name <strong>${name}</strong> after the first %{minutes} minutes.\"\n\n    no_poll_with_this_name: \"No poll named <strong>%{name}</strong> associated with this post.\"\n\n    post_is_deleted: \"Cannot act on a deleted post.\"\n\n    user_cant_post_in_topic: \"You can't vote because you can't post in this topic.\"\n\n    topic_must_be_open_to_vote: \"The topic must be open to vote.\"\n    poll_must_be_open_to_vote: \"Poll must be open to vote.\"\n\n    topic_must_be_open_to_toggle_status: \"The topic must be open to toggle status.\"\n    only_staff_or_op_can_toggle_status: \"Only a staff member or the original poster can toggle a poll status.\"\n\n    insufficient_rights_to_create: \"You are not allowed to create polls.\"\n\n    email:\n      link_to_poll: \"Click to view the poll.\"\n\n    user_field:\n      no_data: \"No Data\"\n", "# frozen_string_literal: true\n\n# name: poll\n# about: Official poll plugin for Discourse\n# version: 1.0\n# authors: Vikhyat Korrapati (vikhyat), R\u00e9gis Hanol (zogstrip)\n# url: https://github.com/discourse/discourse/tree/master/plugins/poll\n\nregister_asset \"stylesheets/common/poll.scss\"\nregister_asset \"stylesheets/common/poll-ui-builder.scss\"\nregister_asset \"stylesheets/common/poll-breakdown.scss\"\nregister_asset \"stylesheets/desktop/poll.scss\", :desktop\nregister_asset \"stylesheets/desktop/poll-ui-builder.scss\", :desktop\nregister_asset \"stylesheets/mobile/poll.scss\", :mobile\n\nregister_svg_icon \"far fa-check-square\"\n\nenabled_site_setting :poll_enabled\nhide_plugin if self.respond_to?(:hide_plugin)\n\nPLUGIN_NAME ||= \"discourse_poll\"\nDATA_PREFIX ||= \"data-poll-\"\n\nafter_initialize do\n\n  [\n    \"../app/models/poll_vote\",\n    \"../app/models/poll_option\",\n    \"../app/models/poll\",\n    \"../app/serializers/poll_option_serializer\",\n    \"../app/serializers/poll_serializer\",\n    \"../lib/polls_validator\",\n    \"../lib/polls_updater\",\n    \"../lib/post_validator\",\n    \"../jobs/regular/close_poll\",\n  ].each { |path| require File.expand_path(path, __FILE__) }\n\n  module ::DiscoursePoll\n    HAS_POLLS ||= \"has_polls\"\n    DEFAULT_POLL_NAME ||= \"poll\"\n\n    class Engine < ::Rails::Engine\n      engine_name PLUGIN_NAME\n      isolate_namespace DiscoursePoll\n    end\n  end\n\n  class DiscoursePoll::Poll\n    class << self\n\n      def vote(post_id, poll_name, options, user)\n        Poll.transaction do\n          post = Post.find_by(id: post_id)\n\n          # post must not be deleted\n          if post.nil? || post.trashed?\n            raise StandardError.new I18n.t(\"poll.post_is_deleted\")\n          end\n\n          # topic must not be archived\n          if post.topic&.archived\n            raise StandardError.new I18n.t(\"poll.topic_must_be_open_to_vote\")\n          end\n\n          # user must be allowed to post in topic\n          guardian = Guardian.new(user)\n          if !guardian.can_create_post?(post.topic)\n            raise StandardError.new I18n.t(\"poll.user_cant_post_in_topic\")\n          end\n\n          poll = Poll.includes(:poll_options).find_by(post_id: post_id, name: poll_name)\n\n          raise StandardError.new I18n.t(\"poll.no_poll_with_this_name\", name: poll_name) unless poll\n          raise StandardError.new I18n.t(\"poll.poll_must_be_open_to_vote\") if poll.is_closed?\n\n          if poll.groups\n            poll_groups = poll.groups.split(\",\").map(&:downcase)\n            user_groups = user.groups.map { |g| g.name.downcase }\n            if (poll_groups & user_groups).empty?\n              raise StandardError.new I18n.t(\"js.poll.results.groups.title\", groups: poll.groups)\n            end\n          end\n\n          # remove options that aren't available in the poll\n          available_options = poll.poll_options.map { |o| o.digest }.to_set\n          options.select! { |o| available_options.include?(o) }\n\n          raise StandardError.new I18n.t(\"poll.requires_at_least_1_valid_option\") if options.empty?\n\n          new_option_ids = poll.poll_options.each_with_object([]) do |option, obj|\n            obj << option.id if options.include?(option.digest)\n          end\n\n          old_option_ids = poll.poll_options.each_with_object([]) do |option, obj|\n            if option.poll_votes.where(user_id: user.id).exists?\n              obj << option.id\n            end\n          end\n\n          # remove non-selected votes\n          PollVote\n            .where(poll: poll, user: user)\n            .where.not(poll_option_id: new_option_ids)\n            .delete_all\n\n          # create missing votes\n          (new_option_ids - old_option_ids).each do |option_id|\n            PollVote.create!(poll: poll, user: user, poll_option_id: option_id)\n          end\n\n          poll.reload\n\n          serialized_poll = PollSerializer.new(poll, root: false, scope: guardian).as_json\n          payload = { post_id: post_id, polls: [serialized_poll] }\n\n          post.publish_message!(\"/polls/#{post.topic_id}\", payload)\n\n          [serialized_poll, options]\n        end\n      end\n\n      def toggle_status(post_id, poll_name, status, user, raise_errors = true)\n        Poll.transaction do\n          post = Post.find_by(id: post_id)\n          guardian = Guardian.new(user)\n\n          # post must not be deleted\n          if post.nil? || post.trashed?\n            raise StandardError.new I18n.t(\"poll.post_is_deleted\") if raise_errors\n            return\n          end\n\n          # topic must not be archived\n          if post.topic&.archived\n            raise StandardError.new I18n.t(\"poll.topic_must_be_open_to_toggle_status\") if raise_errors\n            return\n          end\n\n          # either staff member or OP\n          unless post.user_id == user&.id || user&.staff?\n            raise StandardError.new I18n.t(\"poll.only_staff_or_op_can_toggle_status\") if raise_errors\n            return\n          end\n\n          poll = Poll.find_by(post_id: post_id, name: poll_name)\n\n          if !poll\n            raise StandardError.new I18n.t(\"poll.no_poll_with_this_name\", name: poll_name) if raise_errors\n            return\n          end\n\n          poll.status = status\n          poll.save!\n\n          serialized_poll = PollSerializer.new(poll, root: false, scope: guardian).as_json\n          payload = { post_id: post_id, polls: [serialized_poll] }\n\n          post.publish_message!(\"/polls/#{post.topic_id}\", payload)\n\n          serialized_poll\n        end\n      end\n\n      def serialized_voters(poll, opts = {})\n        limit = (opts[\"limit\"] || 25).to_i\n        limit = 0  if limit < 0\n        limit = 50 if limit > 50\n\n        page = (opts[\"page\"] || 1).to_i\n        page = 1 if page < 1\n\n        offset = (page - 1) * limit\n\n        option_digest = opts[\"option_id\"].to_s\n\n        if poll.number?\n          user_ids = PollVote\n            .where(poll: poll)\n            .group(:user_id)\n            .order(\"MIN(created_at)\")\n            .offset(offset)\n            .limit(limit)\n            .pluck(:user_id)\n\n          result = User.where(id: user_ids).map { |u| UserNameSerializer.new(u).serializable_hash }\n        elsif option_digest.present?\n          poll_option = PollOption.find_by(poll: poll, digest: option_digest)\n\n          raise Discourse::InvalidParameters.new(:option_id) unless poll_option\n\n          user_ids = PollVote\n            .where(poll: poll, poll_option: poll_option)\n            .group(:user_id)\n            .order(\"MIN(created_at)\")\n            .offset(offset)\n            .limit(limit)\n            .pluck(:user_id)\n\n          user_hashes = User.where(id: user_ids).map { |u| UserNameSerializer.new(u).serializable_hash }\n\n          result = { option_digest => user_hashes }\n        else\n          votes = DB.query <<~SQL\n            SELECT digest, user_id\n              FROM (\n                SELECT digest\n                     , user_id\n                     , ROW_NUMBER() OVER (PARTITION BY poll_option_id ORDER BY pv.created_at) AS row\n                  FROM poll_votes pv\n                  JOIN poll_options po ON pv.poll_option_id = po.id\n                 WHERE pv.poll_id = #{poll.id}\n                   AND po.poll_id = #{poll.id}\n              ) v\n              WHERE row BETWEEN #{offset} AND #{offset + limit}\n          SQL\n\n          user_ids = votes.map(&:user_id).uniq\n\n          user_hashes = User\n            .where(id: user_ids)\n            .map { |u| [u.id, UserNameSerializer.new(u).serializable_hash] }\n            .to_h\n\n          result = {}\n          votes.each do |v|\n            result[v.digest] ||= []\n            result[v.digest] << user_hashes[v.user_id]\n          end\n        end\n\n        result\n      end\n\n      def voters(post_id, poll_name, user, opts = {})\n        post = Post.find_by(id: post_id)\n        raise Discourse::InvalidParameters.new(:post_id) unless post\n\n        poll = Poll.find_by(post_id: post_id, name: poll_name)\n        raise Discourse::InvalidParameters.new(:poll_name) unless poll&.can_see_voters?(user)\n\n        serialized_voters(poll, opts)\n      end\n\n      def transform_for_user_field_override(custom_user_field)\n        existing_field = UserField.find_by(name: custom_user_field)\n        existing_field ? \"user_field_#{existing_field.id}\" : custom_user_field\n      end\n\n      def grouped_poll_results(post_id, poll_name, user_field_name, user)\n        post = Post.find_by(id: post_id)\n        raise Discourse::InvalidParameters.new(:post_id) unless post\n\n        poll = Poll.includes(:poll_options).includes(:poll_votes).find_by(post_id: post_id, name: poll_name)\n        raise Discourse::InvalidParameters.new(:poll_name) unless poll\n\n        raise Discourse::InvalidParameters.new(:user_field_name) unless SiteSetting.poll_groupable_user_fields.split('|').include?(user_field_name)\n\n        poll_votes = poll.poll_votes\n\n        poll_options = {}\n        poll.poll_options.each do |option|\n          poll_options[option.id.to_s] = { html: option.html, digest: option.digest }\n        end\n\n        user_ids = poll_votes.map(&:user_id).uniq\n        user_fields = UserCustomField.where(user_id: user_ids, name: transform_for_user_field_override(user_field_name))\n\n        user_field_map = {}\n        user_fields.each do |f|\n          # Build hash, so we can quickly look up field values for each user.\n          user_field_map[f.user_id] = f.value\n        end\n\n        votes_with_field = poll_votes.map do |vote|\n          v = vote.attributes\n          v[:field_value] = user_field_map[vote.user_id]\n          v\n        end\n\n        chart_data = []\n        votes_with_field.group_by { |vote| vote[:field_value] }.each do |field_answer, votes|\n          grouped_selected_options = {}\n\n          # Create all the options with 0 votes. This ensures all the charts will have the same order of options, and same colors per option.\n          poll_options.each do |id, option|\n            grouped_selected_options[id] = {\n              digest: option[:digest],\n              html: option[:html],\n              votes: 0\n            }\n          end\n\n          # Now go back and update the vote counts. Using hashes so we dont have n^2\n          votes.group_by { |v| v[\"poll_option_id\"] }.each do |option_id, votes_for_option|\n            grouped_selected_options[option_id.to_s][:votes] = votes_for_option.length\n          end\n\n          group_label = field_answer ? field_answer.titleize : I18n.t(\"poll.user_field.no_data\")\n          chart_data << { group: group_label, options: grouped_selected_options.values }\n        end\n        chart_data\n      end\n\n      def schedule_jobs(post)\n        Poll.where(post: post).find_each do |poll|\n          job_args = {\n            post_id: post.id,\n            poll_name: poll.name\n          }\n\n          Jobs.cancel_scheduled_job(:close_poll, job_args)\n\n          if poll.open? && poll.close_at && poll.close_at > Time.zone.now\n            Jobs.enqueue_at(poll.close_at, :close_poll, job_args)\n          end\n        end\n      end\n\n      def create!(post_id, poll)\n        close_at = begin\n          Time.zone.parse(poll[\"close\"] || '')\n        rescue ArgumentError\n        end\n\n        created_poll = Poll.create!(\n          post_id: post_id,\n          name: poll[\"name\"].presence || \"poll\",\n          close_at: close_at,\n          type: poll[\"type\"].presence || \"regular\",\n          status: poll[\"status\"].presence || \"open\",\n          visibility: poll[\"public\"] == \"true\" ? \"everyone\" : \"secret\",\n          title: poll[\"title\"],\n          results: poll[\"results\"].presence || \"always\",\n          min: poll[\"min\"],\n          max: poll[\"max\"],\n          step: poll[\"step\"],\n          chart_type: poll[\"charttype\"] || \"bar\",\n          groups: poll[\"groups\"]\n        )\n\n        poll[\"options\"].each do |option|\n          PollOption.create!(\n            poll: created_poll,\n            digest: option[\"id\"].presence,\n            html: option[\"html\"].presence&.strip\n          )\n        end\n      end\n\n      def extract(raw, topic_id, user_id = nil)\n        # TODO: we should fix the callback mess so that the cooked version is available\n        # in the validators instead of cooking twice\n        cooked = PrettyText.cook(raw, topic_id: topic_id, user_id: user_id)\n\n        Nokogiri::HTML5(cooked).css(\"div.poll\").map do |p|\n          poll = { \"options\" => [], \"name\" => DiscoursePoll::DEFAULT_POLL_NAME }\n\n          # attributes\n          p.attributes.values.each do |attribute|\n            if attribute.name.start_with?(DATA_PREFIX)\n              poll[attribute.name[DATA_PREFIX.length..-1]] = CGI.escapeHTML(attribute.value || \"\")\n            end\n          end\n\n          # options\n          p.css(\"li[#{DATA_PREFIX}option-id]\").each do |o|\n            option_id = o.attributes[DATA_PREFIX + \"option-id\"].value.to_s\n            poll[\"options\"] << { \"id\" => option_id, \"html\" => o.inner_html.strip }\n          end\n\n          # title\n          title_element = p.css(\".poll-title\").first\n          if title_element\n            poll[\"title\"] = title_element.inner_html.strip\n          end\n\n          poll\n        end\n      end\n    end\n  end\n\n  class DiscoursePoll::PollsController < ::ApplicationController\n    requires_plugin PLUGIN_NAME\n\n    before_action :ensure_logged_in, except: [:voters, :grouped_poll_results]\n\n    def vote\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n      options   = params.require(:options)\n\n      begin\n        poll, options = DiscoursePoll::Poll.vote(post_id, poll_name, options, current_user)\n        render json: { poll: poll, vote: options }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def toggle_status\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n      status    = params.require(:status)\n\n      begin\n        poll = DiscoursePoll::Poll.toggle_status(post_id, poll_name, status, current_user)\n        render json: { poll: poll }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def voters\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n\n      opts = params.permit(:limit, :page, :option_id)\n\n      begin\n        render json: { voters: DiscoursePoll::Poll.voters(post_id, poll_name, current_user, opts) }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def grouped_poll_results\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n      user_field_name = params.require(:user_field_name)\n\n      begin\n        render json: {\n          grouped_results: DiscoursePoll::Poll.grouped_poll_results(post_id, poll_name, user_field_name, current_user)\n        }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def groupable_user_fields\n      render json: {\n        fields: SiteSetting.poll_groupable_user_fields.split('|').map do |field|\n          { name: field.humanize.capitalize, value: field }\n        end\n      }\n    end\n  end\n\n  DiscoursePoll::Engine.routes.draw do\n    put \"/vote\" => \"polls#vote\"\n    put \"/toggle_status\" => \"polls#toggle_status\"\n    get \"/voters\" => 'polls#voters'\n    get \"/grouped_poll_results\" => 'polls#grouped_poll_results'\n    get \"/groupable_user_fields\" => 'polls#groupable_user_fields'\n  end\n\n  Discourse::Application.routes.append do\n    mount ::DiscoursePoll::Engine, at: \"/polls\"\n  end\n\n  reloadable_patch do\n    Post.class_eval do\n      attr_accessor :extracted_polls\n\n      has_many :polls, dependent: :destroy\n\n      after_save do\n        polls = self.extracted_polls\n        next if polls.blank? || !polls.is_a?(Hash)\n        post = self\n\n        Poll.transaction do\n          polls.values.each do |poll|\n            DiscoursePoll::Poll.create!(post.id, poll)\n          end\n          post.custom_fields[DiscoursePoll::HAS_POLLS] = true\n          post.save_custom_fields(true)\n        end\n      end\n    end\n\n    User.class_eval do\n      has_many :poll_votes, dependent: :delete_all\n    end\n  end\n\n  validate(:post, :validate_polls) do |force = nil|\n    return unless self.raw_changed? || force\n\n    validator = DiscoursePoll::PollsValidator.new(self)\n    return unless (polls = validator.validate_polls)\n\n    if polls.present?\n      validator = DiscoursePoll::PostValidator.new(self)\n      return unless validator.validate_post\n    end\n\n    # are we updating a post?\n    if self.id.present?\n      DiscoursePoll::PollsUpdater.update(self, polls)\n    else\n      self.extracted_polls = polls\n    end\n\n    true\n  end\n\n  allow_new_queued_post_payload_attribute(\"is_poll\")\n\n  NewPostManager.add_handler(1) do |manager|\n    post = Post.new(raw: manager.args[:raw])\n\n    if !DiscoursePoll::PollsValidator.new(post).validate_polls\n      result = NewPostResult.new(:poll, false)\n\n      post.errors.full_messages.each do |message|\n        result.errors[:base] << message\n      end\n\n      result\n    else\n      manager.args[\"is_poll\"] = true\n      nil\n    end\n  end\n\n  on(:approved_post) do |queued_post, created_post|\n    if queued_post.payload[\"is_poll\"]\n      created_post.validate_polls(true)\n    end\n  end\n\n  on(:reduce_cooked) do |fragment, post|\n    if post.nil? || post.trashed?\n      fragment.css(\".poll, [data-poll-name]\").each(&:remove)\n    else\n      post_url = post.full_url\n      fragment.css(\".poll, [data-poll-name]\").each do |poll|\n        poll.replace \"<p><a href='#{post_url}'>#{I18n.t(\"poll.email.link_to_poll\")}</a></p>\"\n      end\n    end\n  end\n\n  on(:reduce_excerpt) do |doc, options|\n    post = options[:post]\n\n    replacement = post&.url.present? ?\n      \"<a href='#{UrlHelper.escape_uri(post.url)}'>#{I18n.t(\"poll.poll\")}</a>\" :\n      I18n.t(\"poll.poll\")\n\n    doc.css(\"div.poll\").each do |poll|\n      poll.replace(replacement)\n    end\n  end\n\n  on(:post_created) do |post, _opts, user|\n    guardian = Guardian.new(user)\n    DiscoursePoll::Poll.schedule_jobs(post)\n\n    unless post.is_first_post?\n      polls = ActiveModel::ArraySerializer.new(post.polls, each_serializer: PollSerializer, root: false, scope: guardian).as_json\n      post.publish_message!(\"/polls/#{post.topic_id}\", post_id: post.id, polls: polls)\n    end\n  end\n\n  on(:merging_users) do |source_user, target_user|\n    PollVote.where(user_id: source_user.id).update_all(user_id: target_user.id)\n  end\n\n  register_post_custom_field_type(DiscoursePoll::HAS_POLLS, :boolean)\n\n  topic_view_post_custom_fields_allowlister { [DiscoursePoll::HAS_POLLS] }\n\n  add_to_class(:topic_view, :polls) do\n    @polls ||= begin\n      polls = {}\n\n      post_with_polls = @post_custom_fields.each_with_object([]) do |fields, obj|\n        obj << fields[0] if fields[1][DiscoursePoll::HAS_POLLS]\n      end\n\n      if post_with_polls.present?\n        Poll\n          .where(post_id: post_with_polls)\n          .each do |p|\n            polls[p.post_id] ||= []\n            polls[p.post_id] << p\n          end\n      end\n\n      polls\n    end\n  end\n\n  add_to_serializer(:post, :preloaded_polls, false) do\n    @preloaded_polls ||= if @topic_view.present?\n      @topic_view.polls[object.id]\n    else\n      Poll.includes(:poll_options).where(post: object)\n    end\n  end\n\n  add_to_serializer(:post, :include_preloaded_polls?) do\n    false\n  end\n\n  add_to_serializer(:post, :polls, false) do\n    preloaded_polls.map { |p| PollSerializer.new(p, root: false, scope: self.scope) }\n  end\n\n  add_to_serializer(:post, :include_polls?) do\n    SiteSetting.poll_enabled && preloaded_polls.present?\n  end\n\n  add_to_serializer(:post, :polls_votes, false) do\n    preloaded_polls.map do |poll|\n      user_poll_votes =\n        poll\n          .poll_votes\n          .where(user_id: scope.user.id)\n          .joins(:poll_option)\n          .pluck(\"poll_options.digest\")\n\n      [poll.name, user_poll_votes]\n    end.to_h\n  end\n\n  add_to_serializer(:post, :include_polls_votes?) do\n    SiteSetting.poll_enabled &&\n    scope.user&.id.present? &&\n    preloaded_polls.present? &&\n    preloaded_polls.any? { |p| p.has_voted?(scope.user) }\n  end\nend\n"], "fixing_code": ["en:\n  site_settings:\n    poll_enabled: \"Allow polls?\"\n    poll_maximum_options: \"Maximum number of options allowed in a poll.\"\n    poll_edit_window_mins: \"Number of minutes after post creation during which polls can be edited.\"\n    poll_minimum_trust_level_to_create: \"Define the minimum trust level needed to create polls.\"\n    poll_groupable_user_fields: \"A set of user field names that can be used to group and filter poll results.\"\n    poll_export_data_explorer_query_id: \"ID of the Data Explorer Query to use for exporting poll results (0 to disable).\"\n\n  poll:\n    poll: \"poll\"\n    invalid_argument: \"Invalid value '%{value}' for argument '%{argument}'.\"\n\n    multiple_polls_without_name: \"There are multiple polls without a name. Use the '<code>name</code>' attribute to uniquely identify your polls.\"\n    multiple_polls_with_same_name: \"There are multiple polls with the same name: <strong>%{name}</strong>. Use the '<code>name</code>' attribute to uniquely identify your polls.\"\n\n    default_poll_must_have_at_least_1_option: \"Poll must have at least 1 option.\"\n    named_poll_must_have_at_least_1_option: \"Poll named <strong>%{name}</strong> must have at least 1 option.\"\n\n    default_poll_must_have_less_options:\n      one: \"Poll must have less than %{count} option.\"\n      other: \"Poll must have less than %{count} options.\"\n    named_poll_must_have_less_options:\n      one: \"Poll named <strong>%{name}</strong> must have less than %{count} option.\"\n      other: \"Poll named <strong>%{name}</strong> must have less than %{count} options.\"\n\n    default_poll_must_have_different_options: \"Poll must have different options.\"\n    named_poll_must_have_different_options: \"Poll named <strong>%{name}</strong> must have different options.\"\n\n    default_poll_must_not_have_any_empty_options: \"Poll must not have any empty options.\"\n    named_poll_must_not_have_any_empty_options: \"Poll named <strong>%{name}</strong> must not have any empty options.\"\n\n    default_poll_with_multiple_choices_has_invalid_parameters: \"Poll with multiple choices has invalid parameters.\"\n    named_poll_with_multiple_choices_has_invalid_parameters: \"Poll named <strong>%{name}</strong> with multiple choice has invalid parameters.\"\n\n    requires_at_least_1_valid_option: \"You must select at least 1 valid option.\"\n\n    edit_window_expired:\n      cannot_edit_default_poll_with_votes: \"You cannot change a poll after the first %{minutes} minutes.\"\n      cannot_edit_named_poll_with_votes: \"You cannot change the poll name <strong>${name}</strong> after the first %{minutes} minutes.\"\n\n    no_poll_with_this_name: \"No poll named <strong>%{name}</strong> associated with this post.\"\n\n    post_is_deleted: \"Cannot act on a deleted post.\"\n\n    user_cant_post_in_topic: \"You can't vote because you can't post in this topic.\"\n\n    topic_must_be_open_to_vote: \"The topic must be open to vote.\"\n    poll_must_be_open_to_vote: \"Poll must be open to vote.\"\n\n    one_vote_per_user: \"Only 1 vote is allowed for this poll.\"\n    max_vote_per_user:\n      one: Only %{count} vote is allowed for this poll.\n      other: A maximum of %{count} votes is allowed for this poll.\n    min_vote_per_user:\n      one: A minimum of %{count} vote is required for this poll.\n      other: A minimum of %{count} votes is required for this poll.\n\n    topic_must_be_open_to_toggle_status: \"The topic must be open to toggle status.\"\n    only_staff_or_op_can_toggle_status: \"Only a staff member or the original poster can toggle a poll status.\"\n\n    insufficient_rights_to_create: \"You are not allowed to create polls.\"\n\n    email:\n      link_to_poll: \"Click to view the poll.\"\n\n    user_field:\n      no_data: \"No Data\"\n", "# frozen_string_literal: true\n\n# name: poll\n# about: Official poll plugin for Discourse\n# version: 1.0\n# authors: Vikhyat Korrapati (vikhyat), R\u00e9gis Hanol (zogstrip)\n# url: https://github.com/discourse/discourse/tree/master/plugins/poll\n\nregister_asset \"stylesheets/common/poll.scss\"\nregister_asset \"stylesheets/common/poll-ui-builder.scss\"\nregister_asset \"stylesheets/common/poll-breakdown.scss\"\nregister_asset \"stylesheets/desktop/poll.scss\", :desktop\nregister_asset \"stylesheets/desktop/poll-ui-builder.scss\", :desktop\nregister_asset \"stylesheets/mobile/poll.scss\", :mobile\n\nregister_svg_icon \"far fa-check-square\"\n\nenabled_site_setting :poll_enabled\nhide_plugin if self.respond_to?(:hide_plugin)\n\nPLUGIN_NAME ||= \"discourse_poll\"\nDATA_PREFIX ||= \"data-poll-\"\n\nafter_initialize do\n\n  [\n    \"../app/models/poll_vote\",\n    \"../app/models/poll_option\",\n    \"../app/models/poll\",\n    \"../app/serializers/poll_option_serializer\",\n    \"../app/serializers/poll_serializer\",\n    \"../lib/polls_validator\",\n    \"../lib/polls_updater\",\n    \"../lib/post_validator\",\n    \"../jobs/regular/close_poll\",\n  ].each { |path| require File.expand_path(path, __FILE__) }\n\n  module ::DiscoursePoll\n    HAS_POLLS ||= \"has_polls\"\n    DEFAULT_POLL_NAME ||= \"poll\"\n\n    class Engine < ::Rails::Engine\n      engine_name PLUGIN_NAME\n      isolate_namespace DiscoursePoll\n    end\n  end\n\n  class DiscoursePoll::Poll\n    class << self\n\n      def vote(post_id, poll_name, options, user)\n        Poll.transaction do\n          post = Post.find_by(id: post_id)\n\n          # post must not be deleted\n          if post.nil? || post.trashed?\n            raise StandardError.new I18n.t(\"poll.post_is_deleted\")\n          end\n\n          # topic must not be archived\n          if post.topic&.archived\n            raise StandardError.new I18n.t(\"poll.topic_must_be_open_to_vote\")\n          end\n\n          # user must be allowed to post in topic\n          guardian = Guardian.new(user)\n          if !guardian.can_create_post?(post.topic)\n            raise StandardError.new I18n.t(\"poll.user_cant_post_in_topic\")\n          end\n\n          poll = Poll.includes(:poll_options).find_by(post_id: post_id, name: poll_name)\n\n          raise StandardError.new I18n.t(\"poll.no_poll_with_this_name\", name: poll_name) unless poll\n          raise StandardError.new I18n.t(\"poll.poll_must_be_open_to_vote\") if poll.is_closed?\n\n          if poll.groups\n            poll_groups = poll.groups.split(\",\").map(&:downcase)\n            user_groups = user.groups.map { |g| g.name.downcase }\n            if (poll_groups & user_groups).empty?\n              raise StandardError.new I18n.t(\"js.poll.results.groups.title\", groups: poll.groups)\n            end\n          end\n\n          # remove options that aren't available in the poll\n          available_options = poll.poll_options.map { |o| o.digest }.to_set\n          options.select! { |o| available_options.include?(o) }\n\n          self.validate_votes!(poll, options)\n          raise StandardError.new I18n.t(\"poll.requires_at_least_1_valid_option\") if options.empty?\n\n          new_option_ids = poll.poll_options.each_with_object([]) do |option, obj|\n            obj << option.id if options.include?(option.digest)\n          end\n\n          old_option_ids = poll.poll_options.each_with_object([]) do |option, obj|\n            if option.poll_votes.where(user_id: user.id).exists?\n              obj << option.id\n            end\n          end\n\n          # remove non-selected votes\n          PollVote\n            .where(poll: poll, user: user)\n            .where.not(poll_option_id: new_option_ids)\n            .delete_all\n\n          # create missing votes\n          (new_option_ids - old_option_ids).each do |option_id|\n            PollVote.create!(poll: poll, user: user, poll_option_id: option_id)\n          end\n\n          poll.reload\n\n          serialized_poll = PollSerializer.new(poll, root: false, scope: guardian).as_json\n          payload = { post_id: post_id, polls: [serialized_poll] }\n\n          post.publish_message!(\"/polls/#{post.topic_id}\", payload)\n\n          [serialized_poll, options]\n        end\n      end\n\n      def validate_votes!(poll, options)\n        num_of_options = options.length\n\n        if poll.multiple?\n          if num_of_options < poll.min\n            raise StandardError.new(I18n.t(\n              \"poll.min_vote_per_user\",\n              count: poll.min\n            ))\n          elsif num_of_options > poll.max\n            raise StandardError.new(I18n.t(\n              \"poll.max_vote_per_user\",\n              count: poll.max\n            ))\n          end\n        elsif num_of_options > 1\n          raise StandardError.new(I18n.t(\"poll.one_vote_per_user\"))\n        end\n      end\n\n      def toggle_status(post_id, poll_name, status, user, raise_errors = true)\n        Poll.transaction do\n          post = Post.find_by(id: post_id)\n          guardian = Guardian.new(user)\n\n          # post must not be deleted\n          if post.nil? || post.trashed?\n            raise StandardError.new I18n.t(\"poll.post_is_deleted\") if raise_errors\n            return\n          end\n\n          # topic must not be archived\n          if post.topic&.archived\n            raise StandardError.new I18n.t(\"poll.topic_must_be_open_to_toggle_status\") if raise_errors\n            return\n          end\n\n          # either staff member or OP\n          unless post.user_id == user&.id || user&.staff?\n            raise StandardError.new I18n.t(\"poll.only_staff_or_op_can_toggle_status\") if raise_errors\n            return\n          end\n\n          poll = Poll.find_by(post_id: post_id, name: poll_name)\n\n          if !poll\n            raise StandardError.new I18n.t(\"poll.no_poll_with_this_name\", name: poll_name) if raise_errors\n            return\n          end\n\n          poll.status = status\n          poll.save!\n\n          serialized_poll = PollSerializer.new(poll, root: false, scope: guardian).as_json\n          payload = { post_id: post_id, polls: [serialized_poll] }\n\n          post.publish_message!(\"/polls/#{post.topic_id}\", payload)\n\n          serialized_poll\n        end\n      end\n\n      def serialized_voters(poll, opts = {})\n        limit = (opts[\"limit\"] || 25).to_i\n        limit = 0  if limit < 0\n        limit = 50 if limit > 50\n\n        page = (opts[\"page\"] || 1).to_i\n        page = 1 if page < 1\n\n        offset = (page - 1) * limit\n\n        option_digest = opts[\"option_id\"].to_s\n\n        if poll.number?\n          user_ids = PollVote\n            .where(poll: poll)\n            .group(:user_id)\n            .order(\"MIN(created_at)\")\n            .offset(offset)\n            .limit(limit)\n            .pluck(:user_id)\n\n          result = User.where(id: user_ids).map { |u| UserNameSerializer.new(u).serializable_hash }\n        elsif option_digest.present?\n          poll_option = PollOption.find_by(poll: poll, digest: option_digest)\n\n          raise Discourse::InvalidParameters.new(:option_id) unless poll_option\n\n          user_ids = PollVote\n            .where(poll: poll, poll_option: poll_option)\n            .group(:user_id)\n            .order(\"MIN(created_at)\")\n            .offset(offset)\n            .limit(limit)\n            .pluck(:user_id)\n\n          user_hashes = User.where(id: user_ids).map { |u| UserNameSerializer.new(u).serializable_hash }\n\n          result = { option_digest => user_hashes }\n        else\n          votes = DB.query <<~SQL\n            SELECT digest, user_id\n              FROM (\n                SELECT digest\n                     , user_id\n                     , ROW_NUMBER() OVER (PARTITION BY poll_option_id ORDER BY pv.created_at) AS row\n                  FROM poll_votes pv\n                  JOIN poll_options po ON pv.poll_option_id = po.id\n                 WHERE pv.poll_id = #{poll.id}\n                   AND po.poll_id = #{poll.id}\n              ) v\n              WHERE row BETWEEN #{offset} AND #{offset + limit}\n          SQL\n\n          user_ids = votes.map(&:user_id).uniq\n\n          user_hashes = User\n            .where(id: user_ids)\n            .map { |u| [u.id, UserNameSerializer.new(u).serializable_hash] }\n            .to_h\n\n          result = {}\n          votes.each do |v|\n            result[v.digest] ||= []\n            result[v.digest] << user_hashes[v.user_id]\n          end\n        end\n\n        result\n      end\n\n      def voters(post_id, poll_name, user, opts = {})\n        post = Post.find_by(id: post_id)\n        raise Discourse::InvalidParameters.new(:post_id) unless post\n\n        poll = Poll.find_by(post_id: post_id, name: poll_name)\n        raise Discourse::InvalidParameters.new(:poll_name) unless poll&.can_see_voters?(user)\n\n        serialized_voters(poll, opts)\n      end\n\n      def transform_for_user_field_override(custom_user_field)\n        existing_field = UserField.find_by(name: custom_user_field)\n        existing_field ? \"user_field_#{existing_field.id}\" : custom_user_field\n      end\n\n      def grouped_poll_results(post_id, poll_name, user_field_name, user)\n        post = Post.find_by(id: post_id)\n        raise Discourse::InvalidParameters.new(:post_id) unless post\n\n        poll = Poll.includes(:poll_options).includes(:poll_votes).find_by(post_id: post_id, name: poll_name)\n        raise Discourse::InvalidParameters.new(:poll_name) unless poll\n\n        raise Discourse::InvalidParameters.new(:user_field_name) unless SiteSetting.poll_groupable_user_fields.split('|').include?(user_field_name)\n\n        poll_votes = poll.poll_votes\n\n        poll_options = {}\n        poll.poll_options.each do |option|\n          poll_options[option.id.to_s] = { html: option.html, digest: option.digest }\n        end\n\n        user_ids = poll_votes.map(&:user_id).uniq\n        user_fields = UserCustomField.where(user_id: user_ids, name: transform_for_user_field_override(user_field_name))\n\n        user_field_map = {}\n        user_fields.each do |f|\n          # Build hash, so we can quickly look up field values for each user.\n          user_field_map[f.user_id] = f.value\n        end\n\n        votes_with_field = poll_votes.map do |vote|\n          v = vote.attributes\n          v[:field_value] = user_field_map[vote.user_id]\n          v\n        end\n\n        chart_data = []\n        votes_with_field.group_by { |vote| vote[:field_value] }.each do |field_answer, votes|\n          grouped_selected_options = {}\n\n          # Create all the options with 0 votes. This ensures all the charts will have the same order of options, and same colors per option.\n          poll_options.each do |id, option|\n            grouped_selected_options[id] = {\n              digest: option[:digest],\n              html: option[:html],\n              votes: 0\n            }\n          end\n\n          # Now go back and update the vote counts. Using hashes so we dont have n^2\n          votes.group_by { |v| v[\"poll_option_id\"] }.each do |option_id, votes_for_option|\n            grouped_selected_options[option_id.to_s][:votes] = votes_for_option.length\n          end\n\n          group_label = field_answer ? field_answer.titleize : I18n.t(\"poll.user_field.no_data\")\n          chart_data << { group: group_label, options: grouped_selected_options.values }\n        end\n        chart_data\n      end\n\n      def schedule_jobs(post)\n        Poll.where(post: post).find_each do |poll|\n          job_args = {\n            post_id: post.id,\n            poll_name: poll.name\n          }\n\n          Jobs.cancel_scheduled_job(:close_poll, job_args)\n\n          if poll.open? && poll.close_at && poll.close_at > Time.zone.now\n            Jobs.enqueue_at(poll.close_at, :close_poll, job_args)\n          end\n        end\n      end\n\n      def create!(post_id, poll)\n        close_at = begin\n          Time.zone.parse(poll[\"close\"] || '')\n        rescue ArgumentError\n        end\n\n        created_poll = Poll.create!(\n          post_id: post_id,\n          name: poll[\"name\"].presence || \"poll\",\n          close_at: close_at,\n          type: poll[\"type\"].presence || \"regular\",\n          status: poll[\"status\"].presence || \"open\",\n          visibility: poll[\"public\"] == \"true\" ? \"everyone\" : \"secret\",\n          title: poll[\"title\"],\n          results: poll[\"results\"].presence || \"always\",\n          min: poll[\"min\"],\n          max: poll[\"max\"],\n          step: poll[\"step\"],\n          chart_type: poll[\"charttype\"] || \"bar\",\n          groups: poll[\"groups\"]\n        )\n\n        poll[\"options\"].each do |option|\n          PollOption.create!(\n            poll: created_poll,\n            digest: option[\"id\"].presence,\n            html: option[\"html\"].presence&.strip\n          )\n        end\n      end\n\n      def extract(raw, topic_id, user_id = nil)\n        # TODO: we should fix the callback mess so that the cooked version is available\n        # in the validators instead of cooking twice\n        cooked = PrettyText.cook(raw, topic_id: topic_id, user_id: user_id)\n\n        Nokogiri::HTML5(cooked).css(\"div.poll\").map do |p|\n          poll = { \"options\" => [], \"name\" => DiscoursePoll::DEFAULT_POLL_NAME }\n\n          # attributes\n          p.attributes.values.each do |attribute|\n            if attribute.name.start_with?(DATA_PREFIX)\n              poll[attribute.name[DATA_PREFIX.length..-1]] = CGI.escapeHTML(attribute.value || \"\")\n            end\n          end\n\n          # options\n          p.css(\"li[#{DATA_PREFIX}option-id]\").each do |o|\n            option_id = o.attributes[DATA_PREFIX + \"option-id\"].value.to_s\n            poll[\"options\"] << { \"id\" => option_id, \"html\" => o.inner_html.strip }\n          end\n\n          # title\n          title_element = p.css(\".poll-title\").first\n          if title_element\n            poll[\"title\"] = title_element.inner_html.strip\n          end\n\n          poll\n        end\n      end\n    end\n  end\n\n  class DiscoursePoll::PollsController < ::ApplicationController\n    requires_plugin PLUGIN_NAME\n\n    before_action :ensure_logged_in, except: [:voters, :grouped_poll_results]\n\n    def vote\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n      options   = params.require(:options)\n\n      begin\n        poll, options = DiscoursePoll::Poll.vote(post_id, poll_name, options, current_user)\n        render json: { poll: poll, vote: options }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def toggle_status\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n      status    = params.require(:status)\n\n      begin\n        poll = DiscoursePoll::Poll.toggle_status(post_id, poll_name, status, current_user)\n        render json: { poll: poll }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def voters\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n\n      opts = params.permit(:limit, :page, :option_id)\n\n      begin\n        render json: { voters: DiscoursePoll::Poll.voters(post_id, poll_name, current_user, opts) }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def grouped_poll_results\n      post_id   = params.require(:post_id)\n      poll_name = params.require(:poll_name)\n      user_field_name = params.require(:user_field_name)\n\n      begin\n        render json: {\n          grouped_results: DiscoursePoll::Poll.grouped_poll_results(post_id, poll_name, user_field_name, current_user)\n        }\n      rescue StandardError => e\n        render_json_error e.message\n      end\n    end\n\n    def groupable_user_fields\n      render json: {\n        fields: SiteSetting.poll_groupable_user_fields.split('|').map do |field|\n          { name: field.humanize.capitalize, value: field }\n        end\n      }\n    end\n  end\n\n  DiscoursePoll::Engine.routes.draw do\n    put \"/vote\" => \"polls#vote\"\n    put \"/toggle_status\" => \"polls#toggle_status\"\n    get \"/voters\" => 'polls#voters'\n    get \"/grouped_poll_results\" => 'polls#grouped_poll_results'\n    get \"/groupable_user_fields\" => 'polls#groupable_user_fields'\n  end\n\n  Discourse::Application.routes.append do\n    mount ::DiscoursePoll::Engine, at: \"/polls\"\n  end\n\n  reloadable_patch do\n    Post.class_eval do\n      attr_accessor :extracted_polls\n\n      has_many :polls, dependent: :destroy\n\n      after_save do\n        polls = self.extracted_polls\n        next if polls.blank? || !polls.is_a?(Hash)\n        post = self\n\n        Poll.transaction do\n          polls.values.each do |poll|\n            DiscoursePoll::Poll.create!(post.id, poll)\n          end\n          post.custom_fields[DiscoursePoll::HAS_POLLS] = true\n          post.save_custom_fields(true)\n        end\n      end\n    end\n\n    User.class_eval do\n      has_many :poll_votes, dependent: :delete_all\n    end\n  end\n\n  validate(:post, :validate_polls) do |force = nil|\n    return unless self.raw_changed? || force\n\n    validator = DiscoursePoll::PollsValidator.new(self)\n    return unless (polls = validator.validate_polls)\n\n    if polls.present?\n      validator = DiscoursePoll::PostValidator.new(self)\n      return unless validator.validate_post\n    end\n\n    # are we updating a post?\n    if self.id.present?\n      DiscoursePoll::PollsUpdater.update(self, polls)\n    else\n      self.extracted_polls = polls\n    end\n\n    true\n  end\n\n  allow_new_queued_post_payload_attribute(\"is_poll\")\n\n  NewPostManager.add_handler(1) do |manager|\n    post = Post.new(raw: manager.args[:raw])\n\n    if !DiscoursePoll::PollsValidator.new(post).validate_polls\n      result = NewPostResult.new(:poll, false)\n\n      post.errors.full_messages.each do |message|\n        result.errors[:base] << message\n      end\n\n      result\n    else\n      manager.args[\"is_poll\"] = true\n      nil\n    end\n  end\n\n  on(:approved_post) do |queued_post, created_post|\n    if queued_post.payload[\"is_poll\"]\n      created_post.validate_polls(true)\n    end\n  end\n\n  on(:reduce_cooked) do |fragment, post|\n    if post.nil? || post.trashed?\n      fragment.css(\".poll, [data-poll-name]\").each(&:remove)\n    else\n      post_url = post.full_url\n      fragment.css(\".poll, [data-poll-name]\").each do |poll|\n        poll.replace \"<p><a href='#{post_url}'>#{I18n.t(\"poll.email.link_to_poll\")}</a></p>\"\n      end\n    end\n  end\n\n  on(:reduce_excerpt) do |doc, options|\n    post = options[:post]\n\n    replacement = post&.url.present? ?\n      \"<a href='#{UrlHelper.escape_uri(post.url)}'>#{I18n.t(\"poll.poll\")}</a>\" :\n      I18n.t(\"poll.poll\")\n\n    doc.css(\"div.poll\").each do |poll|\n      poll.replace(replacement)\n    end\n  end\n\n  on(:post_created) do |post, _opts, user|\n    guardian = Guardian.new(user)\n    DiscoursePoll::Poll.schedule_jobs(post)\n\n    unless post.is_first_post?\n      polls = ActiveModel::ArraySerializer.new(post.polls, each_serializer: PollSerializer, root: false, scope: guardian).as_json\n      post.publish_message!(\"/polls/#{post.topic_id}\", post_id: post.id, polls: polls)\n    end\n  end\n\n  on(:merging_users) do |source_user, target_user|\n    PollVote.where(user_id: source_user.id).update_all(user_id: target_user.id)\n  end\n\n  register_post_custom_field_type(DiscoursePoll::HAS_POLLS, :boolean)\n\n  topic_view_post_custom_fields_allowlister { [DiscoursePoll::HAS_POLLS] }\n\n  add_to_class(:topic_view, :polls) do\n    @polls ||= begin\n      polls = {}\n\n      post_with_polls = @post_custom_fields.each_with_object([]) do |fields, obj|\n        obj << fields[0] if fields[1][DiscoursePoll::HAS_POLLS]\n      end\n\n      if post_with_polls.present?\n        Poll\n          .where(post_id: post_with_polls)\n          .each do |p|\n            polls[p.post_id] ||= []\n            polls[p.post_id] << p\n          end\n      end\n\n      polls\n    end\n  end\n\n  add_to_serializer(:post, :preloaded_polls, false) do\n    @preloaded_polls ||= if @topic_view.present?\n      @topic_view.polls[object.id]\n    else\n      Poll.includes(:poll_options).where(post: object)\n    end\n  end\n\n  add_to_serializer(:post, :include_preloaded_polls?) do\n    false\n  end\n\n  add_to_serializer(:post, :polls, false) do\n    preloaded_polls.map { |p| PollSerializer.new(p, root: false, scope: self.scope) }\n  end\n\n  add_to_serializer(:post, :include_polls?) do\n    SiteSetting.poll_enabled && preloaded_polls.present?\n  end\n\n  add_to_serializer(:post, :polls_votes, false) do\n    preloaded_polls.map do |poll|\n      user_poll_votes =\n        poll\n          .poll_votes\n          .where(user_id: scope.user.id)\n          .joins(:poll_option)\n          .pluck(\"poll_options.digest\")\n\n      [poll.name, user_poll_votes]\n    end.to_h\n  end\n\n  add_to_serializer(:post, :include_polls_votes?) do\n    SiteSetting.poll_enabled &&\n    scope.user&.id.present? &&\n    preloaded_polls.present? &&\n    preloaded_polls.any? { |p| p.has_voted?(scope.user) }\n  end\nend\n"], "filenames": ["plugins/poll/config/locales/server.en.yml", "plugins/poll/plugin.rb"], "buggy_code_start_loc": [50, 87], "buggy_code_end_loc": [50, 118], "fixing_code_start_loc": [51, 88], "fixing_code_end_loc": [59, 140], "type": "NVD-CWE-Other", "message": "Discourse is an open source discussion platform. In affected versions a vulnerability in the Polls feature allowed users to vote multiple times in a single-option poll. The problem is patched in the latest tests-passed, beta and stable versions of Discourse", "other": {"cve": {"id": "CVE-2021-43793", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-01T20:15:08.587", "lastModified": "2022-08-09T14:43:27.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. In affected versions a vulnerability in the Polls feature allowed users to vote multiple times in a single-option poll. The problem is patched in the latest tests-passed, beta and stable versions of Discourse"}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. En las versiones afectadas, una vulnerabilidad en la funcionalidad Polls permit\u00eda a usuarios votar varias veces en una encuesta de una sola opci\u00f3n. El problema se ha parcheado en las \u00faltimas versiones de Discourse, tanto en fase beta como en versi\u00f3n estable"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.11", "matchCriteriaId": "3F845CD5-5BBB-4686-B459-F20DEC41748C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "76EABAB9-BEA4-48D4-ADBA-D00746B29C52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "82A255A2-4658-41AD-A4DE-A7F8D018028D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "E5804585-2EA4-4677-8EC1-5F561D5C7D7A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/0c6b9df77bac9c6f7c7e2eadf6fe100064afdeab", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/commit/1d0faedfbc3a8b77b971dc70d25e30791dbb6e0b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-jq7h-44vc-h6qx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/0c6b9df77bac9c6f7c7e2eadf6fe100064afdeab"}}