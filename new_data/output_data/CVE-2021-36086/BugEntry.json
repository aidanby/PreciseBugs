{"buggy_code": ["\n#include \"cil_internal.h\"\n#include \"cil_log.h\"\n#include \"cil_list.h\"\n#include \"cil_reset_ast.h\"\n#include \"cil_symtab.h\"\n\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list);\nstatic inline void cil_reset_level(struct cil_level *level);\nstatic inline void cil_reset_levelrange(struct cil_levelrange *levelrange);\nstatic inline void cil_reset_context(struct cil_context *context);\n\n\nstatic int __class_reset_perm_values(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_perm *perm = (struct cil_perm *)d;\n\n\tperm->value -= *((int *)args);\n\n\treturn SEPOL_OK;\n}\n\nstatic void cil_reset_class(struct cil_class *class)\n{\n\tif (class->common != NULL) {\n\t\t/* Must assume that the common has been destroyed */\n\t\tint num_common_perms = class->num_perms - class->perms.nprim;\n\t\tcil_symtab_map(&class->perms, __class_reset_perm_values, &num_common_perms);\n\t\t/* during a re-resolve, we need to reset the common, so a classcommon\n\t\t * statement isn't seen as a duplicate */\n\t\tclass->num_perms = class->perms.nprim;\n\t\tclass->common = NULL; /* Must make this NULL or there will be an error when re-resolving */\n\t}\n\tclass->ordered = CIL_FALSE;\n}\n\nstatic void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_list_destroy(&perm->classperms, CIL_FALSE);\n}\n\nstatic inline void cil_reset_classperms(struct cil_classperms *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->perms, CIL_FALSE);\n}\n\nstatic void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n}\n\nstatic void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}\n\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) { /* KERNEL or MAP */\n\t\t\tcil_reset_classperms(curr->data);\n\t\t} else if (curr->flavor == CIL_CLASSPERMS_SET) { /* SET */\n\t\t\tcil_reset_classperms_set(curr->data);\n\t\t}\n\t}\n}\n\nstatic void cil_reset_classpermissionset(struct cil_classpermissionset *cps)\n{\n\tcil_reset_classperms_list(cps->classperms);\n}\n\nstatic void cil_reset_classmapping(struct cil_classmapping *cm)\n{\n\tcil_reset_classperms_list(cm->classperms);\n}\n\nstatic void cil_reset_alias(struct cil_alias *alias)\n{\n\t/* reset actual to NULL during a re-resolve */\n\talias->actual = NULL;\n}\n\nstatic void cil_reset_user(struct cil_user *user)\n{\n\t/* reset the bounds to NULL during a re-resolve */\n\tuser->bounds = NULL;\n\tuser->dftlevel = NULL;\n\tuser->range = NULL;\n}\n\nstatic void cil_reset_userattr(struct cil_userattribute *attr)\n{\n\tstruct cil_list_item *expr = NULL;\n\tstruct cil_list_item *next = NULL;\n\n\t/* during a re-resolve, we need to reset the lists of expression stacks associated with this attribute from a userattribute statement */\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\texpr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tnext = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n}\n\nstatic void cil_reset_userattributeset(struct cil_userattributeset *uas)\n{\n\tcil_list_destroy(&uas->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_selinuxuser(struct cil_selinuxuser *selinuxuser)\n{\n\tif (selinuxuser->range_str == NULL) {\n\t\tcil_reset_levelrange(selinuxuser->range);\n\t}\n}\n\nstatic void cil_reset_role(struct cil_role *role)\n{\n\t/* reset the bounds to NULL during a re-resolve */\n\trole->bounds = NULL;\n}\n\nstatic void cil_reset_roleattr(struct cil_roleattribute *attr)\n{\n\t/* during a re-resolve, we need to reset the lists of expression stacks  associated with this attribute from a attributeroles statement */\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n}\n\nstatic void cil_reset_roleattributeset(struct cil_roleattributeset *ras)\n{\n\tcil_list_destroy(&ras->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_type(struct cil_type *type)\n{\n\t/* reset the bounds to NULL during a re-resolve */\n\ttype->bounds = NULL;\n}\n\nstatic void cil_reset_typeattr(struct cil_typeattribute *attr)\n{\n\t/* during a re-resolve, we need to reset the lists of expression stacks  associated with this attribute from a attributetypes statement */\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\tattr->used = CIL_FALSE;\n\tattr->keep = CIL_FALSE;\n}\n\nstatic void cil_reset_typeattributeset(struct cil_typeattributeset *tas)\n{\n\tcil_list_destroy(&tas->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_avrule(struct cil_avrule *rule)\n{\n\tcil_reset_classperms_list(rule->perms.classperms);\n}\n\nstatic void cil_reset_rangetransition(struct cil_rangetransition *rangetrans)\n{\n\tif (rangetrans->range_str == NULL) {\n\t\tcil_reset_levelrange(rangetrans->range);\n\t}\n}\n\nstatic void cil_reset_sens(struct cil_sens *sens)\n{\n\t/* during a re-resolve, we need to reset the categories associated with\n\t * this sensitivity from a (sensitivitycategory) statement */\n\tcil_list_destroy(&sens->cats_list, CIL_FALSE);\n\tsens->ordered = CIL_FALSE;\n}\n\nstatic void cil_reset_cat(struct cil_cat *cat)\n{\n\tcat->ordered = CIL_FALSE;\n}\n\nstatic inline void cil_reset_cats(struct cil_cats *cats)\n{\n\tif (cats != NULL) {\n\t\tcats->evaluated = CIL_FALSE;\n\t\tcil_list_destroy(&cats->datum_expr, CIL_FALSE);\n\t}\n}\n\n\nstatic void cil_reset_senscat(struct cil_senscat *senscat)\n{\n\tcil_reset_cats(senscat->cats);\n}\n\nstatic void cil_reset_catset(struct cil_catset *catset)\n{\n\tcil_reset_cats(catset->cats);\n}\n\nstatic inline void cil_reset_level(struct cil_level *level)\n{\n\tcil_reset_cats(level->cats);\n}\n\nstatic inline void cil_reset_levelrange(struct cil_levelrange *levelrange)\n{\n\tif (levelrange->low_str == NULL) {\n\t\tcil_reset_level(levelrange->low);\n\t}\n\n\tif (levelrange->high_str == NULL) {\n\t\tcil_reset_level(levelrange->high);\n\t}\n}\n\nstatic inline void cil_reset_userlevel(struct cil_userlevel *userlevel)\n{\n\tif (userlevel->level_str == NULL) {\n\t\tcil_reset_level(userlevel->level);\n\t}\n}\n\nstatic inline void cil_reset_userrange(struct cil_userrange *userrange)\n{\n\tif (userrange->range_str == NULL) {\n\t\tcil_reset_levelrange(userrange->range);\n\t}\n}\n\nstatic inline void cil_reset_context(struct cil_context *context)\n{\n\tif (context->range_str == NULL) {\n\t\tcil_reset_levelrange(context->range);\n\t}\n}\n\nstatic void cil_reset_sidcontext(struct cil_sidcontext *sidcontext)\n{\n\tif (sidcontext->context_str == NULL) {\n\t\tcil_reset_context(sidcontext->context);\n\t}\n}\n\nstatic void cil_reset_filecon(struct cil_filecon *filecon)\n{\n\tif (filecon->context_str == NULL && filecon->context != NULL) {\n\t\tcil_reset_context(filecon->context);\n\t}\n}\n\nstatic void cil_reset_ibpkeycon(struct cil_ibpkeycon *ibpkeycon)\n{\n\tif (!ibpkeycon->context_str)\n\t\tcil_reset_context(ibpkeycon->context);\n}\n\nstatic void cil_reset_portcon(struct cil_portcon *portcon)\n{\n\tif (portcon->context_str == NULL) {\n\t\tcil_reset_context(portcon->context);\n\t}\n}\n\nstatic void cil_reset_nodecon(struct cil_nodecon *nodecon)\n{\n\tif (nodecon->context_str == NULL) {\n\t\tcil_reset_context(nodecon->context);\n\t}\n}\n\nstatic void cil_reset_genfscon(struct cil_genfscon *genfscon)\n{\n\tif (genfscon->context_str == NULL) {\n\t\tcil_reset_context(genfscon->context);\n\t}\n}\n\nstatic void cil_reset_netifcon(struct cil_netifcon *netifcon)\n{\n\tif (netifcon->if_context_str == NULL) {\n\t\tcil_reset_context(netifcon->if_context);\n\t}\n\n\tif (netifcon->packet_context_str == NULL) {\n\t\tcil_reset_context(netifcon->packet_context);\n\t}\n}\n\nstatic void cil_reset_ibendportcon(struct cil_ibendportcon *ibendportcon)\n{\n\tif (!ibendportcon->context_str) {\n\t\tcil_reset_context(ibendportcon->context);\n\t}\n}\n\nstatic void cil_reset_pirqcon(struct cil_pirqcon *pirqcon)\n{\n\tif (pirqcon->context_str == NULL) {\n\t\tcil_reset_context(pirqcon->context);\n\t}\n}\n\nstatic void cil_reset_iomemcon(struct cil_iomemcon *iomemcon)\n{\n\tif (iomemcon->context_str == NULL) {\n\t\tcil_reset_context(iomemcon->context);\n\t}\n}\n\nstatic void cil_reset_ioportcon(struct cil_ioportcon *ioportcon)\n{\n\tif (ioportcon->context_str == NULL) {\n\t\tcil_reset_context(ioportcon->context);\n\t}\n}\n\nstatic void cil_reset_pcidevicecon(struct cil_pcidevicecon *pcidevicecon)\n{\n\tif (pcidevicecon->context_str == NULL) {\n\t\tcil_reset_context(pcidevicecon->context);\n\t}\n}\n\nstatic void cil_reset_devicetreecon(struct cil_devicetreecon *devicetreecon)\n{\n\tif (devicetreecon->context_str == NULL) {\n\t\tcil_reset_context(devicetreecon->context);\n\t}\n}\n\nstatic void cil_reset_fsuse(struct cil_fsuse *fsuse)\n{\n\tif (fsuse->context_str == NULL) {\n\t\tcil_reset_context(fsuse->context);\n\t}\n}\n\nstatic void cil_reset_sid(struct cil_sid *sid)\n{\n\t/* reset the context to NULL during a re-resolve */\n\tsid->context = NULL;\n\tsid->ordered = CIL_FALSE;\n}\n\nstatic void cil_reset_constrain(struct cil_constrain *con)\n{\n\tcil_reset_classperms_list(con->classperms);\n\tcil_list_destroy(&con->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_validatetrans(struct cil_validatetrans *vt)\n{\n\tcil_list_destroy(&vt->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_default(struct cil_default *def)\n{\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n}\n\nstatic void cil_reset_defaultrange(struct cil_defaultrange *def)\n{\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n}\n\nstatic void cil_reset_booleanif(struct cil_booleanif *bif)\n{\n\tcil_list_destroy(&bif->datum_expr, CIL_FALSE);\n}\n\nint __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tswitch (node->flavor) {\n\tcase CIL_CLASS:\n\t\tcil_reset_class(node->data);\n\t\tbreak;\n\tcase CIL_PERM:\n\tcase CIL_MAP_PERM:\n\t\tcil_reset_perm(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\tcil_reset_classpermission(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSIONSET:\n\t\tcil_reset_classpermissionset(node->data);\n\t\tbreak;\n\tcase CIL_CLASSMAPPING:\n\t\tcil_reset_classmapping(node->data);\n\t\tbreak;\n\tcase CIL_TYPEALIAS:\n\tcase CIL_SENSALIAS:\n\tcase CIL_CATALIAS:\n\t\tcil_reset_alias(node->data);\n\t\tbreak;\n\tcase CIL_USERRANGE:\n\t\tcil_reset_userrange(node->data);\n\t\tbreak;\n\tcase CIL_USERLEVEL:\n\t\tcil_reset_userlevel(node->data);\n\t\tbreak;\n\tcase CIL_USER:\n\t\tcil_reset_user(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTE:\n\t\tcil_reset_userattr(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTESET:\n\t\tcil_reset_userattributeset(node->data);\n\t\tbreak;\n\tcase CIL_SELINUXUSERDEFAULT:\n\tcase CIL_SELINUXUSER:\n\t\tcil_reset_selinuxuser(node->data);\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tcil_reset_role(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTE:\n\t\tcil_reset_roleattr(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTESET:\n\t\tcil_reset_roleattributeset(node->data);\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tcil_reset_type(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTE:\n\t\tcil_reset_typeattr(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTESET:\n\t\tcil_reset_typeattributeset(node->data);\n\t\tbreak;\n\tcase CIL_RANGETRANSITION:\n\t\tcil_reset_rangetransition(node->data);\n\t\tbreak;\n\tcase CIL_AVRULE:\n\t\tcil_reset_avrule(node->data);\n\t\tbreak;\n\tcase CIL_SENS:\n\t\tcil_reset_sens(node->data);\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tcil_reset_cat(node->data);\n\t\tbreak;\n\tcase CIL_SENSCAT:\n\t\tcil_reset_senscat(node->data);\n\t\tbreak;\n\tcase CIL_CATSET:\n\t\tcil_reset_catset(node->data);\n\t\tbreak;\n\tcase CIL_LEVEL:\n\t\tcil_reset_level(node->data);\n\t\tbreak;\n\tcase CIL_LEVELRANGE:\n\t\tcil_reset_levelrange(node->data);\n\t\tbreak;\n\tcase CIL_CONTEXT:\n\t\tcil_reset_context(node->data);\n\t\tbreak;\n\tcase CIL_SIDCONTEXT:\n\t\tcil_reset_sidcontext(node->data);\n\t\tbreak;\n\tcase CIL_FILECON:\n\t\tcil_reset_filecon(node->data);\n\t\tbreak;\n\tcase CIL_IBPKEYCON:\n\t\tcil_reset_ibpkeycon(node->data);\n\t\tbreak;\n\tcase CIL_IBENDPORTCON:\n\t\tcil_reset_ibendportcon(node->data);\n\t\tbreak;\n\tcase CIL_PORTCON:\n\t\tcil_reset_portcon(node->data);\n\t\tbreak;\n\tcase CIL_NODECON:\n\t\tcil_reset_nodecon(node->data);\n\t\tbreak;\n\tcase CIL_GENFSCON:\n\t\tcil_reset_genfscon(node->data);\n\t\tbreak;\n\tcase CIL_NETIFCON:\n\t\tcil_reset_netifcon(node->data);\n\t\tbreak;\n\tcase CIL_PIRQCON:\n\t\tcil_reset_pirqcon(node->data);\n\t\tbreak;\n\tcase CIL_IOMEMCON:\n\t\tcil_reset_iomemcon(node->data);\n\t\tbreak;\n\tcase CIL_IOPORTCON:\n\t\tcil_reset_ioportcon(node->data);\n\t\tbreak;\n\tcase CIL_PCIDEVICECON:\n\t\tcil_reset_pcidevicecon(node->data);\n\t\tbreak;\n\tcase CIL_DEVICETREECON:\n\t\tcil_reset_devicetreecon(node->data);\n\t\tbreak;\n\tcase CIL_FSUSE:\n\t\tcil_reset_fsuse(node->data);\n\t\tbreak;\n\tcase CIL_SID:\n\t\tcil_reset_sid(node->data);\n\t\tbreak;\n\tcase CIL_CONSTRAIN:\n\tcase CIL_MLSCONSTRAIN:\n\t\tcil_reset_constrain(node->data);\n\t\tbreak;\n\tcase CIL_VALIDATETRANS:\n\tcase CIL_MLSVALIDATETRANS:\n\t\tcil_reset_validatetrans(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTUSER:\n\tcase CIL_DEFAULTROLE:\n\tcase CIL_DEFAULTTYPE:\n\t\tcil_reset_default(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTRANGE:\n\t\tcil_reset_defaultrange(node->data);\n\t\tbreak;\n\tcase CIL_BOOLEANIF:\n\t\tcil_reset_booleanif(node->data);\n\t\tbreak;\n\tcase CIL_TUNABLEIF:\n\tcase CIL_CALL:\n\t\tbreak; /* Not effected by optional block disabling */\n\tcase CIL_MACRO:\n\tcase CIL_SIDORDER:\n\tcase CIL_CLASSORDER:\n\tcase CIL_CATORDER:\n\tcase CIL_SENSITIVITYORDER:\n\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\tbreak; /* Nothing to reset */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_reset_ast(struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_tree_walk(current, __cil_reset_node, NULL, NULL, NULL);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to reset AST\\n\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}\n"], "fixing_code": ["\n#include \"cil_internal.h\"\n#include \"cil_log.h\"\n#include \"cil_list.h\"\n#include \"cil_reset_ast.h\"\n#include \"cil_symtab.h\"\n\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list);\nstatic inline void cil_reset_level(struct cil_level *level);\nstatic inline void cil_reset_levelrange(struct cil_levelrange *levelrange);\nstatic inline void cil_reset_context(struct cil_context *context);\n\n\nstatic int __class_reset_perm_values(__attribute__((unused)) hashtab_key_t k, hashtab_datum_t d, void *args)\n{\n\tstruct cil_perm *perm = (struct cil_perm *)d;\n\n\tperm->value -= *((int *)args);\n\n\treturn SEPOL_OK;\n}\n\nstatic void cil_reset_class(struct cil_class *class)\n{\n\tif (class->common != NULL) {\n\t\t/* Must assume that the common has been destroyed */\n\t\tint num_common_perms = class->num_perms - class->perms.nprim;\n\t\tcil_symtab_map(&class->perms, __class_reset_perm_values, &num_common_perms);\n\t\t/* during a re-resolve, we need to reset the common, so a classcommon\n\t\t * statement isn't seen as a duplicate */\n\t\tclass->num_perms = class->perms.nprim;\n\t\tclass->common = NULL; /* Must make this NULL or there will be an error when re-resolving */\n\t}\n\tclass->ordered = CIL_FALSE;\n}\n\nstatic void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_list_destroy(&perm->classperms, CIL_FALSE);\n}\n\nstatic inline void cil_reset_classperms(struct cil_classperms *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->perms, CIL_FALSE);\n}\n\nstatic void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n}\n\nstatic void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}\n\nstatic inline void cil_reset_classperms_list(struct cil_list *cp_list)\n{\n\tstruct cil_list_item *curr;\n\n\tif (cp_list == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_for_each(curr, cp_list) {\n\t\tif (curr->flavor == CIL_CLASSPERMS) { /* KERNEL or MAP */\n\t\t\tcil_reset_classperms(curr->data);\n\t\t} else if (curr->flavor == CIL_CLASSPERMS_SET) { /* SET */\n\t\t\tcil_reset_classperms_set(curr->data);\n\t\t}\n\t}\n}\n\nstatic void cil_reset_classpermissionset(struct cil_classpermissionset *cps)\n{\n\tcil_reset_classperms_list(cps->classperms);\n}\n\nstatic void cil_reset_classmapping(struct cil_classmapping *cm)\n{\n\tcil_reset_classperms_list(cm->classperms);\n}\n\nstatic void cil_reset_alias(struct cil_alias *alias)\n{\n\t/* reset actual to NULL during a re-resolve */\n\talias->actual = NULL;\n}\n\nstatic void cil_reset_user(struct cil_user *user)\n{\n\t/* reset the bounds to NULL during a re-resolve */\n\tuser->bounds = NULL;\n\tuser->dftlevel = NULL;\n\tuser->range = NULL;\n}\n\nstatic void cil_reset_userattr(struct cil_userattribute *attr)\n{\n\tstruct cil_list_item *expr = NULL;\n\tstruct cil_list_item *next = NULL;\n\n\t/* during a re-resolve, we need to reset the lists of expression stacks associated with this attribute from a userattribute statement */\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\texpr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tnext = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n}\n\nstatic void cil_reset_userattributeset(struct cil_userattributeset *uas)\n{\n\tcil_list_destroy(&uas->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_selinuxuser(struct cil_selinuxuser *selinuxuser)\n{\n\tif (selinuxuser->range_str == NULL) {\n\t\tcil_reset_levelrange(selinuxuser->range);\n\t}\n}\n\nstatic void cil_reset_role(struct cil_role *role)\n{\n\t/* reset the bounds to NULL during a re-resolve */\n\trole->bounds = NULL;\n}\n\nstatic void cil_reset_roleattr(struct cil_roleattribute *attr)\n{\n\t/* during a re-resolve, we need to reset the lists of expression stacks  associated with this attribute from a attributeroles statement */\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n}\n\nstatic void cil_reset_roleattributeset(struct cil_roleattributeset *ras)\n{\n\tcil_list_destroy(&ras->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_type(struct cil_type *type)\n{\n\t/* reset the bounds to NULL during a re-resolve */\n\ttype->bounds = NULL;\n}\n\nstatic void cil_reset_typeattr(struct cil_typeattribute *attr)\n{\n\t/* during a re-resolve, we need to reset the lists of expression stacks  associated with this attribute from a attributetypes statement */\n\tif (attr->expr_list != NULL) {\n\t\t/* we don't want to destroy the expression stacks (cil_list) inside\n\t\t * this list cil_list_destroy destroys sublists, so we need to do it\n\t\t * manually */\n\t\tstruct cil_list_item *expr = attr->expr_list->head;\n\t\twhile (expr != NULL) {\n\t\t\tstruct cil_list_item *next = expr->next;\n\t\t\tcil_list_item_destroy(&expr, CIL_FALSE);\n\t\t\texpr = next;\n\t\t}\n\t\tfree(attr->expr_list);\n\t\tattr->expr_list = NULL;\n\t}\n\tattr->used = CIL_FALSE;\n\tattr->keep = CIL_FALSE;\n}\n\nstatic void cil_reset_typeattributeset(struct cil_typeattributeset *tas)\n{\n\tcil_list_destroy(&tas->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_avrule(struct cil_avrule *rule)\n{\n\tcil_reset_classperms_list(rule->perms.classperms);\n}\n\nstatic void cil_reset_rangetransition(struct cil_rangetransition *rangetrans)\n{\n\tif (rangetrans->range_str == NULL) {\n\t\tcil_reset_levelrange(rangetrans->range);\n\t}\n}\n\nstatic void cil_reset_sens(struct cil_sens *sens)\n{\n\t/* during a re-resolve, we need to reset the categories associated with\n\t * this sensitivity from a (sensitivitycategory) statement */\n\tcil_list_destroy(&sens->cats_list, CIL_FALSE);\n\tsens->ordered = CIL_FALSE;\n}\n\nstatic void cil_reset_cat(struct cil_cat *cat)\n{\n\tcat->ordered = CIL_FALSE;\n}\n\nstatic inline void cil_reset_cats(struct cil_cats *cats)\n{\n\tif (cats != NULL) {\n\t\tcats->evaluated = CIL_FALSE;\n\t\tcil_list_destroy(&cats->datum_expr, CIL_FALSE);\n\t}\n}\n\n\nstatic void cil_reset_senscat(struct cil_senscat *senscat)\n{\n\tcil_reset_cats(senscat->cats);\n}\n\nstatic void cil_reset_catset(struct cil_catset *catset)\n{\n\tcil_reset_cats(catset->cats);\n}\n\nstatic inline void cil_reset_level(struct cil_level *level)\n{\n\tcil_reset_cats(level->cats);\n}\n\nstatic inline void cil_reset_levelrange(struct cil_levelrange *levelrange)\n{\n\tif (levelrange->low_str == NULL) {\n\t\tcil_reset_level(levelrange->low);\n\t}\n\n\tif (levelrange->high_str == NULL) {\n\t\tcil_reset_level(levelrange->high);\n\t}\n}\n\nstatic inline void cil_reset_userlevel(struct cil_userlevel *userlevel)\n{\n\tif (userlevel->level_str == NULL) {\n\t\tcil_reset_level(userlevel->level);\n\t}\n}\n\nstatic inline void cil_reset_userrange(struct cil_userrange *userrange)\n{\n\tif (userrange->range_str == NULL) {\n\t\tcil_reset_levelrange(userrange->range);\n\t}\n}\n\nstatic inline void cil_reset_context(struct cil_context *context)\n{\n\tif (context->range_str == NULL) {\n\t\tcil_reset_levelrange(context->range);\n\t}\n}\n\nstatic void cil_reset_sidcontext(struct cil_sidcontext *sidcontext)\n{\n\tif (sidcontext->context_str == NULL) {\n\t\tcil_reset_context(sidcontext->context);\n\t}\n}\n\nstatic void cil_reset_filecon(struct cil_filecon *filecon)\n{\n\tif (filecon->context_str == NULL && filecon->context != NULL) {\n\t\tcil_reset_context(filecon->context);\n\t}\n}\n\nstatic void cil_reset_ibpkeycon(struct cil_ibpkeycon *ibpkeycon)\n{\n\tif (!ibpkeycon->context_str)\n\t\tcil_reset_context(ibpkeycon->context);\n}\n\nstatic void cil_reset_portcon(struct cil_portcon *portcon)\n{\n\tif (portcon->context_str == NULL) {\n\t\tcil_reset_context(portcon->context);\n\t}\n}\n\nstatic void cil_reset_nodecon(struct cil_nodecon *nodecon)\n{\n\tif (nodecon->context_str == NULL) {\n\t\tcil_reset_context(nodecon->context);\n\t}\n}\n\nstatic void cil_reset_genfscon(struct cil_genfscon *genfscon)\n{\n\tif (genfscon->context_str == NULL) {\n\t\tcil_reset_context(genfscon->context);\n\t}\n}\n\nstatic void cil_reset_netifcon(struct cil_netifcon *netifcon)\n{\n\tif (netifcon->if_context_str == NULL) {\n\t\tcil_reset_context(netifcon->if_context);\n\t}\n\n\tif (netifcon->packet_context_str == NULL) {\n\t\tcil_reset_context(netifcon->packet_context);\n\t}\n}\n\nstatic void cil_reset_ibendportcon(struct cil_ibendportcon *ibendportcon)\n{\n\tif (!ibendportcon->context_str) {\n\t\tcil_reset_context(ibendportcon->context);\n\t}\n}\n\nstatic void cil_reset_pirqcon(struct cil_pirqcon *pirqcon)\n{\n\tif (pirqcon->context_str == NULL) {\n\t\tcil_reset_context(pirqcon->context);\n\t}\n}\n\nstatic void cil_reset_iomemcon(struct cil_iomemcon *iomemcon)\n{\n\tif (iomemcon->context_str == NULL) {\n\t\tcil_reset_context(iomemcon->context);\n\t}\n}\n\nstatic void cil_reset_ioportcon(struct cil_ioportcon *ioportcon)\n{\n\tif (ioportcon->context_str == NULL) {\n\t\tcil_reset_context(ioportcon->context);\n\t}\n}\n\nstatic void cil_reset_pcidevicecon(struct cil_pcidevicecon *pcidevicecon)\n{\n\tif (pcidevicecon->context_str == NULL) {\n\t\tcil_reset_context(pcidevicecon->context);\n\t}\n}\n\nstatic void cil_reset_devicetreecon(struct cil_devicetreecon *devicetreecon)\n{\n\tif (devicetreecon->context_str == NULL) {\n\t\tcil_reset_context(devicetreecon->context);\n\t}\n}\n\nstatic void cil_reset_fsuse(struct cil_fsuse *fsuse)\n{\n\tif (fsuse->context_str == NULL) {\n\t\tcil_reset_context(fsuse->context);\n\t}\n}\n\nstatic void cil_reset_sid(struct cil_sid *sid)\n{\n\t/* reset the context to NULL during a re-resolve */\n\tsid->context = NULL;\n\tsid->ordered = CIL_FALSE;\n}\n\nstatic void cil_reset_constrain(struct cil_constrain *con)\n{\n\tcil_reset_classperms_list(con->classperms);\n\tcil_list_destroy(&con->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_validatetrans(struct cil_validatetrans *vt)\n{\n\tcil_list_destroy(&vt->datum_expr, CIL_FALSE);\n}\n\nstatic void cil_reset_default(struct cil_default *def)\n{\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n}\n\nstatic void cil_reset_defaultrange(struct cil_defaultrange *def)\n{\n\tcil_list_destroy(&def->class_datums, CIL_FALSE);\n}\n\nstatic void cil_reset_booleanif(struct cil_booleanif *bif)\n{\n\tcil_list_destroy(&bif->datum_expr, CIL_FALSE);\n}\n\nint __cil_reset_node(struct cil_tree_node *node,  __attribute__((unused)) uint32_t *finished, __attribute__((unused)) void *extra_args)\n{\n\tswitch (node->flavor) {\n\tcase CIL_CLASS:\n\t\tcil_reset_class(node->data);\n\t\tbreak;\n\tcase CIL_PERM:\n\tcase CIL_MAP_PERM:\n\t\tcil_reset_perm(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSION:\n\t\tcil_reset_classpermission(node->data);\n\t\tbreak;\n\tcase CIL_CLASSPERMISSIONSET:\n\t\tcil_reset_classpermissionset(node->data);\n\t\tbreak;\n\tcase CIL_CLASSMAPPING:\n\t\tcil_reset_classmapping(node->data);\n\t\tbreak;\n\tcase CIL_TYPEALIAS:\n\tcase CIL_SENSALIAS:\n\tcase CIL_CATALIAS:\n\t\tcil_reset_alias(node->data);\n\t\tbreak;\n\tcase CIL_USERRANGE:\n\t\tcil_reset_userrange(node->data);\n\t\tbreak;\n\tcase CIL_USERLEVEL:\n\t\tcil_reset_userlevel(node->data);\n\t\tbreak;\n\tcase CIL_USER:\n\t\tcil_reset_user(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTE:\n\t\tcil_reset_userattr(node->data);\n\t\tbreak;\n\tcase CIL_USERATTRIBUTESET:\n\t\tcil_reset_userattributeset(node->data);\n\t\tbreak;\n\tcase CIL_SELINUXUSERDEFAULT:\n\tcase CIL_SELINUXUSER:\n\t\tcil_reset_selinuxuser(node->data);\n\t\tbreak;\n\tcase CIL_ROLE:\n\t\tcil_reset_role(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTE:\n\t\tcil_reset_roleattr(node->data);\n\t\tbreak;\n\tcase CIL_ROLEATTRIBUTESET:\n\t\tcil_reset_roleattributeset(node->data);\n\t\tbreak;\n\tcase CIL_TYPE:\n\t\tcil_reset_type(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTE:\n\t\tcil_reset_typeattr(node->data);\n\t\tbreak;\n\tcase CIL_TYPEATTRIBUTESET:\n\t\tcil_reset_typeattributeset(node->data);\n\t\tbreak;\n\tcase CIL_RANGETRANSITION:\n\t\tcil_reset_rangetransition(node->data);\n\t\tbreak;\n\tcase CIL_AVRULE:\n\t\tcil_reset_avrule(node->data);\n\t\tbreak;\n\tcase CIL_SENS:\n\t\tcil_reset_sens(node->data);\n\t\tbreak;\n\tcase CIL_CAT:\n\t\tcil_reset_cat(node->data);\n\t\tbreak;\n\tcase CIL_SENSCAT:\n\t\tcil_reset_senscat(node->data);\n\t\tbreak;\n\tcase CIL_CATSET:\n\t\tcil_reset_catset(node->data);\n\t\tbreak;\n\tcase CIL_LEVEL:\n\t\tcil_reset_level(node->data);\n\t\tbreak;\n\tcase CIL_LEVELRANGE:\n\t\tcil_reset_levelrange(node->data);\n\t\tbreak;\n\tcase CIL_CONTEXT:\n\t\tcil_reset_context(node->data);\n\t\tbreak;\n\tcase CIL_SIDCONTEXT:\n\t\tcil_reset_sidcontext(node->data);\n\t\tbreak;\n\tcase CIL_FILECON:\n\t\tcil_reset_filecon(node->data);\n\t\tbreak;\n\tcase CIL_IBPKEYCON:\n\t\tcil_reset_ibpkeycon(node->data);\n\t\tbreak;\n\tcase CIL_IBENDPORTCON:\n\t\tcil_reset_ibendportcon(node->data);\n\t\tbreak;\n\tcase CIL_PORTCON:\n\t\tcil_reset_portcon(node->data);\n\t\tbreak;\n\tcase CIL_NODECON:\n\t\tcil_reset_nodecon(node->data);\n\t\tbreak;\n\tcase CIL_GENFSCON:\n\t\tcil_reset_genfscon(node->data);\n\t\tbreak;\n\tcase CIL_NETIFCON:\n\t\tcil_reset_netifcon(node->data);\n\t\tbreak;\n\tcase CIL_PIRQCON:\n\t\tcil_reset_pirqcon(node->data);\n\t\tbreak;\n\tcase CIL_IOMEMCON:\n\t\tcil_reset_iomemcon(node->data);\n\t\tbreak;\n\tcase CIL_IOPORTCON:\n\t\tcil_reset_ioportcon(node->data);\n\t\tbreak;\n\tcase CIL_PCIDEVICECON:\n\t\tcil_reset_pcidevicecon(node->data);\n\t\tbreak;\n\tcase CIL_DEVICETREECON:\n\t\tcil_reset_devicetreecon(node->data);\n\t\tbreak;\n\tcase CIL_FSUSE:\n\t\tcil_reset_fsuse(node->data);\n\t\tbreak;\n\tcase CIL_SID:\n\t\tcil_reset_sid(node->data);\n\t\tbreak;\n\tcase CIL_CONSTRAIN:\n\tcase CIL_MLSCONSTRAIN:\n\t\tcil_reset_constrain(node->data);\n\t\tbreak;\n\tcase CIL_VALIDATETRANS:\n\tcase CIL_MLSVALIDATETRANS:\n\t\tcil_reset_validatetrans(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTUSER:\n\tcase CIL_DEFAULTROLE:\n\tcase CIL_DEFAULTTYPE:\n\t\tcil_reset_default(node->data);\n\t\tbreak;\n\tcase CIL_DEFAULTRANGE:\n\t\tcil_reset_defaultrange(node->data);\n\t\tbreak;\n\tcase CIL_BOOLEANIF:\n\t\tcil_reset_booleanif(node->data);\n\t\tbreak;\n\tcase CIL_TUNABLEIF:\n\tcase CIL_CALL:\n\t\tbreak; /* Not effected by optional block disabling */\n\tcase CIL_MACRO:\n\tcase CIL_SIDORDER:\n\tcase CIL_CLASSORDER:\n\tcase CIL_CATORDER:\n\tcase CIL_SENSITIVITYORDER:\n\tcase CIL_EXPANDTYPEATTRIBUTE:\n\t\tbreak; /* Nothing to reset */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SEPOL_OK;\n}\n\nint cil_reset_ast(struct cil_tree_node *current)\n{\n\tint rc = SEPOL_ERR;\n\n\trc = cil_tree_walk(current, __cil_reset_node, NULL, NULL, NULL);\n\tif (rc != SEPOL_OK) {\n\t\tcil_log(CIL_ERR, \"Failed to reset AST\\n\");\n\t\treturn SEPOL_ERR;\n\t}\n\n\treturn SEPOL_OK;\n}\n"], "filenames": ["libsepol/cil/src/cil_reset_ast.c"], "buggy_code_start_loc": [62], "buggy_code_end_loc": [63], "fixing_code_start_loc": [62], "fixing_code_end_loc": [67], "type": "CWE-416", "message": "The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).", "other": {"cve": {"id": "CVE-2021-36086", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:08.783", "lastModified": "2021-11-17T03:27:33.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list)."}, {"lang": "es", "value": "El compilador CIL en SELinux versi\u00f3n 3.2, presenta un uso de la memoria previamente liberada en la funci\u00f3n cil_reset_classpermission (llamado desde cil_reset_classperms_set y cil_reset_classperms_list)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:selinux_project:selinux:-:*:*:*:*:*:*:*", "matchCriteriaId": "7706AF90-BCE3-4A25-B321-635A89192992"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=32177", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/SELinuxProject/selinux/commit/c49a8ea09501ad66e799ea41b8154b6770fec2c8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/selinux/OSV-2021-536.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U7ZYR3PIJ75N6U2IONJWCKZ5L2NKJTGR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SELinuxProject/selinux/commit/c49a8ea09501ad66e799ea41b8154b6770fec2c8"}}