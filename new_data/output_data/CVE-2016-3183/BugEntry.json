{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <assert.h>\n\n#include \"opj_apps_config.h\"\n#include \"openjpeg.h\"\n#include \"color.h\"\n\n#ifdef OPJ_HAVE_LIBLCMS2\n#include <lcms2.h>\n#endif\n#ifdef OPJ_HAVE_LIBLCMS1\n#include <lcms.h>\n#endif\n\n#ifdef OPJ_USE_LEGACY\n#define OPJ_CLRSPC_GRAY CLRSPC_GRAY\n#define OPJ_CLRSPC_SRGB CLRSPC_SRGB\n#endif\n\n/*--------------------------------------------------------\nMatrix for sYCC, Amendment 1 to IEC 61966-2-1\n\nY :   0.299   0.587    0.114   :R\nCb:  -0.1687 -0.3312   0.5     :G\nCr:   0.5    -0.4187  -0.0812  :B\n\nInverse:\n\nR: 1        -3.68213e-05    1.40199      :Y\nG: 1.00003  -0.344125      -0.714128     :Cb - 2^(prec - 1)\nB: 0.999823  1.77204       -8.04142e-06  :Cr - 2^(prec - 1)\n\n-----------------------------------------------------------*/\nstatic void sycc_to_rgb(int offset, int upb, int y, int cb, int cr,\n\tint *out_r, int *out_g, int *out_b)\n{\n\tint r, g, b;\n\n\tcb -= offset; cr -= offset;\n\tr = y + (int)(1.402 * (float)cr);\n\tif(r < 0) r = 0; else if(r > upb) r = upb; *out_r = r;\n\n\tg = y - (int)(0.344 * (float)cb + 0.714 * (float)cr);\n\tif(g < 0) g = 0; else if(g > upb) g = upb; *out_g = g;\n\n\tb = y + (int)(1.772 * (float)cb);\n\tif(b < 0) b = 0; else if(b > upb) b = upb; *out_b = b;\n}\n\nstatic void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}/* sycc444_to_rgb() */\n\nstatic void sycc422_to_rgb(opj_image_t *img)\n{\t\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max;\n\tint offset, upb;\n\tunsigned int i, j;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i=0U; i < maxh; ++i)\n\t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif (j < maxw) {\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}/* sycc422_to_rgb() */\n\nstatic void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max;\n\tint offset, upb;\n\tunsigned int i, j;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n\t{\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\n\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < maxh)\n\t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}/* sycc420_to_rgb() */\n\nvoid color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))/* horizontal and vertical sub-sample */\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))/* horizontal sub-sample only */\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))/* no sub-sample */\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_sycc_to_rgb() */\n\n#if defined(OPJ_HAVE_LIBLCMS2) || defined(OPJ_HAVE_LIBLCMS1)\n\n#ifdef OPJ_HAVE_LIBLCMS1\n/* Bob Friesenhahn proposed:*/\n#define cmsSigXYZData   icSigXYZData\n#define cmsSigLabData   icSigLabData\n#define cmsSigCmykData  icSigCmykData\n#define cmsSigYCbCrData icSigYCbCrData\n#define cmsSigLuvData   icSigLuvData\n#define cmsSigGrayData  icSigGrayData\n#define cmsSigRgbData   icSigRgbData\n#define cmsUInt32Number DWORD\n\n#define cmsColorSpaceSignature icColorSpaceSignature\n#define cmsGetHeaderRenderingIntent cmsTakeRenderingIntent\n\n#endif /* OPJ_HAVE_LIBLCMS1 */\n\n/*#define DEBUG_PROFILE*/\nvoid color_apply_icc_profile(opj_image_t *image)\n{\n\tcmsHPROFILE in_prof, out_prof;\n\tcmsHTRANSFORM transform;\n\tcmsColorSpaceSignature in_space, out_space;\n\tcmsUInt32Number intent, in_type, out_type;\n\tint *r, *g, *b;\n\tsize_t nr_samples;\n\tint prec, i, max, max_w, max_h, ok = 0;\n\tOPJ_COLOR_SPACE new_space;\n\n\tin_prof = \n\t cmsOpenProfileFromMem(image->icc_profile_buf, image->icc_profile_len);\n#ifdef DEBUG_PROFILE\n  FILE *icm = fopen(\"debug.icm\",\"wb\");\n  fwrite( image->icc_profile_buf,1, image->icc_profile_len,icm);\n  fclose(icm);\n#endif\n\n\tif(in_prof == NULL) return;\n\n\tin_space = cmsGetPCS(in_prof);\n\tout_space = cmsGetColorSpace(in_prof);\n\tintent = cmsGetHeaderRenderingIntent(in_prof);\n\n\t\n\tmax_w = (int)image->comps[0].w;\n  max_h = (int)image->comps[0].h;\n\tprec = (int)image->comps[0].prec;\n\n\tif(out_space == cmsSigRgbData) /* enumCS 16 */\n   {\n\tif( prec <= 8 )\n  {\n\tin_type = TYPE_RGB_8;\n\tout_type = TYPE_RGB_8;\n  }\n\telse\n  {\n\tin_type = TYPE_RGB_16;\n\tout_type = TYPE_RGB_16;\n  }\n\tout_prof = cmsCreate_sRGBProfile();\n\tnew_space = OPJ_CLRSPC_SRGB;\n   }\n\telse\n\tif(out_space == cmsSigGrayData) /* enumCS 17 */\n   {\n\tin_type = TYPE_GRAY_8;\n\tout_type = TYPE_RGB_8;\n\tout_prof = cmsCreate_sRGBProfile();\n\tnew_space = OPJ_CLRSPC_SRGB;\n   }\n\telse\n\tif(out_space == cmsSigYCbCrData) /* enumCS 18 */\n   {\n\tin_type = TYPE_YCbCr_16;\n\tout_type = TYPE_RGB_16;\n\tout_prof = cmsCreate_sRGBProfile();\n\tnew_space = OPJ_CLRSPC_SRGB;\n   }\n\telse\n   {\n#ifdef DEBUG_PROFILE\nfprintf(stderr,\"%s:%d: color_apply_icc_profile\\n\\tICC Profile has unknown \"\n\"output colorspace(%#x)(%c%c%c%c)\\n\\tICC Profile ignored.\\n\",\n__FILE__,__LINE__,out_space,\n\t(out_space>>24) & 0xff,(out_space>>16) & 0xff,\n\t(out_space>>8) & 0xff, out_space & 0xff);\n#endif\n\tcmsCloseProfile(in_prof);\n\n\treturn;\n   }\n\tif(out_prof == NULL)\n   {\n\tcmsCloseProfile(in_prof);\n\n\treturn;\n   }\n\n#ifdef DEBUG_PROFILE\nfprintf(stderr,\"%s:%d:color_apply_icc_profile\\n\\tchannels(%d) prec(%d) w(%d) h(%d)\"\n\"\\n\\tprofile: in(%p) out(%p)\\n\",__FILE__,__LINE__,image->numcomps,prec,\n\tmax_w,max_h, (void*)in_prof,(void*)out_prof);\n\nfprintf(stderr,\"\\trender_intent (%u)\\n\\t\"\n\"color_space: in(%#x)(%c%c%c%c)   out:(%#x)(%c%c%c%c)\\n\\t\"\n\"       type: in(%u)              out:(%u)\\n\",\n\tintent,\n\tin_space,\n\t(in_space>>24) & 0xff,(in_space>>16) & 0xff,\n\t(in_space>>8) & 0xff, in_space & 0xff,\n\n\tout_space,\n\t(out_space>>24) & 0xff,(out_space>>16) & 0xff,\n\t(out_space>>8) & 0xff, out_space & 0xff,\n\n\tin_type,out_type\n );\n#else\n  (void)prec;\n  (void)in_space;\n#endif /* DEBUG_PROFILE */\n\n\ttransform = cmsCreateTransform(in_prof, in_type,\n\t out_prof, out_type, intent, 0);\n\n#ifdef OPJ_HAVE_LIBLCMS2\n/* Possible for: LCMS_VERSION >= 2000 :*/\n\tcmsCloseProfile(in_prof);\n\tcmsCloseProfile(out_prof);\n#endif\n\n\tif(transform == NULL)\n   {\n#ifdef DEBUG_PROFILE\nfprintf(stderr,\"%s:%d:color_apply_icc_profile\\n\\tcmsCreateTransform failed. \"\n\"ICC Profile ignored.\\n\",__FILE__,__LINE__);\n#endif\n\n#ifdef OPJ_HAVE_LIBLCMS1\n\tcmsCloseProfile(in_prof);\n\tcmsCloseProfile(out_prof);\n#endif\n\treturn;\n   }\n\n\tif(image->numcomps > 2)/* RGB, RGBA */\n   {\n\tif( prec <= 8 )\n  {\n\tunsigned char *inbuf, *outbuf, *in, *out;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned char));\n\tin = inbuf = (unsigned char*)malloc(nr_samples);\n\tout = outbuf = (unsigned char*)malloc(nr_samples);\n\n\tif(inbuf == NULL || outbuf == NULL) goto fails0;\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned char)*r++;\n\t*in++ = (unsigned char)*g++;\n\t*in++ = (unsigned char)*b++;\n }\n\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++;\n\t*g++ = (int)*out++;\n\t*b++ = (int)*out++;\n }\n\tok = 1;\n\nfails0:\n\tif(inbuf) free(inbuf);\n\tif(outbuf) free(outbuf);\n  }\n\telse /* prec > 8 */\n  {\n\tunsigned short *inbuf, *outbuf, *in, *out;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned short));\n\tin = inbuf = (unsigned short*)malloc(nr_samples);\n\tout = outbuf = (unsigned short*)malloc(nr_samples);\n\n\tif(inbuf == NULL || outbuf == NULL) goto fails1;\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned short)*r++;\n\t*in++ = (unsigned short)*g++;\n\t*in++ = (unsigned short)*b++;\n }\n\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++;\n\t*g++ = (int)*out++;\n\t*b++ = (int)*out++;\n }\n\tok = 1;\n\nfails1:\n\tif(inbuf) free(inbuf); \n\tif(outbuf) free(outbuf);\n  }\n   }\n\telse /* image->numcomps <= 2 : GRAY, GRAYA */\n   {\n\tif(prec <= 8)\n  {\n\tunsigned char *in, *inbuf, *out, *outbuf;\n\topj_image_comp_t *new_comps;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned char));\n\tin = inbuf = (unsigned char*)malloc(nr_samples);\n\tout = outbuf = (unsigned char*)malloc(nr_samples);\n\tg = (int*)calloc((size_t)max, sizeof(int));\n\tb = (int*)calloc((size_t)max, sizeof(int));\n\n\tif(inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) goto fails2;\n\n\tnew_comps = (opj_image_comp_t*)\n\t realloc(image->comps, (image->numcomps+2)*sizeof(opj_image_comp_t));\n\n\tif(new_comps == NULL) goto fails2;\n\n\timage->comps = new_comps;\n\n\tif(image->numcomps == 2)\n\t image->comps[3] = image->comps[1];\n\n\timage->comps[1] = image->comps[0];\n\timage->comps[2] = image->comps[0];\n\n\timage->comps[1].data = g;\n\timage->comps[2].data = b;\n\n\timage->numcomps += 2;\n\n\tr = image->comps[0].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned char)*r++;\n }\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++; *g++ = (int)*out++; *b++ = (int)*out++;\n }\n\tr = g = b = NULL;\n\tok = 1;\n\nfails2:\n\tif(inbuf) free(inbuf);\n\tif(outbuf) free(outbuf);\n\tif(g) free(g);\n\tif(b) free(b);\n  }\n\telse /* prec > 8 */\n  {\n\tunsigned short *in, *inbuf, *out, *outbuf;\n\topj_image_comp_t *new_comps;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned short));\n\tin = inbuf = (unsigned short*)malloc(nr_samples);\n\tout = outbuf = (unsigned short*)malloc(nr_samples);\n\tg = (int*)calloc((size_t)max, sizeof(int));\n\tb = (int*)calloc((size_t)max, sizeof(int));\n\n\tif(inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) goto fails3;\n\n\tnew_comps = (opj_image_comp_t*)\n\t realloc(image->comps, (image->numcomps+2)*sizeof(opj_image_comp_t));\n\n\tif(new_comps == NULL) goto fails3;\n\n\timage->comps = new_comps;\n\n\tif(image->numcomps == 2)\n\t image->comps[3] = image->comps[1];\n\n\timage->comps[1] = image->comps[0];\n\timage->comps[2] = image->comps[0];\n\n\timage->comps[1].data = g;\n\timage->comps[2].data = b;\n\n\timage->numcomps += 2;\n\n\tr = image->comps[0].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned short)*r++;\n }\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++; *g++ = (int)*out++; *b++ = (int)*out++;\n }\n\tr = g = b = NULL;\n\tok = 1;\n\nfails3:\n\tif(inbuf) free(inbuf);\n\tif(outbuf) free(outbuf);\n\tif(g) free(g);\n\tif(b) free(b);\n  }\n   }/* if(image->numcomps > 2) */\n\n\tcmsDeleteTransform(transform);\n\n#ifdef OPJ_HAVE_LIBLCMS1\n\tcmsCloseProfile(in_prof);\n\tcmsCloseProfile(out_prof);\n#endif\n\tif(ok)\n   {\n\timage->color_space = new_space;\n   }\n}/* color_apply_icc_profile() */\n\nvoid color_cielab_to_rgb(opj_image_t *image)\n{\n\tint *row;\n\tint enumcs, numcomps;\n\tOPJ_COLOR_SPACE new_space;\n\n\tnumcomps = (int)image->numcomps;\n\t\n\tif(numcomps != 3)\n\t{\n\t\tfprintf(stderr,\"%s:%d:\\n\\tnumcomps %d not handled. Quitting.\\n\",\n\t\t\t\t\t\t__FILE__,__LINE__,numcomps);\n\t\treturn;\n\t}\n\t\n\trow = (int*)image->icc_profile_buf;\n\tenumcs = row[0];\n\t\n\tif(enumcs == 14) /* CIELab */\n\t{\n\t\tint *L, *a, *b, *red, *green, *blue;\n\t\tint *src0, *src1, *src2, *dst0, *dst1, *dst2;\n\t\tdouble rl, ol, ra, oa, rb, ob, prec0, prec1, prec2;\n\t\tdouble minL, maxL, mina, maxa, minb, maxb;\n\t\tunsigned int default_type;\n\t\tunsigned int i, max;\n\t\tcmsHPROFILE in, out;\n\t\tcmsHTRANSFORM transform;\n\t\tcmsUInt16Number RGB[3];\n\t\tcmsCIELab Lab;\n\t\t\n\t\tin = cmsCreateLab4Profile(NULL);\n\t\tif(in == NULL){\n\t\t\treturn;\n\t\t}\n\t\tout = cmsCreate_sRGBProfile();\n\t\tif(out == NULL){\n\t\t\tcmsCloseProfile(in);\n\t\t\treturn;\n\t\t}\n\t\ttransform = cmsCreateTransform(in, TYPE_Lab_DBL, out, TYPE_RGB_16, INTENT_PERCEPTUAL, 0);\n\t\t\n#ifdef OPJ_HAVE_LIBLCMS2\n\t\tcmsCloseProfile(in);\n\t\tcmsCloseProfile(out);\n#endif\n\t\tif(transform == NULL)\n\t\t{\n#ifdef OPJ_HAVE_LIBLCMS1\n\t\t\tcmsCloseProfile(in);\n\t\t\tcmsCloseProfile(out);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tnew_space = OPJ_CLRSPC_SRGB;\n\n\t\tprec0 = (double)image->comps[0].prec;\n\t\tprec1 = (double)image->comps[1].prec;\n\t\tprec2 = (double)image->comps[2].prec;\n\t\t\n\t\tdefault_type = (unsigned int)row[1];\n\t\t\n\t\tif(default_type == 0x44454600)/* DEF : default */\n\t\t{\n\t\t\trl = 100; ra = 170; rb = 200;\n\t\t\tol = 0;\n\t\t\toa = pow(2, prec1 - 1);\n\t\t\tob = pow(2, prec2 - 2) +  pow(2, prec2 - 3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trl = row[2]; ra = row[4]; rb = row[6];\n\t\t\tol = row[3]; oa = row[5]; ob = row[7];\n\t\t}\n\t\t\n\t\tL = src0 = image->comps[0].data;\n\t\ta = src1 = image->comps[1].data;\n\t\tb = src2 = image->comps[2].data;\n\t\t\n\t\tmax = image->comps[0].w * image->comps[0].h;\n\t\t\n\t\tred = dst0 = (int*)malloc(max * sizeof(int));\n\t\tgreen = dst1 = (int*)malloc(max * sizeof(int));\n\t\tblue = dst2 = (int*)malloc(max * sizeof(int));\n\n\t\tif(red == NULL || green == NULL || blue == NULL) goto fails;\n\n\t\tminL = -(rl * ol)/(pow(2, prec0)-1);\n\t\tmaxL = minL + rl;\n\t\t\n\t\tmina = -(ra * oa)/(pow(2, prec1)-1);\n\t\tmaxa = mina + ra;\n\t\t\n\t\tminb = -(rb * ob)/(pow(2, prec2)-1);\n\t\tmaxb = minb + rb;\n\t\t\n\t\tfor(i = 0; i < max; ++i)\n\t\t{\n\t\t\tLab.L = minL + (double)(*L) * (maxL - minL)/(pow(2, prec0)-1); ++L;\n\t\t\tLab.a = mina + (double)(*a) * (maxa - mina)/(pow(2, prec1)-1); ++a;\n\t\t\tLab.b = minb + (double)(*b) * (maxb - minb)/(pow(2, prec2)-1); ++b;\n\t\t\n\t\t\tcmsDoTransform(transform, &Lab, RGB, 1);\n\t\t\n\t\t\t*red++ = RGB[0];\n\t\t\t*green++ = RGB[1];\n\t\t\t*blue++ = RGB[2];\n\t\t}\n\t\tcmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n\t\tcmsCloseProfile(in);\n\t\tcmsCloseProfile(out);\n#endif\n\t\tfree(src0); image->comps[0].data = dst0;\n\t\tfree(src1); image->comps[1].data = dst1;\n\t\tfree(src2); image->comps[2].data = dst2;\n\t\t\n\t\timage->color_space = new_space;\n\t\timage->comps[0].prec = 16;\n\t\timage->comps[1].prec = 16;\n\t\timage->comps[2].prec = 16;\n\t\t\n\t\treturn;\n\nfails:\n\t\tcmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n\t\tcmsCloseProfile(in);\n\t\tcmsCloseProfile(out);\n#endif\n\t\tif(red) free(red);\n\t\tif(green) free(green);\n\t\tif(blue) free(blue);\n\t\treturn;\n\t}\n\t\n\tfprintf(stderr,\"%s:%d:\\n\\tenumCS %d not handled. Ignoring.\\n\", __FILE__,__LINE__, enumcs);\n}/* color_cielab_to_rgb() */\n\n#endif /* OPJ_HAVE_LIBLCMS2 || OPJ_HAVE_LIBLCMS1 */\n\nvoid color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif(image->numcomps < 4) return;\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -> RGB : RGB results from 0 to 255 */\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */\n\n/*\n * This code has been adopted from sjpx_openjpeg.c of ghostscript\n */\nvoid color_esycc_to_rgb(opj_image_t *image)\n{\n\tint y, cb, cr, sign1, sign2, val;\n\tunsigned int w, h, max, i;\n\tint flip_value = (1 << (image->comps[0].prec-1));\n\tint max_value = (1 << image->comps[0].prec) - 1;\n\t\n\tif (\n\t\t    (image->numcomps < 3)\n\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx)\n\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy)\n\t   ) {\n\t\tfprintf(stderr,\"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n\t}\n\t\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\t\n\tsign1 = (int)image->comps[1].sgnd;\n\tsign2 = (int)image->comps[2].sgnd;\n\t\n\tmax = w * h;\n\t\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t\n\t\ty = image->comps[0].data[i]; cb = image->comps[1].data[i]; cr = image->comps[2].data[i];\n\t\t\n\t\tif( !sign1) cb -= flip_value;\n\t\tif( !sign2) cr -= flip_value;\n\t\t\n\t\tval = (int)\n\t\t((float)y - (float)0.0000368 * (float)cb\n\t\t + (float)1.40199 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[0].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n\t\t - (float)0.7141128 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[1].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n\t\t - (float)0.000008 *(float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[2].data[i] = val;\n\t}\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_esycc_to_rgb() */\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n\tOPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n\tOPJ_UINT32 bfSize;      /* Size of the file        */\n\tOPJ_UINT16 bfReserved1; /* Reserved : 0            */\n\tOPJ_UINT16 bfReserved2; /* Reserved : 0            */\n\tOPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n\tOPJ_UINT32 biSize;             /* Size of the structure in bytes */\n\tOPJ_UINT32 biWidth;            /* Width of the image in pixels */\n\tOPJ_UINT32 biHeight;           /* Heigth of the image in pixels */\n\tOPJ_UINT16 biPlanes;           /* 1 */\n\tOPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n\tOPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n\tOPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n\tOPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n\tOPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n\tOPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n\tOPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n\tOPJ_UINT32 biRedMask;          /* Red channel bit mask */\n\tOPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n\tOPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n\tOPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n\tOPJ_UINT32 biColorSpaceType;   /* Color space type */\n\tOPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n\tOPJ_UINT32 biRedGamma;         /* Red channel gamma */\n\tOPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n\tOPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n\tOPJ_UINT32 biIntent;           /* Intent */\n\tOPJ_UINT32 biIccProfileData;   /* ICC profile data */\n\tOPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n\tOPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* pDst, OPJ_INT32 dstStride,\n\tOPJ_UINT8 const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tpDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpDst += dstStride;\n\t}\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n\tOPJ_UINT8 const* const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\tOPJ_INT32* pR = pDst[0];\n\tOPJ_INT32* pG = pDst[1];\n\tOPJ_INT32* pB = pDst[2];\n\tOPJ_UINT8 const* pLUT_R = pLUT[0];\n\tOPJ_UINT8 const* pLUT_G = pLUT[1];\n\tOPJ_UINT8 const* pLUT_B = pLUT[2];\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT8 idx = pSrc[x];\n\t\t\tpR[x] = (OPJ_INT32)pLUT_R[idx];\n\t\t\tpG[x] = (OPJ_INT32)pLUT_G[idx];\n\t\t\tpB[x] = (OPJ_INT32)pLUT_B[idx];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpR += pDstStride[0];\n\t\tpG += pDstStride[1];\n\t\tpB += pDstStride[2];\n\t}\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)pSrc[3*x+2];\t/* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)pSrc[3*x+1];\t/* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)pSrc[3*x+0];\t/* B */\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)\n{\n\tOPJ_UINT32 l_shift, l_prec;\n\t\n\tl_shift = l_prec = 0U;\n\t\n\tif (mask != 0U) {\n\t\twhile ((mask & 1U) == 0U) {\n\t\t\tmask >>= 1;\n\t\t\tl_shift++;\n\t\t}\n\t\twhile (mask & 1U) {\n\t\t\tmask >>= 1;\n\t\t\tl_prec++;\n\t\t}\n\t}\n\t*shift = l_shift; *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+1]) <<  8;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+2]) << 16;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+3]) << 24;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+1]) <<  8;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n\tOPJ_UINT32 width, height;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tpSrc = pData + (height - 1U) * stride;\n\tif (image->numcomps == 1U) {\n\t\topj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);\n\t}\n\telse {\n\t\tOPJ_INT32* pDst[3];\n\t\tOPJ_INT32  pDstStride[3];\n\t\t\n\t\tpDst[0] = image->comps[0].data; pDst[1] = image->comps[1].data; pDst[2] = image->comps[2].data;\n\t\tpDstStride[0] = (OPJ_INT32)width; pDstStride[1] = (OPJ_INT32)width; pDstStride[2] = (OPJ_INT32)width;\n\t\topj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT, width, height);\n\t}\n\treturn image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n\theader->bfType  = (OPJ_UINT16)getc(IN);\n\theader->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif (header->bfType != 19778) {\n\t\tfprintf(stderr,\"Error, not a BMP file!\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t/* FILE HEADER */\n\t/* ------------- */\n\theader->bfSize  = (OPJ_UINT32)getc(IN);\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->bfReserved1  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfReserved2  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfOffBits  = (OPJ_UINT32)getc(IN);\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n\treturn OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n\tmemset(header, 0, sizeof(*header));\n\t/* INFO HEADER */\n\t/* ------------- */\n\theader->biSize  = (OPJ_UINT32)getc(IN);\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\tswitch (header->biSize) {\n\t\tcase 12U:  /* BITMAPCOREHEADER */\n\t\tcase 40U:  /* BITMAPINFOHEADER */\n\t\tcase 52U:  /* BITMAPV2INFOHEADER */\n\t\tcase 56U:  /* BITMAPV3INFOHEADER */\n\t\tcase 108U: /* BITMAPV4HEADER */\n\t\tcase 124U: /* BITMAPV5HEADER */\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr,\"Error, unknown BMP header size %d\\n\", header->biSize);\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\theader->biWidth  = (OPJ_UINT32)getc(IN);\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biHeight  = (OPJ_UINT32)getc(IN);\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biPlanes  = (OPJ_UINT16)getc(IN);\n\theader->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->biBitCount  = (OPJ_UINT16)getc(IN);\n\theader->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif(header->biSize >= 40U) {\n\t\theader->biCompression  = (OPJ_UINT32)getc(IN);\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biSizeImage  = (OPJ_UINT32)getc(IN);\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrUsed  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrImportant  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 56U) {\n\t\theader->biRedMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biAlphaMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 108U) {\n\t\theader->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\tif (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP), IN) != sizeof(header->biColorSpaceEP)) {\n\t\t\tfprintf(stderr,\"Error, can't  read BMP header\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\theader->biRedGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 124U) {\n\t\theader->biIntent  = (OPJ_UINT32)getc(IN);\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileData  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biReserved  = (OPJ_UINT32)getc(IN);\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_ARG_NOT_USED(width);\n\t\n\tif ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )\n\t{\n\t\tfprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\t\n\tx = y = 0U;\n\twhile (y < height)\n\t{\n\t\tint c = getc(IN);\n\t\t\n\t\tif (c) {\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = c1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tc = getc(IN);\n\t\t\tif (c == 0x00) { /* EOL */\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse if (c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);\n\t\t\t\tx += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);\n\t\t\t\ty += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse /* 03 .. 255 */\n\t\t\t{\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++)\n\t\t\t\t{\n\t\t\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t*pix = c1;\n\t\t\t\t}\n\t\t\t\tif ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/* while() */\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\tx = y = 0U;\n\twhile(y < height)\n\t{\n\t\tint c = getc(IN);\n\t\tif(c == EOF) break;\n\t\t\n\t\tif(c) {/* encoded mode */\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t}\n\t\t}\n\t\telse { /* absolute mode */\n\t\t\tc = getc(IN);\n\t\t\tif(c == EOF) break;\n\t\t\n\t\t\tif(c == 0x00) { /* EOL */\n\t\t\t\tx = 0;  y++;  pix = pData + y * stride;\n\t\t\t}\n\t\t\telse if(c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);  x += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);  y += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse { /* 03 .. 255 : absolute mode */\n\t\t\t\tint j;\n\t\t\t\tOPJ_UINT8 c1 = 0U;\n\t\t\t\t\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t\tif((j&1) == 0) {\n\t\t\t\t\t\t\tc1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t}\n\t\t\t\t\t*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t\t}\n\t\t\t\tif(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */\n\t\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  /* while(y < height) */\n\treturn OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\topj_image_cmptparm_t cmptparm[4];\t/* maximum of 4 components */\n\tOPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n\tOPJ_UINT8 const* pLUT[3];\n\topj_image_t * image = NULL;\n\tFILE *IN;\n\tOPJ_BITMAPFILEHEADER File_h;\n\tOPJ_BITMAPINFOHEADER Info_h;\n\tOPJ_UINT32 i, palette_len, numcmpts = 1U;\n\tOPJ_BOOL l_result = OPJ_FALSE;\n\tOPJ_UINT8* pData = NULL;\n\tOPJ_UINT32 stride;\n\t\n\tpLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;\n\t\n\tIN = fopen(filename, \"rb\");\n\tif (!IN)\n\t{\n\t\tfprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n\t\treturn NULL;\n\t}\n\n\tif (!bmp_read_file_header(IN, &File_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tif (!bmp_read_info_header(IN, &Info_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* Load palette */\n\tif (Info_h.biBitCount <= 8U)\n\t{\n\t\tmemset(&lut_R[0], 0, sizeof(lut_R));\n\t\tmemset(&lut_G[0], 0, sizeof(lut_G));\n\t\tmemset(&lut_B[0], 0, sizeof(lut_B));\n\t\t\n\t\tpalette_len = Info_h.biClrUsed;\n\t\tif((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n\t\t\tpalette_len = (1U << Info_h.biBitCount);\n\t\t}\n\t\tif (palette_len > 256U) {\n\t\t\tpalette_len = 256U;\n\t\t}\n\t\tif (palette_len > 0U) {\n\t\t\tOPJ_UINT8 has_color = 0U;\n\t\t\tfor (i = 0U; i < palette_len; i++) {\n\t\t\t\tlut_B[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_G[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_R[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\t(void)getc(IN); /* padding */\n\t\t\t\thas_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n\t\t\t}\n\t\t\tif(has_color) {\n\t\t\t\tnumcmpts = 3U;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnumcmpts = 3U;\n\t\tif ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n\t\t\tnumcmpts++;\n\t\t}\n\t}\n\t\n\tstride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */\n\tif (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n\t\tstride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n\t}\n\tpData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n\tif (pData == NULL) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t/* Place the cursor at the beginning of the image information */\n\tfseek(IN, 0, SEEK_SET);\n\tfseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\t\n\tswitch (Info_h.biCompression) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\t/* read raw data */\n\t\t\tl_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* read rle8 data */\n\t\t\tl_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* read rle4 data */\n\t\t\tl_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr, \"Unsupported BMP compression\\n\");\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t}\n\tif (!l_result) {\n\t\tfree(pData);\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* create the image */\n\tmemset(&cmptparm[0], 0, sizeof(cmptparm));\n\tfor(i = 0; i < 4U; i++)\n\t{\n\t\tcmptparm[i].prec = 8;\n\t\tcmptparm[i].bpp  = 8;\n\t\tcmptparm[i].sgnd = 0;\n\t\tcmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n\t\tcmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n\t\tcmptparm[i].w    = Info_h.biWidth;\n\t\tcmptparm[i].h    = Info_h.biHeight;\n\t}\n\n\timage = opj_image_create(numcmpts, &cmptparm[0], (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n\tif(!image) {\n\t\tfclose(IN);\n\t\tfree(pData);\n\t\treturn NULL;\n\t}\n\tif (numcmpts == 4U) {\n\t\timage->comps[3].alpha = 1;\n\t}\n\t\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\timage->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)parameters->subsampling_dx + 1U;\n\timage->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)parameters->subsampling_dy + 1U;\n\t\n\t/* Read the data */\n\tif (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n\t\tbmp24toimage(pData, stride, image);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n\t\tbmp8toimage(pData, stride, image, pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU, 0x00000000U);\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n\t\tbmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n\t\tif ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) && (Info_h.biBlueMask == 0U)) {\n\t\t\tInfo_h.biRedMask   = 0xF800U;\n\t\t\tInfo_h.biGreenMask = 0x07E0U;\n\t\t\tInfo_h.biBlueMask  = 0x001FU;\n\t\t}\n\t\tbmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse {\n\t\topj_image_destroy(image);\n\t\timage = NULL;\n\t\tfprintf(stderr, \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\", Info_h.biBitCount);\n\t}\n\tfree(pData);\n\tfclose(IN);\n\treturn image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile) {\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }\n        else\n            adjustR = 0;\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\", image->comps[1].prec);\n        }\n        else\n            adjustG = 0;\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\", image->comps[2].prec);\n        }\n        else\n            adjustB = 0;\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            g = ((g >> adjustG)+((g >> (adjustG-1))%2));\n            if(g > 255) g = 255; else if(g < 0) g = 0;\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            b = ((b >> adjustB)+((b >> (adjustB-1))%2));\n            if(b > 255) b = 255; else if(b < 0) b = 0;\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    } else {\t\t\t/* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }else\n            adjustR = 0;\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for ((pad = w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <assert.h>\n\n#include \"opj_apps_config.h\"\n#include \"openjpeg.h\"\n#include \"color.h\"\n\n#ifdef OPJ_HAVE_LIBLCMS2\n#include <lcms2.h>\n#endif\n#ifdef OPJ_HAVE_LIBLCMS1\n#include <lcms.h>\n#endif\n\n#ifdef OPJ_USE_LEGACY\n#define OPJ_CLRSPC_GRAY CLRSPC_GRAY\n#define OPJ_CLRSPC_SRGB CLRSPC_SRGB\n#endif\n\n/*--------------------------------------------------------\nMatrix for sYCC, Amendment 1 to IEC 61966-2-1\n\nY :   0.299   0.587    0.114   :R\nCb:  -0.1687 -0.3312   0.5     :G\nCr:   0.5    -0.4187  -0.0812  :B\n\nInverse:\n\nR: 1        -3.68213e-05    1.40199      :Y\nG: 1.00003  -0.344125      -0.714128     :Cb - 2^(prec - 1)\nB: 0.999823  1.77204       -8.04142e-06  :Cr - 2^(prec - 1)\n\n-----------------------------------------------------------*/\nstatic void sycc_to_rgb(int offset, int upb, int y, int cb, int cr,\n\tint *out_r, int *out_g, int *out_b)\n{\n\tint r, g, b;\n\n\tcb -= offset; cr -= offset;\n\tr = y + (int)(1.402 * (float)cr);\n\tif(r < 0) r = 0; else if(r > upb) r = upb; *out_r = r;\n\n\tg = y - (int)(0.344 * (float)cb + 0.714 * (float)cr);\n\tif(g < 0) g = 0; else if(g > upb) g = upb; *out_g = g;\n\n\tb = y + (int)(1.772 * (float)cb);\n\tif(b < 0) b = 0; else if(b > upb) b = upb; *out_b = b;\n}\n\nstatic void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tsize_t maxw, maxh, max, i;\n\tint offset, upb;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}/* sycc444_to_rgb() */\n\nstatic void sycc422_to_rgb(opj_image_t *img)\n{\t\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tsize_t maxw, maxh, max, offx, loopmaxw;\n\tint offset, upb;\n\tsize_t i;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\t/* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n\toffx = img->x0 & 1U;\n\tloopmaxw = maxw - offx;\n\t\n\tfor(i=0U; i < maxh; ++i)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tif (offx > 0U) {\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t}\n\t\t\n\t\tfor(j=0U; j < (loopmaxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif (j < loopmaxw) {\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t}\n\t\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}/* sycc422_to_rgb() */\n\nstatic void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tsize_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n\tint offset, upb;\n\tsize_t i;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\t\n\tif (r == NULL || g == NULL || b == NULL) goto fails;\n\t\n\t/* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n\toffx = img->x0 & 1U;\n\tloopmaxw = maxw - offx;\n\t/* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n\toffy = img->y0 & 1U;\n\tloopmaxh = maxh - offy;\n\t\n\tif (offy > 0U) {\n\t\tsize_t j;\n\t\t\n\t\tfor(j=0; j < maxw; ++j)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t}\n\t}\n\n\tfor(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\t\t\n\t\tif (offx > 0U) {\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t}\n\n\t\tfor(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < loopmaxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < loopmaxh)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tfor(j=0U; j < (maxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}/* sycc420_to_rgb() */\n\nvoid color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))/* horizontal and vertical sub-sample */\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))/* horizontal sub-sample only */\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))/* no sub-sample */\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n}/* color_sycc_to_rgb() */\n\n#if defined(OPJ_HAVE_LIBLCMS2) || defined(OPJ_HAVE_LIBLCMS1)\n\n#ifdef OPJ_HAVE_LIBLCMS1\n/* Bob Friesenhahn proposed:*/\n#define cmsSigXYZData   icSigXYZData\n#define cmsSigLabData   icSigLabData\n#define cmsSigCmykData  icSigCmykData\n#define cmsSigYCbCrData icSigYCbCrData\n#define cmsSigLuvData   icSigLuvData\n#define cmsSigGrayData  icSigGrayData\n#define cmsSigRgbData   icSigRgbData\n#define cmsUInt32Number DWORD\n\n#define cmsColorSpaceSignature icColorSpaceSignature\n#define cmsGetHeaderRenderingIntent cmsTakeRenderingIntent\n\n#endif /* OPJ_HAVE_LIBLCMS1 */\n\n/*#define DEBUG_PROFILE*/\nvoid color_apply_icc_profile(opj_image_t *image)\n{\n\tcmsHPROFILE in_prof, out_prof;\n\tcmsHTRANSFORM transform;\n\tcmsColorSpaceSignature in_space, out_space;\n\tcmsUInt32Number intent, in_type, out_type;\n\tint *r, *g, *b;\n\tsize_t nr_samples;\n\tint prec, i, max, max_w, max_h, ok = 0;\n\tOPJ_COLOR_SPACE new_space;\n\n\tin_prof = \n\t cmsOpenProfileFromMem(image->icc_profile_buf, image->icc_profile_len);\n#ifdef DEBUG_PROFILE\n  FILE *icm = fopen(\"debug.icm\",\"wb\");\n  fwrite( image->icc_profile_buf,1, image->icc_profile_len,icm);\n  fclose(icm);\n#endif\n\n\tif(in_prof == NULL) return;\n\n\tin_space = cmsGetPCS(in_prof);\n\tout_space = cmsGetColorSpace(in_prof);\n\tintent = cmsGetHeaderRenderingIntent(in_prof);\n\n\t\n\tmax_w = (int)image->comps[0].w;\n  max_h = (int)image->comps[0].h;\n\tprec = (int)image->comps[0].prec;\n\n\tif(out_space == cmsSigRgbData) /* enumCS 16 */\n   {\n\tif( prec <= 8 )\n  {\n\tin_type = TYPE_RGB_8;\n\tout_type = TYPE_RGB_8;\n  }\n\telse\n  {\n\tin_type = TYPE_RGB_16;\n\tout_type = TYPE_RGB_16;\n  }\n\tout_prof = cmsCreate_sRGBProfile();\n\tnew_space = OPJ_CLRSPC_SRGB;\n   }\n\telse\n\tif(out_space == cmsSigGrayData) /* enumCS 17 */\n   {\n\tin_type = TYPE_GRAY_8;\n\tout_type = TYPE_RGB_8;\n\tout_prof = cmsCreate_sRGBProfile();\n\tnew_space = OPJ_CLRSPC_SRGB;\n   }\n\telse\n\tif(out_space == cmsSigYCbCrData) /* enumCS 18 */\n   {\n\tin_type = TYPE_YCbCr_16;\n\tout_type = TYPE_RGB_16;\n\tout_prof = cmsCreate_sRGBProfile();\n\tnew_space = OPJ_CLRSPC_SRGB;\n   }\n\telse\n   {\n#ifdef DEBUG_PROFILE\nfprintf(stderr,\"%s:%d: color_apply_icc_profile\\n\\tICC Profile has unknown \"\n\"output colorspace(%#x)(%c%c%c%c)\\n\\tICC Profile ignored.\\n\",\n__FILE__,__LINE__,out_space,\n\t(out_space>>24) & 0xff,(out_space>>16) & 0xff,\n\t(out_space>>8) & 0xff, out_space & 0xff);\n#endif\n\tcmsCloseProfile(in_prof);\n\n\treturn;\n   }\n\tif(out_prof == NULL)\n   {\n\tcmsCloseProfile(in_prof);\n\n\treturn;\n   }\n\n#ifdef DEBUG_PROFILE\nfprintf(stderr,\"%s:%d:color_apply_icc_profile\\n\\tchannels(%d) prec(%d) w(%d) h(%d)\"\n\"\\n\\tprofile: in(%p) out(%p)\\n\",__FILE__,__LINE__,image->numcomps,prec,\n\tmax_w,max_h, (void*)in_prof,(void*)out_prof);\n\nfprintf(stderr,\"\\trender_intent (%u)\\n\\t\"\n\"color_space: in(%#x)(%c%c%c%c)   out:(%#x)(%c%c%c%c)\\n\\t\"\n\"       type: in(%u)              out:(%u)\\n\",\n\tintent,\n\tin_space,\n\t(in_space>>24) & 0xff,(in_space>>16) & 0xff,\n\t(in_space>>8) & 0xff, in_space & 0xff,\n\n\tout_space,\n\t(out_space>>24) & 0xff,(out_space>>16) & 0xff,\n\t(out_space>>8) & 0xff, out_space & 0xff,\n\n\tin_type,out_type\n );\n#else\n  (void)prec;\n  (void)in_space;\n#endif /* DEBUG_PROFILE */\n\n\ttransform = cmsCreateTransform(in_prof, in_type,\n\t out_prof, out_type, intent, 0);\n\n#ifdef OPJ_HAVE_LIBLCMS2\n/* Possible for: LCMS_VERSION >= 2000 :*/\n\tcmsCloseProfile(in_prof);\n\tcmsCloseProfile(out_prof);\n#endif\n\n\tif(transform == NULL)\n   {\n#ifdef DEBUG_PROFILE\nfprintf(stderr,\"%s:%d:color_apply_icc_profile\\n\\tcmsCreateTransform failed. \"\n\"ICC Profile ignored.\\n\",__FILE__,__LINE__);\n#endif\n\n#ifdef OPJ_HAVE_LIBLCMS1\n\tcmsCloseProfile(in_prof);\n\tcmsCloseProfile(out_prof);\n#endif\n\treturn;\n   }\n\n\tif(image->numcomps > 2)/* RGB, RGBA */\n   {\n\tif( prec <= 8 )\n  {\n\tunsigned char *inbuf, *outbuf, *in, *out;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned char));\n\tin = inbuf = (unsigned char*)malloc(nr_samples);\n\tout = outbuf = (unsigned char*)malloc(nr_samples);\n\n\tif(inbuf == NULL || outbuf == NULL) goto fails0;\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned char)*r++;\n\t*in++ = (unsigned char)*g++;\n\t*in++ = (unsigned char)*b++;\n }\n\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++;\n\t*g++ = (int)*out++;\n\t*b++ = (int)*out++;\n }\n\tok = 1;\n\nfails0:\n\tif(inbuf) free(inbuf);\n\tif(outbuf) free(outbuf);\n  }\n\telse /* prec > 8 */\n  {\n\tunsigned short *inbuf, *outbuf, *in, *out;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned short));\n\tin = inbuf = (unsigned short*)malloc(nr_samples);\n\tout = outbuf = (unsigned short*)malloc(nr_samples);\n\n\tif(inbuf == NULL || outbuf == NULL) goto fails1;\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned short)*r++;\n\t*in++ = (unsigned short)*g++;\n\t*in++ = (unsigned short)*b++;\n }\n\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++;\n\t*g++ = (int)*out++;\n\t*b++ = (int)*out++;\n }\n\tok = 1;\n\nfails1:\n\tif(inbuf) free(inbuf); \n\tif(outbuf) free(outbuf);\n  }\n   }\n\telse /* image->numcomps <= 2 : GRAY, GRAYA */\n   {\n\tif(prec <= 8)\n  {\n\tunsigned char *in, *inbuf, *out, *outbuf;\n\topj_image_comp_t *new_comps;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned char));\n\tin = inbuf = (unsigned char*)malloc(nr_samples);\n\tout = outbuf = (unsigned char*)malloc(nr_samples);\n\tg = (int*)calloc((size_t)max, sizeof(int));\n\tb = (int*)calloc((size_t)max, sizeof(int));\n\n\tif(inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) goto fails2;\n\n\tnew_comps = (opj_image_comp_t*)\n\t realloc(image->comps, (image->numcomps+2)*sizeof(opj_image_comp_t));\n\n\tif(new_comps == NULL) goto fails2;\n\n\timage->comps = new_comps;\n\n\tif(image->numcomps == 2)\n\t image->comps[3] = image->comps[1];\n\n\timage->comps[1] = image->comps[0];\n\timage->comps[2] = image->comps[0];\n\n\timage->comps[1].data = g;\n\timage->comps[2].data = b;\n\n\timage->numcomps += 2;\n\n\tr = image->comps[0].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned char)*r++;\n }\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++; *g++ = (int)*out++; *b++ = (int)*out++;\n }\n\tr = g = b = NULL;\n\tok = 1;\n\nfails2:\n\tif(inbuf) free(inbuf);\n\tif(outbuf) free(outbuf);\n\tif(g) free(g);\n\tif(b) free(b);\n  }\n\telse /* prec > 8 */\n  {\n\tunsigned short *in, *inbuf, *out, *outbuf;\n\topj_image_comp_t *new_comps;\n\n\tmax = max_w * max_h;\n\tnr_samples = (size_t)(max * 3 * sizeof(unsigned short));\n\tin = inbuf = (unsigned short*)malloc(nr_samples);\n\tout = outbuf = (unsigned short*)malloc(nr_samples);\n\tg = (int*)calloc((size_t)max, sizeof(int));\n\tb = (int*)calloc((size_t)max, sizeof(int));\n\n\tif(inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) goto fails3;\n\n\tnew_comps = (opj_image_comp_t*)\n\t realloc(image->comps, (image->numcomps+2)*sizeof(opj_image_comp_t));\n\n\tif(new_comps == NULL) goto fails3;\n\n\timage->comps = new_comps;\n\n\tif(image->numcomps == 2)\n\t image->comps[3] = image->comps[1];\n\n\timage->comps[1] = image->comps[0];\n\timage->comps[2] = image->comps[0];\n\n\timage->comps[1].data = g;\n\timage->comps[2].data = b;\n\n\timage->numcomps += 2;\n\n\tr = image->comps[0].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*in++ = (unsigned short)*r++;\n }\n\tcmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n\tr = image->comps[0].data;\n\tg = image->comps[1].data;\n\tb = image->comps[2].data;\n\n\tfor(i = 0; i < max; ++i)\n {\n\t*r++ = (int)*out++; *g++ = (int)*out++; *b++ = (int)*out++;\n }\n\tr = g = b = NULL;\n\tok = 1;\n\nfails3:\n\tif(inbuf) free(inbuf);\n\tif(outbuf) free(outbuf);\n\tif(g) free(g);\n\tif(b) free(b);\n  }\n   }/* if(image->numcomps > 2) */\n\n\tcmsDeleteTransform(transform);\n\n#ifdef OPJ_HAVE_LIBLCMS1\n\tcmsCloseProfile(in_prof);\n\tcmsCloseProfile(out_prof);\n#endif\n\tif(ok)\n   {\n\timage->color_space = new_space;\n   }\n}/* color_apply_icc_profile() */\n\nvoid color_cielab_to_rgb(opj_image_t *image)\n{\n\tint *row;\n\tint enumcs, numcomps;\n\tOPJ_COLOR_SPACE new_space;\n\n\tnumcomps = (int)image->numcomps;\n\t\n\tif(numcomps != 3)\n\t{\n\t\tfprintf(stderr,\"%s:%d:\\n\\tnumcomps %d not handled. Quitting.\\n\",\n\t\t\t\t\t\t__FILE__,__LINE__,numcomps);\n\t\treturn;\n\t}\n\t\n\trow = (int*)image->icc_profile_buf;\n\tenumcs = row[0];\n\t\n\tif(enumcs == 14) /* CIELab */\n\t{\n\t\tint *L, *a, *b, *red, *green, *blue;\n\t\tint *src0, *src1, *src2, *dst0, *dst1, *dst2;\n\t\tdouble rl, ol, ra, oa, rb, ob, prec0, prec1, prec2;\n\t\tdouble minL, maxL, mina, maxa, minb, maxb;\n\t\tunsigned int default_type;\n\t\tunsigned int i, max;\n\t\tcmsHPROFILE in, out;\n\t\tcmsHTRANSFORM transform;\n\t\tcmsUInt16Number RGB[3];\n\t\tcmsCIELab Lab;\n\t\t\n\t\tin = cmsCreateLab4Profile(NULL);\n\t\tif(in == NULL){\n\t\t\treturn;\n\t\t}\n\t\tout = cmsCreate_sRGBProfile();\n\t\tif(out == NULL){\n\t\t\tcmsCloseProfile(in);\n\t\t\treturn;\n\t\t}\n\t\ttransform = cmsCreateTransform(in, TYPE_Lab_DBL, out, TYPE_RGB_16, INTENT_PERCEPTUAL, 0);\n\t\t\n#ifdef OPJ_HAVE_LIBLCMS2\n\t\tcmsCloseProfile(in);\n\t\tcmsCloseProfile(out);\n#endif\n\t\tif(transform == NULL)\n\t\t{\n#ifdef OPJ_HAVE_LIBLCMS1\n\t\t\tcmsCloseProfile(in);\n\t\t\tcmsCloseProfile(out);\n#endif\n\t\t\treturn;\n\t\t}\n\t\tnew_space = OPJ_CLRSPC_SRGB;\n\n\t\tprec0 = (double)image->comps[0].prec;\n\t\tprec1 = (double)image->comps[1].prec;\n\t\tprec2 = (double)image->comps[2].prec;\n\t\t\n\t\tdefault_type = (unsigned int)row[1];\n\t\t\n\t\tif(default_type == 0x44454600)/* DEF : default */\n\t\t{\n\t\t\trl = 100; ra = 170; rb = 200;\n\t\t\tol = 0;\n\t\t\toa = pow(2, prec1 - 1);\n\t\t\tob = pow(2, prec2 - 2) +  pow(2, prec2 - 3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trl = row[2]; ra = row[4]; rb = row[6];\n\t\t\tol = row[3]; oa = row[5]; ob = row[7];\n\t\t}\n\t\t\n\t\tL = src0 = image->comps[0].data;\n\t\ta = src1 = image->comps[1].data;\n\t\tb = src2 = image->comps[2].data;\n\t\t\n\t\tmax = image->comps[0].w * image->comps[0].h;\n\t\t\n\t\tred = dst0 = (int*)malloc(max * sizeof(int));\n\t\tgreen = dst1 = (int*)malloc(max * sizeof(int));\n\t\tblue = dst2 = (int*)malloc(max * sizeof(int));\n\n\t\tif(red == NULL || green == NULL || blue == NULL) goto fails;\n\n\t\tminL = -(rl * ol)/(pow(2, prec0)-1);\n\t\tmaxL = minL + rl;\n\t\t\n\t\tmina = -(ra * oa)/(pow(2, prec1)-1);\n\t\tmaxa = mina + ra;\n\t\t\n\t\tminb = -(rb * ob)/(pow(2, prec2)-1);\n\t\tmaxb = minb + rb;\n\t\t\n\t\tfor(i = 0; i < max; ++i)\n\t\t{\n\t\t\tLab.L = minL + (double)(*L) * (maxL - minL)/(pow(2, prec0)-1); ++L;\n\t\t\tLab.a = mina + (double)(*a) * (maxa - mina)/(pow(2, prec1)-1); ++a;\n\t\t\tLab.b = minb + (double)(*b) * (maxb - minb)/(pow(2, prec2)-1); ++b;\n\t\t\n\t\t\tcmsDoTransform(transform, &Lab, RGB, 1);\n\t\t\n\t\t\t*red++ = RGB[0];\n\t\t\t*green++ = RGB[1];\n\t\t\t*blue++ = RGB[2];\n\t\t}\n\t\tcmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n\t\tcmsCloseProfile(in);\n\t\tcmsCloseProfile(out);\n#endif\n\t\tfree(src0); image->comps[0].data = dst0;\n\t\tfree(src1); image->comps[1].data = dst1;\n\t\tfree(src2); image->comps[2].data = dst2;\n\t\t\n\t\timage->color_space = new_space;\n\t\timage->comps[0].prec = 16;\n\t\timage->comps[1].prec = 16;\n\t\timage->comps[2].prec = 16;\n\t\t\n\t\treturn;\n\nfails:\n\t\tcmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n\t\tcmsCloseProfile(in);\n\t\tcmsCloseProfile(out);\n#endif\n\t\tif(red) free(red);\n\t\tif(green) free(green);\n\t\tif(blue) free(blue);\n\t\treturn;\n\t}\n\t\n\tfprintf(stderr,\"%s:%d:\\n\\tenumCS %d not handled. Ignoring.\\n\", __FILE__,__LINE__, enumcs);\n}/* color_cielab_to_rgb() */\n\n#endif /* OPJ_HAVE_LIBLCMS2 || OPJ_HAVE_LIBLCMS1 */\n\nvoid color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif(image->numcomps < 4) return;\n\n\tmax = w * h;\n\t\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t/* CMYK values from 0 to 1 */\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t/* Invert all CMYK values */\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t/* CMYK -> RGB : RGB results from 0 to 255 */\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}/* color_cmyk_to_rgb() */\n\n/*\n * This code has been adopted from sjpx_openjpeg.c of ghostscript\n */\nvoid color_esycc_to_rgb(opj_image_t *image)\n{\n\tint y, cb, cr, sign1, sign2, val;\n\tunsigned int w, h, max, i;\n\tint flip_value = (1 << (image->comps[0].prec-1));\n\tint max_value = (1 << image->comps[0].prec) - 1;\n\t\n\tif (\n\t\t    (image->numcomps < 3)\n\t\t || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx)\n\t\t || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy)\n\t   ) {\n\t\tfprintf(stderr,\"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n\t}\n\t\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\t\n\tsign1 = (int)image->comps[1].sgnd;\n\tsign2 = (int)image->comps[2].sgnd;\n\t\n\tmax = w * h;\n\t\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t\n\t\ty = image->comps[0].data[i]; cb = image->comps[1].data[i]; cr = image->comps[2].data[i];\n\t\t\n\t\tif( !sign1) cb -= flip_value;\n\t\tif( !sign2) cr -= flip_value;\n\t\t\n\t\tval = (int)\n\t\t((float)y - (float)0.0000368 * (float)cb\n\t\t + (float)1.40199 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[0].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n\t\t - (float)0.7141128 * (float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[1].data[i] = val;\n\t\t\n\t\tval = (int)\n\t\t((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n\t\t - (float)0.000008 *(float)cr + (float)0.5);\n\t\t\n\t\tif(val > max_value) val = max_value; else if(val < 0) val = 0;\n\t\timage->comps[2].data[i] = val;\n\t}\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_esycc_to_rgb() */\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n\tOPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n\tOPJ_UINT32 bfSize;      /* Size of the file        */\n\tOPJ_UINT16 bfReserved1; /* Reserved : 0            */\n\tOPJ_UINT16 bfReserved2; /* Reserved : 0            */\n\tOPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n\tOPJ_UINT32 biSize;             /* Size of the structure in bytes */\n\tOPJ_UINT32 biWidth;            /* Width of the image in pixels */\n\tOPJ_UINT32 biHeight;           /* Heigth of the image in pixels */\n\tOPJ_UINT16 biPlanes;           /* 1 */\n\tOPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n\tOPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n\tOPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n\tOPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n\tOPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n\tOPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n\tOPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n\tOPJ_UINT32 biRedMask;          /* Red channel bit mask */\n\tOPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n\tOPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n\tOPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n\tOPJ_UINT32 biColorSpaceType;   /* Color space type */\n\tOPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n\tOPJ_UINT32 biRedGamma;         /* Red channel gamma */\n\tOPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n\tOPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n\tOPJ_UINT32 biIntent;           /* Intent */\n\tOPJ_UINT32 biIccProfileData;   /* ICC profile data */\n\tOPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n\tOPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* pDst, OPJ_INT32 dstStride,\n\tOPJ_UINT8 const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tpDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpDst += dstStride;\n\t}\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n\tOPJ_UINT8 const* const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\tOPJ_INT32* pR = pDst[0];\n\tOPJ_INT32* pG = pDst[1];\n\tOPJ_INT32* pB = pDst[2];\n\tOPJ_UINT8 const* pLUT_R = pLUT[0];\n\tOPJ_UINT8 const* pLUT_G = pLUT[1];\n\tOPJ_UINT8 const* pLUT_B = pLUT[2];\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT8 idx = pSrc[x];\n\t\t\tpR[x] = (OPJ_INT32)pLUT_R[idx];\n\t\t\tpG[x] = (OPJ_INT32)pLUT_G[idx];\n\t\t\tpB[x] = (OPJ_INT32)pLUT_B[idx];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpR += pDstStride[0];\n\t\tpG += pDstStride[1];\n\t\tpB += pDstStride[2];\n\t}\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)pSrc[3*x+2];\t/* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)pSrc[3*x+1];\t/* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)pSrc[3*x+0];\t/* B */\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)\n{\n\tOPJ_UINT32 l_shift, l_prec;\n\t\n\tl_shift = l_prec = 0U;\n\t\n\tif (mask != 0U) {\n\t\twhile ((mask & 1U) == 0U) {\n\t\t\tmask >>= 1;\n\t\t\tl_shift++;\n\t\t}\n\t\twhile (mask & 1U) {\n\t\t\tmask >>= 1;\n\t\t\tl_prec++;\n\t\t}\n\t}\n\t*shift = l_shift; *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+1]) <<  8;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+2]) << 16;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+3]) << 24;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+1]) <<  8;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n\tOPJ_UINT32 width, height;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tpSrc = pData + (height - 1U) * stride;\n\tif (image->numcomps == 1U) {\n\t\topj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);\n\t}\n\telse {\n\t\tOPJ_INT32* pDst[3];\n\t\tOPJ_INT32  pDstStride[3];\n\t\t\n\t\tpDst[0] = image->comps[0].data; pDst[1] = image->comps[1].data; pDst[2] = image->comps[2].data;\n\t\tpDstStride[0] = (OPJ_INT32)width; pDstStride[1] = (OPJ_INT32)width; pDstStride[2] = (OPJ_INT32)width;\n\t\topj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT, width, height);\n\t}\n\treturn image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n\theader->bfType  = (OPJ_UINT16)getc(IN);\n\theader->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif (header->bfType != 19778) {\n\t\tfprintf(stderr,\"Error, not a BMP file!\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t/* FILE HEADER */\n\t/* ------------- */\n\theader->bfSize  = (OPJ_UINT32)getc(IN);\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->bfReserved1  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfReserved2  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfOffBits  = (OPJ_UINT32)getc(IN);\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n\treturn OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n\tmemset(header, 0, sizeof(*header));\n\t/* INFO HEADER */\n\t/* ------------- */\n\theader->biSize  = (OPJ_UINT32)getc(IN);\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\tswitch (header->biSize) {\n\t\tcase 12U:  /* BITMAPCOREHEADER */\n\t\tcase 40U:  /* BITMAPINFOHEADER */\n\t\tcase 52U:  /* BITMAPV2INFOHEADER */\n\t\tcase 56U:  /* BITMAPV3INFOHEADER */\n\t\tcase 108U: /* BITMAPV4HEADER */\n\t\tcase 124U: /* BITMAPV5HEADER */\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr,\"Error, unknown BMP header size %d\\n\", header->biSize);\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\theader->biWidth  = (OPJ_UINT32)getc(IN);\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biHeight  = (OPJ_UINT32)getc(IN);\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biPlanes  = (OPJ_UINT16)getc(IN);\n\theader->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->biBitCount  = (OPJ_UINT16)getc(IN);\n\theader->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif(header->biSize >= 40U) {\n\t\theader->biCompression  = (OPJ_UINT32)getc(IN);\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biSizeImage  = (OPJ_UINT32)getc(IN);\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrUsed  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrImportant  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 56U) {\n\t\theader->biRedMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biAlphaMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 108U) {\n\t\theader->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\tif (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP), IN) != sizeof(header->biColorSpaceEP)) {\n\t\t\tfprintf(stderr,\"Error, can't  read BMP header\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\theader->biRedGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 124U) {\n\t\theader->biIntent  = (OPJ_UINT32)getc(IN);\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileData  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biReserved  = (OPJ_UINT32)getc(IN);\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_ARG_NOT_USED(width);\n\t\n\tif ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )\n\t{\n\t\tfprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\t\n\tx = y = 0U;\n\twhile (y < height)\n\t{\n\t\tint c = getc(IN);\n\t\t\n\t\tif (c) {\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = c1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tc = getc(IN);\n\t\t\tif (c == 0x00) { /* EOL */\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse if (c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);\n\t\t\t\tx += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);\n\t\t\t\ty += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse /* 03 .. 255 */\n\t\t\t{\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++)\n\t\t\t\t{\n\t\t\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t*pix = c1;\n\t\t\t\t}\n\t\t\t\tif ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/* while() */\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\tx = y = 0U;\n\twhile(y < height)\n\t{\n\t\tint c = getc(IN);\n\t\tif(c == EOF) break;\n\t\t\n\t\tif(c) {/* encoded mode */\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t}\n\t\t}\n\t\telse { /* absolute mode */\n\t\t\tc = getc(IN);\n\t\t\tif(c == EOF) break;\n\t\t\n\t\t\tif(c == 0x00) { /* EOL */\n\t\t\t\tx = 0;  y++;  pix = pData + y * stride;\n\t\t\t}\n\t\t\telse if(c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);  x += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);  y += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse { /* 03 .. 255 : absolute mode */\n\t\t\t\tint j;\n\t\t\t\tOPJ_UINT8 c1 = 0U;\n\t\t\t\t\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t\tif((j&1) == 0) {\n\t\t\t\t\t\t\tc1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t}\n\t\t\t\t\t*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t\t}\n\t\t\t\tif(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */\n\t\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  /* while(y < height) */\n\treturn OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\topj_image_cmptparm_t cmptparm[4];\t/* maximum of 4 components */\n\tOPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n\tOPJ_UINT8 const* pLUT[3];\n\topj_image_t * image = NULL;\n\tFILE *IN;\n\tOPJ_BITMAPFILEHEADER File_h;\n\tOPJ_BITMAPINFOHEADER Info_h;\n\tOPJ_UINT32 i, palette_len, numcmpts = 1U;\n\tOPJ_BOOL l_result = OPJ_FALSE;\n\tOPJ_UINT8* pData = NULL;\n\tOPJ_UINT32 stride;\n\t\n\tpLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;\n\t\n\tIN = fopen(filename, \"rb\");\n\tif (!IN)\n\t{\n\t\tfprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n\t\treturn NULL;\n\t}\n\n\tif (!bmp_read_file_header(IN, &File_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tif (!bmp_read_info_header(IN, &Info_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* Load palette */\n\tif (Info_h.biBitCount <= 8U)\n\t{\n\t\tmemset(&lut_R[0], 0, sizeof(lut_R));\n\t\tmemset(&lut_G[0], 0, sizeof(lut_G));\n\t\tmemset(&lut_B[0], 0, sizeof(lut_B));\n\t\t\n\t\tpalette_len = Info_h.biClrUsed;\n\t\tif((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n\t\t\tpalette_len = (1U << Info_h.biBitCount);\n\t\t}\n\t\tif (palette_len > 256U) {\n\t\t\tpalette_len = 256U;\n\t\t}\n\t\tif (palette_len > 0U) {\n\t\t\tOPJ_UINT8 has_color = 0U;\n\t\t\tfor (i = 0U; i < palette_len; i++) {\n\t\t\t\tlut_B[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_G[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_R[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\t(void)getc(IN); /* padding */\n\t\t\t\thas_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n\t\t\t}\n\t\t\tif(has_color) {\n\t\t\t\tnumcmpts = 3U;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnumcmpts = 3U;\n\t\tif ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n\t\t\tnumcmpts++;\n\t\t}\n\t}\n\t\n\tstride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */\n\tif (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n\t\tstride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n\t}\n\tpData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n\tif (pData == NULL) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t/* Place the cursor at the beginning of the image information */\n\tfseek(IN, 0, SEEK_SET);\n\tfseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\t\n\tswitch (Info_h.biCompression) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\t/* read raw data */\n\t\t\tl_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* read rle8 data */\n\t\t\tl_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* read rle4 data */\n\t\t\tl_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr, \"Unsupported BMP compression\\n\");\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t}\n\tif (!l_result) {\n\t\tfree(pData);\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* create the image */\n\tmemset(&cmptparm[0], 0, sizeof(cmptparm));\n\tfor(i = 0; i < 4U; i++)\n\t{\n\t\tcmptparm[i].prec = 8;\n\t\tcmptparm[i].bpp  = 8;\n\t\tcmptparm[i].sgnd = 0;\n\t\tcmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n\t\tcmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n\t\tcmptparm[i].w    = Info_h.biWidth;\n\t\tcmptparm[i].h    = Info_h.biHeight;\n\t}\n\n\timage = opj_image_create(numcmpts, &cmptparm[0], (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n\tif(!image) {\n\t\tfclose(IN);\n\t\tfree(pData);\n\t\treturn NULL;\n\t}\n\tif (numcmpts == 4U) {\n\t\timage->comps[3].alpha = 1;\n\t}\n\t\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\timage->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)parameters->subsampling_dx + 1U;\n\timage->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)parameters->subsampling_dy + 1U;\n\t\n\t/* Read the data */\n\tif (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n\t\tbmp24toimage(pData, stride, image);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n\t\tbmp8toimage(pData, stride, image, pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU, 0x00000000U);\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n\t\tbmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n\t\tif ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) && (Info_h.biBlueMask == 0U)) {\n\t\t\tInfo_h.biRedMask   = 0xF800U;\n\t\t\tInfo_h.biGreenMask = 0x07E0U;\n\t\t\tInfo_h.biBlueMask  = 0x001FU;\n\t\t}\n\t\tbmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse {\n\t\topj_image_destroy(image);\n\t\timage = NULL;\n\t\tfprintf(stderr, \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\", Info_h.biBitCount);\n\t}\n\tfree(pData);\n\tfclose(IN);\n\treturn image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile) {\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }\n        else\n            adjustR = 0;\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\", image->comps[1].prec);\n        }\n        else\n            adjustG = 0;\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\", image->comps[2].prec);\n        }\n        else\n            adjustB = 0;\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            g = ((g >> adjustG)+((g >> (adjustG-1))%2));\n            if(g > 255) g = 255; else if(g < 0) g = 0;\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            b = ((b >> adjustB)+((b >> (adjustB-1))%2));\n            if(b > 255) b = 255; else if(b < 0) b = 0;\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    } else {\t\t\t/* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }else\n            adjustR = 0;\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n"], "filenames": ["src/bin/common/color.c", "src/bin/jp2/convertbmp.c"], "buggy_code_start_loc": [94, 970], "buggy_code_end_loc": [329, 971], "fixing_code_start_loc": [94, 970], "fixing_code_end_loc": [352, 971], "type": "CWE-125", "message": "The sycc422_t_rgb function in common/color.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted jpeg2000 file.", "other": {"cve": {"id": "CVE-2016-3183", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-03T16:59:00.137", "lastModified": "2020-09-09T19:57:00.343", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The sycc422_t_rgb function in common/color.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted jpeg2000 file."}, {"lang": "es", "value": "La funci\u00f3n sycc422_t_rgb en common/color.c en OpenJPEG en versiones anteriores a 2.1.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) a trav\u00e9s de un archivo jpeg2000 manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.0", "matchCriteriaId": "BA6BA5BE-0BB1-43CD-8F99-1252CA514E6D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/03/16/17", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1317821", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/726", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5FFMOZOF2EI6N2CR23EQ5EATWLQKBMHW/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BJM23YERMEC6LCTWBUH7LZURGSLZDFDH/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DFRD35RIPRCGZA5DKAKHZ62LMP2A5UT7/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HPMDEUIMHTLKMHELDL4F4HZ7X4Y34JEB/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201612-26", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767"}}