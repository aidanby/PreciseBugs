{"buggy_code": ["import { isArray, isMissing, isBasicType, isObject } from './TypeUtil';\nimport { ICollideModifiers } from '../interfaces';\nimport { BasicType } from '../types';\n\n/**\n * collide 2 arguments\n * @param arg1 first argument to collide into (note: original object won't be modified directly)\n * @param arg2 second argument to collide from\n * @param modifiers\n * @param startPath the entry path to start modifier path generation. Default value: $\n * @returns collide result\n */\nexport function collide(arg1: any, arg2: any, modifiers?: ICollideModifiers, startPath = '$'): any {\n    const arg1Clone = isMissing(arg1) ? arg1 : JSON.parse(JSON.stringify(arg1));\n    const arg2Clone = isMissing(arg2) ? arg2 : JSON.parse(JSON.stringify(arg2));\n\n    return collideUnsafe(arg1Clone, arg2Clone, modifiers, startPath);\n}\n\n/**\n * Collide unsafe (arg1 may be modified directly)\n * @param arg1 first argument to collide into (note: original object will be modified directly)\n * @param arg2 second argument to collide from\n * @param modifiers\n * @param startPath the entry path to start modifier path generation. Default value: $\n * @returns collide result\n */\nexport function collideUnsafe(arg1: any, arg2: any,  modifiers?: ICollideModifiers, startPath: string = '$'): any {\n    if (arg2 === undefined) {\n        return arg1;\n    }\n\n    if (isMissing(arg1)) {\n        return arg2;\n    }\n\n    if (isBasicType(arg1)) {\n        return collideBasic(arg1, arg2, startPath, modifiers);\n    }\n\n    if (isArray(arg1)) {\n        return collideArrays(arg1, arg2, startPath, modifiers);\n    }\n\n    return collideObjects(arg1, arg2, startPath, modifiers);\n}\n\n/**\n * collide basic value types\n * @param arg1\n * @param arg2\n * @param path\n * @param modifiers\n */\nfunction collideBasic(arg1: BasicType, arg2: BasicType, path: string, modifiers?: ICollideModifiers): any {\n    if (modifiers && modifiers[path]) {\n        return modifiers[path](arg1, arg2);\n    }\n\n    return arg2;\n}\n\n/**\n * collide objects\n * @param obj1\n * @param obj2\n * @param path\n * @param modifiers\n */\nfunction collideObjects(obj1: any, obj2: any, path: string, modifiers?: ICollideModifiers): any {\n    if (!isObject(obj2)) {\n        throw new Error(`Unable to collide. Collide value at path ${path} is not an object.`);\n    }\n\n    if (modifiers && modifiers[path]) {\n        return modifiers[path](obj1, obj2);\n    }\n\n    for (const key of Object.keys(obj2)) {\n        const subPath = path + '.' + key;\n\n        if (obj1[key] === undefined) {\n            obj1[key] = obj2[key];\n        } else {\n            if (modifiers && modifiers[subPath]) {\n                obj1[key] = modifiers[subPath](obj1[key], obj2[key]);\n            } else {\n                obj1[key] = collideUnsafe(obj1[key], obj2[key], modifiers, subPath);\n            }\n        }\n    }\n\n    return obj1;\n}\n\n/**\n * collide arrays. Default behaviour to push values of arr2 into arr1.\n * @param arr1\n * @param arr2\n * @param path\n * @param modifiers\n */\nfunction collideArrays(arr1: any[], arr2: any[], path: string, modifiers?: ICollideModifiers): any {\n    if (!isArray(arr2)) {\n        throw new Error(`Unable to collide. Collide value at path ${path} is not an array.`);\n    }\n\n    if (modifiers && modifiers[path]) {\n        return modifiers[path](arr1, arr2);\n    } else {\n        for (const item of arr2) {\n            if (arr1.indexOf(item) < 0) {\n                arr1.push(item);\n            }\n        }\n    }\n\n    return arr1;\n}\n", "import { suite, test } from 'mocha-typescript';\nimport { collide, collideUnsafe } from '../../src/utils/CollideUtil';\nimport * as assert from 'assert';\n\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nchai.use(chaiAsPromised);\n\n@suite()\nclass CollideUtilTestSuite {\n    @test()\n    async testCollideWithoutModifiers(): Promise<void> {\n        const result = collide(\n            {\n                array: [1, 2],\n                obj: {\n                    n: 'something',\n                    a: true,\n                    c: 'yes',\n                    array: [11, 12],\n                },\n                override: 11,\n            },\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    d: 'd',\n                    e: 1,\n                    n: null,\n                    array: [12, 13, 14],\n                },\n                override: 111,\n            },\n        );\n\n        assert.deepStrictEqual(result, {\n            array: [1, 2, 3, 4],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                d: 'd',\n                e: 1,\n                n: null,\n                array: [11, 12, 13, 14],\n            },\n            override: 111,\n        });\n    }\n\n    @test()\n    async testCollideUnsafeWithoutModifiers(): Promise<void> {\n        const obj1 = {\n            array: [1, 2],\n            obj: {\n                n: 'something',\n                a: true,\n                c: 'yes',\n                array: [11, 12],\n            },\n            override: 11,\n        };\n\n        collideUnsafe(\n            obj1,\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    d: 'd',\n                    e: 1,\n                    n: null,\n                    array: [12, 13, 14],\n                },\n                override: 111,\n            },\n        );\n\n        assert.deepStrictEqual(obj1, {\n            array: [1, 2, 3, 4],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                d: 'd',\n                e: 1,\n                n: null,\n                array: [11, 12, 13, 14],\n            },\n            override: 111,\n        });\n    }\n\n    @test()\n    async testCollideWithModifiers(): Promise<void> {\n        const result = collide(\n            {\n                array: [1, 2],\n                obj: {\n                    a: true,\n                    c: 'yes',\n                    array: [11, 12],\n                },\n                override: 11,\n            },\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    array: [13, 14],\n                },\n                override: 111,\n            },\n            {\n                '$.array': (a: any, b: any) => {\n                    b.push(...a);\n\n                    return b;\n                },\n                '$.obj': (a: any, b: any) => Object.assign(a, b),\n                '$.override': (a: any) => a,\n            },\n        );\n\n        assert.deepStrictEqual(result, {\n            array: [3, 4, 1, 2],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                array: [13, 14],\n            },\n            override: 11,\n        });\n    }\n\n    @test()\n    async testCollideWithModifiersAndCustomPath(): Promise<void> {\n        const result = collide(\n            {\n                array: [1, 2],\n                obj: {\n                    a: true,\n                    c: 'yes',\n                    array: [11, 12],\n                },\n                override: 11,\n            },\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    array: [13, 14],\n                },\n                override: 111,\n            },\n            {\n                '#.custom.array': (a: any, b: any) => {\n                    b.push(...a);\n\n                    return b;\n                },\n                '#.custom.obj': (a: any, b: any) => Object.assign(a, b),\n                '#.custom.override': (a: any) => a,\n            },\n            '#.custom'\n        );\n\n        assert.deepStrictEqual(result, {\n            array: [3, 4, 1, 2],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                array: [13, 14],\n            },\n            override: 11,\n        });\n    }\n\n    @test()\n    async testRootObjectCollideWithModifiers(): Promise<void> {\n        const result = collide(\n            {\n                a: 11,\n            },\n            {\n                a: 111,\n            },\n            {\n                $: (a: any, b: any) => {\n                    return {\n                        a: a.a * 1000 + b.a,\n                    };\n                },\n            },\n        );\n\n        assert.deepStrictEqual(result, {\n            a: 11111,\n        });\n    }\n\n    @test()\n    async testRootArrayCollideWithModifiers(): Promise<void> {\n        const result = collide([11], [111], {\n            $: (a: any, b: any) => {\n                return [a[0] * 1000 + b[0]];\n            },\n        });\n\n        assert.deepStrictEqual(result, [11111]);\n    }\n\n    @test()\n    async testWithMissingTarget(): Promise<void> {\n        const result = collide(\n            {\n                test: true,\n            },\n            undefined,\n        );\n\n        assert.deepStrictEqual(result, {\n            test: true,\n        });\n    }\n\n    @test()\n    async testWithEmptySource(): Promise<void> {\n        const result = collide(null, {\n            test: true,\n        });\n\n        assert.deepStrictEqual(result, {\n            test: true,\n        });\n    }\n\n    @test()\n    async testBasicsWithModifiers(): Promise<void> {\n        const result = collide(1, 2, {\n            $: (a: any, b: any) => {\n                return a + b;\n            },\n        });\n\n        assert.strictEqual(result, 3);\n    }\n\n    @test()\n    async invalidTypes(): Promise<void> {\n        chai.expect(() => {\n            collide({ a: { b: true } }, { a: true });\n        }).to.throw('Unable to collide. Collide value at path $.a is not an object.');\n\n        chai.expect(() => {\n            collide({ a: [1, 2] }, { a: true });\n        }).to.throw('Unable to collide. Collide value at path $.a is not an array.');\n    }\n}\n"], "fixing_code": ["import { isArray, isMissing, isBasicType, isObject } from './TypeUtil';\nimport { ICollideModifiers } from '../interfaces';\nimport { BasicType } from '../types';\n\n/**\n * collide 2 arguments\n * @param arg1 first argument to collide into (note: original object won't be modified directly)\n * @param arg2 second argument to collide from\n * @param modifiers\n * @param startPath the entry path to start modifier path generation. Default value: $\n * @returns collide result\n */\nexport function collide(arg1: any, arg2: any, modifiers?: ICollideModifiers, startPath = '$'): any {\n    const arg1Clone = isMissing(arg1) ? arg1 : JSON.parse(JSON.stringify(arg1));\n    const arg2Clone = isMissing(arg2) ? arg2 : JSON.parse(JSON.stringify(arg2));\n\n    return collideUnsafe(arg1Clone, arg2Clone, modifiers, startPath);\n}\n\n/**\n * Collide unsafe (arg1 may be modified directly)\n * @param arg1 first argument to collide into (note: original object will be modified directly)\n * @param arg2 second argument to collide from\n * @param modifiers\n * @param startPath the entry path to start modifier path generation. Default value: $\n * @returns collide result\n */\nexport function collideUnsafe(arg1: any, arg2: any, modifiers?: ICollideModifiers, startPath = '$'): any {\n    if (arg2 === undefined) {\n        return arg1;\n    }\n\n    if (isMissing(arg1)) {\n        return arg2;\n    }\n\n    if (isBasicType(arg1)) {\n        return collideBasic(arg1, arg2, startPath, modifiers);\n    }\n\n    if (isArray(arg1)) {\n        return collideArrays(arg1, arg2, startPath, modifiers);\n    }\n\n    return collideObjects(arg1, arg2, startPath, modifiers);\n}\n\n/**\n * collide basic value types\n * @param arg1\n * @param arg2\n * @param path\n * @param modifiers\n */\nfunction collideBasic(arg1: BasicType, arg2: BasicType, path: string, modifiers?: ICollideModifiers): any {\n    if (modifiers && modifiers[path]) {\n        return modifiers[path](arg1, arg2);\n    }\n\n    return arg2;\n}\n\n/**\n * collide objects\n * @param obj1\n * @param obj2\n * @param path\n * @param modifiers\n */\nfunction collideObjects(obj1: any, obj2: any, path: string, modifiers?: ICollideModifiers): any {\n    if (!isObject(obj2)) {\n        throw new Error(`Unable to collide. Collide value at path ${path} is not an object.`);\n    }\n\n    if (modifiers && modifiers[path]) {\n        return modifiers[path](obj1, obj2);\n    }\n\n    for (const key of Object.keys(obj2)) {\n        const subPath = path + '.' + key;\n        if (key !== '__proto__') {\n            if (obj1[key] === undefined) {\n                obj1[key] = obj2[key];\n            } else {\n                if (modifiers && modifiers[subPath]) {\n                    obj1[key] = modifiers[subPath](obj1[key], obj2[key]);\n                } else {\n                    obj1[key] = collideUnsafe(obj1[key], obj2[key], modifiers, subPath);\n                }\n            }\n        }\n    }\n\n    return obj1;\n}\n\n/**\n * collide arrays. Default behaviour to push values of arr2 into arr1.\n * @param arr1\n * @param arr2\n * @param path\n * @param modifiers\n */\nfunction collideArrays(arr1: any[], arr2: any[], path: string, modifiers?: ICollideModifiers): any {\n    if (!isArray(arr2)) {\n        throw new Error(`Unable to collide. Collide value at path ${path} is not an array.`);\n    }\n\n    if (modifiers && modifiers[path]) {\n        return modifiers[path](arr1, arr2);\n    } else {\n        for (const item of arr2) {\n            if (arr1.indexOf(item) < 0) {\n                arr1.push(item);\n            }\n        }\n    }\n\n    return arr1;\n}\n", "import { suite, test } from 'mocha-typescript';\nimport { collide, collideUnsafe } from '../../src/utils/CollideUtil';\nimport * as assert from 'assert';\n\nconst chai = require('chai');\nconst chaiAsPromised = require('chai-as-promised');\nchai.use(chaiAsPromised);\n\n@suite()\nclass CollideUtilTestSuite {\n    @test()\n    async testCollideWithoutModifiers(): Promise<void> {\n        const result = collide(\n            {\n                array: [1, 2],\n                obj: {\n                    n: 'something',\n                    a: true,\n                    c: 'yes',\n                    array: [11, 12],\n                },\n                override: 11,\n            },\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    d: 'd',\n                    e: 1,\n                    n: null,\n                    array: [12, 13, 14],\n                },\n                override: 111,\n            },\n        );\n\n        assert.deepStrictEqual(result, {\n            array: [1, 2, 3, 4],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                d: 'd',\n                e: 1,\n                n: null,\n                array: [11, 12, 13, 14],\n            },\n            override: 111,\n        });\n    }\n\n    @test()\n    async testCollideUnsafeWithoutModifiers(): Promise<void> {\n        const obj1 = {\n            array: [1, 2],\n            obj: {\n                n: 'something',\n                a: true,\n                c: 'yes',\n                array: [11, 12],\n            },\n            override: 11,\n        };\n\n        collideUnsafe(obj1, {\n            array: [3, 4],\n            obj: {\n                b: false,\n                d: 'd',\n                e: 1,\n                n: null,\n                array: [12, 13, 14],\n            },\n            override: 111,\n        });\n\n        assert.deepStrictEqual(obj1, {\n            array: [1, 2, 3, 4],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                d: 'd',\n                e: 1,\n                n: null,\n                array: [11, 12, 13, 14],\n            },\n            override: 111,\n        });\n    }\n\n    @test()\n    async testCollideWithModifiers(): Promise<void> {\n        const result = collide(\n            {\n                array: [1, 2],\n                obj: {\n                    a: true,\n                    c: 'yes',\n                    array: [11, 12],\n                },\n                override: 11,\n            },\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    array: [13, 14],\n                },\n                override: 111,\n            },\n            {\n                '$.array': (a: any, b: any) => {\n                    b.push(...a);\n\n                    return b;\n                },\n                '$.obj': (a: any, b: any) => Object.assign(a, b),\n                '$.override': (a: any) => a,\n            },\n        );\n\n        assert.deepStrictEqual(result, {\n            array: [3, 4, 1, 2],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                array: [13, 14],\n            },\n            override: 11,\n        });\n    }\n\n    @test()\n    async testCollideWithModifiersAndCustomPath(): Promise<void> {\n        const result = collide(\n            {\n                array: [1, 2],\n                obj: {\n                    a: true,\n                    c: 'yes',\n                    array: [11, 12],\n                },\n                override: 11,\n            },\n            {\n                array: [3, 4],\n                obj: {\n                    b: false,\n                    array: [13, 14],\n                },\n                override: 111,\n            },\n            {\n                '#.custom.array': (a: any, b: any) => {\n                    b.push(...a);\n\n                    return b;\n                },\n                '#.custom.obj': (a: any, b: any) => Object.assign(a, b),\n                '#.custom.override': (a: any) => a,\n            },\n            '#.custom',\n        );\n\n        assert.deepStrictEqual(result, {\n            array: [3, 4, 1, 2],\n            obj: {\n                a: true,\n                b: false,\n                c: 'yes',\n                array: [13, 14],\n            },\n            override: 11,\n        });\n    }\n\n    @test()\n    async testRootObjectCollideWithModifiers(): Promise<void> {\n        const result = collide(\n            {\n                a: 11,\n            },\n            {\n                a: 111,\n            },\n            {\n                $: (a: any, b: any) => {\n                    return {\n                        a: a.a * 1000 + b.a,\n                    };\n                },\n            },\n        );\n\n        assert.deepStrictEqual(result, {\n            a: 11111,\n        });\n    }\n\n    @test()\n    async testRootArrayCollideWithModifiers(): Promise<void> {\n        const result = collide([11], [111], {\n            $: (a: any, b: any) => {\n                return [a[0] * 1000 + b[0]];\n            },\n        });\n\n        assert.deepStrictEqual(result, [11111]);\n    }\n\n    @test()\n    async testWithMissingTarget(): Promise<void> {\n        const result = collide(\n            {\n                test: true,\n            },\n            undefined,\n        );\n\n        assert.deepStrictEqual(result, {\n            test: true,\n        });\n    }\n\n    @test()\n    async testWithEmptySource(): Promise<void> {\n        const result = collide(null, {\n            test: true,\n        });\n\n        assert.deepStrictEqual(result, {\n            test: true,\n        });\n    }\n\n    @test()\n    async testBasicsWithModifiers(): Promise<void> {\n        const result = collide(1, 2, {\n            $: (a: any, b: any) => {\n                return a + b;\n            },\n        });\n\n        assert.strictEqual(result, 3);\n    }\n\n    @test()\n    async invalidTypes(): Promise<void> {\n        chai.expect(() => {\n            collide({ a: { b: true } }, { a: true });\n        }).to.throw('Unable to collide. Collide value at path $.a is not an object.');\n\n        chai.expect(() => {\n            collide({ a: [1, 2] }, { a: true });\n        }).to.throw('Unable to collide. Collide value at path $.a is not an array.');\n    }\n\n    @test()\n    async testWithPrototypePollution(): Promise<void> {\n        const collideWith = JSON.parse(`{\n            \"__proto__\": {\n                \"vulnerable\": \"yes\"\n            },\n            \"array\": [3, 4]\n        }`);\n\n        console.log(collideWith);\n\n        const result = collide(\n            {\n                array: [1, 2],\n            },\n            collideWith,\n        );\n\n        assert.ok(!result.vulnerable);\n        assert.deepStrictEqual(result, {\n            array: [1, 2, 3, 4],\n        });\n    }\n}\n"], "filenames": ["src/utils/CollideUtil.ts", "test/unit/CollideUtilTestSuite.ts"], "buggy_code_start_loc": [28, 65], "buggy_code_end_loc": [89, 261], "fixing_code_start_loc": [28, 65], "fixing_code_end_loc": [90, 283], "type": "NVD-CWE-Other", "message": "Prototype pollution vulnerability in 'object-collider' versions 1.0.0 through 1.0.3 allows attacker to cause a denial of service and may lead to remote code execution.", "other": {"cve": {"id": "CVE-2021-25914", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-03-01T18:15:19.957", "lastModified": "2021-03-08T12:53:36.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Prototype pollution vulnerability in 'object-collider' versions 1.0.0 through 1.0.3 allows attacker to cause a denial of service and may lead to remote code execution."}, {"lang": "es", "value": "Una vulnerabilidad de contaminaci\u00f3n de prototipo en \"object-collider\" versiones 1.0.0 hasta 1.0.3, permite al atacante causar una denegaci\u00f3n de servicio y puede conllevar a una ejecuci\u00f3n de c\u00f3digo remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fireblink:object-collider:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.0.0", "versionEndIncluding": "1.0.3", "matchCriteriaId": "66A8479E-39A6-469A-84AF-9C6916493CEC"}]}]}], "references": [{"url": "https://github.com/FireBlinkLTD/object-collider/commit/321f75a7f8e7b3393e5b7dd6dd9ab26ede5906e5", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25914", "source": "vulnerabilitylab@mend.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FireBlinkLTD/object-collider/commit/321f75a7f8e7b3393e5b7dd6dd9ab26ede5906e5"}}