{"buggy_code": ["require 'strscan'\n\nmodule HTML #:nodoc:\n  \n  class Conditions < Hash #:nodoc:\n    def initialize(hash)\n      super()\n      hash = { :content => hash } unless Hash === hash\n      hash = keys_to_symbols(hash)\n      hash.each do |k,v|\n        case k\n          when :tag, :content then\n            # keys are valid, and require no further processing\n          when :attributes then\n            hash[k] = keys_to_strings(v)\n          when :parent, :child, :ancestor, :descendant, :sibling, :before,\n                  :after\n            hash[k] = Conditions.new(v)\n          when :children\n            hash[k] = v = keys_to_symbols(v)\n            v.each do |k,v2|\n              case k\n                when :count, :greater_than, :less_than\n                  # keys are valid, and require no further processing\n                when :only\n                  v[k] = Conditions.new(v2)\n                else\n                  raise \"illegal key #{k.inspect} => #{v2.inspect}\"\n              end\n            end\n          else\n            raise \"illegal key #{k.inspect} => #{v.inspect}\"\n        end\n      end\n      update hash\n    end\n\n    private\n\n      def keys_to_strings(hash)\n        hash.keys.inject({}) do |h,k|\n          h[k.to_s] = hash[k]\n          h\n        end\n      end\n\n      def keys_to_symbols(hash)\n        hash.keys.inject({}) do |h,k|\n          raise \"illegal key #{k.inspect}\" unless k.respond_to?(:to_sym)\n          h[k.to_sym] = hash[k]\n          h\n        end\n      end\n  end\n\n  # The base class of all nodes, textual and otherwise, in an HTML document.\n  class Node #:nodoc:\n    # The array of children of this node. Not all nodes have children.\n    attr_reader :children\n    \n    # The parent node of this node. All nodes have a parent, except for the\n    # root node.\n    attr_reader :parent\n    \n    # The line number of the input where this node was begun\n    attr_reader :line\n    \n    # The byte position in the input where this node was begun\n    attr_reader :position\n    \n    # Create a new node as a child of the given parent.\n    def initialize(parent, line=0, pos=0)\n      @parent = parent\n      @children = []\n      @line, @position = line, pos\n    end\n\n    # Return a textual representation of the node.\n    def to_s\n      s = \"\"\n      @children.each { |child| s << child.to_s }\n      s\n    end\n\n    # Return false (subclasses must override this to provide specific matching\n    # behavior.) +conditions+ may be of any type.\n    def match(conditions)\n      false\n    end\n\n    # Search the children of this node for the first node for which #find\n    # returns non +nil+. Returns the result of the #find call that succeeded.\n    def find(conditions)\n      conditions = validate_conditions(conditions)\n      @children.each do |child|        \n        node = child.find(conditions)\n        return node if node\n      end\n      nil\n    end\n\n    # Search for all nodes that match the given conditions, and return them\n    # as an array.\n    def find_all(conditions)\n      conditions = validate_conditions(conditions)\n\n      matches = []\n      matches << self if match(conditions)\n      @children.each do |child|\n        matches.concat child.find_all(conditions)\n      end\n      matches\n    end\n\n    # Returns +false+. Subclasses may override this if they define a kind of\n    # tag.\n    def tag?\n      false\n    end\n\n    def validate_conditions(conditions)\n      Conditions === conditions ? conditions : Conditions.new(conditions)\n    end\n\n    def ==(node)\n      return false unless self.class == node.class && children.size == node.children.size\n\n      equivalent = true\n\n      children.size.times do |i|\n        equivalent &&= children[i] == node.children[i]\n      end\n\n      equivalent\n    end\n    \n    class <<self\n      def parse(parent, line, pos, content, strict=true)\n        if content !~ /^<\\S/\n          Text.new(parent, line, pos, content)\n        else\n          scanner = StringScanner.new(content)\n\n          unless scanner.skip(/</)\n            if strict\n              raise \"expected <\"\n            else\n              return Text.new(parent, line, pos, content)\n            end\n          end\n\n          if scanner.skip(/!\\[CDATA\\[/)\n            unless scanner.skip_until(/\\]\\]>/)\n              if strict\n                raise \"expected ]]> (got #{scanner.rest.inspect} for #{content})\"\n              else\n                scanner.skip_until(/\\Z/)\n              end\n            end\n\n            return CDATA.new(parent, line, pos, scanner.pre_match.gsub(/<!\\[CDATA\\[/, ''))\n          end\n          \n          closing = ( scanner.scan(/\\//) ? :close : nil )\n          return Text.new(parent, line, pos, content) unless name = scanner.scan(/[\\w:-]+/)\n          name.downcase!\n  \n          unless closing\n            scanner.skip(/\\s*/)\n            attributes = {}\n            while attr = scanner.scan(/[-\\w:]+/)\n              value = true\n              if scanner.scan(/\\s*=\\s*/)\n                if delim = scanner.scan(/['\"]/)\n                  value = \"\"\n                  while text = scanner.scan(/[^#{delim}\\\\]+|./)\n                    case text\n                      when \"\\\\\" then\n                        value << text\n                        value << scanner.getch\n                      when delim\n                        break\n                      else value << text\n                    end\n                  end\n                else\n                  value = scanner.scan(/[^\\s>\\/]+/)\n                end\n              end\n              attributes[attr.downcase] = value\n              scanner.skip(/\\s*/)\n            end\n    \n            closing = ( scanner.scan(/\\//) ? :self : nil )\n          end\n          \n          unless scanner.scan(/\\s*>/)\n            if strict\n              raise \"expected > (got #{scanner.rest.inspect} for #{content}, #{attributes.inspect})\" \n            else\n              # throw away all text until we find what we're looking for\n              scanner.skip_until(/>/) or scanner.terminate\n            end\n          end\n\n          Tag.new(parent, line, pos, name, attributes, closing)\n        end\n      end\n    end\n  end\n\n  # A node that represents text, rather than markup.\n  class Text < Node #:nodoc:\n    \n    attr_reader :content\n    \n    # Creates a new text node as a child of the given parent, with the given\n    # content.\n    def initialize(parent, line, pos, content)\n      super(parent, line, pos)\n      @content = content\n    end\n\n    # Returns the content of this node.\n    def to_s\n      @content\n    end\n\n    # Returns +self+ if this node meets the given conditions. Text nodes support\n    # conditions of the following kinds:\n    #\n    # * if +conditions+ is a string, it must be a substring of the node's\n    #   content\n    # * if +conditions+ is a regular expression, it must match the node's\n    #   content\n    # * if +conditions+ is a hash, it must contain a <tt>:content</tt> key that\n    #   is either a string or a regexp, and which is interpreted as described\n    #   above.\n    def find(conditions)\n      match(conditions) && self\n    end\n    \n    # Returns non-+nil+ if this node meets the given conditions, or +nil+\n    # otherwise. See the discussion of #find for the valid conditions.\n    def match(conditions)\n      case conditions\n        when String\n          @content == conditions\n        when Regexp\n          @content =~ conditions\n        when Hash\n          conditions = validate_conditions(conditions)\n\n          # Text nodes only have :content, :parent, :ancestor\n          unless (conditions.keys - [:content, :parent, :ancestor]).empty?\n            return false\n          end\n\n          match(conditions[:content])\n        else\n          nil\n      end\n    end\n\n    def ==(node)\n      return false unless super\n      content == node.content\n    end\n  end\n  \n  # A CDATA node is simply a text node with a specialized way of displaying\n  # itself.\n  class CDATA < Text #:nodoc:\n    def to_s\n      \"<![CDATA[#{super}]]>\"\n    end\n  end\n\n  # A Tag is any node that represents markup. It may be an opening tag, a\n  # closing tag, or a self-closing tag. It has a name, and may have a hash of\n  # attributes.\n  class Tag < Node #:nodoc:\n    \n    # Either +nil+, <tt>:close</tt>, or <tt>:self</tt>\n    attr_reader :closing\n    \n    # Either +nil+, or a hash of attributes for this node.\n    attr_reader :attributes\n\n    # The name of this tag.\n    attr_reader :name\n        \n    # Create a new node as a child of the given parent, using the given content\n    # to describe the node. It will be parsed and the node name, attributes and\n    # closing status extracted.\n    def initialize(parent, line, pos, name, attributes, closing)\n      super(parent, line, pos)\n      @name = name\n      @attributes = attributes\n      @closing = closing\n    end\n\n    # A convenience for obtaining an attribute of the node. Returns +nil+ if\n    # the node has no attributes.\n    def [](attr)\n      @attributes ? @attributes[attr] : nil\n    end\n\n    # Returns non-+nil+ if this tag can contain child nodes.\n    def childless?(xml = false)\n      return false if xml && @closing.nil?\n      !@closing.nil? ||\n        @name =~ /^(img|br|hr|link|meta|area|base|basefont|\n                    col|frame|input|isindex|param)$/ox\n    end\n\n    # Returns a textual representation of the node\n    def to_s\n      if @closing == :close\n        \"</#{@name}>\"\n      else\n        s = \"<#{@name}\"\n        @attributes.each do |k,v|\n          s << \" #{k}\"\n          s << \"=\\\"#{v}\\\"\" if String === v\n        end\n        s << \" /\" if @closing == :self\n        s << \">\"\n        @children.each { |child| s << child.to_s }\n        s << \"</#{@name}>\" if @closing != :self && !@children.empty?\n        s\n      end\n    end\n\n    # If either the node or any of its children meet the given conditions, the\n    # matching node is returned. Otherwise, +nil+ is returned. (See the\n    # description of the valid conditions in the +match+ method.)\n    def find(conditions)\n      match(conditions) && self || super\n    end\n\n    # Returns +true+, indicating that this node represents an HTML tag.\n    def tag?\n      true\n    end\n    \n    # Returns +true+ if the node meets any of the given conditions. The\n    # +conditions+ parameter must be a hash of any of the following keys\n    # (all are optional):\n    #\n    # * <tt>:tag</tt>: the node name must match the corresponding value\n    # * <tt>:attributes</tt>: a hash. The node's values must match the\n    #   corresponding values in the hash.\n    # * <tt>:parent</tt>: a hash. The node's parent must match the\n    #   corresponding hash.\n    # * <tt>:child</tt>: a hash. At least one of the node's immediate children\n    #   must meet the criteria described by the hash.\n    # * <tt>:ancestor</tt>: a hash. At least one of the node's ancestors must\n    #   meet the criteria described by the hash.\n    # * <tt>:descendant</tt>: a hash. At least one of the node's descendants\n    #   must meet the criteria described by the hash.\n    # * <tt>:sibling</tt>: a hash. At least one of the node's siblings must\n    #   meet the criteria described by the hash.\n    # * <tt>:after</tt>: a hash. The node must be after any sibling meeting\n    #   the criteria described by the hash, and at least one sibling must match.\n    # * <tt>:before</tt>: a hash. The node must be before any sibling meeting\n    #   the criteria described by the hash, and at least one sibling must match.\n    # * <tt>:children</tt>: a hash, for counting children of a node. Accepts the\n    #   keys:\n    # ** <tt>:count</tt>: either a number or a range which must equal (or\n    #    include) the number of children that match.\n    # ** <tt>:less_than</tt>: the number of matching children must be less than\n    #    this number.\n    # ** <tt>:greater_than</tt>: the number of matching children must be\n    #    greater than this number.\n    # ** <tt>:only</tt>: another hash consisting of the keys to use\n    #    to match on the children, and only matching children will be\n    #    counted.\n    #\n    # Conditions are matched using the following algorithm:\n    #\n    # * if the condition is a string, it must be a substring of the value.\n    # * if the condition is a regexp, it must match the value.\n    # * if the condition is a number, the value must match number.to_s.\n    # * if the condition is +true+, the value must not be +nil+.\n    # * if the condition is +false+ or +nil+, the value must be +nil+.\n    #\n    # Usage:\n    #\n    #   # test if the node is a \"span\" tag\n    #   node.match :tag => \"span\"\n    #\n    #   # test if the node's parent is a \"div\"\n    #   node.match :parent => { :tag => \"div\" }\n    #\n    #   # test if any of the node's ancestors are \"table\" tags\n    #   node.match :ancestor => { :tag => \"table\" }\n    #\n    #   # test if any of the node's immediate children are \"em\" tags\n    #   node.match :child => { :tag => \"em\" }\n    #\n    #   # test if any of the node's descendants are \"strong\" tags\n    #   node.match :descendant => { :tag => \"strong\" }\n    #\n    #   # test if the node has between 2 and 4 span tags as immediate children\n    #   node.match :children => { :count => 2..4, :only => { :tag => \"span\" } } \n    #\n    #   # get funky: test to see if the node is a \"div\", has a \"ul\" ancestor\n    #   # and an \"li\" parent (with \"class\" = \"enum\"), and whether or not it has\n    #   # a \"span\" descendant that contains # text matching /hello world/:\n    #   node.match :tag => \"div\",\n    #              :ancestor => { :tag => \"ul\" },\n    #              :parent => { :tag => \"li\",\n    #                           :attributes => { :class => \"enum\" } },\n    #              :descendant => { :tag => \"span\",\n    #                               :child => /hello world/ }\n    def match(conditions)\n      conditions = validate_conditions(conditions)\n      # check content of child nodes\n      if conditions[:content]\n        if children.empty?\n          return false unless match_condition(\"\", conditions[:content])\n        else\n          return false unless children.find { |child| child.match(conditions[:content]) }\n        end\n      end\n\n      # test the name\n      return false unless match_condition(@name, conditions[:tag]) if conditions[:tag]\n\n      # test attributes\n      (conditions[:attributes] || {}).each do |key, value|\n        return false unless match_condition(self[key], value)\n      end\n\n      # test parent\n      return false unless parent.match(conditions[:parent]) if conditions[:parent]\n\n      # test children\n      return false unless children.find { |child| child.match(conditions[:child]) } if conditions[:child]\n   \n      # test ancestors\n      if conditions[:ancestor]\n        return false unless catch :found do\n          p = self\n          throw :found, true if p.match(conditions[:ancestor]) while p = p.parent\n        end\n      end\n\n      # test descendants\n      if conditions[:descendant]\n        return false unless children.find do |child|\n          # test the child\n          child.match(conditions[:descendant]) ||\n          # test the child's descendants\n          child.match(:descendant => conditions[:descendant])\n        end\n      end\n      \n      # count children\n      if opts = conditions[:children]\n        matches = children.select do |c|\n          (c.kind_of?(HTML::Tag) and (c.closing == :self or ! c.childless?))\n        end\n        \n        matches = matches.select { |c| c.match(opts[:only]) } if opts[:only]\n        opts.each do |key, value|\n          next if key == :only\n          case key\n            when :count\n              if Integer === value\n                return false if matches.length != value\n              else\n                return false unless value.include?(matches.length)\n              end\n            when :less_than\n              return false unless matches.length < value\n            when :greater_than\n              return false unless matches.length > value\n            else raise \"unknown count condition #{key}\"\n          end\n        end\n      end\n\n      # test siblings\n      if conditions[:sibling] || conditions[:before] || conditions[:after]\n        siblings = parent ? parent.children : []\n        self_index = siblings.index(self)\n\n        if conditions[:sibling]\n          return false unless siblings.detect do |s| \n            s != self && s.match(conditions[:sibling])\n          end\n        end\n\n        if conditions[:before]\n          return false unless siblings[self_index+1..-1].detect do |s| \n            s != self && s.match(conditions[:before])\n          end\n        end\n\n        if conditions[:after]\n          return false unless siblings[0,self_index].detect do |s| \n            s != self && s.match(conditions[:after])\n          end\n        end\n      end\n  \n      true\n    end\n\n    def ==(node)\n      return false unless super\n      return false unless closing == node.closing && self.name == node.name\n      attributes == node.attributes\n    end\n    \n    private\n      # Match the given value to the given condition.\n      def match_condition(value, condition)\n        case condition\n          when String\n            value && value == condition\n          when Regexp\n            value && value.match(condition)\n          when Numeric\n            value == condition.to_s\n          when true\n            !value.nil?\n          when false, nil\n            value.nil?\n          else\n            false\n        end\n      end\n  end\nend\n", "require 'abstract_unit'\n\nclass SanitizerTest < ActionController::TestCase\n  def setup\n    @sanitizer = nil # used by assert_sanitizer\n  end\n\n  def test_strip_tags\n    sanitizer = HTML::FullSanitizer.new\n    assert_equal(\"<<<bad html\", sanitizer.sanitize(\"<<<bad html\"))\n    assert_equal(\"<<\", sanitizer.sanitize(\"<<<bad html>\"))\n    assert_equal(\"Dont touch me\", sanitizer.sanitize(\"Dont touch me\"))\n    assert_equal(\"This is a test.\", sanitizer.sanitize(\"<p>This <u>is<u> a <a href='test.html'><strong>test</strong></a>.</p>\"))\n    assert_equal(\"Weirdos\", sanitizer.sanitize(\"Wei<<a>a onclick='alert(document.cookie);'</a>/>rdos\"))\n    assert_equal(\"This is a test.\", sanitizer.sanitize(\"This is a test.\"))\n    assert_equal(\n    %{This is a test.\\n\\n\\nIt no longer contains any HTML.\\n}, sanitizer.sanitize(\n    %{<title>This is <b>a <a href=\"\" target=\"_blank\">test</a></b>.</title>\\n\\n<!-- it has a comment -->\\n\\n<p>It no <b>longer <strong>contains <em>any <strike>HTML</strike></em>.</strong></b></p>\\n}))\n    assert_equal \"This has a  here.\", sanitizer.sanitize(\"This has a <!-- comment --> here.\")\n    assert_equal \"This has a  here.\", sanitizer.sanitize(\"This has a <![CDATA[<section>]]> here.\")\n    assert_equal \"This has an unclosed \", sanitizer.sanitize(\"This has an unclosed <![CDATA[<section>]] here...\")\n    [nil, '', '   '].each { |blank| assert_equal blank, sanitizer.sanitize(blank) }\n  end\n\n  def test_strip_links\n    sanitizer = HTML::LinkSanitizer.new\n    assert_equal \"Dont touch me\", sanitizer.sanitize(\"Dont touch me\")    \n    assert_equal \"on my mind\\nall day long\", sanitizer.sanitize(\"<a href='almost'>on my mind</a>\\n<A href='almost'>all day long</A>\")\n    assert_equal \"0wn3d\", sanitizer.sanitize(\"<a href='http://www.rubyonrails.com/'><a href='http://www.rubyonrails.com/' onlclick='steal()'>0wn3d</a></a>\") \n    assert_equal \"Magic\", sanitizer.sanitize(\"<a href='http://www.rubyonrails.com/'>Mag<a href='http://www.ruby-lang.org/'>ic\") \n    assert_equal \"FrrFox\", sanitizer.sanitize(\"<href onlclick='steal()'>FrrFox</a></href>\") \n    assert_equal \"My mind\\nall <b>day</b> long\", sanitizer.sanitize(\"<a href='almost'>My mind</a>\\n<A href='almost'>all <b>day</b> long</A>\")\n    assert_equal \"all <b>day</b> long\", sanitizer.sanitize(\"<<a>a href='hello'>all <b>day</b> long<</A>/a>\")\n\n    assert_equal \"<a<a\", sanitizer.sanitize(\"<a<a\")\n  end\n\n  def test_sanitize_form\n    assert_sanitized \"<form action=\\\"/foo/bar\\\" method=\\\"post\\\"><input></form>\", ''\n  end\n\n  def test_sanitize_plaintext\n    raw = \"<plaintext><span>foo</span></plaintext>\"\n    assert_sanitized raw, \"<span>foo</span>\"\n  end\n\n  def test_sanitize_script\n    assert_sanitized \"a b c<script language=\\\"Javascript\\\">blah blah blah</script>d e f\", \"a b cd e f\"\n  end\n\n  # fucked\n  def test_sanitize_js_handlers\n    raw = %{onthis=\"do that\" <a href=\"#\" onclick=\"hello\" name=\"foo\" onbogus=\"remove me\">hello</a>}\n    assert_sanitized raw, %{onthis=\"do that\" <a name=\"foo\" href=\"#\">hello</a>}\n  end\n\n  def test_sanitize_javascript_href\n    raw = %{href=\"javascript:bang\" <a href=\"javascript:bang\" name=\"hello\">foo</a>, <span href=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{href=\"javascript:bang\" <a name=\"hello\">foo</a>, <span>bar</span>}\n  end\n  \n  def test_sanitize_image_src\n    raw = %{src=\"javascript:bang\" <img src=\"javascript:bang\" width=\"5\">foo</img>, <span src=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{src=\"javascript:bang\" <img width=\"5\">foo</img>, <span>bar</span>}\n  end\n\n  HTML::WhiteListSanitizer.allowed_tags.each do |tag_name|\n    define_method \"test_should_allow_#{tag_name}_tag\" do\n      assert_sanitized \"start <#{tag_name} title=\\\"1\\\" onclick=\\\"foo\\\">foo <bad>bar</bad> baz</#{tag_name}> end\", %(start <#{tag_name} title=\"1\">foo bar baz</#{tag_name}> end)\n    end\n  end\n\n  def test_should_allow_anchors\n    assert_sanitized %(<a href=\"foo\" onclick=\"bar\"><script>baz</script></a>), %(<a href=\"foo\"></a>)\n  end\n\n  # RFC 3986, sec 4.2\n  def test_allow_colons_in_path_component\n    assert_sanitized(\"<a href=\\\"./this:that\\\">foo</a>\")\n  end\n\n  %w(src width height alt).each do |img_attr|\n    define_method \"test_should_allow_image_#{img_attr}_attribute\" do\n      assert_sanitized %(<img #{img_attr}=\"foo\" onclick=\"bar\" />), %(<img #{img_attr}=\"foo\" />)\n    end\n  end\n\n  def test_should_handle_non_html\n    assert_sanitized 'abc'\n  end\n\n  def test_should_handle_blank_text\n    assert_sanitized nil\n    assert_sanitized ''\n  end\n\n  def test_should_allow_custom_tags\n    text = \"<u>foo</u>\"\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(text, sanitizer.sanitize(text, :tags => %w(u)))\n  end\n\n  def test_should_allow_only_custom_tags\n    text = \"<u>foo</u> with <i>bar</i>\"\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(\"<u>foo</u> with bar\", sanitizer.sanitize(text, :tags => %w(u)))\n  end\n\n  def test_should_allow_custom_tags_with_attributes\n    text = %(<blockquote cite=\"http://example.com/\">foo</blockquote>)\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(text, sanitizer.sanitize(text))\n  end\n\n  def test_should_allow_custom_tags_with_custom_attributes\n    text = %(<blockquote foo=\"bar\">Lorem ipsum</blockquote>)\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(text, sanitizer.sanitize(text, :attributes => ['foo']))\n  end\n\n  [%w(img src), %w(a href)].each do |(tag, attr)|\n    define_method \"test_should_strip_#{attr}_attribute_in_#{tag}_with_bad_protocols\" do\n      assert_sanitized %(<#{tag} #{attr}=\"javascript:bang\" title=\"1\">boo</#{tag}>), %(<#{tag} title=\"1\">boo</#{tag}>)\n    end\n  end\n\n  def test_should_flag_bad_protocols\n    sanitizer = HTML::WhiteListSanitizer.new\n    %w(about chrome data disk hcp help javascript livescript lynxcgi lynxexec ms-help ms-its mhtml mocha opera res resource shell vbscript view-source vnd.ms.radio wysiwyg).each do |proto|\n      assert sanitizer.send(:contains_bad_protocols?, 'src', \"#{proto}://bad\")\n    end\n  end\n\n  def test_should_accept_good_protocols\n    sanitizer = HTML::WhiteListSanitizer.new\n    HTML::WhiteListSanitizer.allowed_protocols.each do |proto|\n      assert !sanitizer.send(:contains_bad_protocols?, 'src', \"#{proto}://good\")\n    end\n  end\n\n  def test_should_reject_hex_codes_in_protocol\n    assert_sanitized %(<a href=\"&#37;6A&#37;61&#37;76&#37;61&#37;73&#37;63&#37;72&#37;69&#37;70&#37;74&#37;3A&#37;61&#37;6C&#37;65&#37;72&#37;74&#37;28&#37;22&#37;58&#37;53&#37;53&#37;22&#37;29\">1</a>), \"<a>1</a>\"\n    assert @sanitizer.send(:contains_bad_protocols?, 'src', \"%6A%61%76%61%73%63%72%69%70%74%3A%61%6C%65%72%74%28%22%58%53%53%22%29\")\n  end\n\n  def test_should_block_script_tag\n    assert_sanitized %(<SCRIPT\\nSRC=http://ha.ckers.org/xss.js></SCRIPT>), \"\"\n  end\n\n  [%(<IMG SRC=\"javascript:alert('XSS');\">), \n   %(<IMG SRC=javascript:alert('XSS')>), \n   %(<IMG SRC=JaVaScRiPt:alert('XSS')>), \n   %(<IMG \"\"\"><SCRIPT>alert(\"XSS\")</SCRIPT>\">),\n   %(<IMG SRC=javascript:alert(&quot;XSS&quot;)>),\n   %(<IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>),\n   %(<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>),\n   %(<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>),\n   %(<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>),\n   %(<IMG SRC=\"jav\\tascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x09;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0A;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0D;ascript:alert('XSS');\">),\n   %(<IMG SRC=\" &#14;  javascript:alert('XSS');\">),\n   %(<IMG SRC=`javascript:alert(\"RSnake says, 'XSS'\")`>)].each_with_index do |img_hack, i|\n    define_method \"test_should_not_fall_for_xss_image_hack_#{i+1}\" do\n      assert_sanitized img_hack, \"<img>\"\n    end\n  end\n  \n  def test_should_sanitize_tag_broken_up_by_null\n    assert_sanitized %(<SCR\\0IPT>alert(\\\"XSS\\\")</SCR\\0IPT>), \"alert(\\\"XSS\\\")\"\n  end\n  \n  def test_should_sanitize_invalid_script_tag\n    assert_sanitized %(<SCRIPT/XSS SRC=\"http://ha.ckers.org/xss.js\"></SCRIPT>), \"\"\n  end\n  \n  def test_should_sanitize_script_tag_with_multiple_open_brackets\n    assert_sanitized %(<<SCRIPT>alert(\"XSS\");//<</SCRIPT>), \"&lt;\"\n    assert_sanitized %(<iframe src=http://ha.ckers.org/scriptlet.html\\n<a), %(&lt;a)\n  end\n  \n  def test_should_sanitize_unclosed_script\n    assert_sanitized %(<SCRIPT SRC=http://ha.ckers.org/xss.js?<B>), \"<b>\"\n  end\n  \n  def test_should_sanitize_half_open_scripts\n    assert_sanitized %(<IMG SRC=\"javascript:alert('XSS')\"), \"<img>\"\n  end\n  \n  def test_should_not_fall_for_ridiculous_hack\n    img_hack = %(<IMG\\nSRC\\n=\\n\"\\nj\\na\\nv\\na\\ns\\nc\\nr\\ni\\np\\nt\\n:\\na\\nl\\ne\\nr\\nt\\n(\\n'\\nX\\nS\\nS\\n'\\n)\\n\"\\n>)\n    assert_sanitized img_hack, \"<img>\"\n  end\n\n  # fucked\n  def test_should_sanitize_attributes\n    assert_sanitized %(<SPAN title=\"'><script>alert()</script>\">blah</SPAN>), %(<span title=\"'&gt;&lt;script&gt;alert()&lt;/script&gt;\">blah</span>)\n  end\n\n  def test_should_sanitize_illegal_style_properties\n    raw      = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;)\n    expected = %(display: block; width: 100%; height: 100%; background-color: black; background-image: ; background-x: center; background-y: center;)\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_with_trailing_space\n    raw = \"display:block; \"\n    expected = \"display: block;\"\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_xul_style_attributes\n    raw = %(-moz-binding:url('http://ha.ckers.org/xssmoz.xml#xss'))\n    assert_equal '', sanitize_css(raw)\n  end\n  \n  def test_should_sanitize_invalid_tag_names\n    assert_sanitized(%(a b c<script/XSS src=\"http://ha.ckers.org/xss.js\"></script>d e f), \"a b cd e f\")\n  end\n  \n  def test_should_sanitize_non_alpha_and_non_digit_characters_in_tags\n    assert_sanitized('<a onclick!#$%&()*~+-_.,:;?@[/|\\]^`=alert(\"XSS\")>foo</a>', \"<a>foo</a>\")\n  end\n  \n  def test_should_sanitize_invalid_tag_names_in_single_tags\n    assert_sanitized('<img/src=\"http://ha.ckers.org/xss.js\"/>', \"<img />\")\n  end\n\n  def test_should_sanitize_img_dynsrc_lowsrc\n    assert_sanitized(%(<img lowsrc=\"javascript:alert('XSS')\" />), \"<img />\")\n  end\n\n  def test_should_sanitize_div_background_image_unicode_encoded\n    raw = %(background-image:\\0075\\0072\\006C\\0028'\\006a\\0061\\0076\\0061\\0073\\0063\\0072\\0069\\0070\\0074\\003a\\0061\\006c\\0065\\0072\\0074\\0028.1027\\0058.1053\\0053\\0027\\0029'\\0029)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_div_style_expression\n    raw = %(width: expression(alert('XSS'));)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_img_vbscript\n    assert_sanitized %(<img src='vbscript:msgbox(\"XSS\")' />), '<img />'\n  end\n\n  def test_should_sanitize_cdata_section\n    assert_sanitized \"<![CDATA[<span>section</span>]]>\", \"&lt;![CDATA[&lt;span>section&lt;/span>]]>\"\n  end\n\n  def test_should_sanitize_unterminated_cdata_section\n    assert_sanitized \"<![CDATA[<span>neverending...\", \"&lt;![CDATA[&lt;span>neverending...]]>\"\n  end\n\n  def test_should_not_mangle_urls_with_ampersand\n     assert_sanitized %{<a href=\\\"http://www.domain.com?var1=1&amp;var2=2\\\">my link</a>}\n  end\n\nprotected\n  def assert_sanitized(input, expected = nil)\n    @sanitizer ||= HTML::WhiteListSanitizer.new\n    if input\n      assert_dom_equal expected || input, @sanitizer.sanitize(input)\n    else\n      assert_nil @sanitizer.sanitize(input)\n    end\n  end\n\n  def sanitize_css(input)\n    (@sanitizer ||= HTML::WhiteListSanitizer.new).sanitize_css(input)\n  end\nend\n"], "fixing_code": ["require 'strscan'\n\nmodule HTML #:nodoc:\n  \n  class Conditions < Hash #:nodoc:\n    def initialize(hash)\n      super()\n      hash = { :content => hash } unless Hash === hash\n      hash = keys_to_symbols(hash)\n      hash.each do |k,v|\n        case k\n          when :tag, :content then\n            # keys are valid, and require no further processing\n          when :attributes then\n            hash[k] = keys_to_strings(v)\n          when :parent, :child, :ancestor, :descendant, :sibling, :before,\n                  :after\n            hash[k] = Conditions.new(v)\n          when :children\n            hash[k] = v = keys_to_symbols(v)\n            v.each do |k,v2|\n              case k\n                when :count, :greater_than, :less_than\n                  # keys are valid, and require no further processing\n                when :only\n                  v[k] = Conditions.new(v2)\n                else\n                  raise \"illegal key #{k.inspect} => #{v2.inspect}\"\n              end\n            end\n          else\n            raise \"illegal key #{k.inspect} => #{v.inspect}\"\n        end\n      end\n      update hash\n    end\n\n    private\n\n      def keys_to_strings(hash)\n        hash.keys.inject({}) do |h,k|\n          h[k.to_s] = hash[k]\n          h\n        end\n      end\n\n      def keys_to_symbols(hash)\n        hash.keys.inject({}) do |h,k|\n          raise \"illegal key #{k.inspect}\" unless k.respond_to?(:to_sym)\n          h[k.to_sym] = hash[k]\n          h\n        end\n      end\n  end\n\n  # The base class of all nodes, textual and otherwise, in an HTML document.\n  class Node #:nodoc:\n    # The array of children of this node. Not all nodes have children.\n    attr_reader :children\n    \n    # The parent node of this node. All nodes have a parent, except for the\n    # root node.\n    attr_reader :parent\n    \n    # The line number of the input where this node was begun\n    attr_reader :line\n    \n    # The byte position in the input where this node was begun\n    attr_reader :position\n    \n    # Create a new node as a child of the given parent.\n    def initialize(parent, line=0, pos=0)\n      @parent = parent\n      @children = []\n      @line, @position = line, pos\n    end\n\n    # Return a textual representation of the node.\n    def to_s\n      s = \"\"\n      @children.each { |child| s << child.to_s }\n      s\n    end\n\n    # Return false (subclasses must override this to provide specific matching\n    # behavior.) +conditions+ may be of any type.\n    def match(conditions)\n      false\n    end\n\n    # Search the children of this node for the first node for which #find\n    # returns non +nil+. Returns the result of the #find call that succeeded.\n    def find(conditions)\n      conditions = validate_conditions(conditions)\n      @children.each do |child|        \n        node = child.find(conditions)\n        return node if node\n      end\n      nil\n    end\n\n    # Search for all nodes that match the given conditions, and return them\n    # as an array.\n    def find_all(conditions)\n      conditions = validate_conditions(conditions)\n\n      matches = []\n      matches << self if match(conditions)\n      @children.each do |child|\n        matches.concat child.find_all(conditions)\n      end\n      matches\n    end\n\n    # Returns +false+. Subclasses may override this if they define a kind of\n    # tag.\n    def tag?\n      false\n    end\n\n    def validate_conditions(conditions)\n      Conditions === conditions ? conditions : Conditions.new(conditions)\n    end\n\n    def ==(node)\n      return false unless self.class == node.class && children.size == node.children.size\n\n      equivalent = true\n\n      children.size.times do |i|\n        equivalent &&= children[i] == node.children[i]\n      end\n\n      equivalent\n    end\n    \n    class <<self\n      def parse(parent, line, pos, content, strict=true)\n        if content !~ /^<\\S/\n          Text.new(parent, line, pos, content)\n        else\n          scanner = StringScanner.new(content)\n\n          unless scanner.skip(/</)\n            if strict\n              raise \"expected <\"\n            else\n              return Text.new(parent, line, pos, content)\n            end\n          end\n\n          if scanner.skip(/!\\[CDATA\\[/)\n            unless scanner.skip_until(/\\]\\]>/)\n              if strict\n                raise \"expected ]]> (got #{scanner.rest.inspect} for #{content})\"\n              else\n                scanner.skip_until(/\\Z/)\n              end\n            end\n\n            return CDATA.new(parent, line, pos, scanner.pre_match.gsub(/<!\\[CDATA\\[/, ''))\n          end\n          \n          closing = ( scanner.scan(/\\//) ? :close : nil )\n          return Text.new(parent, line, pos, content) unless name = scanner.scan(/[-:\\w\\x00-\\x09\\x0b-\\x0c\\x0e-\\x1f]+/)\n          name.downcase!\n  \n          unless closing\n            scanner.skip(/\\s*/)\n            attributes = {}\n            while attr = scanner.scan(/[-\\w:]+/)\n              value = true\n              if scanner.scan(/\\s*=\\s*/)\n                if delim = scanner.scan(/['\"]/)\n                  value = \"\"\n                  while text = scanner.scan(/[^#{delim}\\\\]+|./)\n                    case text\n                      when \"\\\\\" then\n                        value << text\n                        value << scanner.getch\n                      when delim\n                        break\n                      else value << text\n                    end\n                  end\n                else\n                  value = scanner.scan(/[^\\s>\\/]+/)\n                end\n              end\n              attributes[attr.downcase] = value\n              scanner.skip(/\\s*/)\n            end\n    \n            closing = ( scanner.scan(/\\//) ? :self : nil )\n          end\n          \n          unless scanner.scan(/\\s*>/)\n            if strict\n              raise \"expected > (got #{scanner.rest.inspect} for #{content}, #{attributes.inspect})\" \n            else\n              # throw away all text until we find what we're looking for\n              scanner.skip_until(/>/) or scanner.terminate\n            end\n          end\n\n          Tag.new(parent, line, pos, name, attributes, closing)\n        end\n      end\n    end\n  end\n\n  # A node that represents text, rather than markup.\n  class Text < Node #:nodoc:\n    \n    attr_reader :content\n    \n    # Creates a new text node as a child of the given parent, with the given\n    # content.\n    def initialize(parent, line, pos, content)\n      super(parent, line, pos)\n      @content = content\n    end\n\n    # Returns the content of this node.\n    def to_s\n      @content\n    end\n\n    # Returns +self+ if this node meets the given conditions. Text nodes support\n    # conditions of the following kinds:\n    #\n    # * if +conditions+ is a string, it must be a substring of the node's\n    #   content\n    # * if +conditions+ is a regular expression, it must match the node's\n    #   content\n    # * if +conditions+ is a hash, it must contain a <tt>:content</tt> key that\n    #   is either a string or a regexp, and which is interpreted as described\n    #   above.\n    def find(conditions)\n      match(conditions) && self\n    end\n    \n    # Returns non-+nil+ if this node meets the given conditions, or +nil+\n    # otherwise. See the discussion of #find for the valid conditions.\n    def match(conditions)\n      case conditions\n        when String\n          @content == conditions\n        when Regexp\n          @content =~ conditions\n        when Hash\n          conditions = validate_conditions(conditions)\n\n          # Text nodes only have :content, :parent, :ancestor\n          unless (conditions.keys - [:content, :parent, :ancestor]).empty?\n            return false\n          end\n\n          match(conditions[:content])\n        else\n          nil\n      end\n    end\n\n    def ==(node)\n      return false unless super\n      content == node.content\n    end\n  end\n  \n  # A CDATA node is simply a text node with a specialized way of displaying\n  # itself.\n  class CDATA < Text #:nodoc:\n    def to_s\n      \"<![CDATA[#{super}]]>\"\n    end\n  end\n\n  # A Tag is any node that represents markup. It may be an opening tag, a\n  # closing tag, or a self-closing tag. It has a name, and may have a hash of\n  # attributes.\n  class Tag < Node #:nodoc:\n    \n    # Either +nil+, <tt>:close</tt>, or <tt>:self</tt>\n    attr_reader :closing\n    \n    # Either +nil+, or a hash of attributes for this node.\n    attr_reader :attributes\n\n    # The name of this tag.\n    attr_reader :name\n        \n    # Create a new node as a child of the given parent, using the given content\n    # to describe the node. It will be parsed and the node name, attributes and\n    # closing status extracted.\n    def initialize(parent, line, pos, name, attributes, closing)\n      super(parent, line, pos)\n      @name = name\n      @attributes = attributes\n      @closing = closing\n    end\n\n    # A convenience for obtaining an attribute of the node. Returns +nil+ if\n    # the node has no attributes.\n    def [](attr)\n      @attributes ? @attributes[attr] : nil\n    end\n\n    # Returns non-+nil+ if this tag can contain child nodes.\n    def childless?(xml = false)\n      return false if xml && @closing.nil?\n      !@closing.nil? ||\n        @name =~ /^(img|br|hr|link|meta|area|base|basefont|\n                    col|frame|input|isindex|param)$/ox\n    end\n\n    # Returns a textual representation of the node\n    def to_s\n      if @closing == :close\n        \"</#{@name}>\"\n      else\n        s = \"<#{@name}\"\n        @attributes.each do |k,v|\n          s << \" #{k}\"\n          s << \"=\\\"#{v}\\\"\" if String === v\n        end\n        s << \" /\" if @closing == :self\n        s << \">\"\n        @children.each { |child| s << child.to_s }\n        s << \"</#{@name}>\" if @closing != :self && !@children.empty?\n        s\n      end\n    end\n\n    # If either the node or any of its children meet the given conditions, the\n    # matching node is returned. Otherwise, +nil+ is returned. (See the\n    # description of the valid conditions in the +match+ method.)\n    def find(conditions)\n      match(conditions) && self || super\n    end\n\n    # Returns +true+, indicating that this node represents an HTML tag.\n    def tag?\n      true\n    end\n    \n    # Returns +true+ if the node meets any of the given conditions. The\n    # +conditions+ parameter must be a hash of any of the following keys\n    # (all are optional):\n    #\n    # * <tt>:tag</tt>: the node name must match the corresponding value\n    # * <tt>:attributes</tt>: a hash. The node's values must match the\n    #   corresponding values in the hash.\n    # * <tt>:parent</tt>: a hash. The node's parent must match the\n    #   corresponding hash.\n    # * <tt>:child</tt>: a hash. At least one of the node's immediate children\n    #   must meet the criteria described by the hash.\n    # * <tt>:ancestor</tt>: a hash. At least one of the node's ancestors must\n    #   meet the criteria described by the hash.\n    # * <tt>:descendant</tt>: a hash. At least one of the node's descendants\n    #   must meet the criteria described by the hash.\n    # * <tt>:sibling</tt>: a hash. At least one of the node's siblings must\n    #   meet the criteria described by the hash.\n    # * <tt>:after</tt>: a hash. The node must be after any sibling meeting\n    #   the criteria described by the hash, and at least one sibling must match.\n    # * <tt>:before</tt>: a hash. The node must be before any sibling meeting\n    #   the criteria described by the hash, and at least one sibling must match.\n    # * <tt>:children</tt>: a hash, for counting children of a node. Accepts the\n    #   keys:\n    # ** <tt>:count</tt>: either a number or a range which must equal (or\n    #    include) the number of children that match.\n    # ** <tt>:less_than</tt>: the number of matching children must be less than\n    #    this number.\n    # ** <tt>:greater_than</tt>: the number of matching children must be\n    #    greater than this number.\n    # ** <tt>:only</tt>: another hash consisting of the keys to use\n    #    to match on the children, and only matching children will be\n    #    counted.\n    #\n    # Conditions are matched using the following algorithm:\n    #\n    # * if the condition is a string, it must be a substring of the value.\n    # * if the condition is a regexp, it must match the value.\n    # * if the condition is a number, the value must match number.to_s.\n    # * if the condition is +true+, the value must not be +nil+.\n    # * if the condition is +false+ or +nil+, the value must be +nil+.\n    #\n    # Usage:\n    #\n    #   # test if the node is a \"span\" tag\n    #   node.match :tag => \"span\"\n    #\n    #   # test if the node's parent is a \"div\"\n    #   node.match :parent => { :tag => \"div\" }\n    #\n    #   # test if any of the node's ancestors are \"table\" tags\n    #   node.match :ancestor => { :tag => \"table\" }\n    #\n    #   # test if any of the node's immediate children are \"em\" tags\n    #   node.match :child => { :tag => \"em\" }\n    #\n    #   # test if any of the node's descendants are \"strong\" tags\n    #   node.match :descendant => { :tag => \"strong\" }\n    #\n    #   # test if the node has between 2 and 4 span tags as immediate children\n    #   node.match :children => { :count => 2..4, :only => { :tag => \"span\" } } \n    #\n    #   # get funky: test to see if the node is a \"div\", has a \"ul\" ancestor\n    #   # and an \"li\" parent (with \"class\" = \"enum\"), and whether or not it has\n    #   # a \"span\" descendant that contains # text matching /hello world/:\n    #   node.match :tag => \"div\",\n    #              :ancestor => { :tag => \"ul\" },\n    #              :parent => { :tag => \"li\",\n    #                           :attributes => { :class => \"enum\" } },\n    #              :descendant => { :tag => \"span\",\n    #                               :child => /hello world/ }\n    def match(conditions)\n      conditions = validate_conditions(conditions)\n      # check content of child nodes\n      if conditions[:content]\n        if children.empty?\n          return false unless match_condition(\"\", conditions[:content])\n        else\n          return false unless children.find { |child| child.match(conditions[:content]) }\n        end\n      end\n\n      # test the name\n      return false unless match_condition(@name, conditions[:tag]) if conditions[:tag]\n\n      # test attributes\n      (conditions[:attributes] || {}).each do |key, value|\n        return false unless match_condition(self[key], value)\n      end\n\n      # test parent\n      return false unless parent.match(conditions[:parent]) if conditions[:parent]\n\n      # test children\n      return false unless children.find { |child| child.match(conditions[:child]) } if conditions[:child]\n   \n      # test ancestors\n      if conditions[:ancestor]\n        return false unless catch :found do\n          p = self\n          throw :found, true if p.match(conditions[:ancestor]) while p = p.parent\n        end\n      end\n\n      # test descendants\n      if conditions[:descendant]\n        return false unless children.find do |child|\n          # test the child\n          child.match(conditions[:descendant]) ||\n          # test the child's descendants\n          child.match(:descendant => conditions[:descendant])\n        end\n      end\n      \n      # count children\n      if opts = conditions[:children]\n        matches = children.select do |c|\n          (c.kind_of?(HTML::Tag) and (c.closing == :self or ! c.childless?))\n        end\n        \n        matches = matches.select { |c| c.match(opts[:only]) } if opts[:only]\n        opts.each do |key, value|\n          next if key == :only\n          case key\n            when :count\n              if Integer === value\n                return false if matches.length != value\n              else\n                return false unless value.include?(matches.length)\n              end\n            when :less_than\n              return false unless matches.length < value\n            when :greater_than\n              return false unless matches.length > value\n            else raise \"unknown count condition #{key}\"\n          end\n        end\n      end\n\n      # test siblings\n      if conditions[:sibling] || conditions[:before] || conditions[:after]\n        siblings = parent ? parent.children : []\n        self_index = siblings.index(self)\n\n        if conditions[:sibling]\n          return false unless siblings.detect do |s| \n            s != self && s.match(conditions[:sibling])\n          end\n        end\n\n        if conditions[:before]\n          return false unless siblings[self_index+1..-1].detect do |s| \n            s != self && s.match(conditions[:before])\n          end\n        end\n\n        if conditions[:after]\n          return false unless siblings[0,self_index].detect do |s| \n            s != self && s.match(conditions[:after])\n          end\n        end\n      end\n  \n      true\n    end\n\n    def ==(node)\n      return false unless super\n      return false unless closing == node.closing && self.name == node.name\n      attributes == node.attributes\n    end\n    \n    private\n      # Match the given value to the given condition.\n      def match_condition(value, condition)\n        case condition\n          when String\n            value && value == condition\n          when Regexp\n            value && value.match(condition)\n          when Numeric\n            value == condition.to_s\n          when true\n            !value.nil?\n          when false, nil\n            value.nil?\n          else\n            false\n        end\n      end\n  end\nend\n", "require 'abstract_unit'\n\nclass SanitizerTest < ActionController::TestCase\n  def setup\n    @sanitizer = nil # used by assert_sanitizer\n  end\n\n  def test_strip_tags\n    sanitizer = HTML::FullSanitizer.new\n    assert_equal(\"<<<bad html\", sanitizer.sanitize(\"<<<bad html\"))\n    assert_equal(\"<<\", sanitizer.sanitize(\"<<<bad html>\"))\n    assert_equal(\"Dont touch me\", sanitizer.sanitize(\"Dont touch me\"))\n    assert_equal(\"This is a test.\", sanitizer.sanitize(\"<p>This <u>is<u> a <a href='test.html'><strong>test</strong></a>.</p>\"))\n    assert_equal(\"Weirdos\", sanitizer.sanitize(\"Wei<<a>a onclick='alert(document.cookie);'</a>/>rdos\"))\n    assert_equal(\"This is a test.\", sanitizer.sanitize(\"This is a test.\"))\n    assert_equal(\n    %{This is a test.\\n\\n\\nIt no longer contains any HTML.\\n}, sanitizer.sanitize(\n    %{<title>This is <b>a <a href=\"\" target=\"_blank\">test</a></b>.</title>\\n\\n<!-- it has a comment -->\\n\\n<p>It no <b>longer <strong>contains <em>any <strike>HTML</strike></em>.</strong></b></p>\\n}))\n    assert_equal \"This has a  here.\", sanitizer.sanitize(\"This has a <!-- comment --> here.\")\n    assert_equal \"This has a  here.\", sanitizer.sanitize(\"This has a <![CDATA[<section>]]> here.\")\n    assert_equal \"This has an unclosed \", sanitizer.sanitize(\"This has an unclosed <![CDATA[<section>]] here...\")\n    assert_equal \"non printable char is a tag\", sanitizer.sanitize(\"<\\x07a href='/hello'>non printable char is a tag</a>\")\n    [nil, '', '   '].each { |blank| assert_equal blank, sanitizer.sanitize(blank) }\n  end\n\n  def test_strip_links\n    sanitizer = HTML::LinkSanitizer.new\n    assert_equal \"Dont touch me\", sanitizer.sanitize(\"Dont touch me\")    \n    assert_equal \"on my mind\\nall day long\", sanitizer.sanitize(\"<a href='almost'>on my mind</a>\\n<A href='almost'>all day long</A>\")\n    assert_equal \"0wn3d\", sanitizer.sanitize(\"<a href='http://www.rubyonrails.com/'><a href='http://www.rubyonrails.com/' onlclick='steal()'>0wn3d</a></a>\") \n    assert_equal \"Magic\", sanitizer.sanitize(\"<a href='http://www.rubyonrails.com/'>Mag<a href='http://www.ruby-lang.org/'>ic\") \n    assert_equal \"FrrFox\", sanitizer.sanitize(\"<href onlclick='steal()'>FrrFox</a></href>\") \n    assert_equal \"My mind\\nall <b>day</b> long\", sanitizer.sanitize(\"<a href='almost'>My mind</a>\\n<A href='almost'>all <b>day</b> long</A>\")\n    assert_equal \"all <b>day</b> long\", sanitizer.sanitize(\"<<a>a href='hello'>all <b>day</b> long<</A>/a>\")\n\n    assert_equal \"<a<a\", sanitizer.sanitize(\"<a<a\")\n  end\n\n  def test_sanitize_form\n    assert_sanitized \"<form action=\\\"/foo/bar\\\" method=\\\"post\\\"><input></form>\", ''\n  end\n\n  def test_sanitize_plaintext\n    raw = \"<plaintext><span>foo</span></plaintext>\"\n    assert_sanitized raw, \"<span>foo</span>\"\n  end\n\n  def test_sanitize_script\n    assert_sanitized \"a b c<script language=\\\"Javascript\\\">blah blah blah</script>d e f\", \"a b cd e f\"\n  end\n\n  # fucked\n  def test_sanitize_js_handlers\n    raw = %{onthis=\"do that\" <a href=\"#\" onclick=\"hello\" name=\"foo\" onbogus=\"remove me\">hello</a>}\n    assert_sanitized raw, %{onthis=\"do that\" <a name=\"foo\" href=\"#\">hello</a>}\n  end\n\n  def test_sanitize_javascript_href\n    raw = %{href=\"javascript:bang\" <a href=\"javascript:bang\" name=\"hello\">foo</a>, <span href=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{href=\"javascript:bang\" <a name=\"hello\">foo</a>, <span>bar</span>}\n  end\n  \n  def test_sanitize_image_src\n    raw = %{src=\"javascript:bang\" <img src=\"javascript:bang\" width=\"5\">foo</img>, <span src=\"javascript:bang\">bar</span>}\n    assert_sanitized raw, %{src=\"javascript:bang\" <img width=\"5\">foo</img>, <span>bar</span>}\n  end\n\n  HTML::WhiteListSanitizer.allowed_tags.each do |tag_name|\n    define_method \"test_should_allow_#{tag_name}_tag\" do\n      assert_sanitized \"start <#{tag_name} title=\\\"1\\\" onclick=\\\"foo\\\">foo <bad>bar</bad> baz</#{tag_name}> end\", %(start <#{tag_name} title=\"1\">foo bar baz</#{tag_name}> end)\n    end\n  end\n\n  def test_should_allow_anchors\n    assert_sanitized %(<a href=\"foo\" onclick=\"bar\"><script>baz</script></a>), %(<a href=\"foo\"></a>)\n  end\n\n  # RFC 3986, sec 4.2\n  def test_allow_colons_in_path_component\n    assert_sanitized(\"<a href=\\\"./this:that\\\">foo</a>\")\n  end\n\n  %w(src width height alt).each do |img_attr|\n    define_method \"test_should_allow_image_#{img_attr}_attribute\" do\n      assert_sanitized %(<img #{img_attr}=\"foo\" onclick=\"bar\" />), %(<img #{img_attr}=\"foo\" />)\n    end\n  end\n\n  def test_should_handle_non_html\n    assert_sanitized 'abc'\n  end\n\n  def test_should_handle_blank_text\n    assert_sanitized nil\n    assert_sanitized ''\n  end\n\n  def test_should_allow_custom_tags\n    text = \"<u>foo</u>\"\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(text, sanitizer.sanitize(text, :tags => %w(u)))\n  end\n\n  def test_should_allow_only_custom_tags\n    text = \"<u>foo</u> with <i>bar</i>\"\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(\"<u>foo</u> with bar\", sanitizer.sanitize(text, :tags => %w(u)))\n  end\n\n  def test_should_allow_custom_tags_with_attributes\n    text = %(<blockquote cite=\"http://example.com/\">foo</blockquote>)\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(text, sanitizer.sanitize(text))\n  end\n\n  def test_should_allow_custom_tags_with_custom_attributes\n    text = %(<blockquote foo=\"bar\">Lorem ipsum</blockquote>)\n    sanitizer = HTML::WhiteListSanitizer.new\n    assert_equal(text, sanitizer.sanitize(text, :attributes => ['foo']))\n  end\n\n  [%w(img src), %w(a href)].each do |(tag, attr)|\n    define_method \"test_should_strip_#{attr}_attribute_in_#{tag}_with_bad_protocols\" do\n      assert_sanitized %(<#{tag} #{attr}=\"javascript:bang\" title=\"1\">boo</#{tag}>), %(<#{tag} title=\"1\">boo</#{tag}>)\n    end\n  end\n\n  def test_should_flag_bad_protocols\n    sanitizer = HTML::WhiteListSanitizer.new\n    %w(about chrome data disk hcp help javascript livescript lynxcgi lynxexec ms-help ms-its mhtml mocha opera res resource shell vbscript view-source vnd.ms.radio wysiwyg).each do |proto|\n      assert sanitizer.send(:contains_bad_protocols?, 'src', \"#{proto}://bad\")\n    end\n  end\n\n  def test_should_accept_good_protocols\n    sanitizer = HTML::WhiteListSanitizer.new\n    HTML::WhiteListSanitizer.allowed_protocols.each do |proto|\n      assert !sanitizer.send(:contains_bad_protocols?, 'src', \"#{proto}://good\")\n    end\n  end\n\n  def test_should_reject_hex_codes_in_protocol\n    assert_sanitized %(<a href=\"&#37;6A&#37;61&#37;76&#37;61&#37;73&#37;63&#37;72&#37;69&#37;70&#37;74&#37;3A&#37;61&#37;6C&#37;65&#37;72&#37;74&#37;28&#37;22&#37;58&#37;53&#37;53&#37;22&#37;29\">1</a>), \"<a>1</a>\"\n    assert @sanitizer.send(:contains_bad_protocols?, 'src', \"%6A%61%76%61%73%63%72%69%70%74%3A%61%6C%65%72%74%28%22%58%53%53%22%29\")\n  end\n\n  def test_should_block_script_tag\n    assert_sanitized %(<SCRIPT\\nSRC=http://ha.ckers.org/xss.js></SCRIPT>), \"\"\n  end\n\n  [%(<IMG SRC=\"javascript:alert('XSS');\">), \n   %(<IMG SRC=javascript:alert('XSS')>), \n   %(<IMG SRC=JaVaScRiPt:alert('XSS')>), \n   %(<IMG \"\"\"><SCRIPT>alert(\"XSS\")</SCRIPT>\">),\n   %(<IMG SRC=javascript:alert(&quot;XSS&quot;)>),\n   %(<IMG SRC=javascript:alert(String.fromCharCode(88,83,83))>),\n   %(<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>),\n   %(<IMG SRC=&#0000106&#0000097&#0000118&#0000097&#0000115&#0000099&#0000114&#0000105&#0000112&#0000116&#0000058&#0000097&#0000108&#0000101&#0000114&#0000116&#0000040&#0000039&#0000088&#0000083&#0000083&#0000039&#0000041>),\n   %(<IMG SRC=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A&#x61&#x6C&#x65&#x72&#x74&#x28&#x27&#x58&#x53&#x53&#x27&#x29>),\n   %(<IMG SRC=\"jav\\tascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x09;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0A;ascript:alert('XSS');\">),\n   %(<IMG SRC=\"jav&#x0D;ascript:alert('XSS');\">),\n   %(<IMG SRC=\" &#14;  javascript:alert('XSS');\">),\n   %(<IMG SRC=`javascript:alert(\"RSnake says, 'XSS'\")`>)].each_with_index do |img_hack, i|\n    define_method \"test_should_not_fall_for_xss_image_hack_#{i+1}\" do\n      assert_sanitized img_hack, \"<img>\"\n    end\n  end\n  \n  def test_should_sanitize_tag_broken_up_by_null\n    assert_sanitized %(<SCR\\0IPT>alert(\\\"XSS\\\")</SCR\\0IPT>), \"alert(\\\"XSS\\\")\"\n  end\n  \n  def test_should_sanitize_invalid_script_tag\n    assert_sanitized %(<SCRIPT/XSS SRC=\"http://ha.ckers.org/xss.js\"></SCRIPT>), \"\"\n  end\n  \n  def test_should_sanitize_script_tag_with_multiple_open_brackets\n    assert_sanitized %(<<SCRIPT>alert(\"XSS\");//<</SCRIPT>), \"&lt;\"\n    assert_sanitized %(<iframe src=http://ha.ckers.org/scriptlet.html\\n<a), %(&lt;a)\n  end\n  \n  def test_should_sanitize_unclosed_script\n    assert_sanitized %(<SCRIPT SRC=http://ha.ckers.org/xss.js?<B>), \"<b>\"\n  end\n  \n  def test_should_sanitize_half_open_scripts\n    assert_sanitized %(<IMG SRC=\"javascript:alert('XSS')\"), \"<img>\"\n  end\n  \n  def test_should_not_fall_for_ridiculous_hack\n    img_hack = %(<IMG\\nSRC\\n=\\n\"\\nj\\na\\nv\\na\\ns\\nc\\nr\\ni\\np\\nt\\n:\\na\\nl\\ne\\nr\\nt\\n(\\n'\\nX\\nS\\nS\\n'\\n)\\n\"\\n>)\n    assert_sanitized img_hack, \"<img>\"\n  end\n\n  # fucked\n  def test_should_sanitize_attributes\n    assert_sanitized %(<SPAN title=\"'><script>alert()</script>\">blah</SPAN>), %(<span title=\"'&gt;&lt;script&gt;alert()&lt;/script&gt;\">blah</span>)\n  end\n\n  def test_should_sanitize_illegal_style_properties\n    raw      = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;)\n    expected = %(display: block; width: 100%; height: 100%; background-color: black; background-image: ; background-x: center; background-y: center;)\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_with_trailing_space\n    raw = \"display:block; \"\n    expected = \"display: block;\"\n    assert_equal expected, sanitize_css(raw)\n  end\n\n  def test_should_sanitize_xul_style_attributes\n    raw = %(-moz-binding:url('http://ha.ckers.org/xssmoz.xml#xss'))\n    assert_equal '', sanitize_css(raw)\n  end\n  \n  def test_should_sanitize_invalid_tag_names\n    assert_sanitized(%(a b c<script/XSS src=\"http://ha.ckers.org/xss.js\"></script>d e f), \"a b cd e f\")\n  end\n  \n  def test_should_sanitize_non_alpha_and_non_digit_characters_in_tags\n    assert_sanitized('<a onclick!#$%&()*~+-_.,:;?@[/|\\]^`=alert(\"XSS\")>foo</a>', \"<a>foo</a>\")\n  end\n  \n  def test_should_sanitize_invalid_tag_names_in_single_tags\n    assert_sanitized('<img/src=\"http://ha.ckers.org/xss.js\"/>', \"<img />\")\n  end\n\n  def test_should_sanitize_img_dynsrc_lowsrc\n    assert_sanitized(%(<img lowsrc=\"javascript:alert('XSS')\" />), \"<img />\")\n  end\n\n  def test_should_sanitize_div_background_image_unicode_encoded\n    raw = %(background-image:\\0075\\0072\\006C\\0028'\\006a\\0061\\0076\\0061\\0073\\0063\\0072\\0069\\0070\\0074\\003a\\0061\\006c\\0065\\0072\\0074\\0028.1027\\0058.1053\\0053\\0027\\0029'\\0029)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_div_style_expression\n    raw = %(width: expression(alert('XSS'));)\n    assert_equal '', sanitize_css(raw)\n  end\n\n  def test_should_sanitize_img_vbscript\n    assert_sanitized %(<img src='vbscript:msgbox(\"XSS\")' />), '<img />'\n  end\n\n  def test_should_sanitize_cdata_section\n    assert_sanitized \"<![CDATA[<span>section</span>]]>\", \"&lt;![CDATA[&lt;span>section&lt;/span>]]>\"\n  end\n\n  def test_should_sanitize_unterminated_cdata_section\n    assert_sanitized \"<![CDATA[<span>neverending...\", \"&lt;![CDATA[&lt;span>neverending...]]>\"\n  end\n\n  def test_should_not_mangle_urls_with_ampersand\n     assert_sanitized %{<a href=\\\"http://www.domain.com?var1=1&amp;var2=2\\\">my link</a>}\n  end\n\nprotected\n  def assert_sanitized(input, expected = nil)\n    @sanitizer ||= HTML::WhiteListSanitizer.new\n    if input\n      assert_dom_equal expected || input, @sanitizer.sanitize(input)\n    else\n      assert_nil @sanitizer.sanitize(input)\n    end\n  end\n\n  def sanitize_css(input)\n    (@sanitizer ||= HTML::WhiteListSanitizer.new).sanitize_css(input)\n  end\nend\n"], "filenames": ["actionpack/lib/action_controller/vendor/html-scanner/html/node.rb", "actionpack/test/controller/html-scanner/sanitizer_test.rb"], "buggy_code_start_loc": [165, 21], "buggy_code_end_loc": [166, 21], "fixing_code_start_loc": [165, 22], "fixing_code_end_loc": [166, 23], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in the strip_tags function in Ruby on Rails before 2.2.s, and 2.3.x before 2.3.5, allows remote attackers to inject arbitrary web script or HTML via vectors involving non-printing ASCII characters, related to HTML::Tokenizer and actionpack/lib/action_controller/vendor/html-scanner/html/node.rb.", "other": {"cve": {"id": "CVE-2009-4214", "sourceIdentifier": "cve@mitre.org", "published": "2009-12-07T17:30:00.217", "lastModified": "2019-08-08T14:43:53.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in the strip_tags function in Ruby on Rails before 2.2.s, and 2.3.x before 2.3.5, allows remote attackers to inject arbitrary web script or HTML via vectors involving non-printing ASCII characters, related to HTML::Tokenizer and actionpack/lib/action_controller/vendor/html-scanner/html/node.rb."}, {"lang": "es", "value": "Vulnerabilidad de secuencias de comandos en sitios cruzados (XSS) en Ruby on Rails anterior v2.2.s, y v2.3.x anterior v2.3.5, permite a atacantes remotos inyectar c\u00f3digo Web o HTML a su lecci\u00f3n a trav\u00e9s de vectores que incluyen caracteres ASCII no imprimibles, relacionado con HTML::Tokenizer y actionpack/lib/action_controller/vendor/html-scanner/html/node.rb."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D1467583-23E9-4E2B-982D-80A356174BB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "4DC784C0-5618-4C32-8C17-BE7041656E14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "CFB9ABB5-1F78-4CF0-BA82-7833E0F7A56E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "49B9DD7F-DA3A-49C5-B2D4-8A8BD73C6FA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "EB938651-C874-4427-AF9B-E9564B258633"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "1D59FAFB-5D48-4BD8-AD51-FF9A204E373D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "FE23CCE1-1713-4813-A0AB-1E10DBDA4D12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.9.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "897109FF-2C37-458A-91A9-7407F3DFBC99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "289B1633-AAF7-48BE-9A71-0577428EE531"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "B947FD6D-CD0B-44EE-95B5-E513AF244905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3666B82-1880-4A43-900F-3656F3FB157A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "BE622F6D-AC7D-4D82-A33C-82C2CEFDB9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "C06D18BA-A0AB-461B-B498-2F1759CBF37D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "61EBE7E0-C474-43A7-85E3-093C754A253F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7195418-A2E9-43E6-B29F-AEACC317E69E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "39485B13-3C71-4EC6-97CF-6C796650C5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "E2E16D8B-4FBD-4FB6-ABA8-B38ECA4D413F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.14.2:*:*:*:*:*:*:*", "matchCriteriaId": "D8A3B30A-65F0-4D63-9A09-B23E9FC8D550"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.14.3:*:*:*:*:*:*:*", "matchCriteriaId": "62323F62-AD04-4F43-A566-718DDB4149CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:0.14.4:*:*:*:*:*:*:*", "matchCriteriaId": "A8E890B1-4237-4470-939A-4FC489E04520"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "24F3B933-0F68-4F88-999C-0BE48BC88CF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "9E13DAEA-F118-4CB2-88A5-54E3327B6B9E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "BC33BF68-D887-4C67-8E8C-D2A6CD877FB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "7BFCB88D-D946-4510-8DDC-67C32A606589"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "E793287E-2BDA-4012-86F5-886B82510431"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "DF706143-996C-4120-B620-3EDC977568DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "43E7F32B-C760-4862-B6DB-C38FB2A9182F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "FD68A034-73A2-4B1A-95DB-19AD3131F775"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "2E78C912-E8FF-495F-B922-43C54D1E2180"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "15B72C17-82C3-4930-9227-226C8E64C2E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "FA59F311-B2B4-40EE-A878-64EF9F41581B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "035B47E9-A395-47D2-9164-A2A2CF878326"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "BDA55D29-C830-45EF-A3B3-BFA9EED88F38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "0A9356A6-D32A-487C-B743-1DA0D6C42FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B3C7616-8631-49AC-979C-4347067059AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:1.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "EC487B78-AAEA-4F0E-8C8B-F415013A381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "50EEAFDA-7782-4E1E-9058-205AD4BE9A01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "CAC748BB-BFC5-44F7-B633-CEEBB1279889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "38CF2C31-70BB-41D3-9462-0A8B9869A5F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "F8584B37-7950-4C89-83D2-04E1ACDC60BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "8CB26F65-5CFB-4BF8-BCC4-679327D4A8DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "EF12EA5D-5EB5-46A8-AC60-65B327D610AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "87B4B121-94BD-4E0F-8860-6239890043B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:rails:2.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "63CF211C-683E-4F7D-8C62-05B153AC1960"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.2", "matchCriteriaId": "195F4692-EB88-40A4-AEF5-0F81CC41CFE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "04FDC63D-6ED7-48AE-9D72-6419F54D4B84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "DBF12B2F-39D9-48D5-9620-DF378D199295"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "22E1EAAF-7B49-498B-BFEB-357173824F4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B9AD626-0AFA-4873-A701-C7716193A69C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "BF69F60A-E8D3-4A4D-BBB5-DE42A1402262"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "986D2B30-FF07-498B-A5E0-A77BAB402619"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "A0E3141A-162C-4674-BD7B-E1539BAA0B7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "86E73F12-0551-42D2-ACC3-223C98B69C7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "D6BA0659-2287-4E95-B30D-2441CD96DA90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rubyonrails:ruby_on_rails:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "B01A4699-32D3-459E-B731-4240C8157F71"}]}]}], "references": [{"url": "http://github.com/rails/rails/commit/bfe032858077bb2946abe25e95e485ba6da86bd5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://groups.google.com/group/rubyonrails-security/browse_thread/thread/4d4f71f2aef4c0ab?pli=1", "source": "cve@mitre.org"}, {"url": "http://lists.apple.com/archives/security-announce/2010//Mar/msg00001.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2010-03/msg00004.html", "source": "cve@mitre.org"}, {"url": "http://support.apple.com/kb/HT4077", "source": "cve@mitre.org"}, {"url": "http://weblog.rubyonrails.org/2009/11/30/ruby-on-rails-2-3-5-released", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2011/dsa-2260", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2011/dsa-2301", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2009/11/27/2", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2009/12/08/3", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/37142", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securitytracker.com/id?1023245", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2009/3352", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "http://github.com/rails/rails/commit/bfe032858077bb2946abe25e95e485ba6da86bd5"}}