{"buggy_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2017, Linaro Limited\n * Copyright 2020 NXP\n * Copyright 2021, SumUp Service GmbH\n */\n\n#include <assert.h>\n#include <compiler.h>\n#include <crypto/crypto.h>\n#include <crypto/crypto_impl.h>\n#include <kernel/panic.h>\n#include <stdlib.h>\n#include <string.h>\n#include <utee_defines.h>\n\nTEE_Result crypto_hash_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\tstruct crypto_hash_ctx *c = NULL;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_hash_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_MD5:\n\t\t\tres = crypto_md5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA1:\n\t\t\tres = crypto_sha1_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA224:\n\t\t\tres = crypto_sha224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA256:\n\t\t\tres = crypto_sha256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA384:\n\t\t\tres = crypto_sha384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA512:\n\t\t\tres = crypto_sha512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_224:\n\t\t\tres = crypto_sha3_224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_256:\n\t\t\tres = crypto_sha3_256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_384:\n\t\t\tres = crypto_sha3_384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_512:\n\t\t\tres = crypto_sha3_512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHAKE128:\n\t\t\tres = crypto_shake128_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHAKE256:\n\t\t\tres = crypto_shake256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM3:\n\t\t\tres = crypto_sm3_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_hash_ops *hash_ops(void *ctx)\n{\n\tstruct crypto_hash_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nvoid crypto_hash_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\thash_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_hash_copy_state(void *dst_ctx, void *src_ctx)\n{\n\thash_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\nTEE_Result crypto_hash_init(void *ctx)\n{\n\treturn hash_ops(ctx)->init(ctx);\n}\n\nTEE_Result crypto_hash_update(void *ctx, const uint8_t *data, size_t len)\n{\n\treturn hash_ops(ctx)->update(ctx, data, len);\n}\n\nTEE_Result crypto_hash_final(void *ctx, uint8_t *digest, size_t len)\n{\n\treturn hash_ops(ctx)->final(ctx, digest, len);\n}\n\nTEE_Result crypto_cipher_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\tstruct crypto_cipher_ctx *c = NULL;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_cipher_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_AES_ECB_NOPAD:\n\t\t\tres = crypto_aes_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CBC_NOPAD:\n\t\t\tres = crypto_aes_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CTR:\n\t\t\tres = crypto_aes_ctr_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CTS:\n\t\t\tres = crypto_aes_cts_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_XTS:\n\t\t\tres = crypto_aes_xts_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_ECB_NOPAD:\n\t\t\tres = crypto_des_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_ECB_NOPAD:\n\t\t\tres = crypto_des3_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_CBC_NOPAD:\n\t\t\tres = crypto_des_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CBC_NOPAD:\n\t\t\tres = crypto_des3_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_ECB_NOPAD:\n\t\t\tres = crypto_sm4_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_CBC_NOPAD:\n\t\t\tres = crypto_sm4_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_CTR:\n\t\t\tres = crypto_sm4_ctr_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_XTS:\n\t\t\tres = crypto_sm4_xts_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_cipher_ops *cipher_ops(void *ctx)\n{\n\tstruct crypto_cipher_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nvoid crypto_cipher_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\tcipher_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_cipher_copy_state(void *dst_ctx, void *src_ctx)\n{\n\tcipher_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\nTEE_Result crypto_cipher_init(void *ctx, TEE_OperationMode mode,\n\t\t\t      const uint8_t *key1, size_t key1_len,\n\t\t\t      const uint8_t *key2, size_t key2_len,\n\t\t\t      const uint8_t *iv, size_t iv_len)\n{\n\tif (mode != TEE_MODE_DECRYPT && mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn cipher_ops(ctx)->init(ctx, mode, key1, key1_len, key2, key2_len,\n\t\t\t\t     iv, iv_len);\n}\n\nTEE_Result crypto_cipher_update(void *ctx, TEE_OperationMode mode __unused,\n\t\t\t\tbool last_block, const uint8_t *data,\n\t\t\t\tsize_t len, uint8_t *dst)\n{\n\treturn cipher_ops(ctx)->update(ctx, last_block, data, len, dst);\n}\n\nvoid crypto_cipher_final(void *ctx)\n{\n\tcipher_ops(ctx)->final(ctx);\n}\n\nTEE_Result crypto_cipher_get_block_size(uint32_t algo, size_t *size)\n{\n\tuint32_t class = TEE_ALG_GET_CLASS(algo);\n\n\tif (class != TEE_OPERATION_CIPHER && class != TEE_OPERATION_MAC &&\n\t    class != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(algo)) {\n\tcase TEE_MAIN_ALGO_AES:\n\t\t*size = TEE_AES_BLOCK_SIZE;\n\t\treturn TEE_SUCCESS;\n\tcase TEE_MAIN_ALGO_DES:\n\tcase TEE_MAIN_ALGO_DES3:\n\t\t*size = TEE_DES_BLOCK_SIZE;\n\t\treturn TEE_SUCCESS;\n\tcase TEE_MAIN_ALGO_SM4:\n\t\t*size = TEE_SM4_BLOCK_SIZE;\n\t\treturn TEE_SUCCESS;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n}\n\nTEE_Result crypto_mac_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct crypto_mac_ctx *c = NULL;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_mac_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_HMAC_MD5:\n\t\t\tres = crypto_hmac_md5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA1:\n\t\t\tres = crypto_hmac_sha1_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA224:\n\t\t\tres = crypto_hmac_sha224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA256:\n\t\t\tres = crypto_hmac_sha256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA384:\n\t\t\tres = crypto_hmac_sha384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA512:\n\t\t\tres = crypto_hmac_sha512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_224:\n\t\t\tres = crypto_hmac_sha3_224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_256:\n\t\t\tres = crypto_hmac_sha3_256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_384:\n\t\t\tres = crypto_hmac_sha3_384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_512:\n\t\t\tres = crypto_hmac_sha3_512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SM3:\n\t\t\tres = crypto_hmac_sm3_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CBC_MAC_NOPAD:\n\t\t\tres = crypto_aes_cbc_mac_nopad_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CBC_MAC_PKCS5:\n\t\t\tres = crypto_aes_cbc_mac_pkcs5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_CBC_MAC_NOPAD:\n\t\t\tres = crypto_des_cbc_mac_nopad_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_CBC_MAC_PKCS5:\n\t\t\tres = crypto_des_cbc_mac_pkcs5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CBC_MAC_NOPAD:\n\t\t\tres = crypto_des3_cbc_mac_nopad_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CBC_MAC_PKCS5:\n\t\t\tres = crypto_des3_cbc_mac_pkcs5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CMAC:\n\t\t\tres = crypto_des3_cmac_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CMAC:\n\t\t\tres = crypto_aes_cmac_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_mac_ops *mac_ops(void *ctx)\n{\n\tstruct crypto_mac_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nvoid crypto_mac_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\tmac_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_mac_copy_state(void *dst_ctx, void *src_ctx)\n{\n\tmac_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\nTEE_Result crypto_mac_init(void *ctx, const uint8_t *key, size_t len)\n{\n\treturn mac_ops(ctx)->init(ctx, key, len);\n}\n\nTEE_Result crypto_mac_update(void *ctx, const uint8_t *data, size_t len)\n{\n\tif (!len)\n\t\treturn TEE_SUCCESS;\n\n\treturn mac_ops(ctx)->update(ctx, data, len);\n}\n\nTEE_Result crypto_mac_final(void *ctx, uint8_t *digest, size_t digest_len)\n{\n\treturn mac_ops(ctx)->final(ctx, digest, digest_len);\n}\n\nTEE_Result crypto_authenc_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\tstruct crypto_authenc_ctx *c = NULL;\n\n\t/*\n\t * Use default authenc implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_authenc_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n#if defined(CFG_CRYPTO_CCM)\n\t\tcase TEE_ALG_AES_CCM:\n\t\t\tres = crypto_aes_ccm_alloc_ctx(&c);\n\t\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_GCM)\n\t\tcase TEE_ALG_AES_GCM:\n\t\t\tres = crypto_aes_gcm_alloc_ctx(&c);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_authenc_ops *ae_ops(void *ctx)\n{\n\tstruct crypto_authenc_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nTEE_Result crypto_authenc_init(void *ctx, TEE_OperationMode mode,\n\t\t\t       const uint8_t *key, size_t key_len,\n\t\t\t       const uint8_t *nonce, size_t nonce_len,\n\t\t\t       size_t tag_len, size_t aad_len,\n\t\t\t       size_t payload_len)\n{\n\treturn ae_ops(ctx)->init(ctx, mode, key, key_len, nonce, nonce_len,\n\t\t\t\t tag_len, aad_len, payload_len);\n}\n\nTEE_Result crypto_authenc_update_aad(void *ctx, TEE_OperationMode mode __unused,\n\t\t\t\t     const uint8_t *data, size_t len)\n{\n\treturn ae_ops(ctx)->update_aad(ctx, data, len);\n}\n\n\nTEE_Result crypto_authenc_update_payload(void *ctx, TEE_OperationMode mode,\n\t\t\t\t\t const uint8_t *src_data,\n\t\t\t\t\t size_t src_len, uint8_t *dst_data,\n\t\t\t\t\t size_t *dst_len)\n{\n\tif (*dst_len < src_len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t*dst_len = src_len;\n\n\treturn ae_ops(ctx)->update_payload(ctx, mode, src_data, src_len,\n\t\t\t\t\t   dst_data);\n}\n\nTEE_Result crypto_authenc_enc_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, uint8_t *dst_tag,\n\t\t\t\t    size_t *dst_tag_len)\n{\n\tif (*dst_len < src_len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t*dst_len = src_len;\n\n\treturn ae_ops(ctx)->enc_final(ctx, src_data, src_len, dst_data,\n\t\t\t\t      dst_tag, dst_tag_len);\n}\n\nTEE_Result crypto_authenc_dec_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, const uint8_t *tag,\n\t\t\t\t    size_t tag_len)\n{\n\tif (*dst_len < src_len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t*dst_len = src_len;\n\n\treturn ae_ops(ctx)->dec_final(ctx, src_data, src_len, dst_data, tag,\n\t\t\t\t      tag_len);\n}\n\nvoid crypto_authenc_final(void *ctx)\n{\n\tae_ops(ctx)->final(ctx);\n}\n\nvoid crypto_authenc_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\tae_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_authenc_copy_state(void *dst_ctx, void *src_ctx)\n{\n\tae_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\n#if !defined(CFG_CRYPTO_RSA) && !defined(CFG_CRYPTO_DSA) && \\\n    !defined(CFG_CRYPTO_DH) && !defined(CFG_CRYPTO_ECC)\nstruct bignum *crypto_bignum_allocate(size_t size_bits __unused)\n{\n\treturn NULL;\n}\n\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from __unused,\n\t\t\t\tsize_t fromsize __unused,\n\t\t\t\tstruct bignum *to __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nsize_t crypto_bignum_num_bytes(struct bignum *a __unused)\n{\n\treturn 0;\n}\n\nsize_t crypto_bignum_num_bits(struct bignum *a __unused)\n{\n\treturn 0;\n}\n\n/*\n * crypto_bignum_allocate() and crypto_bignum_bin2bn() failing should be\n * enough to guarantee that the functions calling this function aren't\n * called, but just in case add a panic() here to avoid unexpected\n * behavoir.\n */\nstatic void bignum_cant_happen(void)\n{\n\tvolatile bool b = true;\n\n\t/* Avoid warning about function does not return */\n\tif (b)\n\t\tpanic();\n}\n\nvoid crypto_bignum_bn2bin(const struct bignum *from __unused,\n\t\t\t  uint8_t *to __unused)\n{\n\tbignum_cant_happen();\n}\n\nvoid crypto_bignum_copy(struct bignum *to __unused,\n\t\t\tconst struct bignum *from __unused)\n{\n\tbignum_cant_happen();\n}\n\nvoid crypto_bignum_free(struct bignum *a)\n{\n\tif (a)\n\t\tpanic();\n}\n\nvoid crypto_bignum_clear(struct bignum *a __unused)\n{\n\tbignum_cant_happen();\n}\n\n/* return -1 if a<b, 0 if a==b, +1 if a>b */\nint32_t crypto_bignum_compare(struct bignum *a __unused,\n\t\t\t      struct bignum *b __unused)\n{\n\tbignum_cant_happen();\n\treturn -1;\n}\n#endif\n\n#if !defined(CFG_CRYPTO_RSA)\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s __unused,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s __unused,\n\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s __unused)\n{\n}\n\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s __unused)\n{\n}\n\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key __unused,\n\t\t\t\t      size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key __unused,\n\t\t\t\t\t   const uint8_t *src __unused,\n\t\t\t\t\t   size_t src_len __unused,\n\t\t\t\t\t   uint8_t *dst __unused,\n\t\t\t\t\t   size_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key __unused,\n\t\t\t\t\t   const uint8_t *src __unused,\n\t\t\t\t\t   size_t src_len __unused,\n\t\t\t\t\t   uint8_t *dst __unused,\n\t\t\t\t\t   size_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo __unused,\n\t\t\t\t\tstruct rsa_keypair *key __unused,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src __unused,\n\t\t\t\t\tsize_t src_len __unused,\n\t\t\t\t\tuint8_t *dst __unused,\n\t\t\t\t\tsize_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo __unused,\n\t\t\t\t\tstruct rsa_public_key *key __unused,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src __unused,\n\t\t\t\t\tsize_t src_len __unused,\n\t\t\t\t\tuint8_t *dst __unused,\n\t\t\t\t\tsize_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo __unused,\n\t\t\t\t      struct rsa_keypair *key __unused,\n\t\t\t\t      int salt_len __unused,\n\t\t\t\t      const uint8_t *msg __unused,\n\t\t\t\t      size_t msg_len __unused,\n\t\t\t\t      uint8_t *sig __unused,\n\t\t\t\t      size_t *sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo __unused,\n\t\t\t\t\tstruct rsa_public_key *key __unused,\n\t\t\t\t\tint salt_len __unused,\n\t\t\t\t\tconst uint8_t *msg __unused,\n\t\t\t\t\tsize_t msg_len __unused,\n\t\t\t\t\tconst uint8_t *sig __unused,\n\t\t\t\t\tsize_t sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif /*!CFG_CRYPTO_RSA*/\n\n#if !defined(CFG_CRYPTO_DSA)\nTEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s __unused,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s __unused,\n\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key __unused,\n\t\t\t\t      size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_dsa_sign(uint32_t algo __unused,\n\t\t\t\t   struct dsa_keypair *key __unused,\n\t\t\t\t   const uint8_t *msg __unused,\n\t\t\t\t   size_t msg_len __unused,\n\t\t\t\t   uint8_t *sig __unused,\n\t\t\t\t   size_t *sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_dsa_verify(uint32_t algo __unused,\n\t\t\t\t     struct dsa_public_key *key __unused,\n\t\t\t\t     const uint8_t *msg __unused,\n\t\t\t\t     size_t msg_len __unused,\n\t\t\t\t     const uint8_t *sig __unused,\n\t\t\t\t     size_t sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif /*!CFG_CRYPTO_DSA*/\n\n#if !defined(CFG_CRYPTO_DH)\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s __unused,\n\t\t\t\t\t   size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key __unused,\n\t\t\t\t     struct bignum *q __unused,\n\t\t\t\t     size_t xbits __unused,\n\t\t\t\t     size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_dh_shared_secret(struct dh_keypair *private_key __unused,\n\t\t\t\tstruct bignum *public_key __unused,\n\t\t\t\tstruct bignum *secret __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif /*!CFG_CRYPTO_DH*/\n\nTEE_Result crypto_acipher_alloc_ecc_public_key(struct ecc_public_key *key,\n\t\t\t\t\t       uint32_t key_type,\n\t\t\t\t\t       size_t key_size_bits)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_asym_alloc_ecc_public_key(key, key_type, key_size_bits);\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED)\n\t\tres = crypto_asym_alloc_ecc_public_key(key, key_type,\n\t\t\t\t\t\t       key_size_bits);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_alloc_ecc_keypair(struct ecc_keypair *key,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_asym_alloc_ecc_keypair(key, key_type, key_size_bits);\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED)\n\t\tres = crypto_asym_alloc_ecc_keypair(key, key_type,\n\t\t\t\t\t\t    key_size_bits);\n\n\treturn res;\n}\n\nvoid crypto_acipher_free_ecc_public_key(struct ecc_public_key *key)\n{\n\tassert(key->ops && key->ops->free);\n\n\tkey->ops->free(key);\n}\n\nTEE_Result crypto_acipher_gen_ecc_key(struct ecc_keypair *key,\n\t\t\t\t      size_t key_size_bits)\n{\n\tassert(key->ops && key->ops->generate);\n\n\treturn key->ops->generate(key, key_size_bits);\n}\n\nTEE_Result crypto_acipher_ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->sign)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->sign(algo, key, msg, msg_len, sig, sig_len);\n}\n\nTEE_Result crypto_acipher_ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->verify)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->verify(algo, key, msg, msg_len, sig, sig_len);\n}\n\nTEE_Result crypto_acipher_ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t\t    struct ecc_public_key *public_key,\n\t\t\t\t\t    void *secret,\n\t\t\t\t\t    unsigned long *secret_len)\n{\n\tassert(private_key->ops);\n\n\tif (!private_key->ops->shared_secret)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn private_key->ops->shared_secret(private_key, public_key, secret,\n\t\t\t\t\t       secret_len);\n}\n\nTEE_Result crypto_acipher_sm2_pke_decrypt(struct ecc_keypair *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->decrypt)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->decrypt(key, src, src_len, dst, dst_len);\n}\n\nTEE_Result crypto_acipher_sm2_pke_encrypt(struct ecc_public_key *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->encrypt)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->encrypt(key, src, src_len, dst, dst_len);\n}\n\n#if !defined(CFG_CRYPTO_SM2_KEP)\nTEE_Result crypto_acipher_sm2_kep_derive(struct ecc_keypair *my_key __unused,\n\t\t\t\t\t struct ecc_keypair *my_eph_key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t struct ecc_public_key *peer_key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t struct ecc_public_key *peer_eph_key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t struct sm2_kep_parms *p __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif\n\n#if !defined(CFG_CRYPTO_X25519)\nTEE_Result crypto_acipher_alloc_x25519_keypair(struct x25519_keypair *key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_x25519_key(struct x25519_keypair *key __unused,\n\t\t\t\t\t size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_x25519_shared_secret(struct x25519_keypair\n\t\t\t\t\t       *private_key __unused,\n\t\t\t\t\t       void *public_key __unused,\n\t\t\t\t\t       void *secret __unused,\n\t\t\t\t\t       unsigned long\n\t\t\t\t\t       *secret_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif\n\n#if !defined(CFG_CRYPTO_ED25519)\nTEE_Result crypto_acipher_alloc_ed25519_keypair(struct ed25519_keypair *key\n\t\t\t\t\t\t\t\t __unused,\n\t\t\t\t\t\tsize_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_alloc_ed25519_public_key(struct ed25519_public_key *key __unused,\n\t\t\t\t\tsize_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_ed25519_key(struct ed25519_keypair *key __unused,\n\t\t\t\t\t  size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_ed25519_sign(struct ed25519_keypair *key __unused,\n\t\t\t\t       const uint8_t *msg __unused,\n\t\t\t\t       size_t msg_len __unused,\n\t\t\t\t       uint8_t *sig __unused,\n\t\t\t\t       size_t *sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_ed25519_verify(struct ed25519_public_key *key __unused,\n\t\t\t      const uint8_t *msg __unused,\n\t\t\t      size_t msg_len __unused,\n\t\t\t      const uint8_t *sig __unused,\n\t\t\t      size_t sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_ed25519ctx_sign(struct ed25519_keypair *key __unused,\n\t\t\t\t\t  const uint8_t *msg __unused,\n\t\t\t\t\t  size_t msg_len __unused,\n\t\t\t\t\t  uint8_t *sig __unused,\n\t\t\t\t\t  size_t *sig_len __unused,\n\t\t\t\t\t  bool ph_flag __unused,\n\t\t\t\t\t  const uint8_t *ctx __unused,\n\t\t\t\t\t  size_t ctxlen __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_ed25519ctx_verify(struct ed25519_public_key *key __unused,\n\t\t\t\t const uint8_t *msg __unused,\n\t\t\t\t size_t msg_len __unused,\n\t\t\t\t const uint8_t *sig __unused,\n\t\t\t\t size_t sig_len __unused,\n\t\t\t\t bool ph_flag __unused,\n\t\t\t\t const uint8_t *ctx __unused,\n\t\t\t\t size_t ctxlen __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif\n\n__weak TEE_Result crypto_storage_obj_del(struct tee_obj *obj __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2018-2021 NXP\n *\n * Implementation of DH\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <mm/core_memprot.h>\n#include <tee/cache.h>\n#include <string.h>\n\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_KEY_GEN 14\n#define MAX_DESC_SHARED  14\n#else\n#define MAX_DESC_KEY_GEN 9\n#define MAX_DESC_SHARED  9\n#endif\n\n/*\n * Definition of the local DH Keypair\n */\nstruct caam_dh_keypair {\n\tstruct caambuf g; /* Generator */\n\tstruct caambuf p; /* Prime Number Modulus */\n\tstruct caambuf x; /* Private key */\n\tstruct caambuf y; /* Public key */\n};\n\n/*\n * Free local DH keypair\n *\n * @key DH keypair\n */\nstatic void do_keypair_free(struct caam_dh_keypair *key)\n{\n\tcaam_free_buf(&key->g);\n\tcaam_free_buf(&key->p);\n\tcaam_free_buf(&key->x);\n\tcaam_free_buf(&key->y);\n}\n\n/*\n * Convert Crypto DH Key p and g bignumbers to local buffers\n * (via keypair object).\n *\n * @outkey [out] Output keypair in local format\n * @inkey  Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv_p_g(struct caam_dh_keypair *outkey,\n\t\t\t\t\t    const struct dh_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t p_size = 0;\n\tsize_t field_size = 0;\n\n\tp_size = crypto_bignum_num_bytes(inkey->p);\n\n\tDH_TRACE(\"DH Convert Key Parameters (p,g) size %zu bytes\", p_size);\n\n\t/* Prime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->p, p_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\n\t/* Generator */\n\tretstatus = caam_calloc_buf(&outkey->g, p_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of g to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->g);\n\tcrypto_bignum_bn2bin(inkey->g, outkey->g.data + p_size - field_size);\n\tcache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto DH Private Key to a local Private Key (via keypair object)\n *\n * @outkey [out] Output local keypair\n * @inkey  Input Private key in TEE Crypto format\n */\nstatic enum caam_status do_keypriv_conv(struct caam_dh_keypair *outkey,\n\t\t\t\t\tconst struct dh_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t key_size = inkey->xbits / 8;\n\tsize_t p_size = 0;\n\n\tif (!key_size)\n\t\tkey_size = crypto_bignum_num_bytes(inkey->x);\n\n\tDH_TRACE(\"DH Convert Private Key size %zu bytes\", key_size);\n\n\t/* Prime */\n\tp_size = crypto_bignum_num_bytes(inkey->p);\n\tretstatus = caam_calloc_buf(&outkey->p, p_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\n\t/* Private Key X */\n\tretstatus = caam_calloc_buf(&outkey->x, key_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->x, outkey->x.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->x.data, outkey->x.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto DH Public Key to local Public Key (via a keypair object)\n *\n * @outkey [out] Output local keypair\n * @inkey  Input Public key in TEE Crypto format\n */\nstatic enum caam_status do_keypub_conv(struct caam_dh_keypair *outkey,\n\t\t\t\t       const struct bignum *inkey)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t key_size = 0;\n\n\tkey_size = crypto_bignum_num_bytes((struct bignum *)inkey);\n\tDH_TRACE(\"DH Convert Keypair size %zu bytes\", key_size);\n\n\t/* Public Key Y */\n\tretstatus = caam_calloc_buf(&outkey->y, key_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey, outkey->y.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->y.data, outkey->y.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Allocate a TEE DH keypair.\n * Note: The subprime q is not used but it must be allocated to prevent\n * system referencing issues when object is destroyed.\n *\n * @key       Keypair\n * @size_bits Key size in bits\n */\nstatic TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Private key X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\t/* Allocate Subprime even if not used */\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDH_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Generates an DH keypair\n * Keypair @key contains the input prime p and generator g values\n * The function calculates private x and public y, knowing that the\n * number of bits of x is either key_size if specified or p size.\n *\n * @key      [in/out] Keypair\n * @q        Sub Prime (not used)\n * @key_size Key size in bits multiple of 8 bits\n */\nstatic TEE_Result do_gen_keypair(struct dh_keypair *key,\n\t\t\t\t struct bignum *q __unused, size_t key_size)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_dh_keypair caam_dh_key = { };\n\tstruct caambuf dh_r = { };\n\tsize_t n_bytes = key_size / 8;\n\tsize_t l_bytes = 0;\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tint counter = 0;\n\n\tl_bytes = crypto_bignum_num_bytes(key->p);\n\tif (!l_bytes)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/*\n\t * If @key_size not specified, private key size is\n\t * same as the public key size (same as prime size)\n\t */\n\tif (!n_bytes)\n\t\tn_bytes = l_bytes;\n\n\t/*\n\t * CAAM private key support is limited to the descriptor PDB\n\t * N maximum value (PDB_DL_KEY_N_MASK)\n\t */\n\tif (n_bytes > PDB_DL_KEY_N_MASK)\n\t\tn_bytes = PDB_DL_KEY_N_MASK;\n\n\tDH_TRACE(\"Request %zu bits key -> so do %zu bytes key\", key_size,\n\t\t n_bytes);\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_GEN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Allocate Private Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dh_key.x, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dh_key.x.data,\n\t\t\tcaam_dh_key.x.length);\n\n\t/* Allocate Public Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dh_key.y, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dh_key.y.data,\n\t\t\tcaam_dh_key.y.length);\n\n\t/* Allocate Private Key modulus (r) and fill it with one's */\n\tretstatus = caam_calloc_buf(&dh_r, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\tmemset(dh_r.data, UINT8_MAX, dh_r.length);\n\tcache_operation(TEE_CACHECLEAN, dh_r.data, dh_r.length);\n\n\t/* Generator and Prime */\n\tretstatus = do_keypair_conv_p_g(&caam_dh_key, key);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build the descriptor using the PDB Public Key generation\n\t * block (PD=0)\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DL_KEY_L_SIZE(l_bytes) |\n\t\t\t\t PDB_DL_KEY_N_SIZE(n_bytes));\n\tcaam_desc_add_ptr(desc, caam_dh_key.p.paddr);\n\tcaam_desc_add_ptr(desc, dh_r.paddr);\n\tcaam_desc_add_ptr(desc, caam_dh_key.g.paddr);\n\tcaam_desc_add_ptr(desc, caam_dh_key.x.paddr);\n\tcaam_desc_add_ptr(desc, caam_dh_key.y.paddr);\n\tcaam_desc_add_word(desc, PK_KEYPAIR_GEN(DL));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDH_DUMPDESC(desc);\n\n\t/*\n\t * If the Secure Key X doesn't have the correct size\n\t * retry a new generation.\n\t * Retry 10 times before returing an error to not lock the system.\n\t */\n\tfor (counter = 0; counter < 10; counter++) {\n\t\tmemset(&jobctx, 0, sizeof(jobctx));\n\t\tjobctx.desc = desc;\n\t\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\t\tif (retstatus == CAAM_NO_ERROR) {\n\t\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dh_key.x.data,\n\t\t\t\t\tcaam_dh_key.x.length);\n\t\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dh_key.y.data,\n\t\t\t\t\tcaam_dh_key.y.length);\n\n\t\t\t/* Copy Private and Public keypair */\n\t\t\tret = crypto_bignum_bin2bn(caam_dh_key.x.data,\n\t\t\t\t\t\t   caam_dh_key.x.length,\n\t\t\t\t\t\t   key->x);\n\t\t\tif (ret != TEE_SUCCESS)\n\t\t\t\tgoto out;\n\n\t\t\tif (crypto_bignum_num_bytes(key->x) != n_bytes) {\n\t\t\t\tDH_TRACE(\"Error X size=%zu expected %zu\",\n\t\t\t\t\t crypto_bignum_num_bytes(key->x),\n\t\t\t\t\t n_bytes);\n\t\t\t\tDH_DUMPBUF(\"X\", caam_dh_key.x.data,\n\t\t\t\t\t   caam_dh_key.x.length);\n\t\t\t\tDH_DUMPBUF(\"Y\", caam_dh_key.y.data,\n\t\t\t\t\t   caam_dh_key.y.length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = crypto_bignum_bin2bn(caam_dh_key.y.data,\n\t\t\t\t\t\t   caam_dh_key.y.length,\n\t\t\t\t\t\t   key->y);\n\t\t\tif (ret != TEE_SUCCESS)\n\t\t\t\tgoto out;\n\n\t\t\t/* Set the Private Key size in bits */\n\t\t\tkey->xbits = n_bytes * 8;\n\n\t\t\tret = TEE_SUCCESS;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tDH_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\t\tret = job_status_to_tee_result(jobctx.status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tcaam_free_buf(&dh_r);\n\tdo_keypair_free(&caam_dh_key);\n\n\treturn ret;\n}\n\n/*\n * Compute the shared secret data from DH Private key and Public Key\n *\n * @sdata   [in/out] DH Shared Secret data\n */\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct dh_keypair *inkeypair = sdata->key_priv;\n\tstruct caam_dh_keypair caam_dh_key = { };\n\tstruct caamdmaobj secret = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tuint32_t pdb_sgt_flags = 0;\n\n\tDH_TRACE(\"DH Shared Secret\");\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SHARED);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ReAllocate the secret result buffer with a maximum size\n\t * of the secret size if not cache aligned\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&secret, sdata->secret.data,\n\t\t\t\t\tsdata->secret.length,\n\t\t\t\t\tsdata->secret.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (secret.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKDH_SECRET;\n\n\tcaam_dmaobj_cache_push(&secret);\n\n\t/* Convert the Private key to local key */\n\tretstatus = do_keypriv_conv(&caam_dh_key, inkeypair);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&caam_dh_key, sdata->key_pub);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build the descriptor using PDB Shared Secret\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, pdb_sgt_flags |\n\t\t\t\t PDB_DL_KEY_L_SIZE(caam_dh_key.y.length) |\n\t\t\t\t PDB_DL_KEY_N_SIZE(caam_dh_key.x.length));\n\t/* Prime */\n\tcaam_desc_add_ptr(desc, caam_dh_key.p.paddr);\n\t/* Modulus - Not used */\n\tcaam_desc_add_ptr(desc, 0);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, caam_dh_key.y.paddr);\n\t/* Private key */\n\tcaam_desc_add_ptr(desc, caam_dh_key.x.paddr);\n\t/* Output secret */\n\tcaam_desc_add_ptr(desc, secret.sgtbuf.paddr);\n\n\tcaam_desc_add_word(desc, SHARED_SECRET(DL));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDH_DUMPDESC(desc);\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tsdata->secret.length = caam_dmaobj_copy_to_orig(&secret);\n\n\t\tDH_DUMPBUF(\"Secret\", sdata->secret.data, sdata->secret.length);\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tDH_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&caam_dh_key);\n\tcaam_dmaobj_free(&secret);\n\n\treturn ret;\n}\n\n/*\n * Registration of the ECC Driver\n */\nstatic struct drvcrypt_dh driver_dh = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.shared_secret = do_shared_secret,\n};\n\nenum caam_status caam_dh_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base) &&\n\t    drvcrypt_register_dh(&driver_dh) == TEE_SUCCESS)\n\t\tretstatus = CAAM_NO_ERROR;\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2019-2021 NXP\n *\n * Implementation of DSA functions\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <mm/core_memprot.h>\n#include <tee/cache.h>\n#include <string.h>\n\n#include \"local.h\"\n\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_KEY_GEN 14\n#define MAX_DESC_SIGN    19\n#define MAX_DESC_VERIFY  21\n#else\n#define MAX_DESC_KEY_GEN 9\n#define MAX_DESC_SIGN    12\n#define MAX_DESC_VERIFY  13\n#endif\n\n/*\n * Definition of the local DSA Keypair\n *   Domain Parameters (p, q, g)\n *   Private Key format (x)\n *   Public Key format (y)\n */\nstruct caam_dsa_keypair {\n\tstruct caambuf g; /* Generator */\n\tstruct caambuf p; /* Prime Number (L bits) */\n\tstruct caambuf q; /* Subprime Number (N bits) */\n\tstruct caambuf x; /* Private key */\n\tstruct caambuf y; /* Public key */\n};\n\n/*\n * Free local DSA keypair\n *\n * @key  DSA keypair\n */\nstatic void do_keypair_free(struct caam_dsa_keypair *key)\n{\n\tcaam_free_buf(&key->g);\n\tcaam_free_buf(&key->p);\n\tcaam_free_buf(&key->q);\n\tcaam_free_buf(&key->x);\n\tcaam_free_buf(&key->y);\n}\n\n/*\n * If all DSA parameters p, q and g are present, convert them from bignumbers\n * to local buffers (via keypair object). Otherwise generate them.\n *\n * @outkey    [out] Output keypair in local format\n * @key       Input key in TEE Crypto format\n * @l_bytes   Prime p size in bytes\n * @n_bytes   Subprime q size in bytes\n */\nstatic TEE_Result get_keypair_domain_params(struct caam_dsa_keypair *outkey,\n\t\t\t\t\t    const struct dsa_keypair *key,\n\t\t\t\t\t    size_t l_bytes, size_t n_bytes)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t in_q_size = 0;\n\tsize_t in_p_size = 0;\n\tsize_t in_g_size = 0;\n\tstruct prime_data_dsa prime = { };\n\n\tDSA_TRACE(\"DSA conv key param (p, g) of %zu bytes and (q) of %zu bytes\",\n\t\t  l_bytes, n_bytes);\n\n\tretstatus = caam_calloc_buf(&outkey->q, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn caam_status_to_tee_result(retstatus);\n\n\tretstatus = caam_calloc_buf(&outkey->g, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn caam_status_to_tee_result(retstatus);\n\n\tretstatus = caam_calloc_buf(&outkey->p, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn caam_status_to_tee_result(retstatus);\n\n\t/*\n\t * Get all inputs parameters size, if one of them is not\n\t * define generate new parameters\n\t */\n\tin_g_size = crypto_bignum_num_bytes(key->g);\n\tin_p_size = crypto_bignum_num_bytes(key->p);\n\tin_q_size = crypto_bignum_num_bytes(key->q);\n\n\tif (!in_q_size || !in_g_size || !in_p_size) {\n\t\t/* Generate DSA parameters: Generator G and Primes P/Q */\n\t\tprime.g = &outkey->g;\n\t\tprime.p = &outkey->p;\n\t\tprime.q = &outkey->q;\n\n\t\tretstatus = caam_prime_dsa_gen(&prime);\n\t\tDSA_TRACE(\"Generate G and Primes P/Q returned %#x\", retstatus);\n\n\t\tif (retstatus != CAAM_NO_ERROR)\n\t\t\treturn caam_status_to_tee_result(retstatus);\n\n\t\t/* Copy Generated DSA Parameter */\n\t\tcrypto_bignum_bin2bn(outkey->q.data, outkey->q.length, key->q);\n\t\tcrypto_bignum_bin2bn(outkey->g.data, outkey->g.length, key->g);\n\t\tcrypto_bignum_bin2bn(outkey->p.data, outkey->p.length, key->p);\n\n\t} else {\n\t\tDSA_TRACE(\"Prime Q is defined\");\n\n\t\tcrypto_bignum_bn2bin(key->q,\n\t\t\t\t     outkey->q.data + n_bytes - in_q_size);\n\t\tcache_operation(TEE_CACHECLEAN, outkey->q.data,\n\t\t\t\toutkey->q.length);\n\n\t\tDSA_TRACE(\"Prime G is defined\");\n\t\tcrypto_bignum_bn2bin(key->g,\n\t\t\t\t     outkey->g.data + l_bytes - in_g_size);\n\t\tcache_operation(TEE_CACHECLEAN, outkey->g.data,\n\t\t\t\toutkey->g.length);\n\n\t\tDSA_TRACE(\"Prime P is defined\");\n\t\tcrypto_bignum_bn2bin(key->p,\n\t\t\t\t     outkey->p.data + l_bytes - in_p_size);\n\t\tcache_operation(TEE_CACHECLEAN, outkey->p.data,\n\t\t\t\toutkey->p.length);\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Convert Crypto DSA Private Key to local Keypair Key\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @l_bytes   Prime p size in bytes\n * @n_bytes   Subprime q size in bytes\n */\nstatic enum caam_status do_keypriv_conv(struct caam_dsa_keypair *outkey,\n\t\t\t\t\tconst struct dsa_keypair *inkey,\n\t\t\t\t\tsize_t l_bytes, size_t n_bytes)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t field_size = 0;\n\n\tDSA_TRACE(\"DSA Convert Key Private size l=%zu bytes, n=%zu bytes\",\n\t\t  l_bytes, n_bytes);\n\n\t/* Generator */\n\tretstatus = caam_calloc_buf(&outkey->g, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of g to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->g);\n\tcrypto_bignum_bn2bin(inkey->g, outkey->g.data + l_bytes - field_size);\n\n\t/* Prime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->p, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of p to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->p);\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data + l_bytes - field_size);\n\n\t/* Subprime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->q, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of q to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->q);\n\tcrypto_bignum_bn2bin(inkey->q, outkey->q.data + n_bytes - field_size);\n\n\t/* Private key is only scalar x of n bytes */\n\tretstatus = caam_calloc_buf(&outkey->x, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of x to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->x);\n\tcrypto_bignum_bn2bin(inkey->x, outkey->x.data + n_bytes - field_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->q.data, outkey->q.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->x.data, outkey->x.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto DSA Public Key to local DSA Keypair Key\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @l_bytes   Prime p size in bytes\n * @n_bytes   Subprime q size in bytes\n */\nstatic enum caam_status do_keypub_conv(struct caam_dsa_keypair *outkey,\n\t\t\t\t       const struct dsa_public_key *inkey,\n\t\t\t\t       size_t l_bytes, size_t n_bytes)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t field_size = 0;\n\n\tDSA_TRACE(\"DSA Convert Public Key size l=%zu bytes, n=%zu bytes\",\n\t\t  l_bytes, n_bytes);\n\n\t/* Generator */\n\tretstatus = caam_calloc_buf(&outkey->g, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of g to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->g);\n\tcrypto_bignum_bn2bin(inkey->g, outkey->g.data + l_bytes - field_size);\n\n\t/* Prime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->p, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of p to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->p);\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data + l_bytes - field_size);\n\n\t/* Subprime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->q, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of q to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->q);\n\tcrypto_bignum_bn2bin(inkey->q, outkey->q.data + n_bytes - field_size);\n\n\t/* Public key is only scalar y of l bytes */\n\tretstatus = caam_calloc_buf(&outkey->y, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of y to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->y);\n\tcrypto_bignum_bn2bin(inkey->y, outkey->y.data + l_bytes - field_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->q.data, outkey->q.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->y.data, outkey->y.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Allocate a TEE DSA keypair.\n *\n * @key        Keypair\n * @l_bits     L bits size (prime p size)\n * @n_bits     N bits size (subprime q size)\n */\nstatic TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\t/* Allocate Private key X */\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Allocate a DSA Public Key\n *\n * @key        Public Key\n * @l_bits     L bits size (prime p size)\n * @n_bits     N bits size (subprime q size)\n */\nstatic TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Generates an DSA keypair\n * Keypair @key contains the input primes p, g and generator g values\n * The function computes private x and public y.\n *\n * @key        [in/out] Keypair\n * @l_bits     L bits size (prime p size)\n * @n_bits     N bits size (subprime q size)\n */\nstatic TEE_Result do_gen_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t size_t n_bits)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_dsa_keypair caam_dsa_key = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tsize_t l_bytes = l_bits / 8;\n\tsize_t n_bytes = n_bits / 8;\n\n\tDSA_TRACE(\"Generate Key - Private (%zu bits) and Public (%zu bits)\",\n\t\t  n_bits, l_bits);\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_GEN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Allocate Private Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dsa_key.x, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dsa_key.x.data,\n\t\t\tcaam_dsa_key.x.length);\n\n\t/* Allocate Public Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dsa_key.y, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dsa_key.y.data,\n\t\t\tcaam_dsa_key.y.length);\n\n\t/* Generator and Prime */\n\tret = get_keypair_domain_params(&caam_dsa_key, key, l_bytes, n_bytes);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/*\n\t * Build the descriptor using the PDB Public Key generation\n\t * block (PD=0)\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DL_KEY_L_SIZE(l_bytes) |\n\t\t\t\t PDB_DL_KEY_N_SIZE(n_bytes));\n\tcaam_desc_add_ptr(desc, caam_dsa_key.p.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.q.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.g.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.x.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.y.paddr);\n\tcaam_desc_add_word(desc, PK_KEYPAIR_GEN(DL));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dsa_key.x.data,\n\t\t\t\tcaam_dsa_key.x.length);\n\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dsa_key.y.data,\n\t\t\t\tcaam_dsa_key.y.length);\n\n\t\t/* Copy Private and Public keypair */\n\t\tret = crypto_bignum_bin2bn(caam_dsa_key.x.data,\n\t\t\t\t\t   caam_dsa_key.x.length, key->x);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tret = crypto_bignum_bin2bn(caam_dsa_key.y.data,\n\t\t\t\t\t   caam_dsa_key.y.length, key->y);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tDSA_DUMPBUF(\"X\", caam_dsa_key.x.data, caam_dsa_key.x.length);\n\t\tDSA_DUMPBUF(\"Y\", caam_dsa_key.y.data, caam_dsa_key.y.length);\n\t} else {\n\t\tDSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&caam_dsa_key);\n\n\treturn ret;\n}\n\n/*\n * Signature of DSA message\n * Note : the message to sign is already hashed\n *\n * @sdata    [in/out] DSA data to sign / Signature\n * @l_bytes  L bytes size (prime p size)\n * @n_bytes  N bytes size (subprime q size)\n */\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata, size_t l_bytes,\n\t\t\t  size_t n_bytes)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct dsa_keypair *inkey = sdata->key;\n\tstruct caam_dsa_keypair dsakey = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tsize_t sign_len = 0;\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tDSA_TRACE(\"DSA Signature\");\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SIGN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the private key to a local key */\n\tretstatus = do_keypriv_conv(&dsakey, inkey, l_bytes, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\tDSA_DUMPBUF(\"Message\", sdata->message.data, sdata->message.length);\n\n\t/*\n\t * Re-allocate the signature result buffer with a maximum size\n\t * of the roundup to 16 bytes of the secure size in bytes if\n\t * the signature buffer is not aligned or too short.\n\t *\n\t *  - 1st Part: size_sec\n\t *  - 2nd Part: size_sec roundup to 16 bytes\n\t */\n\tsign_len = ROUNDUP(sdata->size_sec, 16) + sdata->size_sec;\n\n\tret = caam_dmaobj_output_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t\tsdata->signature.length, sign_len);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_C;\n\n\t/* Prepare the 2nd Part of the signature. Derive from sign_c */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tROUNDUP(sdata->size_sec, 16));\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/*\n\t * Build the descriptor using Predifined ECC curve\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DSA_SIGN_N(n_bytes) |\n\t\t\t\t PDB_DSA_SIGN_L(l_bytes) | pdb_sgt_flags);\n\t/* Prime number */\n\tcaam_desc_add_ptr(desc, dsakey.p.paddr);\n\t/* Prime Modulus */\n\tcaam_desc_add_ptr(desc, dsakey.q.paddr);\n\t/* Generator */\n\tcaam_desc_add_ptr(desc, dsakey.g.paddr);\n\t/* Secret key */\n\tcaam_desc_add_ptr(desc, dsakey.x.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_SIGN(DL));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\t/* Limit the copy to 2 * sdata->size_sec */\n\t\tsign_c.orig.length = 2 * sdata->size_sec;\n\t\tsdata->signature.length = caam_dmaobj_copy_to_orig(&sign_c);\n\n\t\tDSA_DUMPBUF(\"Signature\", sdata->signature.data,\n\t\t\t    sdata->signature.length);\n\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tDSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&dsakey);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_c);\n\tcaam_dmaobj_free(&sign_d);\n\n\treturn ret;\n}\n\n/*\n * Verification of the Signature of DSA message\n * Note the message is already hashed\n *\n * @sdata   [in/out] DSA Signature to verify\n * @l_bytes  L bytes size (prime p size)\n * @n_bytes  N bytes size (subprime q size)\n */\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata, size_t l_bytes,\n\t\t\t    size_t n_bytes)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct dsa_public_key *inkey = sdata->key;\n\tstruct caam_dsa_keypair dsakey = { };\n\tstruct caambuf tmp = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tDSA_TRACE(\"DSA Verify\");\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_VERIFY);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&dsakey, inkey, l_bytes, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\t/*\n\t * Prepare the 1st Part of the signature\n\t * Handle the full signature in case signature buffer needs to\n\t * be reallocated.\n\t */\n\tret = caam_dmaobj_input_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t       sdata->signature.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_C;\n\n\t/* Prepare the 2nd Part of the signature, derive from sign_c */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tsdata->size_sec);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/* Allocate a Temporary buffer used by the CAAM */\n\tretstatus = caam_alloc_align_buf(&tmp, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build the descriptor using Predifined ECC curve\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DSA_VERIF_N(n_bytes) |\n\t\t\t\t PDB_DSA_VERIF_L(l_bytes) | pdb_sgt_flags);\n\t/* Prime number */\n\tcaam_desc_add_ptr(desc, dsakey.p.paddr);\n\t/* Prime Modulus */\n\tcaam_desc_add_ptr(desc, dsakey.q.paddr);\n\t/* Generator */\n\tcaam_desc_add_ptr(desc, dsakey.g.paddr);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, dsakey.y.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Temporary buffer */\n\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_VERIFY(DL));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tcache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\tif (retstatus == CAAM_JOB_STATUS && !jobctx.status) {\n\t\tDSA_TRACE(\"DSA Verify Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = TEE_ERROR_SIGNATURE_INVALID;\n\t} else if (retstatus != CAAM_NO_ERROR) {\n\t\tDSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t} else {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&dsakey);\n\tcaam_free_buf(&tmp);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_c);\n\tcaam_dmaobj_free(&sign_d);\n\n\treturn ret;\n}\n\n/*\n * Registration of the DSA Driver\n */\nstatic struct drvcrypt_dsa driver_dsa = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.alloc_publickey = do_allocate_publickey,\n\t.gen_keypair = do_gen_keypair,\n\t.sign = do_sign,\n\t.verify = do_verify,\n};\n\nenum caam_status caam_dsa_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base) &&\n\t    drvcrypt_register_dsa(&driver_dsa) == TEE_SUCCESS)\n\t\tretstatus = CAAM_NO_ERROR;\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2018-2021 NXP\n *\n * Implementation of ECC functions\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <mm/core_memprot.h>\n#include <string.h>\n#include <tee/cache.h>\n\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_KEY_GEN 8\n#define MAX_DESC_SIGN    13\n#define MAX_DESC_VERIFY  15\n#define MAX_DESC_SHARED  10\n#else\n#define MAX_DESC_KEY_GEN 6\n#define MAX_DESC_SIGN    9\n#define MAX_DESC_VERIFY  10\n#define MAX_DESC_SHARED  7\n#endif\n\n/*\n * Definition of the local ECC Keypair\n *   Public Key format (x, y)\n *   Private Key format (d)\n */\nstruct caam_ecc_keypair {\n\tstruct caambuf xy;\n\tstruct caambuf d;\n};\n\n/*\n * Free local ECC keypair\n *\n * @key ECC keypair\n */\nstatic void do_keypair_free(struct caam_ecc_keypair *key)\n{\n\tcaam_free_buf(&key->xy);\n\tcaam_free_buf(&key->d);\n}\n\n/*\n * Convert Crypto ECC Key to local ECC Public Key\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @size_sec  Security size in bytes\n */\nstatic enum caam_status do_keypub_conv(struct caam_ecc_keypair *outkey,\n\t\t\t\t       const struct ecc_public_key *inkey,\n\t\t\t\t       size_t size_sec)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t x_size = 0;\n\tsize_t y_size = 0;\n\n\tECC_TRACE(\"ECC Convert Public Key size %zu bytes\", size_sec);\n\n\t/* Point (x y) is twice security key size */\n\tretstatus = caam_calloc_buf(&outkey->xy, 2 * size_sec);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Copy x and y and get the number of bytes to pad with 0's */\n\tx_size = crypto_bignum_num_bytes(inkey->x);\n\tcrypto_bignum_bn2bin(inkey->x, outkey->xy.data + size_sec - x_size);\n\n\ty_size = crypto_bignum_num_bytes(inkey->y);\n\tcrypto_bignum_bn2bin(inkey->y, outkey->xy.data + 2 * size_sec - y_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->xy.data, outkey->xy.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto ECC Key to local ECC Keypair Key\n * Don't convert the exponent e not used in decrytion\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @size_sec  Security size in bytes\n */\nstatic enum caam_status do_keypair_conv(struct caam_ecc_keypair *outkey,\n\t\t\t\t\tconst struct ecc_keypair *inkey,\n\t\t\t\t\tsize_t size_sec)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t d_size = 0;\n\n\tECC_TRACE(\"ECC Convert Keypair size %zu bytes\", size_sec);\n\n\t/* Private key is only scalar d of sec_size bytes */\n\tretstatus = caam_calloc_buf(&outkey->d, size_sec);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of d to pad with 0's */\n\td_size = crypto_bignum_num_bytes(inkey->d);\n\tcrypto_bignum_bn2bin(inkey->d, outkey->d.data + size_sec - d_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->d.data, outkey->d.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert TEE ECC Curve to CAAM ECC Curve\n *\n * @tee_curve  TEE ECC Curve\n */\nstatic enum caam_ecc_curve get_caam_curve(uint32_t tee_curve)\n{\n\tenum caam_ecc_curve caam_curve = CAAM_ECC_UNKNOWN;\n\n\tif (tee_curve > 0 &&\n\t    tee_curve < CAAM_ECC_MAX + TEE_ECC_CURVE_NIST_P192) {\n\t\t/*\n\t\t * Realign TEE Curve assuming NIST_P192 is the first entry in\n\t\t * the list of supported ECC curves.\n\t\t */\n\t\tcaam_curve = tee_curve - TEE_ECC_CURVE_NIST_P192\n\t\t\t     + CAAM_ECC_P192;\n\t}\n\n\treturn caam_curve;\n}\n\n/*\n * Allocate a ECC keypair\n *\n * @key        Keypair\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_keypair(struct ecc_keypair *key,\n\t\t\t\t      uint32_t type __unused,\n\t\t\t\t      size_t size_bits)\n{\n\tECC_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Secure Scalar */\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err;\n\n\t/* Allocate Public coordinate X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public coordinate Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tECC_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Allocate an ECC Public Key\n *\n * @key        Public Key\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_publickey(struct ecc_public_key *key,\n\t\t\t\t\tuint32_t type __unused,\n\t\t\t\t\tsize_t size_bits)\n{\n\tECC_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Public coordinate X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public coordinate Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tECC_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Free an ECC public key\n *\n * @key  Public Key\n */\nstatic void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n}\n\n/*\n * Generate ECC keypair\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits multiple of 8 bits\n */\nstatic TEE_Result do_gen_keypair(struct ecc_keypair *key, size_t key_size)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct caambuf d = { };\n\tstruct caambuf xy = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\n\tECC_TRACE(\"Generate Keypair of %zu bits\", key_size);\n\n\t/* The key size must be a multiple of 8 bits */\n\tkey_size = ROUNDUP(key_size, 8);\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(key->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_GEN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Allocate secure and public keys in one buffer\n\t * Secure key size = key_size align in bytes\n\t * Public key size = (key_size * 2) align in bytes\n\t */\n\tretstatus = caam_alloc_align_buf(&d, (key_size / 8) * 3);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Build the xy buffer to simplify the code */\n\txy.data = d.data + key_size / 8;\n\txy.length = 2 * (key_size / 8);\n\txy.paddr = d.paddr + key_size / 8;\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_PKGEN_PD1 | PDB_ECC_ECDSEL(curve));\n\tcaam_desc_add_ptr(desc, d.paddr);\n\tcaam_desc_add_ptr(desc, xy.paddr);\n\tcaam_desc_add_word(desc, PK_KEYPAIR_GEN(ECC));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tcache_operation(TEE_CACHEFLUSH, d.data, d.length);\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tcache_operation(TEE_CACHEINVALIDATE, d.data, d.length);\n\n\t\t/* Copy all keypair parameters */\n\t\tret = crypto_bignum_bin2bn(d.data, key_size / 8, key->d);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tret = crypto_bignum_bin2bn(xy.data, xy.length / 2, key->x);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tret = crypto_bignum_bin2bn(xy.data + xy.length / 2,\n\t\t\t\t\t   xy.length / 2, key->y);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tECC_DUMPBUF(\"D\", d.data, key_size / 8);\n\t\tECC_DUMPBUF(\"X\", xy.data, xy.length / 2);\n\t\tECC_DUMPBUF(\"Y\", xy.data + xy.length / 2, xy.length / 2);\n\t} else {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tcaam_free_buf(&d);\n\n\treturn ret;\n}\n\n/*\n * Signature of ECC message\n * Note the message to sign is already hashed\n *\n * @sdata   [in/out] ECC data to sign / Signature\n */\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct ecc_keypair *inkey = sdata->key;\n\tstruct caam_ecc_keypair ecckey = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tsize_t sign_len = 0;\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tECC_TRACE(\"ECC Signature\");\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(inkey->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SIGN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the private key to a local key */\n\tretstatus = do_keypair_conv(&ecckey, inkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\tECC_DUMPBUF(\"Message\", sdata->message.data, sdata->message.length);\n\n\t/*\n\t * ReAllocate the signature result buffer with a maximum size\n\t * of the roundup to 16 bytes of the secure size in bytes if\n\t * the signature buffer is not aligned or too short.\n\t *\n\t *  - 1st Part: size_sec\n\t *  - 2nd Part: size_sec roundup to 16 bytes\n\t */\n\tsign_len = ROUNDUP(sdata->size_sec, 16) + sdata->size_sec;\n\n\tret = caam_dmaobj_output_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t\tsdata->signature.length, sign_len);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_C;\n\n\t/* Derive sign_d from created sign_c DMA object */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tROUNDUP(sdata->size_sec, 16));\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_PKSIGN_PD1 | PDB_ECC_ECDSEL(curve) |\n\t\t\t\t pdb_sgt_flags);\n\t/* Secret key */\n\tcaam_desc_add_ptr(desc, ecckey.d.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_SIGN(ECC));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tsign_c.orig.length = 2 * sdata->size_sec;\n\t\tsdata->signature.length = caam_dmaobj_copy_to_orig(&sign_c);\n\n\t\tECC_DUMPBUF(\"Signature\", sdata->signature.data,\n\t\t\t    sdata->signature.length);\n\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&ecckey);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_d);\n\tcaam_dmaobj_free(&sign_c);\n\n\treturn ret;\n}\n\n/*\n * Verification of the Signature of ECC message\n * Note the message is already hashed\n *\n * @sdata   [in/out] ECC Signature to verify\n */\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct ecc_public_key *inkey = sdata->key;\n\tstruct caam_ecc_keypair ecckey = { };\n\tstruct caambuf tmp = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tECC_TRACE(\"ECC Verify\");\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(inkey->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_VERIFY);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&ecckey, inkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\t/*\n\t * Prepare the 1st Part of the signature\n\t * Handle the full signature in case signature buffer needs to\n\t * be reallocated.\n\t */\n\tret = caam_dmaobj_input_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t       sdata->signature.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_C;\n\n\t/* Prepare the 2nd Part of the signature, derived from sign_c */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tsdata->size_sec);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/* Allocate a Temporary buffer used by the CAAM */\n\tretstatus = caam_alloc_align_buf(&tmp, 2 * sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_PKVERIFY_PD1 | PDB_ECC_ECDSEL(curve) |\n\t\t\t\t pdb_sgt_flags);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, ecckey.xy.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Temporary buffer */\n\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_VERIFY(ECC));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tcache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_JOB_STATUS && !jobctx.status) {\n\t\tECC_TRACE(\"ECC Verify Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = TEE_ERROR_SIGNATURE_INVALID;\n\t} else if (retstatus != CAAM_NO_ERROR) {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t} else {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&ecckey);\n\tcaam_free_buf(&tmp);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_c);\n\tcaam_dmaobj_free(&sign_d);\n\n\treturn ret;\n}\n\n/*\n * Compute the shared secret data from ECC Private key and Public Key\n *\n * @sdata   [in/out] ECC Shared Secret data\n */\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct ecc_keypair *inprivkey = sdata->key_priv;\n\tstruct ecc_public_key *inpubkey = sdata->key_pub;\n\tstruct caam_ecc_keypair ecckey = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj secret = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tECC_TRACE(\"ECC Shared Secret\");\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(inpubkey->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SHARED);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Private key to local key */\n\tretstatus = do_keypair_conv(&ecckey, inprivkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&ecckey, inpubkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Re-allocate the secret result buffer with a maximum size\n\t * of the secret size if not cache aligned\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&secret, sdata->secret.data,\n\t\t\t\t\tsdata->secret.length, sdata->size_sec);\n\tif (ret)\n\t\tgoto out;\n\n\tif (secret.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKDH_SECRET;\n\n\tcaam_dmaobj_cache_push(&secret);\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_SHARED_SECRET_PD1 | PDB_ECC_ECDSEL(curve) |\n\t\t\t\t pdb_sgt_flags);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, ecckey.xy.paddr);\n\t/* Private key */\n\tcaam_desc_add_ptr(desc, ecckey.d.paddr);\n\t/* Output secret */\n\tcaam_desc_add_ptr(desc, secret.sgtbuf.paddr);\n\n\tcaam_desc_add_word(desc, SHARED_SECRET(ECC));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tsdata->secret.length = caam_dmaobj_copy_to_orig(&secret);\n\n\t\tECC_DUMPBUF(\"Secret\", sdata->secret.data, sdata->secret.length);\n\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&ecckey);\n\tcaam_dmaobj_free(&secret);\n\n\treturn ret;\n}\n\n/*\n * Registration of the ECC Driver\n */\nstatic struct drvcrypt_ecc driver_ecc = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.alloc_publickey = do_allocate_publickey,\n\t.free_publickey = do_free_publickey,\n\t.gen_keypair = do_gen_keypair,\n\t.sign = do_sign,\n\t.verify = do_verify,\n\t.shared_secret = do_shared_secret,\n};\n\nenum caam_status caam_ecc_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base))\n\t\tif (drvcrypt_register_ecc(&driver_ecc) == TEE_SUCCESS)\n\t\t\tretstatus = CAAM_NO_ERROR;\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2018-2021 NXP\n *\n * CAAM RSA manager.\n * Implementation of RSA functions\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_io.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <drvcrypt_math.h>\n#include <mm/core_memprot.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n\n#include \"local.h\"\n\n/*\n * Definition of the maximum bits of Exponent e\n * Refer to sp800-56b\n */\n#define MAX_BITS_EXP_E 256\n\n/*\n * Define the maximum number of entries in a descriptor\n * function of the encrypt/decrypt and private key format\n */\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_ENC   (8 + 4)\n#define MAX_DESC_DEC_1 (7 + 2 + 4)\n#define MAX_DESC_DEC_2 (11 + 2 + 7)\n#define MAX_DESC_DEC_3 (13 + 2 + 10)\n/* Define the maximum number of entries in the RSA Finish Key descriptor */\n#define MAX_DESC_KEY_FINISH 24\n#else\n#define MAX_DESC_ENC\t    8\n#define MAX_DESC_DEC_1\t    (7 + 2)\n#define MAX_DESC_DEC_2\t    (11 + 2)\n#define MAX_DESC_DEC_3\t    (13 + 2)\n/* Define the maximum number of entries in the RSA Finish Key descriptor */\n#define MAX_DESC_KEY_FINISH 15\n#endif /* CFG_CAAM_64BIT */\n\nstatic TEE_Result do_caam_encrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation);\nstatic TEE_Result do_caam_decrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation);\n\n/*\n * Definition of the local RSA keypair\n *   Public Key Format: (n, e)\n *   Private Key Format #1: (n, d)\n *   Private Key Format #2: (p, q, d)\n *   Private Key Format #3: (p, q, dp, dq, qp)\n */\nstruct caam_rsa_keypair {\n\tuint8_t format;\t   /* Define the Private Key Format (1, 2 or 3) */\n\tstruct caambuf n;  /* Modulus [n = p * q] */\n\tstruct caambuf e;  /* Public Exponent 65537 <= e < 2^256 */\n\tstruct caambuf d;  /* Private Exponent [d = 1/e mod LCM(p-1, q-1)] */\n\tstruct caambuf p;  /* Private Prime p */\n\tstruct caambuf q;  /* Private Prime q */\n\tstruct caambuf dp; /* Private [dp = d mod (p-1)] */\n\tstruct caambuf dq; /* Private [dq = d mod (q-1)] */\n\tstruct caambuf qp; /* Private [qp = 1/q mod p] */\n};\n\n#define RSA_PRIVATE_KEY_FORMAT_1 1\n#define RSA_PRIVATE_KEY_FORMAT_2 2\n#define RSA_PRIVATE_KEY_FORMAT_3 3\n\n/* CAAM Era version */\nstatic uint8_t caam_era;\n\n/*\n * Free RSA keypair\n *\n * @key  RSA keypair\n */\nstatic void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}\n\n/*\n * Free local caam RSA keypair\n *\n * @key  caam RSA keypair\n */\nstatic void do_keypair_free(struct caam_rsa_keypair *key)\n{\n\tcaam_free_buf(&key->e);\n\tcaam_free_buf(&key->n);\n\tcaam_free_buf(&key->d);\n\n\tif (key->format > RSA_PRIVATE_KEY_FORMAT_1 && key->p.data) {\n\t\tkey->p.length += key->q.length;\n\t\tcaam_free_buf(&key->p);\n\t}\n\n\tif (key->format > RSA_PRIVATE_KEY_FORMAT_2 && key->dp.data) {\n\t\tkey->dp.length += key->dq.length + key->qp.length;\n\t\tcaam_free_buf(&key->dp);\n\t}\n}\n\n/*\n * Convert Crypto RSA Key to local RSA Public Key\n * Ensure Key is push in physical memory\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypub_conv(struct caam_rsa_keypair *outkey,\n\t\t\t\t       const struct rsa_public_key *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\n\tRSA_TRACE(\"RSA Convert Public Key size N=%zu\",\n\t\t  crypto_bignum_num_bytes(inkey->n));\n\n\tretstatus = caam_calloc_align_buf(&outkey->e,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->e));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\tgoto exit_conv;\n\n\tcrypto_bignum_bn2bin(inkey->e, outkey->e.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->e.data, outkey->e.length);\n\n\tretstatus = caam_calloc_align_buf(&outkey->n,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->n));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\tgoto exit_conv;\n\n\tcrypto_bignum_bn2bin(inkey->n, outkey->n.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->n.data, outkey->n.length);\n\n\treturn CAAM_NO_ERROR;\n\nexit_conv:\n\tdo_keypair_free(outkey);\n\n\treturn CAAM_OUT_MEMORY;\n}\n\n/*\n * Convert Crypto RSA Key additional fields of the key format #3\n * Optional fields (dp, dq, qp)\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv_f3(struct caam_rsa_keypair *outkey,\n\t\t\t\t\t   const struct rsa_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tsize_t size_p = 0;\n\tsize_t size_q = 0;\n\tsize_t size_dp = 0;\n\tsize_t size_dq = 0;\n\tsize_t size_qp = 0;\n\n\tsize_p = outkey->p.length;\n\tsize_q = outkey->q.length;\n\tsize_dp = crypto_bignum_num_bytes(inkey->dp);\n\tsize_dq = crypto_bignum_num_bytes(inkey->dq);\n\tsize_qp = crypto_bignum_num_bytes(inkey->qp);\n\n\t/* Check that dp, dq and qp size not exceed p and q size */\n\tif (size_dp > size_p || size_dq > size_q || size_qp > size_p)\n\t\treturn CAAM_FAILURE;\n\n\t/*\n\t * If one of the parameters dp, dq or qp are not filled,\n\t * returns immediately. This is not an error.\n\t */\n\tif (!size_dp || !size_dq || !size_qp)\n\t\treturn CAAM_NO_ERROR;\n\n\t/*\n\t * CAAM is assuming that:\n\t *    - dp and dq are same size as p\n\t *    - dq same size as q\n\t *\n\t * Because calculation of dp, dq and qp can be less\n\t * than above assumption, force the dp, dq and qp\n\t * buffer size.\n\t */\n\t/* Allocate one buffer for the 3 fields */\n\tretstatus =\n\t\tcaam_calloc_align_buf(&outkey->dp, size_p + size_q + size_p);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn CAAM_OUT_MEMORY;\n\n\t/* Field dp */\n\toutkey->dp.length = size_p;\n\n\t/*\n\t * Ensure buffer is copied starting with 0's\n\t * if size_dp != size_p\n\t */\n\tcrypto_bignum_bn2bin(inkey->dp, outkey->dp.data + size_p - size_dp);\n\n\t/* Field dq */\n\toutkey->dq.data = outkey->dp.data + size_p;\n\toutkey->dq.length = size_q;\n\toutkey->dq.paddr = outkey->dp.paddr + size_p;\n\n\t/*\n\t * Ensure buffer is copied starting with 0's\n\t * if size_dq != size_q\n\t */\n\tcrypto_bignum_bn2bin(inkey->dq, outkey->dq.data + size_q - size_dq);\n\n\t/* Field qp */\n\toutkey->qp.data = outkey->dq.data + size_q;\n\toutkey->qp.length = size_p;\n\toutkey->qp.paddr = outkey->dq.paddr + size_q;\n\n\t/*\n\t * Ensure buffer is copied starting with 0's\n\t * if size_qp != size_p\n\t */\n\tcrypto_bignum_bn2bin(inkey->qp, outkey->qp.data + size_p - size_qp);\n\n\t/* Push fields value to the physical memory */\n\tcache_operation(TEE_CACHECLEAN, outkey->dp.data,\n\t\t\toutkey->dp.length + outkey->dq.length +\n\t\t\t\toutkey->qp.length);\n\n\toutkey->format = RSA_PRIVATE_KEY_FORMAT_3;\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto RSA Key additional fields of the key format #2\n * Optional fields (p, q)\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv_f2(struct caam_rsa_keypair *outkey,\n\t\t\t\t\t   const struct rsa_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tsize_t size_p = 0;\n\tsize_t size_q = 0;\n\n\tsize_p = crypto_bignum_num_bytes(inkey->p);\n\tsize_q = crypto_bignum_num_bytes(inkey->q);\n\n\t/*\n\t * If the Prime P or Prime Q are not filled, returns\n\t * immediately. This is not an error.\n\t */\n\tif (size_p || !size_q)\n\t\treturn CAAM_NO_ERROR;\n\n\t/* Allocate one buffer for both */\n\tretstatus = caam_calloc_align_buf(&outkey->p, size_p + size_q);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn CAAM_OUT_MEMORY;\n\n\t/* Field Prime p */\n\toutkey->p.length = size_p;\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data);\n\n\t/* Field Prime q */\n\toutkey->q.data = outkey->p.data + size_p;\n\toutkey->q.length = size_q;\n\toutkey->q.paddr = outkey->p.paddr + size_p;\n\n\tcrypto_bignum_bn2bin(inkey->q, outkey->q.data);\n\n\t/* Push fields value to the physical memory */\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, size_p + size_q);\n\n\toutkey->format = RSA_PRIVATE_KEY_FORMAT_2;\n\n\tif (CFG_NXP_CAAM_RSA_KEY_FORMAT > RSA_PRIVATE_KEY_FORMAT_2) {\n\t\tretstatus = do_keypair_conv_f3(outkey, inkey);\n\t\tRSA_TRACE(\"do_keypair_conv_f3 returned 0x%\" PRIx32, retstatus);\n\t}\n\n\treturn retstatus;\n}\n\n/*\n * Convert Crypto RSA Key to local RSA Keypair Key\n * Ensure Key is push in physical memory\n * Don't convert the exponent e not used in decrytion\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv(struct caam_rsa_keypair *outkey,\n\t\t\t\t\tconst struct rsa_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\n\tRSA_TRACE(\"RSA Convert Keypair size N=%zu\",\n\t\t  crypto_bignum_num_bytes(inkey->n));\n\n\t/* Mandatory fields are n and d => Private Key Format #1 */\n\tretstatus = caam_calloc_align_buf(&outkey->n,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->n));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->n, outkey->n.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->n.data, outkey->n.length);\n\n\tretstatus = caam_calloc_align_buf(&outkey->d,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->d));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->d, outkey->d.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->d.data, outkey->d.length);\n\n\toutkey->format = RSA_PRIVATE_KEY_FORMAT_1;\n\n\tif (CFG_NXP_CAAM_RSA_KEY_FORMAT > RSA_PRIVATE_KEY_FORMAT_1) {\n\t\tretstatus = do_keypair_conv_f2(outkey, inkey);\n\t\tRSA_TRACE(\"do_keypair_conv_f2 returned 0x%\" PRIx32, retstatus);\n\t}\n\n\treturn retstatus;\n}\n\n/*\n * Allocate a RSA keypair\n *\n * @key        Keypair\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_keypair(struct rsa_keypair *key, size_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize all input key fields to 0 */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate the Public Exponent to maximum size */\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the Private Exponent [d = 1/e mod LCM(p-1, q-1)] */\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the Modulus (size_bits) [n = p * q] */\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the prime number p of size (size_bits / 2) */\n\tkey->p = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->p)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the prime number q of size (size_bits / 2) */\n\tkey->q = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->q)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate dp (size_bits / 2) [d mod (p-1)] */\n\tkey->dp = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->dp)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate dq (size_bits / 2) [d mod (q-1)] */\n\tkey->dq = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->dq)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate qp (size_bits / 2) [1/q mod p] */\n\tkey->qp = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->qp)\n\t\tgoto err_alloc_keypair;\n\n\treturn TEE_SUCCESS;\n\nerr_alloc_keypair:\n\tRSA_TRACE(\"Allocation error\");\n\n\tdo_free_keypair(key);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Allocate a RSA public key\n *\n * @key        Public Key\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\n\t/* Initialize all input key fields to 0 */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate the Public Exponent to maximum size */\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\n\t/* Allocate the Modulus (size_bits) [n = p * q] */\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\n\treturn TEE_SUCCESS;\n\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Free a RSA public key\n *\n * @key        Public Key\n */\nstatic void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}\n\n/*\n * Output the RSA keypair format 3 additional fields in bignumber object\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits\n */\nstatic TEE_Result gen_keypair_get_f3(struct rsa_keypair *key,\n\t\t\t\t     struct caam_rsa_keypair *genkey)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\n\tcache_operation(TEE_CACHEINVALIDATE, genkey->dp.data,\n\t\t\tgenkey->dp.length + genkey->dq.length +\n\t\t\t\tgenkey->qp.length);\n\n\tRSA_DUMPBUF(\"dp\", genkey->dp.data, genkey->dp.length);\n\tRSA_DUMPBUF(\"dq\", genkey->dq.data, genkey->dq.length);\n\tRSA_DUMPBUF(\"qp\", genkey->qp.data, genkey->qp.length);\n\n\tret = crypto_bignum_bin2bn(genkey->dp.data, genkey->dp.length, key->dp);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = crypto_bignum_bin2bn(genkey->dq.data, genkey->dq.length, key->dq);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = crypto_bignum_bin2bn(genkey->qp.data, genkey->qp.length, key->qp);\n\treturn ret;\n}\n\n/*\n * Output the RSA keypair format 2 additional fields in big number object\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits\n */\nstatic TEE_Result gen_keypair_get_f2(struct rsa_keypair *key,\n\t\t\t\t     struct caam_rsa_keypair *genkey)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\n\tcache_operation(TEE_CACHEINVALIDATE, genkey->p.data,\n\t\t\tgenkey->p.length + genkey->q.length);\n\n\tret = crypto_bignum_bin2bn(genkey->p.data, genkey->p.length, key->p);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = crypto_bignum_bin2bn(genkey->q.data, genkey->q.length, key->q);\n\n\tif (ret == TEE_SUCCESS && genkey->format > RSA_PRIVATE_KEY_FORMAT_2)\n\t\tret = gen_keypair_get_f3(key, genkey);\n\n\treturn ret;\n}\n\n/*\n * Generates a RSA keypair\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits\n */\nstatic TEE_Result do_gen_keypair(struct rsa_keypair *key, size_t key_size)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_rsa_keypair genkey = { };\n\tsize_t size_d = 0;\n\tsize_t size_n = 0;\n\tsize_t size_d_gen = 0;\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = 0;\n\tuint32_t desclen = 0;\n\tstruct prime_data_rsa prime = { };\n\n\tRSA_TRACE(\"Generate Keypair of %zu bits\", key_size);\n\n\tgenkey.format = CFG_NXP_CAAM_RSA_KEY_FORMAT;\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_FINISH);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit_gen_keypair;\n\t}\n\n\t/* First allocate primes p and q in one buffer */\n\tretstatus = caam_calloc_align_buf(&genkey.p, key_size / 8);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\t/* Prepare q */\n\tgenkey.p.length /= 2;\n\tgenkey.q.data = genkey.p.data + genkey.p.length;\n\tgenkey.q.length = genkey.p.length;\n\tgenkey.q.paddr = genkey.p.paddr + genkey.p.length;\n\n\t/* Allocate Public exponent to a caam buffer */\n\tretstatus = caam_calloc_buf(&genkey.e, crypto_bignum_num_bytes(key->e));\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\t/*\n\t * Allocate d and n in one buffer.\n\t * Size of d is (key_size + 1) bits - Add a 32 bits word to\n\t * retrieve the length of d generated by CAAM RSA Finalize Key\n\t */\n\tsize_d = sizeof(uint32_t) + key_size / 8 + 1;\n\tsize_n = key_size / 8;\n\n\tretstatus = caam_calloc_align_buf(&genkey.d, size_d + size_n);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\tgenkey.d.length = size_d;\n\tgenkey.n.data = genkey.d.data + size_d;\n\tgenkey.n.length = size_n;\n\tgenkey.n.paddr = genkey.d.paddr + size_d;\n\n\tif (genkey.format > RSA_PRIVATE_KEY_FORMAT_2) {\n\t\t/* Allocate dp, dq and qp in one buffer */\n\t\tretstatus = caam_calloc_align_buf(&genkey.dp,\n\t\t\t\t\t\t  ((key_size / 8) / 2) * 3);\n\t\tif (retstatus != CAAM_NO_ERROR) {\n\t\t\tret = caam_status_to_tee_result(retstatus);\n\t\t\tgoto exit_gen_keypair;\n\t\t}\n\n\t\tgenkey.dp.length /= 3;\n\t\t/* Prepare dq and qp */\n\t\tgenkey.dq.data = genkey.dp.data + genkey.dp.length;\n\t\tgenkey.dq.length = genkey.dp.length;\n\t\tgenkey.dq.paddr = genkey.dp.paddr + genkey.dp.length;\n\n\t\tgenkey.qp.data = genkey.dq.data + genkey.dq.length;\n\t\tgenkey.qp.length = genkey.dq.length;\n\t\tgenkey.qp.paddr = genkey.dq.paddr + genkey.dq.length;\n\t}\n\n\tcrypto_bignum_bn2bin(key->e, genkey.e.data);\n\n\tprime.era = caam_era;\n\tprime.key_size = key_size;\n\tprime.e = &genkey.e;\n\tprime.p = &genkey.p;\n\tprime.q = &genkey.q;\n\n\t/* Generate prime p and q */\n\tretstatus = caam_prime_rsa_gen(&prime);\n\tRSA_TRACE(\"Generate Prime P and Q returned 0x%\" PRIx32, retstatus);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\n\tcaam_desc_add_word(desc, 0);\n\tcaam_desc_add_word(desc, PDB_RSA_KEY_P_SIZE(genkey.p.length));\n\tcaam_desc_add_word(desc, PDB_RSA_KEY_N_SIZE(genkey.n.length) |\n\t\t\t\t\t PDB_RSA_KEY_E_SIZE(genkey.e.length));\n\n\tcaam_desc_add_ptr(desc, genkey.p.paddr);\n\tcaam_desc_add_ptr(desc, genkey.q.paddr);\n\tcaam_desc_add_ptr(desc, genkey.e.paddr);\n\tcaam_desc_add_ptr(desc, genkey.n.paddr);\n\tcaam_desc_add_ptr(desc, genkey.d.paddr + sizeof(uint32_t));\n\tcaam_desc_add_ptr(desc, genkey.d.paddr);\n\n\tif (genkey.format > RSA_PRIVATE_KEY_FORMAT_2) {\n\t\tcaam_desc_add_ptr(desc, genkey.dp.paddr);\n\t\tcaam_desc_add_ptr(desc, genkey.dq.paddr);\n\t\tcaam_desc_add_ptr(desc, genkey.qp.paddr);\n\t\tcaam_desc_add_word(desc, RSA_FINAL_KEY(ALL));\n\n\t\tcache_operation(TEE_CACHEFLUSH, genkey.dp.data,\n\t\t\t\tgenkey.dp.length + genkey.dq.length +\n\t\t\t\t\tgenkey.qp.length);\n\n\t} else {\n\t\tcaam_desc_add_word(desc, RSA_FINAL_KEY(N_D));\n\t}\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tjobctx.desc = desc;\n\tRSA_DUMPDESC(desc);\n\n\tcache_operation(TEE_CACHECLEAN, genkey.e.data, genkey.e.length);\n\tcache_operation(TEE_CACHEFLUSH, genkey.p.data,\n\t\t\tgenkey.p.length + genkey.q.length);\n\tcache_operation(TEE_CACHEFLUSH, genkey.d.data,\n\t\t\tgenkey.d.length + genkey.n.length);\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tcache_operation(TEE_CACHEINVALIDATE, genkey.d.data,\n\t\t\t\tgenkey.d.length + genkey.n.length);\n\n\t\tsize_d_gen = caam_read_val32(genkey.d.data);\n\t\tRSA_TRACE(\"D size %zu\", size_d_gen);\n\t\tRSA_DUMPBUF(\"N\", genkey.n.data, genkey.n.length);\n\t\tRSA_DUMPBUF(\"D\", genkey.d.data + sizeof(uint32_t), size_d_gen);\n\n\t\tret = crypto_bignum_bin2bn(genkey.n.data, genkey.n.length,\n\t\t\t\t\t   key->n);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto exit_gen_keypair;\n\n\t\tret = crypto_bignum_bin2bn(genkey.d.data + sizeof(uint32_t),\n\t\t\t\t\t   size_d_gen, key->d);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto exit_gen_keypair;\n\n\t\tif (genkey.format > RSA_PRIVATE_KEY_FORMAT_1)\n\t\t\tret = gen_keypair_get_f2(key, &genkey);\n\t} else {\n\t\tRSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nexit_gen_keypair:\n\tgenkey.d.length += genkey.n.length;\n\tgenkey.n.data = NULL;\n\tdo_keypair_free(&genkey);\n\n\tcaam_free_desc(&desc);\n\n\treturn ret;\n}\n\n/*\n * RSA EME-OAEP Decoding operation\n * Refer the chapter 7.1.2 Decryption operation of pkcs-1v2-1 specification\n *\n * @rsa_data  [in/out] RSA Data to encode\n */\nstatic TEE_Result do_oaep_decoding(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caambuf DB = { };\n\tstruct caambuf lHash = { };\n\tstruct caambuf seed = { };\n\tstruct caambuf dbMask = { };\n\tstruct caambuf maskedDB = { };\n\tstruct caambuf maskedSeed = { };\n\tstruct caambuf EM = { };\n\tsize_t db_size = 0;\n\tsize_t b01_idx = 0;\n\tsize_t db_len = 0;\n\tstruct drvcrypt_rsa_mgf mgf_data = { };\n\tstruct drvcrypt_rsa_ed dec_data = { };\n\tstruct drvcrypt_mod_op mod_op = { };\n\n\tRSA_TRACE(\"RSA OAEP Decoding\");\n\n\t/*\n\t * First Decryption of the Cipher to a EM of modulus size\n\t */\n\tretstatus = caam_calloc_align_buf(&EM, rsa_data->key.n_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tmemcpy(&dec_data, rsa_data, sizeof(dec_data));\n\tdec_data.message.data = EM.data;\n\tdec_data.message.length = EM.length;\n\n\tret = do_caam_decrypt(&dec_data, RSA_DECRYPT(NO));\n\n\tRSA_DUMPBUF(\"EM\", EM.data, EM.length);\n\n\t/*\n\t * DB = lHash' || PS || 0x01 || M\n\t * DB length = k - hLen - 1\n\t *\n\t * PS is a 0's buffer of length h - mLen - 2hLen - 2\n\t *\n\t *  k    is the key modulus length\n\t *  hLen is the Hash digest length\n\t *  mLen is the input RSA message length\n\t */\n\t/* Calculate the DB size */\n\tdb_size = rsa_data->key.n_size - rsa_data->digest_size - 1;\n\tRSA_TRACE(\"DB is %zu bytes\", db_size);\n\n\t/* Allocate the DB buffer */\n\tretstatus = caam_calloc_align_buf(&DB, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/*\n\t * Step a\n\t * Generate the lHash\n\t */\n\t/* Allocate the lHash buffer */\n\tretstatus = caam_calloc_align_buf(&lHash, rsa_data->digest_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tRSA_TRACE(\"Hash the RSA Label of %zu bytes\", rsa_data->label.length);\n\tret = tee_hash_createdigest(rsa_data->hash_algo, rsa_data->label.data,\n\t\t\t\t    rsa_data->label.length, lHash.data,\n\t\t\t\t    lHash.length);\n\tRSA_TRACE(\"Hash the RSA Label returned 0x%08\" PRIx32, ret);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_decrypt;\n\n\tRSA_DUMPBUF(\"lHash\", lHash.data, lHash.length);\n\n\t/* Allocate the seed buffer */\n\tretstatus = caam_calloc_align_buf(&seed, rsa_data->digest_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/* Allocate the dbMask buffer */\n\tretstatus = caam_calloc_align_buf(&dbMask, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/*\n\t * Step b\n\t * Split the EM string\n\t * EM = Y || maskedSeed || maskedDB\n\t *\n\t * Where:\n\t *   Y          size = 1 byte\n\t *   maskedSeed size = hLen\n\t *   maskedDB   size = k - hLen - 1 bytes\n\t *\n\t *  k    is the key modulus length\n\t *  hLen is the Hash digest length\n\t *  mLen is the input RSA message length\n\t *\n\t *  Note Y should have been remove during the\n\t */\n\tmaskedSeed.data = &EM.data[1];\n\tmaskedSeed.length = rsa_data->digest_size;\n\tmaskedSeed.paddr = EM.paddr + sizeof(uint8_t);\n\n\tmaskedDB.data = &EM.data[1 + rsa_data->digest_size];\n\tmaskedDB.length = dbMask.length;\n\tmaskedDB.paddr = EM.paddr + sizeof(uint8_t) + rsa_data->digest_size;\n\n\t/*\n\t * Step c\n\t * Generate a Mask of the maskedDB\n\t * seedMask = MGF(maskedDB, k - hLen - 1)\n\t *\n\t * Note: Use same buffer for seed and seedMask\n\t */\n\tmgf_data.hash_algo = rsa_data->hash_algo;\n\tmgf_data.digest_size = rsa_data->digest_size;\n\tmgf_data.seed.data = maskedDB.data;\n\tmgf_data.seed.length = maskedDB.length;\n\tmgf_data.mask.data = seed.data;\n\tmgf_data.mask.length = seed.length;\n\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_decrypt;\n\n\t/*\n\t * Step d\n\t * seed = maskedSeed xor seedMask\n\t *\n\t * Note: Use same buffer for seed and seedMask\n\t */\n\tmod_op.n.length = seed.length;\n\tmod_op.a.data = maskedSeed.data;\n\tmod_op.a.length = maskedSeed.length;\n\tmod_op.b.data = seed.data;\n\tmod_op.b.length = seed.length;\n\tmod_op.result.data = seed.data;\n\tmod_op.result.length = seed.length;\n\n\tretstatus = drvcrypt_xor_mod_n(&mod_op);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tRSA_DUMPBUF(\"Seed\", seed.data, seed.length);\n\n\t/*\n\t * Step e\n\t * Generate a Mask of the seed value\n\t * dbMask = MGF(seed, k - hLen - 1)\n\t */\n\tmgf_data.seed.data = seed.data;\n\tmgf_data.seed.length = seed.length;\n\tmgf_data.mask.data = dbMask.data;\n\tmgf_data.mask.length = dbMask.length;\n\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_decrypt;\n\n\t/*\n\t * Step f\n\t * DB = maskedDB xor dbMask\n\t */\n\tmod_op.n.length = DB.length;\n\tmod_op.a.data = maskedDB.data;\n\tmod_op.a.length = maskedDB.length;\n\tmod_op.b.data = dbMask.data;\n\tmod_op.b.length = dbMask.length;\n\tmod_op.result.data = DB.data;\n\tmod_op.result.length = DB.length;\n\n\tretstatus = drvcrypt_xor_mod_n(&mod_op);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tRSA_DUMPBUF(\"DB\", DB.data, DB.length);\n\n\t/*\n\t * Step g\n\t * Check the DB generated\n\t * DB = lHash' || PS || 0x01 || M\n\t *\n\t * Error if:\n\t *   - lHash' != lHash (First step - Hash the Label)\n\t *   - byte 0x01 between PS and M is not present\n\t */\n\t/* Check Hash values */\n\tif (memcmp(DB.data, lHash.data, lHash.length)) {\n\t\tRSA_TRACE(\"Hash error\");\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/* Find the byte 0x01 separating PS and M */\n\tfor (b01_idx = rsa_data->digest_size;\n\t     b01_idx < db_size && !DB.data[b01_idx]; b01_idx++)\n\t\t;\n\n\tif (b01_idx == db_size) {\n\t\tRSA_TRACE(\"byte 0x01 not present\");\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tdb_len = DB.length - b01_idx - 1;\n\n\tif (rsa_data->message.length < db_len) {\n\t\trsa_data->message.length = db_len;\n\t\tret = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\trsa_data->message.length = db_len;\n\tmemcpy(rsa_data->message.data, &DB.data[b01_idx + 1],\n\t       rsa_data->message.length);\n\n\tRSA_DUMPBUF(\"Message decrypted\", rsa_data->message.data,\n\t\t    rsa_data->message.length);\n\tret = TEE_SUCCESS;\n\nexit_oaep_decrypt:\n\tcaam_free_buf(&EM);\n\tcaam_free_buf(&DB);\n\tcaam_free_buf(&seed);\n\tcaam_free_buf(&dbMask);\n\tcaam_free_buf(&lHash);\n\n\treturn ret;\n}\n\n/*\n * RSA EME-OAEP Encoding operation\n * Refer the chapter 7.1.1 Encryption operation of pkcs-1v2-1 specification\n *\n * @rsa_data  [int/out] RSA Data to encode\n */\nstatic TEE_Result do_oaep_encoding(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus;\n\tstruct caambuf DB = { };\n\tstruct caambuf lHash = { };\n\tstruct caambuf seed = { };\n\tstruct caambuf dbMask = { };\n\tstruct caambuf maskedDB = { };\n\tstruct caambuf maskedSeed = { };\n\tstruct caambuf EM = { };\n\tsize_t db_size = 0;\n\tsize_t ps_size = 0;\n\tstruct drvcrypt_rsa_mgf mgf_data = { };\n\tstruct drvcrypt_rsa_ed enc_data = { };\n\tstruct drvcrypt_mod_op mod_op = { };\n\n\tRSA_TRACE(\"RSA OAEP Encoding\");\n\n\t/*\n\t * DB = lHash || PS || 0x01 || M\n\t * DB length = k - hLen - 1\n\t *\n\t * PS is a 0's buffer of length h - mLen - 2hLen - 2\n\t *\n\t *  k    is the key modulus length\n\t *  hLen is the Hash digest length\n\t *  mLen is the input RSA message length\n\t */\n\t/* Calculate the DB size */\n\tdb_size = rsa_data->key.n_size - rsa_data->digest_size - 1;\n\tRSA_TRACE(\"DB is %zu bytes\", db_size);\n\n\t/* Allocate the DB buffer */\n\tretstatus = caam_calloc_align_buf(&DB, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\t/*\n\t * Step a\n\t * Generate the lHash\n\t */\n\tlHash.length = rsa_data->digest_size;\n\tlHash.data = DB.data;\n\n\tRSA_TRACE(\"Hash the RSA Label of %zu bytes\", rsa_data->label.length);\n\tret = tee_hash_createdigest(rsa_data->hash_algo, rsa_data->label.data,\n\t\t\t\t    rsa_data->label.length, lHash.data,\n\t\t\t\t    lHash.length);\n\tRSA_TRACE(\"Hash the RSA Label returned 0x%08\" PRIx32, ret);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\tRSA_DUMPBUF(\"lHash\", lHash.data, lHash.length);\n\n\t/*\n\t * Step b\n\t * Add PS 0's\n\t * Note: DB is already filled with 0's at the allocation\n\t */\n\tps_size = rsa_data->key.n_size - rsa_data->message.length -\n\t\t  2 * rsa_data->digest_size - 2;\n\tRSA_TRACE(\"PS is %zu bytes\", ps_size);\n\n\t/*\n\t * Step c\n\t * Set the value 0x01 after the lHash and the PS\n\t * Concatenate result with input message\n\t */\n\tDB.data[lHash.length + ps_size] = 0x01;\n\tmemcpy(&DB.data[lHash.length + ps_size + 1], rsa_data->message.data,\n\t       rsa_data->message.length);\n\n\tRSA_DUMPBUF(\"DB\", DB.data, DB.length);\n\n\t/*\n\t * Step d\n\t * Generate a random seed of hLen\n\t */\n\t/* Allocate the seed buffer */\n\tretstatus = caam_calloc_align_buf(&seed, rsa_data->digest_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\t/* Allocate the dbMask buffer */\n\tretstatus = caam_calloc_align_buf(&dbMask, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\tret = crypto_rng_read(seed.data, seed.length);\n\tRSA_TRACE(\"Get seed of %zu bytes (ret = 0x%08\" PRIx32 \")\", seed.length,\n\t\t  ret);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\tRSA_DUMPBUF(\"Seed\", seed.data, seed.length);\n\n\t/*\n\t * Step e\n\t * Generate a Mask of the seed value\n\t * dbMask = MGF(seed, k - hLen - 1)\n\t */\n\tmgf_data.hash_algo = rsa_data->hash_algo;\n\tmgf_data.digest_size = rsa_data->digest_size;\n\tmgf_data.seed.data = seed.data;\n\tmgf_data.seed.length = seed.length;\n\tmgf_data.mask.data = dbMask.data;\n\tmgf_data.mask.length = dbMask.length;\n\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\t/*\n\t * Step f\n\t * maskedDB = DB xor dbMask\n\t */\n\tretstatus = caam_calloc_align_buf(&EM, rsa_data->key.n_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\tmaskedDB.data = &EM.data[1 + rsa_data->digest_size];\n\tmaskedDB.length = dbMask.length;\n\tmaskedDB.paddr = EM.paddr + sizeof(uint8_t) + rsa_data->digest_size;\n\n\tmod_op.n.length = maskedDB.length;\n\tmod_op.a.data = DB.data;\n\tmod_op.a.length = DB.length;\n\tmod_op.b.data = dbMask.data;\n\tmod_op.b.length = dbMask.length;\n\tmod_op.result.data = maskedDB.data;\n\tmod_op.result.length = maskedDB.length;\n\n\tret = drvcrypt_xor_mod_n(&mod_op);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\t/*\n\t * Step g\n\t * Generate a Mask of the maskedDB\n\t * seedMask = MGF(maskedDB, hLen)\n\t *\n\t * Note: Use same buffer for seedMask and maskedSeed\n\t */\n\tmaskedSeed.data = &EM.data[1];\n\tmaskedSeed.length = rsa_data->digest_size;\n\tmaskedSeed.paddr = EM.paddr + sizeof(uint8_t);\n\n\tmgf_data.seed.data = maskedDB.data;\n\tmgf_data.seed.length = maskedDB.length;\n\tmgf_data.mask.data = maskedSeed.data;\n\tmgf_data.mask.length = maskedSeed.length;\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\t/*\n\t * Step h\n\t * maskedSeed = seed xor seedMask\n\t */\n\tmod_op.n.length = maskedSeed.length;\n\tmod_op.a.data = seed.data;\n\tmod_op.a.length = seed.length;\n\tmod_op.b.data = maskedSeed.data;\n\tmod_op.b.length = maskedSeed.length;\n\tmod_op.result.data = maskedSeed.data;\n\tmod_op.result.length = maskedSeed.length;\n\n\tret = drvcrypt_xor_mod_n(&mod_op);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\tRSA_DUMPBUF(\"EM\", EM.data, EM.length);\n\n\t/*\n\t * Last Encryption of the EM of modulus size to Cipher\n\t */\n\tmemcpy(&enc_data, rsa_data, sizeof(enc_data));\n\n\tenc_data.message.data = EM.data;\n\tenc_data.message.length = EM.length;\n\n\tret = do_caam_encrypt(&enc_data, RSA_ENCRYPT(NO));\n\nexit_oaep_encrypt:\n\tcaam_free_buf(&DB);\n\tcaam_free_buf(&seed);\n\tcaam_free_buf(&dbMask);\n\tcaam_free_buf(&EM);\n\n\treturn ret;\n}\n\n/*\n * CAAM RSA Encryption of the input message to a cipher\n *\n * @rsa_data   [in/out] RSA Data to encrypt\n * @operation  CAAM RSA Encryption operation\n */\nstatic TEE_Result do_caam_encrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_rsa_keypair key = { };\n\tstruct caamdmaobj msg = { };\n\tstruct caamdmaobj cipher = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tuint32_t pdb_sgt_flags = 0;\n\n\tRSA_TRACE(\"RSA Encrypt mode %d\", rsa_data->rsa_id);\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_ENC);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit_encrypt;\n\t}\n\n\t/*\n\t * Convert TEE rsa key type to CAAM rsa key type\n\t * Push key value to memory\n\t */\n\tretstatus = do_keypub_conv(&key, rsa_data->key.key);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_encrypt;\n\t}\n\n\t/*\n\t * ReAllocate the cipher result buffer with a maximum size\n\t * of the Key Modulus's size (N) if not cache aligned\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&cipher, rsa_data->cipher.data,\n\t\t\t\t\trsa_data->cipher.length, key.n.length);\n\tif (ret)\n\t\tgoto exit_encrypt;\n\n\tif (cipher.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_ENC_SGT_G;\n\n\tcaam_dmaobj_cache_push(&cipher);\n\n\t/* Prepare the input message CAAM descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, rsa_data->message.data,\n\t\t\t\t       rsa_data->message.length);\n\tif (ret)\n\t\tgoto exit_encrypt;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_ENC_SGT_F;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_RSA_ENC_E_SIZE(key.e.length) |\n\t\t\t\t\t PDB_RSA_ENC_N_SIZE(key.n.length) |\n\t\t\t\t\t pdb_sgt_flags);\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\tcaam_desc_add_ptr(desc, key.n.paddr);\n\tcaam_desc_add_ptr(desc, key.e.paddr);\n\tcaam_desc_add_word(desc, PDB_RSA_ENC_F_SIZE(rsa_data->message.length));\n\tcaam_desc_add_word(desc, operation);\n\n\t/* Set the descriptor Header with length */\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\tRSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\trsa_data->cipher.length = caam_dmaobj_copy_to_orig(&cipher);\n\n\t\tRSA_DUMPBUF(\"Output\", rsa_data->cipher.data,\n\t\t\t    rsa_data->cipher.length);\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tRSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nexit_encrypt:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&key);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&cipher);\n\n\treturn ret;\n}\n\n/*\n * CAAM RSA Decryption of the input cipher to a message\n *\n * @rsa_data   [in/out] RSA Data to decrypt\n * @operation  CAAM RSA Decryption operation\n */\nstatic TEE_Result do_caam_decrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_rsa_keypair key = { };\n\tstruct caamdmaobj cipher = { };\n\tstruct caamdmaobj msg = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tuint32_t pdb_sgt_flags = 0;\n\tstruct caambuf size_msg = { };\n\tstruct caambuf tmp = { };\n\n\tRSA_TRACE(\"RSA Decrypt mode %d\", rsa_data->rsa_id);\n\n\t/*\n\t * Convert TEE rsa key type to CAAM rsa key type\n\t * Push key value to memory\n\t */\n\tretstatus = do_keypair_conv(&key, rsa_data->key.key);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tRSA_TRACE(\"do_keypair_conv returned 0x%\" PRIx32, retstatus);\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_decrypt;\n\t}\n\n\t/*\n\t * Allocate the temporary result buffer with a maximum size\n\t * of the Key Modulus's size (N)\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&msg, rsa_data->message.data,\n\t\t\t\t\trsa_data->message.length, key.n.length);\n\n\tif (ret)\n\t\tgoto exit_decrypt;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_DEC_SGT_F;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\t/* Allocate the returned computed size when PKCS V1.5 */\n\tif (operation == RSA_DECRYPT(PKCS_V1_5)) {\n\t\tretstatus = caam_alloc_align_buf(&size_msg, 4);\n\t\tif (retstatus != CAAM_NO_ERROR)\n\t\t\tgoto exit_decrypt;\n\n\t\tcache_operation(TEE_CACHEFLUSH, size_msg.data, size_msg.length);\n\t}\n\n\t/* Prepare the input cipher CAAM descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&cipher, rsa_data->cipher.data,\n\t\t\t\t       rsa_data->cipher.length);\n\n\tif (cipher.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_DEC_SGT_G;\n\n\tcaam_dmaobj_cache_push(&cipher);\n\n\t/* Allocate the job descriptor function of the Private key format */\n\tswitch (key.format) {\n\tcase RSA_PRIVATE_KEY_FORMAT_1:\n\t\tdesc = caam_calloc_desc(MAX_DESC_DEC_1);\n\t\tif (!desc) {\n\t\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto exit_decrypt;\n\t\t}\n\t\tbreak;\n\n\tcase RSA_PRIVATE_KEY_FORMAT_2:\n\tcase RSA_PRIVATE_KEY_FORMAT_3:\n\t\tif (key.format == RSA_PRIVATE_KEY_FORMAT_2)\n\t\t\tdesc = caam_calloc_desc(MAX_DESC_DEC_2);\n\t\telse\n\t\t\tdesc = caam_calloc_desc(MAX_DESC_DEC_3);\n\n\t\tif (!desc) {\n\t\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto exit_decrypt;\n\t\t}\n\t\t/* Allocate temporary buffers used by the CAAM */\n\t\tretstatus =\n\t\t\tcaam_alloc_align_buf(&tmp, key.p.length + key.q.length);\n\t\tif (retstatus != CAAM_NO_ERROR) {\n\t\t\tret = caam_status_to_tee_result(retstatus);\n\t\t\tgoto exit_decrypt;\n\t\t}\n\n\t\tcache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);\n\t\tbreak;\n\n\tdefault:\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto exit_decrypt;\n\t}\n\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\n\t/* Build the descriptor function of the Private Key format */\n\tswitch (key.format) {\n\tcase RSA_PRIVATE_KEY_FORMAT_1:\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_D_SIZE(key.d.length) |\n\t\t\t\t\t   PDB_RSA_DEC_N_SIZE(key.n.length) |\n\t\t\t\t\t   pdb_sgt_flags);\n\t\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, key.n.paddr);\n\t\tcaam_desc_add_ptr(desc, key.d.paddr);\n\n\t\tbreak;\n\n\tcase RSA_PRIVATE_KEY_FORMAT_2:\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_D_SIZE(key.d.length) |\n\t\t\t\t\t   PDB_RSA_DEC_N_SIZE(key.n.length) |\n\t\t\t\t\t   pdb_sgt_flags);\n\t\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, key.d.paddr);\n\t\tcaam_desc_add_ptr(desc, key.p.paddr);\n\t\tcaam_desc_add_ptr(desc, key.q.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr + key.p.length);\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_Q_SIZE(key.q.length) |\n\t\t\t\t\t   PDB_RSA_DEC_P_SIZE(key.p.length));\n\t\tbreak;\n\n\tcase RSA_PRIVATE_KEY_FORMAT_3:\n\t\tcaam_desc_add_word(desc, PDB_RSA_DEC_N_SIZE(key.n.length) |\n\t\t\t\t\t\t pdb_sgt_flags);\n\t\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, key.qp.paddr);\n\t\tcaam_desc_add_ptr(desc, key.p.paddr);\n\t\tcaam_desc_add_ptr(desc, key.q.paddr);\n\t\tcaam_desc_add_ptr(desc, key.dp.paddr);\n\t\tcaam_desc_add_ptr(desc, key.dq.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr + key.p.length);\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_Q_SIZE(key.q.length) |\n\t\t\t\t\t   PDB_RSA_DEC_P_SIZE(key.p.length));\n\t\tbreak;\n\n\tdefault:\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto exit_decrypt;\n\t}\n\n\t/* Set the Decryption operation type */\n\tcaam_desc_add_word(desc, operation | PROT_RSA_DEC_KEYFORM(key.format));\n\n\tif (operation == RSA_DECRYPT(PKCS_V1_5)) {\n\t\t/* Get the PPKCS1 v1.5 Message length generated */\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   ST_NOIMM_OFF(CLASS_DECO, REG_MATH0, 4, 4));\n\t\tcaam_desc_add_ptr(desc, size_msg.paddr);\n\t\t/* Set the descriptor Header with length */\n\t\tdesclen = caam_desc_get_len(desc);\n#ifdef CFG_CAAM_64BIT\n\t\tcaam_desc_update_hdr(desc,\n\t\t\t\t     DESC_HEADER_IDX(desclen, desclen - 1 - 3));\n#else\n\t\tcaam_desc_update_hdr(desc,\n\t\t\t\t     DESC_HEADER_IDX(desclen, desclen - 1 - 2));\n#endif /* CFG_CAAM_64BIT */\n\t} else {\n\t\tdesclen = caam_desc_get_len(desc);\n\t\t/* Set the descriptor Header with length */\n\t\tcaam_desc_update_hdr(desc,\n\t\t\t\t     DESC_HEADER_IDX(desclen, desclen - 1));\n\t}\n\n\tRSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tRSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t\tgoto exit_decrypt;\n\t}\n\n\tif (operation == RSA_DECRYPT(NO) &&\n\t    rsa_data->rsa_id == DRVCRYPT_RSA_NOPAD) {\n\t\trsa_data->message.length = caam_dmaobj_copy_ltrim_to_orig(&msg);\n\t} else {\n\t\tif (operation == RSA_DECRYPT(PKCS_V1_5)) {\n\t\t\t/* PKCS 1 v1.5 */\n\t\t\tcache_operation(TEE_CACHEINVALIDATE, size_msg.data,\n\t\t\t\t\tsize_msg.length);\n\n\t\t\t/* Check if the original buffer size is large enough */\n\t\t\tif (msg.orig.length < caam_read_val32(size_msg.data)) {\n\t\t\t\trsa_data->message.length =\n\t\t\t\t\t\tcaam_read_val32(size_msg.data);\n\t\t\t\tret = TEE_ERROR_SHORT_BUFFER;\n\t\t\t\tgoto exit_decrypt;\n\t\t\t}\n\n\t\t\tmsg.orig.length = caam_read_val32(size_msg.data);\n\t\t\tRSA_TRACE(\"New length %zu\", msg.orig.length);\n\t\t}\n\n\t\trsa_data->message.length = caam_dmaobj_copy_to_orig(&msg);\n\t}\n\n\tRSA_DUMPBUF(\"Output\", rsa_data->message.data, rsa_data->message.length);\n\tret = TEE_SUCCESS;\n\nexit_decrypt:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&key);\n\tcaam_free_buf(&size_msg);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&cipher);\n\n\tcaam_free_buf(&tmp);\n\n\treturn ret;\n}\n\n/*\n * RSA Encryption\n *\n * @rsa_data   [in/out] RSA Data to encrypt / Cipher resulting\n */\nstatic TEE_Result do_encrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\t\tret = do_caam_encrypt(rsa_data, RSA_ENCRYPT(NO));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\tret = do_caam_encrypt(rsa_data, RSA_ENCRYPT(PKCS_V1_5));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tret = do_oaep_encoding(rsa_data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/*\n * RSA Decryption\n *\n * @rsa_data   [in/out] RSA Data to decrypt / Message resulting\n */\nstatic TEE_Result do_decrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\t\tret = do_caam_decrypt(rsa_data, RSA_DECRYPT(NO));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\tret = do_caam_decrypt(rsa_data, RSA_DECRYPT(PKCS_V1_5));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tret = do_oaep_decoding(rsa_data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Registration of the RSA Driver\n */\nstatic const struct drvcrypt_rsa driver_rsa = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.alloc_publickey = do_allocate_publickey,\n\t.free_publickey = do_free_publickey,\n\t.free_keypair = do_free_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.encrypt = do_encrypt,\n\t.decrypt = do_decrypt,\n\t.optional.ssa_sign = NULL,\n\t.optional.ssa_verify = NULL,\n};\n\nenum caam_status caam_rsa_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base)) {\n\t\tcaam_era = caam_hal_ctrl_era(jr_base);\n\t\tRSA_TRACE(\"CAAM Era %d\", caam_era);\n\n\t\tif (!drvcrypt_register_rsa(&driver_rsa))\n\t\t\tretstatus = CAAM_NO_ERROR;\n\t}\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) Foundries Ltd. 2020 - All Rights Reserved\n * Author: Jorge Ramirez <jorge@foundries.io>\n */\n\n#include <assert.h>\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <der.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <drvcrypt_math.h>\n#include <initcall.h>\n#include <se050.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee_api_defines.h>\n#include <tee_api_defines_extensions.h>\n#include <utee_defines.h>\n#include <util.h>\n\nstatic const struct crypto_ecc_keypair_ops *pair_ops;\nstatic const struct crypto_ecc_public_ops *pub_ops;\n\nstatic bool oefid_key_supported(size_t bits)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\treturn bits >= 224;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool oefid_algo_supported(uint32_t algo)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_ECDSA_SHA224:\n\t\tcase TEE_ALG_ECDSA_SHA256:\n\t\tcase TEE_ALG_ECDSA_SHA384:\n\t\tcase TEE_ALG_ECDSA_SHA512:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic uint32_t algo_tee2se050(uint32_t algo)\n{\n\tswitch (algo) {\n\tcase TEE_ALG_ECDSA_SHA1:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA1;\n\tcase TEE_ALG_ECDSA_SHA224:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA224;\n\tcase TEE_ALG_ECDSA_SHA256:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA256;\n\tcase TEE_ALG_ECDSA_SHA384:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA384;\n\tcase TEE_ALG_ECDSA_SHA512:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA512;\n\tdefault:\n\t\tEMSG(\"algorithm %#\"PRIx32\" not enabled\", algo);\n\t\treturn kAlgorithm_None;\n\t}\n}\n\nstatic uint32_t cipher_tee2se050(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\tcase TEE_ECC_CURVE_NIST_P224:\n\tcase TEE_ECC_CURVE_NIST_P256:\n\tcase TEE_ECC_CURVE_NIST_P384:\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\treturn kSSS_CipherType_EC_NIST_P;\n\tdefault:\n\t\tEMSG(\"cipher %#\"PRIx32\" not enabled\", curve);\n\t\treturn kSSS_CipherType_NONE;\n\t}\n}\n\nstatic uint32_t curve_tee2se050(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\treturn kSE05x_ECCurve_NIST_P192;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\treturn kSE05x_ECCurve_NIST_P224;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\treturn kSE05x_ECCurve_NIST_P256;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\treturn kSE05x_ECCurve_NIST_P384;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\treturn kSE05x_ECCurve_NIST_P521;\n\tdefault:\n\t\tEMSG(\"curve %#\"PRIx32\" not enabled\", curve);\n\t\treturn kSE05x_ECCurve_NA;\n\t}\n}\n\nstatic uint32_t curve_se0502tee(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase kSE05x_ECCurve_NIST_P192:\n\t\treturn TEE_ECC_CURVE_NIST_P192;\n\tcase kSE05x_ECCurve_NIST_P224:\n\t\treturn TEE_ECC_CURVE_NIST_P224;\n\tcase kSE05x_ECCurve_NIST_P256:\n\t\treturn TEE_ECC_CURVE_NIST_P256;\n\tcase kSE05x_ECCurve_NIST_P384:\n\t\treturn TEE_ECC_CURVE_NIST_P384;\n\tcase kSE05x_ECCurve_NIST_P521:\n\t\treturn TEE_ECC_CURVE_NIST_P521;\n\tdefault:\n\t\tEMSG(\"curve %#\"PRIx32\" not enabled\", curve);\n\t\treturn TEE_CRYPTO_ELEMENT_NONE;\n\t}\n}\n\nstatic bool bn_alloc_max(struct bignum **s)\n{\n\t*s = crypto_bignum_allocate(4096);\n\n\treturn *s;\n}\n\nstatic TEE_Result ecc_get_key_size(uint32_t curve, uint32_t algo,\n\t\t\t\t   size_t *bytes, size_t *bits)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*bits = 192;\n\t\t*bytes = 24;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*bits = 224;\n\t\t*bytes = 28;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*bits = 256;\n\t\t*bytes = 32;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*bits = 384;\n\t\t*bytes = 48;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*bits = 521;\n\t\t*bytes = 66;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\tif (!oefid_key_supported(*bits))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (!oefid_algo_supported(algo))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result ecc_prepare_msg(uint32_t algo, const uint8_t *msg,\n\t\t\t\t  size_t *msg_len, uint8_t **msg_padded)\n{\n\tstruct {\n\t\tuint32_t algo;\n\t\tsize_t len;\n\t} map[] = {\n\t\t{ kAlgorithm_SSS_ECDSA_SHA1, TEE_SHA1_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA224, TEE_SHA224_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA256, TEE_SHA256_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA384, TEE_SHA384_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA512, TEE_SHA512_HASH_SIZE },\n\t};\n\tsize_t i = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (algo == map[i].algo)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(map))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (*msg_len >= map[i].len) {\n\t\t/* truncate */\n\t\t*msg_len = map[i].len;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* pad */\n\t*msg_padded = calloc(1, map[i].len);\n\tif (!*msg_padded)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tmemcpy(*msg_padded, msg, *msg_len);\n\t*msg_len = map[i].len;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result set_binary_data(struct bignum *b, size_t key_len, uint8_t **p,\n\t\t\t\t  size_t *len)\n{\n\tsize_t a = crypto_bignum_num_bytes(b);\n\tuint8_t leading_zeros = 0;\n\tuint8_t *q = NULL;\n\n\tif (!a)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tif (a != key_len) {\n\t\tleading_zeros = key_len - a;\n\t\ta = key_len;\n\t}\n\n\tq = calloc(1, a);\n\tif (!q)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tcrypto_bignum_bn2bin(b, q + leading_zeros);\n\t*len = a;\n\t*p = q;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_public_key(sss_se05x_object_t *k_object,\n\t\t\t\t\t  struct ecc_public_key *key,\n\t\t\t\t\t  size_t key_len)\n{\n\tstruct se050_ecc_keypub key_bin = { };\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tsss_status_t st = kStatus_SSS_Fail;\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/*\n\t * This function might return an error if the curve already\n\t * exists in the secure element. An actual error creating the\n\t * curve will be caught when attempting to set the key.\n\t */\n\tsss_se05x_key_store_create_curve(&se050_session->s_ctx,\n\t\t\t\t\t curve_tee2se050(key->curve));\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Public,\n\t\t\t\t\t\t  cipher_tee2se050(key->curve),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  kKeyObject_Mode_Transient);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tret = set_binary_data(key->x, key_len, &key_bin.x, &key_bin.x_len);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = set_binary_data(key->y, key_len, &key_bin.y, &key_bin.y_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tfree(key_bin.x);\n\t\treturn ret;\n\t}\n\n\tkey_bin.curve = curve_tee2se050(key->curve);\n\tst = se050_key_store_set_ecc_key_bin(se050_kstore, k_object, NULL,\n\t\t\t\t\t     &key_bin);\n\tfree(key_bin.x);\n\tfree(key_bin.y);\n\tif (st != kStatus_SSS_Success) {\n\t\tEMSG(\"Can't inject transient key, curve: %#\"PRIx32, key->curve);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_keypair(sss_se05x_object_t *k_object,\n\t\t\t\t       struct ecc_keypair *key,\n\t\t\t\t       size_t key_len)\n{\n\tstruct se050_ecc_keypair key_bin = { };\n\tsss_status_t st = kStatus_SSS_Fail;\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tuint32_t key_id = 0;\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey_id = se050_ecc_keypair_from_nvm(key);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(k_object, key_id);\n\t\tif (st != kStatus_SSS_Success)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/*\n\t * This function might return an error if the curve already\n\t * exists in the secure element. An actual error creating the\n\t * curve will be caught when attempting to set the key.\n\t */\n\tsss_se05x_key_store_create_curve(&se050_session->s_ctx,\n\t\t\t\t\t curve_tee2se050(key->curve));\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  cipher_tee2se050(key->curve),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  kKeyObject_Mode_Transient);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tret = set_binary_data(key->d, key_len, &key_bin.d, &key_bin.d_len);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = set_binary_data(key->x, key_len,\n\t\t\t      &key_bin.pub.x, &key_bin.pub.x_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tfree(key_bin.d);\n\t\treturn ret;\n\t}\n\n\tret = set_binary_data(key->y, key_len,\n\t\t\t      &key_bin.pub.y, &key_bin.pub.y_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tfree(key_bin.d);\n\t\tfree(key_bin.pub.x);\n\t\treturn ret;\n\t}\n\n\tkey_bin.pub.curve = curve_tee2se050(key->curve);\n\tst = se050_key_store_set_ecc_key_bin(se050_kstore, k_object, &key_bin,\n\t\t\t\t\t     NULL);\n\tfree(key_bin.d);\n\tfree(key_bin.pub.x);\n\tfree(key_bin.pub.y);\n\tif (st != kStatus_SSS_Success) {\n\t\tEMSG(\"Can't inject transient key, curve: %#\"PRIx32, key->curve);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result gen_fallback(struct ecc_keypair *key, size_t len)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: KEYGEN\");\n\treturn pair_ops->generate(key, len);\n}\n\nstatic TEE_Result shared_secret_fallback(struct ecc_keypair *private_key,\n\t\t\t\t\t struct ecc_public_key *public_key,\n\t\t\t\t\t void *secret, size_t *secret_len)\n{\n\tconst struct crypto_ecc_keypair_ops *ops = NULL;\n\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_ecc_keypair_from_nvm(private_key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tops = crypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDH_KEYPAIR);\n\tif (!ops)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: ECDH\");\n\treturn ops->shared_secret(private_key, public_key,\n\t\t\t\t  secret, (unsigned long *)secret_len);\n}\n\nstatic TEE_Result verify_fallback(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t  const uint8_t *msg, size_t msg_len,\n\t\t\t\t  const uint8_t *sig, size_t sig_len)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: VERIFY\");\n\treturn pub_ops->verify(algo, key, msg, msg_len, sig, sig_len);\n}\n\nstatic TEE_Result sign_fallback(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\tconst uint8_t *msg, size_t msg_len,\n\t\t\t\tuint8_t *sig, size_t *sig_len)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_ecc_keypair_from_nvm(key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: SIGN\");\n\treturn pair_ops->sign(algo, key, msg, msg_len, sig, sig_len);\n}\n\nstatic TEE_Result shared_secret(struct ecc_keypair *private_key,\n\t\t\t\tstruct ecc_public_key *public_key,\n\t\t\t\tvoid *secret, size_t *secret_len)\n{\n\tstruct se050_ecc_keypub key = { };\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_derive_key_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result ret = TEE_SUCCESS;\n\tsize_t key_bits = 0;\n\tsize_t key_bytes = 0;\n\n\tif (private_key->curve != public_key->curve)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tret = ecc_get_key_size(private_key->curve, 0, &key_bytes, &key_bits);\n\tif (ret) {\n\t\tif (ret != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\treturn ret;\n\n\t\treturn shared_secret_fallback(private_key, public_key,\n\t\t\t\t\t      secret, secret_len);\n\t}\n\n\tret = se050_inject_keypair(&kobject, private_key, key_bytes);\n\tif (ret != TEE_SUCCESS)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_derive_key_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       kAlgorithm_SSS_ECDH,\n\t\t\t\t\t       kMode_SSS_ComputeSharedSecret);\n\tif (st != kStatus_SSS_Success) {\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\t/* prepare the public key (must be in raw format) */\n\tret = set_binary_data(public_key->x, key_bytes, &key.x, &key.x_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tret = set_binary_data(public_key->y, key_bytes, &key.y, &key.y_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tst = se050_ecc_gen_shared_secret(&se050_session->s_ctx,\n\t\t\t\t\t kobject.keyId, &key,\n\t\t\t\t\t secret, secret_len);\n\n\tif (st != kStatus_SSS_Success)\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\nexit:\n\tif (!se050_ecc_keypair_from_nvm(private_key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tfree(key.x);\n\tfree(key.y);\n\n\treturn ret;\n}\n\nstatic TEE_Result sign(uint32_t algo, struct ecc_keypair *key,\n\t\t       const uint8_t *msg, size_t msg_len,\n\t\t       uint8_t *sig, size_t *sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *sig_der = NULL;\n\tsize_t sig_der_len = 0;\n\tsize_t key_bytes = 0;\n\tsize_t key_bits = 0;\n\tuint8_t *p = NULL;\n\n\tres = ecc_get_key_size(key->curve, algo, &key_bytes, &key_bits);\n\tif (res) {\n\t\tif (res != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\tgoto exit;\n\n\t\treturn sign_fallback(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\t/* allocate temporary buffer to retrieve the signature in DER format */\n\tsig_der_len = 2 * key_bytes + DER_SIGNATURE_SZ;\n\n\tsig_der = malloc(sig_der_len);\n\tif (!sig_der) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit;\n\t}\n\n\t/* truncate or pad the message as needed */\n\tres = ecc_prepare_msg(algo_tee2se050(algo), msg, &msg_len, &p);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = se050_inject_keypair(&kobject, key, key_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       algo_tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Sign);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tst = sss_se05x_asymmetric_sign_digest(&ctx, p ? p : (uint8_t *)msg,\n\t\t\t\t\t      msg_len, sig_der, &sig_der_len);\n\tif (st != kStatus_SSS_Success) {\n\t\tEMSG(\"curve: %#\"PRIx32, key->curve);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tsss_se05x_signature_der2bin(sig_der, &sig_der_len);\n\n\tif (sig_der_len > *sig_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(sig, sig_der, sig_der_len);\n\t*sig_len = sig_der_len;\nexit:\n\tif (!se050_ecc_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\tfree(sig_der);\n\tfree(p);\n\n\treturn res;\n}\n\nstatic TEE_Result verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t const uint8_t *sig, size_t sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *signature = NULL;\n\tsize_t signature_len = sig_len + DER_SIGNATURE_SZ;\n\tsize_t key_bytes = 0;\n\tsize_t key_bits = 0;\n\tuint8_t *p = NULL;\n\n\tres = ecc_get_key_size(key->curve, algo, &key_bytes, &key_bits);\n\tif (res) {\n\t\tif (res != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\tgoto exit;\n\n\t\treturn verify_fallback(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\t/* truncate or pad the message as needed */\n\tres = ecc_prepare_msg(algo_tee2se050(algo), msg, &msg_len, &p);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = se050_inject_public_key(&kobject, key, key_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       algo_tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Verify);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tsignature = calloc(1, signature_len);\n\tif (!signature) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tst = sss_se05x_signature_bin2der(signature, &signature_len,\n\t\t\t\t\t (uint8_t *)sig, sig_len);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tst = sss_se05x_asymmetric_verify_digest(&ctx, p ? p : (uint8_t *)msg,\n\t\t\t\t\t\tmsg_len, (uint8_t *)signature,\n\t\t\t\t\t\tsignature_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\nexit:\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\tfree(p);\n\tfree(signature);\n\n\treturn res;\n}\n\nstatic TEE_Result gen_keypair(struct ecc_keypair *key, size_t key_size)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tTEE_Result ret = TEE_SUCCESS;\n\tuint8_t kf[512] = { };\n\tuint32_t oid = 0;\n\tuint64_t kid = 0;\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tret = ecc_get_key_size(key->curve, 0, &bytes, &bits);\n\tif (ret) {\n\t\tif (ret != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\treturn ret;\n\n\t\treturn gen_fallback(key, key_size);\n\t}\n\n\tst = sss_se05x_key_object_init(&k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(&k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  cipher_tee2se050(key->curve),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_key_store_generate_key(se050_kstore, &k_object, bits,\n\t\t\t\t\t      &se050_asym_policy);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tbytes = sizeof(kf);\n\tst = se050_key_store_get_ecc_key_bin(se050_kstore, &k_object, kf,\n\t\t\t\t\t     &bytes);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* skip the DER tag */\n\tcrypto_bignum_bin2bn(kf + 1, bytes / 2, key->x);\n\tcrypto_bignum_bin2bn(kf + 1 + bytes / 2, bytes / 2, key->y);\n\n\tkid = se050_generate_private_key(oid);\n\tcrypto_bignum_bin2bn((uint8_t *)&kid, sizeof(kid), key->d);\n\tkey->curve = curve_se0502tee(k_object.curve_id);\n\tif (key->curve != TEE_CRYPTO_ELEMENT_NONE)\n\t\treturn TEE_SUCCESS;\n\n\tEMSG(\"ecc key generation failed\");\n\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic TEE_Result do_gen_keypair(struct ecc_keypair *key, size_t size_bytes)\n{\n\treturn gen_keypair(key, size_bytes);\n}\n\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\treturn shared_secret(sdata->key_priv,\n\t\t\t     sdata->key_pub,\n\t\t\t     sdata->secret.data,\n\t\t\t     &sdata->secret.length);\n}\n\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata)\n{\n\treturn sign(sdata->algo,\n\t\t    sdata->key,\n\t\t    sdata->message.data,\n\t\t    sdata->message.length,\n\t\t    sdata->signature.data,\n\t\t    &sdata->signature.length);\n}\n\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata)\n{\n\treturn verify(sdata->algo,\n\t\t      sdata->key,\n\t\t      sdata->message.data,\n\t\t      sdata->message.length,\n\t\t      sdata->signature.data,\n\t\t      sdata->signature.length);\n}\n\nstatic TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic TEE_Result do_alloc_publickey(struct ecc_public_key *s, uint32_t type,\n\t\t\t\t     size_t size_bits __unused)\n{\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic void do_free_publickey(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}\n\nstatic struct drvcrypt_ecc driver_ecc = {\n\t.alloc_keypair = do_alloc_keypair,\n\t.alloc_publickey = do_alloc_publickey,\n\t.free_publickey = do_free_publickey,\n\t.gen_keypair = do_gen_keypair,\n\t.sign = do_sign,\n\t.verify = do_verify,\n\t.shared_secret = do_shared_secret,\n};\n\nstatic TEE_Result ecc_init(void)\n{\n\tpub_ops = crypto_asym_get_ecc_public_ops(TEE_TYPE_ECDSA_PUBLIC_KEY);\n\tif (!pub_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tpair_ops = crypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDSA_KEYPAIR);\n\tif (!pair_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/* This driver supports both ECDH and ECDSA */\n\tassert((pub_ops ==\n\t\tcrypto_asym_get_ecc_public_ops(TEE_TYPE_ECDH_PUBLIC_KEY)) &&\n\t       (pair_ops ==\n\t\tcrypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDH_KEYPAIR)));\n\n\treturn drvcrypt_register_ecc(&driver_ecc);\n}\n\ndriver_init_late(ecc_init);\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) Foundries Ltd. 2020 - All Rights Reserved\n * Author: Jorge Ramirez <jorge@foundries.io>\n */\n\n#include <assert.h>\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <drvcrypt_math.h>\n#include <initcall.h>\n#include <mempool.h>\n#include <se050.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee_api_defines_extensions.h>\n\nstatic sss_cipher_type_t oefid_cipher_type(void)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\treturn kSSS_CipherType_RSA_CRT;\n\tdefault:\n\t\treturn kSSS_CipherType_RSA;\n\t}\n}\n\nstatic bool oefid_keylen_supported(size_t bits)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\treturn bits >= 2048;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool rsa_keypair_has_crt(struct rsa_keypair *key)\n{\n\tif (key->p && crypto_bignum_num_bytes(key->p) &&\n\t    key->q && crypto_bignum_num_bytes(key->q) &&\n\t    key->qp && crypto_bignum_num_bytes(key->qp) &&\n\t    key->dp && crypto_bignum_num_bytes(key->dp) &&\n\t    key->dq && crypto_bignum_num_bytes(key->dq))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool keypair_supported(struct rsa_keypair *key, sss_cipher_type_t ctype)\n{\n\tif (se050_rsa_keypair_from_nvm(key))\n\t\treturn true;\n\n\tif (ctype == kSSS_CipherType_RSA_CRT)\n\t\treturn rsa_keypair_has_crt(key);\n\n\treturn true;\n}\n\nstatic uint32_t tee2se050(uint32_t algo)\n{\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA1;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA224;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA256;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA384;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA512;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA1;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA224;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA256;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA384;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA512;\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_V1_5_SHA256;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA1;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA224;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA256;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA384;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA512;\n\tcase TEE_ALG_RSA_NOPAD:\n\t\treturn kAlgorithm_SSS_RSASSA_NO_PADDING;\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_NO_HASH;\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5SHA1:\n\tdefault:\n\t\treturn kAlgorithm_None;\n\t}\n}\n\nstatic bool bn_alloc_max(struct bignum **s)\n{\n\t*s = crypto_bignum_allocate(4096);\n\n\treturn *s;\n}\n\nstatic TEE_Result set_binary_data(struct bignum *b, uint8_t **p, size_t *len)\n{\n\t*len = crypto_bignum_num_bytes(b);\n\tif (*len) {\n\t\t*p = (uint8_t *)calloc(1, *len);\n\t\tif (!*p)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t\tcrypto_bignum_bn2bin(b, *p);\n\t}\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_public_key(sss_se05x_object_t *k_object,\n\t\t\t\t\t  struct rsa_public_key *key)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tstruct se050_rsa_keypub key_bin = { };\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/*\n\t * Keys 2048 and above MUST to be placed on persistent storage even\n\t * though the keys will be deleted after the operation. This is a\n\t * memory restriction in the secure element.\n\t */\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Public,\n\t\t\t\t\t\t  oefid_cipher_type(), 0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tset_binary_data(key->e, &key_bin.e, &key_bin.e_len);\n\tset_binary_data(key->n, &key_bin.n, &key_bin.n_len);\n\tst = se050_key_store_set_rsa_key_bin(se050_kstore, k_object, NULL,\n\t\t\t\t\t     &key_bin, key_bin.n_len * 8);\n\tfree(key_bin.n);\n\tfree(key_bin.e);\n\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, k_object);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_keypair(sss_se05x_object_t *k_object,\n\t\t\t\t       struct rsa_keypair *key)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tstruct se050_rsa_keypair key_bin = { };\n\tuint32_t key_id = 0;\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey_id = se050_rsa_keypair_from_nvm(key);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(k_object, key_id);\n\t\tif (st != kStatus_SSS_Success)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/* Keys 2048 and above need to be placed on persistent storage */\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  oefid_cipher_type(), 0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tset_binary_data(key->e, &key_bin.e, &key_bin.e_len);\n\tset_binary_data(key->d, &key_bin.d, &key_bin.d_len);\n\tset_binary_data(key->n, &key_bin.n, &key_bin.n_len);\n\tset_binary_data(key->p, &key_bin.p, &key_bin.p_len);\n\tset_binary_data(key->q, &key_bin.q, &key_bin.q_len);\n\tset_binary_data(key->qp, &key_bin.qp, &key_bin.qp_len);\n\tset_binary_data(key->dp, &key_bin.dp, &key_bin.dp_len);\n\tset_binary_data(key->dq, &key_bin.dq, &key_bin.dq_len);\n\tst = se050_key_store_set_rsa_key_bin(se050_kstore, k_object,\n\t\t\t\t\t     &key_bin, NULL,\n\t\t\t\t\t     crypto_bignum_num_bits(key->n));\n\tfree(key_bin.e);\n\tfree(key_bin.d);\n\tfree(key_bin.n);\n\tfree(key_bin.p);\n\tfree(key_bin.q);\n\tfree(key_bin.qp);\n\tfree(key_bin.dp);\n\tfree(key_bin.dq);\n\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, k_object);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result decrypt_es(uint32_t algo, struct rsa_keypair *key,\n\t\t\t     const uint8_t *src, size_t src_len,\n\t\t\t     uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tsize_t buf_len = src_len;\n\n\tres = se050_inject_keypair(&kobject, key);\n\tif (res)\n\t\treturn res;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Decrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tif (!se050_rsa_keypair_from_nvm(key))\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* we don't know the size of the decrypted data, just the upper limit */\n\tbuf = mempool_calloc(mempool_default, 1, buf_len);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tst = sss_se05x_asymmetric_decrypt(&ctx, src, src_len, buf,  &buf_len);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (buf_len > *dst_len) {\n\t\t*dst_len = buf_len;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t*dst_len = buf_len;\n\tmemcpy(dst, buf, buf_len);\nout:\n\tif (!se050_rsa_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\tmempool_free(mempool_default, buf);\n\n\treturn res;\n}\n\nstatic TEE_Result encrypt_es(uint32_t algo, struct rsa_public_key *key,\n\t\t\t     const uint8_t *src, size_t src_len,\n\t\t\t     uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\n\tif (*dst_len < crypto_bignum_num_bytes(key->n)) {\n\t\t*dst_len = crypto_bignum_num_bytes(key->n);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\n\tif (se050_inject_public_key(&kobject, key))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Encrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tst = sss_se05x_asymmetric_encrypt(&ctx, src, src_len, dst, dst_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result decrypt_nopad(struct rsa_keypair *key, const uint8_t *src,\n\t\t\t\tsize_t src_len, uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tsize_t offset = 0;\n\tsize_t blen = 0;\n\tsize_t rsa_len = 0;\n\n\tres = se050_inject_keypair(&kobject, key);\n\tif (res)\n\t\treturn res;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       kAlgorithm_SSS_RSASSA_NO_PADDING,\n\t\t\t\t\t       kMode_SSS_Decrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tif (!se050_rsa_keypair_from_nvm(key))\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = mempool_calloc(mempool_default, 1, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\trsa_len = crypto_bignum_num_bytes(key->n);\n\tmemcpy(buf + rsa_len - src_len, src, src_len);\n\n\tst = sss_se05x_asymmetric_decrypt(&ctx, buf, rsa_len, buf, &blen);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < blen - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < blen - offset) {\n\t\t*dst_len = blen - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t*dst_len = blen - offset;\n\tmemcpy(dst, buf + offset, *dst_len);\nout:\n\tmempool_free(mempool_default, buf);\n\tif (!se050_rsa_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result encrypt_nopad(struct rsa_public_key *key, const uint8_t *src,\n\t\t\t\tsize_t src_len, uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tsize_t offset = 0;\n\tsize_t blen = 0;\n\tsize_t rsa_len = 0;\n\n\tif (se050_inject_public_key(&kobject, key))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       kAlgorithm_SSS_RSASSA_NO_PADDING,\n\t\t\t\t\t       kMode_SSS_Encrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = mempool_calloc(mempool_default, 1, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\trsa_len = crypto_bignum_num_bytes(key->n);\n\tmemcpy(buf + rsa_len - src_len, src, src_len);\n\n\tst = sss_se05x_asymmetric_encrypt(&ctx, buf, rsa_len, buf, &blen);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < blen - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < blen - offset) {\n\t\t*dst_len = blen - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t*dst_len = blen - offset;\n\tmemcpy(dst, buf + offset, *dst_len);\nout:\n\tmempool_free(mempool_default, buf);\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result sign_ssa(uint32_t algo, struct rsa_keypair *key,\n\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t   uint8_t *sig, size_t *sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\n\tif (*sig_len < crypto_bignum_num_bytes(key->n)) {\n\t\t*sig_len = crypto_bignum_num_bytes(key->n);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\n\tres = se050_inject_keypair(&kobject, key);\n\tif (res)\n\t\treturn res;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo), kMode_SSS_Sign);\n\tif (st != kStatus_SSS_Success) {\n\t\tif (!se050_rsa_keypair_from_nvm(key))\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tst = sss_se05x_asymmetric_sign_digest(&ctx, (uint8_t *)msg, msg_len,\n\t\t\t\t\t      sig, sig_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\n\tif (!se050_rsa_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result verify_ssa(uint32_t algo, struct rsa_public_key *key,\n\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\n\tif (se050_inject_public_key(&kobject, key))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Verify);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tst = sss_se05x_asymmetric_verify_digest(&ctx, (uint8_t *)msg, msg_len,\n\t\t\t\t\t\t(uint8_t *)sig, sig_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}\n\nstatic void do_free_keypair(struct rsa_keypair *s)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t key_id = 0;\n\n\tif (!s)\n\t\treturn;\n\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}\n\nstatic TEE_Result do_gen_keypair(struct rsa_keypair *key, size_t kb)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t oid = 0;\n\tuint64_t kid = 0;\n\tuint8_t k[2048] = { 0 };\n\tuint8_t *n = NULL;\n\tuint8_t *e = NULL;\n\tsize_t n_len = 0;\n\tsize_t e_len = 0;\n\tsize_t k_len = sizeof(k);\n\n\tif (!oefid_keylen_supported(kb)) {\n\t\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\tDMSG(\"se050: debug: RSA software fallback: KEYGEN\");\n\t\treturn sw_crypto_acipher_gen_rsa_key(key, kb);\n\t}\n\n\tst = sss_se05x_key_object_init(&k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(&k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  oefid_cipher_type(), 0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_key_store_generate_key(se050_kstore, &k_object, kb,\n\t\t\t\t\t      &se050_asym_policy);\n\tif (st != kStatus_SSS_Success)\n\t\tgoto error;\n\n\tst = sss_se05x_key_store_get_key(se050_kstore, &k_object, k, &k_len,\n\t\t\t\t\t &kb);\n\tif (st != kStatus_SSS_Success)\n\t\tgoto error;\n\n\tst = sss_util_asn1_rsa_parse_public(k, k_len, &n, &n_len, &e, &e_len);\n\tif (st != kStatus_SSS_Success)\n\t\tgoto error;\n\n\tcrypto_bignum_bin2bn(n, n_len, key->n);\n\tcrypto_bignum_bin2bn(e, e_len, key->e);\n\tkid = se050_generate_private_key(oid);\n\tcrypto_bignum_bin2bn((uint8_t *)&kid, sizeof(kid), (key->d));\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->p);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->q);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->qp);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->dp);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->dq);\n\tfree(n);\n\tfree(e);\n\n\treturn TEE_SUCCESS;\nerror:\n\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic TEE_Result encrypt_fallback(struct drvcrypt_rsa_ed *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (p->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\t\tDMSG(\"se050: debug: RSA software fallback: ENCRYPT_NOPAD\");\n\t\treturn sw_crypto_acipher_rsanopad_encrypt(p->key.key,\n\t\t\t\t\t\t\t  p->message.data,\n\t\t\t\t\t\t\t  p->message.length,\n\t\t\t\t\t\t\t  p->cipher.data,\n\t\t\t\t\t\t\t  &p->cipher.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tdefault:\n\t\tDMSG(\"se050: debug: RSA software fallback: ENCRYPT_ES\");\n\t\treturn sw_crypto_acipher_rsaes_encrypt(p->algo,\n\t\t\t\t\t\t       p->key.key,\n\t\t\t\t\t\t       p->label.data,\n\t\t\t\t\t\t       p->label.length,\n\t\t\t\t\t\t       p->message.data,\n\t\t\t\t\t\t       p->message.length,\n\t\t\t\t\t\t       p->cipher.data,\n\t\t\t\t\t\t       &p->cipher.length);\n\t}\n}\n\nstatic TEE_Result do_encrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tif (!oefid_keylen_supported(rsa_data->key.n_size * 8))\n\t\treturn encrypt_fallback(rsa_data);\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\t\treturn encrypt_nopad(rsa_data->key.key,\n\t\t\t\t     rsa_data->message.data,\n\t\t\t\t     rsa_data->message.length,\n\t\t\t\t     rsa_data->cipher.data,\n\t\t\t\t     &rsa_data->cipher.length);\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\treturn encrypt_es(TEE_ALG_RSAES_PKCS1_V1_5,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  rsa_data->message.length,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  &rsa_data->cipher.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tif (rsa_data->hash_algo != TEE_ALG_SHA1)\n\t\t\treturn encrypt_fallback(rsa_data);\n\n\t\treturn encrypt_es(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  rsa_data->message.length,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  &rsa_data->cipher.length);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn encrypt_fallback(rsa_data);\n}\n\nstatic TEE_Result decrypt_fallback(struct drvcrypt_rsa_ed *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_rsa_keypair_from_nvm(p->key.key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (p->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\t\tDMSG(\"se050: debug: RSA software fallback: DECRYPT_NOPAD\");\n\t\treturn sw_crypto_acipher_rsanopad_decrypt(p->key.key,\n\t\t\t\t\t\t\t  p->cipher.data,\n\t\t\t\t\t\t\t  p->cipher.length,\n\t\t\t\t\t\t\t  p->message.data,\n\t\t\t\t\t\t\t  &p->message.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tdefault:\n\t\tDMSG(\"se050: debug: RSA software fallback: DECRYPT_ES\");\n\t\treturn sw_crypto_acipher_rsaes_decrypt(p->algo,\n\t\t\t\t\t\t       p->key.key,\n\t\t\t\t\t\t       p->label.data,\n\t\t\t\t\t\t       p->label.length,\n\t\t\t\t\t\t       p->cipher.data,\n\t\t\t\t\t\t       p->cipher.length,\n\t\t\t\t\t\t       p->message.data,\n\t\t\t\t\t\t       &p->message.length);\n\t}\n}\n\nstatic TEE_Result do_decrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tif (!oefid_keylen_supported(rsa_data->key.n_size * 8))\n\t\treturn decrypt_fallback(rsa_data);\n\n\tif (!keypair_supported(rsa_data->key.key, oefid_cipher_type()))\n\t\treturn decrypt_fallback(rsa_data);\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\t\treturn decrypt_nopad(rsa_data->key.key,\n\t\t\t\t     rsa_data->cipher.data,\n\t\t\t\t     rsa_data->cipher.length,\n\t\t\t\t     rsa_data->message.data,\n\t\t\t\t     &rsa_data->message.length);\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\treturn decrypt_es(TEE_ALG_RSAES_PKCS1_V1_5,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  rsa_data->cipher.length,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  &rsa_data->message.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tif (rsa_data->hash_algo != TEE_ALG_SHA1)\n\t\t\treturn decrypt_fallback(rsa_data);\n\n\t\treturn decrypt_es(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  rsa_data->cipher.length,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  &rsa_data->message.length);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nstatic TEE_Result sign_ssa_fallback(struct drvcrypt_rsa_ssa *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_rsa_keypair_from_nvm(p->key.key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: RSA software fallback: SIGN\");\n\treturn sw_crypto_acipher_rsassa_sign(p->algo,\n\t\t\t\t\t     p->key.key,\n\t\t\t\t\t     p->salt_len,\n\t\t\t\t\t     p->message.data,\n\t\t\t\t\t     p->message.length,\n\t\t\t\t\t     p->signature.data,\n\t\t\t\t\t     &p->signature.length);\n}\n\nstatic TEE_Result do_ssa_sign(struct drvcrypt_rsa_ssa *ssa_data)\n{\n\tif (!oefid_keylen_supported(ssa_data->key.n_size * 8))\n\t\treturn sign_ssa_fallback(ssa_data);\n\n\tif (!keypair_supported(ssa_data->key.key, oefid_cipher_type()))\n\t\treturn sign_ssa_fallback(ssa_data);\n\n\t/* PKCS1_PSS_MGF1 padding limitations */\n\tswitch (ssa_data->algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\t\tif (ssa_data->key.n_size * 8 <= 512)\n\t\t\treturn sign_ssa_fallback(ssa_data);\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (ssa_data->key.n_size * 8 <= 1024)\n\t\t\treturn sign_ssa_fallback(ssa_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn sign_ssa(ssa_data->algo,\n\t\t\tssa_data->key.key,\n\t\t\tssa_data->message.data,\n\t\t\tssa_data->message.length,\n\t\t\tssa_data->signature.data,\n\t\t\t&ssa_data->signature.length);\n}\n\nstatic TEE_Result verify_ssa_fallback(struct drvcrypt_rsa_ssa *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: RSA software fallback: VERIFY\");\n\treturn sw_crypto_acipher_rsassa_verify(p->algo,\n\t\t\t\t\t       p->key.key,\n\t\t\t\t\t       p->salt_len,\n\t\t\t\t\t       p->message.data,\n\t\t\t\t\t       p->message.length,\n\t\t\t\t\t       p->signature.data,\n\t\t\t\t\t       p->signature.length);\n}\n\nstatic TEE_Result do_ssa_verify(struct drvcrypt_rsa_ssa *ssa_data)\n{\n\tif (!oefid_keylen_supported(ssa_data->key.n_size * 8))\n\t\treturn verify_ssa_fallback(ssa_data);\n\n\t/* PKCS1_PSS_MGF1 padding limitations */\n\tswitch (ssa_data->algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\t\tif (ssa_data->key.n_size * 8 <= 512)\n\t\t\treturn verify_ssa_fallback(ssa_data);\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (ssa_data->key.n_size * 8 <= 1024)\n\t\t\treturn verify_ssa_fallback(ssa_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn verify_ssa(ssa_data->algo,\n\t\t\tssa_data->key.key,\n\t\t\tssa_data->message.data,\n\t\t\tssa_data->message.length,\n\t\t\tssa_data->signature.data,\n\t\t\tssa_data->signature.length);\n}\n\nstatic const struct drvcrypt_rsa driver_rsa = {\n\t.alloc_keypair = do_alloc_keypair,\n\t.alloc_publickey = do_alloc_publickey,\n\t.free_publickey = do_free_publickey,\n\t.free_keypair = do_free_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.encrypt = do_encrypt,\n\t.decrypt = do_decrypt,\n\t.optional.ssa_sign = do_ssa_sign,\n\t.optional.ssa_verify = do_ssa_verify,\n};\n\nstatic TEE_Result rsa_init(void)\n{\n\treturn drvcrypt_register_rsa(&driver_rsa);\n}\n\ndriver_init_late(rsa_init);\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) Foundries Ltd. 2022.\n * Author: Jorge Ramirez <jorge@foundries.io>\n */\n\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <crypto/crypto_impl.h>\n#include <initcall.h>\n#include <ipi.h>\n#include <kernel/panic.h>\n#include <mm/core_memprot.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n#include <util.h>\n\n/* AMD/Xilinx Versal's Known Answer Tests */\n#define XSECURE_ECDSA_KAT_NIST_P384\t0\n#define XSECURE_ECDSA_KAT_NIST_P521\t2\n\n/* Software based ECDSA operations */\nstatic const struct crypto_ecc_keypair_ops *pair_ops;\nstatic const struct crypto_ecc_public_ops *pub_ops;\n\nenum versal_ecc_err {\n\tKAT_KEY_NOTVALID_ERROR = 0xC0,\n\tKAT_FAILED_ERROR,\n\tNON_SUPPORTED_CURVE,\n\tKEY_ZERO,\n\tKEY_WRONG_ORDER,\n\tKEY_NOT_ON_CURVE,\n\tBAD_SIGN,\n\tGEN_SIGN_INCORRECT_HASH_LEN,\n\tVER_SIGN_INCORRECT_HASH_LEN,\n\tGEN_SIGN_BAD_RAND_NUM,\n\tGEN_KEY_ERR,\n\tINVALID_PARAM,\n\tVER_SIGN_R_ZERO,\n\tVER_SIGN_S_ZERO,\n\tVER_SIGN_R_ORDER_ERROR,\n\tVER_SIGN_S_ORDER_ERROR,\n\tKAT_INVLD_CRV_ERROR,\n};\n\n#define VERSAL_ECC_ERROR(m) { .error = (m), .name = TO_STR(m) }\n\nstatic const char *versal_ecc_error(uint8_t err)\n{\n\tstruct {\n\t\tenum versal_ecc_err error;\n\t\tconst char *name;\n\t} elist[] = {\n\t\tVERSAL_ECC_ERROR(KAT_KEY_NOTVALID_ERROR),\n\t\tVERSAL_ECC_ERROR(KAT_FAILED_ERROR),\n\t\tVERSAL_ECC_ERROR(NON_SUPPORTED_CURVE),\n\t\tVERSAL_ECC_ERROR(KEY_ZERO),\n\t\tVERSAL_ECC_ERROR(KEY_WRONG_ORDER),\n\t\tVERSAL_ECC_ERROR(KEY_NOT_ON_CURVE),\n\t\tVERSAL_ECC_ERROR(BAD_SIGN),\n\t\tVERSAL_ECC_ERROR(GEN_SIGN_INCORRECT_HASH_LEN),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_INCORRECT_HASH_LEN),\n\t\tVERSAL_ECC_ERROR(GEN_SIGN_BAD_RAND_NUM),\n\t\tVERSAL_ECC_ERROR(GEN_KEY_ERR),\n\t\tVERSAL_ECC_ERROR(INVALID_PARAM),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_R_ZERO),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_S_ZERO),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_R_ORDER_ERROR),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_S_ORDER_ERROR),\n\t\tVERSAL_ECC_ERROR(KAT_INVLD_CRV_ERROR),\n\t};\n\n\tif (err <= KAT_INVLD_CRV_ERROR && err >= KAT_KEY_NOTVALID_ERROR) {\n\t\tif (elist[err - KAT_KEY_NOTVALID_ERROR].name)\n\t\t\treturn elist[err - KAT_KEY_NOTVALID_ERROR].name;\n\n\t\treturn \"Invalid\";\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic TEE_Result ecc_get_key_size(uint32_t curve, size_t *bytes, size_t *bits)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*bits = 384;\n\t\t*bytes = 48;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*bits = 521;\n\t\t*bytes = 66;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void memcpy_swp(uint8_t *to, const uint8_t *from, size_t len)\n{\n\tsize_t i = 0;\n\n\tfor (i = 0; i < len; i++)\n\t\tto[i] = from[len - 1 - i];\n}\n\nstatic void crypto_bignum_bn2bin_eswap(uint32_t curve,\n\t\t\t\t       struct bignum *from, uint8_t *to)\n{\n\tuint8_t pad[66] = { 0 };\n\tsize_t len = crypto_bignum_num_bytes(from);\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tif (ecc_get_key_size(curve, &bytes, &bits))\n\t\tpanic();\n\n\tcrypto_bignum_bn2bin(from, pad + bytes - len);\n\tmemcpy_swp(to, pad, bytes);\n}\n\nstatic TEE_Result ecc_prepare_msg(uint32_t algo, const uint8_t *msg,\n\t\t\t\t  size_t msg_len, struct versal_mbox_mem *p)\n{\n\tuint8_t swp[TEE_SHA512_HASH_SIZE + 2] = { 0 };\n\tsize_t len = 0;\n\n\tif (msg_len > TEE_SHA512_HASH_SIZE + 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (algo == TEE_ALG_ECDSA_SHA384)\n\t\tlen = TEE_SHA384_HASH_SIZE;\n\telse if (algo == TEE_ALG_ECDSA_SHA512)\n\t\tlen = TEE_SHA512_HASH_SIZE + 2;\n\telse\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Swap the hash/message and pad if necessary */\n\tmemcpy_swp(swp, msg, msg_len);\n\treturn versal_mbox_alloc(len, swp, p);\n}\n\nstatic TEE_Result verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result ret = TEE_SUCCESS;\n\tstruct versal_ecc_verify_param *cmd = NULL;\n\tstruct versal_cmd_args arg = { };\n\tstruct versal_mbox_mem x = { };\n\tstruct versal_mbox_mem s = { };\n\tstruct versal_mbox_mem p = { };\n\tstruct versal_mbox_mem cmd_buf = { };\n\tuint32_t err = 0;\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tif (sig_len % 2)\n\t\treturn TEE_ERROR_SIGNATURE_INVALID;\n\n\tret = ecc_get_key_size(key->curve, &bytes, &bits);\n\tif (ret != TEE_SUCCESS) {\n\t\tif (ret != TEE_ERROR_NOT_SUPPORTED)\n\t\t\treturn ret;\n\n\t\t/* Fallback to software */\n\t\treturn pub_ops->verify(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\tret = ecc_prepare_msg(algo, msg, msg_len, &p);\n\tif (ret)\n\t\treturn ret;\n\n\tversal_mbox_alloc(bytes * 2, NULL, &x);\n\tcrypto_bignum_bn2bin_eswap(key->curve, key->x, x.buf);\n\tcrypto_bignum_bn2bin_eswap(key->curve, key->y,\n\t\t\t\t   (uint8_t *)x.buf + bytes);\n\t/* Validate the public key for the curve */\n\targ.data[0] = key->curve;\n\targ.dlen = 1;\n\targ.ibuf[0].mem = x;\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_VALIDATE_PUBLIC_KEY,\n\t\t\t\t  &arg, &err)) {\n\t\tEMSG(\"Versal ECC: %s\", versal_ecc_error(err));\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\tmemset(&arg, 0, sizeof(arg));\n\n\tversal_mbox_alloc(sig_len, NULL, &s);\n\t/* Swap the {R,S} components */\n\tmemcpy_swp(s.buf, sig, sig_len / 2);\n\tmemcpy_swp((uint8_t *)s.buf + sig_len / 2, sig + sig_len / 2,\n\t\t   sig_len / 2);\n\tversal_mbox_alloc(sizeof(*cmd), NULL, &cmd_buf);\n\n\tcmd = cmd_buf.buf;\n\tcmd->signature_addr = virt_to_phys(s.buf);\n\tcmd->pub_key_addr = virt_to_phys(x.buf);\n\tcmd->hash_addr = virt_to_phys(p.buf);\n\tcmd->hash_len = p.len;\n\tcmd->curve = key->curve;\n\n\targ.ibuf[0].mem = cmd_buf;\n\targ.ibuf[1].mem = p;\n\targ.ibuf[1].only_cache = true;\n\targ.ibuf[2].mem = x;\n\targ.ibuf[3].mem = s;\n\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_VERIFY_SIGN, &arg, &err)) {\n\t\tEMSG(\"Versal ECC: %s\", versal_ecc_error(err));\n\t\tret = TEE_ERROR_GENERIC;\n\t}\nout:\n\tfree(p.buf);\n\tfree(x.buf);\n\tfree(s.buf);\n\tfree(cmd);\n\n\treturn ret;\n}\n\nstatic TEE_Result sign(uint32_t algo, struct ecc_keypair *key,\n\t\t       const uint8_t *msg, size_t msg_len,\n\t\t       uint8_t *sig, size_t *sig_len)\n{\n\tstruct versal_ecc_sign_param *cmd = NULL;\n\tstruct versal_mbox_mem cmd_buf = { };\n\tstruct ecc_keypair ephemeral = { };\n\tstruct versal_cmd_args arg = { };\n\tstruct versal_mbox_mem p = { };\n\tstruct versal_mbox_mem k = { };\n\tstruct versal_mbox_mem d = { };\n\tstruct versal_mbox_mem s = { };\n\tTEE_Result ret = TEE_SUCCESS;\n\tuint32_t err = 0;\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tret = ecc_get_key_size(key->curve, &bytes, &bits);\n\tif (ret != TEE_SUCCESS) {\n\t\tif (ret != TEE_ERROR_NOT_SUPPORTED)\n\t\t\treturn ret;\n\n\t\t/* Fallback to software */\n\t\treturn pair_ops->sign(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\t/* Hash and update the length */\n\tret = ecc_prepare_msg(algo, msg, msg_len, &p);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Ephemeral private key */\n\tret = drvcrypt_asym_alloc_ecc_keypair(&ephemeral,\n\t\t\t\t\t      TEE_TYPE_ECDSA_KEYPAIR, bits);\n\tif (ret) {\n\t\tEMSG(\"Versal, can't allocate the ephemeral key\");\n\t\treturn ret;\n\t}\n\n\tephemeral.curve = key->curve;\n\tret = crypto_acipher_gen_ecc_key(&ephemeral, bits);\n\tif (ret) {\n\t\tEMSG(\"Versal, can't generate the ephemeral key\");\n\t\treturn ret;\n\t}\n\n\tversal_mbox_alloc(bytes, NULL, &k);\n\tcrypto_bignum_bn2bin_eswap(key->curve, ephemeral.d, k.buf);\n\tcrypto_bignum_free(ephemeral.d);\n\tcrypto_bignum_free(ephemeral.x);\n\tcrypto_bignum_free(ephemeral.y);\n\n\t/* Private key*/\n\tversal_mbox_alloc(bytes, NULL, &d);\n\tcrypto_bignum_bn2bin_eswap(key->curve, key->d, d.buf);\n\n\t/* Signature */\n\tversal_mbox_alloc(*sig_len, NULL, &s);\n\n\t/* IPI command */\n\tversal_mbox_alloc(sizeof(*cmd), NULL, &cmd_buf);\n\n\tcmd = cmd_buf.buf;\n\tcmd->priv_key_addr = virt_to_phys(d.buf);\n\tcmd->epriv_key_addr = virt_to_phys(k.buf);\n\tcmd->hash_addr = virt_to_phys(p.buf);\n\tcmd->hash_len = p.len;\n\tcmd->curve = key->curve;\n\n\targ.ibuf[0].mem = cmd_buf;\n\targ.ibuf[1].mem = s;\n\targ.ibuf[2].mem = k;\n\targ.ibuf[3].mem = d;\n\targ.ibuf[4].mem = p;\n\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_GENERATE_SIGN, &arg, &err)) {\n\t\tEMSG(\"Versal ECC: %s\", versal_ecc_error(err));\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\t*sig_len = 2 * bytes;\n\n\t/* Swap the {R,S} components */\n\tmemcpy_swp(sig, s.buf, *sig_len / 2);\n\tmemcpy_swp(sig + *sig_len / 2, (uint8_t *)s.buf + *sig_len / 2,\n\t\t   *sig_len / 2);\nout:\n\tfree(cmd);\n\tfree(k.buf);\n\tfree(p.buf);\n\tfree(s.buf);\n\tfree(d.buf);\n\n\treturn ret;\n}\n\nstatic TEE_Result shared_secret(struct ecc_keypair *private_key,\n\t\t\t\tstruct ecc_public_key *public_key,\n\t\t\t\tvoid *secret, size_t *secret_len)\n{\n\treturn pair_ops->shared_secret(private_key, public_key,\n\t\t\t\t\t  secret, secret_len);\n}\n\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\treturn shared_secret(sdata->key_priv,\n\t\t\t     sdata->key_pub,\n\t\t\t     sdata->secret.data,\n\t\t\t     &sdata->secret.length);\n}\n\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata)\n{\n\treturn sign(sdata->algo,\n\t\t    sdata->key,\n\t\t    sdata->message.data,\n\t\t    sdata->message.length,\n\t\t    sdata->signature.data,\n\t\t    &sdata->signature.length);\n}\n\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata)\n{\n\treturn verify(sdata->algo,\n\t\t      sdata->key,\n\t\t      sdata->message.data,\n\t\t      sdata->message.length,\n\t\t      sdata->signature.data,\n\t\t      sdata->signature.length);\n}\n\nstatic TEE_Result do_gen_keypair(struct ecc_keypair *s, size_t size_bits)\n{\n\t/*\n\t * Versal requires little endian so need to memcpy_swp on Versal IP ops.\n\t * We chose not to do it here because some tests might be using\n\t * their own keys\n\t */\n\treturn pair_ops->generate(s, size_bits);\n}\n\nstatic TEE_Result do_alloc_keypair(struct ecc_keypair *s,\n\t\t\t\t   uint32_t type, size_t size_bits)\n{\n\tTEE_Result ret = TEE_SUCCESS;\n\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tret = crypto_asym_alloc_ecc_keypair(s, TEE_TYPE_ECDSA_KEYPAIR,\n\t\t\t\t\t    size_bits);\n\tif (ret)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Ignore the software operations, the crypto API will populate\n\t * this interface.\n\t */\n\ts->ops = NULL;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result do_alloc_publickey(struct ecc_public_key *s,\n\t\t\t\t     uint32_t type, size_t size_bits)\n{\n\tTEE_Result ret = TEE_SUCCESS;\n\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tret = crypto_asym_alloc_ecc_public_key(s, TEE_TYPE_ECDSA_PUBLIC_KEY,\n\t\t\t\t\t       size_bits);\n\tif (ret)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Ignore the software operations, the crypto API will populate\n\t * this interface.\n\t */\n\ts->ops = NULL;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void do_free_publickey(struct ecc_public_key *s)\n{\n\treturn pub_ops->free(s);\n}\n\nstatic struct drvcrypt_ecc driver_ecc = {\n\t.shared_secret = do_shared_secret,\n\t.alloc_publickey = do_alloc_publickey,\n\t.free_publickey = do_free_publickey,\n\t.alloc_keypair = do_alloc_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.verify = do_verify,\n\t.sign = do_sign,\n};\n\nstatic TEE_Result ecc_init(void)\n{\n\tstruct versal_cmd_args arg = { };\n\tuint32_t err = 0;\n\n\targ.data[arg.dlen++] = XSECURE_ECDSA_KAT_NIST_P384;\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_KAT, &arg, &err)) {\n\t\tEMSG(\"Versal KAG NIST_P384: %s\", versal_ecc_error(err));\n\t\treturn TEE_ERROR_GENERIC;\n\t}\n\n\t/* Clean previous request */\n\targ.dlen = 0;\n\n\targ.data[arg.dlen++] = XSECURE_ECDSA_KAT_NIST_P521;\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_KAT, &arg, &err)) {\n\t\tEMSG(\"Versal KAG NIST_P521 %s\", versal_ecc_error(err));\n\t\treturn TEE_ERROR_GENERIC;\n\t}\n\n\tpair_ops = crypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDSA_KEYPAIR);\n\tif (!pair_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tpub_ops = crypto_asym_get_ecc_public_ops(TEE_TYPE_ECDSA_PUBLIC_KEY);\n\tif (!pub_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/* This driver supports both ECDH and ECDSA */\n\tassert((pub_ops ==\n\t\tcrypto_asym_get_ecc_public_ops(TEE_TYPE_ECDH_PUBLIC_KEY)) &&\n\t       (pair_ops ==\n\t\tcrypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDH_KEYPAIR)));\n\n\treturn drvcrypt_register_ecc(&driver_ecc);\n}\n\ndriver_init(ecc_init);\n", "/* SPDX-License-Identifier: BSD-2-Clause */\n/*\n * Copyright (c) 2014-2017, Linaro Limited\n */\n\n/*\n * This is the Cryptographic Provider API (CP API).\n *\n * This defines how most crypto syscalls that implement the Cryptographic\n * Operations API can invoke the actual providers of cryptographic algorithms\n * (such as LibTomCrypt).\n *\n * To add a new provider, you need to provide an implementation of this\n * interface.\n *\n * The following parameters are commonly used.\n *\n * @ctx: context allocated by the syscall, for later use by the algorithm\n * @algo: algorithm identifier (TEE_ALG_*)\n */\n\n#ifndef __CRYPTO_CRYPTO_H\n#define __CRYPTO_CRYPTO_H\n\n#include <tee/tee_obj.h>\n#include <tee_api_types.h>\n\nTEE_Result crypto_init(void);\n\n/* Message digest functions */\nTEE_Result crypto_hash_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_hash_init(void *ctx);\nTEE_Result crypto_hash_update(void *ctx, const uint8_t *data, size_t len);\nTEE_Result crypto_hash_final(void *ctx, uint8_t *digest, size_t len);\nvoid crypto_hash_free_ctx(void *ctx);\nvoid crypto_hash_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Symmetric ciphers */\nTEE_Result crypto_cipher_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_cipher_init(void *ctx, TEE_OperationMode mode,\n\t\t\t      const uint8_t *key1, size_t key1_len,\n\t\t\t      const uint8_t *key2, size_t key2_len,\n\t\t\t      const uint8_t *iv, size_t iv_len);\nTEE_Result crypto_cipher_update(void *ctx, TEE_OperationMode mode,\n\t\t\t\tbool last_block, const uint8_t *data,\n\t\t\t\tsize_t len, uint8_t *dst);\nvoid crypto_cipher_final(void *ctx);\nTEE_Result crypto_cipher_get_block_size(uint32_t algo, size_t *size);\nvoid crypto_cipher_free_ctx(void *ctx);\nvoid crypto_cipher_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Message Authentication Code functions */\nTEE_Result crypto_mac_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_mac_init(void *ctx, const uint8_t *key, size_t len);\nTEE_Result crypto_mac_update(void *ctx, const uint8_t *data, size_t len);\nTEE_Result crypto_mac_final(void *ctx, uint8_t *digest, size_t digest_len);\nvoid crypto_mac_free_ctx(void *ctx);\nvoid crypto_mac_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Authenticated encryption */\nTEE_Result crypto_authenc_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_authenc_init(void *ctx, TEE_OperationMode mode,\n\t\t\t       const uint8_t *key, size_t key_len,\n\t\t\t       const uint8_t *nonce, size_t nonce_len,\n\t\t\t       size_t tag_len, size_t aad_len,\n\t\t\t       size_t payload_len);\nTEE_Result crypto_authenc_update_aad(void *ctx, TEE_OperationMode mode,\n\t\t\t\t     const uint8_t *data, size_t len);\nTEE_Result crypto_authenc_update_payload(void *ctx, TEE_OperationMode mode,\n\t\t\t\t\t const uint8_t *src_data,\n\t\t\t\t\t size_t src_len, uint8_t *dst_data,\n\t\t\t\t\t size_t *dst_len);\nTEE_Result crypto_authenc_enc_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, uint8_t *dst_tag,\n\t\t\t\t    size_t *dst_tag_len);\nTEE_Result crypto_authenc_dec_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, const uint8_t *tag,\n\t\t\t\t    size_t tag_len);\nvoid crypto_authenc_final(void *ctx);\nvoid crypto_authenc_free_ctx(void *ctx);\nvoid crypto_authenc_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Informs crypto that the data in the buffer will be removed from storage */\nTEE_Result crypto_storage_obj_del(struct tee_obj *obj);\n\n/* Implementation-defined big numbers */\n\n/*\n * Allocate a bignum capable of holding an unsigned integer value of\n * up to bitsize bits\n */\nstruct bignum *crypto_bignum_allocate(size_t size_bits);\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,\n\t\t\t\tstruct bignum *to);\nsize_t crypto_bignum_num_bytes(struct bignum *a);\nsize_t crypto_bignum_num_bits(struct bignum *a);\nvoid crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to);\nvoid crypto_bignum_copy(struct bignum *to, const struct bignum *from);\nvoid crypto_bignum_free(struct bignum *a);\nvoid crypto_bignum_clear(struct bignum *a);\n\n/* return -1 if a<b, 0 if a==b, +1 if a>b */\nint32_t crypto_bignum_compare(struct bignum *a, struct bignum *b);\n\n/* Asymmetric algorithms */\n\nstruct rsa_keypair {\n\tstruct bignum *e;\t/* Public exponent */\n\tstruct bignum *d;\t/* Private exponent */\n\tstruct bignum *n;\t/* Modulus */\n\n\t/* Optional CRT parameters (all NULL if unused) */\n\tstruct bignum *p;\t/* N = pq */\n\tstruct bignum *q;\n\tstruct bignum *qp;\t/* 1/q mod p */\n\tstruct bignum *dp;\t/* d mod (p-1) */\n\tstruct bignum *dq;\t/* d mod (q-1) */\n};\n\nstruct rsa_public_key {\n\tstruct bignum *e;\t/* Public exponent */\n\tstruct bignum *n;\t/* Modulus */\n};\n\nstruct dsa_keypair {\n\tstruct bignum *g;\t/* Generator of subgroup (public) */\n\tstruct bignum *p;\t/* Prime number (public) */\n\tstruct bignum *q;\t/* Order of subgroup (public) */\n\tstruct bignum *y;\t/* Public key */\n\tstruct bignum *x;\t/* Private key */\n};\n\nstruct dsa_public_key {\n\tstruct bignum *g;\t/* Generator of subgroup (public) */\n\tstruct bignum *p;\t/* Prime number (public) */\n\tstruct bignum *q;\t/* Order of subgroup (public) */\n\tstruct bignum *y;\t/* Public key */\n};\n\nstruct dh_keypair {\n\tstruct bignum *g;\t/* Generator of Z_p (shared) */\n\tstruct bignum *p;\t/* Prime modulus (shared) */\n\tstruct bignum *x;\t/* Private key */\n\tstruct bignum *y;\t/* Public key y = g^x */\n\n\t/*\n\t * Optional parameters used by key generation.\n\t * When not used, q == NULL and xbits == 0\n\t */\n\tstruct bignum *q;\t/* x must be in the range [2, q-2] */\n\tuint32_t xbits;\t\t/* Number of bits in the private key */\n};\n\nstruct ecc_public_key {\n\tstruct bignum *x;\t/* Public value x */\n\tstruct bignum *y;\t/* Public value y */\n\tuint32_t curve;\t        /* Curve type */\n\tconst struct crypto_ecc_public_ops *ops; /* Key Operations */\n};\n\nstruct ecc_keypair {\n\tstruct bignum *d;\t/* Private value */\n\tstruct bignum *x;\t/* Public value x */\n\tstruct bignum *y;\t/* Public value y */\n\tuint32_t curve;\t        /* Curve type */\n\tconst struct crypto_ecc_keypair_ops *ops; /* Key Operations */\n};\n\nstruct x25519_keypair {\n\tuint8_t *priv;\t/* Private value */\n\tuint8_t *pub;\t/* Public value */\n};\n\nstruct ed25519_keypair {\n\tuint8_t *priv;\n\tuint8_t *pub;\n\tuint32_t curve;\n};\n\nstruct ed25519_public_key {\n\tuint8_t *pub;\n\tuint32_t curve;\n};\n\n/*\n * Key allocation functions\n * Allocate the bignum's inside a key structure.\n * TEE core will later use crypto_bignum_free().\n */\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\tsize_t key_size_bits);\nTEE_Result crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t   size_t key_size_bits);\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s);\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s);\nTEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\tsize_t key_size_bits);\nTEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t   size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,\n\t\t\t       size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t       uint32_t key_type,\n\t\t\t\t\t       size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits);\nvoid crypto_acipher_free_ecc_public_key(struct ecc_public_key *s);\nTEE_Result crypto_acipher_alloc_x25519_keypair(struct x25519_keypair *s,\n\t\t\t\t\t       size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_ed25519_keypair(struct ed25519_keypair *s,\n\t\t\t\t\t\tsize_t key_size_bits);\nTEE_Result\ncrypto_acipher_alloc_ed25519_public_key(struct ed25519_public_key *key,\n\t\t\t\t\tsize_t key_size);\n\n/*\n * Key generation functions\n */\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key, size_t key_size);\nTEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key, size_t key_size);\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key, struct bignum *q,\n\t\t\t\t     size_t xbits, size_t key_size);\nTEE_Result crypto_acipher_gen_ecc_key(struct ecc_keypair *key, size_t key_size);\nTEE_Result crypto_acipher_gen_x25519_key(struct x25519_keypair *key,\n\t\t\t\t\t size_t key_size);\nTEE_Result crypto_acipher_gen_ed25519_key(struct ed25519_keypair *key,\n\t\t\t\t\t  size_t key_size);\nTEE_Result crypto_acipher_ed25519_sign(struct ed25519_keypair *key,\n\t\t\t\t       const uint8_t *msg, size_t msg_len,\n\t\t\t\t       uint8_t *sig, size_t *sig_len);\nTEE_Result crypto_acipher_ed25519ctx_sign(struct ed25519_keypair *key,\n\t\t\t\t\t  const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t  uint8_t *sig, size_t *sig_len,\n\t\t\t\t\t  bool ph_flag,\n\t\t\t\t\t  const uint8_t *ctx, size_t ctxlen);\nTEE_Result crypto_acipher_ed25519_verify(struct ed25519_public_key *key,\n\t\t\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t const uint8_t *sig, size_t sig_len);\nTEE_Result crypto_acipher_ed25519ctx_verify(struct ed25519_public_key *key,\n\t\t\t\t\t    const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t    const uint8_t *sig, size_t sig_len,\n\t\t\t\t\t    bool ph_flag,\n\t\t\t\t\t    const uint8_t *ctx, size_t ctxlen);\n\nTEE_Result crypto_acipher_dh_shared_secret(struct dh_keypair *private_key,\n\t\t\t\t\t   struct bignum *public_key,\n\t\t\t\t\t   struct bignum *secret);\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t\tconst uint8_t *label, size_t label_len,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tconst uint8_t *label, size_t label_len,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len);\n/* RSA SSA sign/verify: if salt_len == -1, use default value */\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t      int salt_len, const uint8_t *msg,\n\t\t\t\t      size_t msg_len, uint8_t *sig,\n\t\t\t\t      size_t *sig_len);\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tint salt_len, const uint8_t *msg,\n\t\t\t\t\tsize_t msg_len, const uint8_t *sig,\n\t\t\t\t\tsize_t sig_len);\nTEE_Result crypto_acipher_dsa_sign(uint32_t algo, struct dsa_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len);\nTEE_Result crypto_acipher_dsa_verify(uint32_t algo, struct dsa_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len);\nTEE_Result crypto_acipher_ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len);\nTEE_Result crypto_acipher_ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len);\nTEE_Result crypto_acipher_ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t\t    struct ecc_public_key *public_key,\n\t\t\t\t\t    void *secret,\n\t\t\t\t\t    unsigned long *secret_len);\nTEE_Result crypto_acipher_sm2_pke_decrypt(struct ecc_keypair *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_sm2_pke_encrypt(struct ecc_public_key *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_x25519_shared_secret(struct x25519_keypair\n\t\t\t\t\t       *private_key,\n\t\t\t\t\t       void *public_key, void *secret,\n\t\t\t\t\t       unsigned long *secret_len);\n\nstruct sm2_kep_parms {\n\tuint8_t *out;\n\tsize_t out_len;\n\tbool is_initiator;\n\tconst uint8_t *initiator_id;\n\tsize_t initiator_id_len;\n\tconst uint8_t *responder_id;\n\tsize_t responder_id_len;\n\tconst uint8_t *conf_in;\n\tsize_t conf_in_len;\n\tuint8_t *conf_out;\n\tsize_t conf_out_len;\n};\n\nTEE_Result crypto_acipher_sm2_kep_derive(struct ecc_keypair *my_key,\n\t\t\t\t\t struct ecc_keypair *my_eph_key,\n\t\t\t\t\t struct ecc_public_key *peer_key,\n\t\t\t\t\t struct ecc_public_key *peer_eph_key,\n\t\t\t\t\t struct sm2_kep_parms *p);\n\n/*\n * Verifies a SHA-256 hash, doesn't require crypto_init() to be called in\n * advance and has as few dependencies as possible.\n *\n * This function is primarily used by pager and early initialization code\n * where the complete crypto library isn't available.\n */\nTEE_Result hash_sha256_check(const uint8_t *hash, const uint8_t *data,\n\t\tsize_t data_size);\n\n/*\n * Computes a SHA-512/256 hash, vetted conditioner as per NIST.SP.800-90B.\n * It doesn't require crypto_init() to be called in advance and has as few\n * dependencies as possible.\n *\n * This function could be used inside interrupt context where the crypto\n * library can't be used due to mutex handling.\n */\nTEE_Result hash_sha512_256_compute(uint8_t *digest, const uint8_t *data,\n\t\tsize_t data_size);\n\n#define CRYPTO_RNG_SRC_IS_QUICK(sid) (!!((sid) & 1))\n\n/*\n * enum crypto_rng_src - RNG entropy source\n *\n * Identifiers for different RNG entropy sources. The lowest bit indicates\n * if the source is to be merely queued (bit is 1) or if it's delivered\n * directly to the pool. The difference is that in the latter case RPC to\n * normal world can be performed and in the former it must not.\n */\nenum crypto_rng_src {\n\tCRYPTO_RNG_SRC_JITTER_SESSION\t= (0 << 1 | 0),\n\tCRYPTO_RNG_SRC_JITTER_RPC\t= (1 << 1 | 1),\n\tCRYPTO_RNG_SRC_NONSECURE\t= (1 << 1 | 0),\n};\n\n/*\n * crypto_rng_init() - initialize the RNG\n * @data:\tbuffer with initial seed\n * @dlen:\tlength of @data\n */\nTEE_Result crypto_rng_init(const void *data, size_t dlen);\n\n/*\n * crypto_rng_add_event() - supply entropy to RNG from a source\n * @sid:\tSource identifier, should be unique for a specific source\n * @pnum:\tPool number, acquired using crypto_rng_get_next_pool_num()\n * @data:\tData associated with the event\n * @dlen:\tLength of @data\n *\n * @sid controls whether the event is merly queued in a ring buffer or if\n * it's added to one of the pools directly. If CRYPTO_RNG_SRC_IS_QUICK() is\n * true (lowest bit set) events are queue otherwise added to corresponding\n * pool. If CRYPTO_RNG_SRC_IS_QUICK() is false, eventual queued events are\n * added to their queues too.\n */\nvoid crypto_rng_add_event(enum crypto_rng_src sid, unsigned int *pnum,\n\t\t\t  const void *data, size_t dlen);\n\n/*\n * crypto_rng_read() - read cryptograhically secure RNG\n * @buf:\tBuffer to hold the data\n * @len:\tLength of buffer.\n *\n * Eventual queued events are also added to their pools during this\n * function call.\n */\nTEE_Result crypto_rng_read(void *buf, size_t len);\n\n/*\n * crypto_aes_expand_enc_key() - Expand an AES key\n * @key:\tAES key buffer\n * @key_len:\tSize of the @key buffer in bytes\n * @enc_key:\tExpanded AES encryption key buffer\n * @enc_keylen: Size of the @enc_key buffer in bytes\n * @rounds:\tNumber of rounds to be used during encryption\n */\nTEE_Result crypto_aes_expand_enc_key(const void *key, size_t key_len,\n\t\t\t\t     void *enc_key, size_t enc_keylen,\n\t\t\t\t     unsigned int *rounds);\n\n/*\n * crypto_aes_enc_block() - Encrypt an AES block\n * @enc_key:\tExpanded AES encryption key\n * @enc_keylen:\tSize of @enc_key in bytes\n * @rounds:\tNumber of rounds\n * @src:\tSource buffer of one AES block (16 bytes)\n * @dst:\tDestination buffer of one AES block (16 bytes)\n */\nvoid crypto_aes_enc_block(const void *enc_key, size_t enc_keylen,\n\t\t\t  unsigned int rounds, const void *src, void *dst);\n\n#endif /* __CRYPTO_CRYPTO_H */\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_types.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,\n\t\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->y);\n\tcrypto_bignum_free(s->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key, struct bignum *q,\n\t\t\t\t     size_t xbits, size_t key_size)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tdh_key ltc_tmp_key = { };\n\tint ltc_res = 0;\n\n\tif (key_size != 8 * mp_unsigned_bin_size(key->p))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tltc_res = mp_init_multi(&ltc_tmp_key.base, &ltc_tmp_key.prime, NULL);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\t/* Generate the DH key */\n\tmp_copy(key->g, ltc_tmp_key.base);\n\tmp_copy(key->p, ltc_tmp_key.prime);\n\tltc_res = dh_make_key(NULL, find_prng(\"prng_crypto\"), q, xbits,\n\t\t\t      &ltc_tmp_key);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\tltc_mp.copy(ltc_tmp_key.y,  key->y);\n\t\tltc_mp.copy(ltc_tmp_key.x,  key->x);\n\t\tres = TEE_SUCCESS;\n\t}\n\n\tdh_free(&ltc_tmp_key);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_dh_shared_secret(struct dh_keypair *private_key,\n\t\t\t\t\t   struct bignum *public_key,\n\t\t\t\t\t   struct bignum *secret)\n{\n\tint err;\n\n\tif (!private_key || !public_key || !secret)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\terr = mp_exptmod(public_key, private_key->x, private_key->p, secret);\n\treturn ((err == CRYPT_OK) ? TEE_SUCCESS : TEE_ERROR_BAD_PARAMETERS);\n\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\nTEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key, size_t key_size)\n{\n\tdsa_key ltc_tmp_key = { };\n\tint ltc_res = 0;\n\n\tif (key_size != 8 * mp_unsigned_bin_size(key->p))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tltc_res = mp_init_multi(&ltc_tmp_key.g, &ltc_tmp_key.p, &ltc_tmp_key.q,\n\t\t\t\t&ltc_tmp_key.x, &ltc_tmp_key.y, NULL);\n\tif (ltc_res)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\t/* Copy the key parameters */\n\tmp_copy(key->g, ltc_tmp_key.g);\n\tmp_copy(key->p, ltc_tmp_key.p);\n\tmp_copy(key->q, ltc_tmp_key.q);\n\n\t/* Generate the DSA key */\n\tltc_res = dsa_generate_key(NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t   &ltc_tmp_key);\n\tif (ltc_res)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Copy the key */\n\tmp_copy(ltc_tmp_key.y, key->y);\n\tmp_copy(ltc_tmp_key.x, key->x);\n\n\t/* Free the temporary key */\n\tdsa_free(&ltc_tmp_key);\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result crypto_acipher_dsa_sign(uint32_t algo, struct dsa_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len)\n{\n\tTEE_Result res;\n\tsize_t hash_size;\n\tint ltc_res;\n\tvoid *r, *s;\n\tdsa_key ltc_key = {\n\t\t.type = PK_PRIVATE,\n\t\t.qord = mp_unsigned_bin_size(key->q),\n\t\t.g = key->g,\n\t\t.p = key->p,\n\t\t.q = key->q,\n\t\t.y = key->y,\n\t\t.x = key->x,\n\t};\n\n\tif (algo != TEE_ALG_DSA_SHA1 &&\n\t    algo != TEE_ALG_DSA_SHA224 &&\n\t    algo != TEE_ALG_DSA_SHA256) {\n\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\tgoto err;\n\t}\n\n\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t      &hash_size);\n\tif (res != TEE_SUCCESS)\n\t\tgoto err;\n\tif (mp_unsigned_bin_size(ltc_key.q) < hash_size)\n\t\thash_size = mp_unsigned_bin_size(ltc_key.q);\n\tif (msg_len != hash_size) {\n\t\tres = TEE_ERROR_SECURITY;\n\t\tgoto err;\n\t}\n\n\tif (*sig_len < 2 * mp_unsigned_bin_size(ltc_key.q)) {\n\t\t*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto err;\n\t}\n\n\tltc_res = mp_init_multi(&r, &s, NULL);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\n\tltc_res = dsa_sign_hash_raw(msg, msg_len, r, s, NULL,\n\t\t\t\t    find_prng(\"prng_crypto\"), &ltc_key);\n\n\tif (ltc_res == CRYPT_OK) {\n\t\t*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);\n\t\tmemset(sig, 0, *sig_len);\n\t\tmp_to_unsigned_bin(r, (uint8_t *)sig + *sig_len/2 -\n\t\t\t\t   mp_unsigned_bin_size(r));\n\t\tmp_to_unsigned_bin(s, (uint8_t *)sig + *sig_len -\n\t\t\t\t   mp_unsigned_bin_size(s));\n\t\tres = TEE_SUCCESS;\n\t} else {\n\t\tres = TEE_ERROR_GENERIC;\n\t}\n\n\tmp_clear_multi(r, s, NULL);\n\nerr:\n\treturn res;\n}\n\nTEE_Result crypto_acipher_dsa_verify(uint32_t algo, struct dsa_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tint ltc_stat, ltc_res;\n\tvoid *r, *s;\n\tdsa_key ltc_key = {\n\t\t.type = PK_PUBLIC,\n\t\t.qord = mp_unsigned_bin_size(key->q),\n\t\t.g = key->g,\n\t\t.p = key->p,\n\t\t.q = key->q,\n\t\t.y = key->y\n\t};\n\n\tif (algo != TEE_ALG_DSA_SHA1 &&\n\t    algo != TEE_ALG_DSA_SHA224 &&\n\t    algo != TEE_ALG_DSA_SHA256) {\n\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\tgoto err;\n\t}\n\n\tltc_res = mp_init_multi(&r, &s, NULL);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tmp_read_unsigned_bin(r, (uint8_t *)sig, sig_len/2);\n\tmp_read_unsigned_bin(s, (uint8_t *)sig + sig_len/2, sig_len/2);\n\tltc_res = dsa_verify_hash_raw(r, s, msg, msg_len, &ltc_stat, &ltc_key);\n\tmp_clear_multi(r, s, NULL);\n\tres = convert_ltc_verify_status(ltc_res, ltc_stat);\nerr:\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, Linaro Limited\n */\n\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_types.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\nstatic void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}\n\n/*\n * For a given TEE @curve, return key size and LTC curve name. Also check that\n * @algo is compatible with this curve.\n * @curve: TEE_ECC_CURVE_NIST_P192, ...\n * @algo: TEE_ALG_ECDSA_SHA1, ...\n */\nstatic TEE_Result ecc_get_curve_info(uint32_t curve, uint32_t algo,\n\t\t\t\t     size_t *key_size_bytes,\n\t\t\t\t     size_t *key_size_bits,\n\t\t\t\t     const char **curve_name)\n{\n\tsize_t size_bytes = 0;\n\tsize_t size_bits = 0;\n\tconst char *name = NULL;\n\n\t/*\n\t * Excerpt of libtomcrypt documentation:\n\t * ecc_make_key(... key_size ...): The keysize is the size of the\n\t * modulus in bytes desired. Currently directly supported values\n\t * are 12, 16, 20, 24, 28, 32, 48, and 65 bytes which correspond\n\t * to key sizes of 112, 128, 160, 192, 224, 256, 384, and 521 bits\n\t * respectively.\n\t */\n\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\tsize_bits = 192;\n\t\tsize_bytes = 24;\n\t\tname = \"NISTP192\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA1) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\tsize_bits = 224;\n\t\tsize_bytes = 28;\n\t\tname = \"NISTP224\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA224) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\tsize_bits = 256;\n\t\tsize_bytes = 32;\n\t\tname = \"NISTP256\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA256) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\tsize_bits = 384;\n\t\tsize_bytes = 48;\n\t\tname = \"NISTP384\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA384) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\tsize_bits = 521;\n\t\tsize_bytes = 66;\n\t\tname = \"NISTP521\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA512) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_SM2:\n\t\tsize_bits = 256;\n\t\tsize_bytes = 32;\n\t\tname = \"SM2\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_SM2_PKE) &&\n\t\t    (algo != TEE_ALG_SM2_DSA_SM3) &&\n\t\t    (algo != TEE_ALG_SM2_KEP))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\tif (key_size_bytes)\n\t\t*key_size_bytes = size_bytes;\n\tif (key_size_bits)\n\t\t*key_size_bits = size_bits;\n\tif (curve_name)\n\t\t*curve_name = name;\n\treturn TEE_SUCCESS;\n}\n\n/* Note: this function clears the key before setting the curve */\nstatic TEE_Result ecc_set_curve_from_name(ecc_key *ltc_key,\n\t\t\t\t\t  const char *curve_name)\n{\n\tconst ltc_ecc_curve *curve = NULL;\n\tint ltc_res = 0;\n\n\tltc_res = ecc_find_curve(curve_name, &curve);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tltc_res = ecc_set_curve(curve, ltc_key);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_GENERIC;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result _ltc_ecc_generate_keypair(struct ecc_keypair *key,\n\t\t\t\t\t    size_t key_size)\n{\n\tTEE_Result res;\n\tecc_key ltc_tmp_key;\n\tint ltc_res;\n\tsize_t key_size_bytes = 0;\n\tsize_t key_size_bits = 0;\n\tconst char *name = NULL;\n\n\tres = ecc_get_curve_info(key->curve, 0, &key_size_bytes, &key_size_bits,\n\t\t\t\t &name);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (key_size != key_size_bits)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_set_curve_from_name(&ltc_tmp_key, name);\n\tif (res)\n\t\treturn res;\n\n\t/* Generate the ECC key */\n\tltc_res = ecc_generate_key(NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t   &ltc_tmp_key);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* check the size of the keys */\n\tif (((size_t)mp_count_bits(ltc_tmp_key.pubkey.x) > key_size_bits) ||\n\t    ((size_t)mp_count_bits(ltc_tmp_key.pubkey.y) > key_size_bits) ||\n\t    ((size_t)mp_count_bits(ltc_tmp_key.k) > key_size_bits)) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\t/* check LTC is returning z==1 */\n\tif (mp_count_bits(ltc_tmp_key.pubkey.z) != 1) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\t/* Copy the key */\n\tltc_mp.copy(ltc_tmp_key.k, key->d);\n\tltc_mp.copy(ltc_tmp_key.pubkey.x, key->x);\n\tltc_mp.copy(ltc_tmp_key.pubkey.y, key->y);\n\n\tres = TEE_SUCCESS;\n\nexit:\n\tecc_free(&ltc_tmp_key);\t\t/* Free the temporary key */\n\treturn res;\n}\n\n/*\n * Given a keypair \"key\", populate the Libtomcrypt private key \"ltc_key\"\n * It also returns the key size, in bytes\n */\nTEE_Result ecc_populate_ltc_private_key(ecc_key *ltc_key,\n\t\t\t\t\tstruct ecc_keypair *key,\n\t\t\t\t\tuint32_t algo, size_t *key_size_bytes)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tconst char *name = NULL;\n\n\tres = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);\n\tif (res)\n\t\treturn res;\n\n\tmemset(ltc_key, 0, sizeof(*ltc_key));\n\n\tres = ecc_set_curve_from_name(ltc_key, name);\n\tif (res)\n\t\treturn res;\n\n\tltc_key->type = PK_PRIVATE;\n\tmp_copy(key->d, ltc_key->k);\n\tmp_copy(key->x, ltc_key->pubkey.x);\n\tmp_copy(key->y, ltc_key->pubkey.y);\n\tmp_set_int(ltc_key->pubkey.z, 1);\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Given a public \"key\", populate the Libtomcrypt public key \"ltc_key\"\n * It also returns the key size, in bytes\n */\nTEE_Result ecc_populate_ltc_public_key(ecc_key *ltc_key,\n\t\t\t\t       struct ecc_public_key *key,\n\t\t\t\t       uint32_t algo, size_t *key_size_bytes)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tconst char *name = NULL;\n\tuint8_t one[1] = { 1 };\n\n\tres = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);\n\tif (res)\n\t\treturn res;\n\n\tmemset(ltc_key, 0, sizeof(*ltc_key));\n\n\tres = ecc_set_curve_from_name(ltc_key, name);\n\tif (res)\n\t\treturn res;\n\n\tltc_key->type = PK_PUBLIC;\n\n\tmp_copy(key->x, ltc_key->pubkey.x);\n\tmp_copy(key->y, ltc_key->pubkey.y);\n\tmp_read_unsigned_bin(ltc_key->pubkey.z, one, sizeof(one));\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result _ltc_ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\tconst uint8_t *msg, size_t msg_len,\n\t\t\t\tuint8_t *sig, size_t *sig_len)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tint ltc_res = 0;\n\tsize_t key_size_bytes = 0;\n\tecc_key ltc_key = { };\n\tunsigned long ltc_sig_len = 0;\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_populate_ltc_private_key(&ltc_key, key, algo,\n\t\t\t\t\t   &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (*sig_len < 2 * key_size_bytes) {\n\t\t*sig_len = 2 * key_size_bytes;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tltc_sig_len = *sig_len;\n\tltc_res = ecc_sign_hash_rfc7518(msg, msg_len, sig, &ltc_sig_len,\n\t\t\t\t    NULL, find_prng(\"prng_crypto\"), &ltc_key);\n\tif (ltc_res == CRYPT_OK) {\n\t\tres = TEE_SUCCESS;\n\t} else {\n\t\tres = TEE_ERROR_GENERIC;\n\t}\n\t*sig_len = ltc_sig_len;\n\nout:\n\tecc_free(&ltc_key);\n\treturn res;\n}\n\nstatic TEE_Result _ltc_ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t  const uint8_t *msg, size_t msg_len,\n\t\t\t\t  const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tint ltc_stat = 0;\n\tint ltc_res = 0;\n\tsize_t key_size_bytes = 0;\n\tecc_key ltc_key = { };\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_populate_ltc_public_key(&ltc_key, key, algo, &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* check keysize vs sig_len */\n\tif ((key_size_bytes * 2) != sig_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tltc_res = ecc_verify_hash_rfc7518(sig, sig_len, msg, msg_len, &ltc_stat,\n\t\t\t\t\t  &ltc_key);\n\tres = convert_ltc_verify_status(ltc_res, ltc_stat);\nout:\n\tecc_free(&ltc_key);\n\treturn res;\n}\n\nstatic TEE_Result _ltc_ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t\t struct ecc_public_key *public_key,\n\t\t\t\t\t void *secret,\n\t\t\t\t\t unsigned long *secret_len)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tint ltc_res = 0;\n\tecc_key ltc_private_key = { };\n\tecc_key ltc_public_key = { };\n\tsize_t key_size_bytes = 0;\n\n\t/* Check the curves are the same */\n\tif (private_key->curve != public_key->curve)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_populate_ltc_private_key(&ltc_private_key, private_key,\n\t\t\t\t\t   0, &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = ecc_populate_ltc_public_key(&ltc_public_key, public_key,\n\t\t\t\t\t  0, &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tltc_res = ecc_shared_secret(&ltc_private_key, &ltc_public_key,\n\t\t\t\t    secret, secret_len);\n\tif (ltc_res == CRYPT_OK)\n\t\tres = TEE_SUCCESS;\n\telse\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\nout:\n\tecc_free(&ltc_private_key);\n\tecc_free(&ltc_public_key);\n\treturn res;\n}\n\nstatic const struct crypto_ecc_keypair_ops ecc_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n\t.sign = _ltc_ecc_sign,\n\t.shared_secret = _ltc_ecc_shared_secret,\n};\n\nstatic const struct crypto_ecc_public_ops ecc_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n\t.verify = _ltc_ecc_verify,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_dsa_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n\t.sign = sm2_ltc_dsa_sign,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_dsa_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n\t.verify = sm2_ltc_dsa_verify,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_pke_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n\t.decrypt = sm2_ltc_pke_decrypt,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_pke_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n\t.encrypt = sm2_ltc_pke_encrypt,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_kep_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_kep_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n};\n\nconst struct crypto_ecc_keypair_ops *\ncrypto_asym_get_ecc_keypair_ops( uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\treturn &ecc_keypair_ops;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn NULL;\n\t\treturn &sm2_dsa_keypair_ops;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn NULL;\n\t\treturn &sm2_pke_keypair_ops;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_keypair_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t uint32_t key_type,\n\t\t\t\t\t size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\ts->ops = &ecc_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_keypair_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\ts->ops = NULL;\n\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nconst struct crypto_ecc_public_ops*\ncrypto_asym_get_ecc_public_ops(uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\treturn &ecc_public_key_ops;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn NULL;\n\t\treturn &sm2_dsa_public_key_ops;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn NULL;\n\t\treturn &sm2_pke_public_key_ops;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_public_key_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\ts->ops = &ecc_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_public_key_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\ts->ops = NULL;\n\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2018, Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <kernel/panic.h>\n#include <mbedtls/bignum.h>\n#include <mempool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tomcrypt_private.h>\n#include <tomcrypt_mp.h>\n#include <util.h>\n\n#if defined(_CFG_CORE_LTC_PAGER)\n#include <mm/core_mmu.h>\n#include <mm/tee_pager.h>\n#endif\n\n/* Size needed for xtest to pass reliably on both ARM32 and ARM64 */\n#define MPI_MEMPOOL_SIZE\t(46 * 1024)\n\n/* From mbedtls/library/bignum.c */\n#define ciL\t\t(sizeof(mbedtls_mpi_uint))\t/* chars in limb  */\n#define biL\t\t(ciL << 3)\t\t\t/* bits  in limb  */\n#define BITS_TO_LIMBS(i)\t((i) / biL + ((i) % biL != 0))\n\n#if defined(_CFG_CORE_LTC_PAGER)\n/* allocate pageable_zi vmem for mp scratch memory pool */\nstatic struct mempool *get_mp_scratch_memory_pool(void)\n{\n\tsize_t size;\n\tvoid *data;\n\n\tsize = ROUNDUP(MPI_MEMPOOL_SIZE, SMALL_PAGE_SIZE);\n\tdata = tee_pager_alloc(size);\n\tif (!data)\n\t\tpanic();\n\n\treturn mempool_alloc_pool(data, size, tee_pager_release_phys);\n}\n#else /* _CFG_CORE_LTC_PAGER */\nstatic struct mempool *get_mp_scratch_memory_pool(void)\n{\n\tstatic uint8_t data[MPI_MEMPOOL_SIZE] __aligned(MEMPOOL_ALIGN);\n\n\treturn mempool_alloc_pool(data, sizeof(data), NULL);\n}\n#endif\n\nvoid init_mp_tomcrypt(void)\n{\n\tstruct mempool *p = get_mp_scratch_memory_pool();\n\n\tif (!p)\n\t\tpanic();\n\tmbedtls_mpi_mempool = p;\n\tassert(!mempool_default);\n\tmempool_default = p;\n}\n\nstatic int init(void **a)\n{\n\tmbedtls_mpi *bn = mempool_alloc(mbedtls_mpi_mempool, sizeof(*bn));\n\n\tif (!bn)\n\t\treturn CRYPT_MEM;\n\n\tmbedtls_mpi_init_mempool(bn);\n\t*a = bn;\n\treturn CRYPT_OK;\n}\n\nstatic int init_size(int size_bits __unused, void **a)\n{\n\treturn init(a);\n}\n\nstatic void deinit(void *a)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)a);\n\tmempool_free(mbedtls_mpi_mempool, a);\n}\n\nstatic int neg(void *a, void *b)\n{\n\tif (mbedtls_mpi_copy(b, a))\n\t\treturn CRYPT_MEM;\n\t((mbedtls_mpi *)b)->s *= -1;\n\treturn CRYPT_OK;\n}\n\nstatic int copy(void *a, void *b)\n{\n\tif (mbedtls_mpi_copy(b, a))\n\t\treturn CRYPT_MEM;\n\treturn CRYPT_OK;\n}\n\nstatic int init_copy(void **a, void *b)\n{\n\tif (init(a) != CRYPT_OK) {\n\t\treturn CRYPT_MEM;\n\t}\n\treturn copy(b, *a);\n}\n\n/* ---- trivial ---- */\nstatic int set_int(void *a, ltc_mp_digit b)\n{\n\tuint32_t b32 = b;\n\n\tif (b32 != b)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tmbedtls_mpi_uint p = b32;\n\tmbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };\n\n\tif (mbedtls_mpi_copy(a, &bn))\n\t\treturn CRYPT_MEM;\n\treturn CRYPT_OK;\n}\n\nstatic unsigned long get_int(void *a)\n{\n\tmbedtls_mpi *bn = a;\n\n\tif (!bn->n)\n\t\treturn 0;\n\n\treturn bn->p[bn->n - 1];\n}\n\nstatic ltc_mp_digit get_digit(void *a, int n)\n{\n\tmbedtls_mpi *bn = a;\n\n\tCOMPILE_TIME_ASSERT(sizeof(ltc_mp_digit) >= sizeof(mbedtls_mpi_uint));\n\n\tif (n < 0 || (size_t)n >= bn->n)\n\t\treturn 0;\n\n\treturn bn->p[n];\n}\n\nstatic int get_digit_count(void *a)\n{\n\treturn ROUNDUP(mbedtls_mpi_size(a), sizeof(mbedtls_mpi_uint)) /\n\t       sizeof(mbedtls_mpi_uint);\n}\n\nstatic int compare(void *a, void *b)\n{\n\tint ret = mbedtls_mpi_cmp_mpi(a, b);\n\n\tif (ret < 0)\n\t\treturn LTC_MP_LT;\n\n\tif (ret > 0)\n\t\treturn LTC_MP_GT;\n\n\treturn LTC_MP_EQ;\n}\n\nstatic int compare_d(void *a, ltc_mp_digit b)\n{\n\tunsigned long v = b;\n\tunsigned int shift = 31;\n\tuint32_t mask = BIT(shift) - 1;\n\tmbedtls_mpi bn;\n\n\tmbedtls_mpi_init_mempool(&bn);\n\twhile (true) {\n\t\tmbedtls_mpi_add_int(&bn, &bn, v & mask);\n\t\tv >>= shift;\n\t\tif (!v)\n\t\t\tbreak;\n\t\tmbedtls_mpi_shift_l(&bn, shift);\n\t}\n\n\tint ret = compare(a, &bn);\n\n\tmbedtls_mpi_free(&bn);\n\n\treturn ret;\n}\n\nstatic int count_bits(void *a)\n{\n\treturn mbedtls_mpi_bitlen(a);\n}\n\nstatic int count_lsb_bits(void *a)\n{\n\treturn mbedtls_mpi_lsb(a);\n}\n\n\nstatic int twoexpt(void *a, int n)\n{\n\tif (mbedtls_mpi_set_bit(a, n, 1))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* ---- conversions ---- */\n\n/* read ascii string */\nstatic int read_radix(void *a, const char *b, int radix)\n{\n\tint res = mbedtls_mpi_read_string(a, radix, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* write one */\nstatic int write_radix(void *a, char *b, int radix)\n{\n\tsize_t ol = SIZE_MAX;\n\tint res = mbedtls_mpi_write_string(a, radix, b, ol, &ol);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* get size as unsigned char string */\nstatic unsigned long unsigned_size(void *a)\n{\n\treturn mbedtls_mpi_size(a);\n}\n\n/* store */\nstatic int unsigned_write(void *a, unsigned char *b)\n{\n\tint res = mbedtls_mpi_write_binary(a, b, unsigned_size(a));\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* read */\nstatic int unsigned_read(void *a, unsigned char *b, unsigned long len)\n{\n\tint res = mbedtls_mpi_read_binary(a, b, len);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* add */\nstatic int add(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_add_mpi(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nstatic int addi(void *a, ltc_mp_digit b, void *c)\n{\n\tuint32_t b32 = b;\n\n\tif (b32 != b)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tmbedtls_mpi_uint p = b32;\n\tmbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };\n\n\treturn add(a, &bn, c);\n}\n\n/* sub */\nstatic int sub(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_sub_mpi(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nstatic int subi(void *a, ltc_mp_digit b, void *c)\n{\n\tuint32_t b32 = b;\n\n\tif (b32 != b)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tmbedtls_mpi_uint p = b32;\n\tmbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };\n\n\treturn sub(a, &bn, c);\n}\n\n/* mul */\nstatic int mul(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_mul_mpi(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nstatic int muli(void *a, ltc_mp_digit b, void *c)\n{\n\tif (b > (unsigned long) UINT32_MAX)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tif (mbedtls_mpi_mul_int(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* sqr */\nstatic int sqr(void *a, void *b)\n{\n\treturn mul(a, a, b);\n}\n\n/* div */\nstatic int divide(void *a, void *b, void *c, void *d)\n{\n\tint res = mbedtls_mpi_div_mpi(c, d, a, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\nstatic int div_2(void *a, void *b)\n{\n\tif (mbedtls_mpi_copy(b, a))\n\t\treturn CRYPT_MEM;\n\n\tif (mbedtls_mpi_shift_r(b, 1))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* modi */\nstatic int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)\n{\n\tmbedtls_mpi bn_b;\n\tmbedtls_mpi bn_c;\n\tint res = 0;\n\n\tmbedtls_mpi_init_mempool(&bn_b);\n\tmbedtls_mpi_init_mempool(&bn_c);\n\n\tres = set_int(&bn_b, b);\n\tif (res)\n\t\treturn res;\n\n\tres = mbedtls_mpi_mod_mpi(&bn_c, &bn_b, a);\n\tif (!res)\n\t\t*c = get_int(&bn_c);\n\n\tmbedtls_mpi_free(&bn_b);\n\tmbedtls_mpi_free(&bn_c);\n\n\tif (res)\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* gcd */\nstatic int gcd(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_gcd(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* lcm */\nstatic int lcm(void *a, void *b, void *c)\n{\n\tint res = CRYPT_MEM;\n\tmbedtls_mpi tmp;\n\n\tmbedtls_mpi_init_mempool(&tmp);\n\tif (mbedtls_mpi_mul_mpi(&tmp, a, b))\n\t\tgoto out;\n\n\tif (mbedtls_mpi_gcd(c, a, b))\n\t\tgoto out;\n\n\t/* We use the following equality: gcd(a, b) * lcm(a, b) = a * b */\n\tres = divide(&tmp, c, c, NULL);\nout:\n\tmbedtls_mpi_free(&tmp);\n\treturn res;\n}\n\nstatic int mod(void *a, void *b, void *c)\n{\n\tint res = mbedtls_mpi_mod_mpi(c, a, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\nstatic int addmod(void *a, void *b, void *c, void *d)\n{\n\tint res = add(a, b, d);\n\n\tif (res)\n\t\treturn res;\n\n\treturn mod(d, c, d);\n}\n\nstatic int submod(void *a, void *b, void *c, void *d)\n{\n\tint res = sub(a, b, d);\n\n\tif (res)\n\t\treturn res;\n\n\treturn mod(d, c, d);\n}\n\nstatic int mulmod(void *a, void *b, void *c, void *d)\n{\n\tint res;\n\tmbedtls_mpi ta;\n\tmbedtls_mpi tb;\n\n\tmbedtls_mpi_init_mempool(&ta);\n\tmbedtls_mpi_init_mempool(&tb);\n\n\tres = mod(a, c, &ta);\n\tif (res)\n\t\tgoto out;\n\tres = mod(b, c, &tb);\n\tif (res)\n\t\tgoto out;\n\tres = mul(&ta, &tb, d);\n\tif (res)\n\t\tgoto out;\n\tres = mod(d, c, d);\nout:\n\tmbedtls_mpi_free(&ta);\n\tmbedtls_mpi_free(&tb);\n\treturn res;\n}\n\nstatic int sqrmod(void *a, void *b, void *c)\n{\n\treturn mulmod(a, a, b, c);\n}\n\n/* invmod */\nstatic int invmod(void *a, void *b, void *c)\n{\n\tint res = mbedtls_mpi_inv_mod(c, a, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n\n/* setup */\nstatic int montgomery_setup(void *a, void **b)\n{\n\t*b = mempool_alloc(mbedtls_mpi_mempool, sizeof(mbedtls_mpi_uint));\n\tif (!*b)\n\t\treturn CRYPT_MEM;\n\n\tmbedtls_mpi_montg_init(*b, a);\n\n\treturn CRYPT_OK;\n}\n\n/* get normalization value */\nstatic int montgomery_normalization(void *a, void *b)\n{\n\tsize_t c = ROUNDUP(mbedtls_mpi_size(b), sizeof(mbedtls_mpi_uint)) * 8;\n\n\tif (mbedtls_mpi_lset(a, 1))\n\t\treturn CRYPT_MEM;\n\tif (mbedtls_mpi_shift_l(a, c))\n\t\treturn CRYPT_MEM;\n\tif (mbedtls_mpi_mod_mpi(a, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* reduce */\nstatic int montgomery_reduce(void *a, void *b, void *c)\n{\n\tmbedtls_mpi A;\n\tmbedtls_mpi *N = b;\n\tmbedtls_mpi_uint *mm = c;\n\tmbedtls_mpi T;\n\tint ret = CRYPT_MEM;\n\n\tmbedtls_mpi_init_mempool(&T);\n\tmbedtls_mpi_init_mempool(&A);\n\n\tif (mbedtls_mpi_grow(&T, (N->n + 1) * 2))\n\t\tgoto out;\n\n\tif (mbedtls_mpi_cmp_mpi(a, N) > 0) {\n\t\tif (mbedtls_mpi_mod_mpi(&A, a, N))\n\t\t\tgoto out;\n\t} else {\n\t\tif (mbedtls_mpi_copy(&A, a))\n\t\t\tgoto out;\n\t}\n\n\tif (mbedtls_mpi_grow(&A, N->n + 1))\n\t\tgoto out;\n\n\tmbedtls_mpi_montred(&A, N, *mm, &T);\n\n\tif (mbedtls_mpi_copy(a, &A))\n\t\tgoto out;\n\n\tret = CRYPT_OK;\nout:\n\tmbedtls_mpi_free(&A);\n\tmbedtls_mpi_free(&T);\n\n\treturn ret;\n}\n\n/* clean up */\nstatic void montgomery_deinit(void *a)\n{\n\tmempool_free(mbedtls_mpi_mempool, a);\n}\n\n/*\n * This function calculates:\n *  d = a^b mod c\n *\n * @a: base\n * @b: exponent\n * @c: modulus\n * @d: destination\n */\nstatic int exptmod(void *a, void *b, void *c, void *d)\n{\n\tint res;\n\n\tif (d == a || d == b || d == c) {\n\t\tmbedtls_mpi dest;\n\n\t\tmbedtls_mpi_init_mempool(&dest);\n\t\tres = mbedtls_mpi_exp_mod(&dest, a, b, c, NULL);\n\t\tif (!res)\n\t\t\tres = mbedtls_mpi_copy(d, &dest);\n\t\tmbedtls_mpi_free(&dest);\n\t} else {\n\t\tres = mbedtls_mpi_exp_mod(d, a, b, c, NULL);\n\t}\n\n\tif (res)\n\t\treturn CRYPT_MEM;\n\telse\n\t\treturn CRYPT_OK;\n}\n\nstatic int rng_read(void *ignored __unused, unsigned char *buf, size_t blen)\n{\n\tif (crypto_rng_read(buf, blen))\n\t\treturn MBEDTLS_ERR_MPI_FILE_IO_ERROR;\n\treturn 0;\n}\n\nstatic int isprime(void *a, int b __unused, int *c)\n{\n\tint res = mbedtls_mpi_is_prime(a, rng_read, NULL);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\n\tif (res)\n\t\t*c = LTC_MP_NO;\n\telse\n\t\t*c = LTC_MP_YES;\n\n\treturn CRYPT_OK;\n}\n\nstatic int mpi_rand(void *a, int size)\n{\n\tif (mbedtls_mpi_fill_random(a, size, rng_read, NULL))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nltc_math_descriptor ltc_mp = {\n\t.name = \"MPI\",\n\t.bits_per_digit = sizeof(mbedtls_mpi_uint) * 8,\n\n\t.init = init,\n\t.init_size = init_size,\n\t.init_copy = init_copy,\n\t.deinit = deinit,\n\n\t.neg = neg,\n\t.copy = copy,\n\n\t.set_int = set_int,\n\t.get_int = get_int,\n\t.get_digit = get_digit,\n\t.get_digit_count = get_digit_count,\n\t.compare = compare,\n\t.compare_d = compare_d,\n\t.count_bits = count_bits,\n\t.count_lsb_bits = count_lsb_bits,\n\t.twoexpt = twoexpt,\n\n\t.read_radix = read_radix,\n\t.write_radix = write_radix,\n\t.unsigned_size = unsigned_size,\n\t.unsigned_write = unsigned_write,\n\t.unsigned_read = unsigned_read,\n\n\t.add = add,\n\t.addi = addi,\n\t.sub = sub,\n\t.subi = subi,\n\t.mul = mul,\n\t.muli = muli,\n\t.sqr = sqr,\n\t.mpdiv = divide,\n\t.div_2 = div_2,\n\t.modi = modi,\n\t.gcd = gcd,\n\t.lcm = lcm,\n\n\t.mulmod = mulmod,\n\t.sqrmod = sqrmod,\n\t.invmod = invmod,\n\n\t.montgomery_setup = montgomery_setup,\n\t.montgomery_normalization = montgomery_normalization,\n\t.montgomery_reduce = montgomery_reduce,\n\t.montgomery_deinit = montgomery_deinit,\n\n\t.exptmod = exptmod,\n\t.isprime = isprime,\n\n#ifdef LTC_MECC\n#ifdef LTC_MECC_FP\n\t.ecc_ptmul = ltc_ecc_fp_mulmod,\n#else\n\t.ecc_ptmul = ltc_ecc_mulmod,\n#endif /* LTC_MECC_FP */\n\t.ecc_ptadd = ltc_ecc_projective_add_point,\n\t.ecc_ptdbl = ltc_ecc_projective_dbl_point,\n\t.ecc_map = ltc_ecc_map,\n#ifdef LTC_ECC_SHAMIR\n#ifdef LTC_MECC_FP\n\t.ecc_mul2add = ltc_ecc_fp_mul2add,\n#else\n\t.ecc_mul2add = ltc_ecc_mul2add,\n#endif /* LTC_MECC_FP */\n#endif /* LTC_ECC_SHAMIR */\n#endif /* LTC_MECC */\n\n#ifdef LTC_MRSA\n\t.rsa_keygen = rsa_make_key,\n\t.rsa_me = rsa_exptmod,\n#endif\n\t.addmod = addmod,\n\t.submod = submod,\n\t.rand = mpi_rand,\n\n};\n\nsize_t crypto_bignum_num_bytes(struct bignum *a)\n{\n\treturn mbedtls_mpi_size((mbedtls_mpi *)a);\n}\n\nsize_t crypto_bignum_num_bits(struct bignum *a)\n{\n\treturn mbedtls_mpi_bitlen((mbedtls_mpi *)a);\n}\n\nint32_t crypto_bignum_compare(struct bignum *a, struct bignum *b)\n{\n\treturn mbedtls_mpi_cmp_mpi((mbedtls_mpi *)a, (mbedtls_mpi *)b);\n}\n\nvoid crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to)\n{\n\tconst mbedtls_mpi *f = (const mbedtls_mpi *)from;\n\tint rc __maybe_unused = 0;\n\n\trc = mbedtls_mpi_write_binary(f, (void *)to, mbedtls_mpi_size(f));\n\tassert(!rc);\n}\n\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,\n\t\t\t struct bignum *to)\n{\n\tif (mbedtls_mpi_read_binary((mbedtls_mpi *)to, (const void *)from,\n\t\t\t\t    fromsize))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nvoid crypto_bignum_copy(struct bignum *to, const struct bignum *from)\n{\n\tint rc __maybe_unused = 0;\n\n\trc = mbedtls_mpi_copy((mbedtls_mpi *)to, (const mbedtls_mpi *)from);\n\tassert(!rc);\n}\n\nstruct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tmbedtls_mpi *bn = malloc(sizeof(*bn));\n\n\tif (!bn)\n\t\treturn NULL;\n\n\tmbedtls_mpi_init(bn);\n\tif (mbedtls_mpi_grow(bn, BITS_TO_LIMBS(size_bits))) {\n\t\tfree(bn);\n\t\treturn NULL;\n\t}\n\n\treturn (struct bignum *)bn;\n}\n\nvoid crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}\n\nvoid crypto_bignum_clear(struct bignum *s)\n{\n\tmbedtls_mpi *bn = (mbedtls_mpi *)s;\n\n\tbn->s = 1;\n\tif (bn->p)\n\t\tmemset(bn->p, 0, sizeof(*bn->p) * bn->n);\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, 2022 Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <crypto/crypto_impl.h>\n#include <fault_mitigation.h>\n#include <mempool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_defines_extensions.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\n\n/*\n * Compute the LibTomCrypt \"hashindex\" given a TEE Algorithm \"algo\"\n * Return\n * - TEE_SUCCESS in case of success,\n * - TEE_ERROR_BAD_PARAMETERS in case algo is not a valid algo\n * - TEE_ERROR_NOT_SUPPORTED in case algo is not supported by LTC\n * Return -1 in case of error\n */\nstatic TEE_Result tee_algo_to_ltc_hashindex(uint32_t algo, int *ltc_hashindex)\n{\n\tswitch (algo) {\n#if defined(_CFG_CORE_LTC_SHA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\t\t*ltc_hashindex = find_hash(\"sha1\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_MD5)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_MD5:\n\t\t*ltc_hashindex = find_hash(\"md5\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA224)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\t\t*ltc_hashindex = find_hash(\"sha224\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA256)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\t\t*ltc_hashindex = find_hash(\"sha256\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA384)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\t\t*ltc_hashindex = find_hash(\"sha384\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA512)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\t*ltc_hashindex = find_hash(\"sha512\");\n\t\tbreak;\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\t\t/* invalid one. but it should not be used anyway */\n\t\t*ltc_hashindex = -1;\n\t\treturn TEE_SUCCESS;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tif (*ltc_hashindex < 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\telse\n\t\treturn TEE_SUCCESS;\n}\n\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_keypair\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_acipher_free_rsa_keypair(s);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n\nTEE_Result crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_public_key\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t\t  size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_public_key\");\n\nvoid sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}\n\n\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_keypair\");\n\nvoid sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}\n\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t      size_t key_size)\n__weak __alias(\"sw_crypto_acipher_gen_rsa_key\");\n\nTEE_Result sw_crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t\t size_t key_size)\n{\n\tTEE_Result res;\n\trsa_key ltc_tmp_key;\n\tint ltc_res;\n\n\t/* Generate a temporary RSA key */\n\tltc_res = rsa_make_key_bn_e(NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t    key_size / 8, key->e, &ltc_tmp_key);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else if ((size_t)mp_count_bits(ltc_tmp_key.N) != key_size) {\n\t\trsa_free(&ltc_tmp_key);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\t/* Copy the key */\n\t\tltc_mp.copy(ltc_tmp_key.d,  key->d);\n\t\tltc_mp.copy(ltc_tmp_key.N,  key->n);\n\t\tltc_mp.copy(ltc_tmp_key.p,  key->p);\n\t\tltc_mp.copy(ltc_tmp_key.q,  key->q);\n\t\tltc_mp.copy(ltc_tmp_key.qP, key->qp);\n\t\tltc_mp.copy(ltc_tmp_key.dP, key->dp);\n\t\tltc_mp.copy(ltc_tmp_key.dQ, key->dq);\n\n\t\t/* Free the temporary key */\n\t\trsa_free(&ltc_tmp_key);\n\t\tres = TEE_SUCCESS;\n\t}\n\n\treturn res;\n}\n\nstatic TEE_Result rsadorep(rsa_key *ltc_key, const uint8_t *src,\n\t\t\t   size_t src_len, uint8_t *dst, size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tunsigned long blen, offset;\n\tint ltc_res;\n\n\t/*\n\t * Use a temporary buffer since we don't know exactly how large the\n\t * required size of the out buffer without doing a partial decrypt.\n\t * We know the upper bound though.\n\t */\n\tblen = _CFG_CORE_LTC_BIGNUM_MAX_BITS / sizeof(uint8_t);\n\tbuf = mempool_alloc(mempool_default, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tltc_res = rsa_exptmod(src, src_len, buf, &blen, ltc_key->type,\n\t\t\t      ltc_key);\n\tswitch (ltc_res) {\n\tcase CRYPT_PK_NOT_PRIVATE:\n\tcase CRYPT_PK_INVALID_TYPE:\n\tcase CRYPT_PK_INVALID_SIZE:\n\tcase CRYPT_INVALID_PACKET:\n\t\tEMSG(\"rsa_exptmod() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\tcase CRYPT_OK:\n\t\tbreak;\n\tdefault:\n\t\t/* This will result in a panic */\n\t\tEMSG(\"rsa_exptmod() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < blen - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < blen - offset) {\n\t\t*dst_len = blen - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = TEE_SUCCESS;\n\t*dst_len = blen - offset;\n\tmemcpy(dst, (char *)buf + offset, *dst_len);\n\nout:\n\tmempool_free(mempool_default, buf);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PUBLIC;\n\tltc_key.e = key->e;\n\tltc_key.N = key->n;\n\n\tres = rsadorep(&ltc_key, src, src_len, dst, dst_len);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PRIVATE;\n\tltc_key.e = key->e;\n\tltc_key.N = key->n;\n\tltc_key.d = key->d;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\tltc_key.p = key->p;\n\t\tltc_key.q = key->q;\n\t\tltc_key.qP = key->qp;\n\t\tltc_key.dP = key->dp;\n\t\tltc_key.dQ = key->dq;\n\t}\n\n\tres = rsadorep(&ltc_key, src, src_len, dst, dst_len);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_keypair *key,\n\t\t\t\t\tconst uint8_t *label,\n\t\t\t\t\tsize_t label_len, const uint8_t *src,\n\t\t\t\t\tsize_t src_len, uint8_t *dst,\n\t\t\t\t\tsize_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *label,\n\t\t\t\t\t   size_t label_len, const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tvoid *buf = NULL;\n\tunsigned long blen;\n\tint ltc_hashindex, ltc_res, ltc_stat, ltc_rsa_algo;\n\tsize_t mod_size;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PRIVATE;\n\tltc_key.e = key->e;\n\tltc_key.d = key->d;\n\tltc_key.N = key->n;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\tltc_key.p = key->p;\n\t\tltc_key.q = key->q;\n\t\tltc_key.qP = key->qp;\n\t\tltc_key.dP = key->dp;\n\t\tltc_key.dQ = key->dq;\n\t}\n\n\t/* Get the algorithm */\n\tres = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\tif (res != TEE_SUCCESS) {\n\t\tEMSG(\"tee_algo_to_ltc_hashindex() returned %d\", (int)res);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Use a temporary buffer since we don't know exactly how large\n\t * the required size of the out buffer without doing a partial\n\t * decrypt. We know the upper bound though.\n\t */\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));\n\t\tblen = mod_size - 11;\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\t} else {\n\t\t/* Decoded message is always shorter than encrypted message */\n\t\tblen = src_len;\n\t\tltc_rsa_algo = LTC_PKCS_1_OAEP;\n\t}\n\n\tbuf = mempool_alloc(mempool_default, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tltc_res = rsa_decrypt_key_ex(src, src_len, buf, &blen,\n\t\t\t\t     ((label_len == 0) ? 0 : label), label_len,\n\t\t\t\t     ltc_hashindex, ltc_rsa_algo, &ltc_stat,\n\t\t\t\t     &ltc_key);\n\tswitch (ltc_res) {\n\tcase CRYPT_PK_INVALID_PADDING:\n\tcase CRYPT_INVALID_PACKET:\n\tcase CRYPT_PK_INVALID_SIZE:\n\t\tEMSG(\"rsa_decrypt_key_ex() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\tcase CRYPT_OK:\n\t\tbreak;\n\tdefault:\n\t\t/* This will result in a panic */\n\t\tEMSG(\"rsa_decrypt_key_ex() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\tif (ltc_stat != 1) {\n\t\t/* This will result in a panic */\n\t\tEMSG(\"rsa_decrypt_key_ex() returned %d and %d\",\n\t\t     ltc_res, ltc_stat);\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tif (*dst_len < blen) {\n\t\t*dst_len = blen;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = TEE_SUCCESS;\n\t*dst_len = blen;\n\tmemcpy(dst, buf, blen);\n\nout:\n\tmempool_free(mempool_default, buf);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tconst uint8_t *label,\n\t\t\t\t\tsize_t label_len, const uint8_t *src,\n\t\t\t\t\tsize_t src_len, uint8_t *dst,\n\t\t\t\t\tsize_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *label,\n\t\t\t\t\t   size_t label_len, const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n{\n\tTEE_Result res;\n\tuint32_t mod_size;\n\tint ltc_hashindex, ltc_res, ltc_rsa_algo;\n\trsa_key ltc_key = {\n\t\t.type = PK_PUBLIC,\n\t\t.e = key->e,\n\t\t.N = key->n\n\t};\n\n\tmod_size =  ltc_mp.unsigned_size((void *)(ltc_key.N));\n\tif (*dst_len < mod_size) {\n\t\t*dst_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = mod_size;\n\n\t/* Get the algorithm */\n\tres = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5)\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\telse\n\t\tltc_rsa_algo = LTC_PKCS_1_OAEP;\n\n\tltc_res = rsa_encrypt_key_ex(src, src_len, dst,\n\t\t\t\t     (unsigned long *)(dst_len), label,\n\t\t\t\t     label_len, NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t     ltc_hashindex, ltc_rsa_algo, &ltc_key);\n\tswitch (ltc_res) {\n\tcase CRYPT_PK_INVALID_PADDING:\n\tcase CRYPT_INVALID_PACKET:\n\tcase CRYPT_PK_INVALID_SIZE:\n\t\tEMSG(\"rsa_encrypt_key_ex() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\tcase CRYPT_OK:\n\t\tbreak;\n\tdefault:\n\t\t/* This will result in a panic */\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\tres = TEE_SUCCESS;\n\nout:\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t      int salt_len, const uint8_t *msg,\n\t\t\t\t      size_t msg_len, uint8_t *sig,\n\t\t\t\t      size_t *sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_sign\");\n\nTEE_Result sw_crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t\t int salt_len, const uint8_t *msg,\n\t\t\t\t\t size_t msg_len, uint8_t *sig,\n\t\t\t\t\t size_t *sig_len)\n{\n\tTEE_Result res;\n\tsize_t hash_size, mod_size;\n\tint ltc_res, ltc_rsa_algo, ltc_hashindex;\n\tunsigned long ltc_sig_len;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PRIVATE;\n\tltc_key.e = key->e;\n\tltc_key.N = key->n;\n\tltc_key.d = key->d;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\tltc_key.p = key->p;\n\t\tltc_key.q = key->q;\n\t\tltc_key.qP = key->qp;\n\t\tltc_key.dP = key->dp;\n\t\tltc_key.dQ = key->dq;\n\t}\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5_NA1;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_PSS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tif (ltc_rsa_algo != LTC_PKCS_1_V1_5_NA1) {\n\t\tltc_res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\t\tif (ltc_res != CRYPT_OK) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t\t      &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto err;\n\n\t\tif (msg_len != hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));\n\n\tif (*sig_len < mod_size) {\n\t\t*sig_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto err;\n\t}\n\n\tltc_sig_len = mod_size;\n\n\tltc_res = rsa_sign_hash_ex(msg, msg_len, sig, &ltc_sig_len,\n\t\t\t\t   ltc_rsa_algo, NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t   ltc_hashindex, salt_len, &ltc_key);\n\n\t*sig_len = ltc_sig_len;\n\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\tres = TEE_SUCCESS;\n\nerr:\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tint salt_len, const uint8_t *msg,\n\t\t\t\t\tsize_t msg_len, const uint8_t *sig,\n\t\t\t\t\tsize_t sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_verify\");\n\nTEE_Result sw_crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   int salt_len, const uint8_t *msg,\n\t\t\t\t\t   size_t msg_len, const uint8_t *sig,\n\t\t\t\t\t   size_t sig_len)\n{\n\tTEE_Result res;\n\tuint32_t bigint_size;\n\tsize_t hash_size;\n\tint stat, ltc_hashindex, ltc_res, ltc_rsa_algo;\n\trsa_key ltc_key = {\n\t\t.type = PK_PUBLIC,\n\t\t.e = key->e,\n\t\t.N = key->n\n\t};\n\tstruct ftmn   ftmn = { };\n\n\t/*\n\t * The caller expects to call crypto_acipher_rsassa_verify(),\n\t * update the hash as needed.\n\t */\n\tFTMN_CALLEE_SWAP_HASH(FTMN_FUNC_HASH(\"crypto_acipher_rsassa_verify\"));\n\n\tif (algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t\t      &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto err;\n\n\t\tif (msg_len != hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tbigint_size = ltc_mp.unsigned_size(ltc_key.N);\n\tif (sig_len < bigint_size) {\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\t\tgoto err;\n\t}\n\n\t/* Get the algorithm */\n\tif (algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\tres = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto err;\n\t}\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5_NA1;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_PSS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tFTMN_PUSH_LINKED_CALL(&ftmn, FTMN_FUNC_HASH(\"rsa_verify_hash_ex\"));\n\tltc_res = rsa_verify_hash_ex(sig, sig_len, msg, msg_len, ltc_rsa_algo,\n\t\t\t\t     ltc_hashindex, salt_len, &stat, &ltc_key);\n\tres = convert_ltc_verify_status(ltc_res, stat);\n\tif (res)\n\t\tFTMN_SET_CHECK_RES_NOT_ZERO(&ftmn, FTMN_INCR0, res);\n\telse\n\t\tFTMN_SET_CHECK_RES_FROM_CALL(&ftmn, FTMN_INCR0, 0);\n\tFTMN_POP_LINKED_CALL(&ftmn);\n\tFTMN_CALLEE_DONE_CHECK(&ftmn, FTMN_INCR0, FTMN_STEP_COUNT(1), res);\n\treturn res;\nerr:\n\tFTMN_CALLEE_DONE_NOT_ZERO(res);\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n * Copyright (c) 2020, 2022 Linaro Limited\n * Copyright (c) 2022, Technology Innovation Institute (TII)\n */\n\n#include <assert.h>\n#include <bitstring.h>\n#include <compiler.h>\n#include <config.h>\n#include <crypto/crypto.h>\n#include <kernel/tee_ta_manager.h>\n#include <kernel/user_access.h>\n#include <memtag.h>\n#include <mm/vm.h>\n#include <stdlib_ext.h>\n#include <string_ext.h>\n#include <string.h>\n#include <sys/queue.h>\n#include <tee_api_defines_extensions.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/tee_obj.h>\n#include <tee/tee_svc_cryp.h>\n#include <tee/tee_svc.h>\n#include <trace.h>\n#include <utee_defines.h>\n#include <util.h>\n#if defined(CFG_CRYPTO_HKDF)\n#include <tee/tee_cryp_hkdf.h>\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n#include <tee/tee_cryp_concat_kdf.h>\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n#include <tee/tee_cryp_pbkdf2.h>\n#endif\n\nenum cryp_state {\n\tCRYP_STATE_INITIALIZED = 0,\n\tCRYP_STATE_UNINITIALIZED\n};\n\ntypedef void (*tee_cryp_ctx_finalize_func_t) (void *ctx);\nstruct tee_cryp_state {\n\tTAILQ_ENTRY(tee_cryp_state) link;\n\tuint32_t algo;\n\tuint32_t mode;\n\tvaddr_t key1;\n\tvaddr_t key2;\n\tvoid *ctx;\n\ttee_cryp_ctx_finalize_func_t ctx_finalize;\n\tenum cryp_state state;\n};\n\nstruct tee_cryp_obj_secret {\n\tuint32_t key_size;\n\tuint32_t alloc_size;\n\n\t/*\n\t * Pseudo code visualize layout of structure\n\t * Next follows data, such as:\n\t *\tuint8_t data[alloc_size]\n\t * key_size must never exceed alloc_size\n\t */\n};\n\n#define TEE_TYPE_ATTR_OPTIONAL\t\tBIT(0)\n#define TEE_TYPE_ATTR_REQUIRED\t\tBIT(1)\n#define TEE_TYPE_ATTR_OPTIONAL_GROUP\tBIT(2)\n#define TEE_TYPE_ATTR_SIZE_INDICATOR\tBIT(3)\n#define TEE_TYPE_ATTR_GEN_KEY_OPT\tBIT(4)\n#define TEE_TYPE_ATTR_GEN_KEY_REQ\tBIT(5)\n#define TEE_TYPE_ATTR_BIGNUM_MAXBITS\tBIT(6)\n\n    /* Handle storing of generic secret keys of varying lengths */\n#define ATTR_OPS_INDEX_SECRET     0\n    /* Convert to/from big-endian byte array and provider-specific bignum */\n#define ATTR_OPS_INDEX_BIGNUM     1\n    /* Convert to/from value attribute depending on direction */\n#define ATTR_OPS_INDEX_VALUE      2\n    /* Convert to/from curve25519 attribute depending on direction */\n#define ATTR_OPS_INDEX_25519      3\n\n    /* Curve25519 key bytes size is always 32 bytes*/\n#define KEY_SIZE_BYTES_25519 UL(32)\n    /* TEE Internal Core API v1.3.1, Table 6-8 */\n#define TEE_ED25519_CTX_MAX_LENGTH 255\n\nstruct tee_cryp_obj_type_attrs {\n\tuint32_t attr_id;\n\tuint16_t flags;\n\tuint16_t ops_index;\n\tuint16_t raw_offs;\n\tuint16_t raw_size;\n};\n\n#define RAW_DATA(_x, _y)\t\\\n\t.raw_offs = offsetof(_x, _y), .raw_size = MEMBER_SIZE(_x, _y)\n\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_secret_value_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_SECRET_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, e)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, e)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIVATE_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dp)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dq)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_COEFFICIENT,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, qp)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS |\n\t\t TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ |\n\t\t TEE_TYPE_ATTR_BIGNUM_MAXBITS | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ |\n\t\t TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dh_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP |\t TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_X_BITS,\n\t.flags = TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct dh_keypair, xbits)\n\t},\n};\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_hkdf_ikm_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_HKDF_IKM,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_concat_kdf_z_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_CONCAT_KDF_Z,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_pbkdf2_passwd_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_PBKDF2_PASSWORD,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_public_key, curve)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_keypair, curve)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_sm2_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_sm2_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, y)\n\t},\n};\n\nstatic\nconst struct tee_cryp_obj_type_attrs tee_cryp_obj_x25519_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_X25519_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct x25519_keypair, priv)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_X25519_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct x25519_keypair, pub)\n\t},\n};\n\nstatic\nconst struct tee_cryp_obj_type_attrs tee_cryp_obj_ed25519_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ED25519_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct ed25519_public_key, pub)\n\t},\n};\n\nstatic\nconst struct tee_cryp_obj_type_attrs tee_cryp_obj_ed25519_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ED25519_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct ed25519_keypair, priv)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ED25519_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct ed25519_keypair, pub)\n\t},\n};\n\nstruct tee_cryp_obj_type_props {\n\tTEE_ObjectType obj_type;\n\tuint16_t min_size;\t/* may not be smaller than this */\n\tuint16_t max_size;\t/* may not be larger than this */\n\tuint16_t alloc_size;\t/* this many bytes are allocated to hold data */\n\tuint8_t quanta;\t\t/* may only be an multiple of this */\n\n\tuint8_t num_type_attrs;\n\tconst struct tee_cryp_obj_type_attrs *type_attrs;\n};\n\n#define PROP(obj_type, quanta, min_size, max_size, alloc_size, type_attrs) \\\n\t\t{ (obj_type), (min_size), (max_size), (alloc_size), (quanta), \\\n\t\t  ARRAY_SIZE(type_attrs), (type_attrs) }\n\nstatic const struct tee_cryp_obj_type_props tee_cryp_obj_props[] = {\n\tPROP(TEE_TYPE_AES, 64, 128, 256,\t/* valid sizes 128, 192, 256 */\n\t\t256 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES, 64, 64, 64,\n\t     /* Valid size 64 with parity */\n\t     64 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES3, 64, 128, 192,\n\t     /* Valid sizes 128, 192 with parity */\n\t     192 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_SM4, 128, 128, 128,\n\t\t128 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_MD5, 8, 64, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#if defined(CFG_HMAC_64_1024_RANGE)\n\tPROP(TEE_TYPE_HMAC_SHA1, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA224, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA256, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA384, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA512, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n#else\n\tPROP(TEE_TYPE_HMAC_SHA1, 8, 80, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA224, 8, 112, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA256, 8, 192, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA384, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA512, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#endif\n\tPROP(TEE_TYPE_HMAC_SHA3_224, 8, 192, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA3_256, 8, 256, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA3_384, 8, 256, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA3_512, 8, 256, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SM3, 8, 80, 1024,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_GENERIC_SECRET, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#if defined(CFG_CRYPTO_HKDF)\n\tPROP(TEE_TYPE_HKDF_IKM, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_hkdf_ikm_attrs),\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tPROP(TEE_TYPE_CONCAT_KDF_Z, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_concat_kdf_z_attrs),\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tPROP(TEE_TYPE_PBKDF2_PASSWORD, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_pbkdf2_passwd_attrs),\n#endif\n\tPROP(TEE_TYPE_RSA_PUBLIC_KEY, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_public_key),\n\t\ttee_cryp_obj_rsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_RSA_KEYPAIR, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_keypair),\n\t\ttee_cryp_obj_rsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DSA_PUBLIC_KEY, 64, 512, 3072,\n\t\tsizeof(struct dsa_public_key),\n\t\ttee_cryp_obj_dsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_DSA_KEYPAIR, 64, 512, 3072,\n\t\tsizeof(struct dsa_keypair),\n\t\ttee_cryp_obj_dsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DH_KEYPAIR, 1, 256, 2048,\n\t\tsizeof(struct dh_keypair),\n\t\ttee_cryp_obj_dh_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDH_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDH_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n\n\tPROP(TEE_TYPE_SM2_DSA_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ecc_public_key),\n\t     tee_cryp_obj_sm2_pub_key_attrs),\n\n\tPROP(TEE_TYPE_SM2_DSA_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ecc_keypair),\n\t     tee_cryp_obj_sm2_keypair_attrs),\n\n\tPROP(TEE_TYPE_SM2_PKE_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ecc_public_key),\n\t     tee_cryp_obj_sm2_pub_key_attrs),\n\n\tPROP(TEE_TYPE_SM2_PKE_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ecc_keypair),\n\t     tee_cryp_obj_sm2_keypair_attrs),\n\n\tPROP(TEE_TYPE_SM2_KEP_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ecc_public_key),\n\t     tee_cryp_obj_sm2_pub_key_attrs),\n\n\tPROP(TEE_TYPE_SM2_KEP_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ecc_keypair),\n\t     tee_cryp_obj_sm2_keypair_attrs),\n\n\tPROP(TEE_TYPE_X25519_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct x25519_keypair),\n\t     tee_cryp_obj_x25519_keypair_attrs),\n\n\tPROP(TEE_TYPE_ED25519_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ed25519_public_key),\n\t     tee_cryp_obj_ed25519_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ED25519_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ed25519_keypair),\n\t     tee_cryp_obj_ed25519_keypair_attrs),\n};\n\nstruct attr_ops {\n\tTEE_Result (*from_user)(void *attr, const void *buffer, size_t size);\n\tTEE_Result (*to_user)(void *attr, struct ts_session *sess,\n\t\t\t      void *buffer, uint64_t *size);\n\tTEE_Result (*to_binary)(void *attr, void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tbool (*from_binary)(void *attr, const void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tTEE_Result (*from_obj)(void *attr, void *src_attr);\n\tvoid (*free)(void *attr);\n\tvoid (*clear)(void *attr);\n};\n\nstatic TEE_Result op_u32_to_binary_helper(uint32_t v, uint8_t *data,\n\t\t\t\t    size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\tsize_t next_offs;\n\n\tif (ADD_OVERFLOW(*offs, sizeof(field), &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len) {\n\t\tfield = TEE_U32_TO_BIG_ENDIAN(v);\n\t\tmemcpy(data + *offs, &field, sizeof(field));\n\t}\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_u32_from_binary_helper(uint32_t *v, const uint8_t *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\n\tif (!data || (*offs + sizeof(field)) > data_len)\n\t\treturn false;\n\n\tmemcpy(&field, data + *offs, sizeof(field));\n\t*v = TEE_U32_FROM_BIG_ENDIAN(field);\n\t(*offs) += sizeof(field);\n\treturn true;\n}\n\nstatic TEE_Result op_attr_secret_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t\t size_t size)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (size > key->alloc_size)\n\t\treturn TEE_ERROR_SECURITY;\n\tmemcpy(key + 1, buffer, size);\n\tkey->key_size = size;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_secret_value_to_user(void *attr,\n\t\t\t\t\t       struct ts_session *sess __unused,\n\t\t\t\t\t       void *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint64_t s;\n\tuint64_t key_size;\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tkey_size = key->key_size;\n\tres = copy_to_user(size, &key_size, sizeof(key_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < key->key_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn copy_to_user(buffer, key + 1, key->key_size);\n}\n\nstatic TEE_Result op_attr_secret_value_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(key->key_size, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, key->key_size, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tmemcpy((uint8_t *)data + *offs, key + 1, key->key_size);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_secret_value_from_binary(void *attr, const void *data,\n\t\t\t\t\t     size_t data_len, size_t *offs)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint32_t s;\n\n\tif (!op_u32_from_binary_helper(&s, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + s) > data_len)\n\t\treturn false;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (s > key->alloc_size)\n\t\treturn false;\n\tkey->key_size = s;\n\tmemcpy(key + 1, (const uint8_t *)data + *offs, s);\n\t(*offs) += s;\n\treturn true;\n}\n\n\nstatic TEE_Result op_attr_secret_value_from_obj(void *attr, void *src_attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tstruct tee_cryp_obj_secret *src_key = src_attr;\n\n\tif (src_key->key_size > key->alloc_size)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tmemcpy(key + 1, src_key + 1, src_key->key_size);\n\tkey->key_size = src_key->key_size;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_secret_value_clear(void *attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\tkey->key_size = 0;\n\tmemzero_explicit(key + 1, key->alloc_size);\n}\n\nstatic TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,\n\t\t\t\t\t   size_t size)\n{\n\tstruct bignum **bn = attr;\n\n\treturn crypto_bignum_bin2bn(buffer, size, *bn);\n}\n\nstatic TEE_Result op_attr_bignum_to_user(void *attr,\n\t\t\t\t\t struct ts_session *sess,\n\t\t\t\t\t void *buffer, uint64_t *size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct bignum **bn = attr;\n\tuint64_t req_size = 0;\n\tuint64_t s = 0;\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treq_size = crypto_bignum_num_bytes(*bn);\n\tres = copy_to_user(size, &req_size, sizeof(req_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (!req_size)\n\t\treturn TEE_SUCCESS;\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\tbuffer = memtag_strip_tag(buffer);\n\n\t/* Check we can access data using supplied user mode pointer */\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)buffer, req_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\t/*\n\t* Write the bignum (wich raw data points to) into an array of\n\t* bytes (stored in buffer)\n\t*/\n\tcrypto_bignum_bn2bin(*bn, buffer);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_bignum_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct bignum **bn = attr;\n\tuint32_t n = crypto_bignum_num_bytes(*bn);\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(n, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, n, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tcrypto_bignum_bn2bin(*bn, (uint8_t *)data + *offs);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_bignum_from_binary(void *attr, const void *data,\n\t\t\t\t       size_t data_len, size_t *offs)\n{\n\tstruct bignum **bn = attr;\n\tuint32_t n;\n\n\tif (!op_u32_from_binary_helper(&n, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + n) > data_len)\n\t\treturn false;\n\tif (crypto_bignum_bin2bn((const uint8_t *)data + *offs, n, *bn))\n\t\treturn false;\n\t(*offs) += n;\n\treturn true;\n}\n\nstatic TEE_Result op_attr_bignum_from_obj(void *attr, void *src_attr)\n{\n\tstruct bignum **bn = attr;\n\tstruct bignum **src_bn = src_attr;\n\n\tcrypto_bignum_copy(*bn, *src_bn);\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_bignum_clear(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_clear(*bn);\n}\n\nstatic void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}\n\nstatic TEE_Result op_attr_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t  size_t size)\n{\n\tuint32_t *v = attr;\n\n\tif (size != sizeof(uint32_t) * 2)\n\t\treturn TEE_ERROR_GENERIC; /* \"can't happen */\n\n\t/* Note that only the first value is copied */\n\tmemcpy(v, buffer, sizeof(uint32_t));\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_value_to_user(void *attr,\n\t\t\t\t\tstruct ts_session *sess __unused,\n\t\t\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tuint32_t *v = attr;\n\tuint64_t s;\n\tuint32_t value[2] = { *v };\n\tuint64_t req_size = sizeof(value);\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn copy_to_user(buffer, value, req_size);\n}\n\nstatic TEE_Result op_attr_value_to_binary(void *attr, void *data,\n\t\t\t\t\t  size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_to_binary_helper(*v, data, data_len, offs);\n}\n\nstatic bool op_attr_value_from_binary(void *attr, const void *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_from_binary_helper(v, data, data_len, offs);\n}\n\nstatic TEE_Result op_attr_value_from_obj(void *attr, void *src_attr)\n{\n\tuint32_t *v = attr;\n\tuint32_t *src_v = src_attr;\n\n\t*v = *src_v;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_value_clear(void *attr)\n{\n\tuint32_t *v = attr;\n\n\t*v = 0;\n}\n\nstatic TEE_Result op_attr_25519_from_user(void *attr, const void *buffer,\n\t\t\t\t\t  size_t size)\n{\n\tuint8_t **key = attr;\n\n\tif (size != KEY_SIZE_BYTES_25519 || !*key)\n\t\treturn TEE_ERROR_SECURITY;\n\n\tmemcpy(*key, buffer, size);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_25519_to_user(void *attr,\n\t\t\t\t\tstruct ts_session *sess __unused,\n\t\t\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tuint8_t **key = attr;\n\tuint64_t s = 0;\n\tuint64_t key_size = (uint64_t)KEY_SIZE_BYTES_25519;\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = copy_to_user(size, &key_size, sizeof(key_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < key_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn copy_to_user(buffer, *key, key_size);\n}\n\nstatic TEE_Result op_attr_25519_to_binary(void *attr, void *data,\n\t\t\t\t\t  size_t data_len, size_t *offs)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tuint8_t **key = attr;\n\tsize_t next_offs = 0;\n\tuint64_t key_size = (uint64_t)KEY_SIZE_BYTES_25519;\n\n\tres = op_u32_to_binary_helper(key_size, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, key_size, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tmemcpy((uint8_t *)data + *offs, *key, key_size);\n\t*offs = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_25519_from_binary(void *attr, const void *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint8_t **key = attr;\n\tuint32_t s = 0;\n\n\tif (!op_u32_from_binary_helper(&s, data, data_len, offs))\n\t\treturn false;\n\n\tif (*offs + s > data_len)\n\t\treturn false;\n\n\tif (s > (uint32_t)KEY_SIZE_BYTES_25519)\n\t\treturn false;\n\n\tmemcpy(*key, (const uint8_t *)data + *offs, s);\n\t*offs += s;\n\treturn true;\n}\n\nstatic TEE_Result op_attr_25519_from_obj(void *attr, void *src_attr)\n{\n\tuint8_t **key = attr;\n\tuint8_t **src_key = src_attr;\n\n\tif (!*key || !*src_key)\n\t\treturn TEE_ERROR_SECURITY;\n\n\tmemcpy(*key, *src_key, KEY_SIZE_BYTES_25519);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_25519_clear(void *attr)\n{\n\tuint8_t **key = attr;\n\n\tassert(*key);\n\n\tmemzero_explicit(*key, KEY_SIZE_BYTES_25519);\n}\n\nstatic void op_attr_25519_free(void *attr)\n{\n\tuint8_t **key = attr;\n\n\top_attr_25519_clear(attr);\n\tfree(*key);\n}\n\nstatic const struct attr_ops attr_ops[] = {\n\t[ATTR_OPS_INDEX_SECRET] = {\n\t\t.from_user = op_attr_secret_value_from_user,\n\t\t.to_user = op_attr_secret_value_to_user,\n\t\t.to_binary = op_attr_secret_value_to_binary,\n\t\t.from_binary = op_attr_secret_value_from_binary,\n\t\t.from_obj = op_attr_secret_value_from_obj,\n\t\t.free = op_attr_secret_value_clear, /* not a typo */\n\t\t.clear = op_attr_secret_value_clear,\n\t},\n\t[ATTR_OPS_INDEX_BIGNUM] = {\n\t\t.from_user = op_attr_bignum_from_user,\n\t\t.to_user = op_attr_bignum_to_user,\n\t\t.to_binary = op_attr_bignum_to_binary,\n\t\t.from_binary = op_attr_bignum_from_binary,\n\t\t.from_obj = op_attr_bignum_from_obj,\n\t\t.free = op_attr_bignum_free,\n\t\t.clear = op_attr_bignum_clear,\n\t},\n\t[ATTR_OPS_INDEX_VALUE] = {\n\t\t.from_user = op_attr_value_from_user,\n\t\t.to_user = op_attr_value_to_user,\n\t\t.to_binary = op_attr_value_to_binary,\n\t\t.from_binary = op_attr_value_from_binary,\n\t\t.from_obj = op_attr_value_from_obj,\n\t\t.free = op_attr_value_clear, /* not a typo */\n\t\t.clear = op_attr_value_clear,\n\t},\n\t[ATTR_OPS_INDEX_25519] = {\n\t\t.from_user = op_attr_25519_from_user,\n\t\t.to_user = op_attr_25519_to_user,\n\t\t.to_binary = op_attr_25519_to_binary,\n\t\t.from_binary = op_attr_25519_from_binary,\n\t\t.from_obj = op_attr_25519_from_obj,\n\t\t.free = op_attr_25519_free,\n\t\t.clear = op_attr_25519_clear,\n\t},\n};\n\nstatic TEE_Result get_user_u64_as_size_t(size_t *dst, uint64_t *src)\n{\n\tuint64_t d = 0;\n\tTEE_Result res = copy_from_user(&d, src, sizeof(d));\n\n\t/*\n\t * On 32-bit systems a size_t can't hold a uint64_t so we need to\n\t * check that the value isn't too large.\n\t */\n\tif (!res && ADD_OVERFLOW(0, d, dst))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\treturn res;\n}\n\nstatic TEE_Result put_user_u64(uint64_t *dst, size_t value)\n{\n\tuint64_t v = value;\n\n\treturn copy_to_user(dst, &v, sizeof(v));\n}\n\nTEE_Result syscall_cryp_obj_get_info(unsigned long obj,\n\t\t\t\t     struct utee_object_info *info)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct utee_object_info o_info = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\to_info.obj_type = o->info.objectType;\n\to_info.obj_size = o->info.objectSize;\n\to_info.max_obj_size = o->info.maxObjectSize;\n\to_info.obj_usage = o->info.objectUsage;\n\to_info.data_size = o->info.dataSize;\n\to_info.data_pos = o->info.dataPosition;\n\to_info.handle_flags = o->info.handleFlags;\n\tres = copy_to_user_private(info, &o_info, sizeof(o_info));\n\nexit:\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_restrict_usage(unsigned long obj,\n\t\t\tunsigned long usage)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\to->info.objectUsage &= usage;\n\nexit:\n\treturn res;\n}\n\nstatic int tee_svc_cryp_obj_find_type_attr_idx(\n\t\tuint32_t attr_id,\n\t\tconst struct tee_cryp_obj_type_props *type_props)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tif (attr_id == type_props->type_attrs[n].attr_id)\n\t\t\treturn n;\n\t}\n\treturn -1;\n}\n\nstatic const struct tee_cryp_obj_type_props *tee_svc_find_type_props(\n\t\tTEE_ObjectType obj_type)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {\n\t\tif (tee_cryp_obj_props[n].obj_type == obj_type)\n\t\t\treturn tee_cryp_obj_props + n;\n\t}\n\n\treturn NULL;\n}\n\n/* Set an attribute on an object */\nstatic void set_attribute(struct tee_obj *o,\n\t\t\t  const struct tee_cryp_obj_type_props *props,\n\t\t\t  uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn;\n\to->have_attrs |= BIT(idx);\n}\n\n/* Get an attribute on an object */\nstatic uint32_t get_attribute(const struct tee_obj *o,\n\t\t\t      const struct tee_cryp_obj_type_props *props,\n\t\t\t      uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn 0;\n\treturn o->have_attrs & BIT(idx);\n}\n\nTEE_Result syscall_cryp_obj_get_attr(unsigned long obj, unsigned long attr_id,\n\t\t\tvoid *buffer, uint64_t *size)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tint idx = 0;\n\tconst struct attr_ops *ops = NULL;\n\tvoid *attr = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/* Check that the object is initialized */\n\tif (!(o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Check that getting the attribute is allowed */\n\tif (!(attr_id & TEE_ATTR_FLAG_PUBLIC) &&\n\t    !(o->info.objectUsage & TEE_USAGE_EXTRACTABLE))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props) {\n\t\t/* Unknown object type, \"can't happen\" */\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tidx = tee_svc_cryp_obj_find_type_attr_idx(attr_id, type_props);\n\tif ((idx < 0) || ((o->have_attrs & (1 << idx)) == 0))\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\tattr = (uint8_t *)o->attr + type_props->type_attrs[idx].raw_offs;\n\treturn ops->to_user(attr, sess, buffer, size);\n}\n\nvoid tee_obj_attr_free(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);\n\t}\n}\n\nvoid tee_obj_attr_clear(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].clear((uint8_t *)o->attr +\n\t\t\t\t\t      ta->raw_offs);\n\t}\n}\n\nTEE_Result tee_obj_attr_to_binary(struct tee_obj *o, void *data,\n\t\t\t\t  size_t *data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\tsize_t len = data ? *data_len : 0;\n\tTEE_Result res;\n\n\tif (o->info.objectType == TEE_TYPE_DATA) {\n\t\t*data_len = 0;\n\t\treturn TEE_SUCCESS; /* pure data object */\n\t}\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tres = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t*data_len = offs;\n\tif (data && offs > len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_from_binary(struct tee_obj *o, const void *data,\n\t\t\t\t    size_t data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tif (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,\n\t\t\t\t\t\t\t &offs))\n\t\t\treturn TEE_ERROR_CORRUPT_OBJECT;\n\t}\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_copy_from(struct tee_obj *o, const struct tee_obj *src)\n{\n\tTEE_Result res;\n\tconst struct tee_cryp_obj_type_props *tp;\n\tconst struct tee_cryp_obj_type_attrs *ta;\n\tsize_t n;\n\tuint32_t have_attrs = 0;\n\tvoid *attr;\n\tvoid *src_attr;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (o->info.objectType == src->info.objectType) {\n\t\thave_attrs = src->have_attrs;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr + ta->raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t} else {\n\t\tconst struct tee_cryp_obj_type_props *tp_src;\n\t\tint idx;\n\n\t\tif (o->info.objectType == TEE_TYPE_RSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_RSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_DSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_DSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDH_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDH_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_SM2_DSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_SM2_DSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_SM2_PKE_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_SM2_PKE_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_SM2_KEP_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_SM2_KEP_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ED25519_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ED25519_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_X25519_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_X25519_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t\ttp_src = tee_svc_find_type_props(src->info.objectType);\n\t\tif (!tp_src)\n\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\thave_attrs = BIT32(tp->num_type_attrs) - 1;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\n\t\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(ta->attr_id,\n\t\t\t\t\t\t\t\t  tp_src);\n\t\t\tif (idx < 0)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr +\n\t\t\t\t   tp_src->type_attrs[idx].raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\to->have_attrs = have_attrs;\n\treturn TEE_SUCCESS;\n}\n\nstatic bool is_gp_legacy_des_key_size(TEE_ObjectType type, size_t sz)\n{\n\treturn IS_ENABLED(CFG_COMPAT_GP10_DES) &&\n\t       ((type == TEE_TYPE_DES && sz == 56) ||\n\t\t(type == TEE_TYPE_DES3 && (sz == 112 || sz == 168)));\n}\n\nstatic TEE_Result check_key_size(const struct tee_cryp_obj_type_props *props,\n\t\t\t\t size_t key_size)\n{\n\tsize_t sz = key_size;\n\n\t/*\n\t * In GP Internal API Specification 1.0 the partity bits aren't\n\t * counted when telling the size of the key in bits so add them\n\t * here if missing.\n\t */\n\tif (is_gp_legacy_des_key_size(props->obj_type, sz))\n\t\tsz += sz / 7;\n\n\tif (sz % props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (sz < props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (sz > props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,\n\t\t\t    size_t max_key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\n\t/* Can only set type for newly allocated objs */\n\tif (o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Verify that maxObjectSize is supported and find out how\n\t * much should be allocated.\n\t */\n\n\tif (obj_type == TEE_TYPE_DATA) {\n\t\tif (max_key_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t} else {\n\t\t/* Find description of object */\n\t\ttype_props = tee_svc_find_type_props(obj_type);\n\t\tif (!type_props)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\t/* Check that max_key_size follows restrictions */\n\t\tres = check_key_size(type_props, max_key_size);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\to->attr = calloc(1, type_props->alloc_size);\n\t\tif (!o->attr)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t/* If we have a key structure, pre-allocate the bignums inside */\n\tswitch (obj_type) {\n\tcase TEE_TYPE_RSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_rsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_dsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_ecc_public_key(o->attr, obj_type,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tres = crypto_acipher_alloc_ecc_keypair(o->attr, obj_type,\n\t\t\t\t\t\t       max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_X25519_KEYPAIR:\n\t\tres = crypto_acipher_alloc_x25519_keypair(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ED25519_KEYPAIR:\n\t\tres = crypto_acipher_alloc_ed25519_keypair(o->attr,\n\t\t\t\t\t\t\t   max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ED25519_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_ed25519_public_key(o->attr,\n\t\t\t\t\t\t\t      max_key_size);\n\t\tbreak;\n\tdefault:\n\t\tif (obj_type != TEE_TYPE_DATA) {\n\t\t\tstruct tee_cryp_obj_secret *key = o->attr;\n\n\t\t\tkey->alloc_size = type_props->alloc_size -\n\t\t\t\t\t  sizeof(*key);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to->info.objectType = obj_type;\n\to->info.maxObjectSize = max_key_size;\n\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_alloc(unsigned long obj_type,\n\t\t\tunsigned long max_key_size, uint32_t *obj)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\n\to = tee_obj_alloc();\n\tif (!o)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = tee_obj_set_type(o, obj_type, max_key_size);\n\tif (res != TEE_SUCCESS) {\n\t\ttee_obj_free(o);\n\t\treturn res;\n\t}\n\n\ttee_obj_add(to_user_ta_ctx(sess->ctx), o);\n\n\tres = copy_kaddr_to_uref(obj, o);\n\tif (res != TEE_SUCCESS)\n\t\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_close(unsigned long obj)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/*\n\t * If it's busy it's used by an operation, a client should never have\n\t * this handle.\n\t */\n\tif (o->busy)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_reset(unsigned long obj)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) == 0) {\n\t\ttee_obj_attr_clear(o);\n\t\to->info.objectSize = 0;\n\t\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\t} else {\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* the object is no more initialized */\n\to->info.handleFlags &= ~TEE_HANDLE_FLAG_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result copy_in_attrs(struct user_ta_ctx *utc,\n\t\t\tconst struct utee_attribute *usr_attrs,\n\t\t\tuint32_t attr_count, TEE_Attribute *attrs)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t size = 0;\n\tuint32_t n = 0;\n\n\tif (MUL_OVERFLOW(sizeof(struct utee_attribute), attr_count, &size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tusr_attrs = memtag_strip_tag_const(usr_attrs);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)usr_attrs, size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tattrs[n].attributeID = usr_attrs[n].attribute_id;\n\t\tif (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE) {\n\t\t\tattrs[n].content.value.a = usr_attrs[n].a;\n\t\t\tattrs[n].content.value.b = usr_attrs[n].b;\n\t\t} else {\n\t\t\tuintptr_t buf = usr_attrs[n].a;\n\t\t\tsize_t len = usr_attrs[n].b;\n\t\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\t\tbuf = memtag_strip_tag_vaddr((void *)buf);\n\n\t\t\tres = vm_check_access_rights(&utc->uctx, flags, buf,\n\t\t\t\t\t\t     len);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tattrs[n].content.ref.buffer = (void *)buf;\n\t\t\tattrs[n].content.ref.length = len;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nenum attr_usage {\n\tATTR_USAGE_POPULATE,\n\tATTR_USAGE_GENERATE_KEY\n};\n\nstatic TEE_Result tee_svc_cryp_check_attr(enum attr_usage usage,\n\t\t\t\t\t  const struct tee_cryp_obj_type_props\n\t\t\t\t\t\t*type_props,\n\t\t\t\t\t  const TEE_Attribute *attrs,\n\t\t\t\t\t  uint32_t attr_count)\n{\n\tuint32_t required_flag = 0;\n\tuint32_t opt_flag = 0;\n\tbool all_opt_needed = false;\n\tuint32_t req_attrs = 0;\n\tuint32_t opt_grp_attrs = 0;\n\tuint32_t attrs_found = 0;\n\tsize_t n = 0;\n\tuint32_t bit = 0;\n\tuint32_t flags = 0;\n\tint idx = 0;\n\n\tif (usage == ATTR_USAGE_POPULATE) {\n\t\trequired_flag = TEE_TYPE_ATTR_REQUIRED;\n\t\topt_flag = TEE_TYPE_ATTR_OPTIONAL_GROUP;\n\t\tall_opt_needed = true;\n\t} else {\n\t\trequired_flag = TEE_TYPE_ATTR_GEN_KEY_REQ;\n\t\topt_flag = TEE_TYPE_ATTR_GEN_KEY_OPT;\n\t\tall_opt_needed = false;\n\t}\n\n\t/*\n\t * First find out which attributes are required and which belong to\n\t * the optional group\n\t */\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tbit = 1 << n;\n\t\tflags = type_props->type_attrs[n].flags;\n\n\t\tif (flags & required_flag)\n\t\t\treq_attrs |= bit;\n\t\telse if (flags & opt_flag)\n\t\t\topt_grp_attrs |= bit;\n\t}\n\n\t/*\n\t * Verify that all required attributes are in place and\n\t * that the same attribute isn't repeated.\n\t */\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tbit = 1 << idx;\n\n\t\t/* attribute not repeated */\n\t\tif ((attrs_found & bit) != 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\t/*\n\t\t * Attribute not defined in current object type for this\n\t\t * usage.\n\t\t */\n\t\tif (!(bit & (req_attrs | opt_grp_attrs)))\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tattrs_found |= bit;\n\t}\n\t/* Required attribute missing */\n\tif ((attrs_found & req_attrs) != req_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/*\n\t * If the flag says that \"if one of the optional attributes are included\n\t * all of them has to be included\" this must be checked.\n\t */\n\tif (all_opt_needed && (attrs_found & opt_grp_attrs) != 0 &&\n\t    (attrs_found & opt_grp_attrs) != opt_grp_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result get_ec_key_size(uint32_t curve, size_t *key_size)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*key_size = 192;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*key_size = 224;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*key_size = 256;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*key_size = 384;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*key_size = 521;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_SM2:\n\tcase TEE_ECC_CURVE_25519:\n\t\t*key_size = 256;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic size_t get_used_bits(const TEE_Attribute *a)\n{\n\tint nbits = a->content.ref.length * 8;\n\tint v = 0;\n\n\tbit_ffs(a->content.ref.buffer, nbits, &v);\n\treturn nbits - v;\n}\n\nstatic TEE_Result tee_svc_cryp_obj_populate_type(\n\t\tstruct tee_obj *o,\n\t\tconst struct tee_cryp_obj_type_props *type_props,\n\t\tconst TEE_Attribute *attrs,\n\t\tuint32_t attr_count)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tuint32_t have_attrs = 0;\n\tsize_t obj_size = 0;\n\tsize_t n = 0;\n\tint idx = 0;\n\tconst struct attr_ops *ops = NULL;\n\tvoid *attr = NULL;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\thave_attrs |= BIT32(idx);\n\t\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\t\tattr = (uint8_t *)o->attr +\n\t\t       type_props->type_attrs[idx].raw_offs;\n\t\tif (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE)\n\t\t\tres = ops->from_user(attr, &attrs[n].content.value,\n\t\t\t\t\t     sizeof(attrs[n].content.value));\n\t\telse\n\t\t\tres = ops->from_user(attr, attrs[n].content.ref.buffer,\n\t\t\t\t\t     attrs[n].content.ref.length);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\t/*\n\t\t * The attribute that gives the size of the object is\n\t\t * flagged with TEE_TYPE_ATTR_SIZE_INDICATOR.\n\t\t */\n\t\tif (type_props->type_attrs[idx].flags &\n\t\t    TEE_TYPE_ATTR_SIZE_INDICATOR) {\n\t\t\t/* There should be only one */\n\t\t\tif (obj_size)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\t\t/*\n\t\t\t * For ECDSA/ECDH we need to translate curve into\n\t\t\t * object size\n\t\t\t */\n\t\t\tif (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {\n\t\t\t\tres = get_ec_key_size(attrs[n].content.value.a,\n\t\t\t\t\t\t      &obj_size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\tTEE_ObjectType obj_type = o->info.objectType;\n\t\t\t\tsize_t sz = o->info.maxObjectSize;\n\n\t\t\t\tobj_size = attrs[n].content.ref.length * 8;\n\t\t\t\t/* Drop the parity bits for legacy objects */\n\t\t\t\tif (is_gp_legacy_des_key_size(obj_type, sz))\n\t\t\t\t\tobj_size -= obj_size / 8;\n\t\t\t}\n\t\t\tif (obj_size > o->info.maxObjectSize)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\t\t\tres = check_key_size(type_props, obj_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t\t/*\n\t\t * Bignum attributes limited by the number of bits in\n\t\t * o->info.objectSize are flagged with\n\t\t * TEE_TYPE_ATTR_BIGNUM_MAXBITS.\n\t\t */\n\t\tif (type_props->type_attrs[idx].flags &\n\t\t    TEE_TYPE_ATTR_BIGNUM_MAXBITS) {\n\t\t\tif (get_used_bits(attrs + n) > o->info.maxObjectSize)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\t\t}\n\t}\n\n\to->have_attrs = have_attrs;\n\to->info.objectSize = obj_size;\n\t/*\n\t * In GP Internal API Specification 1.0 the partity bits aren't\n\t * counted when telling the size of the key in bits so remove the\n\t * parity bits here.\n\t */\n\tif (is_gp_legacy_des_key_size(o->info.objectType,\n\t\t\t\t      o->info.maxObjectSize))\n\t\to->info.objectSize -= o->info.objectSize / 8;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tTEE_Attribute *attrs = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tattrs = malloc(alloc_size);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\nout:\n\tfree_wipe(attrs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_copy(unsigned long dst, unsigned long src)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *dst_o = NULL;\n\tstruct tee_obj *src_o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  uref_to_vaddr(dst), &dst_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  uref_to_vaddr(src), &src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((src_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_obj_attr_copy_from(dst_o, src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tdst_o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\tdst_o->info.objectSize = src_o->info.objectSize;\n\tdst_o->info.objectUsage = src_o->info.objectUsage;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result check_pub_rsa_key(struct bignum *e)\n{\n\tsize_t n = crypto_bignum_num_bytes(e);\n\tuint8_t bin_key[256 / 8] = { 0 };\n\n\t/*\n\t * NIST SP800-56B requires public RSA key to be an odd integer in\n\t * the range 65537 <= e < 2^256.\n\t */\n\n\tif (n > sizeof(bin_key) || n < 3)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tcrypto_bignum_bn2bin(e, bin_key);\n\n\tif (!(bin_key[n - 1] & 1)) /* key must be odd */\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (n == 3) {\n\t\tuint32_t key = 0;\n\n\t\tfor (n = 0; n < 3; n++) {\n\t\t\tkey <<= 8;\n\t\t\tkey |= bin_key[n];\n\t\t}\n\n\t\tif (key < 65537)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* key is larger than 65537 */\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_rsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct rsa_keypair *key = o->attr;\n\tuint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT)) {\n\t\tres = check_pub_rsa_key(key->e);\n\t\tif (res)\n\t\t\treturn res;\n\t} else {\n\t\tcrypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);\n\t}\n\tres = crypto_acipher_gen_rsa_key(key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size, const TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_acipher_gen_dsa_key(o->attr, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dh(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size, const TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct dh_keypair *tee_dh_key;\n\tstruct bignum *dh_q = NULL;\n\tuint32_t dh_xbits = 0;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_dh_key = (struct dh_keypair *)o->attr;\n\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_SUBPRIME))\n\t\tdh_q = tee_dh_key->q;\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_X_BITS))\n\t\tdh_xbits = tee_dh_key->xbits;\n\tres = crypto_acipher_gen_dh_key(tee_dh_key, dh_q, dh_xbits, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_DH_PUBLIC_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_X_BITS);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_ecc(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size, const TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct ecc_keypair *tee_ecc_key;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_ecc_key = (struct ecc_keypair *)o->attr;\n\n\tres = crypto_acipher_gen_ecc_key(tee_ecc_key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_X);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_Y);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_CURVE);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_generate_key_x25519(struct tee_obj *o,\n\t\t\t\tconst struct tee_cryp_obj_type_props\n\t\t\t\t\t\t\t*type_props,\n\t\t\t\tuint32_t key_size,\n\t\t\t\tconst TEE_Attribute *params,\n\t\t\t\tuint32_t param_count)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tstruct x25519_keypair *tee_x25519_key = NULL;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_x25519_key = (struct x25519_keypair *)o->attr;\n\n\tres = crypto_acipher_gen_x25519_key(tee_x25519_key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_X25519_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_X25519_PUBLIC_VALUE);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_generate_key_ed25519(struct tee_obj *o,\n\t\t\t\t const struct tee_cryp_obj_type_props\n\t\t\t\t\t\t\t*type_props,\n\t\t\t\t uint32_t key_size,\n\t\t\t\t const TEE_Attribute *params,\n\t\t\t\t uint32_t param_count)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tstruct ed25519_keypair *key = NULL;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tkey = o->attr;\n\n\tres = crypto_acipher_gen_ed25519_key(key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_ED25519_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_ED25519_PUBLIC_VALUE);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_ed25519_parse_params(const TEE_Attribute *params, size_t num_params,\n\t\t\t\t bool *ph_flag, const uint8_t **ctx,\n\t\t\t\t size_t *ctx_len)\n{\n\tsize_t n = 0;\n\n\t*ctx = NULL;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_EDDSA_PREHASH:\n\t\t\tif (params[n].content.value.b)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tif (!params[n].content.value.a)\n\t\t\t\t*ph_flag = false;\n\t\t\telse if (params[n].content.value.a == 1)\n\t\t\t\t*ph_flag = true;\n\t\t\telse\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\n\t\tcase TEE_ATTR_EDDSA_CTX:\n\t\t\t/* several provided contexts are treated as error */\n\t\t\tif (*ctx)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\t*ctx_len = params[n].content.ref.length;\n\t\t\tif (*ctx_len > TEE_ED25519_CTX_MAX_LENGTH)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tif (!*ctx_len)\n\t\t\t\tbreak;\n\n\t\t\t*ctx = params[n].content.ref.buffer;\n\t\t\tif (!*ctx)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_ed25519_sign(struct ed25519_keypair *key,\n\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t uint8_t *sig, size_t *sig_len,\n\t\t\t const TEE_Attribute *params, size_t num_params)\n{\n\tTEE_Result err = TEE_ERROR_GENERIC;\n\tsize_t ctx_len = 0;\n\tconst uint8_t *ctx = NULL;\n\tbool ph_flag = false;\n\n\terr = tee_svc_obj_ed25519_parse_params(params, num_params, &ph_flag,\n\t\t\t\t\t       &ctx, &ctx_len);\n\tif (err != TEE_SUCCESS)\n\t\treturn err;\n\n\tif (ph_flag || ctx) {\n\t\treturn crypto_acipher_ed25519ctx_sign(key, msg, msg_len, sig,\n\t\t\t\t\t\t      sig_len, ph_flag,\n\t\t\t\t\t\t      ctx, ctx_len);\n\t}\n\n\treturn crypto_acipher_ed25519_sign(key, msg, msg_len, sig, sig_len);\n}\n\nstatic TEE_Result\ntee_svc_obj_ed25519_verify(struct ed25519_public_key *key,\n\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t   const uint8_t *sig, size_t sig_len,\n\t\t\t   const TEE_Attribute *params, size_t num_params)\n{\n\tTEE_Result err = TEE_ERROR_GENERIC;\n\tsize_t ctx_len = 0;\n\tconst uint8_t *ctx = NULL;\n\tbool ph_flag = false;\n\n\terr = tee_svc_obj_ed25519_parse_params(params, num_params, &ph_flag,\n\t\t\t\t\t       &ctx, &ctx_len);\n\tif (err)\n\t\treturn err;\n\n\tif (ph_flag || ctx) {\n\t\treturn crypto_acipher_ed25519ctx_verify(key, msg, msg_len, sig,\n\t\t\t\t\t\t\tsig_len, ph_flag,\n\t\t\t\t\t\t\tctx, ctx_len);\n\t}\n\n\treturn crypto_acipher_ed25519_verify(key, msg, msg_len, sig, sig_len);\n}\n\nTEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tstruct tee_obj *o = NULL;\n\tstruct tee_cryp_obj_secret *key = NULL;\n\tsize_t byte_size = 0;\n\tTEE_Attribute *params = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that key_size follows restrictions */\n\tres = check_key_size(type_props, key_size);\n\tif (res)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_SM4:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_HMAC_SHA3_224:\n\tcase TEE_TYPE_HMAC_SHA3_256:\n\tcase TEE_TYPE_HMAC_SHA3_384:\n\tcase TEE_TYPE_HMAC_SHA3_512:\n\tcase TEE_TYPE_HMAC_SM3:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * In GP Internal API Specification 1.0 the partity bits\n\t\t * aren't counted when telling the size of the key in bits.\n\t\t */\n\t\tif (is_gp_legacy_des_key_size(o->info.objectType, key_size))\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_X25519_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_x25519(o, type_props, key_size,\n\t\t\t\t\t\t      params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ED25519_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ed25519(o, type_props, key_size,\n\t\t\t\t\t\t       params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree_wipe(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.objectSize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n\nstatic TEE_Result tee_svc_cryp_get_state(struct ts_session *sess,\n\t\t\t\t\t vaddr_t state_id,\n\t\t\t\t\t struct tee_cryp_state **state)\n{\n\tstruct tee_cryp_state *s;\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\n\tTAILQ_FOREACH(s, &utc->cryp_states, link) {\n\t\tif (state_id == (vaddr_t)s) {\n\t\t\t*state = s;\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t}\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic void cryp_state_free(struct user_ta_ctx *utc, struct tee_cryp_state *cs)\n{\n\tstruct tee_obj *o;\n\n\tif (tee_obj_get(utc, cs->key1, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\n\tTAILQ_REMOVE(&utc->cryp_states, cs, link);\n\tif (cs->ctx_finalize != NULL)\n\t\tcs->ctx_finalize(cs->ctx);\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_free_ctx(cs->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_free_ctx(cs->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_free_ctx(cs->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_free_ctx(cs->ctx);\n\t\tbreak;\n\tdefault:\n\t\tassert(!cs->ctx);\n\t}\n\n\tfree(cs);\n}\n\nstatic TEE_Result tee_svc_cryp_check_key_type(const struct tee_obj *o,\n\t\t\t\t\t      uint32_t algo,\n\t\t\t\t\t      TEE_OperationMode mode)\n{\n\tuint32_t req_key_type;\n\tuint32_t req_key_type2 = 0;\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(algo)) {\n\tcase TEE_MAIN_ALGO_MD5:\n\t\treq_key_type = TEE_TYPE_HMAC_MD5;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA1:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA1;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA224:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA224;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA256:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA256;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA384:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA384;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA512:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA512;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_224:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_224;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_256:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_256;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_384:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_384;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_512:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_512;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM3:\n\t\treq_key_type = TEE_TYPE_HMAC_SM3;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_AES:\n\t\treq_key_type = TEE_TYPE_AES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES:\n\t\treq_key_type = TEE_TYPE_DES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES3:\n\t\treq_key_type = TEE_TYPE_DES3;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM4:\n\t\treq_key_type = TEE_TYPE_SM4;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_RSA:\n\t\treq_key_type = TEE_TYPE_RSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_RSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DSA:\n\t\treq_key_type = TEE_TYPE_DSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_DSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DH:\n\t\treq_key_type = TEE_TYPE_DH_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\treq_key_type = TEE_TYPE_ECDSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_ECDSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDH:\n\t\treq_key_type = TEE_TYPE_ECDH_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ED25519:\n\t\treq_key_type = TEE_TYPE_ED25519_KEYPAIR;\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_ED25519_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM2_PKE:\n\t\tif (mode == TEE_MODE_ENCRYPT)\n\t\t\treq_key_type = TEE_TYPE_SM2_PKE_PUBLIC_KEY;\n\t\telse\n\t\t\treq_key_type = TEE_TYPE_SM2_PKE_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM2_DSA_SM3:\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type = TEE_TYPE_SM2_DSA_PUBLIC_KEY;\n\t\telse\n\t\t\treq_key_type = TEE_TYPE_SM2_DSA_KEYPAIR;\n\t\tbreak;\n#if defined(CFG_CRYPTO_SM2_KEP)\n\tcase TEE_MAIN_ALGO_SM2_KEP:\n\t\treq_key_type = TEE_TYPE_SM2_KEP_KEYPAIR;\n\t\treq_key_type2 = TEE_TYPE_SM2_KEP_PUBLIC_KEY;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_HKDF)\n\tcase TEE_MAIN_ALGO_HKDF:\n\t\treq_key_type = TEE_TYPE_HKDF_IKM;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tcase TEE_MAIN_ALGO_CONCAT_KDF:\n\t\treq_key_type = TEE_TYPE_CONCAT_KDF_Z;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tcase TEE_MAIN_ALGO_PBKDF2:\n\t\treq_key_type = TEE_TYPE_PBKDF2_PASSWORD;\n\t\tbreak;\n#endif\n\tcase TEE_MAIN_ALGO_X25519:\n\t\treq_key_type = TEE_TYPE_X25519_KEYPAIR;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tif (req_key_type != o->info.objectType &&\n\t    req_key_type2 != o->info.objectType)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nstatic uint32_t translate_compat_algo(uint32_t algo)\n{\n\tswitch (algo) {\n\tcase __OPTEE_ALG_ECDSA_P192:\n\t\treturn TEE_ALG_ECDSA_SHA1;\n\tcase __OPTEE_ALG_ECDSA_P224:\n\t\treturn TEE_ALG_ECDSA_SHA224;\n\tcase __OPTEE_ALG_ECDSA_P256:\n\t\treturn TEE_ALG_ECDSA_SHA256;\n\tcase __OPTEE_ALG_ECDSA_P384:\n\t\treturn TEE_ALG_ECDSA_SHA384;\n\tcase __OPTEE_ALG_ECDSA_P521:\n\t\treturn TEE_ALG_ECDSA_SHA512;\n\tcase __OPTEE_ALG_ECDH_P192:\n\tcase __OPTEE_ALG_ECDH_P224:\n\tcase __OPTEE_ALG_ECDH_P256:\n\tcase __OPTEE_ALG_ECDH_P384:\n\tcase __OPTEE_ALG_ECDH_P521:\n\t\treturn TEE_ALG_ECDH_DERIVE_SHARED_SECRET;\n\tdefault:\n\t\treturn algo;\n\t}\n}\n\nTEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\n\talgo = translate_compat_algo(algo);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\tcs->state = CRYP_STATE_UNINITIALIZED;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((TEE_ALG_GET_CHAIN_MODE(algo) == TEE_CHAIN_MODE_XTS &&\n\t\t     (key1 == 0 || key2 == 0)) ||\n\t\t    (TEE_ALG_GET_CHAIN_MODE(algo) != TEE_CHAIN_MODE_XTS &&\n\t\t    (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5 &&\n\t\t    !IS_ENABLED(CFG_CRYPTO_RSASSA_NA1)) {\n\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (algo == TEE_ALG_SM2_KEP) {\n\t\t\tif (key1 == 0 || key2 == 0)\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tif (key1 == 0 || key2 != 0)\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs_dst = NULL;\n\tstruct tee_cryp_state *cs_src = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tcs_dst->state = cs_src->state;\n\tcs_dst->ctx_finalize = cs_src->ctx_finalize;\n\n\treturn TEE_SUCCESS;\n}\n\nvoid tee_svc_cryp_free_states(struct user_ta_ctx *utc)\n{\n\tstruct tee_cryp_state_head *states = &utc->cryp_states;\n\n\twhile (!TAILQ_EMPTY(states))\n\t\tcryp_state_free(utc, TAILQ_FIRST(states));\n}\n\nTEE_Result syscall_cryp_state_free(unsigned long state)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcryp_state_free(to_user_ta_ctx(sess->ctx), cs);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, (void *)(key + 1),\n\t\t\t\t\t      key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tchunk = memtag_strip_tag_const(chunk);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool is_xof_algo(uint32_t algo)\n{\n\treturn algo == TEE_ALG_SHAKE128 || algo == TEE_ALG_SHAKE256;\n}\n\nTEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res2 = TEE_SUCCESS;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t hash_size = 0;\n\tsize_t hlen = 0;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tchunk = memtag_strip_tag_const(chunk);\n\thash = memtag_strip_tag(hash);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (is_xof_algo(cs->algo)) {\n\t\t\tif (chunk_size) {\n\t\t\t\tres = crypto_hash_update(cs->ctx, chunk,\n\t\t\t\t\t\t\t chunk_size);\n\t\t\t\tif (res)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * hash_size is supposed to be unchanged for XOF\n\t\t\t * algorithms so return directly.\n\t\t\t */\n\t\t\treturn crypto_hash_final(cs->ctx, hash, hlen);\n\t\t}\n\n\t\tres = tee_alg_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, chunk, chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_alg_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, chunk, chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}\n\nTEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tstruct tee_cryp_obj_secret *key1 = NULL;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tiv = memtag_strip_tag_const(iv);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc = memtag_strip_tag_const(src);\n\tdst = memtag_strip_tag(dst);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tstruct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;\n\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = vm_check_access_rights(uctx, flags, (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_cipher_update(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, false /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\nTEE_Result syscall_cipher_final(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, true /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic TEE_Result get_hkdf_params(uint32_t algo, const TEE_Attribute *params,\n\t\t\t\t  uint32_t param_count,\n\t\t\t\t  void **salt, size_t *salt_len, void **info,\n\t\t\t\t  size_t *info_len, size_t *okm_len,\n\t\t\t\t  uint32_t *hash_id)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, INFO = 0x4, HASH = 0x8 };\n\tuint8_t found = 0;\n\n\t*salt = *info = NULL;\n\t*salt_len = *info_len = *okm_len = 0;\n\n\tif (algo == TEE_ALG_HKDF) {\n\t\t*hash_id = TEE_ALG_SHA256;\n\t} else {\n\t\t*hash_id = TEE_ALG_GET_DIGEST_HASH(algo);\n\t\tfound |= HASH;\n\t}\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase __OPTEE_TEE_ATTR_HKDF_SALT:\n\t\tcase TEE_ATTR_HKDF_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_KDF_KEY_SIZE:\n\t\tcase TEE_ATTR_HKDF_OKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*okm_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase __OPTEE_ATTR_HKDF_INFO:\n\t\tcase TEE_ATTR_HKDF_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*info = params[n].content.ref.buffer;\n\t\t\t\t*info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_HKDF_HASH_ALGORITHM:\n\t\t\tif (!(found & HASH)) {\n\t\t\t\t*hash_id = params[n].content.value.a;\n\t\t\t\tfound |= HASH;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic TEE_Result get_concat_kdf_params(const TEE_Attribute *params,\n\t\t\t\t\tuint32_t param_count,\n\t\t\t\t\tvoid **other_info,\n\t\t\t\t\tsize_t *other_info_len,\n\t\t\t\t\tsize_t *derived_key_len)\n{\n\tsize_t n;\n\tenum { LENGTH = 0x1, INFO = 0x2 };\n\tuint8_t found = 0;\n\n\t*other_info = NULL;\n\t*other_info_len = *derived_key_len = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_CONCAT_KDF_OTHER_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*other_info = params[n].content.ref.buffer;\n\t\t\t\t*other_info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_CONCAT_KDF_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic TEE_Result get_pbkdf2_params(const TEE_Attribute *params,\n\t\t\t\t   uint32_t param_count, void **salt,\n\t\t\t\t   size_t *salt_len, size_t *derived_key_len,\n\t\t\t\t   size_t *iteration_count)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, COUNT = 0x4 };\n\tuint8_t found = 0;\n\n\t*salt = NULL;\n\t*salt_len = *derived_key_len = *iteration_count = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_PBKDF2_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_ITERATION_COUNT:\n\t\t\tif (!(found & COUNT)) {\n\t\t\t\t*iteration_count = params[n].content.value.a;\n\t\t\t\tfound |= COUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif ((found & (LENGTH|COUNT)) != (LENGTH|COUNT))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_SM2_KEP)\nstatic TEE_Result get_sm2_kep_params(const TEE_Attribute *params,\n\t\t\t\t     uint32_t param_count,\n\t\t\t\t     struct ecc_public_key *peer_key,\n\t\t\t\t     struct ecc_public_key *peer_eph_key,\n\t\t\t\t     struct sm2_kep_parms *kep_parms)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tsize_t n;\n\tenum {\n\t\tIS_INITIATOR,\n\t\tPEER_KEY_X,\n\t\tPEER_KEY_Y,\n\t\tPEER_EPH_KEY_X,\n\t\tPEER_EPH_KEY_Y,\n\t\tINITIATOR_ID,\n\t\tRESPONDER_ID,\n\t};\n\tuint8_t mandatory = BIT(IS_INITIATOR) | BIT(PEER_KEY_X) |\n\t\tBIT(PEER_KEY_Y) | BIT(PEER_EPH_KEY_X) | BIT(PEER_EPH_KEY_Y) |\n\t\tBIT(INITIATOR_ID) | BIT(RESPONDER_ID);\n\tuint8_t found = 0;\n\n\tres = crypto_acipher_alloc_ecc_public_key(peer_key,\n\t\t\t\t\t\t  TEE_TYPE_SM2_KEP_PUBLIC_KEY,\n\t\t\t\t\t\t  256);\n\tif (res)\n\t\treturn res;\n\n\tres = crypto_acipher_alloc_ecc_public_key(peer_eph_key,\n\t\t\t\t\t\t  TEE_TYPE_SM2_KEP_PUBLIC_KEY,\n\t\t\t\t\t\t  256);\n\tif (res)\n\t\tgoto out_p;\n\n\tpeer_key->curve = TEE_ECC_CURVE_SM2;\n\tpeer_eph_key->curve = TEE_ECC_CURVE_SM2;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tconst TEE_Attribute *p = &params[n];\n\n\t\tswitch (p->attributeID) {\n\t\tcase TEE_ATTR_SM2_KEP_USER:\n\t\t\tkep_parms->is_initiator = !p->content.value.a;\n\t\t\tfound |= BIT(IS_INITIATOR);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_ECC_PUBLIC_VALUE_X:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_key->x);\n\t\t\tfound |= BIT(PEER_KEY_X);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_ECC_PUBLIC_VALUE_Y:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_key->y);\n\t\t\tfound |= BIT(PEER_KEY_Y);\n\t\t\tbreak;\n\t\tcase __OPTEE_SM2_KEP_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_X:\n\t\tcase TEE_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_X:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_eph_key->x);\n\t\t\tfound |= BIT(PEER_EPH_KEY_X);\n\t\t\tbreak;\n\t\tcase __OPTEE_SM2_KEP_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_Y:\n\t\tcase TEE_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_Y:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_eph_key->y);\n\t\t\tfound |= BIT(PEER_EPH_KEY_Y);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_ID_INITIATOR:\n\t\t\tkep_parms->initiator_id = p->content.ref.buffer;\n\t\t\tkep_parms->initiator_id_len = p->content.ref.length;\n\t\t\tfound |= BIT(INITIATOR_ID);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_ID_RESPONDER:\n\t\t\tkep_parms->responder_id = p->content.ref.buffer;\n\t\t\tkep_parms->responder_id_len = p->content.ref.length;\n\t\t\tfound |= BIT(RESPONDER_ID);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_KEP_CONFIRMATION_IN:\n\t\t\tkep_parms->conf_in = p->content.ref.buffer;\n\t\t\tkep_parms->conf_in_len = p->content.ref.length;\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_KEP_CONFIRMATION_OUT:\n\t\t\tkep_parms->conf_out = p->content.ref.buffer;\n\t\t\tkep_parms->conf_out_len = p->content.ref.length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((found & mandatory) != mandatory) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\treturn TEE_SUCCESS;\nout:\n\tcrypto_acipher_free_ecc_public_key(peer_eph_key);\nout_p:\n\tcrypto_acipher_free_ecc_public_key(peer_key);\n\treturn res;\n}\n#endif\n\nTEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_obj *ko = NULL;\n\tstruct tee_obj *so = NULL;\n\tstruct tee_cryp_state *cs = NULL;\n\tstruct tee_cryp_obj_secret *sk = NULL;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tTEE_Attribute *params = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tstruct bignum *pub = NULL;\n\t\tstruct bignum *ss = NULL;\n\t\tsize_t bin_size = 0;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbin_size = params[0].content.ref.length;\n\n\t\tif (MUL_OVERFLOW(bin_size, 8, &alloc_size)) {\n\t\t\tres = TEE_ERROR_OVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     bin_size, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(pub);\n\t\tcrypto_bignum_free(ss);\n\t} else if (cs->algo == TEE_ALG_ECDH_DERIVE_SHARED_SECRET) {\n\t\tuint32_t curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tstruct ecc_public_key key_public = { };\n\t\tuint8_t *pt_secret = NULL;\n\t\tunsigned long pt_secret_len = 0;\n\t\tuint32_t key_type = TEE_TYPE_ECDH_PUBLIC_KEY;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (curve) {\n\t\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public, key_type,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = 0;\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(cs->algo, params, param_count, &salt,\n\t\t\t\t      &salt_len, &info, &info_len, &okm_len,\n\t\t\t\t      &hash_id);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_SM2_KEP)\n\telse if (cs->algo == TEE_ALG_SM2_KEP) {\n\t\tstruct ecc_public_key peer_eph_key = { };\n\t\tstruct ecc_public_key peer_key = { };\n\t\tstruct sm2_kep_parms kep_parms = {\n\t\t\t.out = (uint8_t *)(sk + 1),\n\t\t\t.out_len = so->info.maxObjectSize,\n\t\t};\n\t\tstruct tee_obj *ko2 = NULL;\n\n\t\tres = tee_obj_get(utc, cs->key2, &ko2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tres = get_sm2_kep_params(params, param_count, &peer_key,\n\t\t\t\t\t &peer_eph_key, &kep_parms);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * key1 is our private keypair, key2 is our ephemeral public key\n\t\t */\n\t\tres = crypto_acipher_sm2_kep_derive(ko->attr, /* key1 */\n\t\t\t\t\t\t    ko2->attr, /* key2 */\n\t\t\t\t\t\t    &peer_key, &peer_eph_key,\n\t\t\t\t\t\t    &kep_parms);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = kep_parms.out_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t\tcrypto_acipher_free_ecc_public_key(&peer_key);\n\t\tcrypto_acipher_free_ecc_public_key(&peer_eph_key);\n\t}\n#endif\n#if defined(CFG_CRYPTO_X25519)\n\telse if (cs->algo == TEE_ALG_X25519) {\n\t\tuint8_t *x25519_pub_key = NULL;\n\t\tuint8_t *pt_secret = NULL;\n\t\tunsigned long pt_secret_len = 0;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_X25519_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* X25519 public key size is 32 bytes */\n\t\tif (params[0].content.ref.length != KEY_SIZE_BYTES_25519) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Set the public key */\n\t\tx25519_pub_key = params[0].content.ref.buffer;\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_x25519_shared_secret(ko->attr,\n\t\t\t\t\t\t\t  x25519_pub_key,\n\t\t\t\t\t\t\t  pt_secret,\n\t\t\t\t\t\t\t  &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_random_number_generate(void *buf, size_t blen)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\n\tbuf = memtag_strip_tag(buf);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE,\n\t\t\t\t     (uaddr_t)buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_rng_read(buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_obj_secret *key = NULL;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tnonce = memtag_strip_tag_const(nonce);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->mode, (uint8_t *)(key + 1),\n\t\t\t\t  key->key_size, nonce, nonce_len, tag_len,\n\t\t\t\t  aad_len, payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\t\t      const void *aad_data, size_t aad_data_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\n\taad_data = memtag_strip_tag_const(aad_data);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)aad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->mode, aad_data,\n\t\t\t\t\taad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\t\t\t  const void *src_data,\n\t\t\t\t\t  size_t src_len, void *dst_data,\n\t\t\t\t\t  uint64_t *dst_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->mode, src_data,\n\t\t\t\t\t    src_len, dst_data, &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_enc_final(unsigned long state, const void *src_data,\n\t\t\t\t     size_t src_len, void *dst_data,\n\t\t\t\t     uint64_t *dst_len, void *tag,\n\t\t\t\t     uint64_t *tag_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\ttag = memtag_strip_tag(tag);\n\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = vm_check_access_rights(uctx,\n\t\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t     (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, src_data, src_len, dst_data,\n\t\t\t\t       &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = TEE_SUCCESS;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\ttag = memtag_strip_tag_const(tag);\n\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = vm_check_access_rights(uctx,\n\t\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t     (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t/* Despite TEE Internal Core API up to v1.3, tag is [inbuf], not [in] */\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, src_data, src_len, dst_data,\n\t\t\t\t       &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nstatic int pkcs1_get_salt_len(const TEE_Attribute *params, uint32_t num_params,\n\t\t\t      size_t default_len)\n{\n\tsize_t n;\n\n\tassert(default_len < INT_MAX);\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tif (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {\n\t\t\tif (params[n].content.value.a < INT_MAX)\n\t\t\t\treturn params[n].content.value.a;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If salt length isn't provided use the default value which is\n\t * the length of the digest.\n\t */\n\treturn default_len;\n}\n\nTEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\tsize_t dlen = 0;\n\tstruct tee_obj *o = NULL;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n = 0;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_SM2_PKE:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_sm2_pke_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t     src_len, dst_data,\n\t\t\t\t\t\t\t     &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_sm2_pke_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t     src_len, dst_data,\n\t\t\t\t\t\t\t     &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_MD5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the optional TEE_ATTR_RSA_OAEP_MGF_HASH is\n\t\t\t * provided for algorithm\n\t\t\t * TEE_ALG_RSAES_PKCS1_OAEP_MGF1_x it must match\n\t\t\t * the internal hash x since we don't support using\n\t\t\t * a different hash for MGF1 yet.\n\t\t\t */\n\t\t\tif (cs->algo != TEE_ALG_RSAES_PKCS1_V1_5 &&\n\t\t\t    params[n].attributeID ==\n\t\t\t    TEE_ATTR_RSA_OAEP_MGF_HASH) {\n\t\t\t\tuint32_t hash = 0;\n\n\t\t\t\tif (params[n].content.ref.length !=\n\t\t\t\t    sizeof(hash)) {\n\t\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(&hash, params[n].content.ref.buffer,\n\t\t\t\t       sizeof(hash));\n\t\t\t\tif (hash !=\n\t\t\t\t    TEE_INTERNAL_HASH_TO_ALGO(cs->algo)) {\n\t\t\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_ED25519:\n\t\tres = tee_svc_obj_ed25519_sign(o->attr, src_data, src_len,\n\t\t\t\t\t       dst_data, &dlen, params,\n\t\t\t\t\t       num_params);\n\t\tbreak;\n\n\tcase TEE_ALG_ECDSA_SHA1:\n\tcase TEE_ALG_ECDSA_SHA224:\n\tcase TEE_ALG_ECDSA_SHA256:\n\tcase TEE_ALG_ECDSA_SHA384:\n\tcase TEE_ALG_ECDSA_SHA512:\n\tcase TEE_ALG_SM2_DSA_SM3:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree_wipe(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tTEE_Attribute *params = NULL;\n\tstruct tee_obj *o = NULL;\n\tsize_t hash_size = 0;\n\tuint32_t hash_algo = 0;\n\tint salt_len = 0;\n\tsize_t alloc_size = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tdata = memtag_strip_tag_const(data);\n\tsig = memtag_strip_tag_const(sig);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_alg_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_alg_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\n\t\tif (data_len != hash_size) {\n\t\t\tstruct dsa_public_key *key = o->attr;\n\n\t\t\t/*\n\t\t\t * Depending on the DSA algorithm (NIST), the\n\t\t\t * digital signature output size may be truncated\n\t\t\t * to the size of a key pair (Q prime size). Q\n\t\t\t * prime size must be less or equal than the hash\n\t\t\t * output length of the hash algorithm involved.\n\t\t\t *\n\t\t\t * We're checking here in order to be able to\n\t\t\t * return this particular error code, which will\n\t\t\t * cause TEE_AsymmetricVerifyDigest() to panic as\n\t\t\t * required by GP. crypto_acipher_dsa_verify() is\n\t\t\t * implemented in the glue layer of the crypto\n\t\t\t * library and it might be a bit harder to catch\n\t\t\t * this particular case there or lead to duplicated\n\t\t\t * code in different crypto glue layers.\n\t\t\t *\n\t\t\t * The GP spec says that we SHOULD panic if\n\t\t\t * data_len != hash_size, but that would break a\n\t\t\t * few of the DSA tests in xtest where the\n\t\t\t * hash_size is larger than possible data_len. So\n\t\t\t * the compromise is in case data_len != hash_size\n\t\t\t * check that it's not smaller than what makes\n\t\t\t * sense.\n\t\t\t */\n\t\t\tif (data_len != crypto_bignum_num_bytes(key->q)) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ED25519:\n\t\tres = tee_svc_obj_ed25519_verify(o->attr, data,\n\t\t\t\t\t\t data_len, sig, sig_len,\n\t\t\t\t\t\t params, num_params);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\tcase TEE_MAIN_ALGO_SM2_DSA_SM3:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <crypto/crypto.h>\n#include <kernel/panic.h>\n#include <mbedtls/bignum.h>\n#include <stdlib.h>\n#include <string.h>\n#include <util.h>\n\n#define ciL\t\t(sizeof(mbedtls_mpi_uint))\t/* chars in limb  */\n#define biL\t\t(ciL << 3)\t\t\t/* bits  in limb  */\n#define BITS_TO_LIMBS(i) ((i) / biL + ((i) % biL != 0))\n\nsize_t crypto_bignum_num_bytes(struct bignum *a)\n{\n\tassert(a != NULL);\n\treturn mbedtls_mpi_size((const mbedtls_mpi *)a);\n}\n\nsize_t crypto_bignum_num_bits(struct bignum *a)\n{\n\tassert(a != NULL);\n\treturn mbedtls_mpi_bitlen((const mbedtls_mpi *)a);\n}\n\nint32_t crypto_bignum_compare(struct bignum *a, struct bignum *b)\n{\n\tint ret = 0;\n\n\tassert(a != NULL);\n\tassert(b != NULL);\n\tret = mbedtls_mpi_cmp_mpi((const mbedtls_mpi *)a,\n\t\t\t\t  (const mbedtls_mpi *)b);\n\treturn CMP_TRILEAN(ret, 0);\n}\n\nvoid crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to)\n{\n\tsize_t len = 0;\n\n\tassert(from != NULL);\n\tassert(to != NULL);\n\tlen = crypto_bignum_num_bytes((struct bignum *)from);\n\tif (mbedtls_mpi_write_binary((mbedtls_mpi *)from, to, len))\n\t\tpanic();\n}\n\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,\n\t\t\t struct bignum *to)\n{\n\tassert(from != NULL);\n\tassert(to != NULL);\n\tif (mbedtls_mpi_read_binary((mbedtls_mpi *)to, from, fromsize))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nvoid crypto_bignum_copy(struct bignum *to, const struct bignum *from)\n{\n\tassert(from != NULL);\n\tassert(to != NULL);\n\tif (mbedtls_mpi_copy((mbedtls_mpi *)to, (const mbedtls_mpi *)from))\n\t\tpanic();\n}\n\nstruct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tmbedtls_mpi *bn = NULL;\n\n\tif (size_bits > CFG_CORE_BIGNUM_MAX_BITS)\n\t\tsize_bits = CFG_CORE_BIGNUM_MAX_BITS;\n\n\tbn = calloc(1, sizeof(mbedtls_mpi));\n\tif (!bn)\n\t\treturn NULL;\n\tmbedtls_mpi_init(bn);\n\tif (mbedtls_mpi_grow(bn, BITS_TO_LIMBS(size_bits)) != 0) {\n\t\tfree(bn);\n\t\treturn NULL;\n\t}\n\n\treturn (struct bignum *)bn;\n}\n\nvoid crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}\n\nvoid crypto_bignum_clear(struct bignum *s)\n{\n\tmbedtls_mpi *bn = (mbedtls_mpi *)s;\n\n\tmemset(bn->p, 0, mbedtls_mpi_size((const mbedtls_mpi *)bn));\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <crypto/crypto.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/dhm.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"mbed_helpers.h\"\n\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,\n\t\t\t\t\t   size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->g = crypto_bignum_allocate(key_size_bits);\n\tif (!s->g)\n\t\tgoto err;\n\ts->p = crypto_bignum_allocate(key_size_bits);\n\tif (!s->p)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->q = crypto_bignum_allocate(key_size_bits);\n\tif (!s->q)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->y);\n\tcrypto_bignum_free(s->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key,\n\t\t\t\t     struct bignum *q __unused,\n\t\t\t\t     size_t xbits, size_t key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_dhm_context dhm;\n\tunsigned char *buf = NULL;\n\tsize_t xbytes = 0;\n\n\tmemset(&dhm, 0, sizeof(dhm));\n\tmbedtls_dhm_init(&dhm);\n\n\tdhm.G = *(mbedtls_mpi *)key->g;\n\tdhm.P = *(mbedtls_mpi *)key->p;\n\n\tdhm.len = crypto_bignum_num_bytes(key->p);\n\tif (key_size != 8 * dhm.len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (xbits == 0)\n\t\txbytes = dhm.len;\n\telse\n\t\txbytes = xbits / 8;\n\n\tbuf = malloc(dhm.len);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\tlmd_res = mbedtls_dhm_make_public(&dhm, (int)xbytes, buf,\n\t\t\t\t\t  dhm.len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_dhm_make_public err, return is 0x%x\", -lmd_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\tcrypto_bignum_bin2bn(buf, xbytes, key->y);\n\t\tcrypto_bignum_copy(key->x, (void *)&dhm.X);\n\t\tres = TEE_SUCCESS;\n\t}\nout:\n\tfree(buf);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&dhm.G);\n\tmbedtls_mpi_init(&dhm.P);\n\tmbedtls_dhm_free(&dhm);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_dh_shared_secret(struct dh_keypair *private_key,\n\t\t\t\t\t   struct bignum *public_key,\n\t\t\t\t\t   struct bignum *secret)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_dhm_context dhm;\n\tunsigned char *buf = NULL;\n\tsize_t olen = 0;\n\n\tmemset(&dhm, 0, sizeof(dhm));\n\tmbedtls_dhm_init(&dhm);\n\n\tdhm.G = *(mbedtls_mpi *)private_key->g;\n\tdhm.P = *(mbedtls_mpi *)private_key->p;\n\tdhm.GX = *(mbedtls_mpi *)private_key->y;\n\tdhm.X = *(mbedtls_mpi *)private_key->x;\n\tdhm.GY = *(mbedtls_mpi *)public_key;\n\n\tdhm.len = crypto_bignum_num_bytes(private_key->p);\n\n\tbuf = malloc(dhm.len);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tlmd_res = mbedtls_dhm_calc_secret(&dhm, buf, dhm.len,\n\t\t\t\t\t  &olen, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_dhm_calc_secret failed, ret is 0x%x\", -lmd_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\tcrypto_bignum_bin2bn(buf, olen, secret);\n\t\tres = TEE_SUCCESS;\n\t}\nout:\n\tfree(buf);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&dhm.G);\n\tmbedtls_mpi_init(&dhm.P);\n\tmbedtls_mpi_init(&dhm.GX);\n\tmbedtls_mpi_init(&dhm.X);\n\tmbedtls_mpi_init(&dhm.GY);\n\tmbedtls_dhm_free(&dhm);\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/ecdh.h>\n#include <mbedtls/ecdsa.h>\n#include <mbedtls/ecp.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/pk.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"mbed_helpers.h\"\n#include \"sm2-dsa.h\"\n#include \"sm2-pke.h\"\n\n/* Translate mbedtls result to TEE result */\nstatic TEE_Result get_tee_result(int lmd_res)\n{\n\tswitch (lmd_res) {\n\tcase 0:\n\t\treturn TEE_SUCCESS;\n\tcase MBEDTLS_ERR_ECP_VERIFY_FAILED:\n\t\treturn TEE_ERROR_SIGNATURE_INVALID;\n\tcase MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL:\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n}\n\nstatic void ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}\n\nstatic TEE_Result ecc_get_keysize(uint32_t curve, uint32_t algo,\n\t\t\t\t  size_t *key_size_bytes, size_t *key_size_bits)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*key_size_bits = 192;\n\t\t*key_size_bytes = 24;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*key_size_bits = 224;\n\t\t*key_size_bytes = 28;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*key_size_bits = 256;\n\t\t*key_size_bytes = 32;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*key_size_bits = 384;\n\t\t*key_size_bytes = 48;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*key_size_bits = 521;\n\t\t*key_size_bytes = 66;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_SM2:\n\t\t*key_size_bits = 256;\n\t\t*key_size_bytes = 32;\n\t\tif (algo != 0 && algo != TEE_ALG_SM2_DSA_SM3 &&\n\t\t    algo != TEE_ALG_SM2_KEP && algo != TEE_ALG_SM2_PKE)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\t*key_size_bits = 0;\n\t\t*key_size_bytes = 0;\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Clear some memory that was used to prepare the context\n */\nstatic void ecc_clear_precomputed(mbedtls_ecp_group *grp)\n{\n\tsize_t i = 0;\n\n\tif (grp->T) {\n\t\tfor (i = 0; i < grp->T_size; i++)\n\t\t\tmbedtls_ecp_point_free(&grp->T[i]);\n\t\tfree(grp->T);\n\t}\n\tgrp->T = NULL;\n\tgrp->T_size = 0;\n}\n\nstatic mbedtls_ecp_group_id curve_to_group_id(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\treturn MBEDTLS_ECP_DP_SECP192R1;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\treturn MBEDTLS_ECP_DP_SECP224R1;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\treturn MBEDTLS_ECP_DP_SECP256R1;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\treturn MBEDTLS_ECP_DP_SECP384R1;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\treturn MBEDTLS_ECP_DP_SECP521R1;\n\tcase TEE_ECC_CURVE_SM2:\n\t\treturn MBEDTLS_ECP_DP_SM2;\n\tdefault:\n\t\treturn MBEDTLS_ECP_DP_NONE;\n\t}\n}\n\nstatic TEE_Result ecc_generate_keypair(struct ecc_keypair *key, size_t key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_ecdsa_context ecdsa;\n\tmbedtls_ecp_group_id gid;\n\tsize_t key_size_bytes = 0;\n\tsize_t key_size_bits = 0;\n\n\tmemset(&ecdsa, 0, sizeof(ecdsa));\n\tmemset(&gid, 0, sizeof(gid));\n\n\tres = ecc_get_keysize(key->curve, 0, &key_size_bytes, &key_size_bits);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (key_size != key_size_bits)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmbedtls_ecdsa_init(&ecdsa);\n\n\t/* Generate the ECC key */\n\tgid = curve_to_group_id(key->curve);\n\tlmd_res = mbedtls_ecdsa_genkey(&ecdsa, gid, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tFMSG(\"mbedtls_ecdsa_genkey failed.\");\n\t\tgoto exit;\n\t}\n\tecc_clear_precomputed(&ecdsa.grp);\n\n\t/* check the size of the keys */\n\tif ((mbedtls_mpi_bitlen(&ecdsa.Q.X) > key_size_bits) ||\n\t    (mbedtls_mpi_bitlen(&ecdsa.Q.Y) > key_size_bits) ||\n\t    (mbedtls_mpi_bitlen(&ecdsa.d) > key_size_bits)) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tFMSG(\"Check the size of the keys failed.\");\n\t\tgoto exit;\n\t}\n\n\t/* check LMD is returning z==1 */\n\tif (mbedtls_mpi_bitlen(&ecdsa.Q.Z) != 1) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tFMSG(\"Check LMD failed.\");\n\t\tgoto exit;\n\t}\n\n\t/* Copy the key */\n\tcrypto_bignum_copy(key->d, (void *)&ecdsa.d);\n\tcrypto_bignum_copy(key->x, (void *)&ecdsa.Q.X);\n\tcrypto_bignum_copy(key->y, (void *)&ecdsa.Q.Y);\n\n\tres = TEE_SUCCESS;\nexit:\n\tmbedtls_ecdsa_free(&ecdsa);\t\t/* Free the temporary key */\n\treturn res;\n}\n\nstatic TEE_Result ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t   const uint8_t *msg, size_t msg_len, uint8_t *sig,\n\t\t\t   size_t *sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tmbedtls_ecdsa_context ecdsa;\n\tmbedtls_ecp_group_id gid;\n\tsize_t key_size_bytes = 0;\n\tsize_t key_size_bits = 0;\n\tmbedtls_mpi r;\n\tmbedtls_mpi s;\n\n\tmemset(&ecdsa, 0, sizeof(ecdsa));\n\tmemset(&gid, 0, sizeof(gid));\n\tmemset(&r, 0, sizeof(r));\n\tmemset(&s, 0, sizeof(s));\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmbedtls_mpi_init(&r);\n\tmbedtls_mpi_init(&s);\n\n\tmbedtls_ecdsa_init(&ecdsa);\n\n\tgid = curve_to_group_id(key->curve);\n\tlmd_res = mbedtls_ecp_group_load(&ecdsa.grp, gid);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tecdsa.d = *(mbedtls_mpi *)key->d;\n\n\tres = ecc_get_keysize(key->curve, algo, &key_size_bytes,\n\t\t\t      &key_size_bits);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tif (*sig_len < 2 * key_size_bytes) {\n\t\t*sig_len = 2 * key_size_bytes;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_ECDSA);\n\tif (pk_info == NULL) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tlmd_res = mbedtls_ecdsa_sign(&ecdsa.grp, &r, &s, &ecdsa.d, msg,\n\t\t\t\t     msg_len, mbd_rand, NULL);\n\tif (lmd_res == 0) {\n\t\t*sig_len = 2 * key_size_bytes;\n\t\tmemset(sig, 0, *sig_len);\n\t\tmbedtls_mpi_write_binary(&r, sig + *sig_len / 2 -\n\t\t\t\t\t mbedtls_mpi_size(&r),\n\t\t\t\t\t mbedtls_mpi_size(&r));\n\n\t\tmbedtls_mpi_write_binary(&s, sig + *sig_len -\n\t\t\t\t\t mbedtls_mpi_size(&s),\n\t\t\t\t\t mbedtls_mpi_size(&s));\n\t\tres = TEE_SUCCESS;\n\t} else {\n\t\tFMSG(\"mbedtls_ecdsa_sign failed, returned 0x%x\\n\", -lmd_res);\n\t\tres = TEE_ERROR_GENERIC;\n\t}\nout:\n\tmbedtls_mpi_free(&r);\n\tmbedtls_mpi_free(&s);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&ecdsa.d);\n\tmbedtls_ecdsa_free(&ecdsa);\n\treturn res;\n}\n\nstatic TEE_Result ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_ecdsa_context ecdsa;\n\tmbedtls_ecp_group_id gid;\n\tsize_t key_size_bytes, key_size_bits = 0;\n\tuint8_t one[1] = { 1 };\n\tmbedtls_mpi r;\n\tmbedtls_mpi s;\n\n\tmemset(&ecdsa, 0, sizeof(ecdsa));\n\tmemset(&gid, 0, sizeof(gid));\n\tmemset(&r, 0, sizeof(r));\n\tmemset(&s, 0, sizeof(s));\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmbedtls_mpi_init(&r);\n\tmbedtls_mpi_init(&s);\n\n\tmbedtls_ecdsa_init(&ecdsa);\n\n\tgid = curve_to_group_id(key->curve);\n\tlmd_res = mbedtls_ecp_group_load(&ecdsa.grp, gid);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tecdsa.Q.X = *(mbedtls_mpi *)key->x;\n\tecdsa.Q.Y = *(mbedtls_mpi *)key->y;\n\tmbedtls_mpi_read_binary(&ecdsa.Q.Z, one, sizeof(one));\n\n\tres = ecc_get_keysize(key->curve, algo,\n\t\t\t      &key_size_bytes, &key_size_bits);\n\tif (res != TEE_SUCCESS) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\t/* check keysize vs sig_len */\n\tif ((key_size_bytes * 2) != sig_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tmbedtls_mpi_read_binary(&r, sig, sig_len / 2);\n\tmbedtls_mpi_read_binary(&s, sig + sig_len / 2, sig_len / 2);\n\n\tlmd_res = mbedtls_ecdsa_verify(&ecdsa.grp, msg, msg_len, &ecdsa.Q,\n\t\t\t\t       &r, &s);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_ecdsa_verify failed, returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t}\nout:\n\tmbedtls_mpi_free(&r);\n\tmbedtls_mpi_free(&s);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&ecdsa.Q.X);\n\tmbedtls_mpi_init(&ecdsa.Q.Y);\n\tmbedtls_ecdsa_free(&ecdsa);\n\treturn res;\n}\n\nstatic TEE_Result ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t    struct ecc_public_key *public_key,\n\t\t\t\t    void *secret, unsigned long *secret_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tuint8_t one[1] = { 1 };\n\tmbedtls_ecdh_context ecdh;\n\tmbedtls_ecp_group_id gid;\n\tsize_t out_len = 0;\n\n\tmemset(&ecdh, 0, sizeof(ecdh));\n\tmemset(&gid, 0, sizeof(gid));\n\tmbedtls_ecdh_init(&ecdh);\n\tgid = curve_to_group_id(private_key->curve);\n\tlmd_res = mbedtls_ecp_group_load(&ecdh.grp, gid);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tecdh.d = *(mbedtls_mpi *)private_key->d;\n\tecdh.Qp.X = *(mbedtls_mpi *)public_key->x;\n\tecdh.Qp.Y = *(mbedtls_mpi *)public_key->y;\n\tmbedtls_mpi_read_binary(&ecdh.Qp.Z, one, sizeof(one));\n\n\tlmd_res = mbedtls_ecdh_calc_secret(&ecdh, &out_len, secret,\n\t\t\t\t\t   *secret_len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\t*secret_len = out_len;\nout:\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&ecdh.d);\n\tmbedtls_mpi_init(&ecdh.Qp.X);\n\tmbedtls_mpi_init(&ecdh.Qp.Y);\n\tmbedtls_ecdh_free(&ecdh);\n\treturn res;\n}\n\nstatic const struct crypto_ecc_keypair_ops ecc_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n\t.sign = ecc_sign,\n\t.shared_secret = ecc_shared_secret,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_pke_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n\t.decrypt = sm2_mbedtls_pke_decrypt,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_kep_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_dsa_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n\t.sign = sm2_mbedtls_dsa_sign,\n};\n\nconst struct crypto_ecc_keypair_ops *\ncrypto_asym_get_ecc_keypair_ops(uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\treturn &ecc_keypair_ops;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn NULL;\n\t\treturn &sm2_dsa_keypair_ops;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn NULL;\n\t\treturn &sm2_pke_keypair_ops;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_keypair_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t uint32_t key_type,\n\t\t\t\t\t size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\ts->ops = &ecc_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_keypair_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\ts->d = crypto_bignum_allocate(key_size_bits);\n\tif (!s->d)\n\t\tgoto err;\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic const struct crypto_ecc_public_ops ecc_public_key_ops = {\n\t.free = ecc_free_public_key,\n\t.verify = ecc_verify,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_pke_public_key_ops = {\n\t.free = ecc_free_public_key,\n\t.encrypt = sm2_mbedtls_pke_encrypt,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_kep_public_key_ops = {\n\t.free = ecc_free_public_key,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_dsa_public_key_ops = {\n\t.free = ecc_free_public_key,\n\t.verify = sm2_mbedtls_dsa_verify,\n};\n\nconst struct crypto_ecc_public_ops*\ncrypto_asym_get_ecc_public_ops(uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\treturn &ecc_public_key_ops;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn NULL;\n\n\t\treturn &sm2_dsa_public_key_ops;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn NULL;\n\n\t\treturn &sm2_pke_public_key_ops;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_public_key_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\ts->ops = &ecc_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_public_key_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <crypto/crypto.h>\n#include <crypto/crypto_impl.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/pk.h>\n#include <mbedtls/pk_internal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee/tee_cryp_utl.h>\n#include <utee_defines.h>\n#include <fault_mitigation.h>\n\n#include \"mbed_helpers.h\"\n\nstatic TEE_Result get_tee_result(int lmd_res)\n{\n\tswitch (lmd_res) {\n\tcase 0:\n\t\treturn TEE_SUCCESS;\n\tcase MBEDTLS_ERR_RSA_PRIVATE_FAILED +\n\t\tMBEDTLS_ERR_MPI_BAD_INPUT_DATA:\n\tcase MBEDTLS_ERR_RSA_BAD_INPUT_DATA:\n\tcase MBEDTLS_ERR_RSA_INVALID_PADDING:\n\tcase MBEDTLS_ERR_PK_TYPE_MISMATCH:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tcase MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE:\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n}\n\nstatic uint32_t tee_algo_to_mbedtls_hash_algo(uint32_t algo)\n{\n\tswitch (algo) {\n#if defined(CFG_CRYPTO_SHA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_SHA1:\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_HMAC_SHA1:\n\t\treturn MBEDTLS_MD_SHA1;\n#endif\n#if defined(CFG_CRYPTO_MD5)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_MD5:\n\tcase TEE_ALG_MD5:\n\tcase TEE_ALG_HMAC_MD5:\n\t\treturn MBEDTLS_MD_MD5;\n#endif\n#if defined(CFG_CRYPTO_SHA224)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_SHA224:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_HMAC_SHA224:\n\t\treturn MBEDTLS_MD_SHA224;\n#endif\n#if defined(CFG_CRYPTO_SHA256)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_SHA256:\n\tcase TEE_ALG_DSA_SHA256:\n\tcase TEE_ALG_HMAC_SHA256:\n\t\treturn MBEDTLS_MD_SHA256;\n#endif\n#if defined(CFG_CRYPTO_SHA384)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_SHA384:\n\tcase TEE_ALG_HMAC_SHA384:\n\t\treturn MBEDTLS_MD_SHA384;\n#endif\n#if defined(CFG_CRYPTO_SHA512)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\tcase TEE_ALG_SHA512:\n\tcase TEE_ALG_HMAC_SHA512:\n\t\treturn MBEDTLS_MD_SHA512;\n#endif\n\tdefault:\n\t\treturn MBEDTLS_MD_NONE;\n\t}\n}\n\nstatic void rsa_init_from_key_pair(mbedtls_rsa_context *rsa,\n\t\t\t\tstruct rsa_keypair *key)\n{\n\tmbedtls_rsa_init(rsa, 0, 0);\n\n\trsa->E = *(mbedtls_mpi *)key->e;\n\trsa->N = *(mbedtls_mpi *)key->n;\n\trsa->D = *(mbedtls_mpi *)key->d;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\trsa->P = *(mbedtls_mpi *)key->p;\n\t\trsa->Q = *(mbedtls_mpi *)key->q;\n\t\trsa->QP = *(mbedtls_mpi *)key->qp;\n\t\trsa->DP = *(mbedtls_mpi *)key->dp;\n\t\trsa->DQ = *(mbedtls_mpi *)key->dq;\n\t}\n\trsa->len = mbedtls_mpi_size(&rsa->N);\n}\n\nstatic void mbd_rsa_free(mbedtls_rsa_context *rsa)\n{\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa->E);\n\tmbedtls_mpi_init(&rsa->N);\n\tmbedtls_mpi_init(&rsa->D);\n\tif (mbedtls_mpi_size(&rsa->P)) {\n\t\tmbedtls_mpi_init(&rsa->P);\n\t\tmbedtls_mpi_init(&rsa->Q);\n\t\tmbedtls_mpi_init(&rsa->QP);\n\t\tmbedtls_mpi_init(&rsa->DP);\n\t\tmbedtls_mpi_init(&rsa->DQ);\n\t}\n\tmbedtls_rsa_free(rsa);\n}\n\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_keypair\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t       size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->e = crypto_bignum_allocate(key_size_bits);\n\tif (!s->e)\n\t\tgoto err;\n\ts->d = crypto_bignum_allocate(key_size_bits);\n\tif (!s->d)\n\t\tgoto err;\n\ts->n = crypto_bignum_allocate(key_size_bits);\n\tif (!s->n)\n\t\tgoto err;\n\ts->p = crypto_bignum_allocate(key_size_bits);\n\tif (!s->p)\n\t\tgoto err;\n\ts->q = crypto_bignum_allocate(key_size_bits);\n\tif (!s->q)\n\t\tgoto err;\n\ts->qp = crypto_bignum_allocate(key_size_bits);\n\tif (!s->qp)\n\t\tgoto err;\n\ts->dp = crypto_bignum_allocate(key_size_bits);\n\tif (!s->dp)\n\t\tgoto err;\n\ts->dq = crypto_bignum_allocate(key_size_bits);\n\tif (!s->dq)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_acipher_free_rsa_keypair(s);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_public_key\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t\t  size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->e = crypto_bignum_allocate(key_size_bits);\n\tif (!s->e)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\ts->n = crypto_bignum_allocate(key_size_bits);\n\tif (!s->n)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_public_key\");\n\nvoid sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}\n\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_keypair\");\n\nvoid sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}\n\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t      size_t key_size)\n__weak __alias(\"sw_crypto_acipher_gen_rsa_key\");\n\nTEE_Result sw_crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t\t size_t key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tmbedtls_rsa_context rsa;\n\tmbedtls_ctr_drbg_context rngctx;\n\tint lmd_res = 0;\n\tuint32_t e = 0;\n\n\tmbedtls_ctr_drbg_init(&rngctx);\n\tif (mbedtls_ctr_drbg_seed(&rngctx, mbd_rand, NULL, NULL, 0))\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\t/* get the public exponent */\n\tmbedtls_mpi_write_binary((mbedtls_mpi *)key->e,\n\t\t\t\t (unsigned char *)&e, sizeof(uint32_t));\n\n\te = TEE_U32_FROM_BIG_ENDIAN(e);\n\tlmd_res = mbedtls_rsa_gen_key(&rsa, mbedtls_ctr_drbg_random, &rngctx,\n\t\t\t\t      key_size, (int)e);\n\tmbedtls_ctr_drbg_free(&rngctx);\n\tif (lmd_res != 0) {\n\t\tres = get_tee_result(lmd_res);\n\t} else if ((size_t)mbedtls_mpi_bitlen(&rsa.N) != key_size) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\t/* Copy the key */\n\t\tcrypto_bignum_copy(key->e, (void *)&rsa.E);\n\t\tcrypto_bignum_copy(key->d, (void *)&rsa.D);\n\t\tcrypto_bignum_copy(key->n, (void *)&rsa.N);\n\t\tcrypto_bignum_copy(key->p, (void *)&rsa.P);\n\n\t\tcrypto_bignum_copy(key->q, (void *)&rsa.Q);\n\t\tcrypto_bignum_copy(key->qp, (void *)&rsa.QP);\n\t\tcrypto_bignum_copy(key->dp, (void *)&rsa.DP);\n\t\tcrypto_bignum_copy(key->dq, (void *)&rsa.DQ);\n\n\t\tres = TEE_SUCCESS;\n\t}\n\n\tmbedtls_rsa_free(&rsa);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tmbedtls_rsa_context rsa;\n\tint lmd_res = 0;\n\tuint8_t *buf = NULL;\n\tunsigned long blen = 0;\n\tunsigned long offset = 0;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\trsa.E = *(mbedtls_mpi *)key->e;\n\trsa.N = *(mbedtls_mpi *)key->n;\n\n\trsa.len = crypto_bignum_num_bytes((void *)&rsa.N);\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = malloc(blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tmemset(buf, 0, blen);\n\tmemcpy(buf + rsa.len - src_len, src, src_len);\n\n\tlmd_res = mbedtls_rsa_public(&rsa, buf, buf);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_rsa_public() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < rsa.len - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < rsa.len - offset) {\n\t\t*dst_len = rsa.len - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = rsa.len - offset;\n\tmemcpy(dst, buf + offset, *dst_len);\nout:\n\tfree(buf);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa.E);\n\tmbedtls_mpi_init(&rsa.N);\n\tmbedtls_rsa_free(&rsa);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tmbedtls_rsa_context rsa;\n\tint lmd_res = 0;\n\tuint8_t *buf = NULL;\n\tunsigned long blen = 0;\n\tunsigned long offset = 0;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\trsa_init_from_key_pair(&rsa, key);\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = malloc(blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tmemset(buf, 0, blen);\n\tmemcpy(buf + rsa.len - src_len, src, src_len);\n\n\tlmd_res = mbedtls_rsa_private(&rsa, NULL, NULL, buf, buf);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_rsa_private() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < rsa.len - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < rsa.len - offset) {\n\t\t*dst_len = rsa.len - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = rsa.len - offset;\n\tmemcpy(dst, (char *)buf + offset, *dst_len);\nout:\n\tif (buf)\n\t\tfree(buf);\n\tmbd_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_keypair *key,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *label __unused,\n\t\t\t\t\t   size_t label_len __unused,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t blen = 0;\n\tsize_t mod_size = 0;\n\tvoid *buf = NULL;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = MBEDTLS_MD_NONE;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\trsa_init_from_key_pair(&rsa, key);\n\n\t/*\n\t * Use a temporary buffer since we don't know exactly how large\n\t * the required size of the out buffer without doing a partial\n\t * decrypt. We know the upper bound though.\n\t */\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmod_size = crypto_bignum_num_bytes(key->n);\n\t\tblen = mod_size - 11;\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\t} else {\n\t\t/* Decoded message is always shorter than encrypted message */\n\t\tblen = src_len;\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\t}\n\n\tbuf = malloc(blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * TEE_ALG_RSAES_PKCS1_V1_5 is invalid in hash. But its hash algo will\n\t * not be used in rsa, so skip it here.\n\t */\n\tif (algo != TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\t\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tif (lmd_padding == MBEDTLS_RSA_PKCS_V15)\n\t\tlmd_res = pk_info->decrypt_func(&rsa, src, src_len, buf, &blen,\n\t\t\t\t\t\tblen, NULL, NULL);\n\telse\n\t\tlmd_res = pk_info->decrypt_func(&rsa, src, src_len, buf, &blen,\n\t\t\t\t\t\tblen, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"decrypt_func() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\n\tif (*dst_len < blen) {\n\t\t*dst_len = blen;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = TEE_SUCCESS;\n\t*dst_len = blen;\n\tmemcpy(dst, buf, blen);\nout:\n\tif (buf)\n\t\tfree(buf);\n\tmbd_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *label __unused,\n\t\t\t\t\t   size_t label_len __unused,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t mod_size = 0;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = MBEDTLS_MD_NONE;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\trsa.E = *(mbedtls_mpi *)key->e;\n\trsa.N = *(mbedtls_mpi *)key->n;\n\n\tmod_size = crypto_bignum_num_bytes(key->n);\n\tif (*dst_len < mod_size) {\n\t\t*dst_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = mod_size;\n\trsa.len = mod_size;\n\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5)\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\telse\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * TEE_ALG_RSAES_PKCS1_V1_5 is invalid in hash. But its hash algo will\n\t * not be used in rsa, so skip it here.\n\t */\n\tif (algo != TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\t\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tlmd_res = pk_info->encrypt_func(&rsa, src, src_len, dst, dst_len,\n\t\t\t\t\t*dst_len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"encrypt_func() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\tres = TEE_SUCCESS;\nout:\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa.E);\n\tmbedtls_mpi_init(&rsa.N);\n\tmbedtls_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t      int salt_len __unused,\n\t\t\t\t      const uint8_t *msg, size_t msg_len,\n\t\t\t\t      uint8_t *sig, size_t *sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_sign\");\n\nTEE_Result sw_crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t\t int salt_len __unused,\n\t\t\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t uint8_t *sig, size_t *sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t mod_size = 0;\n\tsize_t hash_size = 0;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = 0;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\trsa_init_from_key_pair(&rsa, key);\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t      &hash_size);\n\tif (res != TEE_SUCCESS)\n\t\tgoto err;\n\n\tif (msg_len != hash_size) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tmod_size = crypto_bignum_num_bytes(key->n);\n\tif (*sig_len < mod_size) {\n\t\t*sig_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto err;\n\t}\n\trsa.len = mod_size;\n\n\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tif (lmd_padding == MBEDTLS_RSA_PKCS_V15)\n\t\tlmd_res = pk_info->sign_func(&rsa, md_algo, msg, msg_len, sig,\n\t\t\t\t\t     sig_len, NULL, NULL);\n\telse\n\t\tlmd_res = pk_info->sign_func(&rsa, md_algo, msg, msg_len, sig,\n\t\t\t\t\t     sig_len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"sign_func failed, returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto err;\n\t}\n\tres = TEE_SUCCESS;\nerr:\n\tmbd_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tint salt_len __unused,\n\t\t\t\t\tconst uint8_t *msg,\n\t\t\t\t\tsize_t msg_len, const uint8_t *sig,\n\t\t\t\t\tsize_t sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_verify\");\n\nTEE_Result sw_crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   int salt_len __unused,\n\t\t\t\t\t   const uint8_t *msg,\n\t\t\t\t\t   size_t msg_len, const uint8_t *sig,\n\t\t\t\t\t   size_t sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t hash_size = 0;\n\tsize_t bigint_size = 0;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = 0;\n\tstruct ftmn ftmn = { };\n\tunsigned long arg_hash = 0;\n\n\t/*\n\t * The caller expects to call crypto_acipher_rsassa_verify(),\n\t * update the hash as needed.\n\t */\n\tFTMN_CALLEE_SWAP_HASH(FTMN_FUNC_HASH(\"crypto_acipher_rsassa_verify\"));\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\trsa.E = *(mbedtls_mpi *)key->e;\n\trsa.N = *(mbedtls_mpi *)key->n;\n\n\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t      &hash_size);\n\tif (res != TEE_SUCCESS)\n\t\tgoto err;\n\n\tif (msg_len != hash_size) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tbigint_size = crypto_bignum_num_bytes(key->n);\n\tif (sig_len < bigint_size) {\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\t\tgoto err;\n\t}\n\n\trsa.len = bigint_size;\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\targ_hash = FTMN_FUNC_HASH(\"mbedtls_rsa_rsassa_pkcs1_v15_verify\");\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\targ_hash = FTMN_FUNC_HASH(\"mbedtls_rsa_rsassa_pss_verify_ext\");\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tFTMN_PUSH_LINKED_CALL(&ftmn, arg_hash);\n\tlmd_res = pk_info->verify_func(&rsa, md_algo, msg, msg_len,\n\t\t\t\t       sig, sig_len);\n\tif (!lmd_res)\n\t\tFTMN_SET_CHECK_RES_FROM_CALL(&ftmn, FTMN_INCR0, lmd_res);\n\tFTMN_POP_LINKED_CALL(&ftmn);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"verify_func failed, returned 0x%x\", -lmd_res);\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\t\tgoto err;\n\t}\n\tres = TEE_SUCCESS;\n\tgoto out;\n\nerr:\n\tFTMN_SET_CHECK_RES_NOT_ZERO(&ftmn, FTMN_INCR0, res);\nout:\n\tFTMN_CALLEE_DONE_CHECK(&ftmn, FTMN_INCR0, FTMN_STEP_COUNT(1), res);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa.E);\n\tmbedtls_mpi_init(&rsa.N);\n\tmbedtls_rsa_free(&rsa);\n\treturn res;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2017, Linaro Limited\n * Copyright 2020 NXP\n * Copyright 2021, SumUp Service GmbH\n */\n\n#include <assert.h>\n#include <compiler.h>\n#include <crypto/crypto.h>\n#include <crypto/crypto_impl.h>\n#include <kernel/panic.h>\n#include <stdlib.h>\n#include <string.h>\n#include <utee_defines.h>\n\nTEE_Result crypto_hash_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\tstruct crypto_hash_ctx *c = NULL;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_hash_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_MD5:\n\t\t\tres = crypto_md5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA1:\n\t\t\tres = crypto_sha1_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA224:\n\t\t\tres = crypto_sha224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA256:\n\t\t\tres = crypto_sha256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA384:\n\t\t\tres = crypto_sha384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA512:\n\t\t\tres = crypto_sha512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_224:\n\t\t\tres = crypto_sha3_224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_256:\n\t\t\tres = crypto_sha3_256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_384:\n\t\t\tres = crypto_sha3_384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHA3_512:\n\t\t\tres = crypto_sha3_512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHAKE128:\n\t\t\tres = crypto_shake128_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SHAKE256:\n\t\t\tres = crypto_shake256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM3:\n\t\t\tres = crypto_sm3_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_hash_ops *hash_ops(void *ctx)\n{\n\tstruct crypto_hash_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nvoid crypto_hash_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\thash_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_hash_copy_state(void *dst_ctx, void *src_ctx)\n{\n\thash_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\nTEE_Result crypto_hash_init(void *ctx)\n{\n\treturn hash_ops(ctx)->init(ctx);\n}\n\nTEE_Result crypto_hash_update(void *ctx, const uint8_t *data, size_t len)\n{\n\treturn hash_ops(ctx)->update(ctx, data, len);\n}\n\nTEE_Result crypto_hash_final(void *ctx, uint8_t *digest, size_t len)\n{\n\treturn hash_ops(ctx)->final(ctx, digest, len);\n}\n\nTEE_Result crypto_cipher_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\tstruct crypto_cipher_ctx *c = NULL;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_cipher_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_AES_ECB_NOPAD:\n\t\t\tres = crypto_aes_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CBC_NOPAD:\n\t\t\tres = crypto_aes_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CTR:\n\t\t\tres = crypto_aes_ctr_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CTS:\n\t\t\tres = crypto_aes_cts_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_XTS:\n\t\t\tres = crypto_aes_xts_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_ECB_NOPAD:\n\t\t\tres = crypto_des_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_ECB_NOPAD:\n\t\t\tres = crypto_des3_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_CBC_NOPAD:\n\t\t\tres = crypto_des_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CBC_NOPAD:\n\t\t\tres = crypto_des3_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_ECB_NOPAD:\n\t\t\tres = crypto_sm4_ecb_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_CBC_NOPAD:\n\t\t\tres = crypto_sm4_cbc_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_CTR:\n\t\t\tres = crypto_sm4_ctr_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_SM4_XTS:\n\t\t\tres = crypto_sm4_xts_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_cipher_ops *cipher_ops(void *ctx)\n{\n\tstruct crypto_cipher_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nvoid crypto_cipher_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\tcipher_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_cipher_copy_state(void *dst_ctx, void *src_ctx)\n{\n\tcipher_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\nTEE_Result crypto_cipher_init(void *ctx, TEE_OperationMode mode,\n\t\t\t      const uint8_t *key1, size_t key1_len,\n\t\t\t      const uint8_t *key2, size_t key2_len,\n\t\t\t      const uint8_t *iv, size_t iv_len)\n{\n\tif (mode != TEE_MODE_DECRYPT && mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn cipher_ops(ctx)->init(ctx, mode, key1, key1_len, key2, key2_len,\n\t\t\t\t     iv, iv_len);\n}\n\nTEE_Result crypto_cipher_update(void *ctx, TEE_OperationMode mode __unused,\n\t\t\t\tbool last_block, const uint8_t *data,\n\t\t\t\tsize_t len, uint8_t *dst)\n{\n\treturn cipher_ops(ctx)->update(ctx, last_block, data, len, dst);\n}\n\nvoid crypto_cipher_final(void *ctx)\n{\n\tcipher_ops(ctx)->final(ctx);\n}\n\nTEE_Result crypto_cipher_get_block_size(uint32_t algo, size_t *size)\n{\n\tuint32_t class = TEE_ALG_GET_CLASS(algo);\n\n\tif (class != TEE_OPERATION_CIPHER && class != TEE_OPERATION_MAC &&\n\t    class != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(algo)) {\n\tcase TEE_MAIN_ALGO_AES:\n\t\t*size = TEE_AES_BLOCK_SIZE;\n\t\treturn TEE_SUCCESS;\n\tcase TEE_MAIN_ALGO_DES:\n\tcase TEE_MAIN_ALGO_DES3:\n\t\t*size = TEE_DES_BLOCK_SIZE;\n\t\treturn TEE_SUCCESS;\n\tcase TEE_MAIN_ALGO_SM4:\n\t\t*size = TEE_SM4_BLOCK_SIZE;\n\t\treturn TEE_SUCCESS;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n}\n\nTEE_Result crypto_mac_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct crypto_mac_ctx *c = NULL;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_mac_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_HMAC_MD5:\n\t\t\tres = crypto_hmac_md5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA1:\n\t\t\tres = crypto_hmac_sha1_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA224:\n\t\t\tres = crypto_hmac_sha224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA256:\n\t\t\tres = crypto_hmac_sha256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA384:\n\t\t\tres = crypto_hmac_sha384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA512:\n\t\t\tres = crypto_hmac_sha512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_224:\n\t\t\tres = crypto_hmac_sha3_224_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_256:\n\t\t\tres = crypto_hmac_sha3_256_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_384:\n\t\t\tres = crypto_hmac_sha3_384_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SHA3_512:\n\t\t\tres = crypto_hmac_sha3_512_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_HMAC_SM3:\n\t\t\tres = crypto_hmac_sm3_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CBC_MAC_NOPAD:\n\t\t\tres = crypto_aes_cbc_mac_nopad_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CBC_MAC_PKCS5:\n\t\t\tres = crypto_aes_cbc_mac_pkcs5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_CBC_MAC_NOPAD:\n\t\t\tres = crypto_des_cbc_mac_nopad_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES_CBC_MAC_PKCS5:\n\t\t\tres = crypto_des_cbc_mac_pkcs5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CBC_MAC_NOPAD:\n\t\t\tres = crypto_des3_cbc_mac_nopad_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CBC_MAC_PKCS5:\n\t\t\tres = crypto_des3_cbc_mac_pkcs5_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_DES3_CMAC:\n\t\t\tres = crypto_des3_cmac_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tcase TEE_ALG_AES_CMAC:\n\t\t\tres = crypto_aes_cmac_alloc_ctx(&c);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_mac_ops *mac_ops(void *ctx)\n{\n\tstruct crypto_mac_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nvoid crypto_mac_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\tmac_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_mac_copy_state(void *dst_ctx, void *src_ctx)\n{\n\tmac_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\nTEE_Result crypto_mac_init(void *ctx, const uint8_t *key, size_t len)\n{\n\treturn mac_ops(ctx)->init(ctx, key, len);\n}\n\nTEE_Result crypto_mac_update(void *ctx, const uint8_t *data, size_t len)\n{\n\tif (!len)\n\t\treturn TEE_SUCCESS;\n\n\treturn mac_ops(ctx)->update(ctx, data, len);\n}\n\nTEE_Result crypto_mac_final(void *ctx, uint8_t *digest, size_t digest_len)\n{\n\treturn mac_ops(ctx)->final(ctx, digest, digest_len);\n}\n\nTEE_Result crypto_authenc_alloc_ctx(void **ctx, uint32_t algo)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\tstruct crypto_authenc_ctx *c = NULL;\n\n\t/*\n\t * Use default authenc implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_authenc_alloc_ctx(&c, algo);\n\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED) {\n\t\tswitch (algo) {\n#if defined(CFG_CRYPTO_CCM)\n\t\tcase TEE_ALG_AES_CCM:\n\t\t\tres = crypto_aes_ccm_alloc_ctx(&c);\n\t\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_GCM)\n\t\tcase TEE_ALG_AES_GCM:\n\t\t\tres = crypto_aes_gcm_alloc_ctx(&c);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res)\n\t\t*ctx = c;\n\n\treturn res;\n}\n\nstatic const struct crypto_authenc_ops *ae_ops(void *ctx)\n{\n\tstruct crypto_authenc_ctx *c = ctx;\n\n\tassert(c && c->ops);\n\n\treturn c->ops;\n}\n\nTEE_Result crypto_authenc_init(void *ctx, TEE_OperationMode mode,\n\t\t\t       const uint8_t *key, size_t key_len,\n\t\t\t       const uint8_t *nonce, size_t nonce_len,\n\t\t\t       size_t tag_len, size_t aad_len,\n\t\t\t       size_t payload_len)\n{\n\treturn ae_ops(ctx)->init(ctx, mode, key, key_len, nonce, nonce_len,\n\t\t\t\t tag_len, aad_len, payload_len);\n}\n\nTEE_Result crypto_authenc_update_aad(void *ctx, TEE_OperationMode mode __unused,\n\t\t\t\t     const uint8_t *data, size_t len)\n{\n\treturn ae_ops(ctx)->update_aad(ctx, data, len);\n}\n\n\nTEE_Result crypto_authenc_update_payload(void *ctx, TEE_OperationMode mode,\n\t\t\t\t\t const uint8_t *src_data,\n\t\t\t\t\t size_t src_len, uint8_t *dst_data,\n\t\t\t\t\t size_t *dst_len)\n{\n\tif (*dst_len < src_len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t*dst_len = src_len;\n\n\treturn ae_ops(ctx)->update_payload(ctx, mode, src_data, src_len,\n\t\t\t\t\t   dst_data);\n}\n\nTEE_Result crypto_authenc_enc_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, uint8_t *dst_tag,\n\t\t\t\t    size_t *dst_tag_len)\n{\n\tif (*dst_len < src_len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t*dst_len = src_len;\n\n\treturn ae_ops(ctx)->enc_final(ctx, src_data, src_len, dst_data,\n\t\t\t\t      dst_tag, dst_tag_len);\n}\n\nTEE_Result crypto_authenc_dec_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, const uint8_t *tag,\n\t\t\t\t    size_t tag_len)\n{\n\tif (*dst_len < src_len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t*dst_len = src_len;\n\n\treturn ae_ops(ctx)->dec_final(ctx, src_data, src_len, dst_data, tag,\n\t\t\t\t      tag_len);\n}\n\nvoid crypto_authenc_final(void *ctx)\n{\n\tae_ops(ctx)->final(ctx);\n}\n\nvoid crypto_authenc_free_ctx(void *ctx)\n{\n\tif (ctx)\n\t\tae_ops(ctx)->free_ctx(ctx);\n}\n\nvoid crypto_authenc_copy_state(void *dst_ctx, void *src_ctx)\n{\n\tae_ops(dst_ctx)->copy_state(dst_ctx, src_ctx);\n}\n\n#if !defined(CFG_CRYPTO_RSA) && !defined(CFG_CRYPTO_DSA) && \\\n    !defined(CFG_CRYPTO_DH) && !defined(CFG_CRYPTO_ECC)\nstruct bignum *crypto_bignum_allocate(size_t size_bits __unused)\n{\n\treturn NULL;\n}\n\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from __unused,\n\t\t\t\tsize_t fromsize __unused,\n\t\t\t\tstruct bignum *to __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nsize_t crypto_bignum_num_bytes(struct bignum *a __unused)\n{\n\treturn 0;\n}\n\nsize_t crypto_bignum_num_bits(struct bignum *a __unused)\n{\n\treturn 0;\n}\n\n/*\n * crypto_bignum_allocate() and crypto_bignum_bin2bn() failing should be\n * enough to guarantee that the functions calling this function aren't\n * called, but just in case add a panic() here to avoid unexpected\n * behavoir.\n */\nstatic void bignum_cant_happen(void)\n{\n\tvolatile bool b = true;\n\n\t/* Avoid warning about function does not return */\n\tif (b)\n\t\tpanic();\n}\n\nvoid crypto_bignum_bn2bin(const struct bignum *from __unused,\n\t\t\t  uint8_t *to __unused)\n{\n\tbignum_cant_happen();\n}\n\nvoid crypto_bignum_copy(struct bignum *to __unused,\n\t\t\tconst struct bignum *from __unused)\n{\n\tbignum_cant_happen();\n}\n\nvoid crypto_bignum_free(struct bignum **a)\n{\n\tif (a && *a)\n\t\tpanic();\n}\n\nvoid crypto_bignum_clear(struct bignum *a __unused)\n{\n\tbignum_cant_happen();\n}\n\n/* return -1 if a<b, 0 if a==b, +1 if a>b */\nint32_t crypto_bignum_compare(struct bignum *a __unused,\n\t\t\t      struct bignum *b __unused)\n{\n\tbignum_cant_happen();\n\treturn -1;\n}\n#endif\n\n#if !defined(CFG_CRYPTO_RSA)\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s __unused,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s __unused,\n\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s __unused)\n{\n}\n\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s __unused)\n{\n}\n\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key __unused,\n\t\t\t\t      size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key __unused,\n\t\t\t\t\t   const uint8_t *src __unused,\n\t\t\t\t\t   size_t src_len __unused,\n\t\t\t\t\t   uint8_t *dst __unused,\n\t\t\t\t\t   size_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key __unused,\n\t\t\t\t\t   const uint8_t *src __unused,\n\t\t\t\t\t   size_t src_len __unused,\n\t\t\t\t\t   uint8_t *dst __unused,\n\t\t\t\t\t   size_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo __unused,\n\t\t\t\t\tstruct rsa_keypair *key __unused,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src __unused,\n\t\t\t\t\tsize_t src_len __unused,\n\t\t\t\t\tuint8_t *dst __unused,\n\t\t\t\t\tsize_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo __unused,\n\t\t\t\t\tstruct rsa_public_key *key __unused,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src __unused,\n\t\t\t\t\tsize_t src_len __unused,\n\t\t\t\t\tuint8_t *dst __unused,\n\t\t\t\t\tsize_t *dst_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo __unused,\n\t\t\t\t      struct rsa_keypair *key __unused,\n\t\t\t\t      int salt_len __unused,\n\t\t\t\t      const uint8_t *msg __unused,\n\t\t\t\t      size_t msg_len __unused,\n\t\t\t\t      uint8_t *sig __unused,\n\t\t\t\t      size_t *sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo __unused,\n\t\t\t\t\tstruct rsa_public_key *key __unused,\n\t\t\t\t\tint salt_len __unused,\n\t\t\t\t\tconst uint8_t *msg __unused,\n\t\t\t\t\tsize_t msg_len __unused,\n\t\t\t\t\tconst uint8_t *sig __unused,\n\t\t\t\t\tsize_t sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif /*!CFG_CRYPTO_RSA*/\n\n#if !defined(CFG_CRYPTO_DSA)\nTEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s __unused,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s __unused,\n\t\t\t\t    size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key __unused,\n\t\t\t\t      size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_dsa_sign(uint32_t algo __unused,\n\t\t\t\t   struct dsa_keypair *key __unused,\n\t\t\t\t   const uint8_t *msg __unused,\n\t\t\t\t   size_t msg_len __unused,\n\t\t\t\t   uint8_t *sig __unused,\n\t\t\t\t   size_t *sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_dsa_verify(uint32_t algo __unused,\n\t\t\t\t     struct dsa_public_key *key __unused,\n\t\t\t\t     const uint8_t *msg __unused,\n\t\t\t\t     size_t msg_len __unused,\n\t\t\t\t     const uint8_t *sig __unused,\n\t\t\t\t     size_t sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif /*!CFG_CRYPTO_DSA*/\n\n#if !defined(CFG_CRYPTO_DH)\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s __unused,\n\t\t\t\t\t   size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key __unused,\n\t\t\t\t     struct bignum *q __unused,\n\t\t\t\t     size_t xbits __unused,\n\t\t\t\t     size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_dh_shared_secret(struct dh_keypair *private_key __unused,\n\t\t\t\tstruct bignum *public_key __unused,\n\t\t\t\tstruct bignum *secret __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif /*!CFG_CRYPTO_DH*/\n\nTEE_Result crypto_acipher_alloc_ecc_public_key(struct ecc_public_key *key,\n\t\t\t\t\t       uint32_t key_type,\n\t\t\t\t\t       size_t key_size_bits)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_asym_alloc_ecc_public_key(key, key_type, key_size_bits);\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED)\n\t\tres = crypto_asym_alloc_ecc_public_key(key, key_type,\n\t\t\t\t\t\t       key_size_bits);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_alloc_ecc_keypair(struct ecc_keypair *key,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits)\n{\n\tTEE_Result res = TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Use default cryptographic implementation if no matching\n\t * drvcrypt device.\n\t */\n\tres = drvcrypt_asym_alloc_ecc_keypair(key, key_type, key_size_bits);\n\tif (res == TEE_ERROR_NOT_IMPLEMENTED)\n\t\tres = crypto_asym_alloc_ecc_keypair(key, key_type,\n\t\t\t\t\t\t    key_size_bits);\n\n\treturn res;\n}\n\nvoid crypto_acipher_free_ecc_public_key(struct ecc_public_key *key)\n{\n\tassert(key->ops && key->ops->free);\n\n\tkey->ops->free(key);\n}\n\nTEE_Result crypto_acipher_gen_ecc_key(struct ecc_keypair *key,\n\t\t\t\t      size_t key_size_bits)\n{\n\tassert(key->ops && key->ops->generate);\n\n\treturn key->ops->generate(key, key_size_bits);\n}\n\nTEE_Result crypto_acipher_ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->sign)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->sign(algo, key, msg, msg_len, sig, sig_len);\n}\n\nTEE_Result crypto_acipher_ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->verify)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->verify(algo, key, msg, msg_len, sig, sig_len);\n}\n\nTEE_Result crypto_acipher_ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t\t    struct ecc_public_key *public_key,\n\t\t\t\t\t    void *secret,\n\t\t\t\t\t    unsigned long *secret_len)\n{\n\tassert(private_key->ops);\n\n\tif (!private_key->ops->shared_secret)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn private_key->ops->shared_secret(private_key, public_key, secret,\n\t\t\t\t\t       secret_len);\n}\n\nTEE_Result crypto_acipher_sm2_pke_decrypt(struct ecc_keypair *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->decrypt)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->decrypt(key, src, src_len, dst, dst_len);\n}\n\nTEE_Result crypto_acipher_sm2_pke_encrypt(struct ecc_public_key *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len)\n{\n\tassert(key->ops);\n\n\tif (!key->ops->encrypt)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn key->ops->encrypt(key, src, src_len, dst, dst_len);\n}\n\n#if !defined(CFG_CRYPTO_SM2_KEP)\nTEE_Result crypto_acipher_sm2_kep_derive(struct ecc_keypair *my_key __unused,\n\t\t\t\t\t struct ecc_keypair *my_eph_key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t struct ecc_public_key *peer_key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t struct ecc_public_key *peer_eph_key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t struct sm2_kep_parms *p __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif\n\n#if !defined(CFG_CRYPTO_X25519)\nTEE_Result crypto_acipher_alloc_x25519_keypair(struct x25519_keypair *key\n\t\t\t\t\t\t\t\t__unused,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_x25519_key(struct x25519_keypair *key __unused,\n\t\t\t\t\t size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_x25519_shared_secret(struct x25519_keypair\n\t\t\t\t\t       *private_key __unused,\n\t\t\t\t\t       void *public_key __unused,\n\t\t\t\t\t       void *secret __unused,\n\t\t\t\t\t       unsigned long\n\t\t\t\t\t       *secret_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif\n\n#if !defined(CFG_CRYPTO_ED25519)\nTEE_Result crypto_acipher_alloc_ed25519_keypair(struct ed25519_keypair *key\n\t\t\t\t\t\t\t\t __unused,\n\t\t\t\t\t\tsize_t key_size_bits __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_alloc_ed25519_public_key(struct ed25519_public_key *key __unused,\n\t\t\t\t\tsize_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_gen_ed25519_key(struct ed25519_keypair *key __unused,\n\t\t\t\t\t  size_t key_size __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_ed25519_sign(struct ed25519_keypair *key __unused,\n\t\t\t\t       const uint8_t *msg __unused,\n\t\t\t\t       size_t msg_len __unused,\n\t\t\t\t       uint8_t *sig __unused,\n\t\t\t\t       size_t *sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_ed25519_verify(struct ed25519_public_key *key __unused,\n\t\t\t      const uint8_t *msg __unused,\n\t\t\t      size_t msg_len __unused,\n\t\t\t      const uint8_t *sig __unused,\n\t\t\t      size_t sig_len __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result crypto_acipher_ed25519ctx_sign(struct ed25519_keypair *key __unused,\n\t\t\t\t\t  const uint8_t *msg __unused,\n\t\t\t\t\t  size_t msg_len __unused,\n\t\t\t\t\t  uint8_t *sig __unused,\n\t\t\t\t\t  size_t *sig_len __unused,\n\t\t\t\t\t  bool ph_flag __unused,\n\t\t\t\t\t  const uint8_t *ctx __unused,\n\t\t\t\t\t  size_t ctxlen __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nTEE_Result\ncrypto_acipher_ed25519ctx_verify(struct ed25519_public_key *key __unused,\n\t\t\t\t const uint8_t *msg __unused,\n\t\t\t\t size_t msg_len __unused,\n\t\t\t\t const uint8_t *sig __unused,\n\t\t\t\t size_t sig_len __unused,\n\t\t\t\t bool ph_flag __unused,\n\t\t\t\t const uint8_t *ctx __unused,\n\t\t\t\t size_t ctxlen __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n#endif\n\n__weak TEE_Result crypto_storage_obj_del(struct tee_obj *obj __unused)\n{\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2018-2021 NXP\n *\n * Implementation of DH\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <mm/core_memprot.h>\n#include <tee/cache.h>\n#include <string.h>\n\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_KEY_GEN 14\n#define MAX_DESC_SHARED  14\n#else\n#define MAX_DESC_KEY_GEN 9\n#define MAX_DESC_SHARED  9\n#endif\n\n/*\n * Definition of the local DH Keypair\n */\nstruct caam_dh_keypair {\n\tstruct caambuf g; /* Generator */\n\tstruct caambuf p; /* Prime Number Modulus */\n\tstruct caambuf x; /* Private key */\n\tstruct caambuf y; /* Public key */\n};\n\n/*\n * Free local DH keypair\n *\n * @key DH keypair\n */\nstatic void do_keypair_free(struct caam_dh_keypair *key)\n{\n\tcaam_free_buf(&key->g);\n\tcaam_free_buf(&key->p);\n\tcaam_free_buf(&key->x);\n\tcaam_free_buf(&key->y);\n}\n\n/*\n * Convert Crypto DH Key p and g bignumbers to local buffers\n * (via keypair object).\n *\n * @outkey [out] Output keypair in local format\n * @inkey  Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv_p_g(struct caam_dh_keypair *outkey,\n\t\t\t\t\t    const struct dh_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t p_size = 0;\n\tsize_t field_size = 0;\n\n\tp_size = crypto_bignum_num_bytes(inkey->p);\n\n\tDH_TRACE(\"DH Convert Key Parameters (p,g) size %zu bytes\", p_size);\n\n\t/* Prime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->p, p_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\n\t/* Generator */\n\tretstatus = caam_calloc_buf(&outkey->g, p_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of g to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->g);\n\tcrypto_bignum_bn2bin(inkey->g, outkey->g.data + p_size - field_size);\n\tcache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto DH Private Key to a local Private Key (via keypair object)\n *\n * @outkey [out] Output local keypair\n * @inkey  Input Private key in TEE Crypto format\n */\nstatic enum caam_status do_keypriv_conv(struct caam_dh_keypair *outkey,\n\t\t\t\t\tconst struct dh_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t key_size = inkey->xbits / 8;\n\tsize_t p_size = 0;\n\n\tif (!key_size)\n\t\tkey_size = crypto_bignum_num_bytes(inkey->x);\n\n\tDH_TRACE(\"DH Convert Private Key size %zu bytes\", key_size);\n\n\t/* Prime */\n\tp_size = crypto_bignum_num_bytes(inkey->p);\n\tretstatus = caam_calloc_buf(&outkey->p, p_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\n\t/* Private Key X */\n\tretstatus = caam_calloc_buf(&outkey->x, key_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->x, outkey->x.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->x.data, outkey->x.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto DH Public Key to local Public Key (via a keypair object)\n *\n * @outkey [out] Output local keypair\n * @inkey  Input Public key in TEE Crypto format\n */\nstatic enum caam_status do_keypub_conv(struct caam_dh_keypair *outkey,\n\t\t\t\t       const struct bignum *inkey)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t key_size = 0;\n\n\tkey_size = crypto_bignum_num_bytes((struct bignum *)inkey);\n\tDH_TRACE(\"DH Convert Keypair size %zu bytes\", key_size);\n\n\t/* Public Key Y */\n\tretstatus = caam_calloc_buf(&outkey->y, key_size);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey, outkey->y.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->y.data, outkey->y.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Allocate a TEE DH keypair.\n * Note: The subprime q is not used but it must be allocated to prevent\n * system referencing issues when object is destroyed.\n *\n * @key       Keypair\n * @size_bits Key size in bits\n */\nstatic TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Private key X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\t/* Allocate Subprime even if not used */\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDH_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(&key->g);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->x);\n\tcrypto_bignum_free(&key->y);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Generates an DH keypair\n * Keypair @key contains the input prime p and generator g values\n * The function calculates private x and public y, knowing that the\n * number of bits of x is either key_size if specified or p size.\n *\n * @key      [in/out] Keypair\n * @q        Sub Prime (not used)\n * @key_size Key size in bits multiple of 8 bits\n */\nstatic TEE_Result do_gen_keypair(struct dh_keypair *key,\n\t\t\t\t struct bignum *q __unused, size_t key_size)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_dh_keypair caam_dh_key = { };\n\tstruct caambuf dh_r = { };\n\tsize_t n_bytes = key_size / 8;\n\tsize_t l_bytes = 0;\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tint counter = 0;\n\n\tl_bytes = crypto_bignum_num_bytes(key->p);\n\tif (!l_bytes)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/*\n\t * If @key_size not specified, private key size is\n\t * same as the public key size (same as prime size)\n\t */\n\tif (!n_bytes)\n\t\tn_bytes = l_bytes;\n\n\t/*\n\t * CAAM private key support is limited to the descriptor PDB\n\t * N maximum value (PDB_DL_KEY_N_MASK)\n\t */\n\tif (n_bytes > PDB_DL_KEY_N_MASK)\n\t\tn_bytes = PDB_DL_KEY_N_MASK;\n\n\tDH_TRACE(\"Request %zu bits key -> so do %zu bytes key\", key_size,\n\t\t n_bytes);\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_GEN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Allocate Private Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dh_key.x, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dh_key.x.data,\n\t\t\tcaam_dh_key.x.length);\n\n\t/* Allocate Public Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dh_key.y, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dh_key.y.data,\n\t\t\tcaam_dh_key.y.length);\n\n\t/* Allocate Private Key modulus (r) and fill it with one's */\n\tretstatus = caam_calloc_buf(&dh_r, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\tmemset(dh_r.data, UINT8_MAX, dh_r.length);\n\tcache_operation(TEE_CACHECLEAN, dh_r.data, dh_r.length);\n\n\t/* Generator and Prime */\n\tretstatus = do_keypair_conv_p_g(&caam_dh_key, key);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build the descriptor using the PDB Public Key generation\n\t * block (PD=0)\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DL_KEY_L_SIZE(l_bytes) |\n\t\t\t\t PDB_DL_KEY_N_SIZE(n_bytes));\n\tcaam_desc_add_ptr(desc, caam_dh_key.p.paddr);\n\tcaam_desc_add_ptr(desc, dh_r.paddr);\n\tcaam_desc_add_ptr(desc, caam_dh_key.g.paddr);\n\tcaam_desc_add_ptr(desc, caam_dh_key.x.paddr);\n\tcaam_desc_add_ptr(desc, caam_dh_key.y.paddr);\n\tcaam_desc_add_word(desc, PK_KEYPAIR_GEN(DL));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDH_DUMPDESC(desc);\n\n\t/*\n\t * If the Secure Key X doesn't have the correct size\n\t * retry a new generation.\n\t * Retry 10 times before returing an error to not lock the system.\n\t */\n\tfor (counter = 0; counter < 10; counter++) {\n\t\tmemset(&jobctx, 0, sizeof(jobctx));\n\t\tjobctx.desc = desc;\n\t\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\t\tif (retstatus == CAAM_NO_ERROR) {\n\t\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dh_key.x.data,\n\t\t\t\t\tcaam_dh_key.x.length);\n\t\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dh_key.y.data,\n\t\t\t\t\tcaam_dh_key.y.length);\n\n\t\t\t/* Copy Private and Public keypair */\n\t\t\tret = crypto_bignum_bin2bn(caam_dh_key.x.data,\n\t\t\t\t\t\t   caam_dh_key.x.length,\n\t\t\t\t\t\t   key->x);\n\t\t\tif (ret != TEE_SUCCESS)\n\t\t\t\tgoto out;\n\n\t\t\tif (crypto_bignum_num_bytes(key->x) != n_bytes) {\n\t\t\t\tDH_TRACE(\"Error X size=%zu expected %zu\",\n\t\t\t\t\t crypto_bignum_num_bytes(key->x),\n\t\t\t\t\t n_bytes);\n\t\t\t\tDH_DUMPBUF(\"X\", caam_dh_key.x.data,\n\t\t\t\t\t   caam_dh_key.x.length);\n\t\t\t\tDH_DUMPBUF(\"Y\", caam_dh_key.y.data,\n\t\t\t\t\t   caam_dh_key.y.length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = crypto_bignum_bin2bn(caam_dh_key.y.data,\n\t\t\t\t\t\t   caam_dh_key.y.length,\n\t\t\t\t\t\t   key->y);\n\t\t\tif (ret != TEE_SUCCESS)\n\t\t\t\tgoto out;\n\n\t\t\t/* Set the Private Key size in bits */\n\t\t\tkey->xbits = n_bytes * 8;\n\n\t\t\tret = TEE_SUCCESS;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tDH_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\t\tret = job_status_to_tee_result(jobctx.status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tcaam_free_buf(&dh_r);\n\tdo_keypair_free(&caam_dh_key);\n\n\treturn ret;\n}\n\n/*\n * Compute the shared secret data from DH Private key and Public Key\n *\n * @sdata   [in/out] DH Shared Secret data\n */\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct dh_keypair *inkeypair = sdata->key_priv;\n\tstruct caam_dh_keypair caam_dh_key = { };\n\tstruct caamdmaobj secret = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tuint32_t pdb_sgt_flags = 0;\n\n\tDH_TRACE(\"DH Shared Secret\");\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SHARED);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ReAllocate the secret result buffer with a maximum size\n\t * of the secret size if not cache aligned\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&secret, sdata->secret.data,\n\t\t\t\t\tsdata->secret.length,\n\t\t\t\t\tsdata->secret.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (secret.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKDH_SECRET;\n\n\tcaam_dmaobj_cache_push(&secret);\n\n\t/* Convert the Private key to local key */\n\tretstatus = do_keypriv_conv(&caam_dh_key, inkeypair);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&caam_dh_key, sdata->key_pub);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build the descriptor using PDB Shared Secret\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, pdb_sgt_flags |\n\t\t\t\t PDB_DL_KEY_L_SIZE(caam_dh_key.y.length) |\n\t\t\t\t PDB_DL_KEY_N_SIZE(caam_dh_key.x.length));\n\t/* Prime */\n\tcaam_desc_add_ptr(desc, caam_dh_key.p.paddr);\n\t/* Modulus - Not used */\n\tcaam_desc_add_ptr(desc, 0);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, caam_dh_key.y.paddr);\n\t/* Private key */\n\tcaam_desc_add_ptr(desc, caam_dh_key.x.paddr);\n\t/* Output secret */\n\tcaam_desc_add_ptr(desc, secret.sgtbuf.paddr);\n\n\tcaam_desc_add_word(desc, SHARED_SECRET(DL));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDH_DUMPDESC(desc);\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tsdata->secret.length = caam_dmaobj_copy_to_orig(&secret);\n\n\t\tDH_DUMPBUF(\"Secret\", sdata->secret.data, sdata->secret.length);\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tDH_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&caam_dh_key);\n\tcaam_dmaobj_free(&secret);\n\n\treturn ret;\n}\n\n/*\n * Registration of the ECC Driver\n */\nstatic struct drvcrypt_dh driver_dh = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.shared_secret = do_shared_secret,\n};\n\nenum caam_status caam_dh_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base) &&\n\t    drvcrypt_register_dh(&driver_dh) == TEE_SUCCESS)\n\t\tretstatus = CAAM_NO_ERROR;\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2019-2021 NXP\n *\n * Implementation of DSA functions\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <mm/core_memprot.h>\n#include <tee/cache.h>\n#include <string.h>\n\n#include \"local.h\"\n\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_KEY_GEN 14\n#define MAX_DESC_SIGN    19\n#define MAX_DESC_VERIFY  21\n#else\n#define MAX_DESC_KEY_GEN 9\n#define MAX_DESC_SIGN    12\n#define MAX_DESC_VERIFY  13\n#endif\n\n/*\n * Definition of the local DSA Keypair\n *   Domain Parameters (p, q, g)\n *   Private Key format (x)\n *   Public Key format (y)\n */\nstruct caam_dsa_keypair {\n\tstruct caambuf g; /* Generator */\n\tstruct caambuf p; /* Prime Number (L bits) */\n\tstruct caambuf q; /* Subprime Number (N bits) */\n\tstruct caambuf x; /* Private key */\n\tstruct caambuf y; /* Public key */\n};\n\n/*\n * Free local DSA keypair\n *\n * @key  DSA keypair\n */\nstatic void do_keypair_free(struct caam_dsa_keypair *key)\n{\n\tcaam_free_buf(&key->g);\n\tcaam_free_buf(&key->p);\n\tcaam_free_buf(&key->q);\n\tcaam_free_buf(&key->x);\n\tcaam_free_buf(&key->y);\n}\n\n/*\n * If all DSA parameters p, q and g are present, convert them from bignumbers\n * to local buffers (via keypair object). Otherwise generate them.\n *\n * @outkey    [out] Output keypair in local format\n * @key       Input key in TEE Crypto format\n * @l_bytes   Prime p size in bytes\n * @n_bytes   Subprime q size in bytes\n */\nstatic TEE_Result get_keypair_domain_params(struct caam_dsa_keypair *outkey,\n\t\t\t\t\t    const struct dsa_keypair *key,\n\t\t\t\t\t    size_t l_bytes, size_t n_bytes)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t in_q_size = 0;\n\tsize_t in_p_size = 0;\n\tsize_t in_g_size = 0;\n\tstruct prime_data_dsa prime = { };\n\n\tDSA_TRACE(\"DSA conv key param (p, g) of %zu bytes and (q) of %zu bytes\",\n\t\t  l_bytes, n_bytes);\n\n\tretstatus = caam_calloc_buf(&outkey->q, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn caam_status_to_tee_result(retstatus);\n\n\tretstatus = caam_calloc_buf(&outkey->g, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn caam_status_to_tee_result(retstatus);\n\n\tretstatus = caam_calloc_buf(&outkey->p, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn caam_status_to_tee_result(retstatus);\n\n\t/*\n\t * Get all inputs parameters size, if one of them is not\n\t * define generate new parameters\n\t */\n\tin_g_size = crypto_bignum_num_bytes(key->g);\n\tin_p_size = crypto_bignum_num_bytes(key->p);\n\tin_q_size = crypto_bignum_num_bytes(key->q);\n\n\tif (!in_q_size || !in_g_size || !in_p_size) {\n\t\t/* Generate DSA parameters: Generator G and Primes P/Q */\n\t\tprime.g = &outkey->g;\n\t\tprime.p = &outkey->p;\n\t\tprime.q = &outkey->q;\n\n\t\tretstatus = caam_prime_dsa_gen(&prime);\n\t\tDSA_TRACE(\"Generate G and Primes P/Q returned %#x\", retstatus);\n\n\t\tif (retstatus != CAAM_NO_ERROR)\n\t\t\treturn caam_status_to_tee_result(retstatus);\n\n\t\t/* Copy Generated DSA Parameter */\n\t\tcrypto_bignum_bin2bn(outkey->q.data, outkey->q.length, key->q);\n\t\tcrypto_bignum_bin2bn(outkey->g.data, outkey->g.length, key->g);\n\t\tcrypto_bignum_bin2bn(outkey->p.data, outkey->p.length, key->p);\n\n\t} else {\n\t\tDSA_TRACE(\"Prime Q is defined\");\n\n\t\tcrypto_bignum_bn2bin(key->q,\n\t\t\t\t     outkey->q.data + n_bytes - in_q_size);\n\t\tcache_operation(TEE_CACHECLEAN, outkey->q.data,\n\t\t\t\toutkey->q.length);\n\n\t\tDSA_TRACE(\"Prime G is defined\");\n\t\tcrypto_bignum_bn2bin(key->g,\n\t\t\t\t     outkey->g.data + l_bytes - in_g_size);\n\t\tcache_operation(TEE_CACHECLEAN, outkey->g.data,\n\t\t\t\toutkey->g.length);\n\n\t\tDSA_TRACE(\"Prime P is defined\");\n\t\tcrypto_bignum_bn2bin(key->p,\n\t\t\t\t     outkey->p.data + l_bytes - in_p_size);\n\t\tcache_operation(TEE_CACHECLEAN, outkey->p.data,\n\t\t\t\toutkey->p.length);\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Convert Crypto DSA Private Key to local Keypair Key\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @l_bytes   Prime p size in bytes\n * @n_bytes   Subprime q size in bytes\n */\nstatic enum caam_status do_keypriv_conv(struct caam_dsa_keypair *outkey,\n\t\t\t\t\tconst struct dsa_keypair *inkey,\n\t\t\t\t\tsize_t l_bytes, size_t n_bytes)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t field_size = 0;\n\n\tDSA_TRACE(\"DSA Convert Key Private size l=%zu bytes, n=%zu bytes\",\n\t\t  l_bytes, n_bytes);\n\n\t/* Generator */\n\tretstatus = caam_calloc_buf(&outkey->g, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of g to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->g);\n\tcrypto_bignum_bn2bin(inkey->g, outkey->g.data + l_bytes - field_size);\n\n\t/* Prime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->p, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of p to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->p);\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data + l_bytes - field_size);\n\n\t/* Subprime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->q, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of q to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->q);\n\tcrypto_bignum_bn2bin(inkey->q, outkey->q.data + n_bytes - field_size);\n\n\t/* Private key is only scalar x of n bytes */\n\tretstatus = caam_calloc_buf(&outkey->x, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of x to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->x);\n\tcrypto_bignum_bn2bin(inkey->x, outkey->x.data + n_bytes - field_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->q.data, outkey->q.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->x.data, outkey->x.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto DSA Public Key to local DSA Keypair Key\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @l_bytes   Prime p size in bytes\n * @n_bytes   Subprime q size in bytes\n */\nstatic enum caam_status do_keypub_conv(struct caam_dsa_keypair *outkey,\n\t\t\t\t       const struct dsa_public_key *inkey,\n\t\t\t\t       size_t l_bytes, size_t n_bytes)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t field_size = 0;\n\n\tDSA_TRACE(\"DSA Convert Public Key size l=%zu bytes, n=%zu bytes\",\n\t\t  l_bytes, n_bytes);\n\n\t/* Generator */\n\tretstatus = caam_calloc_buf(&outkey->g, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of g to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->g);\n\tcrypto_bignum_bn2bin(inkey->g, outkey->g.data + l_bytes - field_size);\n\n\t/* Prime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->p, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of p to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->p);\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data + l_bytes - field_size);\n\n\t/* Subprime Number Modulus */\n\tretstatus = caam_calloc_buf(&outkey->q, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of q to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->q);\n\tcrypto_bignum_bn2bin(inkey->q, outkey->q.data + n_bytes - field_size);\n\n\t/* Public key is only scalar y of l bytes */\n\tretstatus = caam_calloc_buf(&outkey->y, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of y to pad with 0's */\n\tfield_size = crypto_bignum_num_bytes(inkey->y);\n\tcrypto_bignum_bn2bin(inkey->y, outkey->y.data + l_bytes - field_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->g.data, outkey->g.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, outkey->p.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->q.data, outkey->q.length);\n\tcache_operation(TEE_CACHECLEAN, outkey->y.data, outkey->y.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Allocate a TEE DSA keypair.\n *\n * @key        Keypair\n * @l_bits     L bits size (prime p size)\n * @n_bits     N bits size (subprime q size)\n */\nstatic TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\t/* Allocate Private key X */\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(&key->g);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->q);\n\tcrypto_bignum_free(&key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Allocate a DSA Public Key\n *\n * @key        Public Key\n * @l_bits     L bits size (prime p size)\n * @n_bits     N bits size (subprime q size)\n */\nstatic TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Generator Scalar */\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\n\t/* Allocate Prime Number Modulus */\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\n\t/* Allocate Public Key Y */\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(&key->g);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->q);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Generates an DSA keypair\n * Keypair @key contains the input primes p, g and generator g values\n * The function computes private x and public y.\n *\n * @key        [in/out] Keypair\n * @l_bits     L bits size (prime p size)\n * @n_bits     N bits size (subprime q size)\n */\nstatic TEE_Result do_gen_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t size_t n_bits)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_dsa_keypair caam_dsa_key = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tsize_t l_bytes = l_bits / 8;\n\tsize_t n_bytes = n_bits / 8;\n\n\tDSA_TRACE(\"Generate Key - Private (%zu bits) and Public (%zu bits)\",\n\t\t  n_bits, l_bits);\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_GEN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Allocate Private Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dsa_key.x, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dsa_key.x.data,\n\t\t\tcaam_dsa_key.x.length);\n\n\t/* Allocate Public Key to be generated */\n\tretstatus = caam_calloc_align_buf(&caam_dsa_key.y, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\tcache_operation(TEE_CACHEFLUSH, caam_dsa_key.y.data,\n\t\t\tcaam_dsa_key.y.length);\n\n\t/* Generator and Prime */\n\tret = get_keypair_domain_params(&caam_dsa_key, key, l_bytes, n_bytes);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/*\n\t * Build the descriptor using the PDB Public Key generation\n\t * block (PD=0)\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DL_KEY_L_SIZE(l_bytes) |\n\t\t\t\t PDB_DL_KEY_N_SIZE(n_bytes));\n\tcaam_desc_add_ptr(desc, caam_dsa_key.p.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.q.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.g.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.x.paddr);\n\tcaam_desc_add_ptr(desc, caam_dsa_key.y.paddr);\n\tcaam_desc_add_word(desc, PK_KEYPAIR_GEN(DL));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dsa_key.x.data,\n\t\t\t\tcaam_dsa_key.x.length);\n\t\tcache_operation(TEE_CACHEINVALIDATE, caam_dsa_key.y.data,\n\t\t\t\tcaam_dsa_key.y.length);\n\n\t\t/* Copy Private and Public keypair */\n\t\tret = crypto_bignum_bin2bn(caam_dsa_key.x.data,\n\t\t\t\t\t   caam_dsa_key.x.length, key->x);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tret = crypto_bignum_bin2bn(caam_dsa_key.y.data,\n\t\t\t\t\t   caam_dsa_key.y.length, key->y);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tDSA_DUMPBUF(\"X\", caam_dsa_key.x.data, caam_dsa_key.x.length);\n\t\tDSA_DUMPBUF(\"Y\", caam_dsa_key.y.data, caam_dsa_key.y.length);\n\t} else {\n\t\tDSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&caam_dsa_key);\n\n\treturn ret;\n}\n\n/*\n * Signature of DSA message\n * Note : the message to sign is already hashed\n *\n * @sdata    [in/out] DSA data to sign / Signature\n * @l_bytes  L bytes size (prime p size)\n * @n_bytes  N bytes size (subprime q size)\n */\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata, size_t l_bytes,\n\t\t\t  size_t n_bytes)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct dsa_keypair *inkey = sdata->key;\n\tstruct caam_dsa_keypair dsakey = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tsize_t sign_len = 0;\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tDSA_TRACE(\"DSA Signature\");\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SIGN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the private key to a local key */\n\tretstatus = do_keypriv_conv(&dsakey, inkey, l_bytes, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\tDSA_DUMPBUF(\"Message\", sdata->message.data, sdata->message.length);\n\n\t/*\n\t * Re-allocate the signature result buffer with a maximum size\n\t * of the roundup to 16 bytes of the secure size in bytes if\n\t * the signature buffer is not aligned or too short.\n\t *\n\t *  - 1st Part: size_sec\n\t *  - 2nd Part: size_sec roundup to 16 bytes\n\t */\n\tsign_len = ROUNDUP(sdata->size_sec, 16) + sdata->size_sec;\n\n\tret = caam_dmaobj_output_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t\tsdata->signature.length, sign_len);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_C;\n\n\t/* Prepare the 2nd Part of the signature. Derive from sign_c */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tROUNDUP(sdata->size_sec, 16));\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/*\n\t * Build the descriptor using Predifined ECC curve\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DSA_SIGN_N(n_bytes) |\n\t\t\t\t PDB_DSA_SIGN_L(l_bytes) | pdb_sgt_flags);\n\t/* Prime number */\n\tcaam_desc_add_ptr(desc, dsakey.p.paddr);\n\t/* Prime Modulus */\n\tcaam_desc_add_ptr(desc, dsakey.q.paddr);\n\t/* Generator */\n\tcaam_desc_add_ptr(desc, dsakey.g.paddr);\n\t/* Secret key */\n\tcaam_desc_add_ptr(desc, dsakey.x.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_SIGN(DL));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\t/* Limit the copy to 2 * sdata->size_sec */\n\t\tsign_c.orig.length = 2 * sdata->size_sec;\n\t\tsdata->signature.length = caam_dmaobj_copy_to_orig(&sign_c);\n\n\t\tDSA_DUMPBUF(\"Signature\", sdata->signature.data,\n\t\t\t    sdata->signature.length);\n\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tDSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&dsakey);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_c);\n\tcaam_dmaobj_free(&sign_d);\n\n\treturn ret;\n}\n\n/*\n * Verification of the Signature of DSA message\n * Note the message is already hashed\n *\n * @sdata   [in/out] DSA Signature to verify\n * @l_bytes  L bytes size (prime p size)\n * @n_bytes  N bytes size (subprime q size)\n */\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata, size_t l_bytes,\n\t\t\t    size_t n_bytes)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct dsa_public_key *inkey = sdata->key;\n\tstruct caam_dsa_keypair dsakey = { };\n\tstruct caambuf tmp = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tDSA_TRACE(\"DSA Verify\");\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_VERIFY);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&dsakey, inkey, l_bytes, n_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\t/*\n\t * Prepare the 1st Part of the signature\n\t * Handle the full signature in case signature buffer needs to\n\t * be reallocated.\n\t */\n\tret = caam_dmaobj_input_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t       sdata->signature.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_C;\n\n\t/* Prepare the 2nd Part of the signature, derive from sign_c */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tsdata->size_sec);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/* Allocate a Temporary buffer used by the CAAM */\n\tretstatus = caam_alloc_align_buf(&tmp, l_bytes);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build the descriptor using Predifined ECC curve\n\t */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_DSA_VERIF_N(n_bytes) |\n\t\t\t\t PDB_DSA_VERIF_L(l_bytes) | pdb_sgt_flags);\n\t/* Prime number */\n\tcaam_desc_add_ptr(desc, dsakey.p.paddr);\n\t/* Prime Modulus */\n\tcaam_desc_add_ptr(desc, dsakey.q.paddr);\n\t/* Generator */\n\tcaam_desc_add_ptr(desc, dsakey.g.paddr);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, dsakey.y.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Temporary buffer */\n\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_VERIFY(DL));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tDSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tcache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\tif (retstatus == CAAM_JOB_STATUS && !jobctx.status) {\n\t\tDSA_TRACE(\"DSA Verify Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = TEE_ERROR_SIGNATURE_INVALID;\n\t} else if (retstatus != CAAM_NO_ERROR) {\n\t\tDSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t} else {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&dsakey);\n\tcaam_free_buf(&tmp);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_c);\n\tcaam_dmaobj_free(&sign_d);\n\n\treturn ret;\n}\n\n/*\n * Registration of the DSA Driver\n */\nstatic struct drvcrypt_dsa driver_dsa = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.alloc_publickey = do_allocate_publickey,\n\t.gen_keypair = do_gen_keypair,\n\t.sign = do_sign,\n\t.verify = do_verify,\n};\n\nenum caam_status caam_dsa_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base) &&\n\t    drvcrypt_register_dsa(&driver_dsa) == TEE_SUCCESS)\n\t\tretstatus = CAAM_NO_ERROR;\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2018-2021 NXP\n *\n * Implementation of ECC functions\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <mm/core_memprot.h>\n#include <string.h>\n#include <tee/cache.h>\n\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_KEY_GEN 8\n#define MAX_DESC_SIGN    13\n#define MAX_DESC_VERIFY  15\n#define MAX_DESC_SHARED  10\n#else\n#define MAX_DESC_KEY_GEN 6\n#define MAX_DESC_SIGN    9\n#define MAX_DESC_VERIFY  10\n#define MAX_DESC_SHARED  7\n#endif\n\n/*\n * Definition of the local ECC Keypair\n *   Public Key format (x, y)\n *   Private Key format (d)\n */\nstruct caam_ecc_keypair {\n\tstruct caambuf xy;\n\tstruct caambuf d;\n};\n\n/*\n * Free local ECC keypair\n *\n * @key ECC keypair\n */\nstatic void do_keypair_free(struct caam_ecc_keypair *key)\n{\n\tcaam_free_buf(&key->xy);\n\tcaam_free_buf(&key->d);\n}\n\n/*\n * Convert Crypto ECC Key to local ECC Public Key\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @size_sec  Security size in bytes\n */\nstatic enum caam_status do_keypub_conv(struct caam_ecc_keypair *outkey,\n\t\t\t\t       const struct ecc_public_key *inkey,\n\t\t\t\t       size_t size_sec)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t x_size = 0;\n\tsize_t y_size = 0;\n\n\tECC_TRACE(\"ECC Convert Public Key size %zu bytes\", size_sec);\n\n\t/* Point (x y) is twice security key size */\n\tretstatus = caam_calloc_buf(&outkey->xy, 2 * size_sec);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Copy x and y and get the number of bytes to pad with 0's */\n\tx_size = crypto_bignum_num_bytes(inkey->x);\n\tcrypto_bignum_bn2bin(inkey->x, outkey->xy.data + size_sec - x_size);\n\n\ty_size = crypto_bignum_num_bytes(inkey->y);\n\tcrypto_bignum_bn2bin(inkey->y, outkey->xy.data + 2 * size_sec - y_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->xy.data, outkey->xy.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto ECC Key to local ECC Keypair Key\n * Don't convert the exponent e not used in decrytion\n *\n * @outkey    [out] Output keypair in local format\n * @inkey     Input key in TEE Crypto format\n * @size_sec  Security size in bytes\n */\nstatic enum caam_status do_keypair_conv(struct caam_ecc_keypair *outkey,\n\t\t\t\t\tconst struct ecc_keypair *inkey,\n\t\t\t\t\tsize_t size_sec)\n{\n\tenum caam_status retstatus = CAAM_OUT_MEMORY;\n\tsize_t d_size = 0;\n\n\tECC_TRACE(\"ECC Convert Keypair size %zu bytes\", size_sec);\n\n\t/* Private key is only scalar d of sec_size bytes */\n\tretstatus = caam_calloc_buf(&outkey->d, size_sec);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\t/* Get the number of bytes of d to pad with 0's */\n\td_size = crypto_bignum_num_bytes(inkey->d);\n\tcrypto_bignum_bn2bin(inkey->d, outkey->d.data + size_sec - d_size);\n\n\tcache_operation(TEE_CACHECLEAN, outkey->d.data, outkey->d.length);\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert TEE ECC Curve to CAAM ECC Curve\n *\n * @tee_curve  TEE ECC Curve\n */\nstatic enum caam_ecc_curve get_caam_curve(uint32_t tee_curve)\n{\n\tenum caam_ecc_curve caam_curve = CAAM_ECC_UNKNOWN;\n\n\tif (tee_curve > 0 &&\n\t    tee_curve < CAAM_ECC_MAX + TEE_ECC_CURVE_NIST_P192) {\n\t\t/*\n\t\t * Realign TEE Curve assuming NIST_P192 is the first entry in\n\t\t * the list of supported ECC curves.\n\t\t */\n\t\tcaam_curve = tee_curve - TEE_ECC_CURVE_NIST_P192\n\t\t\t     + CAAM_ECC_P192;\n\t}\n\n\treturn caam_curve;\n}\n\n/*\n * Allocate a ECC keypair\n *\n * @key        Keypair\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_keypair(struct ecc_keypair *key,\n\t\t\t\t      uint32_t type __unused,\n\t\t\t\t      size_t size_bits)\n{\n\tECC_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Secure Scalar */\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err;\n\n\t/* Allocate Public coordinate X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public coordinate Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tECC_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(&key->d);\n\tcrypto_bignum_free(&key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Allocate an ECC Public Key\n *\n * @key        Public Key\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_publickey(struct ecc_public_key *key,\n\t\t\t\t\tuint32_t type __unused,\n\t\t\t\t\tsize_t size_bits)\n{\n\tECC_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\n\t/* Initialize the key fields to NULL */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate Public coordinate X */\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\n\t/* Allocate Public coordinate Y */\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tECC_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(&key->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Free an ECC public key\n *\n * @key  Public Key\n */\nstatic void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(&key->x);\n\tcrypto_bignum_free(&key->y);\n}\n\n/*\n * Generate ECC keypair\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits multiple of 8 bits\n */\nstatic TEE_Result do_gen_keypair(struct ecc_keypair *key, size_t key_size)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct caambuf d = { };\n\tstruct caambuf xy = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\n\tECC_TRACE(\"Generate Keypair of %zu bits\", key_size);\n\n\t/* The key size must be a multiple of 8 bits */\n\tkey_size = ROUNDUP(key_size, 8);\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(key->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_GEN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Allocate secure and public keys in one buffer\n\t * Secure key size = key_size align in bytes\n\t * Public key size = (key_size * 2) align in bytes\n\t */\n\tretstatus = caam_alloc_align_buf(&d, (key_size / 8) * 3);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Build the xy buffer to simplify the code */\n\txy.data = d.data + key_size / 8;\n\txy.length = 2 * (key_size / 8);\n\txy.paddr = d.paddr + key_size / 8;\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_PKGEN_PD1 | PDB_ECC_ECDSEL(curve));\n\tcaam_desc_add_ptr(desc, d.paddr);\n\tcaam_desc_add_ptr(desc, xy.paddr);\n\tcaam_desc_add_word(desc, PK_KEYPAIR_GEN(ECC));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tcache_operation(TEE_CACHEFLUSH, d.data, d.length);\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tcache_operation(TEE_CACHEINVALIDATE, d.data, d.length);\n\n\t\t/* Copy all keypair parameters */\n\t\tret = crypto_bignum_bin2bn(d.data, key_size / 8, key->d);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tret = crypto_bignum_bin2bn(xy.data, xy.length / 2, key->x);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tret = crypto_bignum_bin2bn(xy.data + xy.length / 2,\n\t\t\t\t\t   xy.length / 2, key->y);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tECC_DUMPBUF(\"D\", d.data, key_size / 8);\n\t\tECC_DUMPBUF(\"X\", xy.data, xy.length / 2);\n\t\tECC_DUMPBUF(\"Y\", xy.data + xy.length / 2, xy.length / 2);\n\t} else {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tcaam_free_buf(&d);\n\n\treturn ret;\n}\n\n/*\n * Signature of ECC message\n * Note the message to sign is already hashed\n *\n * @sdata   [in/out] ECC data to sign / Signature\n */\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct ecc_keypair *inkey = sdata->key;\n\tstruct caam_ecc_keypair ecckey = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tsize_t sign_len = 0;\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tECC_TRACE(\"ECC Signature\");\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(inkey->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SIGN);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the private key to a local key */\n\tretstatus = do_keypair_conv(&ecckey, inkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\tECC_DUMPBUF(\"Message\", sdata->message.data, sdata->message.length);\n\n\t/*\n\t * ReAllocate the signature result buffer with a maximum size\n\t * of the roundup to 16 bytes of the secure size in bytes if\n\t * the signature buffer is not aligned or too short.\n\t *\n\t *  - 1st Part: size_sec\n\t *  - 2nd Part: size_sec roundup to 16 bytes\n\t */\n\tsign_len = ROUNDUP(sdata->size_sec, 16) + sdata->size_sec;\n\n\tret = caam_dmaobj_output_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t\tsdata->signature.length, sign_len);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_C;\n\n\t/* Derive sign_d from created sign_c DMA object */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tROUNDUP(sdata->size_sec, 16));\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKSIGN_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_PKSIGN_PD1 | PDB_ECC_ECDSEL(curve) |\n\t\t\t\t pdb_sgt_flags);\n\t/* Secret key */\n\tcaam_desc_add_ptr(desc, ecckey.d.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_SIGN(ECC));\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tsign_c.orig.length = 2 * sdata->size_sec;\n\t\tsdata->signature.length = caam_dmaobj_copy_to_orig(&sign_c);\n\n\t\tECC_DUMPBUF(\"Signature\", sdata->signature.data,\n\t\t\t    sdata->signature.length);\n\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&ecckey);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_d);\n\tcaam_dmaobj_free(&sign_c);\n\n\treturn ret;\n}\n\n/*\n * Verification of the Signature of ECC message\n * Note the message is already hashed\n *\n * @sdata   [in/out] ECC Signature to verify\n */\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct ecc_public_key *inkey = sdata->key;\n\tstruct caam_ecc_keypair ecckey = { };\n\tstruct caambuf tmp = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj msg = { };\n\tstruct caamdmaobj sign_c = { };\n\tstruct caamdmaobj sign_d = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tECC_TRACE(\"ECC Verify\");\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(inkey->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_VERIFY);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&ecckey, inkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Prepare the input message CAAM Descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, sdata->message.data,\n\t\t\t\t       sdata->message.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_MSG;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\t/*\n\t * Prepare the 1st Part of the signature\n\t * Handle the full signature in case signature buffer needs to\n\t * be reallocated.\n\t */\n\tret = caam_dmaobj_input_sgtbuf(&sign_c, sdata->signature.data,\n\t\t\t\t       sdata->signature.length);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_c.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_C;\n\n\t/* Prepare the 2nd Part of the signature, derived from sign_c */\n\tret = caam_dmaobj_derive_sgtbuf(&sign_d, &sign_c, sdata->size_sec,\n\t\t\t\t\tsdata->size_sec);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sign_d.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKVERIF_SIGN_D;\n\n\tcaam_dmaobj_cache_push(&sign_c);\n\n\t/* Allocate a Temporary buffer used by the CAAM */\n\tretstatus = caam_alloc_align_buf(&tmp, 2 * sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_PKVERIFY_PD1 | PDB_ECC_ECDSEL(curve) |\n\t\t\t\t pdb_sgt_flags);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, ecckey.xy.paddr);\n\t/* Input message */\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t/* Signature 1st part */\n\tcaam_desc_add_ptr(desc, sign_c.sgtbuf.paddr);\n\t/* Signature 2nd part */\n\tcaam_desc_add_ptr(desc, sign_d.sgtbuf.paddr);\n\t/* Temporary buffer */\n\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t/* Message length */\n\tcaam_desc_add_word(desc, sdata->message.length);\n\n\tcaam_desc_add_word(desc, DSA_VERIFY(ECC));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tcache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_JOB_STATUS && !jobctx.status) {\n\t\tECC_TRACE(\"ECC Verify Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = TEE_ERROR_SIGNATURE_INVALID;\n\t} else if (retstatus != CAAM_NO_ERROR) {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t} else {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&ecckey);\n\tcaam_free_buf(&tmp);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&sign_c);\n\tcaam_dmaobj_free(&sign_d);\n\n\treturn ret;\n}\n\n/*\n * Compute the shared secret data from ECC Private key and Public Key\n *\n * @sdata   [in/out] ECC Shared Secret data\n */\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tenum caam_ecc_curve curve = CAAM_ECC_UNKNOWN;\n\tstruct ecc_keypair *inprivkey = sdata->key_priv;\n\tstruct ecc_public_key *inpubkey = sdata->key_pub;\n\tstruct caam_ecc_keypair ecckey = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tstruct caamdmaobj secret = { };\n\tuint32_t pdb_sgt_flags = 0;\n\n\tECC_TRACE(\"ECC Shared Secret\");\n\n\t/* Verify first if the curve is supported */\n\tcurve = get_caam_curve(inpubkey->curve);\n\tif (curve == CAAM_ECC_UNKNOWN)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_SHARED);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\t/* Convert the Private key to local key */\n\tretstatus = do_keypair_conv(&ecckey, inprivkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/* Convert the Public key to local key */\n\tretstatus = do_keypub_conv(&ecckey, inpubkey, sdata->size_sec);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Re-allocate the secret result buffer with a maximum size\n\t * of the secret size if not cache aligned\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&secret, sdata->secret.data,\n\t\t\t\t\tsdata->secret.length, sdata->size_sec);\n\tif (ret)\n\t\tgoto out;\n\n\tif (secret.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_SGT_PKDH_SECRET;\n\n\tcaam_dmaobj_cache_push(&secret);\n\n\t/* Build the descriptor using Predifined ECC curve */\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_SHARED_SECRET_PD1 | PDB_ECC_ECDSEL(curve) |\n\t\t\t\t pdb_sgt_flags);\n\t/* Public key */\n\tcaam_desc_add_ptr(desc, ecckey.xy.paddr);\n\t/* Private key */\n\tcaam_desc_add_ptr(desc, ecckey.d.paddr);\n\t/* Output secret */\n\tcaam_desc_add_ptr(desc, secret.sgtbuf.paddr);\n\n\tcaam_desc_add_word(desc, SHARED_SECRET(ECC));\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tECC_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tsdata->secret.length = caam_dmaobj_copy_to_orig(&secret);\n\n\t\tECC_DUMPBUF(\"Secret\", sdata->secret.data, sdata->secret.length);\n\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tECC_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nout:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&ecckey);\n\tcaam_dmaobj_free(&secret);\n\n\treturn ret;\n}\n\n/*\n * Registration of the ECC Driver\n */\nstatic struct drvcrypt_ecc driver_ecc = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.alloc_publickey = do_allocate_publickey,\n\t.free_publickey = do_free_publickey,\n\t.gen_keypair = do_gen_keypair,\n\t.sign = do_sign,\n\t.verify = do_verify,\n\t.shared_secret = do_shared_secret,\n};\n\nenum caam_status caam_ecc_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base))\n\t\tif (drvcrypt_register_ecc(&driver_ecc) == TEE_SUCCESS)\n\t\t\tretstatus = CAAM_NO_ERROR;\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright 2018-2021 NXP\n *\n * CAAM RSA manager.\n * Implementation of RSA functions\n */\n#include <caam_acipher.h>\n#include <caam_common.h>\n#include <caam_hal_ctrl.h>\n#include <caam_io.h>\n#include <caam_jr.h>\n#include <caam_utils_mem.h>\n#include <caam_utils_status.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <drvcrypt_math.h>\n#include <mm/core_memprot.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n\n#include \"local.h\"\n\n/*\n * Definition of the maximum bits of Exponent e\n * Refer to sp800-56b\n */\n#define MAX_BITS_EXP_E 256\n\n/*\n * Define the maximum number of entries in a descriptor\n * function of the encrypt/decrypt and private key format\n */\n#ifdef CFG_CAAM_64BIT\n#define MAX_DESC_ENC   (8 + 4)\n#define MAX_DESC_DEC_1 (7 + 2 + 4)\n#define MAX_DESC_DEC_2 (11 + 2 + 7)\n#define MAX_DESC_DEC_3 (13 + 2 + 10)\n/* Define the maximum number of entries in the RSA Finish Key descriptor */\n#define MAX_DESC_KEY_FINISH 24\n#else\n#define MAX_DESC_ENC\t    8\n#define MAX_DESC_DEC_1\t    (7 + 2)\n#define MAX_DESC_DEC_2\t    (11 + 2)\n#define MAX_DESC_DEC_3\t    (13 + 2)\n/* Define the maximum number of entries in the RSA Finish Key descriptor */\n#define MAX_DESC_KEY_FINISH 15\n#endif /* CFG_CAAM_64BIT */\n\nstatic TEE_Result do_caam_encrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation);\nstatic TEE_Result do_caam_decrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation);\n\n/*\n * Definition of the local RSA keypair\n *   Public Key Format: (n, e)\n *   Private Key Format #1: (n, d)\n *   Private Key Format #2: (p, q, d)\n *   Private Key Format #3: (p, q, dp, dq, qp)\n */\nstruct caam_rsa_keypair {\n\tuint8_t format;\t   /* Define the Private Key Format (1, 2 or 3) */\n\tstruct caambuf n;  /* Modulus [n = p * q] */\n\tstruct caambuf e;  /* Public Exponent 65537 <= e < 2^256 */\n\tstruct caambuf d;  /* Private Exponent [d = 1/e mod LCM(p-1, q-1)] */\n\tstruct caambuf p;  /* Private Prime p */\n\tstruct caambuf q;  /* Private Prime q */\n\tstruct caambuf dp; /* Private [dp = d mod (p-1)] */\n\tstruct caambuf dq; /* Private [dq = d mod (q-1)] */\n\tstruct caambuf qp; /* Private [qp = 1/q mod p] */\n};\n\n#define RSA_PRIVATE_KEY_FORMAT_1 1\n#define RSA_PRIVATE_KEY_FORMAT_2 2\n#define RSA_PRIVATE_KEY_FORMAT_3 3\n\n/* CAAM Era version */\nstatic uint8_t caam_era;\n\n/*\n * Free RSA keypair\n *\n * @key  RSA keypair\n */\nstatic void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(&key->e);\n\tcrypto_bignum_free(&key->d);\n\tcrypto_bignum_free(&key->n);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->q);\n\tcrypto_bignum_free(&key->qp);\n\tcrypto_bignum_free(&key->dp);\n\tcrypto_bignum_free(&key->dq);\n}\n\n/*\n * Free local caam RSA keypair\n *\n * @key  caam RSA keypair\n */\nstatic void do_keypair_free(struct caam_rsa_keypair *key)\n{\n\tcaam_free_buf(&key->e);\n\tcaam_free_buf(&key->n);\n\tcaam_free_buf(&key->d);\n\n\tif (key->format > RSA_PRIVATE_KEY_FORMAT_1 && key->p.data) {\n\t\tkey->p.length += key->q.length;\n\t\tcaam_free_buf(&key->p);\n\t}\n\n\tif (key->format > RSA_PRIVATE_KEY_FORMAT_2 && key->dp.data) {\n\t\tkey->dp.length += key->dq.length + key->qp.length;\n\t\tcaam_free_buf(&key->dp);\n\t}\n}\n\n/*\n * Convert Crypto RSA Key to local RSA Public Key\n * Ensure Key is push in physical memory\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypub_conv(struct caam_rsa_keypair *outkey,\n\t\t\t\t       const struct rsa_public_key *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\n\tRSA_TRACE(\"RSA Convert Public Key size N=%zu\",\n\t\t  crypto_bignum_num_bytes(inkey->n));\n\n\tretstatus = caam_calloc_align_buf(&outkey->e,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->e));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\tgoto exit_conv;\n\n\tcrypto_bignum_bn2bin(inkey->e, outkey->e.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->e.data, outkey->e.length);\n\n\tretstatus = caam_calloc_align_buf(&outkey->n,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->n));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\tgoto exit_conv;\n\n\tcrypto_bignum_bn2bin(inkey->n, outkey->n.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->n.data, outkey->n.length);\n\n\treturn CAAM_NO_ERROR;\n\nexit_conv:\n\tdo_keypair_free(outkey);\n\n\treturn CAAM_OUT_MEMORY;\n}\n\n/*\n * Convert Crypto RSA Key additional fields of the key format #3\n * Optional fields (dp, dq, qp)\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv_f3(struct caam_rsa_keypair *outkey,\n\t\t\t\t\t   const struct rsa_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tsize_t size_p = 0;\n\tsize_t size_q = 0;\n\tsize_t size_dp = 0;\n\tsize_t size_dq = 0;\n\tsize_t size_qp = 0;\n\n\tsize_p = outkey->p.length;\n\tsize_q = outkey->q.length;\n\tsize_dp = crypto_bignum_num_bytes(inkey->dp);\n\tsize_dq = crypto_bignum_num_bytes(inkey->dq);\n\tsize_qp = crypto_bignum_num_bytes(inkey->qp);\n\n\t/* Check that dp, dq and qp size not exceed p and q size */\n\tif (size_dp > size_p || size_dq > size_q || size_qp > size_p)\n\t\treturn CAAM_FAILURE;\n\n\t/*\n\t * If one of the parameters dp, dq or qp are not filled,\n\t * returns immediately. This is not an error.\n\t */\n\tif (!size_dp || !size_dq || !size_qp)\n\t\treturn CAAM_NO_ERROR;\n\n\t/*\n\t * CAAM is assuming that:\n\t *    - dp and dq are same size as p\n\t *    - dq same size as q\n\t *\n\t * Because calculation of dp, dq and qp can be less\n\t * than above assumption, force the dp, dq and qp\n\t * buffer size.\n\t */\n\t/* Allocate one buffer for the 3 fields */\n\tretstatus =\n\t\tcaam_calloc_align_buf(&outkey->dp, size_p + size_q + size_p);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn CAAM_OUT_MEMORY;\n\n\t/* Field dp */\n\toutkey->dp.length = size_p;\n\n\t/*\n\t * Ensure buffer is copied starting with 0's\n\t * if size_dp != size_p\n\t */\n\tcrypto_bignum_bn2bin(inkey->dp, outkey->dp.data + size_p - size_dp);\n\n\t/* Field dq */\n\toutkey->dq.data = outkey->dp.data + size_p;\n\toutkey->dq.length = size_q;\n\toutkey->dq.paddr = outkey->dp.paddr + size_p;\n\n\t/*\n\t * Ensure buffer is copied starting with 0's\n\t * if size_dq != size_q\n\t */\n\tcrypto_bignum_bn2bin(inkey->dq, outkey->dq.data + size_q - size_dq);\n\n\t/* Field qp */\n\toutkey->qp.data = outkey->dq.data + size_q;\n\toutkey->qp.length = size_p;\n\toutkey->qp.paddr = outkey->dq.paddr + size_q;\n\n\t/*\n\t * Ensure buffer is copied starting with 0's\n\t * if size_qp != size_p\n\t */\n\tcrypto_bignum_bn2bin(inkey->qp, outkey->qp.data + size_p - size_qp);\n\n\t/* Push fields value to the physical memory */\n\tcache_operation(TEE_CACHECLEAN, outkey->dp.data,\n\t\t\toutkey->dp.length + outkey->dq.length +\n\t\t\t\toutkey->qp.length);\n\n\toutkey->format = RSA_PRIVATE_KEY_FORMAT_3;\n\n\treturn CAAM_NO_ERROR;\n}\n\n/*\n * Convert Crypto RSA Key additional fields of the key format #2\n * Optional fields (p, q)\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv_f2(struct caam_rsa_keypair *outkey,\n\t\t\t\t\t   const struct rsa_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tsize_t size_p = 0;\n\tsize_t size_q = 0;\n\n\tsize_p = crypto_bignum_num_bytes(inkey->p);\n\tsize_q = crypto_bignum_num_bytes(inkey->q);\n\n\t/*\n\t * If the Prime P or Prime Q are not filled, returns\n\t * immediately. This is not an error.\n\t */\n\tif (size_p || !size_q)\n\t\treturn CAAM_NO_ERROR;\n\n\t/* Allocate one buffer for both */\n\tretstatus = caam_calloc_align_buf(&outkey->p, size_p + size_q);\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn CAAM_OUT_MEMORY;\n\n\t/* Field Prime p */\n\toutkey->p.length = size_p;\n\tcrypto_bignum_bn2bin(inkey->p, outkey->p.data);\n\n\t/* Field Prime q */\n\toutkey->q.data = outkey->p.data + size_p;\n\toutkey->q.length = size_q;\n\toutkey->q.paddr = outkey->p.paddr + size_p;\n\n\tcrypto_bignum_bn2bin(inkey->q, outkey->q.data);\n\n\t/* Push fields value to the physical memory */\n\tcache_operation(TEE_CACHECLEAN, outkey->p.data, size_p + size_q);\n\n\toutkey->format = RSA_PRIVATE_KEY_FORMAT_2;\n\n\tif (CFG_NXP_CAAM_RSA_KEY_FORMAT > RSA_PRIVATE_KEY_FORMAT_2) {\n\t\tretstatus = do_keypair_conv_f3(outkey, inkey);\n\t\tRSA_TRACE(\"do_keypair_conv_f3 returned 0x%\" PRIx32, retstatus);\n\t}\n\n\treturn retstatus;\n}\n\n/*\n * Convert Crypto RSA Key to local RSA Keypair Key\n * Ensure Key is push in physical memory\n * Don't convert the exponent e not used in decrytion\n *\n * @outkey   [out] Output keypair in local format\n * @inkey    Input key in TEE Crypto format\n */\nstatic enum caam_status do_keypair_conv(struct caam_rsa_keypair *outkey,\n\t\t\t\t\tconst struct rsa_keypair *inkey)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\n\tRSA_TRACE(\"RSA Convert Keypair size N=%zu\",\n\t\t  crypto_bignum_num_bytes(inkey->n));\n\n\t/* Mandatory fields are n and d => Private Key Format #1 */\n\tretstatus = caam_calloc_align_buf(&outkey->n,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->n));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->n, outkey->n.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->n.data, outkey->n.length);\n\n\tretstatus = caam_calloc_align_buf(&outkey->d,\n\t\t\t\t\t  crypto_bignum_num_bytes(inkey->d));\n\tif (retstatus != CAAM_NO_ERROR)\n\t\treturn retstatus;\n\n\tcrypto_bignum_bn2bin(inkey->d, outkey->d.data);\n\tcache_operation(TEE_CACHECLEAN, outkey->d.data, outkey->d.length);\n\n\toutkey->format = RSA_PRIVATE_KEY_FORMAT_1;\n\n\tif (CFG_NXP_CAAM_RSA_KEY_FORMAT > RSA_PRIVATE_KEY_FORMAT_1) {\n\t\tretstatus = do_keypair_conv_f2(outkey, inkey);\n\t\tRSA_TRACE(\"do_keypair_conv_f2 returned 0x%\" PRIx32, retstatus);\n\t}\n\n\treturn retstatus;\n}\n\n/*\n * Allocate a RSA keypair\n *\n * @key        Keypair\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_keypair(struct rsa_keypair *key, size_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\n\t/* Initialize all input key fields to 0 */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate the Public Exponent to maximum size */\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the Private Exponent [d = 1/e mod LCM(p-1, q-1)] */\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the Modulus (size_bits) [n = p * q] */\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the prime number p of size (size_bits / 2) */\n\tkey->p = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->p)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate the prime number q of size (size_bits / 2) */\n\tkey->q = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->q)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate dp (size_bits / 2) [d mod (p-1)] */\n\tkey->dp = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->dp)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate dq (size_bits / 2) [d mod (q-1)] */\n\tkey->dq = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->dq)\n\t\tgoto err_alloc_keypair;\n\n\t/* Allocate qp (size_bits / 2) [1/q mod p] */\n\tkey->qp = crypto_bignum_allocate(size_bits / 2);\n\tif (!key->qp)\n\t\tgoto err_alloc_keypair;\n\n\treturn TEE_SUCCESS;\n\nerr_alloc_keypair:\n\tRSA_TRACE(\"Allocation error\");\n\n\tdo_free_keypair(key);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Allocate a RSA public key\n *\n * @key        Public Key\n * @size_bits  Key size in bits\n */\nstatic TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\n\t/* Initialize all input key fields to 0 */\n\tmemset(key, 0, sizeof(*key));\n\n\t/* Allocate the Public Exponent to maximum size */\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\n\t/* Allocate the Modulus (size_bits) [n = p * q] */\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\n\treturn TEE_SUCCESS;\n\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\n\tcrypto_bignum_free(&key->e);\n\tcrypto_bignum_free(&key->n);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n/*\n * Free a RSA public key\n *\n * @key        Public Key\n */\nstatic void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(&key->e);\n\tcrypto_bignum_free(&key->n);\n}\n\n/*\n * Output the RSA keypair format 3 additional fields in bignumber object\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits\n */\nstatic TEE_Result gen_keypair_get_f3(struct rsa_keypair *key,\n\t\t\t\t     struct caam_rsa_keypair *genkey)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\n\tcache_operation(TEE_CACHEINVALIDATE, genkey->dp.data,\n\t\t\tgenkey->dp.length + genkey->dq.length +\n\t\t\t\tgenkey->qp.length);\n\n\tRSA_DUMPBUF(\"dp\", genkey->dp.data, genkey->dp.length);\n\tRSA_DUMPBUF(\"dq\", genkey->dq.data, genkey->dq.length);\n\tRSA_DUMPBUF(\"qp\", genkey->qp.data, genkey->qp.length);\n\n\tret = crypto_bignum_bin2bn(genkey->dp.data, genkey->dp.length, key->dp);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = crypto_bignum_bin2bn(genkey->dq.data, genkey->dq.length, key->dq);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = crypto_bignum_bin2bn(genkey->qp.data, genkey->qp.length, key->qp);\n\treturn ret;\n}\n\n/*\n * Output the RSA keypair format 2 additional fields in big number object\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits\n */\nstatic TEE_Result gen_keypair_get_f2(struct rsa_keypair *key,\n\t\t\t\t     struct caam_rsa_keypair *genkey)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\n\tcache_operation(TEE_CACHEINVALIDATE, genkey->p.data,\n\t\t\tgenkey->p.length + genkey->q.length);\n\n\tret = crypto_bignum_bin2bn(genkey->p.data, genkey->p.length, key->p);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = crypto_bignum_bin2bn(genkey->q.data, genkey->q.length, key->q);\n\n\tif (ret == TEE_SUCCESS && genkey->format > RSA_PRIVATE_KEY_FORMAT_2)\n\t\tret = gen_keypair_get_f3(key, genkey);\n\n\treturn ret;\n}\n\n/*\n * Generates a RSA keypair\n *\n * @key        [out] Keypair\n * @key_size   Key size in bits\n */\nstatic TEE_Result do_gen_keypair(struct rsa_keypair *key, size_t key_size)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_rsa_keypair genkey = { };\n\tsize_t size_d = 0;\n\tsize_t size_n = 0;\n\tsize_t size_d_gen = 0;\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = 0;\n\tuint32_t desclen = 0;\n\tstruct prime_data_rsa prime = { };\n\n\tRSA_TRACE(\"Generate Keypair of %zu bits\", key_size);\n\n\tgenkey.format = CFG_NXP_CAAM_RSA_KEY_FORMAT;\n\n\t/* Allocate the job used to prepare the operation */\n\tdesc = caam_calloc_desc(MAX_DESC_KEY_FINISH);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit_gen_keypair;\n\t}\n\n\t/* First allocate primes p and q in one buffer */\n\tretstatus = caam_calloc_align_buf(&genkey.p, key_size / 8);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\t/* Prepare q */\n\tgenkey.p.length /= 2;\n\tgenkey.q.data = genkey.p.data + genkey.p.length;\n\tgenkey.q.length = genkey.p.length;\n\tgenkey.q.paddr = genkey.p.paddr + genkey.p.length;\n\n\t/* Allocate Public exponent to a caam buffer */\n\tretstatus = caam_calloc_buf(&genkey.e, crypto_bignum_num_bytes(key->e));\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\t/*\n\t * Allocate d and n in one buffer.\n\t * Size of d is (key_size + 1) bits - Add a 32 bits word to\n\t * retrieve the length of d generated by CAAM RSA Finalize Key\n\t */\n\tsize_d = sizeof(uint32_t) + key_size / 8 + 1;\n\tsize_n = key_size / 8;\n\n\tretstatus = caam_calloc_align_buf(&genkey.d, size_d + size_n);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\tgenkey.d.length = size_d;\n\tgenkey.n.data = genkey.d.data + size_d;\n\tgenkey.n.length = size_n;\n\tgenkey.n.paddr = genkey.d.paddr + size_d;\n\n\tif (genkey.format > RSA_PRIVATE_KEY_FORMAT_2) {\n\t\t/* Allocate dp, dq and qp in one buffer */\n\t\tretstatus = caam_calloc_align_buf(&genkey.dp,\n\t\t\t\t\t\t  ((key_size / 8) / 2) * 3);\n\t\tif (retstatus != CAAM_NO_ERROR) {\n\t\t\tret = caam_status_to_tee_result(retstatus);\n\t\t\tgoto exit_gen_keypair;\n\t\t}\n\n\t\tgenkey.dp.length /= 3;\n\t\t/* Prepare dq and qp */\n\t\tgenkey.dq.data = genkey.dp.data + genkey.dp.length;\n\t\tgenkey.dq.length = genkey.dp.length;\n\t\tgenkey.dq.paddr = genkey.dp.paddr + genkey.dp.length;\n\n\t\tgenkey.qp.data = genkey.dq.data + genkey.dq.length;\n\t\tgenkey.qp.length = genkey.dq.length;\n\t\tgenkey.qp.paddr = genkey.dq.paddr + genkey.dq.length;\n\t}\n\n\tcrypto_bignum_bn2bin(key->e, genkey.e.data);\n\n\tprime.era = caam_era;\n\tprime.key_size = key_size;\n\tprime.e = &genkey.e;\n\tprime.p = &genkey.p;\n\tprime.q = &genkey.q;\n\n\t/* Generate prime p and q */\n\tretstatus = caam_prime_rsa_gen(&prime);\n\tRSA_TRACE(\"Generate Prime P and Q returned 0x%\" PRIx32, retstatus);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_gen_keypair;\n\t}\n\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\n\tcaam_desc_add_word(desc, 0);\n\tcaam_desc_add_word(desc, PDB_RSA_KEY_P_SIZE(genkey.p.length));\n\tcaam_desc_add_word(desc, PDB_RSA_KEY_N_SIZE(genkey.n.length) |\n\t\t\t\t\t PDB_RSA_KEY_E_SIZE(genkey.e.length));\n\n\tcaam_desc_add_ptr(desc, genkey.p.paddr);\n\tcaam_desc_add_ptr(desc, genkey.q.paddr);\n\tcaam_desc_add_ptr(desc, genkey.e.paddr);\n\tcaam_desc_add_ptr(desc, genkey.n.paddr);\n\tcaam_desc_add_ptr(desc, genkey.d.paddr + sizeof(uint32_t));\n\tcaam_desc_add_ptr(desc, genkey.d.paddr);\n\n\tif (genkey.format > RSA_PRIVATE_KEY_FORMAT_2) {\n\t\tcaam_desc_add_ptr(desc, genkey.dp.paddr);\n\t\tcaam_desc_add_ptr(desc, genkey.dq.paddr);\n\t\tcaam_desc_add_ptr(desc, genkey.qp.paddr);\n\t\tcaam_desc_add_word(desc, RSA_FINAL_KEY(ALL));\n\n\t\tcache_operation(TEE_CACHEFLUSH, genkey.dp.data,\n\t\t\t\tgenkey.dp.length + genkey.dq.length +\n\t\t\t\t\tgenkey.qp.length);\n\n\t} else {\n\t\tcaam_desc_add_word(desc, RSA_FINAL_KEY(N_D));\n\t}\n\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\n\tjobctx.desc = desc;\n\tRSA_DUMPDESC(desc);\n\n\tcache_operation(TEE_CACHECLEAN, genkey.e.data, genkey.e.length);\n\tcache_operation(TEE_CACHEFLUSH, genkey.p.data,\n\t\t\tgenkey.p.length + genkey.q.length);\n\tcache_operation(TEE_CACHEFLUSH, genkey.d.data,\n\t\t\tgenkey.d.length + genkey.n.length);\n\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\tcache_operation(TEE_CACHEINVALIDATE, genkey.d.data,\n\t\t\t\tgenkey.d.length + genkey.n.length);\n\n\t\tsize_d_gen = caam_read_val32(genkey.d.data);\n\t\tRSA_TRACE(\"D size %zu\", size_d_gen);\n\t\tRSA_DUMPBUF(\"N\", genkey.n.data, genkey.n.length);\n\t\tRSA_DUMPBUF(\"D\", genkey.d.data + sizeof(uint32_t), size_d_gen);\n\n\t\tret = crypto_bignum_bin2bn(genkey.n.data, genkey.n.length,\n\t\t\t\t\t   key->n);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto exit_gen_keypair;\n\n\t\tret = crypto_bignum_bin2bn(genkey.d.data + sizeof(uint32_t),\n\t\t\t\t\t   size_d_gen, key->d);\n\t\tif (ret != TEE_SUCCESS)\n\t\t\tgoto exit_gen_keypair;\n\n\t\tif (genkey.format > RSA_PRIVATE_KEY_FORMAT_1)\n\t\t\tret = gen_keypair_get_f2(key, &genkey);\n\t} else {\n\t\tRSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nexit_gen_keypair:\n\tgenkey.d.length += genkey.n.length;\n\tgenkey.n.data = NULL;\n\tdo_keypair_free(&genkey);\n\n\tcaam_free_desc(&desc);\n\n\treturn ret;\n}\n\n/*\n * RSA EME-OAEP Decoding operation\n * Refer the chapter 7.1.2 Decryption operation of pkcs-1v2-1 specification\n *\n * @rsa_data  [in/out] RSA Data to encode\n */\nstatic TEE_Result do_oaep_decoding(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caambuf DB = { };\n\tstruct caambuf lHash = { };\n\tstruct caambuf seed = { };\n\tstruct caambuf dbMask = { };\n\tstruct caambuf maskedDB = { };\n\tstruct caambuf maskedSeed = { };\n\tstruct caambuf EM = { };\n\tsize_t db_size = 0;\n\tsize_t b01_idx = 0;\n\tsize_t db_len = 0;\n\tstruct drvcrypt_rsa_mgf mgf_data = { };\n\tstruct drvcrypt_rsa_ed dec_data = { };\n\tstruct drvcrypt_mod_op mod_op = { };\n\n\tRSA_TRACE(\"RSA OAEP Decoding\");\n\n\t/*\n\t * First Decryption of the Cipher to a EM of modulus size\n\t */\n\tretstatus = caam_calloc_align_buf(&EM, rsa_data->key.n_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tmemcpy(&dec_data, rsa_data, sizeof(dec_data));\n\tdec_data.message.data = EM.data;\n\tdec_data.message.length = EM.length;\n\n\tret = do_caam_decrypt(&dec_data, RSA_DECRYPT(NO));\n\n\tRSA_DUMPBUF(\"EM\", EM.data, EM.length);\n\n\t/*\n\t * DB = lHash' || PS || 0x01 || M\n\t * DB length = k - hLen - 1\n\t *\n\t * PS is a 0's buffer of length h - mLen - 2hLen - 2\n\t *\n\t *  k    is the key modulus length\n\t *  hLen is the Hash digest length\n\t *  mLen is the input RSA message length\n\t */\n\t/* Calculate the DB size */\n\tdb_size = rsa_data->key.n_size - rsa_data->digest_size - 1;\n\tRSA_TRACE(\"DB is %zu bytes\", db_size);\n\n\t/* Allocate the DB buffer */\n\tretstatus = caam_calloc_align_buf(&DB, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/*\n\t * Step a\n\t * Generate the lHash\n\t */\n\t/* Allocate the lHash buffer */\n\tretstatus = caam_calloc_align_buf(&lHash, rsa_data->digest_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tRSA_TRACE(\"Hash the RSA Label of %zu bytes\", rsa_data->label.length);\n\tret = tee_hash_createdigest(rsa_data->hash_algo, rsa_data->label.data,\n\t\t\t\t    rsa_data->label.length, lHash.data,\n\t\t\t\t    lHash.length);\n\tRSA_TRACE(\"Hash the RSA Label returned 0x%08\" PRIx32, ret);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_decrypt;\n\n\tRSA_DUMPBUF(\"lHash\", lHash.data, lHash.length);\n\n\t/* Allocate the seed buffer */\n\tretstatus = caam_calloc_align_buf(&seed, rsa_data->digest_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/* Allocate the dbMask buffer */\n\tretstatus = caam_calloc_align_buf(&dbMask, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/*\n\t * Step b\n\t * Split the EM string\n\t * EM = Y || maskedSeed || maskedDB\n\t *\n\t * Where:\n\t *   Y          size = 1 byte\n\t *   maskedSeed size = hLen\n\t *   maskedDB   size = k - hLen - 1 bytes\n\t *\n\t *  k    is the key modulus length\n\t *  hLen is the Hash digest length\n\t *  mLen is the input RSA message length\n\t *\n\t *  Note Y should have been remove during the\n\t */\n\tmaskedSeed.data = &EM.data[1];\n\tmaskedSeed.length = rsa_data->digest_size;\n\tmaskedSeed.paddr = EM.paddr + sizeof(uint8_t);\n\n\tmaskedDB.data = &EM.data[1 + rsa_data->digest_size];\n\tmaskedDB.length = dbMask.length;\n\tmaskedDB.paddr = EM.paddr + sizeof(uint8_t) + rsa_data->digest_size;\n\n\t/*\n\t * Step c\n\t * Generate a Mask of the maskedDB\n\t * seedMask = MGF(maskedDB, k - hLen - 1)\n\t *\n\t * Note: Use same buffer for seed and seedMask\n\t */\n\tmgf_data.hash_algo = rsa_data->hash_algo;\n\tmgf_data.digest_size = rsa_data->digest_size;\n\tmgf_data.seed.data = maskedDB.data;\n\tmgf_data.seed.length = maskedDB.length;\n\tmgf_data.mask.data = seed.data;\n\tmgf_data.mask.length = seed.length;\n\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_decrypt;\n\n\t/*\n\t * Step d\n\t * seed = maskedSeed xor seedMask\n\t *\n\t * Note: Use same buffer for seed and seedMask\n\t */\n\tmod_op.n.length = seed.length;\n\tmod_op.a.data = maskedSeed.data;\n\tmod_op.a.length = maskedSeed.length;\n\tmod_op.b.data = seed.data;\n\tmod_op.b.length = seed.length;\n\tmod_op.result.data = seed.data;\n\tmod_op.result.length = seed.length;\n\n\tretstatus = drvcrypt_xor_mod_n(&mod_op);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tRSA_DUMPBUF(\"Seed\", seed.data, seed.length);\n\n\t/*\n\t * Step e\n\t * Generate a Mask of the seed value\n\t * dbMask = MGF(seed, k - hLen - 1)\n\t */\n\tmgf_data.seed.data = seed.data;\n\tmgf_data.seed.length = seed.length;\n\tmgf_data.mask.data = dbMask.data;\n\tmgf_data.mask.length = dbMask.length;\n\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_decrypt;\n\n\t/*\n\t * Step f\n\t * DB = maskedDB xor dbMask\n\t */\n\tmod_op.n.length = DB.length;\n\tmod_op.a.data = maskedDB.data;\n\tmod_op.a.length = maskedDB.length;\n\tmod_op.b.data = dbMask.data;\n\tmod_op.b.length = dbMask.length;\n\tmod_op.result.data = DB.data;\n\tmod_op.result.length = DB.length;\n\n\tretstatus = drvcrypt_xor_mod_n(&mod_op);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tRSA_DUMPBUF(\"DB\", DB.data, DB.length);\n\n\t/*\n\t * Step g\n\t * Check the DB generated\n\t * DB = lHash' || PS || 0x01 || M\n\t *\n\t * Error if:\n\t *   - lHash' != lHash (First step - Hash the Label)\n\t *   - byte 0x01 between PS and M is not present\n\t */\n\t/* Check Hash values */\n\tif (memcmp(DB.data, lHash.data, lHash.length)) {\n\t\tRSA_TRACE(\"Hash error\");\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\t/* Find the byte 0x01 separating PS and M */\n\tfor (b01_idx = rsa_data->digest_size;\n\t     b01_idx < db_size && !DB.data[b01_idx]; b01_idx++)\n\t\t;\n\n\tif (b01_idx == db_size) {\n\t\tRSA_TRACE(\"byte 0x01 not present\");\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\tdb_len = DB.length - b01_idx - 1;\n\n\tif (rsa_data->message.length < db_len) {\n\t\trsa_data->message.length = db_len;\n\t\tret = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto exit_oaep_decrypt;\n\t}\n\n\trsa_data->message.length = db_len;\n\tmemcpy(rsa_data->message.data, &DB.data[b01_idx + 1],\n\t       rsa_data->message.length);\n\n\tRSA_DUMPBUF(\"Message decrypted\", rsa_data->message.data,\n\t\t    rsa_data->message.length);\n\tret = TEE_SUCCESS;\n\nexit_oaep_decrypt:\n\tcaam_free_buf(&EM);\n\tcaam_free_buf(&DB);\n\tcaam_free_buf(&seed);\n\tcaam_free_buf(&dbMask);\n\tcaam_free_buf(&lHash);\n\n\treturn ret;\n}\n\n/*\n * RSA EME-OAEP Encoding operation\n * Refer the chapter 7.1.1 Encryption operation of pkcs-1v2-1 specification\n *\n * @rsa_data  [int/out] RSA Data to encode\n */\nstatic TEE_Result do_oaep_encoding(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus;\n\tstruct caambuf DB = { };\n\tstruct caambuf lHash = { };\n\tstruct caambuf seed = { };\n\tstruct caambuf dbMask = { };\n\tstruct caambuf maskedDB = { };\n\tstruct caambuf maskedSeed = { };\n\tstruct caambuf EM = { };\n\tsize_t db_size = 0;\n\tsize_t ps_size = 0;\n\tstruct drvcrypt_rsa_mgf mgf_data = { };\n\tstruct drvcrypt_rsa_ed enc_data = { };\n\tstruct drvcrypt_mod_op mod_op = { };\n\n\tRSA_TRACE(\"RSA OAEP Encoding\");\n\n\t/*\n\t * DB = lHash || PS || 0x01 || M\n\t * DB length = k - hLen - 1\n\t *\n\t * PS is a 0's buffer of length h - mLen - 2hLen - 2\n\t *\n\t *  k    is the key modulus length\n\t *  hLen is the Hash digest length\n\t *  mLen is the input RSA message length\n\t */\n\t/* Calculate the DB size */\n\tdb_size = rsa_data->key.n_size - rsa_data->digest_size - 1;\n\tRSA_TRACE(\"DB is %zu bytes\", db_size);\n\n\t/* Allocate the DB buffer */\n\tretstatus = caam_calloc_align_buf(&DB, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\t/*\n\t * Step a\n\t * Generate the lHash\n\t */\n\tlHash.length = rsa_data->digest_size;\n\tlHash.data = DB.data;\n\n\tRSA_TRACE(\"Hash the RSA Label of %zu bytes\", rsa_data->label.length);\n\tret = tee_hash_createdigest(rsa_data->hash_algo, rsa_data->label.data,\n\t\t\t\t    rsa_data->label.length, lHash.data,\n\t\t\t\t    lHash.length);\n\tRSA_TRACE(\"Hash the RSA Label returned 0x%08\" PRIx32, ret);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\tRSA_DUMPBUF(\"lHash\", lHash.data, lHash.length);\n\n\t/*\n\t * Step b\n\t * Add PS 0's\n\t * Note: DB is already filled with 0's at the allocation\n\t */\n\tps_size = rsa_data->key.n_size - rsa_data->message.length -\n\t\t  2 * rsa_data->digest_size - 2;\n\tRSA_TRACE(\"PS is %zu bytes\", ps_size);\n\n\t/*\n\t * Step c\n\t * Set the value 0x01 after the lHash and the PS\n\t * Concatenate result with input message\n\t */\n\tDB.data[lHash.length + ps_size] = 0x01;\n\tmemcpy(&DB.data[lHash.length + ps_size + 1], rsa_data->message.data,\n\t       rsa_data->message.length);\n\n\tRSA_DUMPBUF(\"DB\", DB.data, DB.length);\n\n\t/*\n\t * Step d\n\t * Generate a random seed of hLen\n\t */\n\t/* Allocate the seed buffer */\n\tretstatus = caam_calloc_align_buf(&seed, rsa_data->digest_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\t/* Allocate the dbMask buffer */\n\tretstatus = caam_calloc_align_buf(&dbMask, db_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\tret = crypto_rng_read(seed.data, seed.length);\n\tRSA_TRACE(\"Get seed of %zu bytes (ret = 0x%08\" PRIx32 \")\", seed.length,\n\t\t  ret);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\tRSA_DUMPBUF(\"Seed\", seed.data, seed.length);\n\n\t/*\n\t * Step e\n\t * Generate a Mask of the seed value\n\t * dbMask = MGF(seed, k - hLen - 1)\n\t */\n\tmgf_data.hash_algo = rsa_data->hash_algo;\n\tmgf_data.digest_size = rsa_data->digest_size;\n\tmgf_data.seed.data = seed.data;\n\tmgf_data.seed.length = seed.length;\n\tmgf_data.mask.data = dbMask.data;\n\tmgf_data.mask.length = dbMask.length;\n\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\t/*\n\t * Step f\n\t * maskedDB = DB xor dbMask\n\t */\n\tretstatus = caam_calloc_align_buf(&EM, rsa_data->key.n_size);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_oaep_encrypt;\n\t}\n\n\tmaskedDB.data = &EM.data[1 + rsa_data->digest_size];\n\tmaskedDB.length = dbMask.length;\n\tmaskedDB.paddr = EM.paddr + sizeof(uint8_t) + rsa_data->digest_size;\n\n\tmod_op.n.length = maskedDB.length;\n\tmod_op.a.data = DB.data;\n\tmod_op.a.length = DB.length;\n\tmod_op.b.data = dbMask.data;\n\tmod_op.b.length = dbMask.length;\n\tmod_op.result.data = maskedDB.data;\n\tmod_op.result.length = maskedDB.length;\n\n\tret = drvcrypt_xor_mod_n(&mod_op);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\t/*\n\t * Step g\n\t * Generate a Mask of the maskedDB\n\t * seedMask = MGF(maskedDB, hLen)\n\t *\n\t * Note: Use same buffer for seedMask and maskedSeed\n\t */\n\tmaskedSeed.data = &EM.data[1];\n\tmaskedSeed.length = rsa_data->digest_size;\n\tmaskedSeed.paddr = EM.paddr + sizeof(uint8_t);\n\n\tmgf_data.seed.data = maskedDB.data;\n\tmgf_data.seed.length = maskedDB.length;\n\tmgf_data.mask.data = maskedSeed.data;\n\tmgf_data.mask.length = maskedSeed.length;\n\tret = rsa_data->mgf(&mgf_data);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\t/*\n\t * Step h\n\t * maskedSeed = seed xor seedMask\n\t */\n\tmod_op.n.length = maskedSeed.length;\n\tmod_op.a.data = seed.data;\n\tmod_op.a.length = seed.length;\n\tmod_op.b.data = maskedSeed.data;\n\tmod_op.b.length = maskedSeed.length;\n\tmod_op.result.data = maskedSeed.data;\n\tmod_op.result.length = maskedSeed.length;\n\n\tret = drvcrypt_xor_mod_n(&mod_op);\n\tif (ret != TEE_SUCCESS)\n\t\tgoto exit_oaep_encrypt;\n\n\tRSA_DUMPBUF(\"EM\", EM.data, EM.length);\n\n\t/*\n\t * Last Encryption of the EM of modulus size to Cipher\n\t */\n\tmemcpy(&enc_data, rsa_data, sizeof(enc_data));\n\n\tenc_data.message.data = EM.data;\n\tenc_data.message.length = EM.length;\n\n\tret = do_caam_encrypt(&enc_data, RSA_ENCRYPT(NO));\n\nexit_oaep_encrypt:\n\tcaam_free_buf(&DB);\n\tcaam_free_buf(&seed);\n\tcaam_free_buf(&dbMask);\n\tcaam_free_buf(&EM);\n\n\treturn ret;\n}\n\n/*\n * CAAM RSA Encryption of the input message to a cipher\n *\n * @rsa_data   [in/out] RSA Data to encrypt\n * @operation  CAAM RSA Encryption operation\n */\nstatic TEE_Result do_caam_encrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_rsa_keypair key = { };\n\tstruct caamdmaobj msg = { };\n\tstruct caamdmaobj cipher = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tuint32_t pdb_sgt_flags = 0;\n\n\tRSA_TRACE(\"RSA Encrypt mode %d\", rsa_data->rsa_id);\n\n\t/* Allocate the job descriptor */\n\tdesc = caam_calloc_desc(MAX_DESC_ENC);\n\tif (!desc) {\n\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit_encrypt;\n\t}\n\n\t/*\n\t * Convert TEE rsa key type to CAAM rsa key type\n\t * Push key value to memory\n\t */\n\tretstatus = do_keypub_conv(&key, rsa_data->key.key);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_encrypt;\n\t}\n\n\t/*\n\t * ReAllocate the cipher result buffer with a maximum size\n\t * of the Key Modulus's size (N) if not cache aligned\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&cipher, rsa_data->cipher.data,\n\t\t\t\t\trsa_data->cipher.length, key.n.length);\n\tif (ret)\n\t\tgoto exit_encrypt;\n\n\tif (cipher.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_ENC_SGT_G;\n\n\tcaam_dmaobj_cache_push(&cipher);\n\n\t/* Prepare the input message CAAM descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&msg, rsa_data->message.data,\n\t\t\t\t       rsa_data->message.length);\n\tif (ret)\n\t\tgoto exit_encrypt;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_ENC_SGT_F;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\tcaam_desc_add_word(desc, PDB_RSA_ENC_E_SIZE(key.e.length) |\n\t\t\t\t\t PDB_RSA_ENC_N_SIZE(key.n.length) |\n\t\t\t\t\t pdb_sgt_flags);\n\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\tcaam_desc_add_ptr(desc, key.n.paddr);\n\tcaam_desc_add_ptr(desc, key.e.paddr);\n\tcaam_desc_add_word(desc, PDB_RSA_ENC_F_SIZE(rsa_data->message.length));\n\tcaam_desc_add_word(desc, operation);\n\n\t/* Set the descriptor Header with length */\n\tdesclen = caam_desc_get_len(desc);\n\tcaam_desc_update_hdr(desc, DESC_HEADER_IDX(desclen, desclen - 1));\n\tRSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus == CAAM_NO_ERROR) {\n\t\trsa_data->cipher.length = caam_dmaobj_copy_to_orig(&cipher);\n\n\t\tRSA_DUMPBUF(\"Output\", rsa_data->cipher.data,\n\t\t\t    rsa_data->cipher.length);\n\t\tret = caam_status_to_tee_result(retstatus);\n\t} else {\n\t\tRSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t}\n\nexit_encrypt:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&key);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&cipher);\n\n\treturn ret;\n}\n\n/*\n * CAAM RSA Decryption of the input cipher to a message\n *\n * @rsa_data   [in/out] RSA Data to decrypt\n * @operation  CAAM RSA Decryption operation\n */\nstatic TEE_Result do_caam_decrypt(struct drvcrypt_rsa_ed *rsa_data,\n\t\t\t\t  uint32_t operation)\n{\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tstruct caam_rsa_keypair key = { };\n\tstruct caamdmaobj cipher = { };\n\tstruct caamdmaobj msg = { };\n\tstruct caam_jobctx jobctx = { };\n\tuint32_t *desc = NULL;\n\tuint32_t desclen = 0;\n\tuint32_t pdb_sgt_flags = 0;\n\tstruct caambuf size_msg = { };\n\tstruct caambuf tmp = { };\n\n\tRSA_TRACE(\"RSA Decrypt mode %d\", rsa_data->rsa_id);\n\n\t/*\n\t * Convert TEE rsa key type to CAAM rsa key type\n\t * Push key value to memory\n\t */\n\tretstatus = do_keypair_conv(&key, rsa_data->key.key);\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tRSA_TRACE(\"do_keypair_conv returned 0x%\" PRIx32, retstatus);\n\t\tret = caam_status_to_tee_result(retstatus);\n\t\tgoto exit_decrypt;\n\t}\n\n\t/*\n\t * Allocate the temporary result buffer with a maximum size\n\t * of the Key Modulus's size (N)\n\t */\n\tret = caam_dmaobj_output_sgtbuf(&msg, rsa_data->message.data,\n\t\t\t\t\trsa_data->message.length, key.n.length);\n\n\tif (ret)\n\t\tgoto exit_decrypt;\n\n\tif (msg.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_DEC_SGT_F;\n\n\tcaam_dmaobj_cache_push(&msg);\n\n\t/* Allocate the returned computed size when PKCS V1.5 */\n\tif (operation == RSA_DECRYPT(PKCS_V1_5)) {\n\t\tretstatus = caam_alloc_align_buf(&size_msg, 4);\n\t\tif (retstatus != CAAM_NO_ERROR)\n\t\t\tgoto exit_decrypt;\n\n\t\tcache_operation(TEE_CACHEFLUSH, size_msg.data, size_msg.length);\n\t}\n\n\t/* Prepare the input cipher CAAM descriptor entry */\n\tret = caam_dmaobj_input_sgtbuf(&cipher, rsa_data->cipher.data,\n\t\t\t\t       rsa_data->cipher.length);\n\n\tif (cipher.sgtbuf.sgt_type)\n\t\tpdb_sgt_flags |= PDB_RSA_DEC_SGT_G;\n\n\tcaam_dmaobj_cache_push(&cipher);\n\n\t/* Allocate the job descriptor function of the Private key format */\n\tswitch (key.format) {\n\tcase RSA_PRIVATE_KEY_FORMAT_1:\n\t\tdesc = caam_calloc_desc(MAX_DESC_DEC_1);\n\t\tif (!desc) {\n\t\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto exit_decrypt;\n\t\t}\n\t\tbreak;\n\n\tcase RSA_PRIVATE_KEY_FORMAT_2:\n\tcase RSA_PRIVATE_KEY_FORMAT_3:\n\t\tif (key.format == RSA_PRIVATE_KEY_FORMAT_2)\n\t\t\tdesc = caam_calloc_desc(MAX_DESC_DEC_2);\n\t\telse\n\t\t\tdesc = caam_calloc_desc(MAX_DESC_DEC_3);\n\n\t\tif (!desc) {\n\t\t\tret = TEE_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto exit_decrypt;\n\t\t}\n\t\t/* Allocate temporary buffers used by the CAAM */\n\t\tretstatus =\n\t\t\tcaam_alloc_align_buf(&tmp, key.p.length + key.q.length);\n\t\tif (retstatus != CAAM_NO_ERROR) {\n\t\t\tret = caam_status_to_tee_result(retstatus);\n\t\t\tgoto exit_decrypt;\n\t\t}\n\n\t\tcache_operation(TEE_CACHEFLUSH, tmp.data, tmp.length);\n\t\tbreak;\n\n\tdefault:\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto exit_decrypt;\n\t}\n\n\tcaam_desc_init(desc);\n\tcaam_desc_add_word(desc, DESC_HEADER(0));\n\n\t/* Build the descriptor function of the Private Key format */\n\tswitch (key.format) {\n\tcase RSA_PRIVATE_KEY_FORMAT_1:\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_D_SIZE(key.d.length) |\n\t\t\t\t\t   PDB_RSA_DEC_N_SIZE(key.n.length) |\n\t\t\t\t\t   pdb_sgt_flags);\n\t\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, key.n.paddr);\n\t\tcaam_desc_add_ptr(desc, key.d.paddr);\n\n\t\tbreak;\n\n\tcase RSA_PRIVATE_KEY_FORMAT_2:\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_D_SIZE(key.d.length) |\n\t\t\t\t\t   PDB_RSA_DEC_N_SIZE(key.n.length) |\n\t\t\t\t\t   pdb_sgt_flags);\n\t\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, key.d.paddr);\n\t\tcaam_desc_add_ptr(desc, key.p.paddr);\n\t\tcaam_desc_add_ptr(desc, key.q.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr + key.p.length);\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_Q_SIZE(key.q.length) |\n\t\t\t\t\t   PDB_RSA_DEC_P_SIZE(key.p.length));\n\t\tbreak;\n\n\tcase RSA_PRIVATE_KEY_FORMAT_3:\n\t\tcaam_desc_add_word(desc, PDB_RSA_DEC_N_SIZE(key.n.length) |\n\t\t\t\t\t\t pdb_sgt_flags);\n\t\tcaam_desc_add_ptr(desc, cipher.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, msg.sgtbuf.paddr);\n\t\tcaam_desc_add_ptr(desc, key.qp.paddr);\n\t\tcaam_desc_add_ptr(desc, key.p.paddr);\n\t\tcaam_desc_add_ptr(desc, key.q.paddr);\n\t\tcaam_desc_add_ptr(desc, key.dp.paddr);\n\t\tcaam_desc_add_ptr(desc, key.dq.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr);\n\t\tcaam_desc_add_ptr(desc, tmp.paddr + key.p.length);\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   PDB_RSA_DEC_Q_SIZE(key.q.length) |\n\t\t\t\t\t   PDB_RSA_DEC_P_SIZE(key.p.length));\n\t\tbreak;\n\n\tdefault:\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto exit_decrypt;\n\t}\n\n\t/* Set the Decryption operation type */\n\tcaam_desc_add_word(desc, operation | PROT_RSA_DEC_KEYFORM(key.format));\n\n\tif (operation == RSA_DECRYPT(PKCS_V1_5)) {\n\t\t/* Get the PPKCS1 v1.5 Message length generated */\n\t\tcaam_desc_add_word(desc,\n\t\t\t\t   ST_NOIMM_OFF(CLASS_DECO, REG_MATH0, 4, 4));\n\t\tcaam_desc_add_ptr(desc, size_msg.paddr);\n\t\t/* Set the descriptor Header with length */\n\t\tdesclen = caam_desc_get_len(desc);\n#ifdef CFG_CAAM_64BIT\n\t\tcaam_desc_update_hdr(desc,\n\t\t\t\t     DESC_HEADER_IDX(desclen, desclen - 1 - 3));\n#else\n\t\tcaam_desc_update_hdr(desc,\n\t\t\t\t     DESC_HEADER_IDX(desclen, desclen - 1 - 2));\n#endif /* CFG_CAAM_64BIT */\n\t} else {\n\t\tdesclen = caam_desc_get_len(desc);\n\t\t/* Set the descriptor Header with length */\n\t\tcaam_desc_update_hdr(desc,\n\t\t\t\t     DESC_HEADER_IDX(desclen, desclen - 1));\n\t}\n\n\tRSA_DUMPDESC(desc);\n\n\tjobctx.desc = desc;\n\tretstatus = caam_jr_enqueue(&jobctx, NULL);\n\n\tif (retstatus != CAAM_NO_ERROR) {\n\t\tRSA_TRACE(\"CAAM Status 0x%08\" PRIx32, jobctx.status);\n\t\tret = job_status_to_tee_result(jobctx.status);\n\t\tgoto exit_decrypt;\n\t}\n\n\tif (operation == RSA_DECRYPT(NO) &&\n\t    rsa_data->rsa_id == DRVCRYPT_RSA_NOPAD) {\n\t\trsa_data->message.length = caam_dmaobj_copy_ltrim_to_orig(&msg);\n\t} else {\n\t\tif (operation == RSA_DECRYPT(PKCS_V1_5)) {\n\t\t\t/* PKCS 1 v1.5 */\n\t\t\tcache_operation(TEE_CACHEINVALIDATE, size_msg.data,\n\t\t\t\t\tsize_msg.length);\n\n\t\t\t/* Check if the original buffer size is large enough */\n\t\t\tif (msg.orig.length < caam_read_val32(size_msg.data)) {\n\t\t\t\trsa_data->message.length =\n\t\t\t\t\t\tcaam_read_val32(size_msg.data);\n\t\t\t\tret = TEE_ERROR_SHORT_BUFFER;\n\t\t\t\tgoto exit_decrypt;\n\t\t\t}\n\n\t\t\tmsg.orig.length = caam_read_val32(size_msg.data);\n\t\t\tRSA_TRACE(\"New length %zu\", msg.orig.length);\n\t\t}\n\n\t\trsa_data->message.length = caam_dmaobj_copy_to_orig(&msg);\n\t}\n\n\tRSA_DUMPBUF(\"Output\", rsa_data->message.data, rsa_data->message.length);\n\tret = TEE_SUCCESS;\n\nexit_decrypt:\n\tcaam_free_desc(&desc);\n\tdo_keypair_free(&key);\n\tcaam_free_buf(&size_msg);\n\tcaam_dmaobj_free(&msg);\n\tcaam_dmaobj_free(&cipher);\n\n\tcaam_free_buf(&tmp);\n\n\treturn ret;\n}\n\n/*\n * RSA Encryption\n *\n * @rsa_data   [in/out] RSA Data to encrypt / Cipher resulting\n */\nstatic TEE_Result do_encrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\t\tret = do_caam_encrypt(rsa_data, RSA_ENCRYPT(NO));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\tret = do_caam_encrypt(rsa_data, RSA_ENCRYPT(PKCS_V1_5));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tret = do_oaep_encoding(rsa_data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/*\n * RSA Decryption\n *\n * @rsa_data   [in/out] RSA Data to decrypt / Message resulting\n */\nstatic TEE_Result do_decrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tTEE_Result ret = TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\t\tret = do_caam_decrypt(rsa_data, RSA_DECRYPT(NO));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\tret = do_caam_decrypt(rsa_data, RSA_DECRYPT(PKCS_V1_5));\n\t\tbreak;\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tret = do_oaep_decoding(rsa_data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Registration of the RSA Driver\n */\nstatic const struct drvcrypt_rsa driver_rsa = {\n\t.alloc_keypair = do_allocate_keypair,\n\t.alloc_publickey = do_allocate_publickey,\n\t.free_publickey = do_free_publickey,\n\t.free_keypair = do_free_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.encrypt = do_encrypt,\n\t.decrypt = do_decrypt,\n\t.optional.ssa_sign = NULL,\n\t.optional.ssa_verify = NULL,\n};\n\nenum caam_status caam_rsa_init(struct caam_jrcfg *caam_jrcfg)\n{\n\tenum caam_status retstatus = CAAM_FAILURE;\n\tvaddr_t jr_base = caam_jrcfg->base + caam_jrcfg->offset;\n\n\tif (caam_hal_ctrl_pknum(jr_base)) {\n\t\tcaam_era = caam_hal_ctrl_era(jr_base);\n\t\tRSA_TRACE(\"CAAM Era %d\", caam_era);\n\n\t\tif (!drvcrypt_register_rsa(&driver_rsa))\n\t\t\tretstatus = CAAM_NO_ERROR;\n\t}\n\n\treturn retstatus;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) Foundries Ltd. 2020 - All Rights Reserved\n * Author: Jorge Ramirez <jorge@foundries.io>\n */\n\n#include <assert.h>\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <der.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <drvcrypt_math.h>\n#include <initcall.h>\n#include <se050.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee_api_defines.h>\n#include <tee_api_defines_extensions.h>\n#include <utee_defines.h>\n#include <util.h>\n\nstatic const struct crypto_ecc_keypair_ops *pair_ops;\nstatic const struct crypto_ecc_public_ops *pub_ops;\n\nstatic bool oefid_key_supported(size_t bits)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\treturn bits >= 224;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool oefid_algo_supported(uint32_t algo)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\tswitch (algo) {\n\t\tcase TEE_ALG_ECDSA_SHA224:\n\t\tcase TEE_ALG_ECDSA_SHA256:\n\t\tcase TEE_ALG_ECDSA_SHA384:\n\t\tcase TEE_ALG_ECDSA_SHA512:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic uint32_t algo_tee2se050(uint32_t algo)\n{\n\tswitch (algo) {\n\tcase TEE_ALG_ECDSA_SHA1:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA1;\n\tcase TEE_ALG_ECDSA_SHA224:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA224;\n\tcase TEE_ALG_ECDSA_SHA256:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA256;\n\tcase TEE_ALG_ECDSA_SHA384:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA384;\n\tcase TEE_ALG_ECDSA_SHA512:\n\t\treturn kAlgorithm_SSS_ECDSA_SHA512;\n\tdefault:\n\t\tEMSG(\"algorithm %#\"PRIx32\" not enabled\", algo);\n\t\treturn kAlgorithm_None;\n\t}\n}\n\nstatic uint32_t cipher_tee2se050(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\tcase TEE_ECC_CURVE_NIST_P224:\n\tcase TEE_ECC_CURVE_NIST_P256:\n\tcase TEE_ECC_CURVE_NIST_P384:\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\treturn kSSS_CipherType_EC_NIST_P;\n\tdefault:\n\t\tEMSG(\"cipher %#\"PRIx32\" not enabled\", curve);\n\t\treturn kSSS_CipherType_NONE;\n\t}\n}\n\nstatic uint32_t curve_tee2se050(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\treturn kSE05x_ECCurve_NIST_P192;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\treturn kSE05x_ECCurve_NIST_P224;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\treturn kSE05x_ECCurve_NIST_P256;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\treturn kSE05x_ECCurve_NIST_P384;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\treturn kSE05x_ECCurve_NIST_P521;\n\tdefault:\n\t\tEMSG(\"curve %#\"PRIx32\" not enabled\", curve);\n\t\treturn kSE05x_ECCurve_NA;\n\t}\n}\n\nstatic uint32_t curve_se0502tee(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase kSE05x_ECCurve_NIST_P192:\n\t\treturn TEE_ECC_CURVE_NIST_P192;\n\tcase kSE05x_ECCurve_NIST_P224:\n\t\treturn TEE_ECC_CURVE_NIST_P224;\n\tcase kSE05x_ECCurve_NIST_P256:\n\t\treturn TEE_ECC_CURVE_NIST_P256;\n\tcase kSE05x_ECCurve_NIST_P384:\n\t\treturn TEE_ECC_CURVE_NIST_P384;\n\tcase kSE05x_ECCurve_NIST_P521:\n\t\treturn TEE_ECC_CURVE_NIST_P521;\n\tdefault:\n\t\tEMSG(\"curve %#\"PRIx32\" not enabled\", curve);\n\t\treturn TEE_CRYPTO_ELEMENT_NONE;\n\t}\n}\n\nstatic bool bn_alloc_max(struct bignum **s)\n{\n\t*s = crypto_bignum_allocate(4096);\n\n\treturn *s;\n}\n\nstatic TEE_Result ecc_get_key_size(uint32_t curve, uint32_t algo,\n\t\t\t\t   size_t *bytes, size_t *bits)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*bits = 192;\n\t\t*bytes = 24;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*bits = 224;\n\t\t*bytes = 28;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*bits = 256;\n\t\t*bytes = 32;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*bits = 384;\n\t\t*bytes = 48;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*bits = 521;\n\t\t*bytes = 66;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\tif (!oefid_key_supported(*bits))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (!oefid_algo_supported(algo))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result ecc_prepare_msg(uint32_t algo, const uint8_t *msg,\n\t\t\t\t  size_t *msg_len, uint8_t **msg_padded)\n{\n\tstruct {\n\t\tuint32_t algo;\n\t\tsize_t len;\n\t} map[] = {\n\t\t{ kAlgorithm_SSS_ECDSA_SHA1, TEE_SHA1_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA224, TEE_SHA224_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA256, TEE_SHA256_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA384, TEE_SHA384_HASH_SIZE },\n\t\t{ kAlgorithm_SSS_ECDSA_SHA512, TEE_SHA512_HASH_SIZE },\n\t};\n\tsize_t i = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (algo == map[i].algo)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(map))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (*msg_len >= map[i].len) {\n\t\t/* truncate */\n\t\t*msg_len = map[i].len;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* pad */\n\t*msg_padded = calloc(1, map[i].len);\n\tif (!*msg_padded)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tmemcpy(*msg_padded, msg, *msg_len);\n\t*msg_len = map[i].len;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result set_binary_data(struct bignum *b, size_t key_len, uint8_t **p,\n\t\t\t\t  size_t *len)\n{\n\tsize_t a = crypto_bignum_num_bytes(b);\n\tuint8_t leading_zeros = 0;\n\tuint8_t *q = NULL;\n\n\tif (!a)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tif (a != key_len) {\n\t\tleading_zeros = key_len - a;\n\t\ta = key_len;\n\t}\n\n\tq = calloc(1, a);\n\tif (!q)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tcrypto_bignum_bn2bin(b, q + leading_zeros);\n\t*len = a;\n\t*p = q;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_public_key(sss_se05x_object_t *k_object,\n\t\t\t\t\t  struct ecc_public_key *key,\n\t\t\t\t\t  size_t key_len)\n{\n\tstruct se050_ecc_keypub key_bin = { };\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tsss_status_t st = kStatus_SSS_Fail;\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/*\n\t * This function might return an error if the curve already\n\t * exists in the secure element. An actual error creating the\n\t * curve will be caught when attempting to set the key.\n\t */\n\tsss_se05x_key_store_create_curve(&se050_session->s_ctx,\n\t\t\t\t\t curve_tee2se050(key->curve));\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Public,\n\t\t\t\t\t\t  cipher_tee2se050(key->curve),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  kKeyObject_Mode_Transient);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tret = set_binary_data(key->x, key_len, &key_bin.x, &key_bin.x_len);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = set_binary_data(key->y, key_len, &key_bin.y, &key_bin.y_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tfree(key_bin.x);\n\t\treturn ret;\n\t}\n\n\tkey_bin.curve = curve_tee2se050(key->curve);\n\tst = se050_key_store_set_ecc_key_bin(se050_kstore, k_object, NULL,\n\t\t\t\t\t     &key_bin);\n\tfree(key_bin.x);\n\tfree(key_bin.y);\n\tif (st != kStatus_SSS_Success) {\n\t\tEMSG(\"Can't inject transient key, curve: %#\"PRIx32, key->curve);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_keypair(sss_se05x_object_t *k_object,\n\t\t\t\t       struct ecc_keypair *key,\n\t\t\t\t       size_t key_len)\n{\n\tstruct se050_ecc_keypair key_bin = { };\n\tsss_status_t st = kStatus_SSS_Fail;\n\tTEE_Result ret = TEE_ERROR_GENERIC;\n\tuint32_t key_id = 0;\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey_id = se050_ecc_keypair_from_nvm(key);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(k_object, key_id);\n\t\tif (st != kStatus_SSS_Success)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/*\n\t * This function might return an error if the curve already\n\t * exists in the secure element. An actual error creating the\n\t * curve will be caught when attempting to set the key.\n\t */\n\tsss_se05x_key_store_create_curve(&se050_session->s_ctx,\n\t\t\t\t\t curve_tee2se050(key->curve));\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  cipher_tee2se050(key->curve),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  kKeyObject_Mode_Transient);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tret = set_binary_data(key->d, key_len, &key_bin.d, &key_bin.d_len);\n\tif (ret != TEE_SUCCESS)\n\t\treturn ret;\n\n\tret = set_binary_data(key->x, key_len,\n\t\t\t      &key_bin.pub.x, &key_bin.pub.x_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tfree(key_bin.d);\n\t\treturn ret;\n\t}\n\n\tret = set_binary_data(key->y, key_len,\n\t\t\t      &key_bin.pub.y, &key_bin.pub.y_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tfree(key_bin.d);\n\t\tfree(key_bin.pub.x);\n\t\treturn ret;\n\t}\n\n\tkey_bin.pub.curve = curve_tee2se050(key->curve);\n\tst = se050_key_store_set_ecc_key_bin(se050_kstore, k_object, &key_bin,\n\t\t\t\t\t     NULL);\n\tfree(key_bin.d);\n\tfree(key_bin.pub.x);\n\tfree(key_bin.pub.y);\n\tif (st != kStatus_SSS_Success) {\n\t\tEMSG(\"Can't inject transient key, curve: %#\"PRIx32, key->curve);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result gen_fallback(struct ecc_keypair *key, size_t len)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: KEYGEN\");\n\treturn pair_ops->generate(key, len);\n}\n\nstatic TEE_Result shared_secret_fallback(struct ecc_keypair *private_key,\n\t\t\t\t\t struct ecc_public_key *public_key,\n\t\t\t\t\t void *secret, size_t *secret_len)\n{\n\tconst struct crypto_ecc_keypair_ops *ops = NULL;\n\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_ecc_keypair_from_nvm(private_key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tops = crypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDH_KEYPAIR);\n\tif (!ops)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: ECDH\");\n\treturn ops->shared_secret(private_key, public_key,\n\t\t\t\t  secret, (unsigned long *)secret_len);\n}\n\nstatic TEE_Result verify_fallback(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t  const uint8_t *msg, size_t msg_len,\n\t\t\t\t  const uint8_t *sig, size_t sig_len)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: VERIFY\");\n\treturn pub_ops->verify(algo, key, msg, msg_len, sig, sig_len);\n}\n\nstatic TEE_Result sign_fallback(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\tconst uint8_t *msg, size_t msg_len,\n\t\t\t\tuint8_t *sig, size_t *sig_len)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_ECC_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_ecc_keypair_from_nvm(key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: ECC software fallback: SIGN\");\n\treturn pair_ops->sign(algo, key, msg, msg_len, sig, sig_len);\n}\n\nstatic TEE_Result shared_secret(struct ecc_keypair *private_key,\n\t\t\t\tstruct ecc_public_key *public_key,\n\t\t\t\tvoid *secret, size_t *secret_len)\n{\n\tstruct se050_ecc_keypub key = { };\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_derive_key_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result ret = TEE_SUCCESS;\n\tsize_t key_bits = 0;\n\tsize_t key_bytes = 0;\n\n\tif (private_key->curve != public_key->curve)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tret = ecc_get_key_size(private_key->curve, 0, &key_bytes, &key_bits);\n\tif (ret) {\n\t\tif (ret != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\treturn ret;\n\n\t\treturn shared_secret_fallback(private_key, public_key,\n\t\t\t\t\t      secret, secret_len);\n\t}\n\n\tret = se050_inject_keypair(&kobject, private_key, key_bytes);\n\tif (ret != TEE_SUCCESS)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_derive_key_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       kAlgorithm_SSS_ECDH,\n\t\t\t\t\t       kMode_SSS_ComputeSharedSecret);\n\tif (st != kStatus_SSS_Success) {\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\t/* prepare the public key (must be in raw format) */\n\tret = set_binary_data(public_key->x, key_bytes, &key.x, &key.x_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tret = set_binary_data(public_key->y, key_bytes, &key.y, &key.y_len);\n\tif (ret != TEE_SUCCESS) {\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tst = se050_ecc_gen_shared_secret(&se050_session->s_ctx,\n\t\t\t\t\t kobject.keyId, &key,\n\t\t\t\t\t secret, secret_len);\n\n\tif (st != kStatus_SSS_Success)\n\t\tret = TEE_ERROR_BAD_PARAMETERS;\nexit:\n\tif (!se050_ecc_keypair_from_nvm(private_key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tfree(key.x);\n\tfree(key.y);\n\n\treturn ret;\n}\n\nstatic TEE_Result sign(uint32_t algo, struct ecc_keypair *key,\n\t\t       const uint8_t *msg, size_t msg_len,\n\t\t       uint8_t *sig, size_t *sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *sig_der = NULL;\n\tsize_t sig_der_len = 0;\n\tsize_t key_bytes = 0;\n\tsize_t key_bits = 0;\n\tuint8_t *p = NULL;\n\n\tres = ecc_get_key_size(key->curve, algo, &key_bytes, &key_bits);\n\tif (res) {\n\t\tif (res != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\tgoto exit;\n\n\t\treturn sign_fallback(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\t/* allocate temporary buffer to retrieve the signature in DER format */\n\tsig_der_len = 2 * key_bytes + DER_SIGNATURE_SZ;\n\n\tsig_der = malloc(sig_der_len);\n\tif (!sig_der) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit;\n\t}\n\n\t/* truncate or pad the message as needed */\n\tres = ecc_prepare_msg(algo_tee2se050(algo), msg, &msg_len, &p);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = se050_inject_keypair(&kobject, key, key_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       algo_tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Sign);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tst = sss_se05x_asymmetric_sign_digest(&ctx, p ? p : (uint8_t *)msg,\n\t\t\t\t\t      msg_len, sig_der, &sig_der_len);\n\tif (st != kStatus_SSS_Success) {\n\t\tEMSG(\"curve: %#\"PRIx32, key->curve);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tsss_se05x_signature_der2bin(sig_der, &sig_der_len);\n\n\tif (sig_der_len > *sig_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(sig, sig_der, sig_der_len);\n\t*sig_len = sig_der_len;\nexit:\n\tif (!se050_ecc_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\tfree(sig_der);\n\tfree(p);\n\n\treturn res;\n}\n\nstatic TEE_Result verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t const uint8_t *sig, size_t sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *signature = NULL;\n\tsize_t signature_len = sig_len + DER_SIGNATURE_SZ;\n\tsize_t key_bytes = 0;\n\tsize_t key_bits = 0;\n\tuint8_t *p = NULL;\n\n\tres = ecc_get_key_size(key->curve, algo, &key_bytes, &key_bits);\n\tif (res) {\n\t\tif (res != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\tgoto exit;\n\n\t\treturn verify_fallback(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\t/* truncate or pad the message as needed */\n\tres = ecc_prepare_msg(algo_tee2se050(algo), msg, &msg_len, &p);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tres = se050_inject_public_key(&kobject, key, key_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       algo_tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Verify);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tsignature = calloc(1, signature_len);\n\tif (!signature) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto exit;\n\t}\n\n\tst = sss_se05x_signature_bin2der(signature, &signature_len,\n\t\t\t\t\t (uint8_t *)sig, sig_len);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\tst = sss_se05x_asymmetric_verify_digest(&ctx, p ? p : (uint8_t *)msg,\n\t\t\t\t\t\tmsg_len, (uint8_t *)signature,\n\t\t\t\t\t\tsignature_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\nexit:\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\tfree(p);\n\tfree(signature);\n\n\treturn res;\n}\n\nstatic TEE_Result gen_keypair(struct ecc_keypair *key, size_t key_size)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tTEE_Result ret = TEE_SUCCESS;\n\tuint8_t kf[512] = { };\n\tuint32_t oid = 0;\n\tuint64_t kid = 0;\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tret = ecc_get_key_size(key->curve, 0, &bytes, &bits);\n\tif (ret) {\n\t\tif (ret != TEE_ERROR_NOT_IMPLEMENTED)\n\t\t\treturn ret;\n\n\t\treturn gen_fallback(key, key_size);\n\t}\n\n\tst = sss_se05x_key_object_init(&k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(&k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  cipher_tee2se050(key->curve),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_key_store_generate_key(se050_kstore, &k_object, bits,\n\t\t\t\t\t      &se050_asym_policy);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tbytes = sizeof(kf);\n\tst = se050_key_store_get_ecc_key_bin(se050_kstore, &k_object, kf,\n\t\t\t\t\t     &bytes);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* skip the DER tag */\n\tcrypto_bignum_bin2bn(kf + 1, bytes / 2, key->x);\n\tcrypto_bignum_bin2bn(kf + 1 + bytes / 2, bytes / 2, key->y);\n\n\tkid = se050_generate_private_key(oid);\n\tcrypto_bignum_bin2bn((uint8_t *)&kid, sizeof(kid), key->d);\n\tkey->curve = curve_se0502tee(k_object.curve_id);\n\tif (key->curve != TEE_CRYPTO_ELEMENT_NONE)\n\t\treturn TEE_SUCCESS;\n\n\tEMSG(\"ecc key generation failed\");\n\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic TEE_Result do_gen_keypair(struct ecc_keypair *key, size_t size_bytes)\n{\n\treturn gen_keypair(key, size_bytes);\n}\n\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\treturn shared_secret(sdata->key_priv,\n\t\t\t     sdata->key_pub,\n\t\t\t     sdata->secret.data,\n\t\t\t     &sdata->secret.length);\n}\n\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata)\n{\n\treturn sign(sdata->algo,\n\t\t    sdata->key,\n\t\t    sdata->message.data,\n\t\t    sdata->message.length,\n\t\t    sdata->signature.data,\n\t\t    &sdata->signature.length);\n}\n\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata)\n{\n\treturn verify(sdata->algo,\n\t\t      sdata->key,\n\t\t      sdata->message.data,\n\t\t      sdata->message.length,\n\t\t      sdata->signature.data,\n\t\t      sdata->signature.length);\n}\n\nstatic TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic TEE_Result do_alloc_publickey(struct ecc_public_key *s, uint32_t type,\n\t\t\t\t     size_t size_bits __unused)\n{\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic void do_free_publickey(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n}\n\nstatic struct drvcrypt_ecc driver_ecc = {\n\t.alloc_keypair = do_alloc_keypair,\n\t.alloc_publickey = do_alloc_publickey,\n\t.free_publickey = do_free_publickey,\n\t.gen_keypair = do_gen_keypair,\n\t.sign = do_sign,\n\t.verify = do_verify,\n\t.shared_secret = do_shared_secret,\n};\n\nstatic TEE_Result ecc_init(void)\n{\n\tpub_ops = crypto_asym_get_ecc_public_ops(TEE_TYPE_ECDSA_PUBLIC_KEY);\n\tif (!pub_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tpair_ops = crypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDSA_KEYPAIR);\n\tif (!pair_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/* This driver supports both ECDH and ECDSA */\n\tassert((pub_ops ==\n\t\tcrypto_asym_get_ecc_public_ops(TEE_TYPE_ECDH_PUBLIC_KEY)) &&\n\t       (pair_ops ==\n\t\tcrypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDH_KEYPAIR)));\n\n\treturn drvcrypt_register_ecc(&driver_ecc);\n}\n\ndriver_init_late(ecc_init);\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) Foundries Ltd. 2020 - All Rights Reserved\n * Author: Jorge Ramirez <jorge@foundries.io>\n */\n\n#include <assert.h>\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <drvcrypt_math.h>\n#include <initcall.h>\n#include <mempool.h>\n#include <se050.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee_api_defines_extensions.h>\n\nstatic sss_cipher_type_t oefid_cipher_type(void)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\treturn kSSS_CipherType_RSA_CRT;\n\tdefault:\n\t\treturn kSSS_CipherType_RSA;\n\t}\n}\n\nstatic bool oefid_keylen_supported(size_t bits)\n{\n\tswitch (se050_get_oefid()) {\n\tcase SE050F_ID:\n\t\treturn bits >= 2048;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool rsa_keypair_has_crt(struct rsa_keypair *key)\n{\n\tif (key->p && crypto_bignum_num_bytes(key->p) &&\n\t    key->q && crypto_bignum_num_bytes(key->q) &&\n\t    key->qp && crypto_bignum_num_bytes(key->qp) &&\n\t    key->dp && crypto_bignum_num_bytes(key->dp) &&\n\t    key->dq && crypto_bignum_num_bytes(key->dq))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool keypair_supported(struct rsa_keypair *key, sss_cipher_type_t ctype)\n{\n\tif (se050_rsa_keypair_from_nvm(key))\n\t\treturn true;\n\n\tif (ctype == kSSS_CipherType_RSA_CRT)\n\t\treturn rsa_keypair_has_crt(key);\n\n\treturn true;\n}\n\nstatic uint32_t tee2se050(uint32_t algo)\n{\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA1;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA224;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA256;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA384;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_SHA512;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA1;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA224;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA256;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA384;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_PSS_MGF1_SHA512;\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_V1_5_SHA256;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA1;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA224;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA256;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA384;\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\treturn kAlgorithm_SSS_RSAES_PKCS1_OAEP_SHA512;\n\tcase TEE_ALG_RSA_NOPAD:\n\t\treturn kAlgorithm_SSS_RSASSA_NO_PADDING;\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\t\treturn kAlgorithm_SSS_RSASSA_PKCS1_V1_5_NO_HASH;\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5SHA1:\n\tdefault:\n\t\treturn kAlgorithm_None;\n\t}\n}\n\nstatic bool bn_alloc_max(struct bignum **s)\n{\n\t*s = crypto_bignum_allocate(4096);\n\n\treturn *s;\n}\n\nstatic TEE_Result set_binary_data(struct bignum *b, uint8_t **p, size_t *len)\n{\n\t*len = crypto_bignum_num_bytes(b);\n\tif (*len) {\n\t\t*p = (uint8_t *)calloc(1, *len);\n\t\tif (!*p)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t\tcrypto_bignum_bn2bin(b, *p);\n\t}\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_public_key(sss_se05x_object_t *k_object,\n\t\t\t\t\t  struct rsa_public_key *key)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tstruct se050_rsa_keypub key_bin = { };\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/*\n\t * Keys 2048 and above MUST to be placed on persistent storage even\n\t * though the keys will be deleted after the operation. This is a\n\t * memory restriction in the secure element.\n\t */\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Public,\n\t\t\t\t\t\t  oefid_cipher_type(), 0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tset_binary_data(key->e, &key_bin.e, &key_bin.e_len);\n\tset_binary_data(key->n, &key_bin.n, &key_bin.n_len);\n\tst = se050_key_store_set_rsa_key_bin(se050_kstore, k_object, NULL,\n\t\t\t\t\t     &key_bin, key_bin.n_len * 8);\n\tfree(key_bin.n);\n\tfree(key_bin.e);\n\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, k_object);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result se050_inject_keypair(sss_se05x_object_t *k_object,\n\t\t\t\t       struct rsa_keypair *key)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tstruct se050_rsa_keypair key_bin = { };\n\tuint32_t key_id = 0;\n\tuint32_t oid = 0;\n\n\tst = sss_se05x_key_object_init(k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey_id = se050_rsa_keypair_from_nvm(key);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(k_object, key_id);\n\t\tif (st != kStatus_SSS_Success)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/* Keys 2048 and above need to be placed on persistent storage */\n\tst = sss_se05x_key_object_allocate_handle(k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  oefid_cipher_type(), 0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tset_binary_data(key->e, &key_bin.e, &key_bin.e_len);\n\tset_binary_data(key->d, &key_bin.d, &key_bin.d_len);\n\tset_binary_data(key->n, &key_bin.n, &key_bin.n_len);\n\tset_binary_data(key->p, &key_bin.p, &key_bin.p_len);\n\tset_binary_data(key->q, &key_bin.q, &key_bin.q_len);\n\tset_binary_data(key->qp, &key_bin.qp, &key_bin.qp_len);\n\tset_binary_data(key->dp, &key_bin.dp, &key_bin.dp_len);\n\tset_binary_data(key->dq, &key_bin.dq, &key_bin.dq_len);\n\tst = se050_key_store_set_rsa_key_bin(se050_kstore, k_object,\n\t\t\t\t\t     &key_bin, NULL,\n\t\t\t\t\t     crypto_bignum_num_bits(key->n));\n\tfree(key_bin.e);\n\tfree(key_bin.d);\n\tfree(key_bin.n);\n\tfree(key_bin.p);\n\tfree(key_bin.q);\n\tfree(key_bin.qp);\n\tfree(key_bin.dp);\n\tfree(key_bin.dq);\n\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, k_object);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result decrypt_es(uint32_t algo, struct rsa_keypair *key,\n\t\t\t     const uint8_t *src, size_t src_len,\n\t\t\t     uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tsize_t buf_len = src_len;\n\n\tres = se050_inject_keypair(&kobject, key);\n\tif (res)\n\t\treturn res;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Decrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tif (!se050_rsa_keypair_from_nvm(key))\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* we don't know the size of the decrypted data, just the upper limit */\n\tbuf = mempool_calloc(mempool_default, 1, buf_len);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tst = sss_se05x_asymmetric_decrypt(&ctx, src, src_len, buf,  &buf_len);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (buf_len > *dst_len) {\n\t\t*dst_len = buf_len;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t*dst_len = buf_len;\n\tmemcpy(dst, buf, buf_len);\nout:\n\tif (!se050_rsa_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\tmempool_free(mempool_default, buf);\n\n\treturn res;\n}\n\nstatic TEE_Result encrypt_es(uint32_t algo, struct rsa_public_key *key,\n\t\t\t     const uint8_t *src, size_t src_len,\n\t\t\t     uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\n\tif (*dst_len < crypto_bignum_num_bytes(key->n)) {\n\t\t*dst_len = crypto_bignum_num_bytes(key->n);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\n\tif (se050_inject_public_key(&kobject, key))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Encrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tst = sss_se05x_asymmetric_encrypt(&ctx, src, src_len, dst, dst_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result decrypt_nopad(struct rsa_keypair *key, const uint8_t *src,\n\t\t\t\tsize_t src_len, uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tsize_t offset = 0;\n\tsize_t blen = 0;\n\tsize_t rsa_len = 0;\n\n\tres = se050_inject_keypair(&kobject, key);\n\tif (res)\n\t\treturn res;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       kAlgorithm_SSS_RSASSA_NO_PADDING,\n\t\t\t\t\t       kMode_SSS_Decrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tif (!se050_rsa_keypair_from_nvm(key))\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = mempool_calloc(mempool_default, 1, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\trsa_len = crypto_bignum_num_bytes(key->n);\n\tmemcpy(buf + rsa_len - src_len, src, src_len);\n\n\tst = sss_se05x_asymmetric_decrypt(&ctx, buf, rsa_len, buf, &blen);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < blen - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < blen - offset) {\n\t\t*dst_len = blen - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t*dst_len = blen - offset;\n\tmemcpy(dst, buf + offset, *dst_len);\nout:\n\tmempool_free(mempool_default, buf);\n\tif (!se050_rsa_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result encrypt_nopad(struct rsa_public_key *key, const uint8_t *src,\n\t\t\t\tsize_t src_len, uint8_t *dst, size_t *dst_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tsize_t offset = 0;\n\tsize_t blen = 0;\n\tsize_t rsa_len = 0;\n\n\tif (se050_inject_public_key(&kobject, key))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       kAlgorithm_SSS_RSASSA_NO_PADDING,\n\t\t\t\t\t       kMode_SSS_Encrypt);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = mempool_calloc(mempool_default, 1, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\trsa_len = crypto_bignum_num_bytes(key->n);\n\tmemcpy(buf + rsa_len - src_len, src, src_len);\n\n\tst = sss_se05x_asymmetric_encrypt(&ctx, buf, rsa_len, buf, &blen);\n\tif (st != kStatus_SSS_Success) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < blen - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < blen - offset) {\n\t\t*dst_len = blen - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t*dst_len = blen - offset;\n\tmemcpy(dst, buf + offset, *dst_len);\nout:\n\tmempool_free(mempool_default, buf);\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result sign_ssa(uint32_t algo, struct rsa_keypair *key,\n\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t   uint8_t *sig, size_t *sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\n\tif (*sig_len < crypto_bignum_num_bytes(key->n)) {\n\t\t*sig_len = crypto_bignum_num_bytes(key->n);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\n\tres = se050_inject_keypair(&kobject, key);\n\tif (res)\n\t\treturn res;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo), kMode_SSS_Sign);\n\tif (st != kStatus_SSS_Success) {\n\t\tif (!se050_rsa_keypair_from_nvm(key))\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tst = sss_se05x_asymmetric_sign_digest(&ctx, (uint8_t *)msg, msg_len,\n\t\t\t\t\t      sig, sig_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\n\tif (!se050_rsa_keypair_from_nvm(key))\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result verify_ssa(uint32_t algo, struct rsa_public_key *key,\n\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_asymmetric_t ctx = { };\n\tsss_se05x_object_t kobject = { };\n\tTEE_Result res = TEE_SUCCESS;\n\n\tif (se050_inject_public_key(&kobject, key))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_asymmetric_context_init(&ctx, se050_session, &kobject,\n\t\t\t\t\t       tee2se050(algo),\n\t\t\t\t\t       kMode_SSS_Verify);\n\tif (st != kStatus_SSS_Success) {\n\t\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tst = sss_se05x_asymmetric_verify_digest(&ctx, (uint8_t *)msg, msg_len,\n\t\t\t\t\t\t(uint8_t *)sig, sig_len);\n\tif (st != kStatus_SSS_Success)\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\n\tsss_se05x_key_store_erase_key(se050_kstore, &kobject);\n\tsss_se05x_asymmetric_context_free(&ctx);\n\n\treturn res;\n}\n\nstatic TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(&s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(&s->n);\n\t\tcrypto_bignum_free(&s->e);\n\t}\n}\n\nstatic void do_free_keypair(struct rsa_keypair *s)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t key_id = 0;\n\n\tif (!s)\n\t\treturn;\n\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n}\n\nstatic TEE_Result do_gen_keypair(struct rsa_keypair *key, size_t kb)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t oid = 0;\n\tuint64_t kid = 0;\n\tuint8_t k[2048] = { 0 };\n\tuint8_t *n = NULL;\n\tuint8_t *e = NULL;\n\tsize_t n_len = 0;\n\tsize_t e_len = 0;\n\tsize_t k_len = sizeof(k);\n\n\tif (!oefid_keylen_supported(kb)) {\n\t\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\tDMSG(\"se050: debug: RSA software fallback: KEYGEN\");\n\t\treturn sw_crypto_acipher_gen_rsa_key(key, kb);\n\t}\n\n\tst = sss_se05x_key_object_init(&k_object, se050_kstore);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = se050_get_oid(&oid);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tst = sss_se05x_key_object_allocate_handle(&k_object, oid,\n\t\t\t\t\t\t  kSSS_KeyPart_Pair,\n\t\t\t\t\t\t  oefid_cipher_type(), 0,\n\t\t\t\t\t\t  kKeyObject_Mode_Persistent);\n\tif (st != kStatus_SSS_Success)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tst = sss_se05x_key_store_generate_key(se050_kstore, &k_object, kb,\n\t\t\t\t\t      &se050_asym_policy);\n\tif (st != kStatus_SSS_Success)\n\t\tgoto error;\n\n\tst = sss_se05x_key_store_get_key(se050_kstore, &k_object, k, &k_len,\n\t\t\t\t\t &kb);\n\tif (st != kStatus_SSS_Success)\n\t\tgoto error;\n\n\tst = sss_util_asn1_rsa_parse_public(k, k_len, &n, &n_len, &e, &e_len);\n\tif (st != kStatus_SSS_Success)\n\t\tgoto error;\n\n\tcrypto_bignum_bin2bn(n, n_len, key->n);\n\tcrypto_bignum_bin2bn(e, e_len, key->e);\n\tkid = se050_generate_private_key(oid);\n\tcrypto_bignum_bin2bn((uint8_t *)&kid, sizeof(kid), (key->d));\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->p);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->q);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->qp);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->dp);\n\tcrypto_bignum_bin2bn((uint8_t *)&oid, sizeof(oid), key->dq);\n\tfree(n);\n\tfree(e);\n\n\treturn TEE_SUCCESS;\nerror:\n\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic TEE_Result encrypt_fallback(struct drvcrypt_rsa_ed *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (p->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\t\tDMSG(\"se050: debug: RSA software fallback: ENCRYPT_NOPAD\");\n\t\treturn sw_crypto_acipher_rsanopad_encrypt(p->key.key,\n\t\t\t\t\t\t\t  p->message.data,\n\t\t\t\t\t\t\t  p->message.length,\n\t\t\t\t\t\t\t  p->cipher.data,\n\t\t\t\t\t\t\t  &p->cipher.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tdefault:\n\t\tDMSG(\"se050: debug: RSA software fallback: ENCRYPT_ES\");\n\t\treturn sw_crypto_acipher_rsaes_encrypt(p->algo,\n\t\t\t\t\t\t       p->key.key,\n\t\t\t\t\t\t       p->label.data,\n\t\t\t\t\t\t       p->label.length,\n\t\t\t\t\t\t       p->message.data,\n\t\t\t\t\t\t       p->message.length,\n\t\t\t\t\t\t       p->cipher.data,\n\t\t\t\t\t\t       &p->cipher.length);\n\t}\n}\n\nstatic TEE_Result do_encrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tif (!oefid_keylen_supported(rsa_data->key.n_size * 8))\n\t\treturn encrypt_fallback(rsa_data);\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\t\treturn encrypt_nopad(rsa_data->key.key,\n\t\t\t\t     rsa_data->message.data,\n\t\t\t\t     rsa_data->message.length,\n\t\t\t\t     rsa_data->cipher.data,\n\t\t\t\t     &rsa_data->cipher.length);\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\treturn encrypt_es(TEE_ALG_RSAES_PKCS1_V1_5,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  rsa_data->message.length,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  &rsa_data->cipher.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tif (rsa_data->hash_algo != TEE_ALG_SHA1)\n\t\t\treturn encrypt_fallback(rsa_data);\n\n\t\treturn encrypt_es(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  rsa_data->message.length,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  &rsa_data->cipher.length);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn encrypt_fallback(rsa_data);\n}\n\nstatic TEE_Result decrypt_fallback(struct drvcrypt_rsa_ed *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_rsa_keypair_from_nvm(p->key.key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tswitch (p->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\t\tDMSG(\"se050: debug: RSA software fallback: DECRYPT_NOPAD\");\n\t\treturn sw_crypto_acipher_rsanopad_decrypt(p->key.key,\n\t\t\t\t\t\t\t  p->cipher.data,\n\t\t\t\t\t\t\t  p->cipher.length,\n\t\t\t\t\t\t\t  p->message.data,\n\t\t\t\t\t\t\t  &p->message.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tdefault:\n\t\tDMSG(\"se050: debug: RSA software fallback: DECRYPT_ES\");\n\t\treturn sw_crypto_acipher_rsaes_decrypt(p->algo,\n\t\t\t\t\t\t       p->key.key,\n\t\t\t\t\t\t       p->label.data,\n\t\t\t\t\t\t       p->label.length,\n\t\t\t\t\t\t       p->cipher.data,\n\t\t\t\t\t\t       p->cipher.length,\n\t\t\t\t\t\t       p->message.data,\n\t\t\t\t\t\t       &p->message.length);\n\t}\n}\n\nstatic TEE_Result do_decrypt(struct drvcrypt_rsa_ed *rsa_data)\n{\n\tif (!oefid_keylen_supported(rsa_data->key.n_size * 8))\n\t\treturn decrypt_fallback(rsa_data);\n\n\tif (!keypair_supported(rsa_data->key.key, oefid_cipher_type()))\n\t\treturn decrypt_fallback(rsa_data);\n\n\tswitch (rsa_data->rsa_id) {\n\tcase DRVCRYPT_RSA_NOPAD:\n\tcase DRVCRYPT_RSASSA_PSS:\n\tcase DRVCRYPT_RSASSA_PKCS_V1_5:\n\t\treturn decrypt_nopad(rsa_data->key.key,\n\t\t\t\t     rsa_data->cipher.data,\n\t\t\t\t     rsa_data->cipher.length,\n\t\t\t\t     rsa_data->message.data,\n\t\t\t\t     &rsa_data->message.length);\n\n\tcase DRVCRYPT_RSA_PKCS_V1_5:\n\t\treturn decrypt_es(TEE_ALG_RSAES_PKCS1_V1_5,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  rsa_data->cipher.length,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  &rsa_data->message.length);\n\n\tcase DRVCRYPT_RSA_OAEP:\n\t\tif (rsa_data->hash_algo != TEE_ALG_SHA1)\n\t\t\treturn decrypt_fallback(rsa_data);\n\n\t\treturn decrypt_es(TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1,\n\t\t\t\t  rsa_data->key.key,\n\t\t\t\t  rsa_data->cipher.data,\n\t\t\t\t  rsa_data->cipher.length,\n\t\t\t\t  rsa_data->message.data,\n\t\t\t\t  &rsa_data->message.length);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn TEE_ERROR_NOT_IMPLEMENTED;\n}\n\nstatic TEE_Result sign_ssa_fallback(struct drvcrypt_rsa_ssa *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (se050_rsa_keypair_from_nvm(p->key.key))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: RSA software fallback: SIGN\");\n\treturn sw_crypto_acipher_rsassa_sign(p->algo,\n\t\t\t\t\t     p->key.key,\n\t\t\t\t\t     p->salt_len,\n\t\t\t\t\t     p->message.data,\n\t\t\t\t\t     p->message.length,\n\t\t\t\t\t     p->signature.data,\n\t\t\t\t\t     &p->signature.length);\n}\n\nstatic TEE_Result do_ssa_sign(struct drvcrypt_rsa_ssa *ssa_data)\n{\n\tif (!oefid_keylen_supported(ssa_data->key.n_size * 8))\n\t\treturn sign_ssa_fallback(ssa_data);\n\n\tif (!keypair_supported(ssa_data->key.key, oefid_cipher_type()))\n\t\treturn sign_ssa_fallback(ssa_data);\n\n\t/* PKCS1_PSS_MGF1 padding limitations */\n\tswitch (ssa_data->algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\t\tif (ssa_data->key.n_size * 8 <= 512)\n\t\t\treturn sign_ssa_fallback(ssa_data);\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (ssa_data->key.n_size * 8 <= 1024)\n\t\t\treturn sign_ssa_fallback(ssa_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn sign_ssa(ssa_data->algo,\n\t\t\tssa_data->key.key,\n\t\t\tssa_data->message.data,\n\t\t\tssa_data->message.length,\n\t\t\tssa_data->signature.data,\n\t\t\t&ssa_data->signature.length);\n}\n\nstatic TEE_Result verify_ssa_fallback(struct drvcrypt_rsa_ssa *p)\n{\n\tif (!IS_ENABLED(CFG_NXP_SE05X_RSA_DRV_FALLBACK))\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tDMSG(\"se050: debug: RSA software fallback: VERIFY\");\n\treturn sw_crypto_acipher_rsassa_verify(p->algo,\n\t\t\t\t\t       p->key.key,\n\t\t\t\t\t       p->salt_len,\n\t\t\t\t\t       p->message.data,\n\t\t\t\t\t       p->message.length,\n\t\t\t\t\t       p->signature.data,\n\t\t\t\t\t       p->signature.length);\n}\n\nstatic TEE_Result do_ssa_verify(struct drvcrypt_rsa_ssa *ssa_data)\n{\n\tif (!oefid_keylen_supported(ssa_data->key.n_size * 8))\n\t\treturn verify_ssa_fallback(ssa_data);\n\n\t/* PKCS1_PSS_MGF1 padding limitations */\n\tswitch (ssa_data->algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\t\tif (ssa_data->key.n_size * 8 <= 512)\n\t\t\treturn verify_ssa_fallback(ssa_data);\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (ssa_data->key.n_size * 8 <= 1024)\n\t\t\treturn verify_ssa_fallback(ssa_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn verify_ssa(ssa_data->algo,\n\t\t\tssa_data->key.key,\n\t\t\tssa_data->message.data,\n\t\t\tssa_data->message.length,\n\t\t\tssa_data->signature.data,\n\t\t\tssa_data->signature.length);\n}\n\nstatic const struct drvcrypt_rsa driver_rsa = {\n\t.alloc_keypair = do_alloc_keypair,\n\t.alloc_publickey = do_alloc_publickey,\n\t.free_publickey = do_free_publickey,\n\t.free_keypair = do_free_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.encrypt = do_encrypt,\n\t.decrypt = do_decrypt,\n\t.optional.ssa_sign = do_ssa_sign,\n\t.optional.ssa_verify = do_ssa_verify,\n};\n\nstatic TEE_Result rsa_init(void)\n{\n\treturn drvcrypt_register_rsa(&driver_rsa);\n}\n\ndriver_init_late(rsa_init);\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) Foundries Ltd. 2022.\n * Author: Jorge Ramirez <jorge@foundries.io>\n */\n\n#include <drvcrypt.h>\n#include <drvcrypt_acipher.h>\n#include <crypto/crypto_impl.h>\n#include <initcall.h>\n#include <ipi.h>\n#include <kernel/panic.h>\n#include <mm/core_memprot.h>\n#include <string.h>\n#include <tee/cache.h>\n#include <tee/tee_cryp_utl.h>\n#include <util.h>\n\n/* AMD/Xilinx Versal's Known Answer Tests */\n#define XSECURE_ECDSA_KAT_NIST_P384\t0\n#define XSECURE_ECDSA_KAT_NIST_P521\t2\n\n/* Software based ECDSA operations */\nstatic const struct crypto_ecc_keypair_ops *pair_ops;\nstatic const struct crypto_ecc_public_ops *pub_ops;\n\nenum versal_ecc_err {\n\tKAT_KEY_NOTVALID_ERROR = 0xC0,\n\tKAT_FAILED_ERROR,\n\tNON_SUPPORTED_CURVE,\n\tKEY_ZERO,\n\tKEY_WRONG_ORDER,\n\tKEY_NOT_ON_CURVE,\n\tBAD_SIGN,\n\tGEN_SIGN_INCORRECT_HASH_LEN,\n\tVER_SIGN_INCORRECT_HASH_LEN,\n\tGEN_SIGN_BAD_RAND_NUM,\n\tGEN_KEY_ERR,\n\tINVALID_PARAM,\n\tVER_SIGN_R_ZERO,\n\tVER_SIGN_S_ZERO,\n\tVER_SIGN_R_ORDER_ERROR,\n\tVER_SIGN_S_ORDER_ERROR,\n\tKAT_INVLD_CRV_ERROR,\n};\n\n#define VERSAL_ECC_ERROR(m) { .error = (m), .name = TO_STR(m) }\n\nstatic const char *versal_ecc_error(uint8_t err)\n{\n\tstruct {\n\t\tenum versal_ecc_err error;\n\t\tconst char *name;\n\t} elist[] = {\n\t\tVERSAL_ECC_ERROR(KAT_KEY_NOTVALID_ERROR),\n\t\tVERSAL_ECC_ERROR(KAT_FAILED_ERROR),\n\t\tVERSAL_ECC_ERROR(NON_SUPPORTED_CURVE),\n\t\tVERSAL_ECC_ERROR(KEY_ZERO),\n\t\tVERSAL_ECC_ERROR(KEY_WRONG_ORDER),\n\t\tVERSAL_ECC_ERROR(KEY_NOT_ON_CURVE),\n\t\tVERSAL_ECC_ERROR(BAD_SIGN),\n\t\tVERSAL_ECC_ERROR(GEN_SIGN_INCORRECT_HASH_LEN),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_INCORRECT_HASH_LEN),\n\t\tVERSAL_ECC_ERROR(GEN_SIGN_BAD_RAND_NUM),\n\t\tVERSAL_ECC_ERROR(GEN_KEY_ERR),\n\t\tVERSAL_ECC_ERROR(INVALID_PARAM),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_R_ZERO),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_S_ZERO),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_R_ORDER_ERROR),\n\t\tVERSAL_ECC_ERROR(VER_SIGN_S_ORDER_ERROR),\n\t\tVERSAL_ECC_ERROR(KAT_INVLD_CRV_ERROR),\n\t};\n\n\tif (err <= KAT_INVLD_CRV_ERROR && err >= KAT_KEY_NOTVALID_ERROR) {\n\t\tif (elist[err - KAT_KEY_NOTVALID_ERROR].name)\n\t\t\treturn elist[err - KAT_KEY_NOTVALID_ERROR].name;\n\n\t\treturn \"Invalid\";\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic TEE_Result ecc_get_key_size(uint32_t curve, size_t *bytes, size_t *bits)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*bits = 384;\n\t\t*bytes = 48;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*bits = 521;\n\t\t*bytes = 66;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void memcpy_swp(uint8_t *to, const uint8_t *from, size_t len)\n{\n\tsize_t i = 0;\n\n\tfor (i = 0; i < len; i++)\n\t\tto[i] = from[len - 1 - i];\n}\n\nstatic void crypto_bignum_bn2bin_eswap(uint32_t curve,\n\t\t\t\t       struct bignum *from, uint8_t *to)\n{\n\tuint8_t pad[66] = { 0 };\n\tsize_t len = crypto_bignum_num_bytes(from);\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tif (ecc_get_key_size(curve, &bytes, &bits))\n\t\tpanic();\n\n\tcrypto_bignum_bn2bin(from, pad + bytes - len);\n\tmemcpy_swp(to, pad, bytes);\n}\n\nstatic TEE_Result ecc_prepare_msg(uint32_t algo, const uint8_t *msg,\n\t\t\t\t  size_t msg_len, struct versal_mbox_mem *p)\n{\n\tuint8_t swp[TEE_SHA512_HASH_SIZE + 2] = { 0 };\n\tsize_t len = 0;\n\n\tif (msg_len > TEE_SHA512_HASH_SIZE + 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (algo == TEE_ALG_ECDSA_SHA384)\n\t\tlen = TEE_SHA384_HASH_SIZE;\n\telse if (algo == TEE_ALG_ECDSA_SHA512)\n\t\tlen = TEE_SHA512_HASH_SIZE + 2;\n\telse\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Swap the hash/message and pad if necessary */\n\tmemcpy_swp(swp, msg, msg_len);\n\treturn versal_mbox_alloc(len, swp, p);\n}\n\nstatic TEE_Result verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result ret = TEE_SUCCESS;\n\tstruct versal_ecc_verify_param *cmd = NULL;\n\tstruct versal_cmd_args arg = { };\n\tstruct versal_mbox_mem x = { };\n\tstruct versal_mbox_mem s = { };\n\tstruct versal_mbox_mem p = { };\n\tstruct versal_mbox_mem cmd_buf = { };\n\tuint32_t err = 0;\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tif (sig_len % 2)\n\t\treturn TEE_ERROR_SIGNATURE_INVALID;\n\n\tret = ecc_get_key_size(key->curve, &bytes, &bits);\n\tif (ret != TEE_SUCCESS) {\n\t\tif (ret != TEE_ERROR_NOT_SUPPORTED)\n\t\t\treturn ret;\n\n\t\t/* Fallback to software */\n\t\treturn pub_ops->verify(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\tret = ecc_prepare_msg(algo, msg, msg_len, &p);\n\tif (ret)\n\t\treturn ret;\n\n\tversal_mbox_alloc(bytes * 2, NULL, &x);\n\tcrypto_bignum_bn2bin_eswap(key->curve, key->x, x.buf);\n\tcrypto_bignum_bn2bin_eswap(key->curve, key->y,\n\t\t\t\t   (uint8_t *)x.buf + bytes);\n\t/* Validate the public key for the curve */\n\targ.data[0] = key->curve;\n\targ.dlen = 1;\n\targ.ibuf[0].mem = x;\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_VALIDATE_PUBLIC_KEY,\n\t\t\t\t  &arg, &err)) {\n\t\tEMSG(\"Versal ECC: %s\", versal_ecc_error(err));\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\tmemset(&arg, 0, sizeof(arg));\n\n\tversal_mbox_alloc(sig_len, NULL, &s);\n\t/* Swap the {R,S} components */\n\tmemcpy_swp(s.buf, sig, sig_len / 2);\n\tmemcpy_swp((uint8_t *)s.buf + sig_len / 2, sig + sig_len / 2,\n\t\t   sig_len / 2);\n\tversal_mbox_alloc(sizeof(*cmd), NULL, &cmd_buf);\n\n\tcmd = cmd_buf.buf;\n\tcmd->signature_addr = virt_to_phys(s.buf);\n\tcmd->pub_key_addr = virt_to_phys(x.buf);\n\tcmd->hash_addr = virt_to_phys(p.buf);\n\tcmd->hash_len = p.len;\n\tcmd->curve = key->curve;\n\n\targ.ibuf[0].mem = cmd_buf;\n\targ.ibuf[1].mem = p;\n\targ.ibuf[1].only_cache = true;\n\targ.ibuf[2].mem = x;\n\targ.ibuf[3].mem = s;\n\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_VERIFY_SIGN, &arg, &err)) {\n\t\tEMSG(\"Versal ECC: %s\", versal_ecc_error(err));\n\t\tret = TEE_ERROR_GENERIC;\n\t}\nout:\n\tfree(p.buf);\n\tfree(x.buf);\n\tfree(s.buf);\n\tfree(cmd);\n\n\treturn ret;\n}\n\nstatic TEE_Result sign(uint32_t algo, struct ecc_keypair *key,\n\t\t       const uint8_t *msg, size_t msg_len,\n\t\t       uint8_t *sig, size_t *sig_len)\n{\n\tstruct versal_ecc_sign_param *cmd = NULL;\n\tstruct versal_mbox_mem cmd_buf = { };\n\tstruct ecc_keypair ephemeral = { };\n\tstruct versal_cmd_args arg = { };\n\tstruct versal_mbox_mem p = { };\n\tstruct versal_mbox_mem k = { };\n\tstruct versal_mbox_mem d = { };\n\tstruct versal_mbox_mem s = { };\n\tTEE_Result ret = TEE_SUCCESS;\n\tuint32_t err = 0;\n\tsize_t bytes = 0;\n\tsize_t bits = 0;\n\n\tret = ecc_get_key_size(key->curve, &bytes, &bits);\n\tif (ret != TEE_SUCCESS) {\n\t\tif (ret != TEE_ERROR_NOT_SUPPORTED)\n\t\t\treturn ret;\n\n\t\t/* Fallback to software */\n\t\treturn pair_ops->sign(algo, key, msg, msg_len, sig, sig_len);\n\t}\n\n\t/* Hash and update the length */\n\tret = ecc_prepare_msg(algo, msg, msg_len, &p);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Ephemeral private key */\n\tret = drvcrypt_asym_alloc_ecc_keypair(&ephemeral,\n\t\t\t\t\t      TEE_TYPE_ECDSA_KEYPAIR, bits);\n\tif (ret) {\n\t\tEMSG(\"Versal, can't allocate the ephemeral key\");\n\t\treturn ret;\n\t}\n\n\tephemeral.curve = key->curve;\n\tret = crypto_acipher_gen_ecc_key(&ephemeral, bits);\n\tif (ret) {\n\t\tEMSG(\"Versal, can't generate the ephemeral key\");\n\t\treturn ret;\n\t}\n\n\tversal_mbox_alloc(bytes, NULL, &k);\n\tcrypto_bignum_bn2bin_eswap(key->curve, ephemeral.d, k.buf);\n\tcrypto_bignum_free(&ephemeral.d);\n\tcrypto_bignum_free(&ephemeral.x);\n\tcrypto_bignum_free(&ephemeral.y);\n\n\t/* Private key*/\n\tversal_mbox_alloc(bytes, NULL, &d);\n\tcrypto_bignum_bn2bin_eswap(key->curve, key->d, d.buf);\n\n\t/* Signature */\n\tversal_mbox_alloc(*sig_len, NULL, &s);\n\n\t/* IPI command */\n\tversal_mbox_alloc(sizeof(*cmd), NULL, &cmd_buf);\n\n\tcmd = cmd_buf.buf;\n\tcmd->priv_key_addr = virt_to_phys(d.buf);\n\tcmd->epriv_key_addr = virt_to_phys(k.buf);\n\tcmd->hash_addr = virt_to_phys(p.buf);\n\tcmd->hash_len = p.len;\n\tcmd->curve = key->curve;\n\n\targ.ibuf[0].mem = cmd_buf;\n\targ.ibuf[1].mem = s;\n\targ.ibuf[2].mem = k;\n\targ.ibuf[3].mem = d;\n\targ.ibuf[4].mem = p;\n\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_GENERATE_SIGN, &arg, &err)) {\n\t\tEMSG(\"Versal ECC: %s\", versal_ecc_error(err));\n\t\tret = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\t*sig_len = 2 * bytes;\n\n\t/* Swap the {R,S} components */\n\tmemcpy_swp(sig, s.buf, *sig_len / 2);\n\tmemcpy_swp(sig + *sig_len / 2, (uint8_t *)s.buf + *sig_len / 2,\n\t\t   *sig_len / 2);\nout:\n\tfree(cmd);\n\tfree(k.buf);\n\tfree(p.buf);\n\tfree(s.buf);\n\tfree(d.buf);\n\n\treturn ret;\n}\n\nstatic TEE_Result shared_secret(struct ecc_keypair *private_key,\n\t\t\t\tstruct ecc_public_key *public_key,\n\t\t\t\tvoid *secret, size_t *secret_len)\n{\n\treturn pair_ops->shared_secret(private_key, public_key,\n\t\t\t\t\t  secret, secret_len);\n}\n\nstatic TEE_Result do_shared_secret(struct drvcrypt_secret_data *sdata)\n{\n\treturn shared_secret(sdata->key_priv,\n\t\t\t     sdata->key_pub,\n\t\t\t     sdata->secret.data,\n\t\t\t     &sdata->secret.length);\n}\n\nstatic TEE_Result do_sign(struct drvcrypt_sign_data *sdata)\n{\n\treturn sign(sdata->algo,\n\t\t    sdata->key,\n\t\t    sdata->message.data,\n\t\t    sdata->message.length,\n\t\t    sdata->signature.data,\n\t\t    &sdata->signature.length);\n}\n\nstatic TEE_Result do_verify(struct drvcrypt_sign_data *sdata)\n{\n\treturn verify(sdata->algo,\n\t\t      sdata->key,\n\t\t      sdata->message.data,\n\t\t      sdata->message.length,\n\t\t      sdata->signature.data,\n\t\t      sdata->signature.length);\n}\n\nstatic TEE_Result do_gen_keypair(struct ecc_keypair *s, size_t size_bits)\n{\n\t/*\n\t * Versal requires little endian so need to memcpy_swp on Versal IP ops.\n\t * We chose not to do it here because some tests might be using\n\t * their own keys\n\t */\n\treturn pair_ops->generate(s, size_bits);\n}\n\nstatic TEE_Result do_alloc_keypair(struct ecc_keypair *s,\n\t\t\t\t   uint32_t type, size_t size_bits)\n{\n\tTEE_Result ret = TEE_SUCCESS;\n\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tret = crypto_asym_alloc_ecc_keypair(s, TEE_TYPE_ECDSA_KEYPAIR,\n\t\t\t\t\t    size_bits);\n\tif (ret)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Ignore the software operations, the crypto API will populate\n\t * this interface.\n\t */\n\ts->ops = NULL;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result do_alloc_publickey(struct ecc_public_key *s,\n\t\t\t\t     uint32_t type, size_t size_bits)\n{\n\tTEE_Result ret = TEE_SUCCESS;\n\n\t/* This driver only supports ECDH/ECDSA */\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tret = crypto_asym_alloc_ecc_public_key(s, TEE_TYPE_ECDSA_PUBLIC_KEY,\n\t\t\t\t\t       size_bits);\n\tif (ret)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t/*\n\t * Ignore the software operations, the crypto API will populate\n\t * this interface.\n\t */\n\ts->ops = NULL;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void do_free_publickey(struct ecc_public_key *s)\n{\n\treturn pub_ops->free(s);\n}\n\nstatic struct drvcrypt_ecc driver_ecc = {\n\t.shared_secret = do_shared_secret,\n\t.alloc_publickey = do_alloc_publickey,\n\t.free_publickey = do_free_publickey,\n\t.alloc_keypair = do_alloc_keypair,\n\t.gen_keypair = do_gen_keypair,\n\t.verify = do_verify,\n\t.sign = do_sign,\n};\n\nstatic TEE_Result ecc_init(void)\n{\n\tstruct versal_cmd_args arg = { };\n\tuint32_t err = 0;\n\n\targ.data[arg.dlen++] = XSECURE_ECDSA_KAT_NIST_P384;\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_KAT, &arg, &err)) {\n\t\tEMSG(\"Versal KAG NIST_P384: %s\", versal_ecc_error(err));\n\t\treturn TEE_ERROR_GENERIC;\n\t}\n\n\t/* Clean previous request */\n\targ.dlen = 0;\n\n\targ.data[arg.dlen++] = XSECURE_ECDSA_KAT_NIST_P521;\n\tif (versal_crypto_request(VERSAL_ELLIPTIC_KAT, &arg, &err)) {\n\t\tEMSG(\"Versal KAG NIST_P521 %s\", versal_ecc_error(err));\n\t\treturn TEE_ERROR_GENERIC;\n\t}\n\n\tpair_ops = crypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDSA_KEYPAIR);\n\tif (!pair_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\tpub_ops = crypto_asym_get_ecc_public_ops(TEE_TYPE_ECDSA_PUBLIC_KEY);\n\tif (!pub_ops)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t/* This driver supports both ECDH and ECDSA */\n\tassert((pub_ops ==\n\t\tcrypto_asym_get_ecc_public_ops(TEE_TYPE_ECDH_PUBLIC_KEY)) &&\n\t       (pair_ops ==\n\t\tcrypto_asym_get_ecc_keypair_ops(TEE_TYPE_ECDH_KEYPAIR)));\n\n\treturn drvcrypt_register_ecc(&driver_ecc);\n}\n\ndriver_init(ecc_init);\n", "/* SPDX-License-Identifier: BSD-2-Clause */\n/*\n * Copyright (c) 2014-2017, Linaro Limited\n */\n\n/*\n * This is the Cryptographic Provider API (CP API).\n *\n * This defines how most crypto syscalls that implement the Cryptographic\n * Operations API can invoke the actual providers of cryptographic algorithms\n * (such as LibTomCrypt).\n *\n * To add a new provider, you need to provide an implementation of this\n * interface.\n *\n * The following parameters are commonly used.\n *\n * @ctx: context allocated by the syscall, for later use by the algorithm\n * @algo: algorithm identifier (TEE_ALG_*)\n */\n\n#ifndef __CRYPTO_CRYPTO_H\n#define __CRYPTO_CRYPTO_H\n\n#include <tee/tee_obj.h>\n#include <tee_api_types.h>\n\nTEE_Result crypto_init(void);\n\n/* Message digest functions */\nTEE_Result crypto_hash_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_hash_init(void *ctx);\nTEE_Result crypto_hash_update(void *ctx, const uint8_t *data, size_t len);\nTEE_Result crypto_hash_final(void *ctx, uint8_t *digest, size_t len);\nvoid crypto_hash_free_ctx(void *ctx);\nvoid crypto_hash_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Symmetric ciphers */\nTEE_Result crypto_cipher_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_cipher_init(void *ctx, TEE_OperationMode mode,\n\t\t\t      const uint8_t *key1, size_t key1_len,\n\t\t\t      const uint8_t *key2, size_t key2_len,\n\t\t\t      const uint8_t *iv, size_t iv_len);\nTEE_Result crypto_cipher_update(void *ctx, TEE_OperationMode mode,\n\t\t\t\tbool last_block, const uint8_t *data,\n\t\t\t\tsize_t len, uint8_t *dst);\nvoid crypto_cipher_final(void *ctx);\nTEE_Result crypto_cipher_get_block_size(uint32_t algo, size_t *size);\nvoid crypto_cipher_free_ctx(void *ctx);\nvoid crypto_cipher_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Message Authentication Code functions */\nTEE_Result crypto_mac_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_mac_init(void *ctx, const uint8_t *key, size_t len);\nTEE_Result crypto_mac_update(void *ctx, const uint8_t *data, size_t len);\nTEE_Result crypto_mac_final(void *ctx, uint8_t *digest, size_t digest_len);\nvoid crypto_mac_free_ctx(void *ctx);\nvoid crypto_mac_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Authenticated encryption */\nTEE_Result crypto_authenc_alloc_ctx(void **ctx, uint32_t algo);\nTEE_Result crypto_authenc_init(void *ctx, TEE_OperationMode mode,\n\t\t\t       const uint8_t *key, size_t key_len,\n\t\t\t       const uint8_t *nonce, size_t nonce_len,\n\t\t\t       size_t tag_len, size_t aad_len,\n\t\t\t       size_t payload_len);\nTEE_Result crypto_authenc_update_aad(void *ctx, TEE_OperationMode mode,\n\t\t\t\t     const uint8_t *data, size_t len);\nTEE_Result crypto_authenc_update_payload(void *ctx, TEE_OperationMode mode,\n\t\t\t\t\t const uint8_t *src_data,\n\t\t\t\t\t size_t src_len, uint8_t *dst_data,\n\t\t\t\t\t size_t *dst_len);\nTEE_Result crypto_authenc_enc_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, uint8_t *dst_tag,\n\t\t\t\t    size_t *dst_tag_len);\nTEE_Result crypto_authenc_dec_final(void *ctx, const uint8_t *src_data,\n\t\t\t\t    size_t src_len, uint8_t *dst_data,\n\t\t\t\t    size_t *dst_len, const uint8_t *tag,\n\t\t\t\t    size_t tag_len);\nvoid crypto_authenc_final(void *ctx);\nvoid crypto_authenc_free_ctx(void *ctx);\nvoid crypto_authenc_copy_state(void *dst_ctx, void *src_ctx);\n\n/* Informs crypto that the data in the buffer will be removed from storage */\nTEE_Result crypto_storage_obj_del(struct tee_obj *obj);\n\n/* Implementation-defined big numbers */\n\n/*\n * Allocate a bignum capable of holding an unsigned integer value of\n * up to bitsize bits\n */\nstruct bignum *crypto_bignum_allocate(size_t size_bits);\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,\n\t\t\t\tstruct bignum *to);\nsize_t crypto_bignum_num_bytes(struct bignum *a);\nsize_t crypto_bignum_num_bits(struct bignum *a);\nvoid crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to);\nvoid crypto_bignum_copy(struct bignum *to, const struct bignum *from);\nvoid crypto_bignum_free(struct bignum **a);\nvoid crypto_bignum_clear(struct bignum *a);\n\n/* return -1 if a<b, 0 if a==b, +1 if a>b */\nint32_t crypto_bignum_compare(struct bignum *a, struct bignum *b);\n\n/* Asymmetric algorithms */\n\nstruct rsa_keypair {\n\tstruct bignum *e;\t/* Public exponent */\n\tstruct bignum *d;\t/* Private exponent */\n\tstruct bignum *n;\t/* Modulus */\n\n\t/* Optional CRT parameters (all NULL if unused) */\n\tstruct bignum *p;\t/* N = pq */\n\tstruct bignum *q;\n\tstruct bignum *qp;\t/* 1/q mod p */\n\tstruct bignum *dp;\t/* d mod (p-1) */\n\tstruct bignum *dq;\t/* d mod (q-1) */\n};\n\nstruct rsa_public_key {\n\tstruct bignum *e;\t/* Public exponent */\n\tstruct bignum *n;\t/* Modulus */\n};\n\nstruct dsa_keypair {\n\tstruct bignum *g;\t/* Generator of subgroup (public) */\n\tstruct bignum *p;\t/* Prime number (public) */\n\tstruct bignum *q;\t/* Order of subgroup (public) */\n\tstruct bignum *y;\t/* Public key */\n\tstruct bignum *x;\t/* Private key */\n};\n\nstruct dsa_public_key {\n\tstruct bignum *g;\t/* Generator of subgroup (public) */\n\tstruct bignum *p;\t/* Prime number (public) */\n\tstruct bignum *q;\t/* Order of subgroup (public) */\n\tstruct bignum *y;\t/* Public key */\n};\n\nstruct dh_keypair {\n\tstruct bignum *g;\t/* Generator of Z_p (shared) */\n\tstruct bignum *p;\t/* Prime modulus (shared) */\n\tstruct bignum *x;\t/* Private key */\n\tstruct bignum *y;\t/* Public key y = g^x */\n\n\t/*\n\t * Optional parameters used by key generation.\n\t * When not used, q == NULL and xbits == 0\n\t */\n\tstruct bignum *q;\t/* x must be in the range [2, q-2] */\n\tuint32_t xbits;\t\t/* Number of bits in the private key */\n};\n\nstruct ecc_public_key {\n\tstruct bignum *x;\t/* Public value x */\n\tstruct bignum *y;\t/* Public value y */\n\tuint32_t curve;\t        /* Curve type */\n\tconst struct crypto_ecc_public_ops *ops; /* Key Operations */\n};\n\nstruct ecc_keypair {\n\tstruct bignum *d;\t/* Private value */\n\tstruct bignum *x;\t/* Public value x */\n\tstruct bignum *y;\t/* Public value y */\n\tuint32_t curve;\t        /* Curve type */\n\tconst struct crypto_ecc_keypair_ops *ops; /* Key Operations */\n};\n\nstruct x25519_keypair {\n\tuint8_t *priv;\t/* Private value */\n\tuint8_t *pub;\t/* Public value */\n};\n\nstruct ed25519_keypair {\n\tuint8_t *priv;\n\tuint8_t *pub;\n\tuint32_t curve;\n};\n\nstruct ed25519_public_key {\n\tuint8_t *pub;\n\tuint32_t curve;\n};\n\n/*\n * Key allocation functions\n * Allocate the bignum's inside a key structure.\n * TEE core will later use crypto_bignum_free().\n */\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\tsize_t key_size_bits);\nTEE_Result crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t   size_t key_size_bits);\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s);\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s);\nTEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\tsize_t key_size_bits);\nTEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t   size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,\n\t\t\t       size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t       uint32_t key_type,\n\t\t\t\t\t       size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits);\nvoid crypto_acipher_free_ecc_public_key(struct ecc_public_key *s);\nTEE_Result crypto_acipher_alloc_x25519_keypair(struct x25519_keypair *s,\n\t\t\t\t\t       size_t key_size_bits);\nTEE_Result crypto_acipher_alloc_ed25519_keypair(struct ed25519_keypair *s,\n\t\t\t\t\t\tsize_t key_size_bits);\nTEE_Result\ncrypto_acipher_alloc_ed25519_public_key(struct ed25519_public_key *key,\n\t\t\t\t\tsize_t key_size);\n\n/*\n * Key generation functions\n */\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key, size_t key_size);\nTEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key, size_t key_size);\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key, struct bignum *q,\n\t\t\t\t     size_t xbits, size_t key_size);\nTEE_Result crypto_acipher_gen_ecc_key(struct ecc_keypair *key, size_t key_size);\nTEE_Result crypto_acipher_gen_x25519_key(struct x25519_keypair *key,\n\t\t\t\t\t size_t key_size);\nTEE_Result crypto_acipher_gen_ed25519_key(struct ed25519_keypair *key,\n\t\t\t\t\t  size_t key_size);\nTEE_Result crypto_acipher_ed25519_sign(struct ed25519_keypair *key,\n\t\t\t\t       const uint8_t *msg, size_t msg_len,\n\t\t\t\t       uint8_t *sig, size_t *sig_len);\nTEE_Result crypto_acipher_ed25519ctx_sign(struct ed25519_keypair *key,\n\t\t\t\t\t  const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t  uint8_t *sig, size_t *sig_len,\n\t\t\t\t\t  bool ph_flag,\n\t\t\t\t\t  const uint8_t *ctx, size_t ctxlen);\nTEE_Result crypto_acipher_ed25519_verify(struct ed25519_public_key *key,\n\t\t\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t const uint8_t *sig, size_t sig_len);\nTEE_Result crypto_acipher_ed25519ctx_verify(struct ed25519_public_key *key,\n\t\t\t\t\t    const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t    const uint8_t *sig, size_t sig_len,\n\t\t\t\t\t    bool ph_flag,\n\t\t\t\t\t    const uint8_t *ctx, size_t ctxlen);\n\nTEE_Result crypto_acipher_dh_shared_secret(struct dh_keypair *private_key,\n\t\t\t\t\t   struct bignum *public_key,\n\t\t\t\t\t   struct bignum *secret);\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t\tconst uint8_t *label, size_t label_len,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tconst uint8_t *label, size_t label_len,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len);\n/* RSA SSA sign/verify: if salt_len == -1, use default value */\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t      int salt_len, const uint8_t *msg,\n\t\t\t\t      size_t msg_len, uint8_t *sig,\n\t\t\t\t      size_t *sig_len);\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tint salt_len, const uint8_t *msg,\n\t\t\t\t\tsize_t msg_len, const uint8_t *sig,\n\t\t\t\t\tsize_t sig_len);\nTEE_Result crypto_acipher_dsa_sign(uint32_t algo, struct dsa_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len);\nTEE_Result crypto_acipher_dsa_verify(uint32_t algo, struct dsa_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len);\nTEE_Result crypto_acipher_ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len);\nTEE_Result crypto_acipher_ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len);\nTEE_Result crypto_acipher_ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t\t    struct ecc_public_key *public_key,\n\t\t\t\t\t    void *secret,\n\t\t\t\t\t    unsigned long *secret_len);\nTEE_Result crypto_acipher_sm2_pke_decrypt(struct ecc_keypair *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_sm2_pke_encrypt(struct ecc_public_key *key,\n\t\t\t\t\t  const uint8_t *src, size_t src_len,\n\t\t\t\t\t  uint8_t *dst, size_t *dst_len);\nTEE_Result crypto_acipher_x25519_shared_secret(struct x25519_keypair\n\t\t\t\t\t       *private_key,\n\t\t\t\t\t       void *public_key, void *secret,\n\t\t\t\t\t       unsigned long *secret_len);\n\nstruct sm2_kep_parms {\n\tuint8_t *out;\n\tsize_t out_len;\n\tbool is_initiator;\n\tconst uint8_t *initiator_id;\n\tsize_t initiator_id_len;\n\tconst uint8_t *responder_id;\n\tsize_t responder_id_len;\n\tconst uint8_t *conf_in;\n\tsize_t conf_in_len;\n\tuint8_t *conf_out;\n\tsize_t conf_out_len;\n};\n\nTEE_Result crypto_acipher_sm2_kep_derive(struct ecc_keypair *my_key,\n\t\t\t\t\t struct ecc_keypair *my_eph_key,\n\t\t\t\t\t struct ecc_public_key *peer_key,\n\t\t\t\t\t struct ecc_public_key *peer_eph_key,\n\t\t\t\t\t struct sm2_kep_parms *p);\n\n/*\n * Verifies a SHA-256 hash, doesn't require crypto_init() to be called in\n * advance and has as few dependencies as possible.\n *\n * This function is primarily used by pager and early initialization code\n * where the complete crypto library isn't available.\n */\nTEE_Result hash_sha256_check(const uint8_t *hash, const uint8_t *data,\n\t\tsize_t data_size);\n\n/*\n * Computes a SHA-512/256 hash, vetted conditioner as per NIST.SP.800-90B.\n * It doesn't require crypto_init() to be called in advance and has as few\n * dependencies as possible.\n *\n * This function could be used inside interrupt context where the crypto\n * library can't be used due to mutex handling.\n */\nTEE_Result hash_sha512_256_compute(uint8_t *digest, const uint8_t *data,\n\t\tsize_t data_size);\n\n#define CRYPTO_RNG_SRC_IS_QUICK(sid) (!!((sid) & 1))\n\n/*\n * enum crypto_rng_src - RNG entropy source\n *\n * Identifiers for different RNG entropy sources. The lowest bit indicates\n * if the source is to be merely queued (bit is 1) or if it's delivered\n * directly to the pool. The difference is that in the latter case RPC to\n * normal world can be performed and in the former it must not.\n */\nenum crypto_rng_src {\n\tCRYPTO_RNG_SRC_JITTER_SESSION\t= (0 << 1 | 0),\n\tCRYPTO_RNG_SRC_JITTER_RPC\t= (1 << 1 | 1),\n\tCRYPTO_RNG_SRC_NONSECURE\t= (1 << 1 | 0),\n};\n\n/*\n * crypto_rng_init() - initialize the RNG\n * @data:\tbuffer with initial seed\n * @dlen:\tlength of @data\n */\nTEE_Result crypto_rng_init(const void *data, size_t dlen);\n\n/*\n * crypto_rng_add_event() - supply entropy to RNG from a source\n * @sid:\tSource identifier, should be unique for a specific source\n * @pnum:\tPool number, acquired using crypto_rng_get_next_pool_num()\n * @data:\tData associated with the event\n * @dlen:\tLength of @data\n *\n * @sid controls whether the event is merly queued in a ring buffer or if\n * it's added to one of the pools directly. If CRYPTO_RNG_SRC_IS_QUICK() is\n * true (lowest bit set) events are queue otherwise added to corresponding\n * pool. If CRYPTO_RNG_SRC_IS_QUICK() is false, eventual queued events are\n * added to their queues too.\n */\nvoid crypto_rng_add_event(enum crypto_rng_src sid, unsigned int *pnum,\n\t\t\t  const void *data, size_t dlen);\n\n/*\n * crypto_rng_read() - read cryptograhically secure RNG\n * @buf:\tBuffer to hold the data\n * @len:\tLength of buffer.\n *\n * Eventual queued events are also added to their pools during this\n * function call.\n */\nTEE_Result crypto_rng_read(void *buf, size_t len);\n\n/*\n * crypto_aes_expand_enc_key() - Expand an AES key\n * @key:\tAES key buffer\n * @key_len:\tSize of the @key buffer in bytes\n * @enc_key:\tExpanded AES encryption key buffer\n * @enc_keylen: Size of the @enc_key buffer in bytes\n * @rounds:\tNumber of rounds to be used during encryption\n */\nTEE_Result crypto_aes_expand_enc_key(const void *key, size_t key_len,\n\t\t\t\t     void *enc_key, size_t enc_keylen,\n\t\t\t\t     unsigned int *rounds);\n\n/*\n * crypto_aes_enc_block() - Encrypt an AES block\n * @enc_key:\tExpanded AES encryption key\n * @enc_keylen:\tSize of @enc_key in bytes\n * @rounds:\tNumber of rounds\n * @src:\tSource buffer of one AES block (16 bytes)\n * @dst:\tDestination buffer of one AES block (16 bytes)\n */\nvoid crypto_aes_enc_block(const void *enc_key, size_t enc_keylen,\n\t\t\t  unsigned int rounds, const void *src, void *dst);\n\n#endif /* __CRYPTO_CRYPTO_H */\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_types.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,\n\t\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->g);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->y);\n\tcrypto_bignum_free(&s->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key, struct bignum *q,\n\t\t\t\t     size_t xbits, size_t key_size)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tdh_key ltc_tmp_key = { };\n\tint ltc_res = 0;\n\n\tif (key_size != 8 * mp_unsigned_bin_size(key->p))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tltc_res = mp_init_multi(&ltc_tmp_key.base, &ltc_tmp_key.prime, NULL);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\t/* Generate the DH key */\n\tmp_copy(key->g, ltc_tmp_key.base);\n\tmp_copy(key->p, ltc_tmp_key.prime);\n\tltc_res = dh_make_key(NULL, find_prng(\"prng_crypto\"), q, xbits,\n\t\t\t      &ltc_tmp_key);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\tltc_mp.copy(ltc_tmp_key.y,  key->y);\n\t\tltc_mp.copy(ltc_tmp_key.x,  key->x);\n\t\tres = TEE_SUCCESS;\n\t}\n\n\tdh_free(&ltc_tmp_key);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_dh_shared_secret(struct dh_keypair *private_key,\n\t\t\t\t\t   struct bignum *public_key,\n\t\t\t\t\t   struct bignum *secret)\n{\n\tint err;\n\n\tif (!private_key || !public_key || !secret)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\terr = mp_exptmod(public_key, private_key->x, private_key->p, secret);\n\treturn ((err == CRYPT_OK) ? TEE_SUCCESS : TEE_ERROR_BAD_PARAMETERS);\n\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\nTEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->g);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->g);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_gen_dsa_key(struct dsa_keypair *key, size_t key_size)\n{\n\tdsa_key ltc_tmp_key = { };\n\tint ltc_res = 0;\n\n\tif (key_size != 8 * mp_unsigned_bin_size(key->p))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tltc_res = mp_init_multi(&ltc_tmp_key.g, &ltc_tmp_key.p, &ltc_tmp_key.q,\n\t\t\t\t&ltc_tmp_key.x, &ltc_tmp_key.y, NULL);\n\tif (ltc_res)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\t/* Copy the key parameters */\n\tmp_copy(key->g, ltc_tmp_key.g);\n\tmp_copy(key->p, ltc_tmp_key.p);\n\tmp_copy(key->q, ltc_tmp_key.q);\n\n\t/* Generate the DSA key */\n\tltc_res = dsa_generate_key(NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t   &ltc_tmp_key);\n\tif (ltc_res)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Copy the key */\n\tmp_copy(ltc_tmp_key.y, key->y);\n\tmp_copy(ltc_tmp_key.x, key->x);\n\n\t/* Free the temporary key */\n\tdsa_free(&ltc_tmp_key);\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result crypto_acipher_dsa_sign(uint32_t algo, struct dsa_keypair *key,\n\t\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t\t   uint8_t *sig, size_t *sig_len)\n{\n\tTEE_Result res;\n\tsize_t hash_size;\n\tint ltc_res;\n\tvoid *r, *s;\n\tdsa_key ltc_key = {\n\t\t.type = PK_PRIVATE,\n\t\t.qord = mp_unsigned_bin_size(key->q),\n\t\t.g = key->g,\n\t\t.p = key->p,\n\t\t.q = key->q,\n\t\t.y = key->y,\n\t\t.x = key->x,\n\t};\n\n\tif (algo != TEE_ALG_DSA_SHA1 &&\n\t    algo != TEE_ALG_DSA_SHA224 &&\n\t    algo != TEE_ALG_DSA_SHA256) {\n\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\tgoto err;\n\t}\n\n\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t      &hash_size);\n\tif (res != TEE_SUCCESS)\n\t\tgoto err;\n\tif (mp_unsigned_bin_size(ltc_key.q) < hash_size)\n\t\thash_size = mp_unsigned_bin_size(ltc_key.q);\n\tif (msg_len != hash_size) {\n\t\tres = TEE_ERROR_SECURITY;\n\t\tgoto err;\n\t}\n\n\tif (*sig_len < 2 * mp_unsigned_bin_size(ltc_key.q)) {\n\t\t*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto err;\n\t}\n\n\tltc_res = mp_init_multi(&r, &s, NULL);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\n\tltc_res = dsa_sign_hash_raw(msg, msg_len, r, s, NULL,\n\t\t\t\t    find_prng(\"prng_crypto\"), &ltc_key);\n\n\tif (ltc_res == CRYPT_OK) {\n\t\t*sig_len = 2 * mp_unsigned_bin_size(ltc_key.q);\n\t\tmemset(sig, 0, *sig_len);\n\t\tmp_to_unsigned_bin(r, (uint8_t *)sig + *sig_len/2 -\n\t\t\t\t   mp_unsigned_bin_size(r));\n\t\tmp_to_unsigned_bin(s, (uint8_t *)sig + *sig_len -\n\t\t\t\t   mp_unsigned_bin_size(s));\n\t\tres = TEE_SUCCESS;\n\t} else {\n\t\tres = TEE_ERROR_GENERIC;\n\t}\n\n\tmp_clear_multi(r, s, NULL);\n\nerr:\n\treturn res;\n}\n\nTEE_Result crypto_acipher_dsa_verify(uint32_t algo, struct dsa_public_key *key,\n\t\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result res;\n\tint ltc_stat, ltc_res;\n\tvoid *r, *s;\n\tdsa_key ltc_key = {\n\t\t.type = PK_PUBLIC,\n\t\t.qord = mp_unsigned_bin_size(key->q),\n\t\t.g = key->g,\n\t\t.p = key->p,\n\t\t.q = key->q,\n\t\t.y = key->y\n\t};\n\n\tif (algo != TEE_ALG_DSA_SHA1 &&\n\t    algo != TEE_ALG_DSA_SHA224 &&\n\t    algo != TEE_ALG_DSA_SHA256) {\n\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\tgoto err;\n\t}\n\n\tltc_res = mp_init_multi(&r, &s, NULL);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto err;\n\t}\n\tmp_read_unsigned_bin(r, (uint8_t *)sig, sig_len/2);\n\tmp_read_unsigned_bin(s, (uint8_t *)sig + sig_len/2, sig_len/2);\n\tltc_res = dsa_verify_hash_raw(r, s, msg, msg_len, &ltc_stat, &ltc_key);\n\tmp_clear_multi(r, s, NULL);\n\tres = convert_ltc_verify_status(ltc_res, ltc_stat);\nerr:\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, Linaro Limited\n */\n\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_types.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\nstatic void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n}\n\n/*\n * For a given TEE @curve, return key size and LTC curve name. Also check that\n * @algo is compatible with this curve.\n * @curve: TEE_ECC_CURVE_NIST_P192, ...\n * @algo: TEE_ALG_ECDSA_SHA1, ...\n */\nstatic TEE_Result ecc_get_curve_info(uint32_t curve, uint32_t algo,\n\t\t\t\t     size_t *key_size_bytes,\n\t\t\t\t     size_t *key_size_bits,\n\t\t\t\t     const char **curve_name)\n{\n\tsize_t size_bytes = 0;\n\tsize_t size_bits = 0;\n\tconst char *name = NULL;\n\n\t/*\n\t * Excerpt of libtomcrypt documentation:\n\t * ecc_make_key(... key_size ...): The keysize is the size of the\n\t * modulus in bytes desired. Currently directly supported values\n\t * are 12, 16, 20, 24, 28, 32, 48, and 65 bytes which correspond\n\t * to key sizes of 112, 128, 160, 192, 224, 256, 384, and 521 bits\n\t * respectively.\n\t */\n\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\tsize_bits = 192;\n\t\tsize_bytes = 24;\n\t\tname = \"NISTP192\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA1) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\tsize_bits = 224;\n\t\tsize_bytes = 28;\n\t\tname = \"NISTP224\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA224) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\tsize_bits = 256;\n\t\tsize_bytes = 32;\n\t\tname = \"NISTP256\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA256) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\tsize_bits = 384;\n\t\tsize_bytes = 48;\n\t\tname = \"NISTP384\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA384) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\tsize_bits = 521;\n\t\tsize_bytes = 66;\n\t\tname = \"NISTP521\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_ECDSA_SHA512) &&\n\t\t    (algo != TEE_ALG_ECDH_DERIVE_SHARED_SECRET))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_SM2:\n\t\tsize_bits = 256;\n\t\tsize_bytes = 32;\n\t\tname = \"SM2\";\n\t\tif ((algo != 0) && (algo != TEE_ALG_SM2_PKE) &&\n\t\t    (algo != TEE_ALG_SM2_DSA_SM3) &&\n\t\t    (algo != TEE_ALG_SM2_KEP))\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\tif (key_size_bytes)\n\t\t*key_size_bytes = size_bytes;\n\tif (key_size_bits)\n\t\t*key_size_bits = size_bits;\n\tif (curve_name)\n\t\t*curve_name = name;\n\treturn TEE_SUCCESS;\n}\n\n/* Note: this function clears the key before setting the curve */\nstatic TEE_Result ecc_set_curve_from_name(ecc_key *ltc_key,\n\t\t\t\t\t  const char *curve_name)\n{\n\tconst ltc_ecc_curve *curve = NULL;\n\tint ltc_res = 0;\n\n\tltc_res = ecc_find_curve(curve_name, &curve);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tltc_res = ecc_set_curve(curve, ltc_key);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_GENERIC;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result _ltc_ecc_generate_keypair(struct ecc_keypair *key,\n\t\t\t\t\t    size_t key_size)\n{\n\tTEE_Result res;\n\tecc_key ltc_tmp_key;\n\tint ltc_res;\n\tsize_t key_size_bytes = 0;\n\tsize_t key_size_bits = 0;\n\tconst char *name = NULL;\n\n\tres = ecc_get_curve_info(key->curve, 0, &key_size_bytes, &key_size_bits,\n\t\t\t\t &name);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (key_size != key_size_bits)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_set_curve_from_name(&ltc_tmp_key, name);\n\tif (res)\n\t\treturn res;\n\n\t/* Generate the ECC key */\n\tltc_res = ecc_generate_key(NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t   &ltc_tmp_key);\n\tif (ltc_res != CRYPT_OK)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* check the size of the keys */\n\tif (((size_t)mp_count_bits(ltc_tmp_key.pubkey.x) > key_size_bits) ||\n\t    ((size_t)mp_count_bits(ltc_tmp_key.pubkey.y) > key_size_bits) ||\n\t    ((size_t)mp_count_bits(ltc_tmp_key.k) > key_size_bits)) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\t/* check LTC is returning z==1 */\n\tif (mp_count_bits(ltc_tmp_key.pubkey.z) != 1) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto exit;\n\t}\n\n\t/* Copy the key */\n\tltc_mp.copy(ltc_tmp_key.k, key->d);\n\tltc_mp.copy(ltc_tmp_key.pubkey.x, key->x);\n\tltc_mp.copy(ltc_tmp_key.pubkey.y, key->y);\n\n\tres = TEE_SUCCESS;\n\nexit:\n\tecc_free(&ltc_tmp_key);\t\t/* Free the temporary key */\n\treturn res;\n}\n\n/*\n * Given a keypair \"key\", populate the Libtomcrypt private key \"ltc_key\"\n * It also returns the key size, in bytes\n */\nTEE_Result ecc_populate_ltc_private_key(ecc_key *ltc_key,\n\t\t\t\t\tstruct ecc_keypair *key,\n\t\t\t\t\tuint32_t algo, size_t *key_size_bytes)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tconst char *name = NULL;\n\n\tres = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);\n\tif (res)\n\t\treturn res;\n\n\tmemset(ltc_key, 0, sizeof(*ltc_key));\n\n\tres = ecc_set_curve_from_name(ltc_key, name);\n\tif (res)\n\t\treturn res;\n\n\tltc_key->type = PK_PRIVATE;\n\tmp_copy(key->d, ltc_key->k);\n\tmp_copy(key->x, ltc_key->pubkey.x);\n\tmp_copy(key->y, ltc_key->pubkey.y);\n\tmp_set_int(ltc_key->pubkey.z, 1);\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Given a public \"key\", populate the Libtomcrypt public key \"ltc_key\"\n * It also returns the key size, in bytes\n */\nTEE_Result ecc_populate_ltc_public_key(ecc_key *ltc_key,\n\t\t\t\t       struct ecc_public_key *key,\n\t\t\t\t       uint32_t algo, size_t *key_size_bytes)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tconst char *name = NULL;\n\tuint8_t one[1] = { 1 };\n\n\tres = ecc_get_curve_info(key->curve, algo, key_size_bytes, NULL, &name);\n\tif (res)\n\t\treturn res;\n\n\tmemset(ltc_key, 0, sizeof(*ltc_key));\n\n\tres = ecc_set_curve_from_name(ltc_key, name);\n\tif (res)\n\t\treturn res;\n\n\tltc_key->type = PK_PUBLIC;\n\n\tmp_copy(key->x, ltc_key->pubkey.x);\n\tmp_copy(key->y, ltc_key->pubkey.y);\n\tmp_read_unsigned_bin(ltc_key->pubkey.z, one, sizeof(one));\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result _ltc_ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t\tconst uint8_t *msg, size_t msg_len,\n\t\t\t\tuint8_t *sig, size_t *sig_len)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tint ltc_res = 0;\n\tsize_t key_size_bytes = 0;\n\tecc_key ltc_key = { };\n\tunsigned long ltc_sig_len = 0;\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_populate_ltc_private_key(&ltc_key, key, algo,\n\t\t\t\t\t   &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (*sig_len < 2 * key_size_bytes) {\n\t\t*sig_len = 2 * key_size_bytes;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tltc_sig_len = *sig_len;\n\tltc_res = ecc_sign_hash_rfc7518(msg, msg_len, sig, &ltc_sig_len,\n\t\t\t\t    NULL, find_prng(\"prng_crypto\"), &ltc_key);\n\tif (ltc_res == CRYPT_OK) {\n\t\tres = TEE_SUCCESS;\n\t} else {\n\t\tres = TEE_ERROR_GENERIC;\n\t}\n\t*sig_len = ltc_sig_len;\n\nout:\n\tecc_free(&ltc_key);\n\treturn res;\n}\n\nstatic TEE_Result _ltc_ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t\t  const uint8_t *msg, size_t msg_len,\n\t\t\t\t  const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tint ltc_stat = 0;\n\tint ltc_res = 0;\n\tsize_t key_size_bytes = 0;\n\tecc_key ltc_key = { };\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_populate_ltc_public_key(&ltc_key, key, algo, &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* check keysize vs sig_len */\n\tif ((key_size_bytes * 2) != sig_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tltc_res = ecc_verify_hash_rfc7518(sig, sig_len, msg, msg_len, &ltc_stat,\n\t\t\t\t\t  &ltc_key);\n\tres = convert_ltc_verify_status(ltc_res, ltc_stat);\nout:\n\tecc_free(&ltc_key);\n\treturn res;\n}\n\nstatic TEE_Result _ltc_ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t\t struct ecc_public_key *public_key,\n\t\t\t\t\t void *secret,\n\t\t\t\t\t unsigned long *secret_len)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tint ltc_res = 0;\n\tecc_key ltc_private_key = { };\n\tecc_key ltc_public_key = { };\n\tsize_t key_size_bytes = 0;\n\n\t/* Check the curves are the same */\n\tif (private_key->curve != public_key->curve)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = ecc_populate_ltc_private_key(&ltc_private_key, private_key,\n\t\t\t\t\t   0, &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = ecc_populate_ltc_public_key(&ltc_public_key, public_key,\n\t\t\t\t\t  0, &key_size_bytes);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tltc_res = ecc_shared_secret(&ltc_private_key, &ltc_public_key,\n\t\t\t\t    secret, secret_len);\n\tif (ltc_res == CRYPT_OK)\n\t\tres = TEE_SUCCESS;\n\telse\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\nout:\n\tecc_free(&ltc_private_key);\n\tecc_free(&ltc_public_key);\n\treturn res;\n}\n\nstatic const struct crypto_ecc_keypair_ops ecc_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n\t.sign = _ltc_ecc_sign,\n\t.shared_secret = _ltc_ecc_shared_secret,\n};\n\nstatic const struct crypto_ecc_public_ops ecc_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n\t.verify = _ltc_ecc_verify,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_dsa_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n\t.sign = sm2_ltc_dsa_sign,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_dsa_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n\t.verify = sm2_ltc_dsa_verify,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_pke_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n\t.decrypt = sm2_ltc_pke_decrypt,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_pke_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n\t.encrypt = sm2_ltc_pke_encrypt,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_kep_keypair_ops = {\n\t.generate = _ltc_ecc_generate_keypair,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_kep_public_key_ops = {\n\t.free = _ltc_ecc_free_public_key,\n};\n\nconst struct crypto_ecc_keypair_ops *\ncrypto_asym_get_ecc_keypair_ops( uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\treturn &ecc_keypair_ops;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn NULL;\n\t\treturn &sm2_dsa_keypair_ops;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn NULL;\n\t\treturn &sm2_pke_keypair_ops;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_keypair_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t uint32_t key_type,\n\t\t\t\t\t size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\ts->ops = &ecc_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_keypair_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\ts->ops = NULL;\n\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nconst struct crypto_ecc_public_ops*\ncrypto_asym_get_ecc_public_ops(uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\treturn &ecc_public_key_ops;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn NULL;\n\t\treturn &sm2_dsa_public_key_ops;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn NULL;\n\t\treturn &sm2_pke_public_key_ops;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_public_key_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\ts->ops = &ecc_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED2(_CFG_CORE_LTC_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_public_key_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\ts->ops = NULL;\n\n\tcrypto_bignum_free(&s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2018, Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <kernel/panic.h>\n#include <mbedtls/bignum.h>\n#include <mempool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tomcrypt_private.h>\n#include <tomcrypt_mp.h>\n#include <util.h>\n\n#if defined(_CFG_CORE_LTC_PAGER)\n#include <mm/core_mmu.h>\n#include <mm/tee_pager.h>\n#endif\n\n/* Size needed for xtest to pass reliably on both ARM32 and ARM64 */\n#define MPI_MEMPOOL_SIZE\t(46 * 1024)\n\n/* From mbedtls/library/bignum.c */\n#define ciL\t\t(sizeof(mbedtls_mpi_uint))\t/* chars in limb  */\n#define biL\t\t(ciL << 3)\t\t\t/* bits  in limb  */\n#define BITS_TO_LIMBS(i)\t((i) / biL + ((i) % biL != 0))\n\n#if defined(_CFG_CORE_LTC_PAGER)\n/* allocate pageable_zi vmem for mp scratch memory pool */\nstatic struct mempool *get_mp_scratch_memory_pool(void)\n{\n\tsize_t size;\n\tvoid *data;\n\n\tsize = ROUNDUP(MPI_MEMPOOL_SIZE, SMALL_PAGE_SIZE);\n\tdata = tee_pager_alloc(size);\n\tif (!data)\n\t\tpanic();\n\n\treturn mempool_alloc_pool(data, size, tee_pager_release_phys);\n}\n#else /* _CFG_CORE_LTC_PAGER */\nstatic struct mempool *get_mp_scratch_memory_pool(void)\n{\n\tstatic uint8_t data[MPI_MEMPOOL_SIZE] __aligned(MEMPOOL_ALIGN);\n\n\treturn mempool_alloc_pool(data, sizeof(data), NULL);\n}\n#endif\n\nvoid init_mp_tomcrypt(void)\n{\n\tstruct mempool *p = get_mp_scratch_memory_pool();\n\n\tif (!p)\n\t\tpanic();\n\tmbedtls_mpi_mempool = p;\n\tassert(!mempool_default);\n\tmempool_default = p;\n}\n\nstatic int init(void **a)\n{\n\tmbedtls_mpi *bn = mempool_alloc(mbedtls_mpi_mempool, sizeof(*bn));\n\n\tif (!bn)\n\t\treturn CRYPT_MEM;\n\n\tmbedtls_mpi_init_mempool(bn);\n\t*a = bn;\n\treturn CRYPT_OK;\n}\n\nstatic int init_size(int size_bits __unused, void **a)\n{\n\treturn init(a);\n}\n\nstatic void deinit(void *a)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)a);\n\tmempool_free(mbedtls_mpi_mempool, a);\n}\n\nstatic int neg(void *a, void *b)\n{\n\tif (mbedtls_mpi_copy(b, a))\n\t\treturn CRYPT_MEM;\n\t((mbedtls_mpi *)b)->s *= -1;\n\treturn CRYPT_OK;\n}\n\nstatic int copy(void *a, void *b)\n{\n\tif (mbedtls_mpi_copy(b, a))\n\t\treturn CRYPT_MEM;\n\treturn CRYPT_OK;\n}\n\nstatic int init_copy(void **a, void *b)\n{\n\tif (init(a) != CRYPT_OK) {\n\t\treturn CRYPT_MEM;\n\t}\n\treturn copy(b, *a);\n}\n\n/* ---- trivial ---- */\nstatic int set_int(void *a, ltc_mp_digit b)\n{\n\tuint32_t b32 = b;\n\n\tif (b32 != b)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tmbedtls_mpi_uint p = b32;\n\tmbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };\n\n\tif (mbedtls_mpi_copy(a, &bn))\n\t\treturn CRYPT_MEM;\n\treturn CRYPT_OK;\n}\n\nstatic unsigned long get_int(void *a)\n{\n\tmbedtls_mpi *bn = a;\n\n\tif (!bn->n)\n\t\treturn 0;\n\n\treturn bn->p[bn->n - 1];\n}\n\nstatic ltc_mp_digit get_digit(void *a, int n)\n{\n\tmbedtls_mpi *bn = a;\n\n\tCOMPILE_TIME_ASSERT(sizeof(ltc_mp_digit) >= sizeof(mbedtls_mpi_uint));\n\n\tif (n < 0 || (size_t)n >= bn->n)\n\t\treturn 0;\n\n\treturn bn->p[n];\n}\n\nstatic int get_digit_count(void *a)\n{\n\treturn ROUNDUP(mbedtls_mpi_size(a), sizeof(mbedtls_mpi_uint)) /\n\t       sizeof(mbedtls_mpi_uint);\n}\n\nstatic int compare(void *a, void *b)\n{\n\tint ret = mbedtls_mpi_cmp_mpi(a, b);\n\n\tif (ret < 0)\n\t\treturn LTC_MP_LT;\n\n\tif (ret > 0)\n\t\treturn LTC_MP_GT;\n\n\treturn LTC_MP_EQ;\n}\n\nstatic int compare_d(void *a, ltc_mp_digit b)\n{\n\tunsigned long v = b;\n\tunsigned int shift = 31;\n\tuint32_t mask = BIT(shift) - 1;\n\tmbedtls_mpi bn;\n\n\tmbedtls_mpi_init_mempool(&bn);\n\twhile (true) {\n\t\tmbedtls_mpi_add_int(&bn, &bn, v & mask);\n\t\tv >>= shift;\n\t\tif (!v)\n\t\t\tbreak;\n\t\tmbedtls_mpi_shift_l(&bn, shift);\n\t}\n\n\tint ret = compare(a, &bn);\n\n\tmbedtls_mpi_free(&bn);\n\n\treturn ret;\n}\n\nstatic int count_bits(void *a)\n{\n\treturn mbedtls_mpi_bitlen(a);\n}\n\nstatic int count_lsb_bits(void *a)\n{\n\treturn mbedtls_mpi_lsb(a);\n}\n\n\nstatic int twoexpt(void *a, int n)\n{\n\tif (mbedtls_mpi_set_bit(a, n, 1))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* ---- conversions ---- */\n\n/* read ascii string */\nstatic int read_radix(void *a, const char *b, int radix)\n{\n\tint res = mbedtls_mpi_read_string(a, radix, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* write one */\nstatic int write_radix(void *a, char *b, int radix)\n{\n\tsize_t ol = SIZE_MAX;\n\tint res = mbedtls_mpi_write_string(a, radix, b, ol, &ol);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* get size as unsigned char string */\nstatic unsigned long unsigned_size(void *a)\n{\n\treturn mbedtls_mpi_size(a);\n}\n\n/* store */\nstatic int unsigned_write(void *a, unsigned char *b)\n{\n\tint res = mbedtls_mpi_write_binary(a, b, unsigned_size(a));\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* read */\nstatic int unsigned_read(void *a, unsigned char *b, unsigned long len)\n{\n\tint res = mbedtls_mpi_read_binary(a, b, len);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n/* add */\nstatic int add(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_add_mpi(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nstatic int addi(void *a, ltc_mp_digit b, void *c)\n{\n\tuint32_t b32 = b;\n\n\tif (b32 != b)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tmbedtls_mpi_uint p = b32;\n\tmbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };\n\n\treturn add(a, &bn, c);\n}\n\n/* sub */\nstatic int sub(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_sub_mpi(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nstatic int subi(void *a, ltc_mp_digit b, void *c)\n{\n\tuint32_t b32 = b;\n\n\tif (b32 != b)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tmbedtls_mpi_uint p = b32;\n\tmbedtls_mpi bn = { .s = 1, .n = 1, .p = &p };\n\n\treturn sub(a, &bn, c);\n}\n\n/* mul */\nstatic int mul(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_mul_mpi(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nstatic int muli(void *a, ltc_mp_digit b, void *c)\n{\n\tif (b > (unsigned long) UINT32_MAX)\n\t\treturn CRYPT_INVALID_ARG;\n\n\tif (mbedtls_mpi_mul_int(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* sqr */\nstatic int sqr(void *a, void *b)\n{\n\treturn mul(a, a, b);\n}\n\n/* div */\nstatic int divide(void *a, void *b, void *c, void *d)\n{\n\tint res = mbedtls_mpi_div_mpi(c, d, a, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\nstatic int div_2(void *a, void *b)\n{\n\tif (mbedtls_mpi_copy(b, a))\n\t\treturn CRYPT_MEM;\n\n\tif (mbedtls_mpi_shift_r(b, 1))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* modi */\nstatic int modi(void *a, ltc_mp_digit b, ltc_mp_digit *c)\n{\n\tmbedtls_mpi bn_b;\n\tmbedtls_mpi bn_c;\n\tint res = 0;\n\n\tmbedtls_mpi_init_mempool(&bn_b);\n\tmbedtls_mpi_init_mempool(&bn_c);\n\n\tres = set_int(&bn_b, b);\n\tif (res)\n\t\treturn res;\n\n\tres = mbedtls_mpi_mod_mpi(&bn_c, &bn_b, a);\n\tif (!res)\n\t\t*c = get_int(&bn_c);\n\n\tmbedtls_mpi_free(&bn_b);\n\tmbedtls_mpi_free(&bn_c);\n\n\tif (res)\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* gcd */\nstatic int gcd(void *a, void *b, void *c)\n{\n\tif (mbedtls_mpi_gcd(c, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* lcm */\nstatic int lcm(void *a, void *b, void *c)\n{\n\tint res = CRYPT_MEM;\n\tmbedtls_mpi tmp;\n\n\tmbedtls_mpi_init_mempool(&tmp);\n\tif (mbedtls_mpi_mul_mpi(&tmp, a, b))\n\t\tgoto out;\n\n\tif (mbedtls_mpi_gcd(c, a, b))\n\t\tgoto out;\n\n\t/* We use the following equality: gcd(a, b) * lcm(a, b) = a * b */\n\tres = divide(&tmp, c, c, NULL);\nout:\n\tmbedtls_mpi_free(&tmp);\n\treturn res;\n}\n\nstatic int mod(void *a, void *b, void *c)\n{\n\tint res = mbedtls_mpi_mod_mpi(c, a, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\nstatic int addmod(void *a, void *b, void *c, void *d)\n{\n\tint res = add(a, b, d);\n\n\tif (res)\n\t\treturn res;\n\n\treturn mod(d, c, d);\n}\n\nstatic int submod(void *a, void *b, void *c, void *d)\n{\n\tint res = sub(a, b, d);\n\n\tif (res)\n\t\treturn res;\n\n\treturn mod(d, c, d);\n}\n\nstatic int mulmod(void *a, void *b, void *c, void *d)\n{\n\tint res;\n\tmbedtls_mpi ta;\n\tmbedtls_mpi tb;\n\n\tmbedtls_mpi_init_mempool(&ta);\n\tmbedtls_mpi_init_mempool(&tb);\n\n\tres = mod(a, c, &ta);\n\tif (res)\n\t\tgoto out;\n\tres = mod(b, c, &tb);\n\tif (res)\n\t\tgoto out;\n\tres = mul(&ta, &tb, d);\n\tif (res)\n\t\tgoto out;\n\tres = mod(d, c, d);\nout:\n\tmbedtls_mpi_free(&ta);\n\tmbedtls_mpi_free(&tb);\n\treturn res;\n}\n\nstatic int sqrmod(void *a, void *b, void *c)\n{\n\treturn mulmod(a, a, b, c);\n}\n\n/* invmod */\nstatic int invmod(void *a, void *b, void *c)\n{\n\tint res = mbedtls_mpi_inv_mod(c, a, b);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\tif (res)\n\t\treturn CRYPT_ERROR;\n\n\treturn CRYPT_OK;\n}\n\n\n/* setup */\nstatic int montgomery_setup(void *a, void **b)\n{\n\t*b = mempool_alloc(mbedtls_mpi_mempool, sizeof(mbedtls_mpi_uint));\n\tif (!*b)\n\t\treturn CRYPT_MEM;\n\n\tmbedtls_mpi_montg_init(*b, a);\n\n\treturn CRYPT_OK;\n}\n\n/* get normalization value */\nstatic int montgomery_normalization(void *a, void *b)\n{\n\tsize_t c = ROUNDUP(mbedtls_mpi_size(b), sizeof(mbedtls_mpi_uint)) * 8;\n\n\tif (mbedtls_mpi_lset(a, 1))\n\t\treturn CRYPT_MEM;\n\tif (mbedtls_mpi_shift_l(a, c))\n\t\treturn CRYPT_MEM;\n\tif (mbedtls_mpi_mod_mpi(a, a, b))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\n/* reduce */\nstatic int montgomery_reduce(void *a, void *b, void *c)\n{\n\tmbedtls_mpi A;\n\tmbedtls_mpi *N = b;\n\tmbedtls_mpi_uint *mm = c;\n\tmbedtls_mpi T;\n\tint ret = CRYPT_MEM;\n\n\tmbedtls_mpi_init_mempool(&T);\n\tmbedtls_mpi_init_mempool(&A);\n\n\tif (mbedtls_mpi_grow(&T, (N->n + 1) * 2))\n\t\tgoto out;\n\n\tif (mbedtls_mpi_cmp_mpi(a, N) > 0) {\n\t\tif (mbedtls_mpi_mod_mpi(&A, a, N))\n\t\t\tgoto out;\n\t} else {\n\t\tif (mbedtls_mpi_copy(&A, a))\n\t\t\tgoto out;\n\t}\n\n\tif (mbedtls_mpi_grow(&A, N->n + 1))\n\t\tgoto out;\n\n\tmbedtls_mpi_montred(&A, N, *mm, &T);\n\n\tif (mbedtls_mpi_copy(a, &A))\n\t\tgoto out;\n\n\tret = CRYPT_OK;\nout:\n\tmbedtls_mpi_free(&A);\n\tmbedtls_mpi_free(&T);\n\n\treturn ret;\n}\n\n/* clean up */\nstatic void montgomery_deinit(void *a)\n{\n\tmempool_free(mbedtls_mpi_mempool, a);\n}\n\n/*\n * This function calculates:\n *  d = a^b mod c\n *\n * @a: base\n * @b: exponent\n * @c: modulus\n * @d: destination\n */\nstatic int exptmod(void *a, void *b, void *c, void *d)\n{\n\tint res;\n\n\tif (d == a || d == b || d == c) {\n\t\tmbedtls_mpi dest;\n\n\t\tmbedtls_mpi_init_mempool(&dest);\n\t\tres = mbedtls_mpi_exp_mod(&dest, a, b, c, NULL);\n\t\tif (!res)\n\t\t\tres = mbedtls_mpi_copy(d, &dest);\n\t\tmbedtls_mpi_free(&dest);\n\t} else {\n\t\tres = mbedtls_mpi_exp_mod(d, a, b, c, NULL);\n\t}\n\n\tif (res)\n\t\treturn CRYPT_MEM;\n\telse\n\t\treturn CRYPT_OK;\n}\n\nstatic int rng_read(void *ignored __unused, unsigned char *buf, size_t blen)\n{\n\tif (crypto_rng_read(buf, blen))\n\t\treturn MBEDTLS_ERR_MPI_FILE_IO_ERROR;\n\treturn 0;\n}\n\nstatic int isprime(void *a, int b __unused, int *c)\n{\n\tint res = mbedtls_mpi_is_prime(a, rng_read, NULL);\n\n\tif (res == MBEDTLS_ERR_MPI_ALLOC_FAILED)\n\t\treturn CRYPT_MEM;\n\n\tif (res)\n\t\t*c = LTC_MP_NO;\n\telse\n\t\t*c = LTC_MP_YES;\n\n\treturn CRYPT_OK;\n}\n\nstatic int mpi_rand(void *a, int size)\n{\n\tif (mbedtls_mpi_fill_random(a, size, rng_read, NULL))\n\t\treturn CRYPT_MEM;\n\n\treturn CRYPT_OK;\n}\n\nltc_math_descriptor ltc_mp = {\n\t.name = \"MPI\",\n\t.bits_per_digit = sizeof(mbedtls_mpi_uint) * 8,\n\n\t.init = init,\n\t.init_size = init_size,\n\t.init_copy = init_copy,\n\t.deinit = deinit,\n\n\t.neg = neg,\n\t.copy = copy,\n\n\t.set_int = set_int,\n\t.get_int = get_int,\n\t.get_digit = get_digit,\n\t.get_digit_count = get_digit_count,\n\t.compare = compare,\n\t.compare_d = compare_d,\n\t.count_bits = count_bits,\n\t.count_lsb_bits = count_lsb_bits,\n\t.twoexpt = twoexpt,\n\n\t.read_radix = read_radix,\n\t.write_radix = write_radix,\n\t.unsigned_size = unsigned_size,\n\t.unsigned_write = unsigned_write,\n\t.unsigned_read = unsigned_read,\n\n\t.add = add,\n\t.addi = addi,\n\t.sub = sub,\n\t.subi = subi,\n\t.mul = mul,\n\t.muli = muli,\n\t.sqr = sqr,\n\t.mpdiv = divide,\n\t.div_2 = div_2,\n\t.modi = modi,\n\t.gcd = gcd,\n\t.lcm = lcm,\n\n\t.mulmod = mulmod,\n\t.sqrmod = sqrmod,\n\t.invmod = invmod,\n\n\t.montgomery_setup = montgomery_setup,\n\t.montgomery_normalization = montgomery_normalization,\n\t.montgomery_reduce = montgomery_reduce,\n\t.montgomery_deinit = montgomery_deinit,\n\n\t.exptmod = exptmod,\n\t.isprime = isprime,\n\n#ifdef LTC_MECC\n#ifdef LTC_MECC_FP\n\t.ecc_ptmul = ltc_ecc_fp_mulmod,\n#else\n\t.ecc_ptmul = ltc_ecc_mulmod,\n#endif /* LTC_MECC_FP */\n\t.ecc_ptadd = ltc_ecc_projective_add_point,\n\t.ecc_ptdbl = ltc_ecc_projective_dbl_point,\n\t.ecc_map = ltc_ecc_map,\n#ifdef LTC_ECC_SHAMIR\n#ifdef LTC_MECC_FP\n\t.ecc_mul2add = ltc_ecc_fp_mul2add,\n#else\n\t.ecc_mul2add = ltc_ecc_mul2add,\n#endif /* LTC_MECC_FP */\n#endif /* LTC_ECC_SHAMIR */\n#endif /* LTC_MECC */\n\n#ifdef LTC_MRSA\n\t.rsa_keygen = rsa_make_key,\n\t.rsa_me = rsa_exptmod,\n#endif\n\t.addmod = addmod,\n\t.submod = submod,\n\t.rand = mpi_rand,\n\n};\n\nsize_t crypto_bignum_num_bytes(struct bignum *a)\n{\n\treturn mbedtls_mpi_size((mbedtls_mpi *)a);\n}\n\nsize_t crypto_bignum_num_bits(struct bignum *a)\n{\n\treturn mbedtls_mpi_bitlen((mbedtls_mpi *)a);\n}\n\nint32_t crypto_bignum_compare(struct bignum *a, struct bignum *b)\n{\n\treturn mbedtls_mpi_cmp_mpi((mbedtls_mpi *)a, (mbedtls_mpi *)b);\n}\n\nvoid crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to)\n{\n\tconst mbedtls_mpi *f = (const mbedtls_mpi *)from;\n\tint rc __maybe_unused = 0;\n\n\trc = mbedtls_mpi_write_binary(f, (void *)to, mbedtls_mpi_size(f));\n\tassert(!rc);\n}\n\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,\n\t\t\t struct bignum *to)\n{\n\tif (mbedtls_mpi_read_binary((mbedtls_mpi *)to, (const void *)from,\n\t\t\t\t    fromsize))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nvoid crypto_bignum_copy(struct bignum *to, const struct bignum *from)\n{\n\tint rc __maybe_unused = 0;\n\n\trc = mbedtls_mpi_copy((mbedtls_mpi *)to, (const mbedtls_mpi *)from);\n\tassert(!rc);\n}\n\nstruct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tmbedtls_mpi *bn = malloc(sizeof(*bn));\n\n\tif (!bn)\n\t\treturn NULL;\n\n\tmbedtls_mpi_init(bn);\n\tif (mbedtls_mpi_grow(bn, BITS_TO_LIMBS(size_bits))) {\n\t\tfree(bn);\n\t\treturn NULL;\n\t}\n\n\treturn (struct bignum *)bn;\n}\n\nvoid crypto_bignum_free(struct bignum **s)\n{\n\tassert(s);\n\n\tmbedtls_mpi_free((mbedtls_mpi *)*s);\n\tfree(*s);\n\t*s = NULL;\n}\n\nvoid crypto_bignum_clear(struct bignum *s)\n{\n\tmbedtls_mpi *bn = (mbedtls_mpi *)s;\n\n\tbn->s = 1;\n\tif (bn->p)\n\t\tmemset(bn->p, 0, sizeof(*bn->p) * bn->n);\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014-2019, 2022 Linaro Limited\n */\n\n#include <crypto/crypto.h>\n#include <crypto/crypto_impl.h>\n#include <fault_mitigation.h>\n#include <mempool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee_api_defines_extensions.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <trace.h>\n#include <utee_defines.h>\n\n#include \"acipher_helpers.h\"\n\n\n/*\n * Compute the LibTomCrypt \"hashindex\" given a TEE Algorithm \"algo\"\n * Return\n * - TEE_SUCCESS in case of success,\n * - TEE_ERROR_BAD_PARAMETERS in case algo is not a valid algo\n * - TEE_ERROR_NOT_SUPPORTED in case algo is not supported by LTC\n * Return -1 in case of error\n */\nstatic TEE_Result tee_algo_to_ltc_hashindex(uint32_t algo, int *ltc_hashindex)\n{\n\tswitch (algo) {\n#if defined(_CFG_CORE_LTC_SHA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\t\t*ltc_hashindex = find_hash(\"sha1\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_MD5)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_MD5:\n\t\t*ltc_hashindex = find_hash(\"md5\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA224)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\t\t*ltc_hashindex = find_hash(\"sha224\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA256)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\t\t*ltc_hashindex = find_hash(\"sha256\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA384)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\t\t*ltc_hashindex = find_hash(\"sha384\");\n\t\tbreak;\n#endif\n#if defined(_CFG_CORE_LTC_SHA512)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\t*ltc_hashindex = find_hash(\"sha512\");\n\t\tbreak;\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\t\t/* invalid one. but it should not be used anyway */\n\t\t*ltc_hashindex = -1;\n\t\treturn TEE_SUCCESS;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tif (*ltc_hashindex < 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\telse\n\t\treturn TEE_SUCCESS;\n}\n\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_keypair\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_acipher_free_rsa_keypair(s);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n\nTEE_Result crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_public_key\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t\t  size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->e);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\n\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_public_key\");\n\nvoid sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->e);\n}\n\n\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_keypair\");\n\nvoid sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n}\n\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t      size_t key_size)\n__weak __alias(\"sw_crypto_acipher_gen_rsa_key\");\n\nTEE_Result sw_crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t\t size_t key_size)\n{\n\tTEE_Result res;\n\trsa_key ltc_tmp_key;\n\tint ltc_res;\n\n\t/* Generate a temporary RSA key */\n\tltc_res = rsa_make_key_bn_e(NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t    key_size / 8, key->e, &ltc_tmp_key);\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else if ((size_t)mp_count_bits(ltc_tmp_key.N) != key_size) {\n\t\trsa_free(&ltc_tmp_key);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\t/* Copy the key */\n\t\tltc_mp.copy(ltc_tmp_key.d,  key->d);\n\t\tltc_mp.copy(ltc_tmp_key.N,  key->n);\n\t\tltc_mp.copy(ltc_tmp_key.p,  key->p);\n\t\tltc_mp.copy(ltc_tmp_key.q,  key->q);\n\t\tltc_mp.copy(ltc_tmp_key.qP, key->qp);\n\t\tltc_mp.copy(ltc_tmp_key.dP, key->dp);\n\t\tltc_mp.copy(ltc_tmp_key.dQ, key->dq);\n\n\t\t/* Free the temporary key */\n\t\trsa_free(&ltc_tmp_key);\n\t\tres = TEE_SUCCESS;\n\t}\n\n\treturn res;\n}\n\nstatic TEE_Result rsadorep(rsa_key *ltc_key, const uint8_t *src,\n\t\t\t   size_t src_len, uint8_t *dst, size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tuint8_t *buf = NULL;\n\tunsigned long blen, offset;\n\tint ltc_res;\n\n\t/*\n\t * Use a temporary buffer since we don't know exactly how large the\n\t * required size of the out buffer without doing a partial decrypt.\n\t * We know the upper bound though.\n\t */\n\tblen = _CFG_CORE_LTC_BIGNUM_MAX_BITS / sizeof(uint8_t);\n\tbuf = mempool_alloc(mempool_default, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tltc_res = rsa_exptmod(src, src_len, buf, &blen, ltc_key->type,\n\t\t\t      ltc_key);\n\tswitch (ltc_res) {\n\tcase CRYPT_PK_NOT_PRIVATE:\n\tcase CRYPT_PK_INVALID_TYPE:\n\tcase CRYPT_PK_INVALID_SIZE:\n\tcase CRYPT_INVALID_PACKET:\n\t\tEMSG(\"rsa_exptmod() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\tcase CRYPT_OK:\n\t\tbreak;\n\tdefault:\n\t\t/* This will result in a panic */\n\t\tEMSG(\"rsa_exptmod() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < blen - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < blen - offset) {\n\t\t*dst_len = blen - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = TEE_SUCCESS;\n\t*dst_len = blen - offset;\n\tmemcpy(dst, (char *)buf + offset, *dst_len);\n\nout:\n\tmempool_free(mempool_default, buf);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PUBLIC;\n\tltc_key.e = key->e;\n\tltc_key.N = key->n;\n\n\tres = rsadorep(&ltc_key, src, src_len, dst, dst_len);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PRIVATE;\n\tltc_key.e = key->e;\n\tltc_key.N = key->n;\n\tltc_key.d = key->d;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\tltc_key.p = key->p;\n\t\tltc_key.q = key->q;\n\t\tltc_key.qP = key->qp;\n\t\tltc_key.dP = key->dp;\n\t\tltc_key.dQ = key->dq;\n\t}\n\n\tres = rsadorep(&ltc_key, src, src_len, dst, dst_len);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_keypair *key,\n\t\t\t\t\tconst uint8_t *label,\n\t\t\t\t\tsize_t label_len, const uint8_t *src,\n\t\t\t\t\tsize_t src_len, uint8_t *dst,\n\t\t\t\t\tsize_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *label,\n\t\t\t\t\t   size_t label_len, const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tvoid *buf = NULL;\n\tunsigned long blen;\n\tint ltc_hashindex, ltc_res, ltc_stat, ltc_rsa_algo;\n\tsize_t mod_size;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PRIVATE;\n\tltc_key.e = key->e;\n\tltc_key.d = key->d;\n\tltc_key.N = key->n;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\tltc_key.p = key->p;\n\t\tltc_key.q = key->q;\n\t\tltc_key.qP = key->qp;\n\t\tltc_key.dP = key->dp;\n\t\tltc_key.dQ = key->dq;\n\t}\n\n\t/* Get the algorithm */\n\tres = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\tif (res != TEE_SUCCESS) {\n\t\tEMSG(\"tee_algo_to_ltc_hashindex() returned %d\", (int)res);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Use a temporary buffer since we don't know exactly how large\n\t * the required size of the out buffer without doing a partial\n\t * decrypt. We know the upper bound though.\n\t */\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));\n\t\tblen = mod_size - 11;\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\t} else {\n\t\t/* Decoded message is always shorter than encrypted message */\n\t\tblen = src_len;\n\t\tltc_rsa_algo = LTC_PKCS_1_OAEP;\n\t}\n\n\tbuf = mempool_alloc(mempool_default, blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tltc_res = rsa_decrypt_key_ex(src, src_len, buf, &blen,\n\t\t\t\t     ((label_len == 0) ? 0 : label), label_len,\n\t\t\t\t     ltc_hashindex, ltc_rsa_algo, &ltc_stat,\n\t\t\t\t     &ltc_key);\n\tswitch (ltc_res) {\n\tcase CRYPT_PK_INVALID_PADDING:\n\tcase CRYPT_INVALID_PACKET:\n\tcase CRYPT_PK_INVALID_SIZE:\n\t\tEMSG(\"rsa_decrypt_key_ex() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\tcase CRYPT_OK:\n\t\tbreak;\n\tdefault:\n\t\t/* This will result in a panic */\n\t\tEMSG(\"rsa_decrypt_key_ex() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\tif (ltc_stat != 1) {\n\t\t/* This will result in a panic */\n\t\tEMSG(\"rsa_decrypt_key_ex() returned %d and %d\",\n\t\t     ltc_res, ltc_stat);\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tif (*dst_len < blen) {\n\t\t*dst_len = blen;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = TEE_SUCCESS;\n\t*dst_len = blen;\n\tmemcpy(dst, buf, blen);\n\nout:\n\tmempool_free(mempool_default, buf);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tconst uint8_t *label,\n\t\t\t\t\tsize_t label_len, const uint8_t *src,\n\t\t\t\t\tsize_t src_len, uint8_t *dst,\n\t\t\t\t\tsize_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *label,\n\t\t\t\t\t   size_t label_len, const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n{\n\tTEE_Result res;\n\tuint32_t mod_size;\n\tint ltc_hashindex, ltc_res, ltc_rsa_algo;\n\trsa_key ltc_key = {\n\t\t.type = PK_PUBLIC,\n\t\t.e = key->e,\n\t\t.N = key->n\n\t};\n\n\tmod_size =  ltc_mp.unsigned_size((void *)(ltc_key.N));\n\tif (*dst_len < mod_size) {\n\t\t*dst_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = mod_size;\n\n\t/* Get the algorithm */\n\tres = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5)\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\telse\n\t\tltc_rsa_algo = LTC_PKCS_1_OAEP;\n\n\tltc_res = rsa_encrypt_key_ex(src, src_len, dst,\n\t\t\t\t     (unsigned long *)(dst_len), label,\n\t\t\t\t     label_len, NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t     ltc_hashindex, ltc_rsa_algo, &ltc_key);\n\tswitch (ltc_res) {\n\tcase CRYPT_PK_INVALID_PADDING:\n\tcase CRYPT_INVALID_PACKET:\n\tcase CRYPT_PK_INVALID_SIZE:\n\t\tEMSG(\"rsa_encrypt_key_ex() returned %d\", ltc_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\tcase CRYPT_OK:\n\t\tbreak;\n\tdefault:\n\t\t/* This will result in a panic */\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\tres = TEE_SUCCESS;\n\nout:\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t      int salt_len, const uint8_t *msg,\n\t\t\t\t      size_t msg_len, uint8_t *sig,\n\t\t\t\t      size_t *sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_sign\");\n\nTEE_Result sw_crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t\t int salt_len, const uint8_t *msg,\n\t\t\t\t\t size_t msg_len, uint8_t *sig,\n\t\t\t\t\t size_t *sig_len)\n{\n\tTEE_Result res;\n\tsize_t hash_size, mod_size;\n\tint ltc_res, ltc_rsa_algo, ltc_hashindex;\n\tunsigned long ltc_sig_len;\n\trsa_key ltc_key = { 0, };\n\n\tltc_key.type = PK_PRIVATE;\n\tltc_key.e = key->e;\n\tltc_key.N = key->n;\n\tltc_key.d = key->d;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\tltc_key.p = key->p;\n\t\tltc_key.q = key->q;\n\t\tltc_key.qP = key->qp;\n\t\tltc_key.dP = key->dp;\n\t\tltc_key.dQ = key->dq;\n\t}\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5_NA1;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_PSS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tif (ltc_rsa_algo != LTC_PKCS_1_V1_5_NA1) {\n\t\tltc_res = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\t\tif (ltc_res != CRYPT_OK) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t\t      &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto err;\n\n\t\tif (msg_len != hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmod_size = ltc_mp.unsigned_size((void *)(ltc_key.N));\n\n\tif (*sig_len < mod_size) {\n\t\t*sig_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto err;\n\t}\n\n\tltc_sig_len = mod_size;\n\n\tltc_res = rsa_sign_hash_ex(msg, msg_len, sig, &ltc_sig_len,\n\t\t\t\t   ltc_rsa_algo, NULL, find_prng(\"prng_crypto\"),\n\t\t\t\t   ltc_hashindex, salt_len, &ltc_key);\n\n\t*sig_len = ltc_sig_len;\n\n\tif (ltc_res != CRYPT_OK) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\tres = TEE_SUCCESS;\n\nerr:\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tint salt_len, const uint8_t *msg,\n\t\t\t\t\tsize_t msg_len, const uint8_t *sig,\n\t\t\t\t\tsize_t sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_verify\");\n\nTEE_Result sw_crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   int salt_len, const uint8_t *msg,\n\t\t\t\t\t   size_t msg_len, const uint8_t *sig,\n\t\t\t\t\t   size_t sig_len)\n{\n\tTEE_Result res;\n\tuint32_t bigint_size;\n\tsize_t hash_size;\n\tint stat, ltc_hashindex, ltc_res, ltc_rsa_algo;\n\trsa_key ltc_key = {\n\t\t.type = PK_PUBLIC,\n\t\t.e = key->e,\n\t\t.N = key->n\n\t};\n\tstruct ftmn   ftmn = { };\n\n\t/*\n\t * The caller expects to call crypto_acipher_rsassa_verify(),\n\t * update the hash as needed.\n\t */\n\tFTMN_CALLEE_SWAP_HASH(FTMN_FUNC_HASH(\"crypto_acipher_rsassa_verify\"));\n\n\tif (algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t\t      &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto err;\n\n\t\tif (msg_len != hash_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tbigint_size = ltc_mp.unsigned_size(ltc_key.N);\n\tif (sig_len < bigint_size) {\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\t\tgoto err;\n\t}\n\n\t/* Get the algorithm */\n\tif (algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\tres = tee_algo_to_ltc_hashindex(algo, &ltc_hashindex);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto err;\n\t}\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5_NA1;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_V1_5;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tltc_rsa_algo = LTC_PKCS_1_PSS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tFTMN_PUSH_LINKED_CALL(&ftmn, FTMN_FUNC_HASH(\"rsa_verify_hash_ex\"));\n\tltc_res = rsa_verify_hash_ex(sig, sig_len, msg, msg_len, ltc_rsa_algo,\n\t\t\t\t     ltc_hashindex, salt_len, &stat, &ltc_key);\n\tres = convert_ltc_verify_status(ltc_res, stat);\n\tif (res)\n\t\tFTMN_SET_CHECK_RES_NOT_ZERO(&ftmn, FTMN_INCR0, res);\n\telse\n\t\tFTMN_SET_CHECK_RES_FROM_CALL(&ftmn, FTMN_INCR0, 0);\n\tFTMN_POP_LINKED_CALL(&ftmn);\n\tFTMN_CALLEE_DONE_CHECK(&ftmn, FTMN_INCR0, FTMN_STEP_COUNT(1), res);\n\treturn res;\nerr:\n\tFTMN_CALLEE_DONE_NOT_ZERO(res);\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n * Copyright (c) 2020, 2022 Linaro Limited\n * Copyright (c) 2022, Technology Innovation Institute (TII)\n */\n\n#include <assert.h>\n#include <bitstring.h>\n#include <compiler.h>\n#include <config.h>\n#include <crypto/crypto.h>\n#include <kernel/tee_ta_manager.h>\n#include <kernel/user_access.h>\n#include <memtag.h>\n#include <mm/vm.h>\n#include <stdlib_ext.h>\n#include <string_ext.h>\n#include <string.h>\n#include <sys/queue.h>\n#include <tee_api_defines_extensions.h>\n#include <tee_api_types.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/tee_obj.h>\n#include <tee/tee_svc_cryp.h>\n#include <tee/tee_svc.h>\n#include <trace.h>\n#include <utee_defines.h>\n#include <util.h>\n#if defined(CFG_CRYPTO_HKDF)\n#include <tee/tee_cryp_hkdf.h>\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n#include <tee/tee_cryp_concat_kdf.h>\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n#include <tee/tee_cryp_pbkdf2.h>\n#endif\n\nenum cryp_state {\n\tCRYP_STATE_INITIALIZED = 0,\n\tCRYP_STATE_UNINITIALIZED\n};\n\ntypedef void (*tee_cryp_ctx_finalize_func_t) (void *ctx);\nstruct tee_cryp_state {\n\tTAILQ_ENTRY(tee_cryp_state) link;\n\tuint32_t algo;\n\tuint32_t mode;\n\tvaddr_t key1;\n\tvaddr_t key2;\n\tvoid *ctx;\n\ttee_cryp_ctx_finalize_func_t ctx_finalize;\n\tenum cryp_state state;\n};\n\nstruct tee_cryp_obj_secret {\n\tuint32_t key_size;\n\tuint32_t alloc_size;\n\n\t/*\n\t * Pseudo code visualize layout of structure\n\t * Next follows data, such as:\n\t *\tuint8_t data[alloc_size]\n\t * key_size must never exceed alloc_size\n\t */\n};\n\n#define TEE_TYPE_ATTR_OPTIONAL\t\tBIT(0)\n#define TEE_TYPE_ATTR_REQUIRED\t\tBIT(1)\n#define TEE_TYPE_ATTR_OPTIONAL_GROUP\tBIT(2)\n#define TEE_TYPE_ATTR_SIZE_INDICATOR\tBIT(3)\n#define TEE_TYPE_ATTR_GEN_KEY_OPT\tBIT(4)\n#define TEE_TYPE_ATTR_GEN_KEY_REQ\tBIT(5)\n#define TEE_TYPE_ATTR_BIGNUM_MAXBITS\tBIT(6)\n\n    /* Handle storing of generic secret keys of varying lengths */\n#define ATTR_OPS_INDEX_SECRET     0\n    /* Convert to/from big-endian byte array and provider-specific bignum */\n#define ATTR_OPS_INDEX_BIGNUM     1\n    /* Convert to/from value attribute depending on direction */\n#define ATTR_OPS_INDEX_VALUE      2\n    /* Convert to/from curve25519 attribute depending on direction */\n#define ATTR_OPS_INDEX_25519      3\n\n    /* Curve25519 key bytes size is always 32 bytes*/\n#define KEY_SIZE_BYTES_25519 UL(32)\n    /* TEE Internal Core API v1.3.1, Table 6-8 */\n#define TEE_ED25519_CTX_MAX_LENGTH 255\n\nstruct tee_cryp_obj_type_attrs {\n\tuint32_t attr_id;\n\tuint16_t flags;\n\tuint16_t ops_index;\n\tuint16_t raw_offs;\n\tuint16_t raw_size;\n};\n\n#define RAW_DATA(_x, _y)\t\\\n\t.raw_offs = offsetof(_x, _y), .raw_size = MEMBER_SIZE(_x, _y)\n\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_secret_value_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_SECRET_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_public_key, e)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_rsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_RSA_MODULUS,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, n)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PUBLIC_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, e)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIVATE_EXPONENT,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_PRIME2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT1,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dp)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_EXPONENT2,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, dq)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_RSA_COEFFICIENT,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct rsa_keypair, qp)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS |\n\t\t TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dsa_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ |\n\t\t TEE_TYPE_ATTR_BIGNUM_MAXBITS | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ |\n\t\t TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DSA_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_BIGNUM_MAXBITS,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dsa_keypair, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_dh_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIME,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, p)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_BASE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, g)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_SUBPRIME,\n\t.flags = TEE_TYPE_ATTR_OPTIONAL_GROUP |\t TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct dh_keypair, q)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_DH_X_BITS,\n\t.flags = TEE_TYPE_ATTR_GEN_KEY_OPT,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct dh_keypair, xbits)\n\t},\n};\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_hkdf_ikm_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_HKDF_IKM,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_concat_kdf_z_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_CONCAT_KDF_Z,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic const struct tee_cryp_obj_type_attrs\n\ttee_cryp_obj_pbkdf2_passwd_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_PBKDF2_PASSWORD,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_SECRET,\n\t.raw_offs = 0,\n\t.raw_size = 0\n\t},\n};\n#endif\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_public_key, curve)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_ecc_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, y)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_CURVE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED | TEE_TYPE_ATTR_SIZE_INDICATOR |\n\t\t TEE_TYPE_ATTR_GEN_KEY_REQ,\n\t.ops_index = ATTR_OPS_INDEX_VALUE,\n\tRAW_DATA(struct ecc_keypair, curve)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_sm2_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_public_key, y)\n\t},\n};\n\nstatic const struct tee_cryp_obj_type_attrs tee_cryp_obj_sm2_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ECC_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, d)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_X,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, x)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ECC_PUBLIC_VALUE_Y,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_BIGNUM,\n\tRAW_DATA(struct ecc_keypair, y)\n\t},\n};\n\nstatic\nconst struct tee_cryp_obj_type_attrs tee_cryp_obj_x25519_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_X25519_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct x25519_keypair, priv)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_X25519_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct x25519_keypair, pub)\n\t},\n};\n\nstatic\nconst struct tee_cryp_obj_type_attrs tee_cryp_obj_ed25519_pub_key_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ED25519_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct ed25519_public_key, pub)\n\t},\n};\n\nstatic\nconst struct tee_cryp_obj_type_attrs tee_cryp_obj_ed25519_keypair_attrs[] = {\n\t{\n\t.attr_id = TEE_ATTR_ED25519_PRIVATE_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct ed25519_keypair, priv)\n\t},\n\n\t{\n\t.attr_id = TEE_ATTR_ED25519_PUBLIC_VALUE,\n\t.flags = TEE_TYPE_ATTR_REQUIRED,\n\t.ops_index = ATTR_OPS_INDEX_25519,\n\tRAW_DATA(struct ed25519_keypair, pub)\n\t},\n};\n\nstruct tee_cryp_obj_type_props {\n\tTEE_ObjectType obj_type;\n\tuint16_t min_size;\t/* may not be smaller than this */\n\tuint16_t max_size;\t/* may not be larger than this */\n\tuint16_t alloc_size;\t/* this many bytes are allocated to hold data */\n\tuint8_t quanta;\t\t/* may only be an multiple of this */\n\n\tuint8_t num_type_attrs;\n\tconst struct tee_cryp_obj_type_attrs *type_attrs;\n};\n\n#define PROP(obj_type, quanta, min_size, max_size, alloc_size, type_attrs) \\\n\t\t{ (obj_type), (min_size), (max_size), (alloc_size), (quanta), \\\n\t\t  ARRAY_SIZE(type_attrs), (type_attrs) }\n\nstatic const struct tee_cryp_obj_type_props tee_cryp_obj_props[] = {\n\tPROP(TEE_TYPE_AES, 64, 128, 256,\t/* valid sizes 128, 192, 256 */\n\t\t256 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES, 64, 64, 64,\n\t     /* Valid size 64 with parity */\n\t     64 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_DES3, 64, 128, 192,\n\t     /* Valid sizes 128, 192 with parity */\n\t     192 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_SM4, 128, 128, 128,\n\t\t128 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_MD5, 8, 64, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#if defined(CFG_HMAC_64_1024_RANGE)\n\tPROP(TEE_TYPE_HMAC_SHA1, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA224, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA256, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA384, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA512, 8, 64, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n#else\n\tPROP(TEE_TYPE_HMAC_SHA1, 8, 80, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA224, 8, 112, 512,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA256, 8, 192, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA384, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA512, 8, 256, 1024,\n\t\t1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#endif\n\tPROP(TEE_TYPE_HMAC_SHA3_224, 8, 192, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA3_256, 8, 256, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA3_384, 8, 256, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SHA3_512, 8, 256, 1024,\n\t     1024 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t     tee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_HMAC_SM3, 8, 80, 1024,\n\t\t512 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n\tPROP(TEE_TYPE_GENERIC_SECRET, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_secret_value_attrs),\n#if defined(CFG_CRYPTO_HKDF)\n\tPROP(TEE_TYPE_HKDF_IKM, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_hkdf_ikm_attrs),\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tPROP(TEE_TYPE_CONCAT_KDF_Z, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_concat_kdf_z_attrs),\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tPROP(TEE_TYPE_PBKDF2_PASSWORD, 8, 0, 4096,\n\t\t4096 / 8 + sizeof(struct tee_cryp_obj_secret),\n\t\ttee_cryp_obj_pbkdf2_passwd_attrs),\n#endif\n\tPROP(TEE_TYPE_RSA_PUBLIC_KEY, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_public_key),\n\t\ttee_cryp_obj_rsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_RSA_KEYPAIR, 1, 256, CFG_CORE_BIGNUM_MAX_BITS,\n\t\tsizeof(struct rsa_keypair),\n\t\ttee_cryp_obj_rsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DSA_PUBLIC_KEY, 64, 512, 3072,\n\t\tsizeof(struct dsa_public_key),\n\t\ttee_cryp_obj_dsa_pub_key_attrs),\n\n\tPROP(TEE_TYPE_DSA_KEYPAIR, 64, 512, 3072,\n\t\tsizeof(struct dsa_keypair),\n\t\ttee_cryp_obj_dsa_keypair_attrs),\n\n\tPROP(TEE_TYPE_DH_KEYPAIR, 1, 256, 2048,\n\t\tsizeof(struct dh_keypair),\n\t\ttee_cryp_obj_dh_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDSA_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n\n\tPROP(TEE_TYPE_ECDH_PUBLIC_KEY, 1, 192, 521,\n\t\tsizeof(struct ecc_public_key),\n\t\ttee_cryp_obj_ecc_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ECDH_KEYPAIR, 1, 192, 521,\n\t\tsizeof(struct ecc_keypair),\n\t\ttee_cryp_obj_ecc_keypair_attrs),\n\n\tPROP(TEE_TYPE_SM2_DSA_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ecc_public_key),\n\t     tee_cryp_obj_sm2_pub_key_attrs),\n\n\tPROP(TEE_TYPE_SM2_DSA_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ecc_keypair),\n\t     tee_cryp_obj_sm2_keypair_attrs),\n\n\tPROP(TEE_TYPE_SM2_PKE_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ecc_public_key),\n\t     tee_cryp_obj_sm2_pub_key_attrs),\n\n\tPROP(TEE_TYPE_SM2_PKE_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ecc_keypair),\n\t     tee_cryp_obj_sm2_keypair_attrs),\n\n\tPROP(TEE_TYPE_SM2_KEP_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ecc_public_key),\n\t     tee_cryp_obj_sm2_pub_key_attrs),\n\n\tPROP(TEE_TYPE_SM2_KEP_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ecc_keypair),\n\t     tee_cryp_obj_sm2_keypair_attrs),\n\n\tPROP(TEE_TYPE_X25519_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct x25519_keypair),\n\t     tee_cryp_obj_x25519_keypair_attrs),\n\n\tPROP(TEE_TYPE_ED25519_PUBLIC_KEY, 1, 256, 256,\n\t     sizeof(struct ed25519_public_key),\n\t     tee_cryp_obj_ed25519_pub_key_attrs),\n\n\tPROP(TEE_TYPE_ED25519_KEYPAIR, 1, 256, 256,\n\t     sizeof(struct ed25519_keypair),\n\t     tee_cryp_obj_ed25519_keypair_attrs),\n};\n\nstruct attr_ops {\n\tTEE_Result (*from_user)(void *attr, const void *buffer, size_t size);\n\tTEE_Result (*to_user)(void *attr, struct ts_session *sess,\n\t\t\t      void *buffer, uint64_t *size);\n\tTEE_Result (*to_binary)(void *attr, void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tbool (*from_binary)(void *attr, const void *data, size_t data_len,\n\t\t\t    size_t *offs);\n\tTEE_Result (*from_obj)(void *attr, void *src_attr);\n\tvoid (*free)(void *attr);\n\tvoid (*clear)(void *attr);\n};\n\nstatic TEE_Result op_u32_to_binary_helper(uint32_t v, uint8_t *data,\n\t\t\t\t    size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\tsize_t next_offs;\n\n\tif (ADD_OVERFLOW(*offs, sizeof(field), &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len) {\n\t\tfield = TEE_U32_TO_BIG_ENDIAN(v);\n\t\tmemcpy(data + *offs, &field, sizeof(field));\n\t}\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_u32_from_binary_helper(uint32_t *v, const uint8_t *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t field;\n\n\tif (!data || (*offs + sizeof(field)) > data_len)\n\t\treturn false;\n\n\tmemcpy(&field, data + *offs, sizeof(field));\n\t*v = TEE_U32_FROM_BIG_ENDIAN(field);\n\t(*offs) += sizeof(field);\n\treturn true;\n}\n\nstatic TEE_Result op_attr_secret_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t\t size_t size)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (size > key->alloc_size)\n\t\treturn TEE_ERROR_SECURITY;\n\tmemcpy(key + 1, buffer, size);\n\tkey->key_size = size;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_secret_value_to_user(void *attr,\n\t\t\t\t\t       struct ts_session *sess __unused,\n\t\t\t\t\t       void *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint64_t s;\n\tuint64_t key_size;\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tkey_size = key->key_size;\n\tres = copy_to_user(size, &key_size, sizeof(key_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < key->key_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn copy_to_user(buffer, key + 1, key->key_size);\n}\n\nstatic TEE_Result op_attr_secret_value_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_obj_secret *key = attr;\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(key->key_size, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, key->key_size, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tmemcpy((uint8_t *)data + *offs, key + 1, key->key_size);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_secret_value_from_binary(void *attr, const void *data,\n\t\t\t\t\t     size_t data_len, size_t *offs)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tuint32_t s;\n\n\tif (!op_u32_from_binary_helper(&s, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + s) > data_len)\n\t\treturn false;\n\n\t/* Data size has to fit in allocated buffer */\n\tif (s > key->alloc_size)\n\t\treturn false;\n\tkey->key_size = s;\n\tmemcpy(key + 1, (const uint8_t *)data + *offs, s);\n\t(*offs) += s;\n\treturn true;\n}\n\n\nstatic TEE_Result op_attr_secret_value_from_obj(void *attr, void *src_attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\tstruct tee_cryp_obj_secret *src_key = src_attr;\n\n\tif (src_key->key_size > key->alloc_size)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tmemcpy(key + 1, src_key + 1, src_key->key_size);\n\tkey->key_size = src_key->key_size;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_secret_value_clear(void *attr)\n{\n\tstruct tee_cryp_obj_secret *key = attr;\n\n\tkey->key_size = 0;\n\tmemzero_explicit(key + 1, key->alloc_size);\n}\n\nstatic TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,\n\t\t\t\t\t   size_t size)\n{\n\tstruct bignum **bn = attr;\n\n\treturn crypto_bignum_bin2bn(buffer, size, *bn);\n}\n\nstatic TEE_Result op_attr_bignum_to_user(void *attr,\n\t\t\t\t\t struct ts_session *sess,\n\t\t\t\t\t void *buffer, uint64_t *size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct bignum **bn = attr;\n\tuint64_t req_size = 0;\n\tuint64_t s = 0;\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treq_size = crypto_bignum_num_bytes(*bn);\n\tres = copy_to_user(size, &req_size, sizeof(req_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (!req_size)\n\t\treturn TEE_SUCCESS;\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\tbuffer = memtag_strip_tag(buffer);\n\n\t/* Check we can access data using supplied user mode pointer */\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)buffer, req_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\t/*\n\t* Write the bignum (wich raw data points to) into an array of\n\t* bytes (stored in buffer)\n\t*/\n\tcrypto_bignum_bn2bin(*bn, buffer);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_bignum_to_binary(void *attr, void *data,\n\t\t\t\t\t   size_t data_len, size_t *offs)\n{\n\tTEE_Result res;\n\tstruct bignum **bn = attr;\n\tuint32_t n = crypto_bignum_num_bytes(*bn);\n\tsize_t next_offs;\n\n\tres = op_u32_to_binary_helper(n, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, n, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tcrypto_bignum_bn2bin(*bn, (uint8_t *)data + *offs);\n\t(*offs) = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_bignum_from_binary(void *attr, const void *data,\n\t\t\t\t       size_t data_len, size_t *offs)\n{\n\tstruct bignum **bn = attr;\n\tuint32_t n;\n\n\tif (!op_u32_from_binary_helper(&n, data, data_len, offs))\n\t\treturn false;\n\n\tif ((*offs + n) > data_len)\n\t\treturn false;\n\tif (crypto_bignum_bin2bn((const uint8_t *)data + *offs, n, *bn))\n\t\treturn false;\n\t(*offs) += n;\n\treturn true;\n}\n\nstatic TEE_Result op_attr_bignum_from_obj(void *attr, void *src_attr)\n{\n\tstruct bignum **bn = attr;\n\tstruct bignum **src_bn = src_attr;\n\n\tcrypto_bignum_copy(*bn, *src_bn);\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_bignum_clear(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_clear(*bn);\n}\n\nstatic void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(bn);\n}\n\nstatic TEE_Result op_attr_value_from_user(void *attr, const void *buffer,\n\t\t\t\t\t  size_t size)\n{\n\tuint32_t *v = attr;\n\n\tif (size != sizeof(uint32_t) * 2)\n\t\treturn TEE_ERROR_GENERIC; /* \"can't happen */\n\n\t/* Note that only the first value is copied */\n\tmemcpy(v, buffer, sizeof(uint32_t));\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_value_to_user(void *attr,\n\t\t\t\t\tstruct ts_session *sess __unused,\n\t\t\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res;\n\tuint32_t *v = attr;\n\tuint64_t s;\n\tuint32_t value[2] = { *v };\n\tuint64_t req_size = sizeof(value);\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < req_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn copy_to_user(buffer, value, req_size);\n}\n\nstatic TEE_Result op_attr_value_to_binary(void *attr, void *data,\n\t\t\t\t\t  size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_to_binary_helper(*v, data, data_len, offs);\n}\n\nstatic bool op_attr_value_from_binary(void *attr, const void *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint32_t *v = attr;\n\n\treturn op_u32_from_binary_helper(v, data, data_len, offs);\n}\n\nstatic TEE_Result op_attr_value_from_obj(void *attr, void *src_attr)\n{\n\tuint32_t *v = attr;\n\tuint32_t *src_v = src_attr;\n\n\t*v = *src_v;\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_value_clear(void *attr)\n{\n\tuint32_t *v = attr;\n\n\t*v = 0;\n}\n\nstatic TEE_Result op_attr_25519_from_user(void *attr, const void *buffer,\n\t\t\t\t\t  size_t size)\n{\n\tuint8_t **key = attr;\n\n\tif (size != KEY_SIZE_BYTES_25519 || !*key)\n\t\treturn TEE_ERROR_SECURITY;\n\n\tmemcpy(*key, buffer, size);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result op_attr_25519_to_user(void *attr,\n\t\t\t\t\tstruct ts_session *sess __unused,\n\t\t\t\t\tvoid *buffer, uint64_t *size)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tuint8_t **key = attr;\n\tuint64_t s = 0;\n\tuint64_t key_size = (uint64_t)KEY_SIZE_BYTES_25519;\n\n\tres = copy_from_user(&s, size, sizeof(s));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = copy_to_user(size, &key_size, sizeof(key_size));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (s < key_size || !buffer)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\n\treturn copy_to_user(buffer, *key, key_size);\n}\n\nstatic TEE_Result op_attr_25519_to_binary(void *attr, void *data,\n\t\t\t\t\t  size_t data_len, size_t *offs)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tuint8_t **key = attr;\n\tsize_t next_offs = 0;\n\tuint64_t key_size = (uint64_t)KEY_SIZE_BYTES_25519;\n\n\tres = op_u32_to_binary_helper(key_size, data, data_len, offs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (ADD_OVERFLOW(*offs, key_size, &next_offs))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tif (data && next_offs <= data_len)\n\t\tmemcpy((uint8_t *)data + *offs, *key, key_size);\n\t*offs = next_offs;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool op_attr_25519_from_binary(void *attr, const void *data,\n\t\t\t\t      size_t data_len, size_t *offs)\n{\n\tuint8_t **key = attr;\n\tuint32_t s = 0;\n\n\tif (!op_u32_from_binary_helper(&s, data, data_len, offs))\n\t\treturn false;\n\n\tif (*offs + s > data_len)\n\t\treturn false;\n\n\tif (s > (uint32_t)KEY_SIZE_BYTES_25519)\n\t\treturn false;\n\n\tmemcpy(*key, (const uint8_t *)data + *offs, s);\n\t*offs += s;\n\treturn true;\n}\n\nstatic TEE_Result op_attr_25519_from_obj(void *attr, void *src_attr)\n{\n\tuint8_t **key = attr;\n\tuint8_t **src_key = src_attr;\n\n\tif (!*key || !*src_key)\n\t\treturn TEE_ERROR_SECURITY;\n\n\tmemcpy(*key, *src_key, KEY_SIZE_BYTES_25519);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void op_attr_25519_clear(void *attr)\n{\n\tuint8_t **key = attr;\n\n\tassert(*key);\n\n\tmemzero_explicit(*key, KEY_SIZE_BYTES_25519);\n}\n\nstatic void op_attr_25519_free(void *attr)\n{\n\tuint8_t **key = attr;\n\n\top_attr_25519_clear(attr);\n\tfree(*key);\n}\n\nstatic const struct attr_ops attr_ops[] = {\n\t[ATTR_OPS_INDEX_SECRET] = {\n\t\t.from_user = op_attr_secret_value_from_user,\n\t\t.to_user = op_attr_secret_value_to_user,\n\t\t.to_binary = op_attr_secret_value_to_binary,\n\t\t.from_binary = op_attr_secret_value_from_binary,\n\t\t.from_obj = op_attr_secret_value_from_obj,\n\t\t.free = op_attr_secret_value_clear, /* not a typo */\n\t\t.clear = op_attr_secret_value_clear,\n\t},\n\t[ATTR_OPS_INDEX_BIGNUM] = {\n\t\t.from_user = op_attr_bignum_from_user,\n\t\t.to_user = op_attr_bignum_to_user,\n\t\t.to_binary = op_attr_bignum_to_binary,\n\t\t.from_binary = op_attr_bignum_from_binary,\n\t\t.from_obj = op_attr_bignum_from_obj,\n\t\t.free = op_attr_bignum_free,\n\t\t.clear = op_attr_bignum_clear,\n\t},\n\t[ATTR_OPS_INDEX_VALUE] = {\n\t\t.from_user = op_attr_value_from_user,\n\t\t.to_user = op_attr_value_to_user,\n\t\t.to_binary = op_attr_value_to_binary,\n\t\t.from_binary = op_attr_value_from_binary,\n\t\t.from_obj = op_attr_value_from_obj,\n\t\t.free = op_attr_value_clear, /* not a typo */\n\t\t.clear = op_attr_value_clear,\n\t},\n\t[ATTR_OPS_INDEX_25519] = {\n\t\t.from_user = op_attr_25519_from_user,\n\t\t.to_user = op_attr_25519_to_user,\n\t\t.to_binary = op_attr_25519_to_binary,\n\t\t.from_binary = op_attr_25519_from_binary,\n\t\t.from_obj = op_attr_25519_from_obj,\n\t\t.free = op_attr_25519_free,\n\t\t.clear = op_attr_25519_clear,\n\t},\n};\n\nstatic TEE_Result get_user_u64_as_size_t(size_t *dst, uint64_t *src)\n{\n\tuint64_t d = 0;\n\tTEE_Result res = copy_from_user(&d, src, sizeof(d));\n\n\t/*\n\t * On 32-bit systems a size_t can't hold a uint64_t so we need to\n\t * check that the value isn't too large.\n\t */\n\tif (!res && ADD_OVERFLOW(0, d, dst))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\treturn res;\n}\n\nstatic TEE_Result put_user_u64(uint64_t *dst, size_t value)\n{\n\tuint64_t v = value;\n\n\treturn copy_to_user(dst, &v, sizeof(v));\n}\n\nTEE_Result syscall_cryp_obj_get_info(unsigned long obj,\n\t\t\t\t     struct utee_object_info *info)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct utee_object_info o_info = { };\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\to_info.obj_type = o->info.objectType;\n\to_info.obj_size = o->info.objectSize;\n\to_info.max_obj_size = o->info.maxObjectSize;\n\to_info.obj_usage = o->info.objectUsage;\n\to_info.data_size = o->info.dataSize;\n\to_info.data_pos = o->info.dataPosition;\n\to_info.handle_flags = o->info.handleFlags;\n\tres = copy_to_user_private(info, &o_info, sizeof(o_info));\n\nexit:\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_restrict_usage(unsigned long obj,\n\t\t\tunsigned long usage)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto exit;\n\n\to->info.objectUsage &= usage;\n\nexit:\n\treturn res;\n}\n\nstatic int tee_svc_cryp_obj_find_type_attr_idx(\n\t\tuint32_t attr_id,\n\t\tconst struct tee_cryp_obj_type_props *type_props)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tif (attr_id == type_props->type_attrs[n].attr_id)\n\t\t\treturn n;\n\t}\n\treturn -1;\n}\n\nstatic const struct tee_cryp_obj_type_props *tee_svc_find_type_props(\n\t\tTEE_ObjectType obj_type)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < ARRAY_SIZE(tee_cryp_obj_props); n++) {\n\t\tif (tee_cryp_obj_props[n].obj_type == obj_type)\n\t\t\treturn tee_cryp_obj_props + n;\n\t}\n\n\treturn NULL;\n}\n\n/* Set an attribute on an object */\nstatic void set_attribute(struct tee_obj *o,\n\t\t\t  const struct tee_cryp_obj_type_props *props,\n\t\t\t  uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn;\n\to->have_attrs |= BIT(idx);\n}\n\n/* Get an attribute on an object */\nstatic uint32_t get_attribute(const struct tee_obj *o,\n\t\t\t      const struct tee_cryp_obj_type_props *props,\n\t\t\t      uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn 0;\n\treturn o->have_attrs & BIT(idx);\n}\n\nTEE_Result syscall_cryp_obj_get_attr(unsigned long obj, unsigned long attr_id,\n\t\t\tvoid *buffer, uint64_t *size)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tint idx = 0;\n\tconst struct attr_ops *ops = NULL;\n\tvoid *attr = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/* Check that the object is initialized */\n\tif (!(o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Check that getting the attribute is allowed */\n\tif (!(attr_id & TEE_ATTR_FLAG_PUBLIC) &&\n\t    !(o->info.objectUsage & TEE_USAGE_EXTRACTABLE))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props) {\n\t\t/* Unknown object type, \"can't happen\" */\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tidx = tee_svc_cryp_obj_find_type_attr_idx(attr_id, type_props);\n\tif ((idx < 0) || ((o->have_attrs & (1 << idx)) == 0))\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\tattr = (uint8_t *)o->attr + type_props->type_attrs[idx].raw_offs;\n\treturn ops->to_user(attr, sess, buffer, size);\n}\n\nvoid tee_obj_attr_free(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].free((uint8_t *)o->attr + ta->raw_offs);\n\t}\n}\n\nvoid tee_obj_attr_clear(struct tee_obj *o)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\n\tif (!o->attr)\n\t\treturn;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\n\t\tattr_ops[ta->ops_index].clear((uint8_t *)o->attr +\n\t\t\t\t\t      ta->raw_offs);\n\t}\n}\n\nTEE_Result tee_obj_attr_to_binary(struct tee_obj *o, void *data,\n\t\t\t\t  size_t *data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\tsize_t len = data ? *data_len : 0;\n\tTEE_Result res;\n\n\tif (o->info.objectType == TEE_TYPE_DATA) {\n\t\t*data_len = 0;\n\t\treturn TEE_SUCCESS; /* pure data object */\n\t}\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tres = attr_ops[ta->ops_index].to_binary(attr, data, len, &offs);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t*data_len = offs;\n\tif (data && offs > len)\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_from_binary(struct tee_obj *o, const void *data,\n\t\t\t\t    size_t data_len)\n{\n\tconst struct tee_cryp_obj_type_props *tp;\n\tsize_t n;\n\tsize_t offs = 0;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\tconst struct tee_cryp_obj_type_attrs *ta = tp->type_attrs + n;\n\t\tvoid *attr = (uint8_t *)o->attr + ta->raw_offs;\n\n\t\tif (!attr_ops[ta->ops_index].from_binary(attr, data, data_len,\n\t\t\t\t\t\t\t &offs))\n\t\t\treturn TEE_ERROR_CORRUPT_OBJECT;\n\t}\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_attr_copy_from(struct tee_obj *o, const struct tee_obj *src)\n{\n\tTEE_Result res;\n\tconst struct tee_cryp_obj_type_props *tp;\n\tconst struct tee_cryp_obj_type_attrs *ta;\n\tsize_t n;\n\tuint32_t have_attrs = 0;\n\tvoid *attr;\n\tvoid *src_attr;\n\n\tif (o->info.objectType == TEE_TYPE_DATA)\n\t\treturn TEE_SUCCESS; /* pure data object */\n\tif (!o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\ttp = tee_svc_find_type_props(o->info.objectType);\n\tif (!tp)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (o->info.objectType == src->info.objectType) {\n\t\thave_attrs = src->have_attrs;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr + ta->raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t} else {\n\t\tconst struct tee_cryp_obj_type_props *tp_src;\n\t\tint idx;\n\n\t\tif (o->info.objectType == TEE_TYPE_RSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_RSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_DSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_DSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ECDH_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ECDH_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_SM2_DSA_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_SM2_DSA_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_SM2_PKE_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_SM2_PKE_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_SM2_KEP_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_SM2_KEP_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_ED25519_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_ED25519_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else if (o->info.objectType == TEE_TYPE_X25519_PUBLIC_KEY) {\n\t\t\tif (src->info.objectType != TEE_TYPE_X25519_KEYPAIR)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t\ttp_src = tee_svc_find_type_props(src->info.objectType);\n\t\tif (!tp_src)\n\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\thave_attrs = BIT32(tp->num_type_attrs) - 1;\n\t\tfor (n = 0; n < tp->num_type_attrs; n++) {\n\t\t\tta = tp->type_attrs + n;\n\n\t\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(ta->attr_id,\n\t\t\t\t\t\t\t\t  tp_src);\n\t\t\tif (idx < 0)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\t\tattr = (uint8_t *)o->attr + ta->raw_offs;\n\t\t\tsrc_attr = (uint8_t *)src->attr +\n\t\t\t\t   tp_src->type_attrs[idx].raw_offs;\n\t\t\tres = attr_ops[ta->ops_index].from_obj(attr, src_attr);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\to->have_attrs = have_attrs;\n\treturn TEE_SUCCESS;\n}\n\nstatic bool is_gp_legacy_des_key_size(TEE_ObjectType type, size_t sz)\n{\n\treturn IS_ENABLED(CFG_COMPAT_GP10_DES) &&\n\t       ((type == TEE_TYPE_DES && sz == 56) ||\n\t\t(type == TEE_TYPE_DES3 && (sz == 112 || sz == 168)));\n}\n\nstatic TEE_Result check_key_size(const struct tee_cryp_obj_type_props *props,\n\t\t\t\t size_t key_size)\n{\n\tsize_t sz = key_size;\n\n\t/*\n\t * In GP Internal API Specification 1.0 the partity bits aren't\n\t * counted when telling the size of the key in bits so add them\n\t * here if missing.\n\t */\n\tif (is_gp_legacy_des_key_size(props->obj_type, sz))\n\t\tsz += sz / 7;\n\n\tif (sz % props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (sz < props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (sz > props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_obj_set_type(struct tee_obj *o, uint32_t obj_type,\n\t\t\t    size_t max_key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\n\t/* Can only set type for newly allocated objs */\n\tif (o->attr)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Verify that maxObjectSize is supported and find out how\n\t * much should be allocated.\n\t */\n\n\tif (obj_type == TEE_TYPE_DATA) {\n\t\tif (max_key_size)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t} else {\n\t\t/* Find description of object */\n\t\ttype_props = tee_svc_find_type_props(obj_type);\n\t\tif (!type_props)\n\t\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t\t/* Check that max_key_size follows restrictions */\n\t\tres = check_key_size(type_props, max_key_size);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\to->attr = calloc(1, type_props->alloc_size);\n\t\tif (!o->attr)\n\t\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\n\t/* If we have a key structure, pre-allocate the bignums inside */\n\tswitch (obj_type) {\n\tcase TEE_TYPE_RSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_rsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_rsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_dsa_public_key(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dsa_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = crypto_acipher_alloc_dh_keypair(o->attr, max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_ecc_public_key(o->attr, obj_type,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tres = crypto_acipher_alloc_ecc_keypair(o->attr, obj_type,\n\t\t\t\t\t\t       max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_X25519_KEYPAIR:\n\t\tres = crypto_acipher_alloc_x25519_keypair(o->attr,\n\t\t\t\t\t\t\t  max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ED25519_KEYPAIR:\n\t\tres = crypto_acipher_alloc_ed25519_keypair(o->attr,\n\t\t\t\t\t\t\t   max_key_size);\n\t\tbreak;\n\tcase TEE_TYPE_ED25519_PUBLIC_KEY:\n\t\tres = crypto_acipher_alloc_ed25519_public_key(o->attr,\n\t\t\t\t\t\t\t      max_key_size);\n\t\tbreak;\n\tdefault:\n\t\tif (obj_type != TEE_TYPE_DATA) {\n\t\t\tstruct tee_cryp_obj_secret *key = o->attr;\n\n\t\t\tkey->alloc_size = type_props->alloc_size -\n\t\t\t\t\t  sizeof(*key);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\to->info.objectType = obj_type;\n\to->info.maxObjectSize = max_key_size;\n\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_alloc(unsigned long obj_type,\n\t\t\tunsigned long max_key_size, uint32_t *obj)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\n\to = tee_obj_alloc();\n\tif (!o)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = tee_obj_set_type(o, obj_type, max_key_size);\n\tif (res != TEE_SUCCESS) {\n\t\ttee_obj_free(o);\n\t\treturn res;\n\t}\n\n\ttee_obj_add(to_user_ta_ctx(sess->ctx), o);\n\n\tres = copy_kaddr_to_uref(obj, o);\n\tif (res != TEE_SUCCESS)\n\t\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_close(unsigned long obj)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/*\n\t * If it's busy it's used by an operation, a client should never have\n\t * this handle.\n\t */\n\tif (o->busy)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_reset(unsigned long obj)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) == 0) {\n\t\ttee_obj_attr_clear(o);\n\t\to->info.objectSize = 0;\n\t\to->info.objectUsage = TEE_USAGE_DEFAULT;\n\t} else {\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* the object is no more initialized */\n\to->info.handleFlags &= ~TEE_HANDLE_FLAG_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result copy_in_attrs(struct user_ta_ctx *utc,\n\t\t\tconst struct utee_attribute *usr_attrs,\n\t\t\tuint32_t attr_count, TEE_Attribute *attrs)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t size = 0;\n\tuint32_t n = 0;\n\n\tif (MUL_OVERFLOW(sizeof(struct utee_attribute), attr_count, &size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tusr_attrs = memtag_strip_tag_const(usr_attrs);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)usr_attrs, size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tattrs[n].attributeID = usr_attrs[n].attribute_id;\n\t\tif (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE) {\n\t\t\tattrs[n].content.value.a = usr_attrs[n].a;\n\t\t\tattrs[n].content.value.b = usr_attrs[n].b;\n\t\t} else {\n\t\t\tuintptr_t buf = usr_attrs[n].a;\n\t\t\tsize_t len = usr_attrs[n].b;\n\t\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\t\tbuf = memtag_strip_tag_vaddr((void *)buf);\n\n\t\t\tres = vm_check_access_rights(&utc->uctx, flags, buf,\n\t\t\t\t\t\t     len);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tattrs[n].content.ref.buffer = (void *)buf;\n\t\t\tattrs[n].content.ref.length = len;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nenum attr_usage {\n\tATTR_USAGE_POPULATE,\n\tATTR_USAGE_GENERATE_KEY\n};\n\nstatic TEE_Result tee_svc_cryp_check_attr(enum attr_usage usage,\n\t\t\t\t\t  const struct tee_cryp_obj_type_props\n\t\t\t\t\t\t*type_props,\n\t\t\t\t\t  const TEE_Attribute *attrs,\n\t\t\t\t\t  uint32_t attr_count)\n{\n\tuint32_t required_flag = 0;\n\tuint32_t opt_flag = 0;\n\tbool all_opt_needed = false;\n\tuint32_t req_attrs = 0;\n\tuint32_t opt_grp_attrs = 0;\n\tuint32_t attrs_found = 0;\n\tsize_t n = 0;\n\tuint32_t bit = 0;\n\tuint32_t flags = 0;\n\tint idx = 0;\n\n\tif (usage == ATTR_USAGE_POPULATE) {\n\t\trequired_flag = TEE_TYPE_ATTR_REQUIRED;\n\t\topt_flag = TEE_TYPE_ATTR_OPTIONAL_GROUP;\n\t\tall_opt_needed = true;\n\t} else {\n\t\trequired_flag = TEE_TYPE_ATTR_GEN_KEY_REQ;\n\t\topt_flag = TEE_TYPE_ATTR_GEN_KEY_OPT;\n\t\tall_opt_needed = false;\n\t}\n\n\t/*\n\t * First find out which attributes are required and which belong to\n\t * the optional group\n\t */\n\tfor (n = 0; n < type_props->num_type_attrs; n++) {\n\t\tbit = 1 << n;\n\t\tflags = type_props->type_attrs[n].flags;\n\n\t\tif (flags & required_flag)\n\t\t\treq_attrs |= bit;\n\t\telse if (flags & opt_flag)\n\t\t\topt_grp_attrs |= bit;\n\t}\n\n\t/*\n\t * Verify that all required attributes are in place and\n\t * that the same attribute isn't repeated.\n\t */\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tbit = 1 << idx;\n\n\t\t/* attribute not repeated */\n\t\tif ((attrs_found & bit) != 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\t/*\n\t\t * Attribute not defined in current object type for this\n\t\t * usage.\n\t\t */\n\t\tif (!(bit & (req_attrs | opt_grp_attrs)))\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\tattrs_found |= bit;\n\t}\n\t/* Required attribute missing */\n\tif ((attrs_found & req_attrs) != req_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t/*\n\t * If the flag says that \"if one of the optional attributes are included\n\t * all of them has to be included\" this must be checked.\n\t */\n\tif (all_opt_needed && (attrs_found & opt_grp_attrs) != 0 &&\n\t    (attrs_found & opt_grp_attrs) != opt_grp_attrs)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result get_ec_key_size(uint32_t curve, size_t *key_size)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*key_size = 192;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*key_size = 224;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*key_size = 256;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*key_size = 384;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*key_size = 521;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_SM2:\n\tcase TEE_ECC_CURVE_25519:\n\t\t*key_size = 256;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic size_t get_used_bits(const TEE_Attribute *a)\n{\n\tint nbits = a->content.ref.length * 8;\n\tint v = 0;\n\n\tbit_ffs(a->content.ref.buffer, nbits, &v);\n\treturn nbits - v;\n}\n\nstatic TEE_Result tee_svc_cryp_obj_populate_type(\n\t\tstruct tee_obj *o,\n\t\tconst struct tee_cryp_obj_type_props *type_props,\n\t\tconst TEE_Attribute *attrs,\n\t\tuint32_t attr_count)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tuint32_t have_attrs = 0;\n\tsize_t obj_size = 0;\n\tsize_t n = 0;\n\tint idx = 0;\n\tconst struct attr_ops *ops = NULL;\n\tvoid *attr = NULL;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tidx = tee_svc_cryp_obj_find_type_attr_idx(\n\t\t\t\t\t\t\tattrs[n].attributeID,\n\t\t\t\t\t\t\ttype_props);\n\t\t/* attribute not defined in current object type */\n\t\tif (idx < 0)\n\t\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\t\thave_attrs |= BIT32(idx);\n\t\tops = attr_ops + type_props->type_attrs[idx].ops_index;\n\t\tattr = (uint8_t *)o->attr +\n\t\t       type_props->type_attrs[idx].raw_offs;\n\t\tif (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE)\n\t\t\tres = ops->from_user(attr, &attrs[n].content.value,\n\t\t\t\t\t     sizeof(attrs[n].content.value));\n\t\telse\n\t\t\tres = ops->from_user(attr, attrs[n].content.ref.buffer,\n\t\t\t\t\t     attrs[n].content.ref.length);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\t/*\n\t\t * The attribute that gives the size of the object is\n\t\t * flagged with TEE_TYPE_ATTR_SIZE_INDICATOR.\n\t\t */\n\t\tif (type_props->type_attrs[idx].flags &\n\t\t    TEE_TYPE_ATTR_SIZE_INDICATOR) {\n\t\t\t/* There should be only one */\n\t\t\tif (obj_size)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\n\t\t\t/*\n\t\t\t * For ECDSA/ECDH we need to translate curve into\n\t\t\t * object size\n\t\t\t */\n\t\t\tif (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {\n\t\t\t\tres = get_ec_key_size(attrs[n].content.value.a,\n\t\t\t\t\t\t      &obj_size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\tTEE_ObjectType obj_type = o->info.objectType;\n\t\t\t\tsize_t sz = o->info.maxObjectSize;\n\n\t\t\t\tobj_size = attrs[n].content.ref.length * 8;\n\t\t\t\t/* Drop the parity bits for legacy objects */\n\t\t\t\tif (is_gp_legacy_des_key_size(obj_type, sz))\n\t\t\t\t\tobj_size -= obj_size / 8;\n\t\t\t}\n\t\t\tif (obj_size > o->info.maxObjectSize)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\t\t\tres = check_key_size(type_props, obj_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t\t/*\n\t\t * Bignum attributes limited by the number of bits in\n\t\t * o->info.objectSize are flagged with\n\t\t * TEE_TYPE_ATTR_BIGNUM_MAXBITS.\n\t\t */\n\t\tif (type_props->type_attrs[idx].flags &\n\t\t    TEE_TYPE_ATTR_BIGNUM_MAXBITS) {\n\t\t\tif (get_used_bits(attrs + n) > o->info.maxObjectSize)\n\t\t\t\treturn TEE_ERROR_BAD_STATE;\n\t\t}\n\t}\n\n\to->have_attrs = have_attrs;\n\to->info.objectSize = obj_size;\n\t/*\n\t * In GP Internal API Specification 1.0 the partity bits aren't\n\t * counted when telling the size of the key in bits so remove the\n\t * parity bits here.\n\t */\n\tif (is_gp_legacy_des_key_size(o->info.objectType,\n\t\t\t\t      o->info.maxObjectSize))\n\t\to->info.objectSize -= o->info.objectSize / 8;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tTEE_Attribute *attrs = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tattrs = malloc(alloc_size);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\nout:\n\tfree_wipe(attrs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_obj_copy(unsigned long dst, unsigned long src)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *dst_o = NULL;\n\tstruct tee_obj *src_o = NULL;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  uref_to_vaddr(dst), &dst_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  uref_to_vaddr(src), &src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif ((src_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((dst_o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_obj_attr_copy_from(dst_o, src_o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tdst_o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\tdst_o->info.objectSize = src_o->info.objectSize;\n\tdst_o->info.objectUsage = src_o->info.objectUsage;\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result check_pub_rsa_key(struct bignum *e)\n{\n\tsize_t n = crypto_bignum_num_bytes(e);\n\tuint8_t bin_key[256 / 8] = { 0 };\n\n\t/*\n\t * NIST SP800-56B requires public RSA key to be an odd integer in\n\t * the range 65537 <= e < 2^256.\n\t */\n\n\tif (n > sizeof(bin_key) || n < 3)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tcrypto_bignum_bn2bin(e, bin_key);\n\n\tif (!(bin_key[n - 1] & 1)) /* key must be odd */\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (n == 3) {\n\t\tuint32_t key = 0;\n\n\t\tfor (n = 0; n < 3; n++) {\n\t\t\tkey <<= 8;\n\t\t\tkey |= bin_key[n];\n\t\t}\n\n\t\tif (key < 65537)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t/* key is larger than 65537 */\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_rsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size,\n\tconst TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct rsa_keypair *key = o->attr;\n\tuint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT)) {\n\t\tres = check_pub_rsa_key(key->e);\n\t\tif (res)\n\t\t\treturn res;\n\t} else {\n\t\tcrypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);\n\t}\n\tres = crypto_acipher_gen_rsa_key(key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dsa(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size, const TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_acipher_gen_dsa_key(o->attr, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for all known attributes for this object type */\n\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_dh(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size, const TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct dh_keypair *tee_dh_key;\n\tstruct bignum *dh_q = NULL;\n\tuint32_t dh_xbits = 0;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_dh_key = (struct dh_keypair *)o->attr;\n\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_SUBPRIME))\n\t\tdh_q = tee_dh_key->q;\n\tif (get_attribute(o, type_props, TEE_ATTR_DH_X_BITS))\n\t\tdh_xbits = tee_dh_key->xbits;\n\tres = crypto_acipher_gen_dh_key(tee_dh_key, dh_q, dh_xbits, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_DH_PUBLIC_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_DH_X_BITS);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_obj_generate_key_ecc(\n\tstruct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,\n\tuint32_t key_size, const TEE_Attribute *params, uint32_t param_count)\n{\n\tTEE_Result res;\n\tstruct ecc_keypair *tee_ecc_key;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_ecc_key = (struct ecc_keypair *)o->attr;\n\n\tres = crypto_acipher_gen_ecc_key(tee_ecc_key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_X);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_PUBLIC_VALUE_Y);\n\tset_attribute(o, type_props, TEE_ATTR_ECC_CURVE);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_generate_key_x25519(struct tee_obj *o,\n\t\t\t\tconst struct tee_cryp_obj_type_props\n\t\t\t\t\t\t\t*type_props,\n\t\t\t\tuint32_t key_size,\n\t\t\t\tconst TEE_Attribute *params,\n\t\t\t\tuint32_t param_count)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tstruct x25519_keypair *tee_x25519_key = NULL;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\ttee_x25519_key = (struct x25519_keypair *)o->attr;\n\n\tres = crypto_acipher_gen_x25519_key(tee_x25519_key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_X25519_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_X25519_PUBLIC_VALUE);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_generate_key_ed25519(struct tee_obj *o,\n\t\t\t\t const struct tee_cryp_obj_type_props\n\t\t\t\t\t\t\t*type_props,\n\t\t\t\t uint32_t key_size,\n\t\t\t\t const TEE_Attribute *params,\n\t\t\t\t uint32_t param_count)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tstruct ed25519_keypair *key = NULL;\n\n\t/* Copy the present attributes into the obj before starting */\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, params,\n\t\t\t\t\t     param_count);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tkey = o->attr;\n\n\tres = crypto_acipher_gen_ed25519_key(key, key_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Set bits for the generated public and private key */\n\tset_attribute(o, type_props, TEE_ATTR_ED25519_PRIVATE_VALUE);\n\tset_attribute(o, type_props, TEE_ATTR_ED25519_PUBLIC_VALUE);\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_ed25519_parse_params(const TEE_Attribute *params, size_t num_params,\n\t\t\t\t bool *ph_flag, const uint8_t **ctx,\n\t\t\t\t size_t *ctx_len)\n{\n\tsize_t n = 0;\n\n\t*ctx = NULL;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_EDDSA_PREHASH:\n\t\t\tif (params[n].content.value.b)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tif (!params[n].content.value.a)\n\t\t\t\t*ph_flag = false;\n\t\t\telse if (params[n].content.value.a == 1)\n\t\t\t\t*ph_flag = true;\n\t\t\telse\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\n\t\tcase TEE_ATTR_EDDSA_CTX:\n\t\t\t/* several provided contexts are treated as error */\n\t\t\tif (*ctx)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\t*ctx_len = params[n].content.ref.length;\n\t\t\tif (*ctx_len > TEE_ED25519_CTX_MAX_LENGTH)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tif (!*ctx_len)\n\t\t\t\tbreak;\n\n\t\t\t*ctx = params[n].content.ref.buffer;\n\t\t\tif (!*ctx)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result\ntee_svc_obj_ed25519_sign(struct ed25519_keypair *key,\n\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t uint8_t *sig, size_t *sig_len,\n\t\t\t const TEE_Attribute *params, size_t num_params)\n{\n\tTEE_Result err = TEE_ERROR_GENERIC;\n\tsize_t ctx_len = 0;\n\tconst uint8_t *ctx = NULL;\n\tbool ph_flag = false;\n\n\terr = tee_svc_obj_ed25519_parse_params(params, num_params, &ph_flag,\n\t\t\t\t\t       &ctx, &ctx_len);\n\tif (err != TEE_SUCCESS)\n\t\treturn err;\n\n\tif (ph_flag || ctx) {\n\t\treturn crypto_acipher_ed25519ctx_sign(key, msg, msg_len, sig,\n\t\t\t\t\t\t      sig_len, ph_flag,\n\t\t\t\t\t\t      ctx, ctx_len);\n\t}\n\n\treturn crypto_acipher_ed25519_sign(key, msg, msg_len, sig, sig_len);\n}\n\nstatic TEE_Result\ntee_svc_obj_ed25519_verify(struct ed25519_public_key *key,\n\t\t\t   const uint8_t *msg, size_t msg_len,\n\t\t\t   const uint8_t *sig, size_t sig_len,\n\t\t\t   const TEE_Attribute *params, size_t num_params)\n{\n\tTEE_Result err = TEE_ERROR_GENERIC;\n\tsize_t ctx_len = 0;\n\tconst uint8_t *ctx = NULL;\n\tbool ph_flag = false;\n\n\terr = tee_svc_obj_ed25519_parse_params(params, num_params, &ph_flag,\n\t\t\t\t\t       &ctx, &ctx_len);\n\tif (err)\n\t\treturn err;\n\n\tif (ph_flag || ctx) {\n\t\treturn crypto_acipher_ed25519ctx_verify(key, msg, msg_len, sig,\n\t\t\t\t\t\t\tsig_len, ph_flag,\n\t\t\t\t\t\t\tctx, ctx_len);\n\t}\n\n\treturn crypto_acipher_ed25519_verify(key, msg, msg_len, sig, sig_len);\n}\n\nTEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tstruct tee_obj *o = NULL;\n\tstruct tee_cryp_obj_secret *key = NULL;\n\tsize_t byte_size = 0;\n\tTEE_Attribute *params = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that key_size follows restrictions */\n\tres = check_key_size(type_props, key_size);\n\tif (res)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_SM4:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_HMAC_SHA3_224:\n\tcase TEE_TYPE_HMAC_SHA3_256:\n\tcase TEE_TYPE_HMAC_SHA3_384:\n\tcase TEE_TYPE_HMAC_SHA3_512:\n\tcase TEE_TYPE_HMAC_SM3:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * In GP Internal API Specification 1.0 the partity bits\n\t\t * aren't counted when telling the size of the key in bits.\n\t\t */\n\t\tif (is_gp_legacy_des_key_size(o->info.objectType, key_size))\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_X25519_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_x25519(o, type_props, key_size,\n\t\t\t\t\t\t      params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ED25519_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ed25519(o, type_props, key_size,\n\t\t\t\t\t\t       params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree_wipe(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.objectSize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n\nstatic TEE_Result tee_svc_cryp_get_state(struct ts_session *sess,\n\t\t\t\t\t vaddr_t state_id,\n\t\t\t\t\t struct tee_cryp_state **state)\n{\n\tstruct tee_cryp_state *s;\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\n\tTAILQ_FOREACH(s, &utc->cryp_states, link) {\n\t\tif (state_id == (vaddr_t)s) {\n\t\t\t*state = s;\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t}\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic void cryp_state_free(struct user_ta_ctx *utc, struct tee_cryp_state *cs)\n{\n\tstruct tee_obj *o;\n\n\tif (tee_obj_get(utc, cs->key1, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS)\n\t\ttee_obj_close(utc, o);\n\n\tTAILQ_REMOVE(&utc->cryp_states, cs, link);\n\tif (cs->ctx_finalize != NULL)\n\t\tcs->ctx_finalize(cs->ctx);\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_free_ctx(cs->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_free_ctx(cs->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_free_ctx(cs->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_free_ctx(cs->ctx);\n\t\tbreak;\n\tdefault:\n\t\tassert(!cs->ctx);\n\t}\n\n\tfree(cs);\n}\n\nstatic TEE_Result tee_svc_cryp_check_key_type(const struct tee_obj *o,\n\t\t\t\t\t      uint32_t algo,\n\t\t\t\t\t      TEE_OperationMode mode)\n{\n\tuint32_t req_key_type;\n\tuint32_t req_key_type2 = 0;\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(algo)) {\n\tcase TEE_MAIN_ALGO_MD5:\n\t\treq_key_type = TEE_TYPE_HMAC_MD5;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA1:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA1;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA224:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA224;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA256:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA256;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA384:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA384;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA512:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA512;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_224:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_224;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_256:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_256;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_384:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_384;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SHA3_512:\n\t\treq_key_type = TEE_TYPE_HMAC_SHA3_512;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM3:\n\t\treq_key_type = TEE_TYPE_HMAC_SM3;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_AES:\n\t\treq_key_type = TEE_TYPE_AES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES:\n\t\treq_key_type = TEE_TYPE_DES;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DES3:\n\t\treq_key_type = TEE_TYPE_DES3;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM4:\n\t\treq_key_type = TEE_TYPE_SM4;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_RSA:\n\t\treq_key_type = TEE_TYPE_RSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_RSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DSA:\n\t\treq_key_type = TEE_TYPE_DSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_ENCRYPT || mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_DSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_DH:\n\t\treq_key_type = TEE_TYPE_DH_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDSA:\n\t\treq_key_type = TEE_TYPE_ECDSA_KEYPAIR;\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_ECDSA_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ECDH:\n\t\treq_key_type = TEE_TYPE_ECDH_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_ED25519:\n\t\treq_key_type = TEE_TYPE_ED25519_KEYPAIR;\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type2 = TEE_TYPE_ED25519_PUBLIC_KEY;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM2_PKE:\n\t\tif (mode == TEE_MODE_ENCRYPT)\n\t\t\treq_key_type = TEE_TYPE_SM2_PKE_PUBLIC_KEY;\n\t\telse\n\t\t\treq_key_type = TEE_TYPE_SM2_PKE_KEYPAIR;\n\t\tbreak;\n\tcase TEE_MAIN_ALGO_SM2_DSA_SM3:\n\t\tif (mode == TEE_MODE_VERIFY)\n\t\t\treq_key_type = TEE_TYPE_SM2_DSA_PUBLIC_KEY;\n\t\telse\n\t\t\treq_key_type = TEE_TYPE_SM2_DSA_KEYPAIR;\n\t\tbreak;\n#if defined(CFG_CRYPTO_SM2_KEP)\n\tcase TEE_MAIN_ALGO_SM2_KEP:\n\t\treq_key_type = TEE_TYPE_SM2_KEP_KEYPAIR;\n\t\treq_key_type2 = TEE_TYPE_SM2_KEP_PUBLIC_KEY;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_HKDF)\n\tcase TEE_MAIN_ALGO_HKDF:\n\t\treq_key_type = TEE_TYPE_HKDF_IKM;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\tcase TEE_MAIN_ALGO_CONCAT_KDF:\n\t\treq_key_type = TEE_TYPE_CONCAT_KDF_Z;\n\t\tbreak;\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\tcase TEE_MAIN_ALGO_PBKDF2:\n\t\treq_key_type = TEE_TYPE_PBKDF2_PASSWORD;\n\t\tbreak;\n#endif\n\tcase TEE_MAIN_ALGO_X25519:\n\t\treq_key_type = TEE_TYPE_X25519_KEYPAIR;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tif (req_key_type != o->info.objectType &&\n\t    req_key_type2 != o->info.objectType)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nstatic uint32_t translate_compat_algo(uint32_t algo)\n{\n\tswitch (algo) {\n\tcase __OPTEE_ALG_ECDSA_P192:\n\t\treturn TEE_ALG_ECDSA_SHA1;\n\tcase __OPTEE_ALG_ECDSA_P224:\n\t\treturn TEE_ALG_ECDSA_SHA224;\n\tcase __OPTEE_ALG_ECDSA_P256:\n\t\treturn TEE_ALG_ECDSA_SHA256;\n\tcase __OPTEE_ALG_ECDSA_P384:\n\t\treturn TEE_ALG_ECDSA_SHA384;\n\tcase __OPTEE_ALG_ECDSA_P521:\n\t\treturn TEE_ALG_ECDSA_SHA512;\n\tcase __OPTEE_ALG_ECDH_P192:\n\tcase __OPTEE_ALG_ECDH_P224:\n\tcase __OPTEE_ALG_ECDH_P256:\n\tcase __OPTEE_ALG_ECDH_P384:\n\tcase __OPTEE_ALG_ECDH_P521:\n\t\treturn TEE_ALG_ECDH_DERIVE_SHARED_SECRET;\n\tdefault:\n\t\treturn algo;\n\t}\n}\n\nTEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\n\talgo = translate_compat_algo(algo);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\tcs->state = CRYP_STATE_UNINITIALIZED;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((TEE_ALG_GET_CHAIN_MODE(algo) == TEE_CHAIN_MODE_XTS &&\n\t\t     (key1 == 0 || key2 == 0)) ||\n\t\t    (TEE_ALG_GET_CHAIN_MODE(algo) != TEE_CHAIN_MODE_XTS &&\n\t\t    (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5 &&\n\t\t    !IS_ENABLED(CFG_CRYPTO_RSASSA_NA1)) {\n\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (algo == TEE_ALG_SM2_KEP) {\n\t\t\tif (key1 == 0 || key2 == 0)\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tif (key1 == 0 || key2 != 0)\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs_dst = NULL;\n\tstruct tee_cryp_state *cs_src = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tcs_dst->state = cs_src->state;\n\tcs_dst->ctx_finalize = cs_src->ctx_finalize;\n\n\treturn TEE_SUCCESS;\n}\n\nvoid tee_svc_cryp_free_states(struct user_ta_ctx *utc)\n{\n\tstruct tee_cryp_state_head *states = &utc->cryp_states;\n\n\twhile (!TAILQ_EMPTY(states))\n\t\tcryp_state_free(utc, TAILQ_FIRST(states));\n}\n\nTEE_Result syscall_cryp_state_free(unsigned long state)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcryp_state_free(to_user_ta_ctx(sess->ctx), cs);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, (void *)(key + 1),\n\t\t\t\t\t      key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tchunk = memtag_strip_tag_const(chunk);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic bool is_xof_algo(uint32_t algo)\n{\n\treturn algo == TEE_ALG_SHAKE128 || algo == TEE_ALG_SHAKE256;\n}\n\nTEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res2 = TEE_SUCCESS;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t hash_size = 0;\n\tsize_t hlen = 0;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tchunk = memtag_strip_tag_const(chunk);\n\thash = memtag_strip_tag(hash);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (is_xof_algo(cs->algo)) {\n\t\t\tif (chunk_size) {\n\t\t\t\tres = crypto_hash_update(cs->ctx, chunk,\n\t\t\t\t\t\t\t chunk_size);\n\t\t\t\tif (res)\n\t\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * hash_size is supposed to be unchanged for XOF\n\t\t\t * algorithms so return directly.\n\t\t\t */\n\t\t\treturn crypto_hash_final(cs->ctx, hash, hlen);\n\t\t}\n\n\t\tres = tee_alg_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, chunk, chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_alg_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, chunk, chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}\n\nTEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tstruct tee_cryp_obj_secret *key1 = NULL;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tiv = memtag_strip_tag_const(iv);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc = memtag_strip_tag_const(src);\n\tdst = memtag_strip_tag(dst);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tstruct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;\n\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = vm_check_access_rights(uctx, flags, (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_cipher_update(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, false /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\nTEE_Result syscall_cipher_final(unsigned long state, const void *src,\n\t\t\tsize_t src_len, void *dst, uint64_t *dst_len)\n{\n\treturn tee_svc_cipher_update_helper(state, true /* last_block */,\n\t\t\t\t\t    src, src_len, dst, dst_len);\n}\n\n#if defined(CFG_CRYPTO_HKDF)\nstatic TEE_Result get_hkdf_params(uint32_t algo, const TEE_Attribute *params,\n\t\t\t\t  uint32_t param_count,\n\t\t\t\t  void **salt, size_t *salt_len, void **info,\n\t\t\t\t  size_t *info_len, size_t *okm_len,\n\t\t\t\t  uint32_t *hash_id)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, INFO = 0x4, HASH = 0x8 };\n\tuint8_t found = 0;\n\n\t*salt = *info = NULL;\n\t*salt_len = *info_len = *okm_len = 0;\n\n\tif (algo == TEE_ALG_HKDF) {\n\t\t*hash_id = TEE_ALG_SHA256;\n\t} else {\n\t\t*hash_id = TEE_ALG_GET_DIGEST_HASH(algo);\n\t\tfound |= HASH;\n\t}\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase __OPTEE_TEE_ATTR_HKDF_SALT:\n\t\tcase TEE_ATTR_HKDF_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_KDF_KEY_SIZE:\n\t\tcase TEE_ATTR_HKDF_OKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*okm_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase __OPTEE_ATTR_HKDF_INFO:\n\t\tcase TEE_ATTR_HKDF_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*info = params[n].content.ref.buffer;\n\t\t\t\t*info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_HKDF_HASH_ALGORITHM:\n\t\t\tif (!(found & HASH)) {\n\t\t\t\t*hash_id = params[n].content.value.a;\n\t\t\t\tfound |= HASH;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_CONCAT_KDF)\nstatic TEE_Result get_concat_kdf_params(const TEE_Attribute *params,\n\t\t\t\t\tuint32_t param_count,\n\t\t\t\t\tvoid **other_info,\n\t\t\t\t\tsize_t *other_info_len,\n\t\t\t\t\tsize_t *derived_key_len)\n{\n\tsize_t n;\n\tenum { LENGTH = 0x1, INFO = 0x2 };\n\tuint8_t found = 0;\n\n\t*other_info = NULL;\n\t*other_info_len = *derived_key_len = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_CONCAT_KDF_OTHER_INFO:\n\t\t\tif (!(found & INFO)) {\n\t\t\t\t*other_info = params[n].content.ref.buffer;\n\t\t\t\t*other_info_len = params[n].content.ref.length;\n\t\t\t\tfound |= INFO;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_CONCAT_KDF_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif (!(found & LENGTH))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_PBKDF2)\nstatic TEE_Result get_pbkdf2_params(const TEE_Attribute *params,\n\t\t\t\t   uint32_t param_count, void **salt,\n\t\t\t\t   size_t *salt_len, size_t *derived_key_len,\n\t\t\t\t   size_t *iteration_count)\n{\n\tsize_t n;\n\tenum { SALT = 0x1, LENGTH = 0x2, COUNT = 0x4 };\n\tuint8_t found = 0;\n\n\t*salt = NULL;\n\t*salt_len = *derived_key_len = *iteration_count = 0;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tswitch (params[n].attributeID) {\n\t\tcase TEE_ATTR_PBKDF2_SALT:\n\t\t\tif (!(found & SALT)) {\n\t\t\t\t*salt = params[n].content.ref.buffer;\n\t\t\t\t*salt_len = params[n].content.ref.length;\n\t\t\t\tfound |= SALT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_DKM_LENGTH:\n\t\t\tif (!(found & LENGTH)) {\n\t\t\t\t*derived_key_len = params[n].content.value.a;\n\t\t\t\tfound |= LENGTH;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_ATTR_PBKDF2_ITERATION_COUNT:\n\t\t\tif (!(found & COUNT)) {\n\t\t\t\t*iteration_count = params[n].content.value.a;\n\t\t\t\tfound |= COUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tif ((found & (LENGTH|COUNT)) != (LENGTH|COUNT))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\treturn TEE_SUCCESS;\n}\n#endif\n\n#if defined(CFG_CRYPTO_SM2_KEP)\nstatic TEE_Result get_sm2_kep_params(const TEE_Attribute *params,\n\t\t\t\t     uint32_t param_count,\n\t\t\t\t     struct ecc_public_key *peer_key,\n\t\t\t\t     struct ecc_public_key *peer_eph_key,\n\t\t\t\t     struct sm2_kep_parms *kep_parms)\n{\n\tTEE_Result res = TEE_ERROR_GENERIC;\n\tsize_t n;\n\tenum {\n\t\tIS_INITIATOR,\n\t\tPEER_KEY_X,\n\t\tPEER_KEY_Y,\n\t\tPEER_EPH_KEY_X,\n\t\tPEER_EPH_KEY_Y,\n\t\tINITIATOR_ID,\n\t\tRESPONDER_ID,\n\t};\n\tuint8_t mandatory = BIT(IS_INITIATOR) | BIT(PEER_KEY_X) |\n\t\tBIT(PEER_KEY_Y) | BIT(PEER_EPH_KEY_X) | BIT(PEER_EPH_KEY_Y) |\n\t\tBIT(INITIATOR_ID) | BIT(RESPONDER_ID);\n\tuint8_t found = 0;\n\n\tres = crypto_acipher_alloc_ecc_public_key(peer_key,\n\t\t\t\t\t\t  TEE_TYPE_SM2_KEP_PUBLIC_KEY,\n\t\t\t\t\t\t  256);\n\tif (res)\n\t\treturn res;\n\n\tres = crypto_acipher_alloc_ecc_public_key(peer_eph_key,\n\t\t\t\t\t\t  TEE_TYPE_SM2_KEP_PUBLIC_KEY,\n\t\t\t\t\t\t  256);\n\tif (res)\n\t\tgoto out_p;\n\n\tpeer_key->curve = TEE_ECC_CURVE_SM2;\n\tpeer_eph_key->curve = TEE_ECC_CURVE_SM2;\n\n\tfor (n = 0; n < param_count; n++) {\n\t\tconst TEE_Attribute *p = &params[n];\n\n\t\tswitch (p->attributeID) {\n\t\tcase TEE_ATTR_SM2_KEP_USER:\n\t\t\tkep_parms->is_initiator = !p->content.value.a;\n\t\t\tfound |= BIT(IS_INITIATOR);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_ECC_PUBLIC_VALUE_X:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_key->x);\n\t\t\tfound |= BIT(PEER_KEY_X);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_ECC_PUBLIC_VALUE_Y:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_key->y);\n\t\t\tfound |= BIT(PEER_KEY_Y);\n\t\t\tbreak;\n\t\tcase __OPTEE_SM2_KEP_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_X:\n\t\tcase TEE_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_X:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_eph_key->x);\n\t\t\tfound |= BIT(PEER_EPH_KEY_X);\n\t\t\tbreak;\n\t\tcase __OPTEE_SM2_KEP_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_Y:\n\t\tcase TEE_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_Y:\n\t\t\tcrypto_bignum_bin2bn(p->content.ref.buffer,\n\t\t\t\t\t     p->content.ref.length,\n\t\t\t\t\t     peer_eph_key->y);\n\t\t\tfound |= BIT(PEER_EPH_KEY_Y);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_ID_INITIATOR:\n\t\t\tkep_parms->initiator_id = p->content.ref.buffer;\n\t\t\tkep_parms->initiator_id_len = p->content.ref.length;\n\t\t\tfound |= BIT(INITIATOR_ID);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_ID_RESPONDER:\n\t\t\tkep_parms->responder_id = p->content.ref.buffer;\n\t\t\tkep_parms->responder_id_len = p->content.ref.length;\n\t\t\tfound |= BIT(RESPONDER_ID);\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_KEP_CONFIRMATION_IN:\n\t\t\tkep_parms->conf_in = p->content.ref.buffer;\n\t\t\tkep_parms->conf_in_len = p->content.ref.length;\n\t\t\tbreak;\n\t\tcase TEE_ATTR_SM2_KEP_CONFIRMATION_OUT:\n\t\t\tkep_parms->conf_out = p->content.ref.buffer;\n\t\t\tkep_parms->conf_out_len = p->content.ref.length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Unexpected attribute */\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((found & mandatory) != mandatory) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\treturn TEE_SUCCESS;\nout:\n\tcrypto_acipher_free_ecc_public_key(peer_eph_key);\nout_p:\n\tcrypto_acipher_free_ecc_public_key(peer_key);\n\treturn res;\n}\n#endif\n\nTEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_obj *ko = NULL;\n\tstruct tee_obj *so = NULL;\n\tstruct tee_cryp_state *cs = NULL;\n\tstruct tee_cryp_obj_secret *sk = NULL;\n\tconst struct tee_cryp_obj_type_props *type_props = NULL;\n\tTEE_Attribute *params = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tstruct bignum *pub = NULL;\n\t\tstruct bignum *ss = NULL;\n\t\tsize_t bin_size = 0;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbin_size = params[0].content.ref.length;\n\n\t\tif (MUL_OVERFLOW(bin_size, 8, &alloc_size)) {\n\t\t\tres = TEE_ERROR_OVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     bin_size, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(&pub);\n\t\tcrypto_bignum_free(&ss);\n\t} else if (cs->algo == TEE_ALG_ECDH_DERIVE_SHARED_SECRET) {\n\t\tuint32_t curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tstruct ecc_public_key key_public = { };\n\t\tuint8_t *pt_secret = NULL;\n\t\tunsigned long pt_secret_len = 0;\n\t\tuint32_t key_type = TEE_TYPE_ECDH_PUBLIC_KEY;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (curve) {\n\t\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public, key_type,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = 0;\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(cs->algo, params, param_count, &salt,\n\t\t\t\t      &salt_len, &info, &info_len, &okm_len,\n\t\t\t\t      &hash_id);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_SM2_KEP)\n\telse if (cs->algo == TEE_ALG_SM2_KEP) {\n\t\tstruct ecc_public_key peer_eph_key = { };\n\t\tstruct ecc_public_key peer_key = { };\n\t\tstruct sm2_kep_parms kep_parms = {\n\t\t\t.out = (uint8_t *)(sk + 1),\n\t\t\t.out_len = so->info.maxObjectSize,\n\t\t};\n\t\tstruct tee_obj *ko2 = NULL;\n\n\t\tres = tee_obj_get(utc, cs->key2, &ko2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tres = get_sm2_kep_params(params, param_count, &peer_key,\n\t\t\t\t\t &peer_eph_key, &kep_parms);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * key1 is our private keypair, key2 is our ephemeral public key\n\t\t */\n\t\tres = crypto_acipher_sm2_kep_derive(ko->attr, /* key1 */\n\t\t\t\t\t\t    ko2->attr, /* key2 */\n\t\t\t\t\t\t    &peer_key, &peer_eph_key,\n\t\t\t\t\t\t    &kep_parms);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = kep_parms.out_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t\tcrypto_acipher_free_ecc_public_key(&peer_key);\n\t\tcrypto_acipher_free_ecc_public_key(&peer_eph_key);\n\t}\n#endif\n#if defined(CFG_CRYPTO_X25519)\n\telse if (cs->algo == TEE_ALG_X25519) {\n\t\tuint8_t *x25519_pub_key = NULL;\n\t\tuint8_t *pt_secret = NULL;\n\t\tunsigned long pt_secret_len = 0;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_X25519_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* X25519 public key size is 32 bytes */\n\t\tif (params[0].content.ref.length != KEY_SIZE_BYTES_25519) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Set the public key */\n\t\tx25519_pub_key = params[0].content.ref.buffer;\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_x25519_shared_secret(ko->attr,\n\t\t\t\t\t\t\t  x25519_pub_key,\n\t\t\t\t\t\t\t  pt_secret,\n\t\t\t\t\t\t\t  &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n\nTEE_Result syscall_cryp_random_number_generate(void *buf, size_t blen)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\n\tbuf = memtag_strip_tag(buf);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE,\n\t\t\t\t     (uaddr_t)buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_rng_read(buf, blen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_obj_secret *key = NULL;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_obj *o = NULL;\n\n\tnonce = memtag_strip_tag_const(nonce);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->mode, (uint8_t *)(key + 1),\n\t\t\t\t  key->key_size, nonce, nonce_len, tag_len,\n\t\t\t\t  aad_len, payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\t\t      const void *aad_data, size_t aad_data_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\n\taad_data = memtag_strip_tag_const(aad_data);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)aad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->mode, aad_data,\n\t\t\t\t\taad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\t\t\t  const void *src_data,\n\t\t\t\t\t  size_t src_len, void *dst_data,\n\t\t\t\t\t  uint64_t *dst_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&to_user_ta_ctx(sess->ctx)->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->mode, src_data,\n\t\t\t\t\t    src_len, dst_data, &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_enc_final(unsigned long state, const void *src_data,\n\t\t\t\t     size_t src_len, void *dst_data,\n\t\t\t\t     uint64_t *dst_len, void *tag,\n\t\t\t\t     uint64_t *tag_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\ttag = memtag_strip_tag(tag);\n\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = vm_check_access_rights(uctx,\n\t\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t     (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, src_data, src_len, dst_data,\n\t\t\t\t       &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = TEE_SUCCESS;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_mode_ctx *uctx = &to_user_ta_ctx(sess->ctx)->uctx;\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tsize_t dlen = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\ttag = memtag_strip_tag_const(tag);\n\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = vm_check_access_rights(uctx,\n\t\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t     (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\t/* Despite TEE Internal Core API up to v1.3, tag is [inbuf], not [in] */\n\tres = vm_check_access_rights(uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, src_data, src_len, dst_data,\n\t\t\t\t       &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nstatic int pkcs1_get_salt_len(const TEE_Attribute *params, uint32_t num_params,\n\t\t\t      size_t default_len)\n{\n\tsize_t n;\n\n\tassert(default_len < INT_MAX);\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tif (params[n].attributeID == TEE_ATTR_RSA_PSS_SALT_LENGTH) {\n\t\t\tif (params[n].content.value.a < INT_MAX)\n\t\t\t\treturn params[n].content.value.a;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * If salt length isn't provided use the default value which is\n\t * the length of the digest.\n\t */\n\treturn default_len;\n}\n\nTEE_Result syscall_asymm_operate(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *src_data, size_t src_len,\n\t\t\tvoid *dst_data, uint64_t *dst_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tTEE_Result res = TEE_SUCCESS;\n\tstruct tee_cryp_state *cs = NULL;\n\tsize_t dlen = 0;\n\tstruct tee_obj *o = NULL;\n\tvoid *label = NULL;\n\tsize_t label_len = 0;\n\tsize_t n = 0;\n\tint salt_len = 0;\n\tTEE_Attribute *params = NULL;\n\tsize_t alloc_size = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tsrc_data = memtag_strip_tag_const(src_data);\n\tdst_data = memtag_strip_tag(dst_data);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_GENERIC;\n\t\tgoto out;\n\t}\n\n\tswitch (cs->algo) {\n\tcase TEE_ALG_RSA_NOPAD:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t      src_len, dst_data,\n\t\t\t\t\t\t\t      &dlen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We will panic because \"the mode is not compatible\n\t\t\t * with the function\"\n\t\t\t */\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_SM2_PKE:\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_sm2_pke_encrypt(o->attr, src_data,\n\t\t\t\t\t\t\t     src_len, dst_data,\n\t\t\t\t\t\t\t     &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_sm2_pke_decrypt(o->attr, src_data,\n\t\t\t\t\t\t\t     src_len, dst_data,\n\t\t\t\t\t\t\t     &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_GENERIC;\n\t\t}\n\t\tbreak;\n\n\tcase TEE_ALG_RSAES_PKCS1_V1_5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_MD5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\t\tfor (n = 0; n < num_params; n++) {\n\t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {\n\t\t\t\tlabel = params[n].content.ref.buffer;\n\t\t\t\tlabel_len = params[n].content.ref.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the optional TEE_ATTR_RSA_OAEP_MGF_HASH is\n\t\t\t * provided for algorithm\n\t\t\t * TEE_ALG_RSAES_PKCS1_OAEP_MGF1_x it must match\n\t\t\t * the internal hash x since we don't support using\n\t\t\t * a different hash for MGF1 yet.\n\t\t\t */\n\t\t\tif (cs->algo != TEE_ALG_RSAES_PKCS1_V1_5 &&\n\t\t\t    params[n].attributeID ==\n\t\t\t    TEE_ATTR_RSA_OAEP_MGF_HASH) {\n\t\t\t\tuint32_t hash = 0;\n\n\t\t\t\tif (params[n].content.ref.length !=\n\t\t\t\t    sizeof(hash)) {\n\t\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(&hash, params[n].content.ref.buffer,\n\t\t\t\t       sizeof(hash));\n\t\t\t\tif (hash !=\n\t\t\t\t    TEE_INTERNAL_HASH_TO_ALGO(cs->algo)) {\n\t\t\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cs->mode == TEE_MODE_ENCRYPT) {\n\t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,\n\t\t\t\t\t\t\t   label, label_len,\n\t\t\t\t\t\t\t   src_data, src_len,\n\t\t\t\t\t\t\t   dst_data, &dlen);\n\t\t} else if (cs->mode == TEE_MODE_DECRYPT) {\n\t\t\tres = crypto_acipher_rsaes_decrypt(\n\t\t\t\t\tcs->algo, o->attr, label, label_len,\n\t\t\t\t\tsrc_data, src_len, dst_data, &dlen);\n\t\t} else {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t\tbreak;\n\n#if defined(CFG_CRYPTO_RSASSA_NA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5:\n#endif\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tif (cs->mode != TEE_MODE_SIGN) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tbreak;\n\t\t}\n\t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);\n\t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t src_data, src_len, dst_data,\n\t\t\t\t\t\t &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_DSA_SHA256:\n\t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\n\tcase TEE_ALG_ED25519:\n\t\tres = tee_svc_obj_ed25519_sign(o->attr, src_data, src_len,\n\t\t\t\t\t       dst_data, &dlen, params,\n\t\t\t\t\t       num_params);\n\t\tbreak;\n\n\tcase TEE_ALG_ECDSA_SHA1:\n\tcase TEE_ALG_ECDSA_SHA224:\n\tcase TEE_ALG_ECDSA_SHA256:\n\tcase TEE_ALG_ECDSA_SHA384:\n\tcase TEE_ALG_ECDSA_SHA512:\n\tcase TEE_ALG_SM2_DSA_SM3:\n\t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,\n\t\t\t\t\t      src_len, dst_data, &dlen);\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\nout:\n\tfree_wipe(params);\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_asymm_verify(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tsize_t num_params, const void *data, size_t data_len,\n\t\t\tconst void *sig, size_t sig_len)\n{\n\tstruct ts_session *sess = ts_get_current_session();\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tstruct tee_cryp_state *cs = NULL;\n\tTEE_Result res = TEE_SUCCESS;\n\tTEE_Attribute *params = NULL;\n\tstruct tee_obj *o = NULL;\n\tsize_t hash_size = 0;\n\tuint32_t hash_algo = 0;\n\tint salt_len = 0;\n\tsize_t alloc_size = 0;\n\n\tres = tee_svc_cryp_get_state(sess, uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_VERIFY)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tdata = memtag_strip_tag_const(data);\n\tsig = memtag_strip_tag_const(sig);\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)data, data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = vm_check_access_rights(&utc->uctx,\n\t\t\t\t     TEE_MEMORY_ACCESS_READ |\n\t\t\t\t     TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t     (uaddr_t)sig, sig_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(utc, usr_params, num_params, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tswitch (TEE_ALG_GET_MAIN_ALG(cs->algo)) {\n\tcase TEE_MAIN_ALGO_RSA:\n\t\tif (cs->algo != TEE_ALG_RSASSA_PKCS1_V1_5) {\n\t\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\t\tres = tee_alg_get_digest_size(hash_algo, &hash_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tif (data_len != hash_size) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsalt_len = pkcs1_get_salt_len(params, num_params,\n\t\t\t\t\t\t      hash_size);\n\t\t}\n\t\tres = crypto_acipher_rsassa_verify(cs->algo, o->attr, salt_len,\n\t\t\t\t\t\t   data, data_len, sig,\n\t\t\t\t\t\t   sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_DSA:\n\t\thash_algo = TEE_DIGEST_HASH_TO_ALGO(cs->algo);\n\t\tres = tee_alg_get_digest_size(hash_algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tbreak;\n\n\t\tif (data_len != hash_size) {\n\t\t\tstruct dsa_public_key *key = o->attr;\n\n\t\t\t/*\n\t\t\t * Depending on the DSA algorithm (NIST), the\n\t\t\t * digital signature output size may be truncated\n\t\t\t * to the size of a key pair (Q prime size). Q\n\t\t\t * prime size must be less or equal than the hash\n\t\t\t * output length of the hash algorithm involved.\n\t\t\t *\n\t\t\t * We're checking here in order to be able to\n\t\t\t * return this particular error code, which will\n\t\t\t * cause TEE_AsymmetricVerifyDigest() to panic as\n\t\t\t * required by GP. crypto_acipher_dsa_verify() is\n\t\t\t * implemented in the glue layer of the crypto\n\t\t\t * library and it might be a bit harder to catch\n\t\t\t * this particular case there or lead to duplicated\n\t\t\t * code in different crypto glue layers.\n\t\t\t *\n\t\t\t * The GP spec says that we SHOULD panic if\n\t\t\t * data_len != hash_size, but that would break a\n\t\t\t * few of the DSA tests in xtest where the\n\t\t\t * hash_size is larger than possible data_len. So\n\t\t\t * the compromise is in case data_len != hash_size\n\t\t\t * check that it's not smaller than what makes\n\t\t\t * sense.\n\t\t\t */\n\t\t\tif (data_len != crypto_bignum_num_bytes(key->q)) {\n\t\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = crypto_acipher_dsa_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ED25519:\n\t\tres = tee_svc_obj_ed25519_verify(o->attr, data,\n\t\t\t\t\t\t data_len, sig, sig_len,\n\t\t\t\t\t\t params, num_params);\n\t\tbreak;\n\n\tcase TEE_MAIN_ALGO_ECDSA:\n\tcase TEE_MAIN_ALGO_SM2_DSA_SM3:\n\t\tres = crypto_acipher_ecc_verify(cs->algo, o->attr, data,\n\t\t\t\t\t\tdata_len, sig, sig_len);\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t}\n\nout:\n\tfree_wipe(params);\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <crypto/crypto.h>\n#include <kernel/panic.h>\n#include <mbedtls/bignum.h>\n#include <stdlib.h>\n#include <string.h>\n#include <util.h>\n\n#define ciL\t\t(sizeof(mbedtls_mpi_uint))\t/* chars in limb  */\n#define biL\t\t(ciL << 3)\t\t\t/* bits  in limb  */\n#define BITS_TO_LIMBS(i) ((i) / biL + ((i) % biL != 0))\n\nsize_t crypto_bignum_num_bytes(struct bignum *a)\n{\n\tassert(a != NULL);\n\treturn mbedtls_mpi_size((const mbedtls_mpi *)a);\n}\n\nsize_t crypto_bignum_num_bits(struct bignum *a)\n{\n\tassert(a != NULL);\n\treturn mbedtls_mpi_bitlen((const mbedtls_mpi *)a);\n}\n\nint32_t crypto_bignum_compare(struct bignum *a, struct bignum *b)\n{\n\tint ret = 0;\n\n\tassert(a != NULL);\n\tassert(b != NULL);\n\tret = mbedtls_mpi_cmp_mpi((const mbedtls_mpi *)a,\n\t\t\t\t  (const mbedtls_mpi *)b);\n\treturn CMP_TRILEAN(ret, 0);\n}\n\nvoid crypto_bignum_bn2bin(const struct bignum *from, uint8_t *to)\n{\n\tsize_t len = 0;\n\n\tassert(from != NULL);\n\tassert(to != NULL);\n\tlen = crypto_bignum_num_bytes((struct bignum *)from);\n\tif (mbedtls_mpi_write_binary((mbedtls_mpi *)from, to, len))\n\t\tpanic();\n}\n\nTEE_Result crypto_bignum_bin2bn(const uint8_t *from, size_t fromsize,\n\t\t\t struct bignum *to)\n{\n\tassert(from != NULL);\n\tassert(to != NULL);\n\tif (mbedtls_mpi_read_binary((mbedtls_mpi *)to, from, fromsize))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\treturn TEE_SUCCESS;\n}\n\nvoid crypto_bignum_copy(struct bignum *to, const struct bignum *from)\n{\n\tassert(from != NULL);\n\tassert(to != NULL);\n\tif (mbedtls_mpi_copy((mbedtls_mpi *)to, (const mbedtls_mpi *)from))\n\t\tpanic();\n}\n\nstruct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tmbedtls_mpi *bn = NULL;\n\n\tif (size_bits > CFG_CORE_BIGNUM_MAX_BITS)\n\t\tsize_bits = CFG_CORE_BIGNUM_MAX_BITS;\n\n\tbn = calloc(1, sizeof(mbedtls_mpi));\n\tif (!bn)\n\t\treturn NULL;\n\tmbedtls_mpi_init(bn);\n\tif (mbedtls_mpi_grow(bn, BITS_TO_LIMBS(size_bits)) != 0) {\n\t\tfree(bn);\n\t\treturn NULL;\n\t}\n\n\treturn (struct bignum *)bn;\n}\n\nvoid crypto_bignum_free(struct bignum **s)\n{\n\tassert(s);\n\n\tmbedtls_mpi_free((mbedtls_mpi *)*s);\n\tfree(*s);\n\t*s = NULL;\n}\n\nvoid crypto_bignum_clear(struct bignum *s)\n{\n\tmbedtls_mpi *bn = (mbedtls_mpi *)s;\n\n\tmemset(bn->p, 0, mbedtls_mpi_size((const mbedtls_mpi *)bn));\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <crypto/crypto.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/dhm.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"mbed_helpers.h\"\n\nTEE_Result crypto_acipher_alloc_dh_keypair(struct dh_keypair *s,\n\t\t\t\t\t   size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->g = crypto_bignum_allocate(key_size_bits);\n\tif (!s->g)\n\t\tgoto err;\n\ts->p = crypto_bignum_allocate(key_size_bits);\n\tif (!s->p)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->q = crypto_bignum_allocate(key_size_bits);\n\tif (!s->q)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->g);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->y);\n\tcrypto_bignum_free(&s->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_gen_dh_key(struct dh_keypair *key,\n\t\t\t\t     struct bignum *q __unused,\n\t\t\t\t     size_t xbits, size_t key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_dhm_context dhm;\n\tunsigned char *buf = NULL;\n\tsize_t xbytes = 0;\n\n\tmemset(&dhm, 0, sizeof(dhm));\n\tmbedtls_dhm_init(&dhm);\n\n\tdhm.G = *(mbedtls_mpi *)key->g;\n\tdhm.P = *(mbedtls_mpi *)key->p;\n\n\tdhm.len = crypto_bignum_num_bytes(key->p);\n\tif (key_size != 8 * dhm.len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tif (xbits == 0)\n\t\txbytes = dhm.len;\n\telse\n\t\txbytes = xbits / 8;\n\n\tbuf = malloc(dhm.len);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\tlmd_res = mbedtls_dhm_make_public(&dhm, (int)xbytes, buf,\n\t\t\t\t\t  dhm.len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_dhm_make_public err, return is 0x%x\", -lmd_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\tcrypto_bignum_bin2bn(buf, xbytes, key->y);\n\t\tcrypto_bignum_copy(key->x, (void *)&dhm.X);\n\t\tres = TEE_SUCCESS;\n\t}\nout:\n\tfree(buf);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&dhm.G);\n\tmbedtls_mpi_init(&dhm.P);\n\tmbedtls_dhm_free(&dhm);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_dh_shared_secret(struct dh_keypair *private_key,\n\t\t\t\t\t   struct bignum *public_key,\n\t\t\t\t\t   struct bignum *secret)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_dhm_context dhm;\n\tunsigned char *buf = NULL;\n\tsize_t olen = 0;\n\n\tmemset(&dhm, 0, sizeof(dhm));\n\tmbedtls_dhm_init(&dhm);\n\n\tdhm.G = *(mbedtls_mpi *)private_key->g;\n\tdhm.P = *(mbedtls_mpi *)private_key->p;\n\tdhm.GX = *(mbedtls_mpi *)private_key->y;\n\tdhm.X = *(mbedtls_mpi *)private_key->x;\n\tdhm.GY = *(mbedtls_mpi *)public_key;\n\n\tdhm.len = crypto_bignum_num_bytes(private_key->p);\n\n\tbuf = malloc(dhm.len);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tlmd_res = mbedtls_dhm_calc_secret(&dhm, buf, dhm.len,\n\t\t\t\t\t  &olen, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_dhm_calc_secret failed, ret is 0x%x\", -lmd_res);\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\tcrypto_bignum_bin2bn(buf, olen, secret);\n\t\tres = TEE_SUCCESS;\n\t}\nout:\n\tfree(buf);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&dhm.G);\n\tmbedtls_mpi_init(&dhm.P);\n\tmbedtls_mpi_init(&dhm.GX);\n\tmbedtls_mpi_init(&dhm.X);\n\tmbedtls_mpi_init(&dhm.GY);\n\tmbedtls_dhm_free(&dhm);\n\treturn res;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <config.h>\n#include <crypto/crypto_impl.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/ecdh.h>\n#include <mbedtls/ecdsa.h>\n#include <mbedtls/ecp.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/pk.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"mbed_helpers.h\"\n#include \"sm2-dsa.h\"\n#include \"sm2-pke.h\"\n\n/* Translate mbedtls result to TEE result */\nstatic TEE_Result get_tee_result(int lmd_res)\n{\n\tswitch (lmd_res) {\n\tcase 0:\n\t\treturn TEE_SUCCESS;\n\tcase MBEDTLS_ERR_ECP_VERIFY_FAILED:\n\t\treturn TEE_ERROR_SIGNATURE_INVALID;\n\tcase MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL:\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n}\n\nstatic void ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n}\n\nstatic TEE_Result ecc_get_keysize(uint32_t curve, uint32_t algo,\n\t\t\t\t  size_t *key_size_bytes, size_t *key_size_bits)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\t*key_size_bits = 192;\n\t\t*key_size_bytes = 24;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\t*key_size_bits = 224;\n\t\t*key_size_bytes = 28;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\t*key_size_bits = 256;\n\t\t*key_size_bytes = 32;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\t*key_size_bits = 384;\n\t\t*key_size_bytes = 48;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\t*key_size_bits = 521;\n\t\t*key_size_bytes = 66;\n\t\tbreak;\n\tcase TEE_ECC_CURVE_SM2:\n\t\t*key_size_bits = 256;\n\t\t*key_size_bytes = 32;\n\t\tif (algo != 0 && algo != TEE_ALG_SM2_DSA_SM3 &&\n\t\t    algo != TEE_ALG_SM2_KEP && algo != TEE_ALG_SM2_PKE)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\t*key_size_bits = 0;\n\t\t*key_size_bytes = 0;\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Clear some memory that was used to prepare the context\n */\nstatic void ecc_clear_precomputed(mbedtls_ecp_group *grp)\n{\n\tsize_t i = 0;\n\n\tif (grp->T) {\n\t\tfor (i = 0; i < grp->T_size; i++)\n\t\t\tmbedtls_ecp_point_free(&grp->T[i]);\n\t\tfree(grp->T);\n\t}\n\tgrp->T = NULL;\n\tgrp->T_size = 0;\n}\n\nstatic mbedtls_ecp_group_id curve_to_group_id(uint32_t curve)\n{\n\tswitch (curve) {\n\tcase TEE_ECC_CURVE_NIST_P192:\n\t\treturn MBEDTLS_ECP_DP_SECP192R1;\n\tcase TEE_ECC_CURVE_NIST_P224:\n\t\treturn MBEDTLS_ECP_DP_SECP224R1;\n\tcase TEE_ECC_CURVE_NIST_P256:\n\t\treturn MBEDTLS_ECP_DP_SECP256R1;\n\tcase TEE_ECC_CURVE_NIST_P384:\n\t\treturn MBEDTLS_ECP_DP_SECP384R1;\n\tcase TEE_ECC_CURVE_NIST_P521:\n\t\treturn MBEDTLS_ECP_DP_SECP521R1;\n\tcase TEE_ECC_CURVE_SM2:\n\t\treturn MBEDTLS_ECP_DP_SM2;\n\tdefault:\n\t\treturn MBEDTLS_ECP_DP_NONE;\n\t}\n}\n\nstatic TEE_Result ecc_generate_keypair(struct ecc_keypair *key, size_t key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_ecdsa_context ecdsa;\n\tmbedtls_ecp_group_id gid;\n\tsize_t key_size_bytes = 0;\n\tsize_t key_size_bits = 0;\n\n\tmemset(&ecdsa, 0, sizeof(ecdsa));\n\tmemset(&gid, 0, sizeof(gid));\n\n\tres = ecc_get_keysize(key->curve, 0, &key_size_bytes, &key_size_bits);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (key_size != key_size_bits)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmbedtls_ecdsa_init(&ecdsa);\n\n\t/* Generate the ECC key */\n\tgid = curve_to_group_id(key->curve);\n\tlmd_res = mbedtls_ecdsa_genkey(&ecdsa, gid, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tFMSG(\"mbedtls_ecdsa_genkey failed.\");\n\t\tgoto exit;\n\t}\n\tecc_clear_precomputed(&ecdsa.grp);\n\n\t/* check the size of the keys */\n\tif ((mbedtls_mpi_bitlen(&ecdsa.Q.X) > key_size_bits) ||\n\t    (mbedtls_mpi_bitlen(&ecdsa.Q.Y) > key_size_bits) ||\n\t    (mbedtls_mpi_bitlen(&ecdsa.d) > key_size_bits)) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tFMSG(\"Check the size of the keys failed.\");\n\t\tgoto exit;\n\t}\n\n\t/* check LMD is returning z==1 */\n\tif (mbedtls_mpi_bitlen(&ecdsa.Q.Z) != 1) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tFMSG(\"Check LMD failed.\");\n\t\tgoto exit;\n\t}\n\n\t/* Copy the key */\n\tcrypto_bignum_copy(key->d, (void *)&ecdsa.d);\n\tcrypto_bignum_copy(key->x, (void *)&ecdsa.Q.X);\n\tcrypto_bignum_copy(key->y, (void *)&ecdsa.Q.Y);\n\n\tres = TEE_SUCCESS;\nexit:\n\tmbedtls_ecdsa_free(&ecdsa);\t\t/* Free the temporary key */\n\treturn res;\n}\n\nstatic TEE_Result ecc_sign(uint32_t algo, struct ecc_keypair *key,\n\t\t\t   const uint8_t *msg, size_t msg_len, uint8_t *sig,\n\t\t\t   size_t *sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tmbedtls_ecdsa_context ecdsa;\n\tmbedtls_ecp_group_id gid;\n\tsize_t key_size_bytes = 0;\n\tsize_t key_size_bits = 0;\n\tmbedtls_mpi r;\n\tmbedtls_mpi s;\n\n\tmemset(&ecdsa, 0, sizeof(ecdsa));\n\tmemset(&gid, 0, sizeof(gid));\n\tmemset(&r, 0, sizeof(r));\n\tmemset(&s, 0, sizeof(s));\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmbedtls_mpi_init(&r);\n\tmbedtls_mpi_init(&s);\n\n\tmbedtls_ecdsa_init(&ecdsa);\n\n\tgid = curve_to_group_id(key->curve);\n\tlmd_res = mbedtls_ecp_group_load(&ecdsa.grp, gid);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tecdsa.d = *(mbedtls_mpi *)key->d;\n\n\tres = ecc_get_keysize(key->curve, algo, &key_size_bytes,\n\t\t\t      &key_size_bits);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tif (*sig_len < 2 * key_size_bytes) {\n\t\t*sig_len = 2 * key_size_bytes;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_ECDSA);\n\tif (pk_info == NULL) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tlmd_res = mbedtls_ecdsa_sign(&ecdsa.grp, &r, &s, &ecdsa.d, msg,\n\t\t\t\t     msg_len, mbd_rand, NULL);\n\tif (lmd_res == 0) {\n\t\t*sig_len = 2 * key_size_bytes;\n\t\tmemset(sig, 0, *sig_len);\n\t\tmbedtls_mpi_write_binary(&r, sig + *sig_len / 2 -\n\t\t\t\t\t mbedtls_mpi_size(&r),\n\t\t\t\t\t mbedtls_mpi_size(&r));\n\n\t\tmbedtls_mpi_write_binary(&s, sig + *sig_len -\n\t\t\t\t\t mbedtls_mpi_size(&s),\n\t\t\t\t\t mbedtls_mpi_size(&s));\n\t\tres = TEE_SUCCESS;\n\t} else {\n\t\tFMSG(\"mbedtls_ecdsa_sign failed, returned 0x%x\\n\", -lmd_res);\n\t\tres = TEE_ERROR_GENERIC;\n\t}\nout:\n\tmbedtls_mpi_free(&r);\n\tmbedtls_mpi_free(&s);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&ecdsa.d);\n\tmbedtls_ecdsa_free(&ecdsa);\n\treturn res;\n}\n\nstatic TEE_Result ecc_verify(uint32_t algo, struct ecc_public_key *key,\n\t\t\t     const uint8_t *msg, size_t msg_len,\n\t\t\t     const uint8_t *sig, size_t sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tmbedtls_ecdsa_context ecdsa;\n\tmbedtls_ecp_group_id gid;\n\tsize_t key_size_bytes, key_size_bits = 0;\n\tuint8_t one[1] = { 1 };\n\tmbedtls_mpi r;\n\tmbedtls_mpi s;\n\n\tmemset(&ecdsa, 0, sizeof(ecdsa));\n\tmemset(&gid, 0, sizeof(gid));\n\tmemset(&r, 0, sizeof(r));\n\tmemset(&s, 0, sizeof(s));\n\n\tif (algo == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmbedtls_mpi_init(&r);\n\tmbedtls_mpi_init(&s);\n\n\tmbedtls_ecdsa_init(&ecdsa);\n\n\tgid = curve_to_group_id(key->curve);\n\tlmd_res = mbedtls_ecp_group_load(&ecdsa.grp, gid);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tecdsa.Q.X = *(mbedtls_mpi *)key->x;\n\tecdsa.Q.Y = *(mbedtls_mpi *)key->y;\n\tmbedtls_mpi_read_binary(&ecdsa.Q.Z, one, sizeof(one));\n\n\tres = ecc_get_keysize(key->curve, algo,\n\t\t\t      &key_size_bytes, &key_size_bits);\n\tif (res != TEE_SUCCESS) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\t/* check keysize vs sig_len */\n\tif ((key_size_bytes * 2) != sig_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tmbedtls_mpi_read_binary(&r, sig, sig_len / 2);\n\tmbedtls_mpi_read_binary(&s, sig + sig_len / 2, sig_len / 2);\n\n\tlmd_res = mbedtls_ecdsa_verify(&ecdsa.grp, msg, msg_len, &ecdsa.Q,\n\t\t\t\t       &r, &s);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_ecdsa_verify failed, returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t}\nout:\n\tmbedtls_mpi_free(&r);\n\tmbedtls_mpi_free(&s);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&ecdsa.Q.X);\n\tmbedtls_mpi_init(&ecdsa.Q.Y);\n\tmbedtls_ecdsa_free(&ecdsa);\n\treturn res;\n}\n\nstatic TEE_Result ecc_shared_secret(struct ecc_keypair *private_key,\n\t\t\t\t    struct ecc_public_key *public_key,\n\t\t\t\t    void *secret, unsigned long *secret_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tuint8_t one[1] = { 1 };\n\tmbedtls_ecdh_context ecdh;\n\tmbedtls_ecp_group_id gid;\n\tsize_t out_len = 0;\n\n\tmemset(&ecdh, 0, sizeof(ecdh));\n\tmemset(&gid, 0, sizeof(gid));\n\tmbedtls_ecdh_init(&ecdh);\n\tgid = curve_to_group_id(private_key->curve);\n\tlmd_res = mbedtls_ecp_group_load(&ecdh.grp, gid);\n\tif (lmd_res != 0) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tecdh.d = *(mbedtls_mpi *)private_key->d;\n\tecdh.Qp.X = *(mbedtls_mpi *)public_key->x;\n\tecdh.Qp.Y = *(mbedtls_mpi *)public_key->y;\n\tmbedtls_mpi_read_binary(&ecdh.Qp.Z, one, sizeof(one));\n\n\tlmd_res = mbedtls_ecdh_calc_secret(&ecdh, &out_len, secret,\n\t\t\t\t\t   *secret_len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\t*secret_len = out_len;\nout:\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&ecdh.d);\n\tmbedtls_mpi_init(&ecdh.Qp.X);\n\tmbedtls_mpi_init(&ecdh.Qp.Y);\n\tmbedtls_ecdh_free(&ecdh);\n\treturn res;\n}\n\nstatic const struct crypto_ecc_keypair_ops ecc_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n\t.sign = ecc_sign,\n\t.shared_secret = ecc_shared_secret,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_pke_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n\t.decrypt = sm2_mbedtls_pke_decrypt,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_kep_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n};\n\nstatic const struct crypto_ecc_keypair_ops sm2_dsa_keypair_ops = {\n\t.generate = ecc_generate_keypair,\n\t.sign = sm2_mbedtls_dsa_sign,\n};\n\nconst struct crypto_ecc_keypair_ops *\ncrypto_asym_get_ecc_keypair_ops(uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\treturn &ecc_keypair_ops;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn NULL;\n\t\treturn &sm2_dsa_keypair_ops;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn NULL;\n\t\treturn &sm2_pke_keypair_ops;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_keypair_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_keypair(struct ecc_keypair *s,\n\t\t\t\t\t uint32_t key_type,\n\t\t\t\t\t size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\ts->ops = &ecc_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_keypair_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_KEYPAIR:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_keypair_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\ts->d = crypto_bignum_allocate(key_size_bits);\n\tif (!s->d)\n\t\tgoto err;\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nstatic const struct crypto_ecc_public_ops ecc_public_key_ops = {\n\t.free = ecc_free_public_key,\n\t.verify = ecc_verify,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_pke_public_key_ops = {\n\t.free = ecc_free_public_key,\n\t.encrypt = sm2_mbedtls_pke_encrypt,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_kep_public_key_ops = {\n\t.free = ecc_free_public_key,\n};\n\nstatic const struct crypto_ecc_public_ops sm2_dsa_public_key_ops = {\n\t.free = ecc_free_public_key,\n\t.verify = sm2_mbedtls_dsa_verify,\n};\n\nconst struct crypto_ecc_public_ops*\ncrypto_asym_get_ecc_public_ops(uint32_t key_type)\n{\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\treturn &ecc_public_key_ops;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn NULL;\n\n\t\treturn &sm2_dsa_public_key_ops;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn NULL;\n\n\t\treturn &sm2_pke_public_key_ops;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn NULL;\n\t\treturn &sm2_kep_public_key_ops;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nTEE_Result crypto_asym_alloc_ecc_public_key(struct ecc_public_key *s,\n\t\t\t\t\t    uint32_t key_type,\n\t\t\t\t\t    size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\n\tswitch (key_type) {\n\tcase TEE_TYPE_ECDSA_PUBLIC_KEY:\n\tcase TEE_TYPE_ECDH_PUBLIC_KEY:\n\t\ts->ops = &ecc_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_DSA_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_DSA))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_dsa_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_PKE_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_PKE))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_pke_public_key_ops;\n\t\tbreak;\n\tcase TEE_TYPE_SM2_KEP_PUBLIC_KEY:\n\t\tif (!IS_ENABLED(CFG_CRYPTO_SM2_KEP))\n\t\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\n\t\ts->curve = TEE_ECC_CURVE_SM2;\n\t\ts->ops = &sm2_kep_public_key_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(&s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n", "// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (C) 2018, ARM Limited\n * Copyright (C) 2019, Linaro Limited\n */\n\n#include <assert.h>\n#include <crypto/crypto.h>\n#include <crypto/crypto_impl.h>\n#include <mbedtls/ctr_drbg.h>\n#include <mbedtls/entropy.h>\n#include <mbedtls/pk.h>\n#include <mbedtls/pk_internal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <tee/tee_cryp_utl.h>\n#include <utee_defines.h>\n#include <fault_mitigation.h>\n\n#include \"mbed_helpers.h\"\n\nstatic TEE_Result get_tee_result(int lmd_res)\n{\n\tswitch (lmd_res) {\n\tcase 0:\n\t\treturn TEE_SUCCESS;\n\tcase MBEDTLS_ERR_RSA_PRIVATE_FAILED +\n\t\tMBEDTLS_ERR_MPI_BAD_INPUT_DATA:\n\tcase MBEDTLS_ERR_RSA_BAD_INPUT_DATA:\n\tcase MBEDTLS_ERR_RSA_INVALID_PADDING:\n\tcase MBEDTLS_ERR_PK_TYPE_MISMATCH:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tcase MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE:\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n}\n\nstatic uint32_t tee_algo_to_mbedtls_hash_algo(uint32_t algo)\n{\n\tswitch (algo) {\n#if defined(CFG_CRYPTO_SHA1)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:\n\tcase TEE_ALG_SHA1:\n\tcase TEE_ALG_DSA_SHA1:\n\tcase TEE_ALG_HMAC_SHA1:\n\t\treturn MBEDTLS_MD_SHA1;\n#endif\n#if defined(CFG_CRYPTO_MD5)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_MD5:\n\tcase TEE_ALG_MD5:\n\tcase TEE_ALG_HMAC_MD5:\n\t\treturn MBEDTLS_MD_MD5;\n#endif\n#if defined(CFG_CRYPTO_SHA224)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:\n\tcase TEE_ALG_SHA224:\n\tcase TEE_ALG_DSA_SHA224:\n\tcase TEE_ALG_HMAC_SHA224:\n\t\treturn MBEDTLS_MD_SHA224;\n#endif\n#if defined(CFG_CRYPTO_SHA256)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:\n\tcase TEE_ALG_SHA256:\n\tcase TEE_ALG_DSA_SHA256:\n\tcase TEE_ALG_HMAC_SHA256:\n\t\treturn MBEDTLS_MD_SHA256;\n#endif\n#if defined(CFG_CRYPTO_SHA384)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:\n\tcase TEE_ALG_SHA384:\n\tcase TEE_ALG_HMAC_SHA384:\n\t\treturn MBEDTLS_MD_SHA384;\n#endif\n#if defined(CFG_CRYPTO_SHA512)\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:\n\tcase TEE_ALG_SHA512:\n\tcase TEE_ALG_HMAC_SHA512:\n\t\treturn MBEDTLS_MD_SHA512;\n#endif\n\tdefault:\n\t\treturn MBEDTLS_MD_NONE;\n\t}\n}\n\nstatic void rsa_init_from_key_pair(mbedtls_rsa_context *rsa,\n\t\t\t\tstruct rsa_keypair *key)\n{\n\tmbedtls_rsa_init(rsa, 0, 0);\n\n\trsa->E = *(mbedtls_mpi *)key->e;\n\trsa->N = *(mbedtls_mpi *)key->n;\n\trsa->D = *(mbedtls_mpi *)key->d;\n\tif (key->p && crypto_bignum_num_bytes(key->p)) {\n\t\trsa->P = *(mbedtls_mpi *)key->p;\n\t\trsa->Q = *(mbedtls_mpi *)key->q;\n\t\trsa->QP = *(mbedtls_mpi *)key->qp;\n\t\trsa->DP = *(mbedtls_mpi *)key->dp;\n\t\trsa->DQ = *(mbedtls_mpi *)key->dq;\n\t}\n\trsa->len = mbedtls_mpi_size(&rsa->N);\n}\n\nstatic void mbd_rsa_free(mbedtls_rsa_context *rsa)\n{\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa->E);\n\tmbedtls_mpi_init(&rsa->N);\n\tmbedtls_mpi_init(&rsa->D);\n\tif (mbedtls_mpi_size(&rsa->P)) {\n\t\tmbedtls_mpi_init(&rsa->P);\n\t\tmbedtls_mpi_init(&rsa->Q);\n\t\tmbedtls_mpi_init(&rsa->QP);\n\t\tmbedtls_mpi_init(&rsa->DP);\n\t\tmbedtls_mpi_init(&rsa->DQ);\n\t}\n\tmbedtls_rsa_free(rsa);\n}\n\nTEE_Result crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_keypair\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_keypair(struct rsa_keypair *s,\n\t\t\t\t\t       size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->e = crypto_bignum_allocate(key_size_bits);\n\tif (!s->e)\n\t\tgoto err;\n\ts->d = crypto_bignum_allocate(key_size_bits);\n\tif (!s->d)\n\t\tgoto err;\n\ts->n = crypto_bignum_allocate(key_size_bits);\n\tif (!s->n)\n\t\tgoto err;\n\ts->p = crypto_bignum_allocate(key_size_bits);\n\tif (!s->p)\n\t\tgoto err;\n\ts->q = crypto_bignum_allocate(key_size_bits);\n\tif (!s->q)\n\t\tgoto err;\n\ts->qp = crypto_bignum_allocate(key_size_bits);\n\tif (!s->qp)\n\t\tgoto err;\n\ts->dp = crypto_bignum_allocate(key_size_bits);\n\tif (!s->dp)\n\t\tgoto err;\n\ts->dq = crypto_bignum_allocate(key_size_bits);\n\tif (!s->dq)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_acipher_free_rsa_keypair(s);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nTEE_Result crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits)\n__weak __alias(\"sw_crypto_acipher_alloc_rsa_public_key\");\n\nTEE_Result sw_crypto_acipher_alloc_rsa_public_key(struct rsa_public_key *s,\n\t\t\t\t\t\t  size_t key_size_bits)\n{\n\tmemset(s, 0, sizeof(*s));\n\ts->e = crypto_bignum_allocate(key_size_bits);\n\tif (!s->e)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\ts->n = crypto_bignum_allocate(key_size_bits);\n\tif (!s->n)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(&s->e);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}\n\nvoid crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_public_key\");\n\nvoid sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->e);\n}\n\nvoid crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n__weak __alias(\"sw_crypto_acipher_free_rsa_keypair\");\n\nvoid sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n}\n\nTEE_Result crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t      size_t key_size)\n__weak __alias(\"sw_crypto_acipher_gen_rsa_key\");\n\nTEE_Result sw_crypto_acipher_gen_rsa_key(struct rsa_keypair *key,\n\t\t\t\t\t size_t key_size)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tmbedtls_rsa_context rsa;\n\tmbedtls_ctr_drbg_context rngctx;\n\tint lmd_res = 0;\n\tuint32_t e = 0;\n\n\tmbedtls_ctr_drbg_init(&rngctx);\n\tif (mbedtls_ctr_drbg_seed(&rngctx, mbd_rand, NULL, NULL, 0))\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\t/* get the public exponent */\n\tmbedtls_mpi_write_binary((mbedtls_mpi *)key->e,\n\t\t\t\t (unsigned char *)&e, sizeof(uint32_t));\n\n\te = TEE_U32_FROM_BIG_ENDIAN(e);\n\tlmd_res = mbedtls_rsa_gen_key(&rsa, mbedtls_ctr_drbg_random, &rngctx,\n\t\t\t\t      key_size, (int)e);\n\tmbedtls_ctr_drbg_free(&rngctx);\n\tif (lmd_res != 0) {\n\t\tres = get_tee_result(lmd_res);\n\t} else if ((size_t)mbedtls_mpi_bitlen(&rsa.N) != key_size) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t} else {\n\t\t/* Copy the key */\n\t\tcrypto_bignum_copy(key->e, (void *)&rsa.E);\n\t\tcrypto_bignum_copy(key->d, (void *)&rsa.D);\n\t\tcrypto_bignum_copy(key->n, (void *)&rsa.N);\n\t\tcrypto_bignum_copy(key->p, (void *)&rsa.P);\n\n\t\tcrypto_bignum_copy(key->q, (void *)&rsa.Q);\n\t\tcrypto_bignum_copy(key->qp, (void *)&rsa.QP);\n\t\tcrypto_bignum_copy(key->dp, (void *)&rsa.DP);\n\t\tcrypto_bignum_copy(key->dq, (void *)&rsa.DQ);\n\n\t\tres = TEE_SUCCESS;\n\t}\n\n\tmbedtls_rsa_free(&rsa);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_encrypt(struct rsa_public_key *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tmbedtls_rsa_context rsa;\n\tint lmd_res = 0;\n\tuint8_t *buf = NULL;\n\tunsigned long blen = 0;\n\tunsigned long offset = 0;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\trsa.E = *(mbedtls_mpi *)key->e;\n\trsa.N = *(mbedtls_mpi *)key->n;\n\n\trsa.len = crypto_bignum_num_bytes((void *)&rsa.N);\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = malloc(blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tmemset(buf, 0, blen);\n\tmemcpy(buf + rsa.len - src_len, src, src_len);\n\n\tlmd_res = mbedtls_rsa_public(&rsa, buf, buf);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_rsa_public() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < rsa.len - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < rsa.len - offset) {\n\t\t*dst_len = rsa.len - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = rsa.len - offset;\n\tmemcpy(dst, buf + offset, *dst_len);\nout:\n\tfree(buf);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa.E);\n\tmbedtls_mpi_init(&rsa.N);\n\tmbedtls_rsa_free(&rsa);\n\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *src,\n\t\t\t\t\t   size_t src_len, uint8_t *dst,\n\t\t\t\t\t   size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsanopad_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsanopad_decrypt(struct rsa_keypair *key,\n\t\t\t\t\t      const uint8_t *src,\n\t\t\t\t\t      size_t src_len, uint8_t *dst,\n\t\t\t\t\t      size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tmbedtls_rsa_context rsa;\n\tint lmd_res = 0;\n\tuint8_t *buf = NULL;\n\tunsigned long blen = 0;\n\tunsigned long offset = 0;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\trsa_init_from_key_pair(&rsa, key);\n\n\tblen = CFG_CORE_BIGNUM_MAX_BITS / 8;\n\tbuf = malloc(blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tmemset(buf, 0, blen);\n\tmemcpy(buf + rsa.len - src_len, src, src_len);\n\n\tlmd_res = mbedtls_rsa_private(&rsa, NULL, NULL, buf, buf);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"mbedtls_rsa_private() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\n\t/* Remove the zero-padding (leave one zero if buff is all zeroes) */\n\toffset = 0;\n\twhile ((offset < rsa.len - 1) && (buf[offset] == 0))\n\t\toffset++;\n\n\tif (*dst_len < rsa.len - offset) {\n\t\t*dst_len = rsa.len - offset;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = rsa.len - offset;\n\tmemcpy(dst, (char *)buf + offset, *dst_len);\nout:\n\tif (buf)\n\t\tfree(buf);\n\tmbd_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_keypair *key,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_decrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_decrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_keypair *key,\n\t\t\t\t\t   const uint8_t *label __unused,\n\t\t\t\t\t   size_t label_len __unused,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t blen = 0;\n\tsize_t mod_size = 0;\n\tvoid *buf = NULL;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = MBEDTLS_MD_NONE;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\trsa_init_from_key_pair(&rsa, key);\n\n\t/*\n\t * Use a temporary buffer since we don't know exactly how large\n\t * the required size of the out buffer without doing a partial\n\t * decrypt. We know the upper bound though.\n\t */\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmod_size = crypto_bignum_num_bytes(key->n);\n\t\tblen = mod_size - 11;\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\t} else {\n\t\t/* Decoded message is always shorter than encrypted message */\n\t\tblen = src_len;\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\t}\n\n\tbuf = malloc(blen);\n\tif (!buf) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * TEE_ALG_RSAES_PKCS1_V1_5 is invalid in hash. But its hash algo will\n\t * not be used in rsa, so skip it here.\n\t */\n\tif (algo != TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\t\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tif (lmd_padding == MBEDTLS_RSA_PKCS_V15)\n\t\tlmd_res = pk_info->decrypt_func(&rsa, src, src_len, buf, &blen,\n\t\t\t\t\t\tblen, NULL, NULL);\n\telse\n\t\tlmd_res = pk_info->decrypt_func(&rsa, src, src_len, buf, &blen,\n\t\t\t\t\t\tblen, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"decrypt_func() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\n\tif (*dst_len < blen) {\n\t\t*dst_len = blen;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = TEE_SUCCESS;\n\t*dst_len = blen;\n\tmemcpy(dst, buf, blen);\nout:\n\tif (buf)\n\t\tfree(buf);\n\tmbd_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tconst uint8_t *label __unused,\n\t\t\t\t\tsize_t label_len __unused,\n\t\t\t\t\tconst uint8_t *src, size_t src_len,\n\t\t\t\t\tuint8_t *dst, size_t *dst_len)\n__weak __alias(\"sw_crypto_acipher_rsaes_encrypt\");\n\nTEE_Result sw_crypto_acipher_rsaes_encrypt(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   const uint8_t *label __unused,\n\t\t\t\t\t   size_t label_len __unused,\n\t\t\t\t\t   const uint8_t *src, size_t src_len,\n\t\t\t\t\t   uint8_t *dst, size_t *dst_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t mod_size = 0;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = MBEDTLS_MD_NONE;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\trsa.E = *(mbedtls_mpi *)key->e;\n\trsa.N = *(mbedtls_mpi *)key->n;\n\n\tmod_size = crypto_bignum_num_bytes(key->n);\n\tif (*dst_len < mod_size) {\n\t\t*dst_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\t*dst_len = mod_size;\n\trsa.len = mod_size;\n\n\tif (algo == TEE_ALG_RSAES_PKCS1_V1_5)\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\telse\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * TEE_ALG_RSAES_PKCS1_V1_5 is invalid in hash. But its hash algo will\n\t * not be used in rsa, so skip it here.\n\t */\n\tif (algo != TEE_ALG_RSAES_PKCS1_V1_5) {\n\t\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\t\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tlmd_res = pk_info->encrypt_func(&rsa, src, src_len, dst, dst_len,\n\t\t\t\t\t*dst_len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"encrypt_func() returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto out;\n\t}\n\tres = TEE_SUCCESS;\nout:\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa.E);\n\tmbedtls_mpi_init(&rsa.N);\n\tmbedtls_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t      int salt_len __unused,\n\t\t\t\t      const uint8_t *msg, size_t msg_len,\n\t\t\t\t      uint8_t *sig, size_t *sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_sign\");\n\nTEE_Result sw_crypto_acipher_rsassa_sign(uint32_t algo, struct rsa_keypair *key,\n\t\t\t\t\t int salt_len __unused,\n\t\t\t\t\t const uint8_t *msg, size_t msg_len,\n\t\t\t\t\t uint8_t *sig, size_t *sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t mod_size = 0;\n\tsize_t hash_size = 0;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = 0;\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\trsa_init_from_key_pair(&rsa, key);\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t      &hash_size);\n\tif (res != TEE_SUCCESS)\n\t\tgoto err;\n\n\tif (msg_len != hash_size) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tmod_size = crypto_bignum_num_bytes(key->n);\n\tif (*sig_len < mod_size) {\n\t\t*sig_len = mod_size;\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto err;\n\t}\n\trsa.len = mod_size;\n\n\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tif (lmd_padding == MBEDTLS_RSA_PKCS_V15)\n\t\tlmd_res = pk_info->sign_func(&rsa, md_algo, msg, msg_len, sig,\n\t\t\t\t\t     sig_len, NULL, NULL);\n\telse\n\t\tlmd_res = pk_info->sign_func(&rsa, md_algo, msg, msg_len, sig,\n\t\t\t\t\t     sig_len, mbd_rand, NULL);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"sign_func failed, returned 0x%x\", -lmd_res);\n\t\tres = get_tee_result(lmd_res);\n\t\tgoto err;\n\t}\n\tres = TEE_SUCCESS;\nerr:\n\tmbd_rsa_free(&rsa);\n\treturn res;\n}\n\nTEE_Result crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\tstruct rsa_public_key *key,\n\t\t\t\t\tint salt_len __unused,\n\t\t\t\t\tconst uint8_t *msg,\n\t\t\t\t\tsize_t msg_len, const uint8_t *sig,\n\t\t\t\t\tsize_t sig_len)\n__weak __alias(\"sw_crypto_acipher_rsassa_verify\");\n\nTEE_Result sw_crypto_acipher_rsassa_verify(uint32_t algo,\n\t\t\t\t\t   struct rsa_public_key *key,\n\t\t\t\t\t   int salt_len __unused,\n\t\t\t\t\t   const uint8_t *msg,\n\t\t\t\t\t   size_t msg_len, const uint8_t *sig,\n\t\t\t\t\t   size_t sig_len)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tint lmd_res = 0;\n\tint lmd_padding = 0;\n\tsize_t hash_size = 0;\n\tsize_t bigint_size = 0;\n\tmbedtls_rsa_context rsa;\n\tconst mbedtls_pk_info_t *pk_info = NULL;\n\tuint32_t md_algo = 0;\n\tstruct ftmn ftmn = { };\n\tunsigned long arg_hash = 0;\n\n\t/*\n\t * The caller expects to call crypto_acipher_rsassa_verify(),\n\t * update the hash as needed.\n\t */\n\tFTMN_CALLEE_SWAP_HASH(FTMN_FUNC_HASH(\"crypto_acipher_rsassa_verify\"));\n\n\tmemset(&rsa, 0, sizeof(rsa));\n\tmbedtls_rsa_init(&rsa, 0, 0);\n\n\trsa.E = *(mbedtls_mpi *)key->e;\n\trsa.N = *(mbedtls_mpi *)key->n;\n\n\tres = tee_alg_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(algo),\n\t\t\t\t      &hash_size);\n\tif (res != TEE_SUCCESS)\n\t\tgoto err;\n\n\tif (msg_len != hash_size) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tbigint_size = crypto_bignum_num_bytes(key->n);\n\tif (sig_len < bigint_size) {\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\t\tgoto err;\n\t}\n\n\trsa.len = bigint_size;\n\n\tswitch (algo) {\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:\n\t\targ_hash = FTMN_FUNC_HASH(\"mbedtls_rsa_rsassa_pkcs1_v15_verify\");\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V15;\n\t\tbreak;\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_MD5:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:\n\tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:\n\t\targ_hash = FTMN_FUNC_HASH(\"mbedtls_rsa_rsassa_pss_verify_ext\");\n\t\tlmd_padding = MBEDTLS_RSA_PKCS_V21;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto err;\n\t}\n\n\tmd_algo = tee_algo_to_mbedtls_hash_algo(algo);\n\tif (md_algo == MBEDTLS_MD_NONE) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tpk_info = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);\n\tif (!pk_info) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto err;\n\t}\n\n\tmbedtls_rsa_set_padding(&rsa, lmd_padding, md_algo);\n\n\tFTMN_PUSH_LINKED_CALL(&ftmn, arg_hash);\n\tlmd_res = pk_info->verify_func(&rsa, md_algo, msg, msg_len,\n\t\t\t\t       sig, sig_len);\n\tif (!lmd_res)\n\t\tFTMN_SET_CHECK_RES_FROM_CALL(&ftmn, FTMN_INCR0, lmd_res);\n\tFTMN_POP_LINKED_CALL(&ftmn);\n\tif (lmd_res != 0) {\n\t\tFMSG(\"verify_func failed, returned 0x%x\", -lmd_res);\n\t\tres = TEE_ERROR_SIGNATURE_INVALID;\n\t\tgoto err;\n\t}\n\tres = TEE_SUCCESS;\n\tgoto out;\n\nerr:\n\tFTMN_SET_CHECK_RES_NOT_ZERO(&ftmn, FTMN_INCR0, res);\nout:\n\tFTMN_CALLEE_DONE_CHECK(&ftmn, FTMN_INCR0, FTMN_STEP_COUNT(1), res);\n\t/* Reset mpi to skip freeing here, those mpis will be freed with key */\n\tmbedtls_mpi_init(&rsa.E);\n\tmbedtls_mpi_init(&rsa.N);\n\tmbedtls_rsa_free(&rsa);\n\treturn res;\n}\n"], "filenames": ["core/crypto/crypto.c", "core/drivers/crypto/caam/acipher/caam_dh.c", "core/drivers/crypto/caam/acipher/caam_dsa.c", "core/drivers/crypto/caam/acipher/caam_ecc.c", "core/drivers/crypto/caam/acipher/caam_rsa.c", "core/drivers/crypto/se050/core/ecc.c", "core/drivers/crypto/se050/core/rsa.c", "core/drivers/crypto/versal/ecc.c", "core/include/crypto/crypto.h", "core/lib/libtomcrypt/dh.c", "core/lib/libtomcrypt/dsa.c", "core/lib/libtomcrypt/ecc.c", "core/lib/libtomcrypt/mpi_desc.c", "core/lib/libtomcrypt/rsa.c", "core/tee/tee_svc_cryp.c", "lib/libmbedtls/core/bignum.c", "lib/libmbedtls/core/dh.c", "lib/libmbedtls/core/ecc.c", "lib/libmbedtls/core/rsa.c"], "buggy_code_start_loc": [531, 198, 312, 174, 89, 746, 540, 274, 101, 31, 33, 21, 766, 136, 902, 90, 38, 43, 188], "buggy_code_end_loc": [534, 202, 364, 224, 453, 779, 598, 277, 102, 35, 58, 540, 770, 168, 3562, 94, 42, 562, 218], "fixing_code_start_loc": [531, 198, 312, 174, 89, 746, 540, 274, 101, 31, 33, 21, 766, 136, 902, 90, 38, 43, 188], "fixing_code_end_loc": [534, 202, 364, 224, 453, 779, 598, 277, 102, 35, 58, 540, 773, 168, 3561, 97, 42, 562, 218], "type": "CWE-415", "message": "OP-TEE is a Trusted Execution Environment (TEE) designed as companion to a non-secure Linux kernel running on Arm; Cortex-A cores using the TrustZone technology. Starting in version 3.20 and prior to version 3.22, `shdr_verify_signature` can make a double free. `shdr_verify_signature` used to verify a TA binary before it is loaded. To verify a signature of it, allocate a memory for RSA key. RSA key allocate function (`sw_crypto_acipher_alloc_rsa_public_key`) will try to allocate a memory (which is optee\u2019s heap memory). RSA key is consist of exponent and modulus (represent as variable `e`, `n`) and it allocation is not atomic way, so it may succeed in `e` but fail in `n`. In this case sw_crypto_acipher_alloc_rsa_public_key` will free on `e` and return as it is failed but variable \u2018e\u2019 is remained as already freed memory address . `shdr_verify_signature` will free again that memory (which is `e`) even it is freed when it failed allocate RSA key. A patch is available in version 3.22. No known workarounds are available.", "other": {"cve": {"id": "CVE-2023-41325", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-15T20:15:10.800", "lastModified": "2023-09-22T19:07:17.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OP-TEE is a Trusted Execution Environment (TEE) designed as companion to a non-secure Linux kernel running on Arm; Cortex-A cores using the TrustZone technology. Starting in version 3.20 and prior to version 3.22, `shdr_verify_signature` can make a double free. `shdr_verify_signature` used to verify a TA binary before it is loaded. To verify a signature of it, allocate a memory for RSA key. RSA key allocate function (`sw_crypto_acipher_alloc_rsa_public_key`) will try to allocate a memory (which is optee\u2019s heap memory). RSA key is consist of exponent and modulus (represent as variable `e`, `n`) and it allocation is not atomic way, so it may succeed in `e` but fail in `n`. In this case sw_crypto_acipher_alloc_rsa_public_key` will free on `e` and return as it is failed but variable \u2018e\u2019 is remained as already freed memory address . `shdr_verify_signature` will free again that memory (which is `e`) even it is freed when it failed allocate RSA key. A patch is available in version 3.22. No known workarounds are available."}, {"lang": "es", "value": "OP-TEE es un Entorno de Ejecuci\u00f3n Confiable (TEE) dise\u00f1ado como complemento de un kernel de Linux no seguro que se ejecuta en Arm; N\u00facleos Cortex-A que utilizan la tecnolog\u00eda TrustZone. A partir de la versi\u00f3n 3.20 y anteriores a la versi\u00f3n 3.22, `shdr_verify_signature` puede hacer un doble libremente. `shdr_verify_signature` se usa para verificar un binario TA antes de cargarlo. Para verificar una firma del mismo, asigne una memoria para la clave RSA. La funci\u00f3n de asignaci\u00f3n de clave RSA (`sw_crypto_acipher_alloc_rsa_public_key`) intentar\u00e1 asignar una memoria (que es la memoria del mont\u00f3n del candidato). La clave RSA consta de exponente y m\u00f3dulo (representados como variables `e`, `n`) y su asignaci\u00f3n no es de forma at\u00f3mica, por lo que puede tener \u00e9xito en `e` pero fallar en `n`. En este caso, sw_crypto_acipher_alloc_rsa_public_key` se liberar\u00e1 en `e` y regresar\u00e1 cuando fall\u00f3, pero la variable \u201ce\u201d permanece como direcci\u00f3n de memoria ya liberada. `shdr_verify_signature` liberar\u00e1 nuevamente esa memoria (que es `e`), incluso si se libera cuando no se pudo asignar la clave RSA. Hay un parche disponible en la versi\u00f3n 3.22. No hay workarounds conocidos disponibles."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.1, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linaro:op-tee:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.20.0", "versionEndExcluding": "3.22.0", "matchCriteriaId": "F01EDA96-EF6E-4A65-8831-4B42ED235B96"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linaro:op-tee:3.22.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D516A715-0899-4350-9992-FF21D31AD67B"}]}]}], "references": [{"url": "https://github.com/OP-TEE/optee_os/commit/e2ec831cb07ed0099535c7c140cb6338aa62816a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OP-TEE/optee_os/security/advisories/GHSA-jrw7-63cq-7vhm", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OP-TEE/optee_os/commit/e2ec831cb07ed0099535c7c140cb6338aa62816a"}}