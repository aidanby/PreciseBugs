{"buggy_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2019 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// dsdiff.c\n\n// This module is a helper to the WavPack command-line programs to support DFF files.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#ifdef _WIN32\n#define strdup(x) _strdup(x)\n#endif\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\n#pragma pack(push,2)\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n} DFFChunkHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char formType [4];\n} DFFFileHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t version;\n} DFFVersionChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t sampleRate;\n} DFFSampleRateChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint16_t numChannels;\n} DFFChannelsHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char compressionType [4];\n} DFFCompressionHeader;\n\n#pragma pack(pop)\n\n#define DFFChunkHeaderFormat \"4D\"\n#define DFFFileHeaderFormat \"4D4\"\n#define DFFVersionChunkFormat \"4DL\"\n#define DFFSampleRateChunkFormat \"4DL\"\n#define DFFChannelsHeaderFormat \"4DS\"\n#define DFFCompressionHeaderFormat \"4D4\"\n\nint ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels = 0, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\n                                error_line (\"%s is not a valid .DFF file!\", infilename);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n\n            if (!config->num_channels) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteDsdiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    uint32_t chan_mask = WavpackGetChannelMask (wpc);\n    int num_channels = WavpackGetNumChannels (wpc);\n    DFFFileHeader file_header, prop_header;\n    DFFChunkHeader data_header;\n    DFFVersionChunk ver_chunk;\n    DFFSampleRateChunk fs_chunk;\n    DFFChannelsHeader chan_header;\n    DFFCompressionHeader cmpr_header;\n    char *cmpr_name = \"\\016not compressed\", *chan_ids;\n    int64_t file_size, prop_chunk_size, data_size;\n    int cmpr_name_size, chan_ids_size;\n    uint32_t bcount;\n\n    if (debug_logging_mode)\n        error_line (\"WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\\n\",\n            (long long) total_samples, qmode);\n\n    cmpr_name_size = (strlen (cmpr_name) + 1) & ~1;\n    chan_ids_size = num_channels * 4;\n    chan_ids = malloc (chan_ids_size);\n\n    if (chan_ids) {\n        uint32_t scan_mask = 0x1;\n        char *cptr = chan_ids;\n        int ci, uci = 0;\n\n        for (ci = 0; ci < num_channels; ++ci) {\n            while (scan_mask && !(scan_mask & chan_mask))\n                scan_mask <<= 1;\n\n            if (scan_mask & 0x1)\n                memcpy (cptr, num_channels <= 2 ? \"SLFT\" : \"MLFT\", 4);\n            else if (scan_mask & 0x2)\n                memcpy (cptr, num_channels <= 2 ? \"SRGT\" : \"MRGT\", 4);\n            else if (scan_mask & 0x4)\n                memcpy (cptr, \"C   \", 4);\n            else if (scan_mask & 0x8)\n                memcpy (cptr, \"LFE \", 4);\n            else if (scan_mask & 0x10)\n                memcpy (cptr, \"LS  \", 4);\n            else if (scan_mask & 0x20)\n                memcpy (cptr, \"RS  \", 4);\n            else {\n                cptr [0] = 'C';\n                cptr [1] = (uci / 100) + '0';\n                cptr [2] = ((uci % 100) / 10) + '0';\n                cptr [3] = (uci % 10) + '0';\n                uci++;\n            }\n\n            scan_mask <<= 1;\n            cptr += 4;\n        }\n    }\n    else {\n        error_line (\"can't allocate memory!\");\n        return FALSE;\n    }\n\n    data_size = total_samples * num_channels;\n    prop_chunk_size = sizeof (prop_header) + sizeof (fs_chunk) + sizeof (chan_header) + chan_ids_size + sizeof (cmpr_header) + cmpr_name_size;\n    file_size = sizeof (file_header) + sizeof (ver_chunk) + prop_chunk_size + sizeof (data_header) + ((data_size + 1) & ~(int64_t)1);\n\n    memcpy (file_header.ckID, \"FRM8\", 4);\n    file_header.ckDataSize = file_size - 12;\n    memcpy (file_header.formType, \"DSD \", 4);\n\n    memcpy (prop_header.ckID, \"PROP\", 4);\n    prop_header.ckDataSize = prop_chunk_size - 12;\n    memcpy (prop_header.formType, \"SND \", 4);\n\n    memcpy (ver_chunk.ckID, \"FVER\", 4);\n    ver_chunk.ckDataSize = sizeof (ver_chunk) - 12;\n    ver_chunk.version = 0x01050000;\n\n    memcpy (fs_chunk.ckID, \"FS  \", 4);\n    fs_chunk.ckDataSize = sizeof (fs_chunk) - 12;\n    fs_chunk.sampleRate = WavpackGetSampleRate (wpc) * 8;\n\n    memcpy (chan_header.ckID, \"CHNL\", 4);\n    chan_header.ckDataSize = sizeof (chan_header) + chan_ids_size - 12;\n    chan_header.numChannels = num_channels;\n\n    memcpy (cmpr_header.ckID, \"CMPR\", 4);\n    cmpr_header.ckDataSize = sizeof (cmpr_header) + cmpr_name_size - 12;\n    memcpy (cmpr_header.compressionType, \"DSD \", 4);\n\n    memcpy (data_header.ckID, \"DSD \", 4);\n    data_header.ckDataSize = data_size;\n\n    WavpackNativeToBigEndian (&file_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&ver_chunk, DFFVersionChunkFormat);\n    WavpackNativeToBigEndian (&prop_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&fs_chunk, DFFSampleRateChunkFormat);\n    WavpackNativeToBigEndian (&chan_header, DFFChannelsHeaderFormat);\n    WavpackNativeToBigEndian (&cmpr_header, DFFCompressionHeaderFormat);\n    WavpackNativeToBigEndian (&data_header, DFFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &file_header, sizeof (file_header), &bcount) || bcount != sizeof (file_header) ||\n        !DoWriteFile (outfile, &ver_chunk, sizeof (ver_chunk), &bcount) || bcount != sizeof (ver_chunk) ||\n        !DoWriteFile (outfile, &prop_header, sizeof (prop_header), &bcount) || bcount != sizeof (prop_header) ||\n        !DoWriteFile (outfile, &fs_chunk, sizeof (fs_chunk), &bcount) || bcount != sizeof (fs_chunk) ||\n        !DoWriteFile (outfile, &chan_header, sizeof (chan_header), &bcount) || bcount != sizeof (chan_header) ||\n        !DoWriteFile (outfile, chan_ids, chan_ids_size, &bcount) || bcount != chan_ids_size ||\n        !DoWriteFile (outfile, &cmpr_header, sizeof (cmpr_header), &bcount) || bcount != sizeof (cmpr_header) ||\n        !DoWriteFile (outfile, cmpr_name, cmpr_name_size, &bcount) || bcount != cmpr_name_size ||\n        !DoWriteFile (outfile, &data_header, sizeof (data_header), &bcount) || bcount != sizeof (data_header)) {\n            error_line (\"can't write .DSF data, disk probably full!\");\n            free (chan_ids);\n            return FALSE;\n    }\n\n    free (chan_ids);\n    return TRUE;\n}\n\n"], "fixing_code": ["////////////////////////////////////////////////////////////////////////////\n//                           **** WAVPACK ****                            //\n//                  Hybrid Lossless Wavefile Compressor                   //\n//                Copyright (c) 1998 - 2019 David Bryant.                 //\n//                          All Rights Reserved.                          //\n//      Distributed under the BSD Software License (see license.txt)      //\n////////////////////////////////////////////////////////////////////////////\n\n// dsdiff.c\n\n// This module is a helper to the WavPack command-line programs to support DFF files.\n\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"wavpack.h\"\n#include \"utils.h\"\n#include \"md5.h\"\n\n#ifdef _WIN32\n#define strdup(x) _strdup(x)\n#endif\n\n#define WAVPACK_NO_ERROR    0\n#define WAVPACK_SOFT_ERROR  1\n#define WAVPACK_HARD_ERROR  2\n\nextern int debug_logging_mode;\n\n#pragma pack(push,2)\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n} DFFChunkHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char formType [4];\n} DFFFileHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t version;\n} DFFVersionChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint32_t sampleRate;\n} DFFSampleRateChunk;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    uint16_t numChannels;\n} DFFChannelsHeader;\n\ntypedef struct {\n    char ckID [4];\n    int64_t ckDataSize;\n    char compressionType [4];\n} DFFCompressionHeader;\n\n#pragma pack(pop)\n\n#define DFFChunkHeaderFormat \"4D\"\n#define DFFFileHeaderFormat \"4D4\"\n#define DFFVersionChunkFormat \"4DL\"\n#define DFFSampleRateChunkFormat \"4DL\"\n#define DFFChannelsHeaderFormat \"4DS\"\n#define DFFCompressionHeaderFormat \"4D4\"\n\nint ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n    // loop through all elements of the DSDIFF header\n    // (until the data chuck) and copy them to the output file\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels = 0, chansSpecified, chanMask = 0;\n                uint32_t sampleRate = 0;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {\n                                error_line (\"%s is not a valid .DFF file!\", infilename);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n\n            if (!config->num_channels || !config->sample_rate) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n\nint WriteDsdiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    uint32_t chan_mask = WavpackGetChannelMask (wpc);\n    int num_channels = WavpackGetNumChannels (wpc);\n    DFFFileHeader file_header, prop_header;\n    DFFChunkHeader data_header;\n    DFFVersionChunk ver_chunk;\n    DFFSampleRateChunk fs_chunk;\n    DFFChannelsHeader chan_header;\n    DFFCompressionHeader cmpr_header;\n    char *cmpr_name = \"\\016not compressed\", *chan_ids;\n    int64_t file_size, prop_chunk_size, data_size;\n    int cmpr_name_size, chan_ids_size;\n    uint32_t bcount;\n\n    if (debug_logging_mode)\n        error_line (\"WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\\n\",\n            (long long) total_samples, qmode);\n\n    cmpr_name_size = (strlen (cmpr_name) + 1) & ~1;\n    chan_ids_size = num_channels * 4;\n    chan_ids = malloc (chan_ids_size);\n\n    if (chan_ids) {\n        uint32_t scan_mask = 0x1;\n        char *cptr = chan_ids;\n        int ci, uci = 0;\n\n        for (ci = 0; ci < num_channels; ++ci) {\n            while (scan_mask && !(scan_mask & chan_mask))\n                scan_mask <<= 1;\n\n            if (scan_mask & 0x1)\n                memcpy (cptr, num_channels <= 2 ? \"SLFT\" : \"MLFT\", 4);\n            else if (scan_mask & 0x2)\n                memcpy (cptr, num_channels <= 2 ? \"SRGT\" : \"MRGT\", 4);\n            else if (scan_mask & 0x4)\n                memcpy (cptr, \"C   \", 4);\n            else if (scan_mask & 0x8)\n                memcpy (cptr, \"LFE \", 4);\n            else if (scan_mask & 0x10)\n                memcpy (cptr, \"LS  \", 4);\n            else if (scan_mask & 0x20)\n                memcpy (cptr, \"RS  \", 4);\n            else {\n                cptr [0] = 'C';\n                cptr [1] = (uci / 100) + '0';\n                cptr [2] = ((uci % 100) / 10) + '0';\n                cptr [3] = (uci % 10) + '0';\n                uci++;\n            }\n\n            scan_mask <<= 1;\n            cptr += 4;\n        }\n    }\n    else {\n        error_line (\"can't allocate memory!\");\n        return FALSE;\n    }\n\n    data_size = total_samples * num_channels;\n    prop_chunk_size = sizeof (prop_header) + sizeof (fs_chunk) + sizeof (chan_header) + chan_ids_size + sizeof (cmpr_header) + cmpr_name_size;\n    file_size = sizeof (file_header) + sizeof (ver_chunk) + prop_chunk_size + sizeof (data_header) + ((data_size + 1) & ~(int64_t)1);\n\n    memcpy (file_header.ckID, \"FRM8\", 4);\n    file_header.ckDataSize = file_size - 12;\n    memcpy (file_header.formType, \"DSD \", 4);\n\n    memcpy (prop_header.ckID, \"PROP\", 4);\n    prop_header.ckDataSize = prop_chunk_size - 12;\n    memcpy (prop_header.formType, \"SND \", 4);\n\n    memcpy (ver_chunk.ckID, \"FVER\", 4);\n    ver_chunk.ckDataSize = sizeof (ver_chunk) - 12;\n    ver_chunk.version = 0x01050000;\n\n    memcpy (fs_chunk.ckID, \"FS  \", 4);\n    fs_chunk.ckDataSize = sizeof (fs_chunk) - 12;\n    fs_chunk.sampleRate = WavpackGetSampleRate (wpc) * 8;\n\n    memcpy (chan_header.ckID, \"CHNL\", 4);\n    chan_header.ckDataSize = sizeof (chan_header) + chan_ids_size - 12;\n    chan_header.numChannels = num_channels;\n\n    memcpy (cmpr_header.ckID, \"CMPR\", 4);\n    cmpr_header.ckDataSize = sizeof (cmpr_header) + cmpr_name_size - 12;\n    memcpy (cmpr_header.compressionType, \"DSD \", 4);\n\n    memcpy (data_header.ckID, \"DSD \", 4);\n    data_header.ckDataSize = data_size;\n\n    WavpackNativeToBigEndian (&file_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&ver_chunk, DFFVersionChunkFormat);\n    WavpackNativeToBigEndian (&prop_header, DFFFileHeaderFormat);\n    WavpackNativeToBigEndian (&fs_chunk, DFFSampleRateChunkFormat);\n    WavpackNativeToBigEndian (&chan_header, DFFChannelsHeaderFormat);\n    WavpackNativeToBigEndian (&cmpr_header, DFFCompressionHeaderFormat);\n    WavpackNativeToBigEndian (&data_header, DFFChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &file_header, sizeof (file_header), &bcount) || bcount != sizeof (file_header) ||\n        !DoWriteFile (outfile, &ver_chunk, sizeof (ver_chunk), &bcount) || bcount != sizeof (ver_chunk) ||\n        !DoWriteFile (outfile, &prop_header, sizeof (prop_header), &bcount) || bcount != sizeof (prop_header) ||\n        !DoWriteFile (outfile, &fs_chunk, sizeof (fs_chunk), &bcount) || bcount != sizeof (fs_chunk) ||\n        !DoWriteFile (outfile, &chan_header, sizeof (chan_header), &bcount) || bcount != sizeof (chan_header) ||\n        !DoWriteFile (outfile, chan_ids, chan_ids_size, &bcount) || bcount != chan_ids_size ||\n        !DoWriteFile (outfile, &cmpr_header, sizeof (cmpr_header), &bcount) || bcount != sizeof (cmpr_header) ||\n        !DoWriteFile (outfile, cmpr_name, cmpr_name_size, &bcount) || bcount != cmpr_name_size ||\n        !DoWriteFile (outfile, &data_header, sizeof (data_header), &bcount) || bcount != sizeof (data_header)) {\n            error_line (\"can't write .DSF data, disk probably full!\");\n            free (chan_ids);\n            return FALSE;\n    }\n\n    free (chan_ids);\n    return TRUE;\n}\n\n"], "filenames": ["cli/dsdiff.c"], "buggy_code_start_loc": [184], "buggy_code_end_loc": [284], "fixing_code_start_loc": [184], "fixing_code_end_loc": [284], "type": "CWE-824", "message": "WavpackSetConfiguration64 in pack_utils.c in libwavpack.a in WavPack through 5.1.0 has a \"Conditional jump or move depends on uninitialised value\" condition, which might allow attackers to cause a denial of service (application crash) via a DFF file that lacks valid sample-rate data.", "other": {"cve": {"id": "CVE-2019-11498", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-24T05:29:00.783", "lastModified": "2022-10-07T13:44:43.097", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WavpackSetConfiguration64 in pack_utils.c in libwavpack.a in WavPack through 5.1.0 has a \"Conditional jump or move depends on uninitialised value\" condition, which might allow attackers to cause a denial of service (application crash) via a DFF file that lacks valid sample-rate data."}, {"lang": "es", "value": "WavpackSetConfiguration64, en pack_utils.c, en libwavpack.a, en WavPack hasta la versi\u00f3n 5.1.0, tiene una condici\u00f3n \"Conditional jump or move depends on uninitialised value\", que podr\u00eda permitir a los atacantes causar una denegaci\u00f3n de servicio (fallo de la aplicaci\u00f3n) a trav\u00e9s de un archivo DFF que carece de datos v\u00e1lidos sobre la velocidad de muestreo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wavpack:wavpack:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.1.0", "matchCriteriaId": "A5AF1FF6-17E5-429C-8280-8215E7010571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/dbry/WavPack/commit/bc6cba3f552c44565f7f1e66dc1580189addb2b4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dbry/WavPack/issues/67", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6CFFFWIWALGQPKINRDW3PRGRD5LOLGZA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BRWQNE3TH5UF64IKHKKHVCHJHUOVKJUH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NZDKXGA2ZNSSM64ZYDHOWCO4Q4VAKAON/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SCK2YJXY6V5CKGKSF2PPN7RL2DXVOC6G/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-19", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3960-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dbry/WavPack/commit/bc6cba3f552c44565f7f1e66dc1580189addb2b4"}}