{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_as_req.c */\n/*\n * Portions Copyright (C) 2007 Apple Inc.\n * Copyright 1990, 1991, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n *\n * KDC Routines to deal with AS_REQ's\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n#include \"com_err.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif  /* hpux */\n#endif /* HAVE_NETINET_IN_H */\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include <kadm5/admin.h>\n#include \"adm_proto.h\"\n#include \"extern.h\"\n\nstatic krb5_error_code\nprepare_error_as(struct kdc_request_state *, krb5_kdc_req *, krb5_db_entry *,\n                 int, krb5_pa_data **, krb5_boolean, krb5_principal,\n                 krb5_data **, const char *);\n\n/* Determine the key-expiration value according to RFC 4120 section 5.4.2. */\nstatic krb5_timestamp\nget_key_exp(krb5_db_entry *entry)\n{\n    if (entry->expiration == 0)\n        return entry->pw_expiration;\n    if (entry->pw_expiration == 0)\n        return entry->expiration;\n    return ts_min(entry->expiration, entry->pw_expiration);\n}\n\n/*\n * Find the key in client for the most preferred enctype in req_enctypes.  Fill\n * in *kb_out with the decrypted keyblock (which the caller must free) and set\n * *kd_out to an alias to that key data entry.  Set *kd_out to NULL and leave\n * *kb_out zeroed if no key is found for any of the requested enctypes.\n * kb_out->enctype may differ from the enctype of *kd_out for DES enctypes; in\n * this case, kb_out->enctype is the requested enctype used to match the key\n * data entry.\n */\nstatic krb5_error_code\nselect_client_key(krb5_context context, krb5_db_entry *client,\n                  krb5_enctype *req_enctypes, int n_req_enctypes,\n                  krb5_keyblock *kb_out, krb5_key_data **kd_out)\n{\n    krb5_error_code ret;\n    krb5_key_data *kd;\n    krb5_enctype etype;\n    int i;\n\n    memset(kb_out, 0, sizeof(*kb_out));\n    *kd_out = NULL;\n\n    for (i = 0; i < n_req_enctypes; i++) {\n        etype = req_enctypes[i];\n        if (!krb5_c_valid_enctype(etype))\n            continue;\n        if (krb5_dbe_find_enctype(context, client, etype, -1, 0, &kd) == 0) {\n            /* Decrypt the client key data and set its enctype to the request\n             * enctype (which may differ from the key data enctype for DES). */\n            ret = krb5_dbe_decrypt_key_data(context, NULL, kd, kb_out, NULL);\n            if (ret)\n                return ret;\n            kb_out->enctype = etype;\n            *kd_out = kd;\n            return 0;\n        }\n    }\n    return 0;\n}\n\nstruct as_req_state {\n    loop_respond_fn respond;\n    void *arg;\n\n    krb5_principal_data client_princ;\n    krb5_enc_tkt_part enc_tkt_reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply;\n    krb5_keyblock server_keyblock;\n    krb5_keyblock client_keyblock;\n    krb5_db_entry *client;\n    krb5_db_entry *server;\n    krb5_db_entry *local_tgt;\n    krb5_db_entry *local_tgt_storage;\n    krb5_key_data *client_key;\n    krb5_kdc_req *request;\n    struct krb5_kdcpreauth_rock_st rock;\n    const char *status;\n    krb5_pa_data **e_data;\n    krb5_boolean typed_e_data;\n    krb5_kdc_rep reply;\n    krb5_timestamp kdc_time;\n    krb5_timestamp authtime;\n    krb5_keyblock session_key;\n    unsigned int c_flags;\n    krb5_data *req_pkt;\n    krb5_data *inner_body;\n    struct kdc_request_state *rstate;\n    char *sname, *cname;\n    void *pa_context;\n    const krb5_fulladdr *local_addr;\n    const krb5_fulladdr *remote_addr;\n    krb5_data **auth_indicators;\n\n    krb5_error_code preauth_err;\n\n    kdc_realm_t *active_realm;\n    krb5_audit_state *au_state;\n};\n\nstatic void\nfinish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state->active_realm;\n    krb5_audit_state *au_state = state->au_state;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state->request, *state->client,\n                                        *state->server, state->kdc_time,\n                                        &state->status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state->server,\n                               state->auth_indicators);\n    if (errcode) {\n        state->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state->server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &server_key))) {\n        state->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /*\n     * Convert server->key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &state->server_keyblock,\n                                             NULL))) {\n        state->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req))) {\n        state->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it's location\n     *  is used for ktime\n     */\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.times.authtime = state->authtime = state->kdc_time;\n\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \"CANT_FIND_CLIENT_KEY\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state->c_flags,\n                              state->client,\n                              state->server,\n                              NULL,\n                              state->local_tgt,\n                              &state->client_keyblock,\n                              &state->server_keyblock,\n                              NULL,\n                              state->req_pkt,\n                              state->request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state->auth_indicators,\n                              &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"AS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        state->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode) {\n        state->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode) {\n        state->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part.kvno = server_key->key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode) {\n        state->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode) {\n        state->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &state->reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &state->reply, &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode) {\n        state->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0)\n        assert (state->status != 0);\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(kdc_context,\n              (errcode || state->preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state->status) {\n        log_as_req(kdc_context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->authtime,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode < 0 || errcode > KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, errcode,\n                                       state->e_data, state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state->enc_tkt_reply.authorization_data);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(kdc_context, state->client);\n    krb5_db_free_principal(kdc_context, state->server);\n    krb5_db_free_principal(kdc_context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state->e_data);\n    krb5_free_data(kdc_context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(kdc_context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}\n\nstatic void\nfinish_missing_required_preauth(void *arg)\n{\n    struct as_req_state *state = (struct as_req_state *)arg;\n\n    finish_process_as_req(state, state->preauth_err);\n}\n\nstatic void\nfinish_preauth(void *arg, krb5_error_code code)\n{\n    struct as_req_state *state = arg;\n    krb5_error_code real_code = code;\n\n    if (code) {\n        if (vague_errors)\n            code = KRB5KRB_ERR_GENERIC;\n        state->status = \"PREAUTH_FAILED\";\n        if (real_code == KRB5KDC_ERR_PREAUTH_FAILED) {\n            state->preauth_err = code;\n            get_preauth_hint_list(state->request, &state->rock, &state->e_data,\n                                  finish_missing_required_preauth, state);\n            return;\n        }\n    } else {\n        /*\n         * Final check before handing out ticket: If the client requires\n         * preauthentication, verify that the proper kind of\n         * preauthentication was carried out.\n         */\n        state->status = missing_required_preauth(state->client, state->server,\n                                                 &state->enc_tkt_reply);\n        if (state->status) {\n            state->preauth_err = KRB5KDC_ERR_PREAUTH_REQUIRED;\n            get_preauth_hint_list(state->request, &state->rock, &state->e_data,\n                                  finish_missing_required_preauth, state);\n            return;\n        }\n    }\n\n    finish_process_as_req(state, code);\n}\n\n/*ARGSUSED*/\nvoid\nprocess_as_req(krb5_kdc_req *request, krb5_data *req_pkt,\n               const krb5_fulladdr *local_addr,\n               const krb5_fulladdr *remote_addr, kdc_realm_t *kdc_active_realm,\n               verto_ctx *vctx, loop_respond_fn respond, void *arg)\n{\n    krb5_error_code errcode;\n    unsigned int s_flags = 0;\n    krb5_data encoded_req_body;\n    krb5_enctype useenctype;\n    struct as_req_state *state;\n    krb5_audit_state *au_state = NULL;\n\n    state = k5alloc(sizeof(*state), &errcode);\n    if (state == NULL) {\n        (*respond)(arg, errcode, NULL);\n        return;\n    }\n    state->respond = respond;\n    state->arg = arg;\n    state->request = request;\n    state->req_pkt = req_pkt;\n    state->local_addr = local_addr;\n    state->remote_addr = remote_addr;\n    state->active_realm = kdc_active_realm;\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state->rstate);\n    if (errcode != 0) {\n        (*respond)(arg, errcode, NULL);\n        free(state);\n        return;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, state->request, remote_addr,\n                               &au_state);\n    if (errcode) {\n        (*respond)(arg, errcode, NULL);\n        kdc_free_rstate(state->rstate);\n        free(state);\n        return;\n    }\n    state->au_state = au_state;\n\n    if (state->request->msg_type != KRB5_AS_REQ) {\n        state->status = \"VALIDATE_MESSAGE_TYPE\";\n        errcode = KRB5_BADMSGTYPE;\n        goto errout;\n    }\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_as_req(kdc_context, TRUE, au_state);\n\n    if (fetch_asn1_field((unsigned char *) req_pkt->data,\n                         1, 4, &encoded_req_body) != 0) {\n        errcode = ASN1_BAD_ID;\n        state->status = \"FETCH_REQ_BODY\";\n        goto errout;\n    }\n    errcode = kdc_find_fast(&state->request, &encoded_req_body, NULL, NULL,\n                            state->rstate, &state->inner_body);\n    if (errcode) {\n        state->status = \"FIND_FAST\";\n        goto errout;\n    }\n    if (state->inner_body == NULL) {\n        /* Not a FAST request; copy the encoded request body. */\n        errcode = krb5_copy_data(kdc_context, &encoded_req_body,\n                                 &state->inner_body);\n        if (errcode) {\n            state->status = \"COPY_REQ_BODY\";\n            goto errout;\n        }\n    }\n    au_state->request = state->request;\n    state->rock.request = state->request;\n    state->rock.inner_body = state->inner_body;\n    state->rock.rstate = state->rstate;\n    state->rock.vctx = vctx;\n    state->rock.auth_indicators = &state->auth_indicators;\n    if (!state->request->client) {\n        state->status = \"NULL_CLIENT\";\n        errcode = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n    if ((errcode = krb5_unparse_name(kdc_context,\n                                     state->request->client,\n                                     &state->cname))) {\n        state->status = \"UNPARSE_CLIENT\";\n        goto errout;\n    }\n    limit_string(state->cname);\n\n    if (!state->request->server) {\n        state->status = \"NULL_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n    if ((errcode = krb5_unparse_name(kdc_context,\n                                     state->request->server,\n                                     &state->sname))) {\n        state->status = \"UNPARSE_SERVER\";\n        goto errout;\n    }\n    limit_string(state->sname);\n\n    /*\n     * We set KRB5_KDB_FLAG_CLIENT_REFERRALS_ONLY as a hint\n     * to the backend to return naming information in lieu\n     * of cross realm TGS entries.\n     */\n    setflag(state->c_flags, KRB5_KDB_FLAG_CLIENT_REFERRALS_ONLY);\n    /*\n     * Note that according to the referrals draft we should\n     * always canonicalize enterprise principal names.\n     */\n    if (isflagset(state->request->kdc_options, KDC_OPT_CANONICALIZE) ||\n        state->request->client->type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        setflag(state->c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(state->c_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    }\n    if (include_pac_p(kdc_context, state->request)) {\n        setflag(state->c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n    }\n    errcode = krb5_db_get_principal(kdc_context, state->request->client,\n                                    state->c_flags, &state->client);\n    if (errcode == KRB5_KDB_CANTLOCK_DB)\n        errcode = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (errcode == KRB5_KDB_NOENTRY) {\n        state->status = \"CLIENT_NOT_FOUND\";\n        if (vague_errors)\n            errcode = KRB5KRB_ERR_GENERIC;\n        else\n            errcode = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        goto errout;\n    } else if (errcode) {\n        state->status = \"LOOKING_UP_CLIENT\";\n        goto errout;\n    }\n    state->rock.client = state->client;\n\n    /*\n     * If the backend returned a principal that is not in the local\n     * realm, then we need to refer the client to that realm.\n     */\n    if (!is_local_principal(kdc_active_realm, state->client->princ)) {\n        /* Entry is a referral to another realm */\n        state->status = \"REFERRAL\";\n        au_state->cl_realm = &state->client->princ->realm;\n        errcode = KRB5KDC_ERR_WRONG_REALM;\n        goto errout;\n    }\n\n    au_state->stage = SRVC_PRINC;\n\n    s_flags = 0;\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(state->request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n    errcode = krb5_db_get_principal(kdc_context, state->request->server,\n                                    s_flags, &state->server);\n    if (errcode == KRB5_KDB_CANTLOCK_DB)\n        errcode = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (errcode == KRB5_KDB_NOENTRY) {\n        state->status = \"SERVER_NOT_FOUND\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    } else if (errcode) {\n        state->status = \"LOOKING_UP_SERVER\";\n        goto errout;\n    }\n\n    errcode = get_local_tgt(kdc_context, &state->request->server->realm,\n                            state->server, &state->local_tgt,\n                            &state->local_tgt_storage);\n    if (errcode) {\n        state->status = \"GET_LOCAL_TGT\";\n        goto errout;\n    }\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &state->kdc_time))) {\n        state->status = \"TIMEOFDAY\";\n        goto errout;\n    }\n    state->authtime = state->kdc_time; /* for audit_as_request() */\n\n    if ((errcode = validate_as_request(kdc_active_realm,\n                                       state->request, *state->client,\n                                       *state->server, state->kdc_time,\n                                       &state->status, &state->e_data))) {\n        if (!state->status)\n            state->status = \"UNKNOWN_REASON\";\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto errout;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    /*\n     * Select the keytype for the ticket session key.\n     */\n    if ((useenctype = select_session_keytype(kdc_active_realm, state->server,\n                                             state->request->nktypes,\n                                             state->request->ktype)) == 0) {\n        /* unsupported ktype */\n        state->status = \"BAD_ENCRYPTION_TYPE\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto errout;\n    }\n\n    if ((errcode = krb5_c_make_random_key(kdc_context, useenctype,\n                                          &state->session_key))) {\n        state->status = \"MAKE_RANDOM_KEY\";\n        goto errout;\n    }\n\n    /*\n     * Canonicalization is only effective if we are issuing a TGT\n     * (the intention is to allow support for Windows \"short\" realm\n     * aliases, nothing more).\n     */\n    if (isflagset(s_flags, KRB5_KDB_FLAG_CANONICALIZE) &&\n        krb5_is_tgs_principal(state->request->server) &&\n        krb5_is_tgs_principal(state->server->princ)) {\n        state->ticket_reply.server = state->server->princ;\n    } else {\n        state->ticket_reply.server = state->request->server;\n    }\n\n    /* Copy options that request the corresponding ticket flags. */\n    state->enc_tkt_reply.flags = OPTS2FLAGS(state->request->kdc_options);\n    state->enc_tkt_reply.times.authtime = state->authtime;\n\n    setflag(state->enc_tkt_reply.flags, TKT_FLG_INITIAL);\n    setflag(state->enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    state->enc_tkt_reply.session = &state->session_key;\n    if (isflagset(state->c_flags, KRB5_KDB_FLAG_CANONICALIZE)) {\n        state->client_princ = *(state->client->princ);\n    } else {\n        state->client_princ = *(state->request->client);\n        /* The realm is always canonicalized */\n        state->client_princ.realm = state->client->princ->realm;\n    }\n    state->enc_tkt_reply.client = &state->client_princ;\n    state->enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    state->enc_tkt_reply.transited.tr_contents = empty_string;\n\n    if (isflagset(state->request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(state->enc_tkt_reply.flags, TKT_FLG_INVALID);\n        state->enc_tkt_reply.times.starttime = state->request->from;\n    } else\n        state->enc_tkt_reply.times.starttime = state->kdc_time;\n\n    kdc_get_ticket_endtime(kdc_active_realm,\n                           state->enc_tkt_reply.times.starttime,\n                           kdc_infinity, state->request->till, state->client,\n                           state->server, &state->enc_tkt_reply.times.endtime);\n\n    kdc_get_ticket_renewtime(kdc_active_realm, state->request, NULL,\n                             state->client, state->server,\n                             &state->enc_tkt_reply);\n\n    /*\n     * starttime is optional, and treated as authtime if not present.\n     * so we can nuke it if it matches\n     */\n    if (state->enc_tkt_reply.times.starttime ==\n        state->enc_tkt_reply.times.authtime)\n        state->enc_tkt_reply.times.starttime = 0;\n\n    state->enc_tkt_reply.caddrs = state->request->addresses;\n    state->enc_tkt_reply.authorization_data = 0;\n\n    /* If anonymous requests are being used, adjust the realm of the client\n     * principal. */\n    if (isflagset(state->request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS)) {\n        if (!krb5_principal_compare_any_realm(kdc_context,\n                                              state->request->client,\n                                              krb5_anonymous_principal())) {\n            errcode = KRB5KDC_ERR_BADOPTION;\n            /* Anonymous requested but anonymous principal not used.*/\n            state->status = \"VALIDATE_ANONYMOUS_PRINCIPAL\";\n            goto errout;\n        }\n        krb5_free_principal(kdc_context, state->request->client);\n        state->request->client = NULL;\n        errcode = krb5_copy_principal(kdc_context, krb5_anonymous_principal(),\n                                      &state->request->client);\n        if (errcode) {\n            state->status = \"COPY_ANONYMOUS_PRINCIPAL\";\n            goto errout;\n        }\n        state->enc_tkt_reply.client = state->request->client;\n        setflag(state->client->attributes, KRB5_KDB_REQUIRES_PRE_AUTH);\n    }\n\n    errcode = select_client_key(kdc_context, state->client,\n                                state->request->ktype, state->request->nktypes,\n                                &state->client_keyblock, &state->client_key);\n    if (errcode) {\n        state->status = \"DECRYPT_CLIENT_KEY\";\n        goto errout;\n    }\n    if (state->client_key != NULL) {\n        state->rock.client_key = state->client_key;\n        state->rock.client_keyblock = &state->client_keyblock;\n    }\n\n    errcode = kdc_fast_read_cookie(kdc_context, state->rstate, state->request,\n                                   state->local_tgt);\n    if (errcode) {\n        state->status = \"READ_COOKIE\";\n        goto errout;\n    }\n\n    /*\n     * Check the preauthentication if it is there.\n     */\n    if (state->request->padata) {\n        check_padata(kdc_context, &state->rock, state->req_pkt,\n                     state->request, &state->enc_tkt_reply, &state->pa_context,\n                     &state->e_data, &state->typed_e_data, finish_preauth,\n                     state);\n    } else\n        finish_preauth(state, 0);\n    return;\n\nerrout:\n    finish_process_as_req(state, errcode);\n}\n\nstatic krb5_error_code\nprepare_error_as(struct kdc_request_state *rstate, krb5_kdc_req *request,\n                 krb5_db_entry *local_tgt, int error, krb5_pa_data **e_data_in,\n                 krb5_boolean typed_e_data, krb5_principal canon_client,\n                 krb5_data **response, const char *status)\n{\n    krb5_error errpkt;\n    krb5_error_code retval;\n    krb5_data *scratch = NULL, *e_data_asn1 = NULL, *fast_edata = NULL;\n    krb5_pa_data **e_data = NULL, *cookie = NULL;\n    kdc_realm_t *kdc_active_realm = rstate->realm_data;\n    size_t count;\n\n    errpkt.magic = KV5M_ERROR;\n\n    if (e_data_in != NULL) {\n        /* Add a PA-FX-COOKIE to e_data_in.  e_data is a shallow copy\n         * containing aliases. */\n        for (count = 0; e_data_in[count] != NULL; count++);\n        e_data = calloc(count + 2, sizeof(*e_data));\n        if (e_data == NULL)\n            return ENOMEM;\n        memcpy(e_data, e_data_in, count * sizeof(*e_data));\n        retval = kdc_fast_make_cookie(kdc_context, rstate, local_tgt,\n                                      request->client, &cookie);\n        e_data[count] = cookie;\n    }\n\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    retval = krb5_us_timeofday(kdc_context, &errpkt.stime, &errpkt.susec);\n    if (retval)\n        goto cleanup;\n    errpkt.error = error;\n    errpkt.server = request->server;\n    errpkt.client = (error == KDC_ERR_WRONG_REALM) ? canon_client :\n        request->client;\n    errpkt.text = string2data((char *)status);\n\n    if (e_data != NULL) {\n        if (typed_e_data)\n            retval = encode_krb5_typed_data(e_data, &e_data_asn1);\n        else\n            retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval)\n            goto cleanup;\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(kdc_context, rstate, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval)\n        goto cleanup;\n    if (fast_edata != NULL)\n        errpkt.e_data = *fast_edata;\n\n    scratch = k5alloc(sizeof(*scratch), &retval);\n    if (scratch == NULL)\n        goto cleanup;\n    if (kdc_fast_hide_client(rstate) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    if (retval)\n        goto cleanup;\n\n    *response = scratch;\n    scratch = NULL;\n\ncleanup:\n    krb5_free_data(kdc_context, fast_edata);\n    krb5_free_data(kdc_context, e_data_asn1);\n    free(scratch);\n    free(e_data);\n    if (cookie != NULL)\n        free(cookie->contents);\n    free(cookie);\n    return retval;\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *, krb5_principal, krb5_db_entry **,\n                   const char**);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *, krb5_kdc_req *, krb5_flags, krb5_db_entry **,\n               const char **);\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *, krb5_kdc_req *, krb5_db_entry *,\n                krb5_keyblock *, const char **);\n\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *, krb5_kdc_req *, krb5_principal *);\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *, krb5_kdc_req *, krb5_flags,\n              krb5_db_entry **, const char **);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL) {\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        if (is_referral) {\n            /* The requesting server appears to no longer exist, and we found\n             * a referral instead.  Treat this as a server lookup failure. */\n            errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            status = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* Deal with user-to-user and constrained delegation */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, request->second_ticket[st_idx],\n                                  &au_state->evid_tkt_id);\n        if (retval) {\n            status = \"GENERATE_TICKET_ID\";\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract auth indicators from the subject ticket, except for S4U2Proxy\n     * requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    errcode = check_indicators(kdc_context, server, auth_indicators);\n    if (errcode) {\n        status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = OPTS2FLAGS(request->kdc_options);\n    enc_tkt_reply.flags |= COPY_TKT_FLAGS(header_enc_tkt->flags);\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /* Indicate support for encrypted padata (RFC 6806). */\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones, so just ignore the option. */\n    if (isflagset(request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS) &&\n        !isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        clear(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, header_server);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              header_server, local_tgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              header_key,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              auth_indicators,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            au_state->status = status;\n            kau_u2u(kdc_context, FALSE, au_state);\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"MAKE_S4U2SELF_PADATA\";\n            au_state->status = status;\n        }\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n    kdc_realm_t *kdc_active_realm = state->realm_data;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    if (kdc_fast_hide_client(state) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * Get the key for the second ticket, if any, and decrypt it.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n               krb5_flags flags, krb5_db_entry **server_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server = NULL;\n    krb5_keyblock *key;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    if (!(req->kdc_options & STKT_OPTIONS))\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(kdc_context, stkt,\n                                flags,\n                                TRUE, /* match_enctype */\n                                &server,\n                                &key,\n                                &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(kdc_context, key,\n                                   req->second_ticket[0]);\n    krb5_free_keyblock(kdc_context, key);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    *server_out = server;\n    server = NULL;\ncleanup:\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                   krb5_enctype *useenctype, const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                krb5_db_entry *server, krb5_keyblock *skey,\n                const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(kdc_active_realm, req, &useenctype,\n                                    status);\n        if (retval != 0)\n            goto cleanup;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(kdc_active_realm, server,\n                                            req->nktypes,\n                                            req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n    retval = krb5_c_make_random_key(kdc_context, useenctype, skey);\n    if (retval != 0) {\n        /* random key failed */\n        *status = \"MAKE_RANDOM_KEY\";\n        goto cleanup;\n    }\ncleanup:\n    return retval;\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, princ));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && *server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\n/* Return true if item is an element of the space/comma-separated list. */\nstatic krb5_boolean\nin_list(const char *list, const char *item)\n{\n    const char *p;\n    int len = strlen(item);\n\n    if (list == NULL)\n        return FALSE;\n    for (p = strstr(list, item); p != NULL; p = strstr(p + 1, item)) {\n        if ((p == list || isspace((unsigned char)p[-1]) || p[-1] == ',') &&\n            (p[len] == '\\0' || isspace((unsigned char)p[len]) ||\n             p[len] == ','))\n                return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *hostbased = kdc_active_realm->realm_hostbased;\n    char *no_referral = kdc_active_realm->realm_no_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (krb5_princ_size(kdc_context, request->server) != 2)\n        return FALSE;\n\n    stype = data2string(krb5_princ_component(kdc_context, request->server, 0));\n    if (stype == NULL)\n        return FALSE;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (!in_list(hostbased, stype) && !in_list(hostbased, \"*\"))\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (in_list(no_referral, stype) || in_list(no_referral, \"*\"))\n            goto cleanup;\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_CANONICALIZE;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/kdc_util.c - Utility functions for the KDC implementation */\n/*\n * Copyright 1990,1991,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n#include \"kdc_util.h\"\n#include \"extern.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <kadm5/admin.h>\n#include \"adm_proto.h\"\n#include \"net-server.h\"\n#include <limits.h>\n\n#ifdef KRBCONF_VAGUE_ERRORS\nconst int vague_errors = 1;\n#else\nconst int vague_errors = 0;\n#endif\n\nstatic krb5_error_code kdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n                                     krb5_ap_req *apreq,\n                                     krb5_auth_context auth_context,\n                                     krb5_db_entry **server,\n                                     krb5_keyblock **tgskey);\nstatic krb5_error_code find_server_key(krb5_context,\n                                       krb5_db_entry *, krb5_enctype,\n                                       krb5_kvno, krb5_keyblock **,\n                                       krb5_kvno *);\n\n/*\n * concatenate first two authdata arrays, returning an allocated replacement.\n * The replacement should be freed with krb5_free_authdata().\n */\nkrb5_error_code\nconcat_authorization_data(krb5_context context,\n                          krb5_authdata **first, krb5_authdata **second,\n                          krb5_authdata ***output)\n{\n    register int i, j;\n    register krb5_authdata **ptr, **retdata;\n\n    /* count up the entries */\n    i = 0;\n    if (first)\n        for (ptr = first; *ptr; ptr++)\n            i++;\n    if (second)\n        for (ptr = second; *ptr; ptr++)\n            i++;\n\n    retdata = (krb5_authdata **)malloc((i+1)*sizeof(*retdata));\n    if (!retdata)\n        return ENOMEM;\n    retdata[i] = 0;                     /* null-terminated array */\n    for (i = 0, j = 0, ptr = first; j < 2 ; ptr = second, j++)\n        while (ptr && *ptr) {\n            /* now walk & copy */\n            retdata[i] = (krb5_authdata *)malloc(sizeof(*retdata[i]));\n            if (!retdata[i]) {\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            *retdata[i] = **ptr;\n            if (!(retdata[i]->contents =\n                  (krb5_octet *)malloc(retdata[i]->length))) {\n                free(retdata[i]);\n                retdata[i] = 0;\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            memcpy(retdata[i]->contents, (*ptr)->contents, retdata[i]->length);\n\n            ptr++;\n            i++;\n        }\n    *output = retdata;\n    return 0;\n}\n\nkrb5_boolean\nis_local_principal(kdc_realm_t *kdc_active_realm, krb5_const_principal princ1)\n{\n    return krb5_realm_compare(kdc_context, princ1, tgs_server);\n}\n\n/*\n * Returns TRUE if the kerberos principal is the name of a Kerberos ticket\n * service.\n */\nkrb5_boolean\nkrb5_is_tgs_principal(krb5_const_principal principal)\n{\n    if (krb5_princ_size(kdc_context, principal) != 2)\n        return FALSE;\n    if (data_eq_string(*krb5_princ_component(kdc_context, principal, 0),\n                       KRB5_TGS_NAME))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/* Returns TRUE if principal is the name of a cross-realm TGS. */\nkrb5_boolean\nis_cross_tgs_principal(krb5_const_principal principal)\n{\n    if (!krb5_is_tgs_principal(principal))\n        return FALSE;\n    if (!data_eq(*krb5_princ_component(kdc_context, principal, 1),\n                 *krb5_princ_realm(kdc_context, principal)))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/*\n * given authentication data (provides seed for checksum), verify checksum\n * for source data.\n */\nstatic krb5_error_code\ncomp_cksum(krb5_context kcontext, krb5_data *source, krb5_ticket *ticket,\n           krb5_checksum *his_cksum)\n{\n    krb5_error_code       retval;\n    krb5_boolean          valid;\n\n    if (!krb5_c_valid_cksumtype(his_cksum->checksum_type))\n        return KRB5KDC_ERR_SUMTYPE_NOSUPP;\n\n    /* must be collision proof */\n    if (!krb5_c_is_coll_proof_cksum(his_cksum->checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    /* verify checksum */\n    if ((retval = krb5_c_verify_checksum(kcontext, ticket->enc_part2->session,\n                                         KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                         source, his_cksum, &valid)))\n        return(retval);\n\n    if (!valid)\n        return(KRB5KRB_AP_ERR_BAD_INTEGRITY);\n\n    return(0);\n}\n\n/* If a header ticket is decrypted, *ticket_out is filled in even on error. */\nkrb5_error_code\nkdc_process_tgs_req(kdc_realm_t *kdc_active_realm,\n                    krb5_kdc_req *request, const krb5_fulladdr *from,\n                    krb5_data *pkt, krb5_ticket **ticket_out,\n                    krb5_db_entry **krbtgt_ptr,\n                    krb5_keyblock **tgskey,\n                    krb5_keyblock **subkey,\n                    krb5_pa_data **pa_tgs_req)\n{\n    krb5_pa_data        * tmppa;\n    krb5_ap_req         * apreq;\n    krb5_error_code       retval;\n    krb5_authdata **authdata = NULL;\n    krb5_data             scratch1;\n    krb5_data           * scratch = NULL;\n    krb5_boolean          foreign_server = FALSE;\n    krb5_auth_context     auth_context = NULL;\n    krb5_authenticator  * authenticator = NULL;\n    krb5_checksum       * his_cksum = NULL;\n    krb5_db_entry       * krbtgt = NULL;\n    krb5_ticket         * ticket;\n\n    *ticket_out = NULL;\n    *krbtgt_ptr = NULL;\n    *tgskey = NULL;\n\n    tmppa = krb5int_find_pa_data(kdc_context,\n                                 request->padata, KRB5_PADATA_AP_REQ);\n    if (!tmppa)\n        return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    scratch1.length = tmppa->length;\n    scratch1.data = (char *)tmppa->contents;\n    if ((retval = decode_krb5_ap_req(&scratch1, &apreq)))\n        return retval;\n    ticket = apreq->ticket;\n\n    if (isflagset(apreq->ap_options, AP_OPTS_USE_SESSION_KEY) ||\n        isflagset(apreq->ap_options, AP_OPTS_MUTUAL_REQUIRED)) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ: SESSION KEY or MUTUAL\"));\n        retval = KRB5KDC_ERR_POLICY;\n        goto cleanup;\n    }\n\n    /* If the \"server\" principal in the ticket is not something\n       in the local realm, then we must refuse to service the request\n       if the client claims to be from the local realm.\n\n       If we don't do this, then some other realm's nasty KDC can\n       claim to be authenticating a client from our realm, and we'll\n       give out tickets concurring with it!\n\n       we set a flag here for checking below.\n    */\n    foreign_server = !is_local_principal(kdc_active_realm,\n                                         apreq->ticket->server);\n\n    if ((retval = krb5_auth_con_init(kdc_context, &auth_context)))\n        goto cleanup;\n\n    /* Don't use a replay cache. */\n    if ((retval = krb5_auth_con_setflags(kdc_context, auth_context, 0)))\n        goto cleanup;\n\n    if ((retval = krb5_auth_con_setaddrs(kdc_context, auth_context, NULL,\n                                         from->address)) )\n        goto cleanup_auth_context;\n\n    retval = kdc_rd_ap_req(kdc_active_realm,\n                           apreq, auth_context, &krbtgt, tgskey);\n    if (retval)\n        goto cleanup_auth_context;\n\n    /* \"invalid flag\" tickets can must be used to validate */\n    if (isflagset(ticket->enc_part2->flags, TKT_FLG_INVALID) &&\n        !isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        retval = KRB5KRB_AP_ERR_TKT_INVALID;\n        goto cleanup_auth_context;\n    }\n\n    if ((retval = krb5_auth_con_getrecvsubkey(kdc_context,\n                                              auth_context, subkey)))\n        goto cleanup_auth_context;\n\n    if ((retval = krb5_auth_con_getauthenticator(kdc_context, auth_context,\n                                                 &authenticator)))\n        goto cleanup_auth_context;\n\n    retval = krb5_find_authdata(kdc_context,\n                                ticket->enc_part2->authorization_data,\n                                authenticator->authorization_data,\n                                KRB5_AUTHDATA_FX_ARMOR, &authdata);\n    if (retval != 0)\n        goto cleanup_authenticator;\n    if (authdata&& authdata[0]) {\n        k5_setmsg(kdc_context, KRB5KDC_ERR_POLICY,\n                  \"ticket valid only as FAST armor\");\n        retval = KRB5KDC_ERR_POLICY;\n        krb5_free_authdata(kdc_context, authdata);\n        goto cleanup_authenticator;\n    }\n    krb5_free_authdata(kdc_context, authdata);\n\n\n    /* Check for a checksum */\n    if (!(his_cksum = authenticator->checksum)) {\n        retval = KRB5KRB_AP_ERR_INAPP_CKSUM;\n        goto cleanup_authenticator;\n    }\n\n    /* make sure the client is of proper lineage (see above) */\n    if (foreign_server &&\n        !krb5int_find_pa_data(kdc_context,\n                              request->padata, KRB5_PADATA_FOR_USER)) {\n        if (is_local_principal(kdc_active_realm,\n                               ticket->enc_part2->client)) {\n            /* someone in a foreign realm claiming to be local */\n            krb5_klog_syslog(LOG_INFO, _(\"PROCESS_TGS: failed lineage check\"));\n            retval = KRB5KDC_ERR_POLICY;\n            goto cleanup_authenticator;\n        }\n    }\n\n    /*\n     * Check application checksum vs. tgs request\n     *\n     * We try checksumming the req-body two different ways: first we\n     * try reaching into the raw asn.1 stream (if available), and\n     * checksum that directly; if that fails, then we try encoding\n     * using our local asn.1 library.\n     */\n    if (pkt && (fetch_asn1_field((unsigned char *) pkt->data,\n                                 1, 4, &scratch1) >= 0)) {\n        if (comp_cksum(kdc_context, &scratch1, ticket, his_cksum)) {\n            if (!(retval = encode_krb5_kdc_req_body(request, &scratch)))\n                retval = comp_cksum(kdc_context, scratch, ticket, his_cksum);\n            krb5_free_data(kdc_context, scratch);\n            if (retval)\n                goto cleanup_authenticator;\n        }\n    }\n\n    *pa_tgs_req = tmppa;\n    *krbtgt_ptr = krbtgt;\n    krbtgt = NULL;\n\ncleanup_authenticator:\n    krb5_free_authenticator(kdc_context, authenticator);\n\ncleanup_auth_context:\n    krb5_auth_con_free(kdc_context, auth_context);\n\ncleanup:\n    if (retval != 0) {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        *tgskey = NULL;\n    }\n    if (apreq->ticket->enc_part2 != NULL) {\n        /* Steal the decrypted ticket pointer, even on error. */\n        *ticket_out = apreq->ticket;\n        apreq->ticket = NULL;\n    }\n    krb5_free_ap_req(kdc_context, apreq);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    return retval;\n}\n\n/*\n * This is a KDC wrapper around krb5_rd_req_decoded_anyflag().\n *\n * We can't depend on KDB-as-keytab for handling the AP-REQ here for\n * optimization reasons: we want to minimize the number of KDB lookups.  We'll\n * need the KDB entry for the TGS principal, and the TGS key used to decrypt\n * the TGT, elsewhere in the TGS code.\n *\n * This function also implements key rollover support for kvno 0 cross-realm\n * TGTs issued by AD.\n */\nstatic\nkrb5_error_code\nkdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n              krb5_ap_req *apreq, krb5_auth_context auth_context,\n              krb5_db_entry **server, krb5_keyblock **tgskey)\n{\n    krb5_error_code     retval;\n    krb5_enctype        search_enctype = apreq->ticket->enc_part.enctype;\n    krb5_boolean        match_enctype = 1;\n    krb5_kvno           kvno;\n    size_t              tries = 3;\n\n    /*\n     * When we issue tickets we use the first key in the principals' highest\n     * kvno keyset.  For non-cross-realm krbtgt principals we want to only\n     * allow the use of the first key of the principal's keyset that matches\n     * the given kvno.\n     */\n    if (krb5_is_tgs_principal(apreq->ticket->server) &&\n        !is_cross_tgs_principal(apreq->ticket->server)) {\n        search_enctype = -1;\n        match_enctype = 0;\n    }\n\n    retval = kdc_get_server_key(kdc_context, apreq->ticket,\n                                KRB5_KDB_FLAG_ALIAS_OK, match_enctype, server,\n                                NULL, NULL);\n    if (retval)\n        return retval;\n\n    *tgskey = NULL;\n    kvno = apreq->ticket->enc_part.kvno;\n    do {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        retval = find_server_key(kdc_context,\n                                 *server, search_enctype, kvno, tgskey, &kvno);\n        if (retval)\n            continue;\n\n        /* Make the TGS key available to krb5_rd_req_decoded_anyflag() */\n        retval = krb5_auth_con_setuseruserkey(kdc_context, auth_context,\n                                              *tgskey);\n        if (retval)\n            return retval;\n\n        retval = krb5_rd_req_decoded_anyflag(kdc_context, &auth_context, apreq,\n                                             apreq->ticket->server,\n                                             kdc_active_realm->realm_keytab,\n                                             NULL, NULL);\n\n        /* If the ticket was decrypted, don't try any more keys. */\n        if (apreq->ticket->enc_part2 != NULL)\n            break;\n\n    } while (retval && apreq->ticket->enc_part.kvno == 0 && kvno-- > 1 &&\n             --tries > 0);\n\n    return retval;\n}\n\n/*\n * The KDC should take the keytab associated with the realm and pass\n * that to the krb5_rd_req_decoded_anyflag(), but we still need to use\n * the service (TGS, here) key elsewhere.  This approach is faster than\n * the KDB keytab approach too.\n *\n * This is also used by do_tgs_req() for u2u auth.\n */\nkrb5_error_code\nkdc_get_server_key(krb5_context context,\n                   krb5_ticket *ticket, unsigned int flags,\n                   krb5_boolean match_enctype, krb5_db_entry **server_ptr,\n                   krb5_keyblock **key, krb5_kvno *kvno)\n{\n    krb5_error_code       retval;\n    krb5_db_entry       * server = NULL;\n    krb5_enctype          search_enctype = -1;\n    krb5_kvno             search_kvno = -1;\n\n    if (match_enctype)\n        search_enctype = ticket->enc_part.enctype;\n    if (ticket->enc_part.kvno)\n        search_kvno = ticket->enc_part.kvno;\n\n    *server_ptr = NULL;\n\n    retval = krb5_db_get_principal(context, ticket->server, flags,\n                                   &server);\n    if (retval == KRB5_KDB_NOENTRY) {\n        char *sname;\n        if (!krb5_unparse_name(context, ticket->server, &sname)) {\n            limit_string(sname);\n            krb5_klog_syslog(LOG_ERR,\n                             _(\"TGS_REQ: UNKNOWN SERVER: server='%s'\"), sname);\n            free(sname);\n        }\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    } else if (retval)\n        return retval;\n    if (server->attributes & KRB5_KDB_DISALLOW_SVR ||\n        server->attributes & KRB5_KDB_DISALLOW_ALL_TIX) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n\n    if (key) {\n        retval = find_server_key(context, server, search_enctype, search_kvno,\n                                 key, kvno);\n        if (retval)\n            goto errout;\n    }\n    *server_ptr = server;\n    server = NULL;\n    return 0;\n\nerrout:\n    krb5_db_free_principal(context, server);\n    return retval;\n}\n\n/*\n * A utility function to get the right key from a KDB entry.  Used in handling\n * of kvno 0 TGTs, for example.\n */\nstatic\nkrb5_error_code\nfind_server_key(krb5_context context,\n                krb5_db_entry *server, krb5_enctype enctype, krb5_kvno kvno,\n                krb5_keyblock **key_out, krb5_kvno *kvno_out)\n{\n    krb5_error_code       retval;\n    krb5_key_data       * server_key;\n    krb5_keyblock       * key;\n\n    *key_out = NULL;\n    retval = krb5_dbe_find_enctype(context, server, enctype, -1,\n                                   kvno ? (krb5_int32)kvno : -1, &server_key);\n    if (retval)\n        return retval;\n    if (!server_key)\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    if ((key = (krb5_keyblock *)malloc(sizeof *key)) == NULL)\n        return ENOMEM;\n    retval = krb5_dbe_decrypt_key_data(context, NULL, server_key,\n                                       key, NULL);\n    if (retval)\n        goto errout;\n    if (enctype != -1) {\n        krb5_boolean similar;\n        retval = krb5_c_enctype_compare(context, enctype, key->enctype,\n                                        &similar);\n        if (retval)\n            goto errout;\n        if (!similar) {\n            retval = KRB5_KDB_NO_PERMITTED_KEY;\n            goto errout;\n        }\n        key->enctype = enctype;\n    }\n    *key_out = key;\n    key = NULL;\n    if (kvno_out)\n        *kvno_out = server_key->key_data_kvno;\nerrout:\n    krb5_free_keyblock(context, key);\n    return retval;\n}\n\n/*\n * If candidate is the local TGT for realm, set *alias_out to candidate and\n * *storage_out to NULL.  Otherwise, load the local TGT into *storage_out and\n * set *alias_out to *storage_out.\n *\n * In the future we might generalize this to a small per-request principal\n * cache.  For now, it saves a load operation in the common case where the AS\n * server or TGS header ticket server is the local TGT.\n */\nkrb5_error_code\nget_local_tgt(krb5_context context, const krb5_data *realm,\n              krb5_db_entry *candidate, krb5_db_entry **alias_out,\n              krb5_db_entry **storage_out)\n{\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_db_entry *tgt;\n\n    *alias_out = NULL;\n    *storage_out = NULL;\n\n    ret = krb5_build_principal_ext(context, &princ, realm->length, realm->data,\n                                   KRB5_TGS_NAME_SIZE, KRB5_TGS_NAME,\n                                   realm->length, realm->data, 0);\n    if (ret)\n        return ret;\n\n    if (!krb5_principal_compare(context, candidate->princ, princ)) {\n        ret = krb5_db_get_principal(context, princ, 0, &tgt);\n        if (!ret)\n            *storage_out = *alias_out = tgt;\n    } else {\n        *alias_out = candidate;\n    }\n\n    krb5_free_principal(context, princ);\n    return ret;\n}\n\n/* This probably wants to be updated if you support last_req stuff */\n\nstatic krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\nstatic krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };\n\nkrb5_error_code\nfetch_last_req_info(krb5_db_entry *dbentry, krb5_last_req_entry ***lrentry)\n{\n    *lrentry = nolrarray;\n    return 0;\n}\n\n\n/* XXX!  This is a temporary place-holder */\n\nkrb5_error_code\ncheck_hot_list(krb5_ticket *ticket)\n{\n    return 0;\n}\n\n\n/* Convert an API error code to a protocol error code. */\nint\nerrcode_to_protocol(krb5_error_code code)\n{\n    int protcode;\n\n    protcode = code - ERROR_TABLE_BASE_krb5;\n    return (protcode >= 0 && protcode <= 128) ? protcode : KRB_ERR_GENERIC;\n}\n\n/* Return -1 if the AS or TGS request is disallowed due to KDC policy on\n * anonymous tickets. */\nint\ncheck_anon(kdc_realm_t *kdc_active_realm,\n           krb5_principal client, krb5_principal server)\n{\n    /* If restrict_anon is set, reject requests from anonymous to principals\n     * other than the local TGT. */\n    if (kdc_active_realm->realm_restrict_anon &&\n        krb5_principal_compare_any_realm(kdc_context, client,\n                                         krb5_anonymous_principal()) &&\n        !krb5_principal_compare(kdc_context, server, tgs_server))\n        return -1;\n    return 0;\n}\n\n/*\n * Routines that validate a AS request; checks a lot of things.  :-)\n *\n * Returns a Kerberos protocol error number, which is _not_ the same\n * as a com_err error number!\n */\n#define AS_INVALID_OPTIONS (KDC_OPT_FORWARDED | KDC_OPT_PROXY |         \\\n                            KDC_OPT_VALIDATE | KDC_OPT_RENEW |          \\\n                            KDC_OPT_ENC_TKT_IN_SKEY | KDC_OPT_CNAME_IN_ADDL_TKT)\nint\nvalidate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && ts_after(kdc_time, client.expiration)) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && ts_after(kdc_time, client.pw_expiration) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && ts_after(kdc_time, server.expiration)) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n\nint\nvalidate_forwardable(krb5_kdc_req *request, krb5_db_entry client,\n                     krb5_db_entry server, krb5_timestamp kdc_time,\n                     const char **status)\n{\n    *status = NULL;\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_FORWARDABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_FORWARDABLE))) {\n        *status = \"FORWARDABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    } else\n        return 0;\n}\n\n/* Return KRB5KDC_ERR_POLICY if indicators does not contain the required auth\n * indicators for server, ENOMEM on allocation error, 0 otherwise. */\nkrb5_error_code\ncheck_indicators(krb5_context context, krb5_db_entry *server,\n                 krb5_data *const *indicators)\n{\n    krb5_error_code ret;\n    char *str = NULL, *copy = NULL, *save, *ind;\n\n    ret = krb5_dbe_get_string(context, server, KRB5_KDB_SK_REQUIRE_AUTH, &str);\n    if (ret || str == NULL)\n        goto cleanup;\n    copy = strdup(str);\n    if (copy == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Look for any of the space-separated strings in indicators. */\n    ind = strtok_r(copy, \" \", &save);\n    while (ind != NULL) {\n        if (authind_contains(indicators, ind))\n            goto cleanup;\n        ind = strtok_r(NULL, \" \", &save);\n    }\n\n    ret = KRB5KDC_ERR_POLICY;\n    k5_setmsg(context, ret,\n              _(\"Required auth indicators not present in ticket: %s\"), str);\n\ncleanup:\n    krb5_dbe_free_string(context, str);\n    free(copy);\n    return ret;\n}\n\n#define ASN1_ID_CLASS   (0xc0)\n#define ASN1_ID_TYPE    (0x20)\n#define ASN1_ID_TAG     (0x1f)\n#define ASN1_CLASS_UNIV (0)\n#define ASN1_CLASS_APP  (1)\n#define ASN1_CLASS_CTX  (2)\n#define ASN1_CLASS_PRIV (3)\n#define asn1_id_constructed(x)  (x & ASN1_ID_TYPE)\n#define asn1_id_primitive(x)    (!asn1_id_constructed(x))\n#define asn1_id_class(x)        ((x & ASN1_ID_CLASS) >> 6)\n#define asn1_id_tag(x)          (x & ASN1_ID_TAG)\n\n/*\n * asn1length - return encoded length of value.\n *\n * passed a pointer into the asn.1 stream, which is updated\n * to point right after the length bits.\n *\n * returns -1 on failure.\n */\nstatic int\nasn1length(unsigned char **astream)\n{\n    int length;         /* resulting length */\n    int sublen;         /* sublengths */\n    int blen;           /* bytes of length */\n    unsigned char *p;   /* substring searching */\n\n    if (**astream & 0x80) {\n        blen = **astream & 0x7f;\n        if (blen > 3) {\n            return(-1);\n        }\n        for (++*astream, length = 0; blen; ++*astream, blen--) {\n            length = (length << 8) | **astream;\n        }\n        if (length == 0) {\n            /* indefinite length, figure out by hand */\n            p = *astream;\n            p++;\n            while (1) {\n                /* compute value length. */\n                if ((sublen = asn1length(&p)) < 0) {\n                    return(-1);\n                }\n                p += sublen;\n                /* check for termination */\n                if ((!*p++) && (!*p)) {\n                    p++;\n                    break;\n                }\n            }\n            length = p - *astream;\n        }\n    } else {\n        length = **astream;\n        ++*astream;\n    }\n    return(length);\n}\n\n/*\n * fetch_asn1_field - return raw asn.1 stream of subfield.\n *\n * this routine is passed a context-dependent tag number and \"level\" and returns\n * the size and length of the corresponding level subfield.\n *\n * levels and are numbered starting from 1.\n *\n * returns 0 on success, -1 otherwise.\n */\nint\nfetch_asn1_field(unsigned char *astream, unsigned int level,\n                 unsigned int field, krb5_data *data)\n{\n    unsigned char *estream;     /* end of stream */\n    int classes;                /* # classes seen so far this level */\n    unsigned int levels = 0;            /* levels seen so far */\n    int lastlevel = 1000;       /* last level seen */\n    int length;                 /* various lengths */\n    int tag;                    /* tag number */\n    unsigned char savelen;      /* saved length of our field */\n\n    classes = -1;\n    /* we assume that the first identifier/length will tell us\n       how long the entire stream is. */\n    astream++;\n    estream = astream;\n    if ((length = asn1length(&astream)) < 0) {\n        return(-1);\n    }\n    estream += length;\n    /* search down the stream, checking identifiers.  we process identifiers\n       until we hit the \"level\" we want, and then process that level for our\n       subfield, always making sure we don't go off the end of the stream.  */\n    while (astream < estream) {\n        if (!asn1_id_constructed(*astream)) {\n            return(-1);\n        }\n        if (asn1_id_class(*astream) == ASN1_CLASS_CTX) {\n            if ((tag = (int)asn1_id_tag(*astream)) <= lastlevel) {\n                levels++;\n                classes = -1;\n            }\n            lastlevel = tag;\n            if (levels == level) {\n                /* in our context-dependent class, is this the one we're looking for ? */\n                if (tag == (int)field) {\n                    /* return length and data */\n                    astream++;\n                    savelen = *astream;\n                    if ((length = asn1length(&astream)) < 0) {\n                        return(-1);\n                    }\n                    data->length = length;\n                    /* if the field length is indefinite, we will have to subtract two\n                       (terminating octets) from the length returned since we don't want\n                       to pass any info from the \"wrapper\" back.  asn1length will always return\n                       the *total* length of the field, not just what's contained in it */\n                    if ((savelen & 0xff) == 0x80) {\n                        data->length -=2 ;\n                    }\n                    data->data = (char *)astream;\n                    return(0);\n                } else if (tag <= classes) {\n                    /* we've seen this class before, something must be wrong */\n                    return(-1);\n                } else {\n                    classes = tag;\n                }\n            }\n        }\n        /* if we're not on our level yet, process this value.  otherwise skip over it */\n        astream++;\n        if ((length = asn1length(&astream)) < 0) {\n            return(-1);\n        }\n        if (levels == level) {\n            astream += length;\n        }\n    }\n    return(-1);\n}\n\n/* Return true if we believe server can support enctype as a session key. */\nstatic krb5_boolean\ndbentry_supports_enctype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                         krb5_enctype enctype)\n{\n    krb5_error_code     retval;\n    krb5_key_data       *datap;\n    char                *etypes_str = NULL;\n    krb5_enctype        default_enctypes[1] = { 0 };\n    krb5_enctype        *etypes = NULL;\n    krb5_boolean        in_list;\n\n    /* Look up the supported session key enctypes list in the KDB. */\n    retval = krb5_dbe_get_string(kdc_context, server,\n                                 KRB5_KDB_SK_SESSION_ENCTYPES,\n                                 &etypes_str);\n    if (retval == 0 && etypes_str != NULL && *etypes_str != '\\0') {\n        /* Pass a fake profile key for tracing of unrecognized tokens. */\n        retval = krb5int_parse_enctype_list(kdc_context, \"KDB-session_etypes\",\n                                            etypes_str, default_enctypes,\n                                            &etypes);\n        if (retval == 0 && etypes != NULL && etypes[0]) {\n            in_list = k5_etypes_contains(etypes, enctype);\n            free(etypes_str);\n            free(etypes);\n            return in_list;\n        }\n        /* Fall through on error or empty list */\n    }\n    free(etypes_str);\n    free(etypes);\n\n    /* If configured to, assume every server without a session_enctypes\n     * attribute supports DES_CBC_CRC. */\n    if (kdc_active_realm->realm_assume_des_crc_sess &&\n        enctype == ENCTYPE_DES_CBC_CRC)\n        return TRUE;\n\n    /* Due to an ancient interop problem, assume nothing supports des-cbc-md5\n     * unless there's a session_enctypes explicitly saying that it does. */\n    if (enctype == ENCTYPE_DES_CBC_MD5)\n        return FALSE;\n\n    /* Assume the server supports any enctype it has a long-term key for. */\n    return !krb5_dbe_find_enctype(kdc_context, server, enctype, -1, 0, &datap);\n}\n\n/*\n * This function returns the keytype which should be selected for the\n * session key.  It is based on the ordered list which the user\n * requested, and what the KDC and the application server can support.\n */\nkrb5_enctype\nselect_session_keytype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                       int nktypes, krb5_enctype *ktype)\n{\n    int         i;\n\n    for (i = 0; i < nktypes; i++) {\n        if (!krb5_c_valid_enctype(ktype[i]))\n            continue;\n\n        if (!krb5_is_permitted_enctype(kdc_context, ktype[i]))\n            continue;\n\n        if (dbentry_supports_enctype(kdc_active_realm, server, ktype[i]))\n            return ktype[i];\n    }\n\n    return 0;\n}\n\n/*\n * Limit strings to a \"reasonable\" length to prevent crowding out of\n * other useful information in the log entry\n */\n#define NAME_LENGTH_LIMIT 128\n\nvoid limit_string(char *name)\n{\n    int     i;\n\n    if (!name)\n        return;\n\n    if (strlen(name) < NAME_LENGTH_LIMIT)\n        return;\n\n    i = NAME_LENGTH_LIMIT-4;\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i] = '\\0';\n    return;\n}\n\n/*\n * L10_2 = log10(2**x), rounded up; log10(2) ~= 0.301.\n */\n#define L10_2(x) ((int)(((x * 301) + 999) / 1000))\n\n/*\n * Max length of sprintf(\"%ld\") for an int of type T; includes leading\n * minus sign and terminating NUL.\n */\n#define D_LEN(t) (L10_2(sizeof(t) * CHAR_BIT) + 2)\n\nvoid\nktypes2str(char *s, size_t len, int nktypes, krb5_enctype *ktype)\n{\n    int i;\n    char stmp[D_LEN(krb5_enctype) + 1];\n    char *p;\n\n    if (nktypes < 0\n        || len < (sizeof(\" etypes {...}\") + D_LEN(int))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"%d etypes {\", nktypes);\n    for (i = 0; i < nktypes; i++) {\n        snprintf(stmp, sizeof(stmp), \"%s%ld\", i ? \" \" : \"\", (long)ktype[i]);\n        if (strlen(s) + strlen(stmp) + sizeof(\"}\") > len)\n            break;\n        strlcat(s, stmp, len);\n    }\n    if (i < nktypes) {\n        /*\n         * We broke out of the loop. Try to truncate the list.\n         */\n        p = s + strlen(s);\n        while (p - s + sizeof(\"...}\") > len) {\n            while (p > s && *p != ' ' && *p != '{')\n                *p-- = '\\0';\n            if (p > s && *p == ' ') {\n                *p-- = '\\0';\n                continue;\n            }\n        }\n        strlcat(s, \"...\", len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nvoid\nrep_etypes2str(char *s, size_t len, krb5_kdc_rep *rep)\n{\n    char stmp[sizeof(\"ses=\") + D_LEN(krb5_enctype)];\n\n    if (len < (3 * D_LEN(krb5_enctype)\n               + sizeof(\"etypes {rep= tkt= ses=}\"))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"etypes {rep=%ld\", (long)rep->enc_part.enctype);\n\n    if (rep->ticket != NULL) {\n        snprintf(stmp, sizeof(stmp),\n                 \" tkt=%ld\", (long)rep->ticket->enc_part.enctype);\n        strlcat(s, stmp, len);\n    }\n\n    if (rep->ticket != NULL\n        && rep->ticket->enc_part2 != NULL\n        && rep->ticket->enc_part2->session != NULL) {\n        snprintf(stmp, sizeof(stmp), \" ses=%ld\",\n                 (long)rep->ticket->enc_part2->session->enctype);\n        strlcat(s, stmp, len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nstatic krb5_error_code\nverify_for_user_checksum(krb5_context context,\n                         krb5_keyblock *key,\n                         krb5_pa_for_user *req)\n{\n    krb5_error_code             code;\n    int                         i;\n    krb5_int32                  name_type;\n    char                        *p;\n    krb5_data                   data;\n    krb5_boolean                valid = FALSE;\n\n    if (!krb5_c_is_keyed_cksum(req->cksum.checksum_type)) {\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n    }\n\n    /*\n     * Checksum is over name type and string components of\n     * client principal name and auth_package.\n     */\n    data.length = 4;\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        data.length += krb5_princ_component(context, req->user, i)->length;\n    }\n    data.length += krb5_princ_realm(context, req->user)->length;\n    data.length += req->auth_package.length;\n\n    p = data.data = malloc(data.length);\n    if (data.data == NULL) {\n        return ENOMEM;\n    }\n\n    name_type = krb5_princ_type(context, req->user);\n    p[0] = (name_type >> 0 ) & 0xFF;\n    p[1] = (name_type >> 8 ) & 0xFF;\n    p[2] = (name_type >> 16) & 0xFF;\n    p[3] = (name_type >> 24) & 0xFF;\n    p += 4;\n\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        if (krb5_princ_component(context, req->user, i)->length > 0) {\n            memcpy(p, krb5_princ_component(context, req->user, i)->data,\n                   krb5_princ_component(context, req->user, i)->length);\n        }\n        p += krb5_princ_component(context, req->user, i)->length;\n    }\n\n    if (krb5_princ_realm(context, req->user)->length > 0) {\n        memcpy(p, krb5_princ_realm(context, req->user)->data,\n               krb5_princ_realm(context, req->user)->length);\n    }\n    p += krb5_princ_realm(context, req->user)->length;\n\n    if (req->auth_package.length > 0)\n        memcpy(p, req->auth_package.data, req->auth_package.length);\n    p += req->auth_package.length;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_APP_DATA_CKSUM,\n                                  &data,\n                                  &req->cksum,\n                                  &valid);\n\n    if (code == 0 && valid == FALSE)\n        code = KRB5KRB_AP_ERR_MODIFIED;\n\n    free(data.data);\n\n    return code;\n}\n\n/*\n * Legacy protocol transition (Windows 2003 and above)\n */\nstatic krb5_error_code\nkdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}\n\nstatic krb5_error_code\nverify_s4u_x509_user_checksum(krb5_context context,\n                              krb5_keyblock *key,\n                              krb5_data *req_data,\n                              krb5_int32 kdc_req_nonce,\n                              krb5_pa_s4u_x509_user *req)\n{\n    krb5_error_code             code;\n    krb5_data                   scratch;\n    krb5_boolean                valid = FALSE;\n\n    if (enctype_requires_etype_info_2(key->enctype) &&\n        !krb5_c_is_keyed_cksum(req->cksum.checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    if (req->user_id.nonce != kdc_req_nonce)\n        return KRB5KRB_AP_ERR_MODIFIED;\n\n    /*\n     * Verify checksum over the encoded userid. If that fails,\n     * re-encode, and verify that. This is similar to the\n     * behaviour in kdc_process_tgs_req().\n     */\n    if (fetch_asn1_field((unsigned char *)req_data->data, 1, 0, &scratch) < 0)\n        return ASN1_PARSE_ERROR;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                  &scratch,\n                                  &req->cksum,\n                                  &valid);\n    if (code != 0)\n        return code;\n\n    if (valid == FALSE) {\n        krb5_data *data;\n\n        code = encode_krb5_s4u_userid(&req->user_id, &data);\n        if (code != 0)\n            return code;\n\n        code = krb5_c_verify_checksum(context,\n                                      key,\n                                      KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                      data,\n                                      &req->cksum,\n                                      &valid);\n\n        krb5_free_data(context, data);\n\n        if (code != 0)\n            return code;\n    }\n\n    return valid ? 0 : KRB5KRB_AP_ERR_MODIFIED;\n}\n\n/*\n * New protocol transition request (Windows 2008 and above)\n */\nstatic krb5_error_code\nkdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_make_s4u2self_rep(krb5_context context,\n                      krb5_keyblock *tgs_subkey,\n                      krb5_keyblock *tgs_session,\n                      krb5_pa_s4u_x509_user *req_s4u_user,\n                      krb5_kdc_rep *reply,\n                      krb5_enc_kdc_rep_part *reply_encpart)\n{\n    krb5_error_code             code;\n    krb5_data                   *data = NULL;\n    krb5_pa_s4u_x509_user       rep_s4u_user;\n    krb5_pa_data                padata;\n    krb5_enctype                enctype;\n    krb5_keyusage               usage;\n\n    memset(&rep_s4u_user, 0, sizeof(rep_s4u_user));\n\n    rep_s4u_user.user_id.nonce   = req_s4u_user->user_id.nonce;\n    rep_s4u_user.user_id.user    = req_s4u_user->user_id.user;\n    rep_s4u_user.user_id.options =\n        req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE;\n\n    code = encode_krb5_s4u_userid(&rep_s4u_user.user_id, &data);\n    if (code != 0)\n        goto cleanup;\n\n    if (req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE)\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY;\n    else\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST;\n\n    code = krb5_c_make_checksum(context, req_s4u_user->cksum.checksum_type,\n                                tgs_subkey != NULL ? tgs_subkey : tgs_session,\n                                usage, data,\n                                &rep_s4u_user.cksum);\n    if (code != 0)\n        goto cleanup;\n\n    krb5_free_data(context, data);\n    data = NULL;\n\n    code = encode_krb5_pa_s4u_x509_user(&rep_s4u_user, &data);\n    if (code != 0)\n        goto cleanup;\n\n    padata.magic = KV5M_PA_DATA;\n    padata.pa_type = KRB5_PADATA_S4U_X509_USER;\n    padata.length = data->length;\n    padata.contents = (krb5_octet *)data->data;\n\n    code = add_pa_data_element(context, &padata, &reply->padata, FALSE);\n    if (code != 0)\n        goto cleanup;\n\n    free(data);\n    data = NULL;\n\n    if (tgs_subkey != NULL)\n        enctype = tgs_subkey->enctype;\n    else\n        enctype = tgs_session->enctype;\n\n    /*\n     * Owing to a bug in Windows, unkeyed checksums were used for older\n     * enctypes, including rc4-hmac. A forthcoming workaround for this\n     * includes the checksum bytes in the encrypted padata.\n     */\n    if ((req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE) &&\n        enctype_requires_etype_info_2(enctype) == FALSE) {\n        padata.length = req_s4u_user->cksum.length +\n            rep_s4u_user.cksum.length;\n        padata.contents = malloc(padata.length);\n        if (padata.contents == NULL) {\n            code = ENOMEM;\n            goto cleanup;\n        }\n\n        memcpy(padata.contents,\n               req_s4u_user->cksum.contents,\n               req_s4u_user->cksum.length);\n        memcpy(&padata.contents[req_s4u_user->cksum.length],\n               rep_s4u_user.cksum.contents,\n               rep_s4u_user.cksum.length);\n\n        code = add_pa_data_element(context,&padata,\n                                   &reply_encpart->enc_padata, FALSE);\n        if (code != 0) {\n            free(padata.contents);\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    if (rep_s4u_user.cksum.contents != NULL)\n        krb5_free_checksum_contents(context, &rep_s4u_user.cksum);\n    krb5_free_data(context, data);\n\n    return code;\n}\n\n/*\n * Protocol transition (S4U2Self)\n */\nkrb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\ncheck_allowed_to_delegate_to(krb5_context context, krb5_const_principal client,\n                             const krb5_db_entry *server,\n                             krb5_const_principal proxy)\n{\n    /* Can't get a TGT (otherwise it would be unconstrained delegation) */\n    if (krb5_is_tgs_principal(proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    /* Must be in same realm */\n    if (!krb5_realm_compare(context, server->princ, proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    return krb5_db_check_allowed_to_delegate(context, client, server, proxy);\n}\n\nkrb5_error_code\nkdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n\n    /*\n     * Constrained delegation is mutually exclusive with renew/forward/etc.\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /* Ensure that evidence ticket server matches TGT client */\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, /* after canon */\n                                server_princ)) {\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n\n    /* Backend policy check */\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_check_transited_list(kdc_realm_t *kdc_active_realm,\n                         const krb5_data *trans,\n                         const krb5_data *realm1,\n                         const krb5_data *realm2)\n{\n    krb5_error_code             code;\n\n    /* Check against the KDB module.  Treat this answer as authoritative if the\n     * method is supported and doesn't explicitly pass control. */\n    code = krb5_db_check_transited_realms(kdc_context, trans, realm1, realm2);\n    if (code != KRB5_PLUGIN_OP_NOTSUPP && code != KRB5_PLUGIN_NO_HANDLE)\n        return code;\n\n    /* Check using krb5.conf [capaths] or hierarchical relationships. */\n    return krb5_check_transited_list(kdc_context, trans, realm1, realm2);\n}\n\nkrb5_error_code\nvalidate_transit_path(krb5_context context,\n                      krb5_const_principal client,\n                      krb5_db_entry *server,\n                      krb5_db_entry *header_srv)\n{\n    /* Incoming */\n    if (isflagset(server->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE)) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    /* Outgoing */\n    if (isflagset(header_srv->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE) &&\n        (!krb5_principal_compare(context, server->princ, header_srv->princ) ||\n         !krb5_realm_compare(context, client, header_srv->princ))) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    return 0;\n}\n\nkrb5_boolean\nenctype_requires_etype_info_2(krb5_enctype enctype)\n{\n    switch(enctype) {\n    case ENCTYPE_DES_CBC_CRC:\n    case ENCTYPE_DES_CBC_MD4:\n    case ENCTYPE_DES_CBC_MD5:\n    case ENCTYPE_DES3_CBC_SHA1:\n    case ENCTYPE_DES3_CBC_RAW:\n    case ENCTYPE_ARCFOUR_HMAC:\n    case ENCTYPE_ARCFOUR_HMAC_EXP :\n        return 0;\n    default:\n        return krb5_c_valid_enctype(enctype);\n    }\n}\n\n/* XXX where are the generic helper routines for this? */\nkrb5_error_code\nadd_pa_data_element(krb5_context context,\n                    krb5_pa_data *padata,\n                    krb5_pa_data ***inout_padata,\n                    krb5_boolean copy)\n{\n    int                         i;\n    krb5_pa_data                **p;\n\n    if (*inout_padata != NULL) {\n        for (i = 0; (*inout_padata)[i] != NULL; i++)\n            ;\n    } else\n        i = 0;\n\n    p = realloc(*inout_padata, (i + 2) * sizeof(krb5_pa_data *));\n    if (p == NULL)\n        return ENOMEM;\n\n    *inout_padata = p;\n\n    p[i] = (krb5_pa_data *)malloc(sizeof(krb5_pa_data));\n    if (p[i] == NULL)\n        return ENOMEM;\n    *(p[i]) = *padata;\n\n    p[i + 1] = NULL;\n\n    if (copy) {\n        p[i]->contents = (krb5_octet *)malloc(padata->length);\n        if (p[i]->contents == NULL) {\n            free(p[i]);\n            p[i] = NULL;\n            return ENOMEM;\n        }\n\n        memcpy(p[i]->contents, padata->contents, padata->length);\n    }\n\n    return 0;\n}\n\nvoid\nkdc_get_ticket_endtime(kdc_realm_t *kdc_active_realm,\n                       krb5_timestamp starttime,\n                       krb5_timestamp endtime,\n                       krb5_timestamp till,\n                       krb5_db_entry *client,\n                       krb5_db_entry *server,\n                       krb5_timestamp *out_endtime)\n{\n    krb5_timestamp until, life;\n\n    if (till == 0)\n        till = kdc_infinity;\n\n    until = ts_min(till, endtime);\n\n    life = ts_delta(until, starttime);\n\n    if (client != NULL && client->max_life != 0)\n        life = min(life, client->max_life);\n    if (server->max_life != 0)\n        life = min(life, server->max_life);\n    if (kdc_active_realm->realm_maxlife != 0)\n        life = min(life, kdc_active_realm->realm_maxlife);\n\n    *out_endtime = ts_incr(starttime, life);\n}\n\n/*\n * Set tkt->renew_till to the requested renewable lifetime as modified by\n * policy.  Set the TKT_FLG_RENEWABLE flag if we set a nonzero renew_till.\n * client and tgt may be NULL.\n */\nvoid\nkdc_get_ticket_renewtime(kdc_realm_t *realm, krb5_kdc_req *request,\n                         krb5_enc_tkt_part *tgt, krb5_db_entry *client,\n                         krb5_db_entry *server, krb5_enc_tkt_part *tkt)\n{\n    krb5_timestamp rtime, max_rlife;\n\n    tkt->times.renew_till = 0;\n\n    /* Don't issue renewable tickets if the client or server don't allow it,\n     * or if this is a TGS request and the TGT isn't renewable. */\n    if (server->attributes & KRB5_KDB_DISALLOW_RENEWABLE)\n        return;\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_RENEWABLE))\n        return;\n    if (tgt != NULL && !(tgt->flags & TKT_FLG_RENEWABLE))\n        return;\n\n    /* Determine the requested renewable time. */\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE))\n        rtime = request->rtime ? request->rtime : kdc_infinity;\n    else if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n             ts_after(request->till, tkt->times.endtime))\n        rtime = request->till;\n    else\n        return;\n\n    /* Truncate it to the allowable renewable time. */\n    if (tgt != NULL)\n        rtime = ts_min(rtime, tgt->times.renew_till);\n    max_rlife = min(server->max_renewable_life, realm->realm_maxrlife);\n    if (client != NULL)\n        max_rlife = min(max_rlife, client->max_renewable_life);\n    rtime = ts_min(rtime, ts_incr(tkt->times.starttime, max_rlife));\n\n    /* Make the ticket renewable if the truncated requested time is larger than\n     * the ticket end time. */\n    if (ts_after(rtime, tkt->times.endtime)) {\n        setflag(tkt->flags, TKT_FLG_RENEWABLE);\n        tkt->times.renew_till = rtime;\n    }\n}\n\n/**\n * Handle protected negotiation of FAST using enc_padata\n * - If ENCPADATA_REQ_ENC_PA_REP is present, then:\n * - Return ENCPADATA_REQ_ENC_PA_REP with checksum of AS-REQ from client\n * - Include PADATA_FX_FAST in the enc_padata to indicate FAST\n * @pre @c out_enc_padata has space for at least two more padata\n * @param index in/out index into @c out_enc_padata for next item\n */\nkrb5_error_code\nkdc_handle_protected_negotiation(krb5_context context,\n                                 krb5_data *req_pkt, krb5_kdc_req *request,\n                                 const krb5_keyblock *reply_key,\n                                 krb5_pa_data ***out_enc_padata)\n{\n    krb5_error_code retval = 0;\n    krb5_checksum checksum;\n    krb5_data *out = NULL;\n    krb5_pa_data pa, *pa_in;\n    pa_in = krb5int_find_pa_data(context, request->padata,\n                                 KRB5_ENCPADATA_REQ_ENC_PA_REP);\n    if (pa_in == NULL)\n        return 0;\n    pa.magic = KV5M_PA_DATA;\n    pa.pa_type = KRB5_ENCPADATA_REQ_ENC_PA_REP;\n    memset(&checksum, 0, sizeof(checksum));\n    retval = krb5_c_make_checksum(context,0, reply_key,\n                                  KRB5_KEYUSAGE_AS_REQ, req_pkt, &checksum);\n    if (retval != 0)\n        goto cleanup;\n    retval = encode_krb5_checksum(&checksum, &out);\n    if (retval != 0)\n        goto cleanup;\n    pa.contents = (krb5_octet *) out->data;\n    pa.length = out->length;\n    retval = add_pa_data_element(context, &pa, out_enc_padata, FALSE);\n    if (retval)\n        goto cleanup;\n    out->data = NULL;\n    pa.magic = KV5M_PA_DATA;\n    pa.pa_type = KRB5_PADATA_FX_FAST;\n    pa.length = 0;\n    pa.contents = NULL;\n    retval = add_pa_data_element(context, &pa, out_enc_padata, FALSE);\ncleanup:\n    if (checksum.contents)\n        krb5_free_checksum_contents(context, &checksum);\n    if (out != NULL)\n        krb5_free_data(context, out);\n    return retval;\n}\n\n/*\n * Although the KDC doesn't call this function directly,\n * process_tcp_connection_read() in net-server.c does call it.\n */\nkrb5_error_code\nmake_toolong_error (void *handle, krb5_data **out)\n{\n    krb5_error errpkt;\n    krb5_error_code retval;\n    krb5_data *scratch;\n    struct server_handle *h = handle;\n\n    retval = krb5_us_timeofday(h->kdc_err_context,\n                               &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return retval;\n    errpkt.error = KRB_ERR_FIELD_TOOLONG;\n    errpkt.server = h->kdc_realmlist[0]->realm_tgsprinc;\n    errpkt.client = NULL;\n    errpkt.cusec = 0;\n    errpkt.ctime = 0;\n    errpkt.text.length = 0;\n    errpkt.text.data = 0;\n    errpkt.e_data.length = 0;\n    errpkt.e_data.data = 0;\n    scratch = malloc(sizeof(*scratch));\n    if (scratch == NULL)\n        return ENOMEM;\n    retval = krb5_mk_error(h->kdc_err_context, &errpkt, scratch);\n    if (retval) {\n        free(scratch);\n        return retval;\n    }\n\n    *out = scratch;\n    return 0;\n}\n\nvoid reset_for_hangup(void *ctx)\n{\n    int k;\n    struct server_handle *h = ctx;\n\n    for (k = 0; k < h->kdc_numrealms; k++)\n        krb5_db_refresh_config(h->kdc_realmlist[k]->realm_context);\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_as_req.c */\n/*\n * Portions Copyright (C) 2007 Apple Inc.\n * Copyright 1990, 1991, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n *\n * KDC Routines to deal with AS_REQ's\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n#include \"com_err.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif  /* hpux */\n#endif /* HAVE_NETINET_IN_H */\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include <kadm5/admin.h>\n#include \"adm_proto.h\"\n#include \"extern.h\"\n\nstatic krb5_error_code\nprepare_error_as(struct kdc_request_state *, krb5_kdc_req *, krb5_db_entry *,\n                 int, krb5_pa_data **, krb5_boolean, krb5_principal,\n                 krb5_data **, const char *);\n\n/* Determine the key-expiration value according to RFC 4120 section 5.4.2. */\nstatic krb5_timestamp\nget_key_exp(krb5_db_entry *entry)\n{\n    if (entry->expiration == 0)\n        return entry->pw_expiration;\n    if (entry->pw_expiration == 0)\n        return entry->expiration;\n    return ts_min(entry->expiration, entry->pw_expiration);\n}\n\n/*\n * Find the key in client for the most preferred enctype in req_enctypes.  Fill\n * in *kb_out with the decrypted keyblock (which the caller must free) and set\n * *kd_out to an alias to that key data entry.  Set *kd_out to NULL and leave\n * *kb_out zeroed if no key is found for any of the requested enctypes.\n * kb_out->enctype may differ from the enctype of *kd_out for DES enctypes; in\n * this case, kb_out->enctype is the requested enctype used to match the key\n * data entry.\n */\nstatic krb5_error_code\nselect_client_key(krb5_context context, krb5_db_entry *client,\n                  krb5_enctype *req_enctypes, int n_req_enctypes,\n                  krb5_keyblock *kb_out, krb5_key_data **kd_out)\n{\n    krb5_error_code ret;\n    krb5_key_data *kd;\n    krb5_enctype etype;\n    int i;\n\n    memset(kb_out, 0, sizeof(*kb_out));\n    *kd_out = NULL;\n\n    for (i = 0; i < n_req_enctypes; i++) {\n        etype = req_enctypes[i];\n        if (!krb5_c_valid_enctype(etype))\n            continue;\n        if (krb5_dbe_find_enctype(context, client, etype, -1, 0, &kd) == 0) {\n            /* Decrypt the client key data and set its enctype to the request\n             * enctype (which may differ from the key data enctype for DES). */\n            ret = krb5_dbe_decrypt_key_data(context, NULL, kd, kb_out, NULL);\n            if (ret)\n                return ret;\n            kb_out->enctype = etype;\n            *kd_out = kd;\n            return 0;\n        }\n    }\n    return 0;\n}\n\nstruct as_req_state {\n    loop_respond_fn respond;\n    void *arg;\n\n    krb5_principal_data client_princ;\n    krb5_enc_tkt_part enc_tkt_reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply;\n    krb5_keyblock server_keyblock;\n    krb5_keyblock client_keyblock;\n    krb5_db_entry *client;\n    krb5_db_entry *server;\n    krb5_db_entry *local_tgt;\n    krb5_db_entry *local_tgt_storage;\n    krb5_key_data *client_key;\n    krb5_kdc_req *request;\n    struct krb5_kdcpreauth_rock_st rock;\n    const char *status;\n    krb5_pa_data **e_data;\n    krb5_boolean typed_e_data;\n    krb5_kdc_rep reply;\n    krb5_timestamp kdc_time;\n    krb5_timestamp authtime;\n    krb5_keyblock session_key;\n    unsigned int c_flags;\n    krb5_data *req_pkt;\n    krb5_data *inner_body;\n    struct kdc_request_state *rstate;\n    char *sname, *cname;\n    void *pa_context;\n    const krb5_fulladdr *local_addr;\n    const krb5_fulladdr *remote_addr;\n    krb5_data **auth_indicators;\n\n    krb5_error_code preauth_err;\n\n    kdc_realm_t *active_realm;\n    krb5_audit_state *au_state;\n};\n\nstatic void\nfinish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state->active_realm;\n    krb5_audit_state *au_state = state->au_state;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state->request, *state->client,\n                                        *state->server, state->kdc_time,\n                                        &state->status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state->server,\n                               state->auth_indicators);\n    if (errcode) {\n        state->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state->server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &server_key))) {\n        state->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /*\n     * Convert server->key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &state->server_keyblock,\n                                             NULL))) {\n        state->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req))) {\n        state->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it's location\n     *  is used for ktime\n     */\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.times.authtime = state->authtime = state->kdc_time;\n\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \"CANT_FIND_CLIENT_KEY\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state->c_flags,\n                              state->client,\n                              state->server,\n                              NULL,\n                              state->local_tgt,\n                              &state->client_keyblock,\n                              &state->server_keyblock,\n                              NULL,\n                              state->req_pkt,\n                              state->request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state->auth_indicators,\n                              &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"AS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        state->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode) {\n        state->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode) {\n        state->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part.kvno = server_key->key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode) {\n        state->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode) {\n        state->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &state->reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &state->reply, &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode) {\n        state->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0 && state->status == NULL)\n        state->status = \"UNKNOWN_REASON\";\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(kdc_context,\n              (errcode || state->preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state->status) {\n        log_as_req(kdc_context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->authtime,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode < 0 || errcode > KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, errcode,\n                                       state->e_data, state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state->enc_tkt_reply.authorization_data);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(kdc_context, state->client);\n    krb5_db_free_principal(kdc_context, state->server);\n    krb5_db_free_principal(kdc_context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state->e_data);\n    krb5_free_data(kdc_context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(kdc_context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}\n\nstatic void\nfinish_missing_required_preauth(void *arg)\n{\n    struct as_req_state *state = (struct as_req_state *)arg;\n\n    finish_process_as_req(state, state->preauth_err);\n}\n\nstatic void\nfinish_preauth(void *arg, krb5_error_code code)\n{\n    struct as_req_state *state = arg;\n    krb5_error_code real_code = code;\n\n    if (code) {\n        if (vague_errors)\n            code = KRB5KRB_ERR_GENERIC;\n        state->status = \"PREAUTH_FAILED\";\n        if (real_code == KRB5KDC_ERR_PREAUTH_FAILED) {\n            state->preauth_err = code;\n            get_preauth_hint_list(state->request, &state->rock, &state->e_data,\n                                  finish_missing_required_preauth, state);\n            return;\n        }\n    } else {\n        /*\n         * Final check before handing out ticket: If the client requires\n         * preauthentication, verify that the proper kind of\n         * preauthentication was carried out.\n         */\n        state->status = missing_required_preauth(state->client, state->server,\n                                                 &state->enc_tkt_reply);\n        if (state->status) {\n            state->preauth_err = KRB5KDC_ERR_PREAUTH_REQUIRED;\n            get_preauth_hint_list(state->request, &state->rock, &state->e_data,\n                                  finish_missing_required_preauth, state);\n            return;\n        }\n    }\n\n    finish_process_as_req(state, code);\n}\n\n/*ARGSUSED*/\nvoid\nprocess_as_req(krb5_kdc_req *request, krb5_data *req_pkt,\n               const krb5_fulladdr *local_addr,\n               const krb5_fulladdr *remote_addr, kdc_realm_t *kdc_active_realm,\n               verto_ctx *vctx, loop_respond_fn respond, void *arg)\n{\n    krb5_error_code errcode;\n    unsigned int s_flags = 0;\n    krb5_data encoded_req_body;\n    krb5_enctype useenctype;\n    struct as_req_state *state;\n    krb5_audit_state *au_state = NULL;\n\n    state = k5alloc(sizeof(*state), &errcode);\n    if (state == NULL) {\n        (*respond)(arg, errcode, NULL);\n        return;\n    }\n    state->respond = respond;\n    state->arg = arg;\n    state->request = request;\n    state->req_pkt = req_pkt;\n    state->local_addr = local_addr;\n    state->remote_addr = remote_addr;\n    state->active_realm = kdc_active_realm;\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state->rstate);\n    if (errcode != 0) {\n        (*respond)(arg, errcode, NULL);\n        free(state);\n        return;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, state->request, remote_addr,\n                               &au_state);\n    if (errcode) {\n        (*respond)(arg, errcode, NULL);\n        kdc_free_rstate(state->rstate);\n        free(state);\n        return;\n    }\n    state->au_state = au_state;\n\n    if (state->request->msg_type != KRB5_AS_REQ) {\n        state->status = \"VALIDATE_MESSAGE_TYPE\";\n        errcode = KRB5_BADMSGTYPE;\n        goto errout;\n    }\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_as_req(kdc_context, TRUE, au_state);\n\n    if (fetch_asn1_field((unsigned char *) req_pkt->data,\n                         1, 4, &encoded_req_body) != 0) {\n        errcode = ASN1_BAD_ID;\n        state->status = \"FETCH_REQ_BODY\";\n        goto errout;\n    }\n    errcode = kdc_find_fast(&state->request, &encoded_req_body, NULL, NULL,\n                            state->rstate, &state->inner_body);\n    if (errcode) {\n        state->status = \"FIND_FAST\";\n        goto errout;\n    }\n    if (state->inner_body == NULL) {\n        /* Not a FAST request; copy the encoded request body. */\n        errcode = krb5_copy_data(kdc_context, &encoded_req_body,\n                                 &state->inner_body);\n        if (errcode) {\n            state->status = \"COPY_REQ_BODY\";\n            goto errout;\n        }\n    }\n    au_state->request = state->request;\n    state->rock.request = state->request;\n    state->rock.inner_body = state->inner_body;\n    state->rock.rstate = state->rstate;\n    state->rock.vctx = vctx;\n    state->rock.auth_indicators = &state->auth_indicators;\n    if (!state->request->client) {\n        state->status = \"NULL_CLIENT\";\n        errcode = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n    if ((errcode = krb5_unparse_name(kdc_context,\n                                     state->request->client,\n                                     &state->cname))) {\n        state->status = \"UNPARSE_CLIENT\";\n        goto errout;\n    }\n    limit_string(state->cname);\n\n    if (!state->request->server) {\n        state->status = \"NULL_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n    if ((errcode = krb5_unparse_name(kdc_context,\n                                     state->request->server,\n                                     &state->sname))) {\n        state->status = \"UNPARSE_SERVER\";\n        goto errout;\n    }\n    limit_string(state->sname);\n\n    /*\n     * We set KRB5_KDB_FLAG_CLIENT_REFERRALS_ONLY as a hint\n     * to the backend to return naming information in lieu\n     * of cross realm TGS entries.\n     */\n    setflag(state->c_flags, KRB5_KDB_FLAG_CLIENT_REFERRALS_ONLY);\n    /*\n     * Note that according to the referrals draft we should\n     * always canonicalize enterprise principal names.\n     */\n    if (isflagset(state->request->kdc_options, KDC_OPT_CANONICALIZE) ||\n        state->request->client->type == KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        setflag(state->c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(state->c_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    }\n    if (include_pac_p(kdc_context, state->request)) {\n        setflag(state->c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n    }\n    errcode = krb5_db_get_principal(kdc_context, state->request->client,\n                                    state->c_flags, &state->client);\n    if (errcode == KRB5_KDB_CANTLOCK_DB)\n        errcode = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (errcode == KRB5_KDB_NOENTRY) {\n        state->status = \"CLIENT_NOT_FOUND\";\n        if (vague_errors)\n            errcode = KRB5KRB_ERR_GENERIC;\n        else\n            errcode = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        goto errout;\n    } else if (errcode) {\n        state->status = \"LOOKING_UP_CLIENT\";\n        goto errout;\n    }\n    state->rock.client = state->client;\n\n    /*\n     * If the backend returned a principal that is not in the local\n     * realm, then we need to refer the client to that realm.\n     */\n    if (!is_local_principal(kdc_active_realm, state->client->princ)) {\n        /* Entry is a referral to another realm */\n        state->status = \"REFERRAL\";\n        au_state->cl_realm = &state->client->princ->realm;\n        errcode = KRB5KDC_ERR_WRONG_REALM;\n        goto errout;\n    }\n\n    au_state->stage = SRVC_PRINC;\n\n    s_flags = 0;\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(state->request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n    errcode = krb5_db_get_principal(kdc_context, state->request->server,\n                                    s_flags, &state->server);\n    if (errcode == KRB5_KDB_CANTLOCK_DB)\n        errcode = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (errcode == KRB5_KDB_NOENTRY) {\n        state->status = \"SERVER_NOT_FOUND\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    } else if (errcode) {\n        state->status = \"LOOKING_UP_SERVER\";\n        goto errout;\n    }\n\n    errcode = get_local_tgt(kdc_context, &state->request->server->realm,\n                            state->server, &state->local_tgt,\n                            &state->local_tgt_storage);\n    if (errcode) {\n        state->status = \"GET_LOCAL_TGT\";\n        goto errout;\n    }\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &state->kdc_time))) {\n        state->status = \"TIMEOFDAY\";\n        goto errout;\n    }\n    state->authtime = state->kdc_time; /* for audit_as_request() */\n\n    if ((errcode = validate_as_request(kdc_active_realm,\n                                       state->request, *state->client,\n                                       *state->server, state->kdc_time,\n                                       &state->status, &state->e_data))) {\n        if (!state->status)\n            state->status = \"UNKNOWN_REASON\";\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto errout;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    /*\n     * Select the keytype for the ticket session key.\n     */\n    if ((useenctype = select_session_keytype(kdc_active_realm, state->server,\n                                             state->request->nktypes,\n                                             state->request->ktype)) == 0) {\n        /* unsupported ktype */\n        state->status = \"BAD_ENCRYPTION_TYPE\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto errout;\n    }\n\n    if ((errcode = krb5_c_make_random_key(kdc_context, useenctype,\n                                          &state->session_key))) {\n        state->status = \"MAKE_RANDOM_KEY\";\n        goto errout;\n    }\n\n    /*\n     * Canonicalization is only effective if we are issuing a TGT\n     * (the intention is to allow support for Windows \"short\" realm\n     * aliases, nothing more).\n     */\n    if (isflagset(s_flags, KRB5_KDB_FLAG_CANONICALIZE) &&\n        krb5_is_tgs_principal(state->request->server) &&\n        krb5_is_tgs_principal(state->server->princ)) {\n        state->ticket_reply.server = state->server->princ;\n    } else {\n        state->ticket_reply.server = state->request->server;\n    }\n\n    /* Copy options that request the corresponding ticket flags. */\n    state->enc_tkt_reply.flags = OPTS2FLAGS(state->request->kdc_options);\n    state->enc_tkt_reply.times.authtime = state->authtime;\n\n    setflag(state->enc_tkt_reply.flags, TKT_FLG_INITIAL);\n    setflag(state->enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    state->enc_tkt_reply.session = &state->session_key;\n    if (isflagset(state->c_flags, KRB5_KDB_FLAG_CANONICALIZE)) {\n        state->client_princ = *(state->client->princ);\n    } else {\n        state->client_princ = *(state->request->client);\n        /* The realm is always canonicalized */\n        state->client_princ.realm = state->client->princ->realm;\n    }\n    state->enc_tkt_reply.client = &state->client_princ;\n    state->enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    state->enc_tkt_reply.transited.tr_contents = empty_string;\n\n    if (isflagset(state->request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(state->enc_tkt_reply.flags, TKT_FLG_INVALID);\n        state->enc_tkt_reply.times.starttime = state->request->from;\n    } else\n        state->enc_tkt_reply.times.starttime = state->kdc_time;\n\n    kdc_get_ticket_endtime(kdc_active_realm,\n                           state->enc_tkt_reply.times.starttime,\n                           kdc_infinity, state->request->till, state->client,\n                           state->server, &state->enc_tkt_reply.times.endtime);\n\n    kdc_get_ticket_renewtime(kdc_active_realm, state->request, NULL,\n                             state->client, state->server,\n                             &state->enc_tkt_reply);\n\n    /*\n     * starttime is optional, and treated as authtime if not present.\n     * so we can nuke it if it matches\n     */\n    if (state->enc_tkt_reply.times.starttime ==\n        state->enc_tkt_reply.times.authtime)\n        state->enc_tkt_reply.times.starttime = 0;\n\n    state->enc_tkt_reply.caddrs = state->request->addresses;\n    state->enc_tkt_reply.authorization_data = 0;\n\n    /* If anonymous requests are being used, adjust the realm of the client\n     * principal. */\n    if (isflagset(state->request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS)) {\n        if (!krb5_principal_compare_any_realm(kdc_context,\n                                              state->request->client,\n                                              krb5_anonymous_principal())) {\n            errcode = KRB5KDC_ERR_BADOPTION;\n            /* Anonymous requested but anonymous principal not used.*/\n            state->status = \"VALIDATE_ANONYMOUS_PRINCIPAL\";\n            goto errout;\n        }\n        krb5_free_principal(kdc_context, state->request->client);\n        state->request->client = NULL;\n        errcode = krb5_copy_principal(kdc_context, krb5_anonymous_principal(),\n                                      &state->request->client);\n        if (errcode) {\n            state->status = \"COPY_ANONYMOUS_PRINCIPAL\";\n            goto errout;\n        }\n        state->enc_tkt_reply.client = state->request->client;\n        setflag(state->client->attributes, KRB5_KDB_REQUIRES_PRE_AUTH);\n    }\n\n    errcode = select_client_key(kdc_context, state->client,\n                                state->request->ktype, state->request->nktypes,\n                                &state->client_keyblock, &state->client_key);\n    if (errcode) {\n        state->status = \"DECRYPT_CLIENT_KEY\";\n        goto errout;\n    }\n    if (state->client_key != NULL) {\n        state->rock.client_key = state->client_key;\n        state->rock.client_keyblock = &state->client_keyblock;\n    }\n\n    errcode = kdc_fast_read_cookie(kdc_context, state->rstate, state->request,\n                                   state->local_tgt);\n    if (errcode) {\n        state->status = \"READ_COOKIE\";\n        goto errout;\n    }\n\n    /*\n     * Check the preauthentication if it is there.\n     */\n    if (state->request->padata) {\n        check_padata(kdc_context, &state->rock, state->req_pkt,\n                     state->request, &state->enc_tkt_reply, &state->pa_context,\n                     &state->e_data, &state->typed_e_data, finish_preauth,\n                     state);\n    } else\n        finish_preauth(state, 0);\n    return;\n\nerrout:\n    finish_process_as_req(state, errcode);\n}\n\nstatic krb5_error_code\nprepare_error_as(struct kdc_request_state *rstate, krb5_kdc_req *request,\n                 krb5_db_entry *local_tgt, int error, krb5_pa_data **e_data_in,\n                 krb5_boolean typed_e_data, krb5_principal canon_client,\n                 krb5_data **response, const char *status)\n{\n    krb5_error errpkt;\n    krb5_error_code retval;\n    krb5_data *scratch = NULL, *e_data_asn1 = NULL, *fast_edata = NULL;\n    krb5_pa_data **e_data = NULL, *cookie = NULL;\n    kdc_realm_t *kdc_active_realm = rstate->realm_data;\n    size_t count;\n\n    errpkt.magic = KV5M_ERROR;\n\n    if (e_data_in != NULL) {\n        /* Add a PA-FX-COOKIE to e_data_in.  e_data is a shallow copy\n         * containing aliases. */\n        for (count = 0; e_data_in[count] != NULL; count++);\n        e_data = calloc(count + 2, sizeof(*e_data));\n        if (e_data == NULL)\n            return ENOMEM;\n        memcpy(e_data, e_data_in, count * sizeof(*e_data));\n        retval = kdc_fast_make_cookie(kdc_context, rstate, local_tgt,\n                                      request->client, &cookie);\n        e_data[count] = cookie;\n    }\n\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    retval = krb5_us_timeofday(kdc_context, &errpkt.stime, &errpkt.susec);\n    if (retval)\n        goto cleanup;\n    errpkt.error = error;\n    errpkt.server = request->server;\n    errpkt.client = (error == KDC_ERR_WRONG_REALM) ? canon_client :\n        request->client;\n    errpkt.text = string2data((char *)status);\n\n    if (e_data != NULL) {\n        if (typed_e_data)\n            retval = encode_krb5_typed_data(e_data, &e_data_asn1);\n        else\n            retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval)\n            goto cleanup;\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(kdc_context, rstate, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval)\n        goto cleanup;\n    if (fast_edata != NULL)\n        errpkt.e_data = *fast_edata;\n\n    scratch = k5alloc(sizeof(*scratch), &retval);\n    if (scratch == NULL)\n        goto cleanup;\n    if (kdc_fast_hide_client(rstate) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    if (retval)\n        goto cleanup;\n\n    *response = scratch;\n    scratch = NULL;\n\ncleanup:\n    krb5_free_data(kdc_context, fast_edata);\n    krb5_free_data(kdc_context, e_data_asn1);\n    free(scratch);\n    free(e_data);\n    if (cookie != NULL)\n        free(cookie->contents);\n    free(cookie);\n    return retval;\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *, krb5_principal, krb5_db_entry **,\n                   const char**);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *, krb5_kdc_req *, krb5_flags, krb5_db_entry **,\n               const char **);\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *, krb5_kdc_req *, krb5_db_entry *,\n                krb5_keyblock *, const char **);\n\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *, krb5_kdc_req *, krb5_principal *);\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *, krb5_kdc_req *, krb5_flags,\n              krb5_db_entry **, const char **);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL) {\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        if (is_referral) {\n            /* The requesting server appears to no longer exist, and we found\n             * a referral instead.  Treat this as a server lookup failure. */\n            errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            status = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* Deal with user-to-user and constrained delegation */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, request->second_ticket[st_idx],\n                                  &au_state->evid_tkt_id);\n        if (retval) {\n            status = \"GENERATE_TICKET_ID\";\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract auth indicators from the subject ticket, except for S4U2Proxy\n     * requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    errcode = check_indicators(kdc_context, server, auth_indicators);\n    if (errcode) {\n        status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = OPTS2FLAGS(request->kdc_options);\n    enc_tkt_reply.flags |= COPY_TKT_FLAGS(header_enc_tkt->flags);\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /* Indicate support for encrypted padata (RFC 6806). */\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones, so just ignore the option. */\n    if (isflagset(request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS) &&\n        !isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        clear(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, header_server);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              header_server, local_tgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              header_key,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              auth_indicators,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            au_state->status = status;\n            kau_u2u(kdc_context, FALSE, au_state);\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"MAKE_S4U2SELF_PADATA\";\n            au_state->status = status;\n        }\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n    kdc_realm_t *kdc_active_realm = state->realm_data;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    if (kdc_fast_hide_client(state) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * Get the key for the second ticket, if any, and decrypt it.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n               krb5_flags flags, krb5_db_entry **server_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server = NULL;\n    krb5_keyblock *key;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    if (!(req->kdc_options & STKT_OPTIONS))\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(kdc_context, stkt,\n                                flags,\n                                TRUE, /* match_enctype */\n                                &server,\n                                &key,\n                                &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(kdc_context, key,\n                                   req->second_ticket[0]);\n    krb5_free_keyblock(kdc_context, key);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    *server_out = server;\n    server = NULL;\ncleanup:\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                   krb5_enctype *useenctype, const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                krb5_db_entry *server, krb5_keyblock *skey,\n                const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(kdc_active_realm, req, &useenctype,\n                                    status);\n        if (retval != 0)\n            goto cleanup;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(kdc_active_realm, server,\n                                            req->nktypes,\n                                            req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n    retval = krb5_c_make_random_key(kdc_context, useenctype, skey);\n    if (retval != 0) {\n        /* random key failed */\n        *status = \"MAKE_RANDOM_KEY\";\n        goto cleanup;\n    }\ncleanup:\n    return retval;\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, princ));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && *server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\n/* Return true if item is an element of the space/comma-separated list. */\nstatic krb5_boolean\nin_list(const char *list, const char *item)\n{\n    const char *p;\n    int len = strlen(item);\n\n    if (list == NULL)\n        return FALSE;\n    for (p = strstr(list, item); p != NULL; p = strstr(p + 1, item)) {\n        if ((p == list || isspace((unsigned char)p[-1]) || p[-1] == ',') &&\n            (p[len] == '\\0' || isspace((unsigned char)p[len]) ||\n             p[len] == ','))\n                return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *hostbased = kdc_active_realm->realm_hostbased;\n    char *no_referral = kdc_active_realm->realm_no_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (krb5_princ_size(kdc_context, request->server) != 2)\n        return FALSE;\n\n    stype = data2string(krb5_princ_component(kdc_context, request->server, 0));\n    if (stype == NULL)\n        return FALSE;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (!in_list(hostbased, stype) && !in_list(hostbased, \"*\"))\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (in_list(no_referral, stype) || in_list(no_referral, \"*\"))\n            goto cleanup;\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_CANONICALIZE;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/kdc_util.c - Utility functions for the KDC implementation */\n/*\n * Copyright 1990,1991,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n#include \"kdc_util.h\"\n#include \"extern.h\"\n#include <stdio.h>\n#include <ctype.h>\n#include <syslog.h>\n#include <kadm5/admin.h>\n#include \"adm_proto.h\"\n#include \"net-server.h\"\n#include <limits.h>\n\n#ifdef KRBCONF_VAGUE_ERRORS\nconst int vague_errors = 1;\n#else\nconst int vague_errors = 0;\n#endif\n\nstatic krb5_error_code kdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n                                     krb5_ap_req *apreq,\n                                     krb5_auth_context auth_context,\n                                     krb5_db_entry **server,\n                                     krb5_keyblock **tgskey);\nstatic krb5_error_code find_server_key(krb5_context,\n                                       krb5_db_entry *, krb5_enctype,\n                                       krb5_kvno, krb5_keyblock **,\n                                       krb5_kvno *);\n\n/*\n * concatenate first two authdata arrays, returning an allocated replacement.\n * The replacement should be freed with krb5_free_authdata().\n */\nkrb5_error_code\nconcat_authorization_data(krb5_context context,\n                          krb5_authdata **first, krb5_authdata **second,\n                          krb5_authdata ***output)\n{\n    register int i, j;\n    register krb5_authdata **ptr, **retdata;\n\n    /* count up the entries */\n    i = 0;\n    if (first)\n        for (ptr = first; *ptr; ptr++)\n            i++;\n    if (second)\n        for (ptr = second; *ptr; ptr++)\n            i++;\n\n    retdata = (krb5_authdata **)malloc((i+1)*sizeof(*retdata));\n    if (!retdata)\n        return ENOMEM;\n    retdata[i] = 0;                     /* null-terminated array */\n    for (i = 0, j = 0, ptr = first; j < 2 ; ptr = second, j++)\n        while (ptr && *ptr) {\n            /* now walk & copy */\n            retdata[i] = (krb5_authdata *)malloc(sizeof(*retdata[i]));\n            if (!retdata[i]) {\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            *retdata[i] = **ptr;\n            if (!(retdata[i]->contents =\n                  (krb5_octet *)malloc(retdata[i]->length))) {\n                free(retdata[i]);\n                retdata[i] = 0;\n                krb5_free_authdata(context, retdata);\n                return ENOMEM;\n            }\n            memcpy(retdata[i]->contents, (*ptr)->contents, retdata[i]->length);\n\n            ptr++;\n            i++;\n        }\n    *output = retdata;\n    return 0;\n}\n\nkrb5_boolean\nis_local_principal(kdc_realm_t *kdc_active_realm, krb5_const_principal princ1)\n{\n    return krb5_realm_compare(kdc_context, princ1, tgs_server);\n}\n\n/*\n * Returns TRUE if the kerberos principal is the name of a Kerberos ticket\n * service.\n */\nkrb5_boolean\nkrb5_is_tgs_principal(krb5_const_principal principal)\n{\n    if (krb5_princ_size(kdc_context, principal) != 2)\n        return FALSE;\n    if (data_eq_string(*krb5_princ_component(kdc_context, principal, 0),\n                       KRB5_TGS_NAME))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/* Returns TRUE if principal is the name of a cross-realm TGS. */\nkrb5_boolean\nis_cross_tgs_principal(krb5_const_principal principal)\n{\n    if (!krb5_is_tgs_principal(principal))\n        return FALSE;\n    if (!data_eq(*krb5_princ_component(kdc_context, principal, 1),\n                 *krb5_princ_realm(kdc_context, principal)))\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/*\n * given authentication data (provides seed for checksum), verify checksum\n * for source data.\n */\nstatic krb5_error_code\ncomp_cksum(krb5_context kcontext, krb5_data *source, krb5_ticket *ticket,\n           krb5_checksum *his_cksum)\n{\n    krb5_error_code       retval;\n    krb5_boolean          valid;\n\n    if (!krb5_c_valid_cksumtype(his_cksum->checksum_type))\n        return KRB5KDC_ERR_SUMTYPE_NOSUPP;\n\n    /* must be collision proof */\n    if (!krb5_c_is_coll_proof_cksum(his_cksum->checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    /* verify checksum */\n    if ((retval = krb5_c_verify_checksum(kcontext, ticket->enc_part2->session,\n                                         KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,\n                                         source, his_cksum, &valid)))\n        return(retval);\n\n    if (!valid)\n        return(KRB5KRB_AP_ERR_BAD_INTEGRITY);\n\n    return(0);\n}\n\n/* If a header ticket is decrypted, *ticket_out is filled in even on error. */\nkrb5_error_code\nkdc_process_tgs_req(kdc_realm_t *kdc_active_realm,\n                    krb5_kdc_req *request, const krb5_fulladdr *from,\n                    krb5_data *pkt, krb5_ticket **ticket_out,\n                    krb5_db_entry **krbtgt_ptr,\n                    krb5_keyblock **tgskey,\n                    krb5_keyblock **subkey,\n                    krb5_pa_data **pa_tgs_req)\n{\n    krb5_pa_data        * tmppa;\n    krb5_ap_req         * apreq;\n    krb5_error_code       retval;\n    krb5_authdata **authdata = NULL;\n    krb5_data             scratch1;\n    krb5_data           * scratch = NULL;\n    krb5_boolean          foreign_server = FALSE;\n    krb5_auth_context     auth_context = NULL;\n    krb5_authenticator  * authenticator = NULL;\n    krb5_checksum       * his_cksum = NULL;\n    krb5_db_entry       * krbtgt = NULL;\n    krb5_ticket         * ticket;\n\n    *ticket_out = NULL;\n    *krbtgt_ptr = NULL;\n    *tgskey = NULL;\n\n    tmppa = krb5int_find_pa_data(kdc_context,\n                                 request->padata, KRB5_PADATA_AP_REQ);\n    if (!tmppa)\n        return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    scratch1.length = tmppa->length;\n    scratch1.data = (char *)tmppa->contents;\n    if ((retval = decode_krb5_ap_req(&scratch1, &apreq)))\n        return retval;\n    ticket = apreq->ticket;\n\n    if (isflagset(apreq->ap_options, AP_OPTS_USE_SESSION_KEY) ||\n        isflagset(apreq->ap_options, AP_OPTS_MUTUAL_REQUIRED)) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ: SESSION KEY or MUTUAL\"));\n        retval = KRB5KDC_ERR_POLICY;\n        goto cleanup;\n    }\n\n    /* If the \"server\" principal in the ticket is not something\n       in the local realm, then we must refuse to service the request\n       if the client claims to be from the local realm.\n\n       If we don't do this, then some other realm's nasty KDC can\n       claim to be authenticating a client from our realm, and we'll\n       give out tickets concurring with it!\n\n       we set a flag here for checking below.\n    */\n    foreign_server = !is_local_principal(kdc_active_realm,\n                                         apreq->ticket->server);\n\n    if ((retval = krb5_auth_con_init(kdc_context, &auth_context)))\n        goto cleanup;\n\n    /* Don't use a replay cache. */\n    if ((retval = krb5_auth_con_setflags(kdc_context, auth_context, 0)))\n        goto cleanup;\n\n    if ((retval = krb5_auth_con_setaddrs(kdc_context, auth_context, NULL,\n                                         from->address)) )\n        goto cleanup_auth_context;\n\n    retval = kdc_rd_ap_req(kdc_active_realm,\n                           apreq, auth_context, &krbtgt, tgskey);\n    if (retval)\n        goto cleanup_auth_context;\n\n    /* \"invalid flag\" tickets can must be used to validate */\n    if (isflagset(ticket->enc_part2->flags, TKT_FLG_INVALID) &&\n        !isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        retval = KRB5KRB_AP_ERR_TKT_INVALID;\n        goto cleanup_auth_context;\n    }\n\n    if ((retval = krb5_auth_con_getrecvsubkey(kdc_context,\n                                              auth_context, subkey)))\n        goto cleanup_auth_context;\n\n    if ((retval = krb5_auth_con_getauthenticator(kdc_context, auth_context,\n                                                 &authenticator)))\n        goto cleanup_auth_context;\n\n    retval = krb5_find_authdata(kdc_context,\n                                ticket->enc_part2->authorization_data,\n                                authenticator->authorization_data,\n                                KRB5_AUTHDATA_FX_ARMOR, &authdata);\n    if (retval != 0)\n        goto cleanup_authenticator;\n    if (authdata&& authdata[0]) {\n        k5_setmsg(kdc_context, KRB5KDC_ERR_POLICY,\n                  \"ticket valid only as FAST armor\");\n        retval = KRB5KDC_ERR_POLICY;\n        krb5_free_authdata(kdc_context, authdata);\n        goto cleanup_authenticator;\n    }\n    krb5_free_authdata(kdc_context, authdata);\n\n\n    /* Check for a checksum */\n    if (!(his_cksum = authenticator->checksum)) {\n        retval = KRB5KRB_AP_ERR_INAPP_CKSUM;\n        goto cleanup_authenticator;\n    }\n\n    /* make sure the client is of proper lineage (see above) */\n    if (foreign_server &&\n        !krb5int_find_pa_data(kdc_context,\n                              request->padata, KRB5_PADATA_FOR_USER)) {\n        if (is_local_principal(kdc_active_realm,\n                               ticket->enc_part2->client)) {\n            /* someone in a foreign realm claiming to be local */\n            krb5_klog_syslog(LOG_INFO, _(\"PROCESS_TGS: failed lineage check\"));\n            retval = KRB5KDC_ERR_POLICY;\n            goto cleanup_authenticator;\n        }\n    }\n\n    /*\n     * Check application checksum vs. tgs request\n     *\n     * We try checksumming the req-body two different ways: first we\n     * try reaching into the raw asn.1 stream (if available), and\n     * checksum that directly; if that fails, then we try encoding\n     * using our local asn.1 library.\n     */\n    if (pkt && (fetch_asn1_field((unsigned char *) pkt->data,\n                                 1, 4, &scratch1) >= 0)) {\n        if (comp_cksum(kdc_context, &scratch1, ticket, his_cksum)) {\n            if (!(retval = encode_krb5_kdc_req_body(request, &scratch)))\n                retval = comp_cksum(kdc_context, scratch, ticket, his_cksum);\n            krb5_free_data(kdc_context, scratch);\n            if (retval)\n                goto cleanup_authenticator;\n        }\n    }\n\n    *pa_tgs_req = tmppa;\n    *krbtgt_ptr = krbtgt;\n    krbtgt = NULL;\n\ncleanup_authenticator:\n    krb5_free_authenticator(kdc_context, authenticator);\n\ncleanup_auth_context:\n    krb5_auth_con_free(kdc_context, auth_context);\n\ncleanup:\n    if (retval != 0) {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        *tgskey = NULL;\n    }\n    if (apreq->ticket->enc_part2 != NULL) {\n        /* Steal the decrypted ticket pointer, even on error. */\n        *ticket_out = apreq->ticket;\n        apreq->ticket = NULL;\n    }\n    krb5_free_ap_req(kdc_context, apreq);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    return retval;\n}\n\n/*\n * This is a KDC wrapper around krb5_rd_req_decoded_anyflag().\n *\n * We can't depend on KDB-as-keytab for handling the AP-REQ here for\n * optimization reasons: we want to minimize the number of KDB lookups.  We'll\n * need the KDB entry for the TGS principal, and the TGS key used to decrypt\n * the TGT, elsewhere in the TGS code.\n *\n * This function also implements key rollover support for kvno 0 cross-realm\n * TGTs issued by AD.\n */\nstatic\nkrb5_error_code\nkdc_rd_ap_req(kdc_realm_t *kdc_active_realm,\n              krb5_ap_req *apreq, krb5_auth_context auth_context,\n              krb5_db_entry **server, krb5_keyblock **tgskey)\n{\n    krb5_error_code     retval;\n    krb5_enctype        search_enctype = apreq->ticket->enc_part.enctype;\n    krb5_boolean        match_enctype = 1;\n    krb5_kvno           kvno;\n    size_t              tries = 3;\n\n    /*\n     * When we issue tickets we use the first key in the principals' highest\n     * kvno keyset.  For non-cross-realm krbtgt principals we want to only\n     * allow the use of the first key of the principal's keyset that matches\n     * the given kvno.\n     */\n    if (krb5_is_tgs_principal(apreq->ticket->server) &&\n        !is_cross_tgs_principal(apreq->ticket->server)) {\n        search_enctype = -1;\n        match_enctype = 0;\n    }\n\n    retval = kdc_get_server_key(kdc_context, apreq->ticket,\n                                KRB5_KDB_FLAG_ALIAS_OK, match_enctype, server,\n                                NULL, NULL);\n    if (retval)\n        return retval;\n\n    *tgskey = NULL;\n    kvno = apreq->ticket->enc_part.kvno;\n    do {\n        krb5_free_keyblock(kdc_context, *tgskey);\n        retval = find_server_key(kdc_context,\n                                 *server, search_enctype, kvno, tgskey, &kvno);\n        if (retval)\n            continue;\n\n        /* Make the TGS key available to krb5_rd_req_decoded_anyflag() */\n        retval = krb5_auth_con_setuseruserkey(kdc_context, auth_context,\n                                              *tgskey);\n        if (retval)\n            return retval;\n\n        retval = krb5_rd_req_decoded_anyflag(kdc_context, &auth_context, apreq,\n                                             apreq->ticket->server,\n                                             kdc_active_realm->realm_keytab,\n                                             NULL, NULL);\n\n        /* If the ticket was decrypted, don't try any more keys. */\n        if (apreq->ticket->enc_part2 != NULL)\n            break;\n\n    } while (retval && apreq->ticket->enc_part.kvno == 0 && kvno-- > 1 &&\n             --tries > 0);\n\n    return retval;\n}\n\n/*\n * The KDC should take the keytab associated with the realm and pass\n * that to the krb5_rd_req_decoded_anyflag(), but we still need to use\n * the service (TGS, here) key elsewhere.  This approach is faster than\n * the KDB keytab approach too.\n *\n * This is also used by do_tgs_req() for u2u auth.\n */\nkrb5_error_code\nkdc_get_server_key(krb5_context context,\n                   krb5_ticket *ticket, unsigned int flags,\n                   krb5_boolean match_enctype, krb5_db_entry **server_ptr,\n                   krb5_keyblock **key, krb5_kvno *kvno)\n{\n    krb5_error_code       retval;\n    krb5_db_entry       * server = NULL;\n    krb5_enctype          search_enctype = -1;\n    krb5_kvno             search_kvno = -1;\n\n    if (match_enctype)\n        search_enctype = ticket->enc_part.enctype;\n    if (ticket->enc_part.kvno)\n        search_kvno = ticket->enc_part.kvno;\n\n    *server_ptr = NULL;\n\n    retval = krb5_db_get_principal(context, ticket->server, flags,\n                                   &server);\n    if (retval == KRB5_KDB_NOENTRY) {\n        char *sname;\n        if (!krb5_unparse_name(context, ticket->server, &sname)) {\n            limit_string(sname);\n            krb5_klog_syslog(LOG_ERR,\n                             _(\"TGS_REQ: UNKNOWN SERVER: server='%s'\"), sname);\n            free(sname);\n        }\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    } else if (retval)\n        return retval;\n    if (server->attributes & KRB5_KDB_DISALLOW_SVR ||\n        server->attributes & KRB5_KDB_DISALLOW_ALL_TIX) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto errout;\n    }\n\n    if (key) {\n        retval = find_server_key(context, server, search_enctype, search_kvno,\n                                 key, kvno);\n        if (retval)\n            goto errout;\n    }\n    *server_ptr = server;\n    server = NULL;\n    return 0;\n\nerrout:\n    krb5_db_free_principal(context, server);\n    return retval;\n}\n\n/*\n * A utility function to get the right key from a KDB entry.  Used in handling\n * of kvno 0 TGTs, for example.\n */\nstatic\nkrb5_error_code\nfind_server_key(krb5_context context,\n                krb5_db_entry *server, krb5_enctype enctype, krb5_kvno kvno,\n                krb5_keyblock **key_out, krb5_kvno *kvno_out)\n{\n    krb5_error_code       retval;\n    krb5_key_data       * server_key;\n    krb5_keyblock       * key;\n\n    *key_out = NULL;\n    retval = krb5_dbe_find_enctype(context, server, enctype, -1,\n                                   kvno ? (krb5_int32)kvno : -1, &server_key);\n    if (retval)\n        return retval;\n    if (!server_key)\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    if ((key = (krb5_keyblock *)malloc(sizeof *key)) == NULL)\n        return ENOMEM;\n    retval = krb5_dbe_decrypt_key_data(context, NULL, server_key,\n                                       key, NULL);\n    if (retval)\n        goto errout;\n    if (enctype != -1) {\n        krb5_boolean similar;\n        retval = krb5_c_enctype_compare(context, enctype, key->enctype,\n                                        &similar);\n        if (retval)\n            goto errout;\n        if (!similar) {\n            retval = KRB5_KDB_NO_PERMITTED_KEY;\n            goto errout;\n        }\n        key->enctype = enctype;\n    }\n    *key_out = key;\n    key = NULL;\n    if (kvno_out)\n        *kvno_out = server_key->key_data_kvno;\nerrout:\n    krb5_free_keyblock(context, key);\n    return retval;\n}\n\n/*\n * If candidate is the local TGT for realm, set *alias_out to candidate and\n * *storage_out to NULL.  Otherwise, load the local TGT into *storage_out and\n * set *alias_out to *storage_out.\n *\n * In the future we might generalize this to a small per-request principal\n * cache.  For now, it saves a load operation in the common case where the AS\n * server or TGS header ticket server is the local TGT.\n */\nkrb5_error_code\nget_local_tgt(krb5_context context, const krb5_data *realm,\n              krb5_db_entry *candidate, krb5_db_entry **alias_out,\n              krb5_db_entry **storage_out)\n{\n    krb5_error_code ret;\n    krb5_principal princ;\n    krb5_db_entry *tgt;\n\n    *alias_out = NULL;\n    *storage_out = NULL;\n\n    ret = krb5_build_principal_ext(context, &princ, realm->length, realm->data,\n                                   KRB5_TGS_NAME_SIZE, KRB5_TGS_NAME,\n                                   realm->length, realm->data, 0);\n    if (ret)\n        return ret;\n\n    if (!krb5_principal_compare(context, candidate->princ, princ)) {\n        ret = krb5_db_get_principal(context, princ, 0, &tgt);\n        if (!ret)\n            *storage_out = *alias_out = tgt;\n    } else {\n        *alias_out = candidate;\n    }\n\n    krb5_free_principal(context, princ);\n    return ret;\n}\n\n/* This probably wants to be updated if you support last_req stuff */\n\nstatic krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\nstatic krb5_last_req_entry *nolrarray[] = { &nolrentry, 0 };\n\nkrb5_error_code\nfetch_last_req_info(krb5_db_entry *dbentry, krb5_last_req_entry ***lrentry)\n{\n    *lrentry = nolrarray;\n    return 0;\n}\n\n\n/* XXX!  This is a temporary place-holder */\n\nkrb5_error_code\ncheck_hot_list(krb5_ticket *ticket)\n{\n    return 0;\n}\n\n\n/* Convert an API error code to a protocol error code. */\nint\nerrcode_to_protocol(krb5_error_code code)\n{\n    int protcode;\n\n    protcode = code - ERROR_TABLE_BASE_krb5;\n    return (protcode >= 0 && protcode <= 128) ? protcode : KRB_ERR_GENERIC;\n}\n\n/* Return -1 if the AS or TGS request is disallowed due to KDC policy on\n * anonymous tickets. */\nint\ncheck_anon(kdc_realm_t *kdc_active_realm,\n           krb5_principal client, krb5_principal server)\n{\n    /* If restrict_anon is set, reject requests from anonymous to principals\n     * other than the local TGT. */\n    if (kdc_active_realm->realm_restrict_anon &&\n        krb5_principal_compare_any_realm(kdc_context, client,\n                                         krb5_anonymous_principal()) &&\n        !krb5_principal_compare(kdc_context, server, tgs_server))\n        return -1;\n    return 0;\n}\n\n/*\n * Routines that validate a AS request; checks a lot of things.  :-)\n *\n * Returns a Kerberos protocol error number, which is _not_ the same\n * as a com_err error number!\n */\n#define AS_INVALID_OPTIONS (KDC_OPT_FORWARDED | KDC_OPT_PROXY |         \\\n                            KDC_OPT_VALIDATE | KDC_OPT_RENEW |          \\\n                            KDC_OPT_ENC_TKT_IN_SKEY | KDC_OPT_CNAME_IN_ADDL_TKT)\nint\nvalidate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && ts_after(kdc_time, client.expiration)) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && ts_after(kdc_time, client.pw_expiration) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && ts_after(kdc_time, server.expiration)) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}\n\nint\nvalidate_forwardable(krb5_kdc_req *request, krb5_db_entry client,\n                     krb5_db_entry server, krb5_timestamp kdc_time,\n                     const char **status)\n{\n    *status = NULL;\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_FORWARDABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_FORWARDABLE))) {\n        *status = \"FORWARDABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    } else\n        return 0;\n}\n\n/* Return KRB5KDC_ERR_POLICY if indicators does not contain the required auth\n * indicators for server, ENOMEM on allocation error, 0 otherwise. */\nkrb5_error_code\ncheck_indicators(krb5_context context, krb5_db_entry *server,\n                 krb5_data *const *indicators)\n{\n    krb5_error_code ret;\n    char *str = NULL, *copy = NULL, *save, *ind;\n\n    ret = krb5_dbe_get_string(context, server, KRB5_KDB_SK_REQUIRE_AUTH, &str);\n    if (ret || str == NULL)\n        goto cleanup;\n    copy = strdup(str);\n    if (copy == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Look for any of the space-separated strings in indicators. */\n    ind = strtok_r(copy, \" \", &save);\n    while (ind != NULL) {\n        if (authind_contains(indicators, ind))\n            goto cleanup;\n        ind = strtok_r(NULL, \" \", &save);\n    }\n\n    ret = KRB5KDC_ERR_POLICY;\n    k5_setmsg(context, ret,\n              _(\"Required auth indicators not present in ticket: %s\"), str);\n\ncleanup:\n    krb5_dbe_free_string(context, str);\n    free(copy);\n    return ret;\n}\n\n#define ASN1_ID_CLASS   (0xc0)\n#define ASN1_ID_TYPE    (0x20)\n#define ASN1_ID_TAG     (0x1f)\n#define ASN1_CLASS_UNIV (0)\n#define ASN1_CLASS_APP  (1)\n#define ASN1_CLASS_CTX  (2)\n#define ASN1_CLASS_PRIV (3)\n#define asn1_id_constructed(x)  (x & ASN1_ID_TYPE)\n#define asn1_id_primitive(x)    (!asn1_id_constructed(x))\n#define asn1_id_class(x)        ((x & ASN1_ID_CLASS) >> 6)\n#define asn1_id_tag(x)          (x & ASN1_ID_TAG)\n\n/*\n * asn1length - return encoded length of value.\n *\n * passed a pointer into the asn.1 stream, which is updated\n * to point right after the length bits.\n *\n * returns -1 on failure.\n */\nstatic int\nasn1length(unsigned char **astream)\n{\n    int length;         /* resulting length */\n    int sublen;         /* sublengths */\n    int blen;           /* bytes of length */\n    unsigned char *p;   /* substring searching */\n\n    if (**astream & 0x80) {\n        blen = **astream & 0x7f;\n        if (blen > 3) {\n            return(-1);\n        }\n        for (++*astream, length = 0; blen; ++*astream, blen--) {\n            length = (length << 8) | **astream;\n        }\n        if (length == 0) {\n            /* indefinite length, figure out by hand */\n            p = *astream;\n            p++;\n            while (1) {\n                /* compute value length. */\n                if ((sublen = asn1length(&p)) < 0) {\n                    return(-1);\n                }\n                p += sublen;\n                /* check for termination */\n                if ((!*p++) && (!*p)) {\n                    p++;\n                    break;\n                }\n            }\n            length = p - *astream;\n        }\n    } else {\n        length = **astream;\n        ++*astream;\n    }\n    return(length);\n}\n\n/*\n * fetch_asn1_field - return raw asn.1 stream of subfield.\n *\n * this routine is passed a context-dependent tag number and \"level\" and returns\n * the size and length of the corresponding level subfield.\n *\n * levels and are numbered starting from 1.\n *\n * returns 0 on success, -1 otherwise.\n */\nint\nfetch_asn1_field(unsigned char *astream, unsigned int level,\n                 unsigned int field, krb5_data *data)\n{\n    unsigned char *estream;     /* end of stream */\n    int classes;                /* # classes seen so far this level */\n    unsigned int levels = 0;            /* levels seen so far */\n    int lastlevel = 1000;       /* last level seen */\n    int length;                 /* various lengths */\n    int tag;                    /* tag number */\n    unsigned char savelen;      /* saved length of our field */\n\n    classes = -1;\n    /* we assume that the first identifier/length will tell us\n       how long the entire stream is. */\n    astream++;\n    estream = astream;\n    if ((length = asn1length(&astream)) < 0) {\n        return(-1);\n    }\n    estream += length;\n    /* search down the stream, checking identifiers.  we process identifiers\n       until we hit the \"level\" we want, and then process that level for our\n       subfield, always making sure we don't go off the end of the stream.  */\n    while (astream < estream) {\n        if (!asn1_id_constructed(*astream)) {\n            return(-1);\n        }\n        if (asn1_id_class(*astream) == ASN1_CLASS_CTX) {\n            if ((tag = (int)asn1_id_tag(*astream)) <= lastlevel) {\n                levels++;\n                classes = -1;\n            }\n            lastlevel = tag;\n            if (levels == level) {\n                /* in our context-dependent class, is this the one we're looking for ? */\n                if (tag == (int)field) {\n                    /* return length and data */\n                    astream++;\n                    savelen = *astream;\n                    if ((length = asn1length(&astream)) < 0) {\n                        return(-1);\n                    }\n                    data->length = length;\n                    /* if the field length is indefinite, we will have to subtract two\n                       (terminating octets) from the length returned since we don't want\n                       to pass any info from the \"wrapper\" back.  asn1length will always return\n                       the *total* length of the field, not just what's contained in it */\n                    if ((savelen & 0xff) == 0x80) {\n                        data->length -=2 ;\n                    }\n                    data->data = (char *)astream;\n                    return(0);\n                } else if (tag <= classes) {\n                    /* we've seen this class before, something must be wrong */\n                    return(-1);\n                } else {\n                    classes = tag;\n                }\n            }\n        }\n        /* if we're not on our level yet, process this value.  otherwise skip over it */\n        astream++;\n        if ((length = asn1length(&astream)) < 0) {\n            return(-1);\n        }\n        if (levels == level) {\n            astream += length;\n        }\n    }\n    return(-1);\n}\n\n/* Return true if we believe server can support enctype as a session key. */\nstatic krb5_boolean\ndbentry_supports_enctype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                         krb5_enctype enctype)\n{\n    krb5_error_code     retval;\n    krb5_key_data       *datap;\n    char                *etypes_str = NULL;\n    krb5_enctype        default_enctypes[1] = { 0 };\n    krb5_enctype        *etypes = NULL;\n    krb5_boolean        in_list;\n\n    /* Look up the supported session key enctypes list in the KDB. */\n    retval = krb5_dbe_get_string(kdc_context, server,\n                                 KRB5_KDB_SK_SESSION_ENCTYPES,\n                                 &etypes_str);\n    if (retval == 0 && etypes_str != NULL && *etypes_str != '\\0') {\n        /* Pass a fake profile key for tracing of unrecognized tokens. */\n        retval = krb5int_parse_enctype_list(kdc_context, \"KDB-session_etypes\",\n                                            etypes_str, default_enctypes,\n                                            &etypes);\n        if (retval == 0 && etypes != NULL && etypes[0]) {\n            in_list = k5_etypes_contains(etypes, enctype);\n            free(etypes_str);\n            free(etypes);\n            return in_list;\n        }\n        /* Fall through on error or empty list */\n    }\n    free(etypes_str);\n    free(etypes);\n\n    /* If configured to, assume every server without a session_enctypes\n     * attribute supports DES_CBC_CRC. */\n    if (kdc_active_realm->realm_assume_des_crc_sess &&\n        enctype == ENCTYPE_DES_CBC_CRC)\n        return TRUE;\n\n    /* Due to an ancient interop problem, assume nothing supports des-cbc-md5\n     * unless there's a session_enctypes explicitly saying that it does. */\n    if (enctype == ENCTYPE_DES_CBC_MD5)\n        return FALSE;\n\n    /* Assume the server supports any enctype it has a long-term key for. */\n    return !krb5_dbe_find_enctype(kdc_context, server, enctype, -1, 0, &datap);\n}\n\n/*\n * This function returns the keytype which should be selected for the\n * session key.  It is based on the ordered list which the user\n * requested, and what the KDC and the application server can support.\n */\nkrb5_enctype\nselect_session_keytype(kdc_realm_t *kdc_active_realm, krb5_db_entry *server,\n                       int nktypes, krb5_enctype *ktype)\n{\n    int         i;\n\n    for (i = 0; i < nktypes; i++) {\n        if (!krb5_c_valid_enctype(ktype[i]))\n            continue;\n\n        if (!krb5_is_permitted_enctype(kdc_context, ktype[i]))\n            continue;\n\n        if (dbentry_supports_enctype(kdc_active_realm, server, ktype[i]))\n            return ktype[i];\n    }\n\n    return 0;\n}\n\n/*\n * Limit strings to a \"reasonable\" length to prevent crowding out of\n * other useful information in the log entry\n */\n#define NAME_LENGTH_LIMIT 128\n\nvoid limit_string(char *name)\n{\n    int     i;\n\n    if (!name)\n        return;\n\n    if (strlen(name) < NAME_LENGTH_LIMIT)\n        return;\n\n    i = NAME_LENGTH_LIMIT-4;\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i++] = '.';\n    name[i] = '\\0';\n    return;\n}\n\n/*\n * L10_2 = log10(2**x), rounded up; log10(2) ~= 0.301.\n */\n#define L10_2(x) ((int)(((x * 301) + 999) / 1000))\n\n/*\n * Max length of sprintf(\"%ld\") for an int of type T; includes leading\n * minus sign and terminating NUL.\n */\n#define D_LEN(t) (L10_2(sizeof(t) * CHAR_BIT) + 2)\n\nvoid\nktypes2str(char *s, size_t len, int nktypes, krb5_enctype *ktype)\n{\n    int i;\n    char stmp[D_LEN(krb5_enctype) + 1];\n    char *p;\n\n    if (nktypes < 0\n        || len < (sizeof(\" etypes {...}\") + D_LEN(int))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"%d etypes {\", nktypes);\n    for (i = 0; i < nktypes; i++) {\n        snprintf(stmp, sizeof(stmp), \"%s%ld\", i ? \" \" : \"\", (long)ktype[i]);\n        if (strlen(s) + strlen(stmp) + sizeof(\"}\") > len)\n            break;\n        strlcat(s, stmp, len);\n    }\n    if (i < nktypes) {\n        /*\n         * We broke out of the loop. Try to truncate the list.\n         */\n        p = s + strlen(s);\n        while (p - s + sizeof(\"...}\") > len) {\n            while (p > s && *p != ' ' && *p != '{')\n                *p-- = '\\0';\n            if (p > s && *p == ' ') {\n                *p-- = '\\0';\n                continue;\n            }\n        }\n        strlcat(s, \"...\", len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nvoid\nrep_etypes2str(char *s, size_t len, krb5_kdc_rep *rep)\n{\n    char stmp[sizeof(\"ses=\") + D_LEN(krb5_enctype)];\n\n    if (len < (3 * D_LEN(krb5_enctype)\n               + sizeof(\"etypes {rep= tkt= ses=}\"))) {\n        *s = '\\0';\n        return;\n    }\n\n    snprintf(s, len, \"etypes {rep=%ld\", (long)rep->enc_part.enctype);\n\n    if (rep->ticket != NULL) {\n        snprintf(stmp, sizeof(stmp),\n                 \" tkt=%ld\", (long)rep->ticket->enc_part.enctype);\n        strlcat(s, stmp, len);\n    }\n\n    if (rep->ticket != NULL\n        && rep->ticket->enc_part2 != NULL\n        && rep->ticket->enc_part2->session != NULL) {\n        snprintf(stmp, sizeof(stmp), \" ses=%ld\",\n                 (long)rep->ticket->enc_part2->session->enctype);\n        strlcat(s, stmp, len);\n    }\n    strlcat(s, \"}\", len);\n    return;\n}\n\nstatic krb5_error_code\nverify_for_user_checksum(krb5_context context,\n                         krb5_keyblock *key,\n                         krb5_pa_for_user *req)\n{\n    krb5_error_code             code;\n    int                         i;\n    krb5_int32                  name_type;\n    char                        *p;\n    krb5_data                   data;\n    krb5_boolean                valid = FALSE;\n\n    if (!krb5_c_is_keyed_cksum(req->cksum.checksum_type)) {\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n    }\n\n    /*\n     * Checksum is over name type and string components of\n     * client principal name and auth_package.\n     */\n    data.length = 4;\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        data.length += krb5_princ_component(context, req->user, i)->length;\n    }\n    data.length += krb5_princ_realm(context, req->user)->length;\n    data.length += req->auth_package.length;\n\n    p = data.data = malloc(data.length);\n    if (data.data == NULL) {\n        return ENOMEM;\n    }\n\n    name_type = krb5_princ_type(context, req->user);\n    p[0] = (name_type >> 0 ) & 0xFF;\n    p[1] = (name_type >> 8 ) & 0xFF;\n    p[2] = (name_type >> 16) & 0xFF;\n    p[3] = (name_type >> 24) & 0xFF;\n    p += 4;\n\n    for (i = 0; i < krb5_princ_size(context, req->user); i++) {\n        if (krb5_princ_component(context, req->user, i)->length > 0) {\n            memcpy(p, krb5_princ_component(context, req->user, i)->data,\n                   krb5_princ_component(context, req->user, i)->length);\n        }\n        p += krb5_princ_component(context, req->user, i)->length;\n    }\n\n    if (krb5_princ_realm(context, req->user)->length > 0) {\n        memcpy(p, krb5_princ_realm(context, req->user)->data,\n               krb5_princ_realm(context, req->user)->length);\n    }\n    p += krb5_princ_realm(context, req->user)->length;\n\n    if (req->auth_package.length > 0)\n        memcpy(p, req->auth_package.data, req->auth_package.length);\n    p += req->auth_package.length;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_APP_DATA_CKSUM,\n                                  &data,\n                                  &req->cksum,\n                                  &valid);\n\n    if (code == 0 && valid == FALSE)\n        code = KRB5KRB_AP_ERR_MODIFIED;\n\n    free(data.data);\n\n    return code;\n}\n\n/*\n * Legacy protocol transition (Windows 2003 and above)\n */\nstatic krb5_error_code\nkdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code) {\n        *status = \"DECODE_PA_FOR_USER\";\n        return code;\n    }\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}\n\nstatic krb5_error_code\nverify_s4u_x509_user_checksum(krb5_context context,\n                              krb5_keyblock *key,\n                              krb5_data *req_data,\n                              krb5_int32 kdc_req_nonce,\n                              krb5_pa_s4u_x509_user *req)\n{\n    krb5_error_code             code;\n    krb5_data                   scratch;\n    krb5_boolean                valid = FALSE;\n\n    if (enctype_requires_etype_info_2(key->enctype) &&\n        !krb5_c_is_keyed_cksum(req->cksum.checksum_type))\n        return KRB5KRB_AP_ERR_INAPP_CKSUM;\n\n    if (req->user_id.nonce != kdc_req_nonce)\n        return KRB5KRB_AP_ERR_MODIFIED;\n\n    /*\n     * Verify checksum over the encoded userid. If that fails,\n     * re-encode, and verify that. This is similar to the\n     * behaviour in kdc_process_tgs_req().\n     */\n    if (fetch_asn1_field((unsigned char *)req_data->data, 1, 0, &scratch) < 0)\n        return ASN1_PARSE_ERROR;\n\n    code = krb5_c_verify_checksum(context,\n                                  key,\n                                  KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                  &scratch,\n                                  &req->cksum,\n                                  &valid);\n    if (code != 0)\n        return code;\n\n    if (valid == FALSE) {\n        krb5_data *data;\n\n        code = encode_krb5_s4u_userid(&req->user_id, &data);\n        if (code != 0)\n            return code;\n\n        code = krb5_c_verify_checksum(context,\n                                      key,\n                                      KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST,\n                                      data,\n                                      &req->cksum,\n                                      &valid);\n\n        krb5_free_data(context, data);\n\n        if (code != 0)\n            return code;\n    }\n\n    return valid ? 0 : KRB5KRB_AP_ERR_MODIFIED;\n}\n\n/*\n * New protocol transition request (Windows 2008 and above)\n */\nstatic krb5_error_code\nkdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code) {\n        *status = \"DECODE_PA_S4U_X509_USER\";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_make_s4u2self_rep(krb5_context context,\n                      krb5_keyblock *tgs_subkey,\n                      krb5_keyblock *tgs_session,\n                      krb5_pa_s4u_x509_user *req_s4u_user,\n                      krb5_kdc_rep *reply,\n                      krb5_enc_kdc_rep_part *reply_encpart)\n{\n    krb5_error_code             code;\n    krb5_data                   *data = NULL;\n    krb5_pa_s4u_x509_user       rep_s4u_user;\n    krb5_pa_data                padata;\n    krb5_enctype                enctype;\n    krb5_keyusage               usage;\n\n    memset(&rep_s4u_user, 0, sizeof(rep_s4u_user));\n\n    rep_s4u_user.user_id.nonce   = req_s4u_user->user_id.nonce;\n    rep_s4u_user.user_id.user    = req_s4u_user->user_id.user;\n    rep_s4u_user.user_id.options =\n        req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE;\n\n    code = encode_krb5_s4u_userid(&rep_s4u_user.user_id, &data);\n    if (code != 0)\n        goto cleanup;\n\n    if (req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE)\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REPLY;\n    else\n        usage = KRB5_KEYUSAGE_PA_S4U_X509_USER_REQUEST;\n\n    code = krb5_c_make_checksum(context, req_s4u_user->cksum.checksum_type,\n                                tgs_subkey != NULL ? tgs_subkey : tgs_session,\n                                usage, data,\n                                &rep_s4u_user.cksum);\n    if (code != 0)\n        goto cleanup;\n\n    krb5_free_data(context, data);\n    data = NULL;\n\n    code = encode_krb5_pa_s4u_x509_user(&rep_s4u_user, &data);\n    if (code != 0)\n        goto cleanup;\n\n    padata.magic = KV5M_PA_DATA;\n    padata.pa_type = KRB5_PADATA_S4U_X509_USER;\n    padata.length = data->length;\n    padata.contents = (krb5_octet *)data->data;\n\n    code = add_pa_data_element(context, &padata, &reply->padata, FALSE);\n    if (code != 0)\n        goto cleanup;\n\n    free(data);\n    data = NULL;\n\n    if (tgs_subkey != NULL)\n        enctype = tgs_subkey->enctype;\n    else\n        enctype = tgs_session->enctype;\n\n    /*\n     * Owing to a bug in Windows, unkeyed checksums were used for older\n     * enctypes, including rc4-hmac. A forthcoming workaround for this\n     * includes the checksum bytes in the encrypted padata.\n     */\n    if ((req_s4u_user->user_id.options & KRB5_S4U_OPTS_USE_REPLY_KEY_USAGE) &&\n        enctype_requires_etype_info_2(enctype) == FALSE) {\n        padata.length = req_s4u_user->cksum.length +\n            rep_s4u_user.cksum.length;\n        padata.contents = malloc(padata.length);\n        if (padata.contents == NULL) {\n            code = ENOMEM;\n            goto cleanup;\n        }\n\n        memcpy(padata.contents,\n               req_s4u_user->cksum.contents,\n               req_s4u_user->cksum.length);\n        memcpy(&padata.contents[req_s4u_user->cksum.length],\n               rep_s4u_user.cksum.contents,\n               rep_s4u_user.cksum.length);\n\n        code = add_pa_data_element(context,&padata,\n                                   &reply_encpart->enc_padata, FALSE);\n        if (code != 0) {\n            free(padata.contents);\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    if (rep_s4u_user.cksum.contents != NULL)\n        krb5_free_checksum_contents(context, &rep_s4u_user.cksum);\n    krb5_free_data(context, data);\n\n    return code;\n}\n\n/*\n * Protocol transition (S4U2Self)\n */\nkrb5_error_code\nkdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\ncheck_allowed_to_delegate_to(krb5_context context, krb5_const_principal client,\n                             const krb5_db_entry *server,\n                             krb5_const_principal proxy)\n{\n    /* Can't get a TGT (otherwise it would be unconstrained delegation) */\n    if (krb5_is_tgs_principal(proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    /* Must be in same realm */\n    if (!krb5_realm_compare(context, server->princ, proxy))\n        return KRB5KDC_ERR_POLICY;\n\n    return krb5_db_check_allowed_to_delegate(context, client, server, proxy);\n}\n\nkrb5_error_code\nkdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n\n    /*\n     * Constrained delegation is mutually exclusive with renew/forward/etc.\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /* Ensure that evidence ticket server matches TGT client */\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, /* after canon */\n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n\n    /* Backend policy check */\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkdc_check_transited_list(kdc_realm_t *kdc_active_realm,\n                         const krb5_data *trans,\n                         const krb5_data *realm1,\n                         const krb5_data *realm2)\n{\n    krb5_error_code             code;\n\n    /* Check against the KDB module.  Treat this answer as authoritative if the\n     * method is supported and doesn't explicitly pass control. */\n    code = krb5_db_check_transited_realms(kdc_context, trans, realm1, realm2);\n    if (code != KRB5_PLUGIN_OP_NOTSUPP && code != KRB5_PLUGIN_NO_HANDLE)\n        return code;\n\n    /* Check using krb5.conf [capaths] or hierarchical relationships. */\n    return krb5_check_transited_list(kdc_context, trans, realm1, realm2);\n}\n\nkrb5_error_code\nvalidate_transit_path(krb5_context context,\n                      krb5_const_principal client,\n                      krb5_db_entry *server,\n                      krb5_db_entry *header_srv)\n{\n    /* Incoming */\n    if (isflagset(server->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE)) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    /* Outgoing */\n    if (isflagset(header_srv->attributes, KRB5_KDB_XREALM_NON_TRANSITIVE) &&\n        (!krb5_principal_compare(context, server->princ, header_srv->princ) ||\n         !krb5_realm_compare(context, client, header_srv->princ))) {\n        return KRB5KDC_ERR_PATH_NOT_ACCEPTED;\n    }\n\n    return 0;\n}\n\nkrb5_boolean\nenctype_requires_etype_info_2(krb5_enctype enctype)\n{\n    switch(enctype) {\n    case ENCTYPE_DES_CBC_CRC:\n    case ENCTYPE_DES_CBC_MD4:\n    case ENCTYPE_DES_CBC_MD5:\n    case ENCTYPE_DES3_CBC_SHA1:\n    case ENCTYPE_DES3_CBC_RAW:\n    case ENCTYPE_ARCFOUR_HMAC:\n    case ENCTYPE_ARCFOUR_HMAC_EXP :\n        return 0;\n    default:\n        return krb5_c_valid_enctype(enctype);\n    }\n}\n\n/* XXX where are the generic helper routines for this? */\nkrb5_error_code\nadd_pa_data_element(krb5_context context,\n                    krb5_pa_data *padata,\n                    krb5_pa_data ***inout_padata,\n                    krb5_boolean copy)\n{\n    int                         i;\n    krb5_pa_data                **p;\n\n    if (*inout_padata != NULL) {\n        for (i = 0; (*inout_padata)[i] != NULL; i++)\n            ;\n    } else\n        i = 0;\n\n    p = realloc(*inout_padata, (i + 2) * sizeof(krb5_pa_data *));\n    if (p == NULL)\n        return ENOMEM;\n\n    *inout_padata = p;\n\n    p[i] = (krb5_pa_data *)malloc(sizeof(krb5_pa_data));\n    if (p[i] == NULL)\n        return ENOMEM;\n    *(p[i]) = *padata;\n\n    p[i + 1] = NULL;\n\n    if (copy) {\n        p[i]->contents = (krb5_octet *)malloc(padata->length);\n        if (p[i]->contents == NULL) {\n            free(p[i]);\n            p[i] = NULL;\n            return ENOMEM;\n        }\n\n        memcpy(p[i]->contents, padata->contents, padata->length);\n    }\n\n    return 0;\n}\n\nvoid\nkdc_get_ticket_endtime(kdc_realm_t *kdc_active_realm,\n                       krb5_timestamp starttime,\n                       krb5_timestamp endtime,\n                       krb5_timestamp till,\n                       krb5_db_entry *client,\n                       krb5_db_entry *server,\n                       krb5_timestamp *out_endtime)\n{\n    krb5_timestamp until, life;\n\n    if (till == 0)\n        till = kdc_infinity;\n\n    until = ts_min(till, endtime);\n\n    life = ts_delta(until, starttime);\n\n    if (client != NULL && client->max_life != 0)\n        life = min(life, client->max_life);\n    if (server->max_life != 0)\n        life = min(life, server->max_life);\n    if (kdc_active_realm->realm_maxlife != 0)\n        life = min(life, kdc_active_realm->realm_maxlife);\n\n    *out_endtime = ts_incr(starttime, life);\n}\n\n/*\n * Set tkt->renew_till to the requested renewable lifetime as modified by\n * policy.  Set the TKT_FLG_RENEWABLE flag if we set a nonzero renew_till.\n * client and tgt may be NULL.\n */\nvoid\nkdc_get_ticket_renewtime(kdc_realm_t *realm, krb5_kdc_req *request,\n                         krb5_enc_tkt_part *tgt, krb5_db_entry *client,\n                         krb5_db_entry *server, krb5_enc_tkt_part *tkt)\n{\n    krb5_timestamp rtime, max_rlife;\n\n    tkt->times.renew_till = 0;\n\n    /* Don't issue renewable tickets if the client or server don't allow it,\n     * or if this is a TGS request and the TGT isn't renewable. */\n    if (server->attributes & KRB5_KDB_DISALLOW_RENEWABLE)\n        return;\n    if (client != NULL && (client->attributes & KRB5_KDB_DISALLOW_RENEWABLE))\n        return;\n    if (tgt != NULL && !(tgt->flags & TKT_FLG_RENEWABLE))\n        return;\n\n    /* Determine the requested renewable time. */\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE))\n        rtime = request->rtime ? request->rtime : kdc_infinity;\n    else if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n             ts_after(request->till, tkt->times.endtime))\n        rtime = request->till;\n    else\n        return;\n\n    /* Truncate it to the allowable renewable time. */\n    if (tgt != NULL)\n        rtime = ts_min(rtime, tgt->times.renew_till);\n    max_rlife = min(server->max_renewable_life, realm->realm_maxrlife);\n    if (client != NULL)\n        max_rlife = min(max_rlife, client->max_renewable_life);\n    rtime = ts_min(rtime, ts_incr(tkt->times.starttime, max_rlife));\n\n    /* Make the ticket renewable if the truncated requested time is larger than\n     * the ticket end time. */\n    if (ts_after(rtime, tkt->times.endtime)) {\n        setflag(tkt->flags, TKT_FLG_RENEWABLE);\n        tkt->times.renew_till = rtime;\n    }\n}\n\n/**\n * Handle protected negotiation of FAST using enc_padata\n * - If ENCPADATA_REQ_ENC_PA_REP is present, then:\n * - Return ENCPADATA_REQ_ENC_PA_REP with checksum of AS-REQ from client\n * - Include PADATA_FX_FAST in the enc_padata to indicate FAST\n * @pre @c out_enc_padata has space for at least two more padata\n * @param index in/out index into @c out_enc_padata for next item\n */\nkrb5_error_code\nkdc_handle_protected_negotiation(krb5_context context,\n                                 krb5_data *req_pkt, krb5_kdc_req *request,\n                                 const krb5_keyblock *reply_key,\n                                 krb5_pa_data ***out_enc_padata)\n{\n    krb5_error_code retval = 0;\n    krb5_checksum checksum;\n    krb5_data *out = NULL;\n    krb5_pa_data pa, *pa_in;\n    pa_in = krb5int_find_pa_data(context, request->padata,\n                                 KRB5_ENCPADATA_REQ_ENC_PA_REP);\n    if (pa_in == NULL)\n        return 0;\n    pa.magic = KV5M_PA_DATA;\n    pa.pa_type = KRB5_ENCPADATA_REQ_ENC_PA_REP;\n    memset(&checksum, 0, sizeof(checksum));\n    retval = krb5_c_make_checksum(context,0, reply_key,\n                                  KRB5_KEYUSAGE_AS_REQ, req_pkt, &checksum);\n    if (retval != 0)\n        goto cleanup;\n    retval = encode_krb5_checksum(&checksum, &out);\n    if (retval != 0)\n        goto cleanup;\n    pa.contents = (krb5_octet *) out->data;\n    pa.length = out->length;\n    retval = add_pa_data_element(context, &pa, out_enc_padata, FALSE);\n    if (retval)\n        goto cleanup;\n    out->data = NULL;\n    pa.magic = KV5M_PA_DATA;\n    pa.pa_type = KRB5_PADATA_FX_FAST;\n    pa.length = 0;\n    pa.contents = NULL;\n    retval = add_pa_data_element(context, &pa, out_enc_padata, FALSE);\ncleanup:\n    if (checksum.contents)\n        krb5_free_checksum_contents(context, &checksum);\n    if (out != NULL)\n        krb5_free_data(context, out);\n    return retval;\n}\n\n/*\n * Although the KDC doesn't call this function directly,\n * process_tcp_connection_read() in net-server.c does call it.\n */\nkrb5_error_code\nmake_toolong_error (void *handle, krb5_data **out)\n{\n    krb5_error errpkt;\n    krb5_error_code retval;\n    krb5_data *scratch;\n    struct server_handle *h = handle;\n\n    retval = krb5_us_timeofday(h->kdc_err_context,\n                               &errpkt.stime, &errpkt.susec);\n    if (retval)\n        return retval;\n    errpkt.error = KRB_ERR_FIELD_TOOLONG;\n    errpkt.server = h->kdc_realmlist[0]->realm_tgsprinc;\n    errpkt.client = NULL;\n    errpkt.cusec = 0;\n    errpkt.ctime = 0;\n    errpkt.text.length = 0;\n    errpkt.text.data = 0;\n    errpkt.e_data.length = 0;\n    errpkt.e_data.data = 0;\n    scratch = malloc(sizeof(*scratch));\n    if (scratch == NULL)\n        return ENOMEM;\n    retval = krb5_mk_error(h->kdc_err_context, &errpkt, scratch);\n    if (retval) {\n        free(scratch);\n        return retval;\n    }\n\n    *out = scratch;\n    return 0;\n}\n\nvoid reset_for_hangup(void *ctx)\n{\n    int k;\n    struct server_handle *h = ctx;\n\n    for (k = 0; k < h->kdc_numrealms; k++)\n        krb5_db_refresh_config(h->kdc_realmlist[k]->realm_context);\n}\n"], "filenames": ["src/kdc/do_as_req.c", "src/kdc/do_tgs_req.c", "src/kdc/kdc_util.c"], "buggy_code_start_loc": [369, 826, 1223], "buggy_code_end_loc": [371, 827, 1633], "fixing_code_start_loc": [369, 826, 1223], "fixing_code_end_loc": [371, 828, 1640], "type": "CWE-617", "message": "In MIT Kerberos 5 (aka krb5) 1.7 and later, an authenticated attacker can cause a KDC assertion failure by sending invalid S4U2Self or S4U2Proxy requests.", "other": {"cve": {"id": "CVE-2017-11368", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-09T18:29:01.450", "lastModified": "2020-01-21T15:47:29.447", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In MIT Kerberos 5 (aka krb5) 1.7 and later, an authenticated attacker can cause a KDC assertion failure by sending invalid S4U2Self or S4U2Proxy requests."}, {"lang": "es", "value": "En MIT Kerberos 5 (tambi\u00e9n llamado krb5) en versiones 1.7 y posteriores, un atacante autenticado puede provocar un error de aserci\u00f3n KDC mediante el env\u00edo de peticiones S4U2Self o S4U2Proxy no v\u00e1lidas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:26:*:*:*:*:*:*:*", "matchCriteriaId": "6E4D8269-B407-4C24-AAB0-02F885C7D752"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos:5-1.13.7:*:*:*:*:*:*:*", "matchCriteriaId": "B58B2F8D-83F5-46E0-B0DE-FEC2B0706CC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.7:*:*:*:*:*:*:*", "matchCriteriaId": "DFB1190E-BE7A-4C6B-862D-D5747C64E980"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "4B09C090-B842-43C7-B8A6-DBF63D80FEC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8:*:*:*:*:*:*:*", "matchCriteriaId": "36823B2B-5C72-4FF3-9301-FB263EB8CE09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "59AFA33E-FEBC-45F5-9EC6-8AA363163FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "04D83332-B2FD-4E86-A76C-C3F1CD3B3A31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "758A0011-20ED-414A-9DF3-50A161DF8BC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "7768AED0-AE4C-4D4E-8D5D-5B618AB82966"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "534104C5-966E-4740-A354-4F6C210FF25B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "78AF5659-C0E3-49C4-9CA7-FC3917C8AC49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "86738633-C081-4440-9F75-A775D6DF2228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7BCFFEE-EA7A-4F26-97AA-31128A179745"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "91A2D7F5-EBDE-4000-AC78-8DD6472E685A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8E92BFA5-723E-4843-A8D8-BC1D32F34569"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "34C27198-9B55-42FB-AA21-D8B4EB60D926"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10:*:*:*:*:*:*:*", "matchCriteriaId": "FC504264-A9E9-4433-B7AA-6D5015A93FF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "77FA352F-520C-4C05-AD52-FC8586DB16B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "9FFB18F7-CB08-4AE4-9DEC-55D047819A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "637E858A-7C16-490C-99A8-F46440E5F504"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "22840B84-2EA4-4E96-A8D8-154AAEADB806"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "2D554BDC-CD7D-4572-B1E8-5F627F2C5916"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "65BCD38A-33AD-4FD7-AF5B-8470B24C4139"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "E11F9209-799A-428B-9513-DBD0F19C7BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "1DA40FAA-B858-4282-8438-247E99FBB002"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "65795542-D886-46C4-8ECB-4630078DF66A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "D0A4C436-C3D7-469E-8895-8EEC9569EE86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "79A9FAE9-7219-4D6A-9E94-FFE20223537D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA68BC90-FCFC-4C9B-8574-9029DB2358E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "9D0A28CB-173D-4676-B083-E3718213B840"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "AA3D2861-7EB7-4984-AC92-989B427BDB58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13:*:*:*:*:*:*:*", "matchCriteriaId": "169D00BD-344F-453C-BE7C-9DF0740080BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "765B3248-A524-4A79-858C-E787C1C1599E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.2:*:*:*:*:*:*:*", "matchCriteriaId": "BF1BB0AB-2C22-49F9-9D2A-074D2F711BA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.3:*:*:*:*:*:*:*", "matchCriteriaId": "C8EC001E-9507-410D-836F-93002789D574"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.5:*:*:*:*:*:*:*", "matchCriteriaId": "0037EF80-A599-4938-889F-9276E339A8E0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.13.6:*:*:*:*:*:*:*", "matchCriteriaId": "1CABFE58-4811-49EC-8565-35EB7D5F6F4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:*:*:*:*:*:*:*", "matchCriteriaId": "6E30B176-1FE5-4C53-8B79-2E6D87DF05B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:alpha1:*:*:*:*:*:*", "matchCriteriaId": "EC81822F-DC8C-4889-AD53-33216B66A109"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:beta1:*:*:*:*:*:*", "matchCriteriaId": "C1B23EE0-35EB-46FC-8620-AC0059498D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:beta2:*:*:*:*:*:*", "matchCriteriaId": "70831CB8-695D-45E8-A829-2E888823E8A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "E650B5A3-99CA-491B-A1FB-259EF548D92E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.2:*:*:*:*:*:*:*", "matchCriteriaId": "091F3C51-980E-482F-9882-0A555A8F74BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.3:*:*:*:*:*:*:*", "matchCriteriaId": "A00BDDDC-3D5D-4D63-A8D8-63BF2F4C7329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.4:*:*:*:*:*:*:*", "matchCriteriaId": "42505BC2-12A0-43E9-8561-80270D7CA74D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.5:*:*:*:*:*:*:*", "matchCriteriaId": "AF0496EF-F0F9-4A5D-92F4-E50C5F3DCA12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15:*:*:*:*:*:*:*", "matchCriteriaId": "79EEC80F-9E4F-4A6D-BB8D-6AB7764AD8E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "DB427FE4-CC39-43EE-A27B-69C5B18056FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15.1:beta1:*:*:*:*:*:*", "matchCriteriaId": "14A2F0C0-91E0-4DD9-851E-67CE8A5EAE0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15.1:beta2:*:*:*:*:*:*", "matchCriteriaId": "C1770120-B3B2-4B5A-9785-162399A47989"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100291", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0666", "source": "cve@mitre.org"}, {"url": "https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4HNWXM6OQU7G23MG7XWIOBRGP43ECLDT/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UBUTXMNZWMVJLQ4NDX5OQFPUVCJRLV3W/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970"}}