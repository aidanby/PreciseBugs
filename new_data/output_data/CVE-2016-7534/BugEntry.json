{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%                   IIIII  M   M  PPPP    OOO   RRRR   TTTTT                  %\n%                     I    MM MM  P   P  O   O  R   R    T                    %\n%                     I    M M M  PPPP   O   O  RRRR     T                    %\n%                     I    M   M  P      O   O  R R      T                    %\n%                   IIIII  M   M  P       OOO   R  R     T                    %\n%                                                                             %\n%                 MagickCore Methods to Import Quantum Pixels                 %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m p o r t Q u a n t u m P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImportQuantumPixels() transfers one or more pixel components from a user\n%  supplied buffer into the image pixel cache of an image.  The pixels are\n%  expected in network byte order.  It returns MagickTrue if the pixels are\n%  successfully transferred, otherwise MagickFalse.\n%\n%  The format of the ImportQuantumPixels method is:\n%\n%      size_t ImportQuantumPixels(const Image *image,CacheView *image_view,\n%        QuantumInfo *quantum_info,const QuantumType quantum_type,\n%        const unsigned char *magick_restrict pixels,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o image_view: the image cache view.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n%    o pixels:  The pixel components are transferred from this buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PushColormapIndex(const Image *image,const size_t index,\n  MagickBooleanType *range_exception)\n{\n  if (index < image->colors)\n    return((Quantum) index);\n  *range_exception=MagickTrue;\n  return((Quantum) 0);\n}\n\nstatic inline const unsigned char *PushDoublePixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,double *pixel)\n{\n  double\n    *p;\n\n  unsigned char\n    quantum[8];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      quantum[4]=(*pixels++);\n      quantum[5]=(*pixels++);\n      quantum[6]=(*pixels++);\n      quantum[7]=(*pixels++);\n      p=(double *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[7]=(*pixels++);\n  quantum[6]=(*pixels++);\n  quantum[5]=(*pixels++);\n  quantum[4]=(*pixels++);\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(double *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushFloatPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,float *pixel)\n{\n  float\n    *p;\n\n  unsigned char\n    quantum[4];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      p=(float *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(float *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=(QuantumAny) 0;\n  for (i=(ssize_t) quantum_info->depth; i > 0L; )\n  {\n    if (quantum_info->state.bits == 0UL)\n      {\n        quantum_info->state.pixel=(*pixels++);\n        quantum_info->state.bits=8UL;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n    *quantum=(unsigned int) ((*quantum << quantum_bits) |\n      ((quantum_info->state.pixel >> quantum_info->state.bits) &~ ((~0UL) <<\n      quantum_bits)));\n  }\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumLongPixel(\n  QuantumInfo *quantum_info,const unsigned char *magick_restrict pixels,\n  unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=0UL;\n  for (i=(ssize_t) quantum_info->depth; i > 0; )\n  {\n    if (quantum_info->state.bits == 0)\n      {\n        pixels=PushLongPixel(quantum_info->endian,pixels,\n          &quantum_info->state.pixel);\n        quantum_info->state.bits=32U;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    *quantum|=(((quantum_info->state.pixel >> (32U-quantum_info->state.bits)) &\n      quantum_info->state.mask[quantum_bits]) << (quantum_info->depth-i));\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n  }\n  return(pixels);\n}\n\nstatic void ImportAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGROQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlackQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlueQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 10:\n    {\n      Quantum\n        cbcr[4];\n\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x+=2)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              cbcr[i]=(Quantum) (quantum);\n              n++;\n            }\n            p+=quantum_info->pad;\n            SetPixelRed(image,cbcr[1],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n            SetPixelRed(image,cbcr[3],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      bit=0;\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel != 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGreenQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ?\n              0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ?\n              0x00 : 0x01);\n          SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),\n            q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n            GetPixelIndex(image,q),q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        if (quantum_info->min_is_white == MagickFalse)\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n        else\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) ((*p++ >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportIndexAlphaQuantum(const Image *image,\n  QuantumInfo *quantum_info,const MagickSizeType number_pixels,\n  const unsigned char *magick_restrict p,Quantum *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          q+=GetPixelChannels(image);\n        }\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,\n              ClampToQuantum(pixel),&range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRedQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nMagickExport size_t ImportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,const unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  register const unsigned char\n    *magick_restrict p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (const unsigned char *) NULL)\n    pixels=(const unsigned char *) GetQuantumPixels(quantum_info);\n  x=0;\n  p=pixels;\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      q=GetAuthenticPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_view);\n      q=GetCacheViewAuthenticPixelQueue(image_view);\n    }\n  ResetQuantumState(quantum_info);\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  switch (quantum_type)\n  {\n    case AlphaQuantum:\n    {\n      ImportAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRQuantum:\n    {\n      ImportBGRQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRAQuantum:\n    {\n      ImportBGRAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGROQuantum:\n    {\n      ImportBGROQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlackQuantum:\n    {\n      ImportBlackQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlueQuantum:\n    case YellowQuantum:\n    {\n      ImportBlueQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKQuantum:\n    {\n      ImportCMYKQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKAQuantum:\n    {\n      ImportCMYKAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKOQuantum:\n    {\n      ImportCMYKOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CbYCrYQuantum:\n    {\n      ImportCbYCrYQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayQuantum:\n    {\n      ImportGrayQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayAlphaQuantum:\n    {\n      ImportGrayAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GreenQuantum:\n    case MagentaQuantum:\n    {\n      ImportGreenQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexQuantum:\n    {\n      ImportIndexQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexAlphaQuantum:\n    {\n      ImportIndexAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case OpacityQuantum:\n    {\n      ImportOpacityQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RedQuantum:\n    case CyanQuantum:\n    {\n      ImportRedQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBQuantum:\n    case CbYCrQuantum:\n    {\n      ImportRGBQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBAQuantum:\n    case CbYCrAQuantum:\n    {\n      ImportRGBAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBOQuantum:\n    {\n      ImportRGBOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    default:\n      break;\n  }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      register Quantum\n        *magick_restrict q;\n\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  if (quantum_info->alpha_type == DisassociatedQuantumAlpha)\n    {\n      double\n        gamma,\n        Sa;\n\n      register Quantum\n        *magick_restrict q;\n\n      /*\n        Disassociate alpha.\n      */\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        register ssize_t\n          i;\n\n        if (GetPixelReadMask(image,q) == 0)\n          {\n            q+=GetPixelChannels(image);\n            continue;\n          }\n        Sa=QuantumScale*GetPixelAlpha(image,q);\n        gamma=PerceptibleReciprocal(Sa);\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          if ((channel == AlphaPixelChannel) ||\n              ((traits & UpdatePixelTrait) == 0))\n            continue;\n          q[i]=ClampToQuantum(gamma*q[i]);\n        }\n        q+=GetPixelChannels(image);\n      }\n    }\n  return(extent);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%             MagicCore Methods to Acquire / Destroy Quantum Pixels           %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Define declarations.\n*/\n#define QuantumSignature  0xab\n\f\n/*\n  Forward declarations.\n*/\nstatic void\n  DestroyQuantumPixels(QuantumInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t u m I n f o                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumInfo() allocates the QuantumInfo structure.\n%\n%  The format of the AcquireQuantumInfo method is:\n%\n%      QuantumInfo *AcquireQuantumInfo(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n*/\nMagickExport QuantumInfo *AcquireQuantumInfo(const ImageInfo *image_info,\n  Image *image)\n{\n  MagickBooleanType\n    status;\n\n  QuantumInfo\n    *quantum_info;\n\n  quantum_info=(QuantumInfo *) AcquireMagickMemory(sizeof(*quantum_info));\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  quantum_info->signature=MagickCoreSignature;\n  GetQuantumInfo(image_info,quantum_info);\n  if (image == (const Image *) NULL)\n    return(quantum_info);\n  status=SetQuantumDepth(image,quantum_info,image->depth);\n  quantum_info->endian=image->endian;\n  if (status == MagickFalse)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n  return(quantum_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e Q u a n t u m P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumPixels() allocates the pixel staging areas.\n%\n%  The format of the AcquireQuantumPixels method is:\n%\n%      MagickBooleanType AcquireQuantumPixels(QuantumInfo *quantum_info,\n%        const size_t extent)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o extent: the quantum info.\n%\n*/\nstatic MagickBooleanType AcquireQuantumPixels(QuantumInfo *quantum_info,\n  const size_t extent)\n{\n  register ssize_t\n    i;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  quantum_info->pixels=(unsigned char **) AcquireQuantumMemory(\n    quantum_info->number_threads,sizeof(*quantum_info->pixels));\n  if (quantum_info->pixels == (unsigned char **) NULL)\n    return(MagickFalse);\n  quantum_info->extent=extent;\n  (void) ResetMagickMemory(quantum_info->pixels,0,quantum_info->number_threads*\n    sizeof(*quantum_info->pixels));\n  for (i=0; i < (ssize_t) quantum_info->number_threads; i++)\n  {\n    quantum_info->pixels[i]=(unsigned char *) AcquireQuantumMemory(extent+1,\n      sizeof(**quantum_info->pixels));\n    if (quantum_info->pixels[i] == (unsigned char *) NULL)\n      {\n        while (--i >= 0)\n          quantum_info->pixels[i]=(unsigned char *) RelinquishMagickMemory(\n            quantum_info->pixels[i]);\n        return(MagickFalse);\n      }\n    (void) ResetMagickMemory(quantum_info->pixels[i],0,(extent+1)*\n      sizeof(**quantum_info->pixels));\n    quantum_info->pixels[i][extent]=QuantumSignature;\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y Q u a n t u m I n f o                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyQuantumInfo() deallocates memory associated with the QuantumInfo\n%  structure.\n%\n%  The format of the DestroyQuantumInfo method is:\n%\n%      QuantumInfo *DestroyQuantumInfo(QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport QuantumInfo *DestroyQuantumInfo(QuantumInfo *quantum_info)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (quantum_info->pixels != (unsigned char **) NULL)\n    DestroyQuantumPixels(quantum_info);\n  if (quantum_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&quantum_info->semaphore);\n  quantum_info->signature=(~MagickCoreSignature);\n  quantum_info=(QuantumInfo *) RelinquishMagickMemory(quantum_info);\n  return(quantum_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y Q u a n t u m P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyQuantumPixels() destroys the quantum pixels.\n%\n%  The format of the DestroyQuantumPixels() method is:\n%\n%      void DestroyQuantumPixels(QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nstatic void DestroyQuantumPixels(QuantumInfo *quantum_info)\n{\n  register ssize_t\n    i;\n\n  ssize_t\n    extent;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  assert(quantum_info->pixels != (unsigned char **) NULL);\n  extent=(ssize_t) quantum_info->extent;\n  for (i=0; i < (ssize_t) quantum_info->number_threads; i++)\n    if (quantum_info->pixels[i] != (unsigned char *) NULL)\n      {\n        /*\n          Did we overrun our quantum buffer?\n        */\n        assert(quantum_info->pixels[i][extent] == QuantumSignature);\n        quantum_info->pixels[i]=(unsigned char *) RelinquishMagickMemory(\n          quantum_info->pixels[i]);\n      }\n  quantum_info->pixels=(unsigned char **) RelinquishMagickMemory(\n    quantum_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m E x t e n t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumExtent() returns the quantum pixel buffer extent.\n%\n%  The format of the GetQuantumExtent method is:\n%\n%      size_t GetQuantumExtent(Image *image,const QuantumInfo *quantum_info,\n%        const QuantumType quantum_type)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n*/\nMagickExport size_t GetQuantumExtent(const Image *image,\n  const QuantumInfo *quantum_info,const QuantumType quantum_type)\n{\n  size_t\n    extent,\n    packet_size;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  packet_size=1;\n  switch (quantum_type)\n  {\n    case GrayAlphaQuantum: packet_size=2; break;\n    case IndexAlphaQuantum: packet_size=2; break;\n    case RGBQuantum: packet_size=3; break;\n    case BGRQuantum: packet_size=3; break;\n    case RGBAQuantum: packet_size=4; break;\n    case RGBOQuantum: packet_size=4; break;\n    case BGRAQuantum: packet_size=4; break;\n    case CMYKQuantum: packet_size=4; break;\n    case CMYKAQuantum: packet_size=5; break;\n    default: break;\n  }\n  extent=MagickMax(image->columns,image->rows);\n  if (quantum_info->pack == MagickFalse)\n    return((size_t) (packet_size*extent*((quantum_info->depth+7)/8)));\n  return((size_t) ((packet_size*extent*quantum_info->depth+7)/8));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m E n d i a n                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumEndian() returns the quantum endian of the image.\n%\n%  The endian of the GetQuantumEndian method is:\n%\n%      EndianType GetQuantumEndian(const QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport EndianType GetQuantumEndian(const QuantumInfo *quantum_info)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  return(quantum_info->endian);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m F o r m a t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumFormat() returns the quantum format of the image.\n%\n%  The format of the GetQuantumFormat method is:\n%\n%      QuantumFormatType GetQuantumFormat(const QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport QuantumFormatType GetQuantumFormat(const QuantumInfo *quantum_info)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  return(quantum_info->format);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m I n f o                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumInfo() initializes the QuantumInfo structure to default values.\n%\n%  The format of the GetQuantumInfo method is:\n%\n%      GetQuantumInfo(const ImageInfo *image_info,QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport void GetQuantumInfo(const ImageInfo *image_info,\n  QuantumInfo *quantum_info)\n{\n  const char\n    *option;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  (void) ResetMagickMemory(quantum_info,0,sizeof(*quantum_info));\n  quantum_info->quantum=8;\n  quantum_info->maximum=1.0;\n  quantum_info->scale=QuantumRange;\n  quantum_info->pack=MagickTrue;\n  quantum_info->semaphore=AcquireSemaphoreInfo();\n  quantum_info->signature=MagickCoreSignature;\n  if (image_info == (const ImageInfo *) NULL)\n    return;\n  option=GetImageOption(image_info,\"quantum:format\");\n  if (option != (char *) NULL)\n    quantum_info->format=(QuantumFormatType) ParseCommandOption(\n      MagickQuantumFormatOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"quantum:minimum\");\n  if (option != (char *) NULL)\n    quantum_info->minimum=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(image_info,\"quantum:maximum\");\n  if (option != (char *) NULL)\n    quantum_info->maximum=StringToDouble(option,(char **) NULL);\n  if ((quantum_info->minimum == 0.0) && (quantum_info->maximum == 0.0))\n    quantum_info->scale=0.0;\n  else\n    if (quantum_info->minimum == quantum_info->maximum)\n      {\n        quantum_info->scale=(double) QuantumRange/quantum_info->minimum;\n        quantum_info->minimum=0.0;\n      }\n    else\n      quantum_info->scale=(double) QuantumRange/(quantum_info->maximum-\n        quantum_info->minimum);\n  option=GetImageOption(image_info,\"quantum:scale\");\n  if (option != (char *) NULL)\n    quantum_info->scale=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(image_info,\"quantum:polarity\");\n  if (option != (char *) NULL)\n    quantum_info->min_is_white=LocaleCompare(option,\"min-is-white\") == 0 ?\n      MagickTrue : MagickFalse;\n  quantum_info->endian=image_info->endian;\n  ResetQuantumState(quantum_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumPixels() returns the quantum pixels.\n%\n%  The format of the GetQuantumPixels method is:\n%\n%      unsigned char *QuantumPixels GetQuantumPixels(\n%        const QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned char *GetQuantumPixels(const QuantumInfo *quantum_info)\n{\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  return(quantum_info->pixels[id]);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m T y p e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumType() returns the quantum type of the image.\n%\n%  The format of the GetQuantumType method is:\n%\n%      QuantumType GetQuantumType(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport QuantumType GetQuantumType(Image *image,ExceptionInfo *exception)\n{\n  QuantumType\n    quantum_type;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  (void) exception;\n  quantum_type=RGBQuantum;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    quantum_type=RGBAQuantum;\n  if (image->colorspace == CMYKColorspace)\n    {\n      quantum_type=CMYKQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=CMYKAQuantum;\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    {\n      quantum_type=GrayQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=GrayAlphaQuantum;\n    }\n  if (image->storage_class == PseudoClass)\n    {\n      quantum_type=IndexQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=IndexAlphaQuantum;\n    }\n  return(quantum_type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e s e t Q u a n t u m S t a t e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetQuantumState() resets the quantum state.\n%\n%  The format of the ResetQuantumState method is:\n%\n%      void ResetQuantumState(QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickPrivate void ResetQuantumState(QuantumInfo *quantum_info)\n{\n  static const unsigned int mask[32] =\n  {\n    0x00000000U, 0x00000001U, 0x00000003U, 0x00000007U, 0x0000000fU,\n    0x0000001fU, 0x0000003fU, 0x0000007fU, 0x000000ffU, 0x000001ffU,\n    0x000003ffU, 0x000007ffU, 0x00000fffU, 0x00001fffU, 0x00003fffU,\n    0x00007fffU, 0x0000ffffU, 0x0001ffffU, 0x0003ffffU, 0x0007ffffU,\n    0x000fffffU, 0x001fffffU, 0x003fffffU, 0x007fffffU, 0x00ffffffU,\n    0x01ffffffU, 0x03ffffffU, 0x07ffffffU, 0x0fffffffU, 0x1fffffffU,\n    0x3fffffffU, 0x7fffffffU\n  };\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->state.inverse_scale=1.0;\n  if (fabs(quantum_info->scale) >= MagickEpsilon)\n    quantum_info->state.inverse_scale/=quantum_info->scale;\n  quantum_info->state.pixel=0U;\n  quantum_info->state.bits=0U;\n  quantum_info->state.mask=mask;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m F o r m a t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumAlphaType() sets the quantum format.\n%\n%  The format of the SetQuantumAlphaType method is:\n%\n%      void SetQuantumAlphaType(QuantumInfo *quantum_info,\n%        const QuantumAlphaType type)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o type: the alpha type (e.g. associate).\n%\n*/\nMagickExport void SetQuantumAlphaType(QuantumInfo *quantum_info,\n  const QuantumAlphaType type)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->alpha_type=type;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m D e p t h                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumDepth() sets the quantum depth.\n%\n%  The format of the SetQuantumDepth method is:\n%\n%      MagickBooleanType SetQuantumDepth(const Image *image,\n%        QuantumInfo *quantum_info,const size_t depth)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o depth: the quantum depth.\n%\n*/\nMagickExport MagickBooleanType SetQuantumDepth(const Image *image,\n  QuantumInfo *quantum_info,const size_t depth)\n{\n  size_t\n    extent,\n    quantum;\n\n  /*\n    Allocate the quantum pixel buffer.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->depth=depth;\n  if (quantum_info->format == FloatingPointQuantumFormat)\n    {\n      if (quantum_info->depth > 32)\n        quantum_info->depth=64;\n      else\n        if (quantum_info->depth > 16)\n          quantum_info->depth=32;\n        else\n          quantum_info->depth=16;\n    }\n  if (quantum_info->pixels != (unsigned char **) NULL)\n    DestroyQuantumPixels(quantum_info);\n  quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;\n  extent=MagickMax(image->columns,image->rows)*quantum;\n  if ((MagickMax(image->columns,image->rows) != 0) &&\n      (quantum != (extent/MagickMax(image->columns,image->rows))))\n    return(MagickFalse);\n  return(AcquireQuantumPixels(quantum_info,extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m E n d i a n                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumEndian() sets the quantum endian.\n%\n%  The endian of the SetQuantumEndian method is:\n%\n%      MagickBooleanType SetQuantumEndian(const Image *image,\n%        QuantumInfo *quantum_info,const EndianType endian)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o endian: the quantum endian.\n%\n*/\nMagickExport MagickBooleanType SetQuantumEndian(const Image *image,\n  QuantumInfo *quantum_info,const EndianType endian)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->endian=endian;\n  return(SetQuantumDepth(image,quantum_info,quantum_info->depth));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m F o r m a t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumFormat() sets the quantum format.\n%\n%  The format of the SetQuantumFormat method is:\n%\n%      MagickBooleanType SetQuantumFormat(const Image *image,\n%        QuantumInfo *quantum_info,const QuantumFormatType format)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o format: the quantum format.\n%\n*/\nMagickExport MagickBooleanType SetQuantumFormat(const Image *image,\n  QuantumInfo *quantum_info,const QuantumFormatType format)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->format=format;\n  return(SetQuantumDepth(image,quantum_info,quantum_info->depth));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m I m a g e T y p e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumImageType() sets the image type based on the quantum type.\n%\n%  The format of the SetQuantumImageType method is:\n%\n%      void ImageType SetQuantumImageType(Image *image,\n%        const QuantumType quantum_type)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n*/\nMagickExport void SetQuantumImageType(Image *image,\n  const QuantumType quantum_type)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  switch (quantum_type)\n  {\n    case IndexQuantum:\n    case IndexAlphaQuantum:\n    {\n      image->type=PaletteType;\n      break;\n    }\n    case GrayQuantum:\n    case GrayAlphaQuantum:\n    {\n      image->type=GrayscaleType;\n      if (image->depth == 1)\n        image->type=BilevelType;\n      break;\n    }\n    case CyanQuantum:\n    case MagentaQuantum:\n    case YellowQuantum:\n    case BlackQuantum:\n    case CMYKQuantum:\n    case CMYKAQuantum:\n    {\n      image->type=ColorSeparationType;\n      break;\n    }\n    default:\n    {\n      image->type=TrueColorType;\n      break;\n    }\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m P a c k                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumPack() sets the quantum pack flag.\n%\n%  The format of the SetQuantumPack method is:\n%\n%      void SetQuantumPack(QuantumInfo *quantum_info,\n%        const MagickBooleanType pack)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o pack: the pack flag.\n%\n*/\nMagickExport void SetQuantumPack(QuantumInfo *quantum_info,\n  const MagickBooleanType pack)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->pack=pack;\n}\n\f\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m P a d                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumPad() sets the quantum pad.\n%\n%  The format of the SetQuantumPad method is:\n%\n%      MagickBooleanType SetQuantumPad(const Image *image,\n%        QuantumInfo *quantum_info,const size_t pad)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o pad: the quantum pad.\n%\n*/\nMagickExport MagickBooleanType SetQuantumPad(const Image *image,\n  QuantumInfo *quantum_info,const size_t pad)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->pad=pad;\n  return(SetQuantumDepth(image,quantum_info,quantum_info->depth));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m M i n I s W h i t e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumMinIsWhite() sets the quantum min-is-white flag.\n%\n%  The format of the SetQuantumMinIsWhite method is:\n%\n%      void SetQuantumMinIsWhite(QuantumInfo *quantum_info,\n%        const MagickBooleanType min_is_white)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o min_is_white: the min-is-white flag.\n%\n*/\nMagickExport void SetQuantumMinIsWhite(QuantumInfo *quantum_info,\n  const MagickBooleanType min_is_white)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->min_is_white=min_is_white;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m Q u a n t u m                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumQuantum() sets the quantum quantum.\n%\n%  The format of the SetQuantumQuantum method is:\n%\n%      void SetQuantumQuantum(QuantumInfo *quantum_info,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum: the quantum quantum.\n%\n*/\nMagickExport void SetQuantumQuantum(QuantumInfo *quantum_info,\n  const size_t quantum)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->quantum=quantum;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m S c a l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumScale() sets the quantum scale.\n%\n%  The format of the SetQuantumScale method is:\n%\n%      void SetQuantumScale(QuantumInfo *quantum_info,const double scale)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o scale: the quantum scale.\n%\n*/\nMagickExport void SetQuantumScale(QuantumInfo *quantum_info,const double scale)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->scale=scale;\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%                   IIIII  M   M  PPPP    OOO   RRRR   TTTTT                  %\n%                     I    MM MM  P   P  O   O  R   R    T                    %\n%                     I    M M M  PPPP   O   O  RRRR     T                    %\n%                     I    M   M  P      O   O  R R      T                    %\n%                   IIIII  M   M  P       OOO   R  R     T                    %\n%                                                                             %\n%                 MagickCore Methods to Import Quantum Pixels                 %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m p o r t Q u a n t u m P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImportQuantumPixels() transfers one or more pixel components from a user\n%  supplied buffer into the image pixel cache of an image.  The pixels are\n%  expected in network byte order.  It returns MagickTrue if the pixels are\n%  successfully transferred, otherwise MagickFalse.\n%\n%  The format of the ImportQuantumPixels method is:\n%\n%      size_t ImportQuantumPixels(const Image *image,CacheView *image_view,\n%        QuantumInfo *quantum_info,const QuantumType quantum_type,\n%        const unsigned char *magick_restrict pixels,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o image_view: the image cache view.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n%    o pixels:  The pixel components are transferred from this buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PushColormapIndex(const Image *image,const size_t index,\n  MagickBooleanType *range_exception)\n{\n  if (index < image->colors)\n    return((Quantum) index);\n  *range_exception=MagickTrue;\n  return((Quantum) 0);\n}\n\nstatic inline const unsigned char *PushDoublePixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,double *pixel)\n{\n  double\n    *p;\n\n  unsigned char\n    quantum[8];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      quantum[4]=(*pixels++);\n      quantum[5]=(*pixels++);\n      quantum[6]=(*pixels++);\n      quantum[7]=(*pixels++);\n      p=(double *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[7]=(*pixels++);\n  quantum[6]=(*pixels++);\n  quantum[5]=(*pixels++);\n  quantum[4]=(*pixels++);\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(double *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushFloatPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,float *pixel)\n{\n  float\n    *p;\n\n  unsigned char\n    quantum[4];\n\n  if (quantum_info->endian == LSBEndian)\n    {\n      quantum[0]=(*pixels++);\n      quantum[1]=(*pixels++);\n      quantum[2]=(*pixels++);\n      quantum[3]=(*pixels++);\n      p=(float *) quantum;\n      *pixel=(*p);\n      *pixel-=quantum_info->minimum;\n      *pixel*=quantum_info->scale;\n      return(pixels);\n    }\n  quantum[3]=(*pixels++);\n  quantum[2]=(*pixels++);\n  quantum[1]=(*pixels++);\n  quantum[0]=(*pixels++);\n  p=(float *) quantum;\n  *pixel=(*p);\n  *pixel-=quantum_info->minimum;\n  *pixel*=quantum_info->scale;\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumPixel(QuantumInfo *quantum_info,\n  const unsigned char *magick_restrict pixels,unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=(QuantumAny) 0;\n  for (i=(ssize_t) quantum_info->depth; i > 0L; )\n  {\n    if (quantum_info->state.bits == 0UL)\n      {\n        quantum_info->state.pixel=(*pixels++);\n        quantum_info->state.bits=8UL;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n    *quantum=(unsigned int) ((*quantum << quantum_bits) |\n      ((quantum_info->state.pixel >> quantum_info->state.bits) &~ ((~0UL) <<\n      quantum_bits)));\n  }\n  return(pixels);\n}\n\nstatic inline const unsigned char *PushQuantumLongPixel(\n  QuantumInfo *quantum_info,const unsigned char *magick_restrict pixels,\n  unsigned int *quantum)\n{\n  register ssize_t\n    i;\n\n  register size_t\n    quantum_bits;\n\n  *quantum=0UL;\n  for (i=(ssize_t) quantum_info->depth; i > 0; )\n  {\n    if (quantum_info->state.bits == 0)\n      {\n        pixels=PushLongPixel(quantum_info->endian,pixels,\n          &quantum_info->state.pixel);\n        quantum_info->state.bits=32U;\n      }\n    quantum_bits=(size_t) i;\n    if (quantum_bits > quantum_info->state.bits)\n      quantum_bits=quantum_info->state.bits;\n    *quantum|=(((quantum_info->state.pixel >> (32U-quantum_info->state.bits)) &\n      quantum_info->state.mask[quantum_bits]) << (quantum_info->depth-i));\n    i-=(ssize_t) quantum_bits;\n    quantum_info->state.bits-=quantum_bits;\n  }\n  return(pixels);\n}\n\nstatic void ImportAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBGROQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlackQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportBlueQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 10:\n    {\n      Quantum\n        cbcr[4];\n\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x+=4)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              cbcr[i]=(Quantum) (quantum);\n              n++;\n            }\n            p+=quantum_info->pad;\n            SetPixelRed(image,cbcr[1],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n            SetPixelRed(image,cbcr[3],q);\n            SetPixelGreen(image,cbcr[0],q);\n            SetPixelBlue(image,cbcr[2],q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportCMYKOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  if (image->colorspace != CMYKColorspace)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColorSeparatedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlack(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlack(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlack(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlack(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGrayAlphaQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      bit=0;\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel != 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportGreenQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportIndexQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ?\n              0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ?\n              0x00 : 0x01);\n          SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),\n            q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n            GetPixelIndex(image,q),q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        if (quantum_info->min_is_white == MagickFalse)\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n        else\n          pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) ((*p++ >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportIndexAlphaQuantum(const Image *image,\n  QuantumInfo *quantum_info,const MagickSizeType number_pixels,\n  const unsigned char *magick_restrict p,Quantum *magick_restrict q,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    range_exception;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ColormappedImageRequired\",\"`%s'\",image->filename);\n      return;\n    }\n  range_exception=MagickFalse;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        for (bit=0; bit < 8; bit+=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          q+=GetPixelChannels(image);\n        }\n      }\n      if ((number_pixels % 4) != 0)\n        for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n        {\n          if (quantum_info->min_is_white == MagickFalse)\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) == 0 ? 0x00 : 0x01);\n          else\n            pixel=(unsigned char) (((*p) & (1 << (7-bit))) != 0 ? 0x00 : 0x01);\n          SetPixelIndex(image,(Quantum) (pixel == 0 ? 0 : 1),q);\n          SetPixelGray(image,(Quantum) (pixel == 0 ? 0 : QuantumRange),q);\n          SetPixelAlpha(image,((*p) & (1UL << (unsigned char) (6-bit))) == 0 ?\n            TransparentAlpha : OpaqueAlpha,q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(\n              (double) QuantumRange*HalfToSinglePrecision(pixel)),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,\n              ClampToQuantum(pixel),&range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelIndex(image,PushColormapIndex(image,ClampToQuantum(pixel),\n              &range_exception),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              GetPixelIndex(image,q),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelIndex(image,PushColormapIndex(image,pixel,&range_exception),q);\n        SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n          GetPixelIndex(image,q),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n  if (range_exception != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      \"InvalidColormapIndex\",\"`%s'\",image->filename);\n}\n\nstatic void ImportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRedQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),q);\n            SetPixelGreen(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            SetPixelBlue(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch (x % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+1) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            switch ((x+bit) % 3)\n            {\n              default:\n              case 0:\n              {\n                SetPixelRed(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 1:\n              {\n                SetPixelGreen(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                break;\n              }\n              case 2:\n              {\n                SetPixelBlue(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n                  range),q);\n                q+=GetPixelChannels(image);\n                break;\n              }\n            }\n            p+=quantum_info->pad;\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      if (quantum_info->quantum == 32U)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n            p=PushQuantumLongPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelAlpha(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nstatic void ImportRGBOQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelRed(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelGreen(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelBlue(image,ScaleCharToQuantum(pixel),q);\n        p=PushCharPixel(p,&pixel);\n        SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      pixel=0;\n      if (quantum_info->pack == MagickFalse)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            quantum;\n\n          ssize_t\n            n;\n\n          n=0;\n          quantum=0;\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            for (i=0; i < 4; i++)\n            {\n              switch (n % 3)\n              {\n                case 0:\n                {\n                  p=PushLongPixel(quantum_info->endian,p,&pixel);\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 22) & 0x3ff) << 6)));\n                  break;\n                }\n                case 1:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 12) & 0x3ff) << 6)));\n                  break;\n                }\n                case 2:\n                {\n                  quantum=(size_t) (ScaleShortToQuantum((unsigned short)\n                    (((pixel >> 2) & 0x3ff) << 6)));\n                  break;\n                }\n              }\n              switch (i)\n              {\n                case 0: SetPixelRed(image,(Quantum) quantum,q); break;\n                case 1: SetPixelGreen(image,(Quantum) quantum,q); break;\n                case 2: SetPixelBlue(image,(Quantum) quantum,q); break;\n                case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;\n              }\n              n++;\n            }\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),\n          q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelRed(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGreen(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelBlue(image,ClampToQuantum(pixel),q);\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelOpacity(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}\n\nMagickExport size_t ImportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,const unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  register const unsigned char\n    *magick_restrict p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (const unsigned char *) NULL)\n    pixels=(const unsigned char *) GetQuantumPixels(quantum_info);\n  x=0;\n  p=pixels;\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      q=GetAuthenticPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_view);\n      q=GetCacheViewAuthenticPixelQueue(image_view);\n    }\n  ResetQuantumState(quantum_info);\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  switch (quantum_type)\n  {\n    case AlphaQuantum:\n    {\n      ImportAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRQuantum:\n    {\n      ImportBGRQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGRAQuantum:\n    {\n      ImportBGRAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BGROQuantum:\n    {\n      ImportBGROQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlackQuantum:\n    {\n      ImportBlackQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case BlueQuantum:\n    case YellowQuantum:\n    {\n      ImportBlueQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKQuantum:\n    {\n      ImportCMYKQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKAQuantum:\n    {\n      ImportCMYKAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CMYKOQuantum:\n    {\n      ImportCMYKOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case CbYCrYQuantum:\n    {\n      ImportCbYCrYQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayQuantum:\n    {\n      ImportGrayQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GrayAlphaQuantum:\n    {\n      ImportGrayAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case GreenQuantum:\n    case MagentaQuantum:\n    {\n      ImportGreenQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexQuantum:\n    {\n      ImportIndexQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case IndexAlphaQuantum:\n    {\n      ImportIndexAlphaQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case OpacityQuantum:\n    {\n      ImportOpacityQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RedQuantum:\n    case CyanQuantum:\n    {\n      ImportRedQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBQuantum:\n    case CbYCrQuantum:\n    {\n      ImportRGBQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBAQuantum:\n    case CbYCrAQuantum:\n    {\n      ImportRGBAQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    case RGBOQuantum:\n    {\n      ImportRGBOQuantum(image,quantum_info,number_pixels,p,q,exception);\n      break;\n    }\n    default:\n      break;\n  }\n  if ((quantum_type == CbYCrQuantum) || (quantum_type == CbYCrAQuantum))\n    {\n      Quantum\n        quantum;\n\n      register Quantum\n        *magick_restrict q;\n\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        quantum=GetPixelRed(image,q);\n        SetPixelRed(image,GetPixelGreen(image,q),q);\n        SetPixelGreen(image,quantum,q);\n        q+=GetPixelChannels(image);\n      }\n    }\n  if (quantum_info->alpha_type == DisassociatedQuantumAlpha)\n    {\n      double\n        gamma,\n        Sa;\n\n      register Quantum\n        *magick_restrict q;\n\n      /*\n        Disassociate alpha.\n      */\n      q=GetAuthenticPixelQueue(image);\n      if (image_view != (CacheView *) NULL)\n        q=GetCacheViewAuthenticPixelQueue(image_view);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        register ssize_t\n          i;\n\n        if (GetPixelReadMask(image,q) == 0)\n          {\n            q+=GetPixelChannels(image);\n            continue;\n          }\n        Sa=QuantumScale*GetPixelAlpha(image,q);\n        gamma=PerceptibleReciprocal(Sa);\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          if ((channel == AlphaPixelChannel) ||\n              ((traits & UpdatePixelTrait) == 0))\n            continue;\n          q[i]=ClampToQuantum(gamma*q[i]);\n        }\n        q+=GetPixelChannels(image);\n      }\n    }\n  return(extent);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                QQQ   U   U   AAA   N   N  TTTTT  U   U  M   M               %\n%               Q   Q  U   U  A   A  NN  N    T    U   U  MM MM               %\n%               Q   Q  U   U  AAAAA  N N N    T    U   U  M M M               %\n%               Q  QQ  U   U  A   A  N  NN    T    U   U  M   M               %\n%                QQQQ   UUU   A   A  N   N    T     UUU   M   M               %\n%                                                                             %\n%             MagicCore Methods to Acquire / Destroy Quantum Pixels           %\n%                                                                             %\n%                             Software Design                                 %\n%                                  Cristy                                     %\n%                               October 1998                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/stream.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Define declarations.\n*/\n#define QuantumSignature  0xab\n\f\n/*\n  Forward declarations.\n*/\nstatic void\n  DestroyQuantumPixels(QuantumInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e Q u a n t u m I n f o                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumInfo() allocates the QuantumInfo structure.\n%\n%  The format of the AcquireQuantumInfo method is:\n%\n%      QuantumInfo *AcquireQuantumInfo(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n*/\nMagickExport QuantumInfo *AcquireQuantumInfo(const ImageInfo *image_info,\n  Image *image)\n{\n  MagickBooleanType\n    status;\n\n  QuantumInfo\n    *quantum_info;\n\n  quantum_info=(QuantumInfo *) AcquireMagickMemory(sizeof(*quantum_info));\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  quantum_info->signature=MagickCoreSignature;\n  GetQuantumInfo(image_info,quantum_info);\n  if (image == (const Image *) NULL)\n    return(quantum_info);\n  status=SetQuantumDepth(image,quantum_info,image->depth);\n  quantum_info->endian=image->endian;\n  if (status == MagickFalse)\n    quantum_info=DestroyQuantumInfo(quantum_info);\n  return(quantum_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e Q u a n t u m P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireQuantumPixels() allocates the pixel staging areas.\n%\n%  The format of the AcquireQuantumPixels method is:\n%\n%      MagickBooleanType AcquireQuantumPixels(QuantumInfo *quantum_info,\n%        const size_t extent)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o extent: the quantum info.\n%\n*/\nstatic MagickBooleanType AcquireQuantumPixels(QuantumInfo *quantum_info,\n  const size_t extent)\n{\n  register ssize_t\n    i;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  quantum_info->pixels=(unsigned char **) AcquireQuantumMemory(\n    quantum_info->number_threads,sizeof(*quantum_info->pixels));\n  if (quantum_info->pixels == (unsigned char **) NULL)\n    return(MagickFalse);\n  quantum_info->extent=extent;\n  (void) ResetMagickMemory(quantum_info->pixels,0,quantum_info->number_threads*\n    sizeof(*quantum_info->pixels));\n  for (i=0; i < (ssize_t) quantum_info->number_threads; i++)\n  {\n    quantum_info->pixels[i]=(unsigned char *) AcquireQuantumMemory(extent+1,\n      sizeof(**quantum_info->pixels));\n    if (quantum_info->pixels[i] == (unsigned char *) NULL)\n      {\n        while (--i >= 0)\n          quantum_info->pixels[i]=(unsigned char *) RelinquishMagickMemory(\n            quantum_info->pixels[i]);\n        return(MagickFalse);\n      }\n    (void) ResetMagickMemory(quantum_info->pixels[i],0,(extent+1)*\n      sizeof(**quantum_info->pixels));\n    quantum_info->pixels[i][extent]=QuantumSignature;\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y Q u a n t u m I n f o                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyQuantumInfo() deallocates memory associated with the QuantumInfo\n%  structure.\n%\n%  The format of the DestroyQuantumInfo method is:\n%\n%      QuantumInfo *DestroyQuantumInfo(QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport QuantumInfo *DestroyQuantumInfo(QuantumInfo *quantum_info)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (quantum_info->pixels != (unsigned char **) NULL)\n    DestroyQuantumPixels(quantum_info);\n  if (quantum_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&quantum_info->semaphore);\n  quantum_info->signature=(~MagickCoreSignature);\n  quantum_info=(QuantumInfo *) RelinquishMagickMemory(quantum_info);\n  return(quantum_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y Q u a n t u m P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyQuantumPixels() destroys the quantum pixels.\n%\n%  The format of the DestroyQuantumPixels() method is:\n%\n%      void DestroyQuantumPixels(QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nstatic void DestroyQuantumPixels(QuantumInfo *quantum_info)\n{\n  register ssize_t\n    i;\n\n  ssize_t\n    extent;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  assert(quantum_info->pixels != (unsigned char **) NULL);\n  extent=(ssize_t) quantum_info->extent;\n  for (i=0; i < (ssize_t) quantum_info->number_threads; i++)\n    if (quantum_info->pixels[i] != (unsigned char *) NULL)\n      {\n        /*\n          Did we overrun our quantum buffer?\n        */\n        assert(quantum_info->pixels[i][extent] == QuantumSignature);\n        quantum_info->pixels[i]=(unsigned char *) RelinquishMagickMemory(\n          quantum_info->pixels[i]);\n      }\n  quantum_info->pixels=(unsigned char **) RelinquishMagickMemory(\n    quantum_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m E x t e n t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumExtent() returns the quantum pixel buffer extent.\n%\n%  The format of the GetQuantumExtent method is:\n%\n%      size_t GetQuantumExtent(Image *image,const QuantumInfo *quantum_info,\n%        const QuantumType quantum_type)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n*/\nMagickExport size_t GetQuantumExtent(const Image *image,\n  const QuantumInfo *quantum_info,const QuantumType quantum_type)\n{\n  size_t\n    extent,\n    packet_size;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  packet_size=1;\n  switch (quantum_type)\n  {\n    case GrayAlphaQuantum: packet_size=2; break;\n    case IndexAlphaQuantum: packet_size=2; break;\n    case RGBQuantum: packet_size=3; break;\n    case BGRQuantum: packet_size=3; break;\n    case RGBAQuantum: packet_size=4; break;\n    case RGBOQuantum: packet_size=4; break;\n    case BGRAQuantum: packet_size=4; break;\n    case CMYKQuantum: packet_size=4; break;\n    case CMYKAQuantum: packet_size=5; break;\n    case CbYCrAQuantum: packet_size=4; break;\n    case CbYCrQuantum: packet_size=3; break;\n    case CbYCrYQuantum: packet_size=4; break;\n    default: break;\n  }\n  extent=MagickMax(image->columns,image->rows);\n  if (quantum_info->pack == MagickFalse)\n    return((size_t) (packet_size*extent*((quantum_info->depth+7)/8)));\n  return((size_t) ((packet_size*extent*quantum_info->depth+7)/8));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m E n d i a n                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumEndian() returns the quantum endian of the image.\n%\n%  The endian of the GetQuantumEndian method is:\n%\n%      EndianType GetQuantumEndian(const QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport EndianType GetQuantumEndian(const QuantumInfo *quantum_info)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  return(quantum_info->endian);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m F o r m a t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumFormat() returns the quantum format of the image.\n%\n%  The format of the GetQuantumFormat method is:\n%\n%      QuantumFormatType GetQuantumFormat(const QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport QuantumFormatType GetQuantumFormat(const QuantumInfo *quantum_info)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  return(quantum_info->format);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m I n f o                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumInfo() initializes the QuantumInfo structure to default values.\n%\n%  The format of the GetQuantumInfo method is:\n%\n%      GetQuantumInfo(const ImageInfo *image_info,QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickExport void GetQuantumInfo(const ImageInfo *image_info,\n  QuantumInfo *quantum_info)\n{\n  const char\n    *option;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  (void) ResetMagickMemory(quantum_info,0,sizeof(*quantum_info));\n  quantum_info->quantum=8;\n  quantum_info->maximum=1.0;\n  quantum_info->scale=QuantumRange;\n  quantum_info->pack=MagickTrue;\n  quantum_info->semaphore=AcquireSemaphoreInfo();\n  quantum_info->signature=MagickCoreSignature;\n  if (image_info == (const ImageInfo *) NULL)\n    return;\n  option=GetImageOption(image_info,\"quantum:format\");\n  if (option != (char *) NULL)\n    quantum_info->format=(QuantumFormatType) ParseCommandOption(\n      MagickQuantumFormatOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"quantum:minimum\");\n  if (option != (char *) NULL)\n    quantum_info->minimum=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(image_info,\"quantum:maximum\");\n  if (option != (char *) NULL)\n    quantum_info->maximum=StringToDouble(option,(char **) NULL);\n  if ((quantum_info->minimum == 0.0) && (quantum_info->maximum == 0.0))\n    quantum_info->scale=0.0;\n  else\n    if (quantum_info->minimum == quantum_info->maximum)\n      {\n        quantum_info->scale=(double) QuantumRange/quantum_info->minimum;\n        quantum_info->minimum=0.0;\n      }\n    else\n      quantum_info->scale=(double) QuantumRange/(quantum_info->maximum-\n        quantum_info->minimum);\n  option=GetImageOption(image_info,\"quantum:scale\");\n  if (option != (char *) NULL)\n    quantum_info->scale=StringToDouble(option,(char **) NULL);\n  option=GetImageOption(image_info,\"quantum:polarity\");\n  if (option != (char *) NULL)\n    quantum_info->min_is_white=LocaleCompare(option,\"min-is-white\") == 0 ?\n      MagickTrue : MagickFalse;\n  quantum_info->endian=image_info->endian;\n  ResetQuantumState(quantum_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumPixels() returns the quantum pixels.\n%\n%  The format of the GetQuantumPixels method is:\n%\n%      unsigned char *QuantumPixels GetQuantumPixels(\n%        const QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned char *GetQuantumPixels(const QuantumInfo *quantum_info)\n{\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  return(quantum_info->pixels[id]);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t Q u a n t u m T y p e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetQuantumType() returns the quantum type of the image.\n%\n%  The format of the GetQuantumType method is:\n%\n%      QuantumType GetQuantumType(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport QuantumType GetQuantumType(Image *image,ExceptionInfo *exception)\n{\n  QuantumType\n    quantum_type;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  (void) exception;\n  quantum_type=RGBQuantum;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    quantum_type=RGBAQuantum;\n  if (image->colorspace == CMYKColorspace)\n    {\n      quantum_type=CMYKQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=CMYKAQuantum;\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    {\n      quantum_type=GrayQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=GrayAlphaQuantum;\n    }\n  if (image->storage_class == PseudoClass)\n    {\n      quantum_type=IndexQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=IndexAlphaQuantum;\n    }\n  return(quantum_type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e s e t Q u a n t u m S t a t e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetQuantumState() resets the quantum state.\n%\n%  The format of the ResetQuantumState method is:\n%\n%      void ResetQuantumState(QuantumInfo *quantum_info)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n*/\nMagickPrivate void ResetQuantumState(QuantumInfo *quantum_info)\n{\n  static const unsigned int mask[32] =\n  {\n    0x00000000U, 0x00000001U, 0x00000003U, 0x00000007U, 0x0000000fU,\n    0x0000001fU, 0x0000003fU, 0x0000007fU, 0x000000ffU, 0x000001ffU,\n    0x000003ffU, 0x000007ffU, 0x00000fffU, 0x00001fffU, 0x00003fffU,\n    0x00007fffU, 0x0000ffffU, 0x0001ffffU, 0x0003ffffU, 0x0007ffffU,\n    0x000fffffU, 0x001fffffU, 0x003fffffU, 0x007fffffU, 0x00ffffffU,\n    0x01ffffffU, 0x03ffffffU, 0x07ffffffU, 0x0fffffffU, 0x1fffffffU,\n    0x3fffffffU, 0x7fffffffU\n  };\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->state.inverse_scale=1.0;\n  if (fabs(quantum_info->scale) >= MagickEpsilon)\n    quantum_info->state.inverse_scale/=quantum_info->scale;\n  quantum_info->state.pixel=0U;\n  quantum_info->state.bits=0U;\n  quantum_info->state.mask=mask;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m F o r m a t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumAlphaType() sets the quantum format.\n%\n%  The format of the SetQuantumAlphaType method is:\n%\n%      void SetQuantumAlphaType(QuantumInfo *quantum_info,\n%        const QuantumAlphaType type)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o type: the alpha type (e.g. associate).\n%\n*/\nMagickExport void SetQuantumAlphaType(QuantumInfo *quantum_info,\n  const QuantumAlphaType type)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->alpha_type=type;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m D e p t h                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumDepth() sets the quantum depth.\n%\n%  The format of the SetQuantumDepth method is:\n%\n%      MagickBooleanType SetQuantumDepth(const Image *image,\n%        QuantumInfo *quantum_info,const size_t depth)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o depth: the quantum depth.\n%\n*/\nMagickExport MagickBooleanType SetQuantumDepth(const Image *image,\n  QuantumInfo *quantum_info,const size_t depth)\n{\n  size_t\n    extent,\n    quantum;\n\n  /*\n    Allocate the quantum pixel buffer.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->depth=depth;\n  if (quantum_info->format == FloatingPointQuantumFormat)\n    {\n      if (quantum_info->depth > 32)\n        quantum_info->depth=64;\n      else\n        if (quantum_info->depth > 16)\n          quantum_info->depth=32;\n        else\n          quantum_info->depth=16;\n    }\n  if (quantum_info->pixels != (unsigned char **) NULL)\n    DestroyQuantumPixels(quantum_info);\n  quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;\n  extent=MagickMax(image->columns,image->rows)*quantum;\n  if ((MagickMax(image->columns,image->rows) != 0) &&\n      (quantum != (extent/MagickMax(image->columns,image->rows))))\n    return(MagickFalse);\n  return(AcquireQuantumPixels(quantum_info,extent));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m E n d i a n                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumEndian() sets the quantum endian.\n%\n%  The endian of the SetQuantumEndian method is:\n%\n%      MagickBooleanType SetQuantumEndian(const Image *image,\n%        QuantumInfo *quantum_info,const EndianType endian)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o endian: the quantum endian.\n%\n*/\nMagickExport MagickBooleanType SetQuantumEndian(const Image *image,\n  QuantumInfo *quantum_info,const EndianType endian)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->endian=endian;\n  return(SetQuantumDepth(image,quantum_info,quantum_info->depth));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m F o r m a t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumFormat() sets the quantum format.\n%\n%  The format of the SetQuantumFormat method is:\n%\n%      MagickBooleanType SetQuantumFormat(const Image *image,\n%        QuantumInfo *quantum_info,const QuantumFormatType format)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o format: the quantum format.\n%\n*/\nMagickExport MagickBooleanType SetQuantumFormat(const Image *image,\n  QuantumInfo *quantum_info,const QuantumFormatType format)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->format=format;\n  return(SetQuantumDepth(image,quantum_info,quantum_info->depth));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m I m a g e T y p e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumImageType() sets the image type based on the quantum type.\n%\n%  The format of the SetQuantumImageType method is:\n%\n%      void ImageType SetQuantumImageType(Image *image,\n%        const QuantumType quantum_type)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_type: Declare which pixel components to transfer (red, green,\n%      blue, opacity, RGB, or RGBA).\n%\n*/\nMagickExport void SetQuantumImageType(Image *image,\n  const QuantumType quantum_type)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  switch (quantum_type)\n  {\n    case IndexQuantum:\n    case IndexAlphaQuantum:\n    {\n      image->type=PaletteType;\n      break;\n    }\n    case GrayQuantum:\n    case GrayAlphaQuantum:\n    {\n      image->type=GrayscaleType;\n      if (image->depth == 1)\n        image->type=BilevelType;\n      break;\n    }\n    case CyanQuantum:\n    case MagentaQuantum:\n    case YellowQuantum:\n    case BlackQuantum:\n    case CMYKQuantum:\n    case CMYKAQuantum:\n    {\n      image->type=ColorSeparationType;\n      break;\n    }\n    default:\n    {\n      image->type=TrueColorType;\n      break;\n    }\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m P a c k                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumPack() sets the quantum pack flag.\n%\n%  The format of the SetQuantumPack method is:\n%\n%      void SetQuantumPack(QuantumInfo *quantum_info,\n%        const MagickBooleanType pack)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o pack: the pack flag.\n%\n*/\nMagickExport void SetQuantumPack(QuantumInfo *quantum_info,\n  const MagickBooleanType pack)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->pack=pack;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m P a d                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumPad() sets the quantum pad.\n%\n%  The format of the SetQuantumPad method is:\n%\n%      MagickBooleanType SetQuantumPad(const Image *image,\n%        QuantumInfo *quantum_info,const size_t pad)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o quantum_info: the quantum info.\n%\n%    o pad: the quantum pad.\n%\n*/\nMagickExport MagickBooleanType SetQuantumPad(const Image *image,\n  QuantumInfo *quantum_info,const size_t pad)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->pad=pad;\n  return(SetQuantumDepth(image,quantum_info,quantum_info->depth));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m M i n I s W h i t e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumMinIsWhite() sets the quantum min-is-white flag.\n%\n%  The format of the SetQuantumMinIsWhite method is:\n%\n%      void SetQuantumMinIsWhite(QuantumInfo *quantum_info,\n%        const MagickBooleanType min_is_white)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o min_is_white: the min-is-white flag.\n%\n*/\nMagickExport void SetQuantumMinIsWhite(QuantumInfo *quantum_info,\n  const MagickBooleanType min_is_white)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->min_is_white=min_is_white;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m Q u a n t u m                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumQuantum() sets the quantum quantum.\n%\n%  The format of the SetQuantumQuantum method is:\n%\n%      void SetQuantumQuantum(QuantumInfo *quantum_info,\n%        const size_t quantum)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o quantum: the quantum quantum.\n%\n*/\nMagickExport void SetQuantumQuantum(QuantumInfo *quantum_info,\n  const size_t quantum)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->quantum=quantum;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t Q u a n t u m S c a l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetQuantumScale() sets the quantum scale.\n%\n%  The format of the SetQuantumScale method is:\n%\n%      void SetQuantumScale(QuantumInfo *quantum_info,const double scale)\n%\n%  A description of each parameter follows:\n%\n%    o quantum_info: the quantum info.\n%\n%    o scale: the quantum scale.\n%\n*/\nMagickExport void SetQuantumScale(QuantumInfo *quantum_info,const double scale)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->scale=scale;\n}\n"], "filenames": ["MagickCore/quantum-import.c", "MagickCore/quantum.c"], "buggy_code_start_loc": [1426, 331], "buggy_code_end_loc": [1427, 898], "fixing_code_start_loc": [1426, 332], "fixing_code_end_loc": [1427, 898], "type": "CWE-125", "message": "The generic decoder in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted file.", "other": {"cve": {"id": "CVE-2016-7534", "sourceIdentifier": "security@debian.org", "published": "2017-04-20T18:59:01.357", "lastModified": "2017-05-09T12:39:03.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The generic decoder in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted file."}, {"lang": "es", "value": "El descodificador gen\u00e9rico en ImageMagick permite a atacantes remotos provocar una denegaci\u00f3n de servicio (acceso fuera de los l\u00edmites) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:-:*:*:*:*:*:*:*", "matchCriteriaId": "6E6BE7A5-6FF7-4916-B671-9EE11CA54F65"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93131", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1542785", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378767", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/430403b0029b37decf216d57f810899cab2317dd", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/126", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/430403b0029b37decf216d57f810899cab2317dd"}}