{"buggy_code": ["/*\n * dhcp.c\tFunctions to send/receive dhcp packets.\n *\n * Version:\t$Id$\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n *\n * Copyright 2008 The FreeRADIUS server project\n * Copyright 2008 Alan DeKok <aland@deployingradius.com>\n */\n\n#include\t<freeradius-devel/ident.h>\nRCSID(\"$Id$\")\n\n#include <freeradius-devel/libradius.h>\n#include <freeradius-devel/udpfromto.h>\n#include <freeradius-devel/dhcp.h>\n\n#ifdef WITH_DHCP\n#define DHCP_CHADDR_LEN\t(16)\n#define DHCP_SNAME_LEN\t(64)\n#define DHCP_FILE_LEN\t(128)\n#define DHCP_VEND_LEN\t(308)\n#define DHCP_OPTION_MAGIC_NUMBER (0x63825363)\n\n#ifndef INADDR_BROADCAST\n#define INADDR_BROADCAST INADDR_NONE\n#endif\n\ntypedef struct dhcp_packet_t {\n\tuint8_t\t\topcode;\n\tuint8_t\t\thtype;\n\tuint8_t\t\thlen;\n\tuint8_t\t\thops;\n\tuint32_t\txid;\t/* 4 */\n\tuint16_t\tsecs;\t/* 8 */\n\tuint16_t\tflags;\n\tuint32_t\tciaddr;\t/* 12 */\n\tuint32_t\tyiaddr;\t/* 16 */\n\tuint32_t\tsiaddr;\t/* 20 */\n\tuint32_t\tgiaddr;\t/* 24 */\n\tuint8_t\t\tchaddr[DHCP_CHADDR_LEN]; /* 28 */\n\tuint8_t\t\tsname[DHCP_SNAME_LEN]; /* 44 */\n\tuint8_t\t\tfile[DHCP_FILE_LEN]; /* 108 */\n\tuint32_t\toption_format; /* 236 */\n\tuint8_t\t\toptions[DHCP_VEND_LEN];\n} dhcp_packet_t;\n\ntypedef struct dhcp_option_t {\n\tuint8_t\t\tcode;\n\tuint8_t\t\tlength;\n} dhcp_option_t;\n\n/*\n *\tINADDR_ANY : 68 -> INADDR_BROADCAST : 67\tDISCOVER\n *\tINADDR_BROADCAST : 68 <- SERVER_IP : 67\t\tOFFER\n *\tINADDR_ANY : 68 -> INADDR_BROADCAST : 67\tREQUEST\n *\tINADDR_BROADCAST : 68 <- SERVER_IP : 67\t\tACK\n */\nstatic const char *dhcp_header_names[] = {\n\t\"DHCP-Opcode\",\n\t\"DHCP-Hardware-Type\",\n\t\"DHCP-Hardware-Address-Length\",\n\t\"DHCP-Hop-Count\",\n\t\"DHCP-Transaction-Id\",\n\t\"DHCP-Number-of-Seconds\",\n\t\"DHCP-Flags\",\n\t\"DHCP-Client-IP-Address\",\n\t\"DHCP-Your-IP-Address\",\n\t\"DHCP-Server-IP-Address\",\n\t\"DHCP-Gateway-IP-Address\",\n\t\"DHCP-Client-Hardware-Address\",\n\t\"DHCP-Server-Host-Name\",\n\t\"DHCP-Boot-Filename\",\n\n\tNULL\n};\n\nstatic const char *dhcp_message_types[] = {\n\t\"invalid\",\n\t\"DHCP-Discover\",\n\t\"DHCP-Offer\",\n\t\"DHCP-Request\",\n\t\"DHCP-Decline\",\n\t\"DHCP-Ack\",\n\t\"DHCP-NAK\",\n\t\"DHCP-Release\",\n\t\"DHCP-Inform\",\n\t\"DHCP-Force-Renew\",\n};\n\nstatic int dhcp_header_sizes[] = {\n\t1, 1, 1, 1,\n\t4, 2, 2, 4,\n\t4, 4, 4,\n\tDHCP_CHADDR_LEN,\n\tDHCP_SNAME_LEN,\n\tDHCP_FILE_LEN\n};\n\n\n/*\n *\tSome clients silently ignore responses less than 300 bytes.\n */\n#define MIN_PACKET_SIZE (244)\n#define DEFAULT_PACKET_SIZE (300)\n#define MAX_PACKET_SIZE (1500 - 40)\n\n#define DHCP_OPTION_FIELD (0)\n#define DHCP_FILE_FIELD\t  (1)\n#define DHCP_SNAME_FIELD  (2)\n\nstatic uint8_t *dhcp_get_option(dhcp_packet_t *packet, size_t packet_size,\n\t\t\t\tunsigned int option)\n\t\t\t\t\n{\n\tint overload = 0;\n\tint field = DHCP_OPTION_FIELD;\n\tsize_t where, size;\n\tuint8_t *data = packet->options;\n\n\twhere = 0;\n\tsize = packet_size - offsetof(dhcp_packet_t, options);\n\tdata = &packet->options[where];\n\n\twhile (where < size) {\n\t\tif (data[0] == 0) { /* padding */\n\t\t\twhere++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data[0] == 255) { /* end of options */\n\t\t\tif ((field == DHCP_OPTION_FIELD) &&\n\t\t\t    (overload & DHCP_FILE_FIELD)) {\n\t\t\t\tdata = packet->file;\n\t\t\t\twhere = 0;\n\t\t\t\tsize = sizeof(packet->file);\n\t\t\t\tfield = DHCP_FILE_FIELD;\n\t\t\t\tcontinue;\n\n\t\t\t} else if ((field == DHCP_FILE_FIELD) &&\n\t\t\t\t   (overload && DHCP_SNAME_FIELD)) {\n\t\t\t\tdata = packet->sname;\n\t\t\t\twhere = 0;\n\t\t\t\tsize = sizeof(packet->sname);\n\t\t\t\tfield = DHCP_SNAME_FIELD;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t *\tWe MUST have a real option here.\n\t\t */\n\t\tif ((where + 2) > size) {\n\t\t\tfr_strerror_printf(\"Options overflow field at %u\",\n\t\t\t\t\t   (unsigned int) (data - (uint8_t *) packet));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((where + 2 + data[1]) > size) {\n\t\t\tfr_strerror_printf(\"Option length overflows field at %u\",\n\t\t\t\t\t   (unsigned int) (data - (uint8_t *) packet));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (data[0] == option) return data;\n\n\t\tif (data[0] == 52) { /* overload sname and/or file */\n\t\t\toverload = data[3];\n\t\t}\n\n\t\twhere += data[1] + 2;\n\t\tdata += data[1] + 2;\n\t}\n\n\treturn NULL;\n}\n\n/*\n *\tDHCPv4 is only for IPv4.  Broadcast only works if udpfromto is\n *\tdefined.\n */\nRADIUS_PACKET *fr_dhcp_recv(int sockfd)\n{\n\tuint32_t\t\tmagic;\n\tstruct sockaddr_storage\tsrc;\n\tstruct sockaddr_storage\tdst;\n\tsocklen_t\t\tsizeof_src;\n\tsocklen_t\t        sizeof_dst;\n\tRADIUS_PACKET\t\t*packet;\n\tint port;\n\tuint8_t\t\t\t*code;\n\n\tpacket = rad_alloc(0);\n\tif (!packet) {\n\t\tfr_strerror_printf(\"Failed allocating packet\");\n\t\treturn NULL;\n\t}\n\tmemset(packet, 0, sizeof(packet));\n\n\tpacket->data = malloc(MAX_PACKET_SIZE);\n\tif (!packet->data) {\n\t\tfr_strerror_printf(\"Failed in malloc\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tpacket->sockfd = sockfd;\n\tsizeof_src = sizeof(src);\n#ifdef WITH_UDPFROMTO\n\tsizeof_dst = sizeof(dst);\n\tpacket->data_len = recvfromto(sockfd, packet->data, MAX_PACKET_SIZE, 0,\n\t\t\t\t      (struct sockaddr *)&src, &sizeof_src,\n\t\t\t\t      (struct sockaddr *)&dst, &sizeof_dst);\n#else\n\tpacket->data_len = recvfrom(sockfd, packet->data, MAX_PACKET_SIZE, 0,\n\t\t\t\t    (struct sockaddr *)&src, &sizeof_src);\n#endif\n\n\tif (packet->data_len <= 0) {\n\t\tfr_strerror_printf(\"Failed reading DHCP socket: %s\", strerror(errno));\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif (packet->data_len < MIN_PACKET_SIZE) {\n\t\tfr_strerror_printf(\"DHCP packet is too small (%d < %d)\",\n\t\t      packet->data_len, MIN_PACKET_SIZE);\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif (packet->data[1] != 1) {\n\t\tfr_strerror_printf(\"DHCP can only receive ethernet requests, not type %02x\",\n\t\t      packet->data[1]);\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif (packet->data[2] != 6) {\n\t\tfr_strerror_printf(\"Ethernet HW length is wrong length %d\",\n\t\t\tpacket->data[2]);\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(&magic, packet->data + 236, 4);\n\tmagic = ntohl(magic);\n\tif (magic != DHCP_OPTION_MAGIC_NUMBER) {\n\t\tfr_strerror_printf(\"Cannot do BOOTP\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tCreate unique keys for the packet.\n\t */\n\tmemcpy(&magic, packet->data + 4, 4);\n\tpacket->id = ntohl(magic);\n\n\tcode = dhcp_get_option((dhcp_packet_t *) packet->data,\n\t\t\t       packet->data_len, 53);\n\tif (!code) {\n\t\tfr_strerror_printf(\"No message-type option was found in the packet\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif ((code[1] < 1) || (code[2] == 0) || (code[2] > 8)) {\n\t\tfr_strerror_printf(\"Unknown value for message-type option\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tpacket->code = code[2] | PW_DHCP_OFFSET;\n\n\t/*\n\t *\tCreate a unique vector from the MAC address and the\n\t *\tDHCP opcode.  This is a hack for the RADIUS\n\t *\tinfrastructure in the rest of the server.\n\t *\n\t *\tNote: packet->data[2] == 6, which is smaller than\n\t *\tsizeof(packet->vector)\n\t *\n\t *\tFIXME:  Look for client-identifier in packet,\n\t *      and use that, too?\n\t */\n\tmemset(packet->vector, 0, sizeof(packet->vector));\n\tmemcpy(packet->vector, packet->data + 28, packet->data[2]);\n\tpacket->vector[packet->data[2]] = packet->code & 0xff;\n\n\t/*\n\t *\tFIXME: for DISCOVER / REQUEST: src_port == dst_port + 1\n\t *\tFIXME: for OFFER / ACK       : src_port = dst_port - 1\n\t */\n\n\t/*\n\t *\tUnique keys are xid, client mac, and client ID?\n\t */\n\n\t/*\n\t *\tFIXME: More checks, like DHCP packet type?\n\t */\n\n\tsizeof_dst = sizeof(dst);\n\n#ifndef WITH_UDPFROMTO\n\t/*\n\t *\tThis should never fail...\n\t */\n\tgetsockname(sockfd, (struct sockaddr *) &dst, &sizeof_dst);\n#endif\n\t\n\tfr_sockaddr2ipaddr(&dst, sizeof_dst, &packet->dst_ipaddr, &port);\n\tpacket->dst_port = port;\n\n\tfr_sockaddr2ipaddr(&src, sizeof_src, &packet->src_ipaddr, &port);\n\tpacket->src_port = port;\n\n\tif (fr_debug_flag > 1) {\n\t\tchar type_buf[64];\n\t\tconst char *name = type_buf;\n\t\tchar src_ip_buf[256], dst_ip_buf[256];\n\t\t\n\t\tif ((packet->code >= PW_DHCP_DISCOVER) &&\n\t\t    (packet->code <= PW_DHCP_INFORM)) {\n\t\t\tname = dhcp_message_types[packet->code - PW_DHCP_OFFSET];\n\t\t} else {\n\t\t\tsnprintf(type_buf, sizeof(type_buf), \"%d\",\n\t\t\t\t packet->code - PW_DHCP_OFFSET);\n\t\t}\n\n\t\tDEBUG(\"Received %s of id %08x from %s:%d to %s:%d\",\n\t\t       name, (unsigned int) packet->id,\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t src_ip_buf, sizeof(src_ip_buf)),\n\t\t       packet->src_port,\n\t\t       inet_ntop(packet->dst_ipaddr.af,\n\t\t\t\t &packet->dst_ipaddr.ipaddr,\n\t\t\t\t dst_ip_buf, sizeof(dst_ip_buf)),\n\t\t       packet->dst_port);\n\t}\n\n\treturn packet;\n}\n\n\n/*\n *\tSend a DHCP packet.\n */\nint fr_dhcp_send(RADIUS_PACKET *packet)\n{\n\tstruct sockaddr_storage\tdst;\n\tsocklen_t\t\tsizeof_dst;\n#ifdef WITH_UDPFROMTO\n\tstruct sockaddr_storage\tsrc;\n\tsocklen_t\t\tsizeof_src;\n#endif\n\n\tfr_ipaddr2sockaddr(&packet->dst_ipaddr, packet->dst_port,\n\t\t\t   &dst, &sizeof_dst);\n\n#ifndef WITH_UDPFROMTO\n\t/*\n\t *\tAssume that the packet is encoded before sending it.\n\t */\n\treturn sendto(packet->sockfd, packet->data, packet->data_len, 0,\n\t\t      (struct sockaddr *)&dst, sizeof_dst);\n#else\n\tfr_ipaddr2sockaddr(&packet->src_ipaddr, packet->src_port,\n\t\t\t   &src, &sizeof_src);\n\n\treturn sendfromto(packet->sockfd,\n\t\t\t  packet->data, packet->data_len, 0,\n\t\t\t  (struct sockaddr *)&src, sizeof_src,\n\t\t\t  (struct sockaddr *)&dst, sizeof_dst);\n#endif\n}\n\nstatic int fr_dhcp_attr2vp(VALUE_PAIR *vp, const uint8_t *p, size_t alen);\n\nstatic int decode_tlv(VALUE_PAIR *tlv, const uint8_t *data, size_t data_len)\n{\n\tconst uint8_t *p;\n\tVALUE_PAIR *head, **tail, *vp;\n\n\t/*\n\t *\tTake a pass at parsing it.\n\t */\n\tp = data;\n\twhile (p < (data + data_len)) {\n\t\tif ((p + 2) > (data + data_len)) goto make_tlv;\n\n\t\tif ((p + p[1] + 2) > (data + data_len)) goto make_tlv;\n\t\tp += 2 + p[1];\n\t}\n\n\t/*\n\t *\tGot here... must be well formed.\n\t */\n\thead = NULL;\n\ttail = &head;\n\n\tp = data;\n\twhile (p < (data + data_len)) {\n\t\tvp = paircreate(tlv->attribute | (p[0] << 8), PW_TYPE_OCTETS);\n\t\tif (!vp) {\n\t\t\tpairfree(&head);\n\t\t\tgoto make_tlv;\n\t\t}\n\n\t\tif (fr_dhcp_attr2vp(vp, p + 2, p[1]) < 0) {\n\t\t\tpairfree(&head);\n\t\t\tgoto make_tlv;\n\t\t}\n\n\t\t*tail = vp;\n\t\ttail = &(vp->next);\n\t\tp += 2 + p[1];\n\t}\n\n\t/*\n\t *\tThe caller allocated TLV, so we need to copy the FIRST\n\t *\tattribute over top of that.\n\t */\n\tmemcpy(tlv, head, sizeof(*tlv));\n\thead->next = NULL;\n\tpairfree(&head);\n\treturn 0;\n\nmake_tlv:\n\ttlv->vp_tlv = malloc(data_len);\n\tif (!tlv->vp_tlv) {\n\t\tfr_strerror_printf(\"No memory\");\n\t\treturn -1;\n\t}\n\tmemcpy(tlv->vp_tlv, data, data_len);\n\ttlv->length = data_len;\n\t\n\treturn 0;\n}\n\n\n/*\n *\tDecode ONE value into a VP\n */\nstatic int fr_dhcp_attr2vp(VALUE_PAIR *vp, const uint8_t *p, size_t alen)\n{\n\tswitch (vp->type) {\n\tcase PW_TYPE_BYTE:\n\t\tif (alen != 1) goto raw;\n\t\tvp->vp_integer = p[0];\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_SHORT:\n\t\tif (alen != 2) goto raw;\n\t\tvp->vp_integer = (p[0] << 8) | p[1];\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_INTEGER:\n\t\tif (alen != 4) goto raw;\n\t\tmemcpy(&vp->vp_integer, p, 4);\n\t\tvp->vp_integer = ntohl(vp->vp_integer);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_IPADDR:\n\t\tif (alen != 4) goto raw;\n\t\tmemcpy(&vp->vp_ipaddr, p , 4);\n\t\tvp->length = 4;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_STRING:\n\t\tif (alen > 253) return -1;\n\t\tmemcpy(vp->vp_strvalue, p , alen);\n\t\tvp->vp_strvalue[alen] = '\\0';\n\t\tbreak;\n\t\t\n\traw:\n\t\tvp->type = PW_TYPE_OCTETS;\n\n\tcase PW_TYPE_OCTETS:\n\t\tif (alen > 253) return -1;\n\t\tmemcpy(vp->vp_octets, p, alen);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_TLV:\n\t\treturn decode_tlv(vp, p, alen);\n\t\t\n\tdefault:\n\t\tfr_strerror_printf(\"Internal sanity check %d %d\", vp->type, __LINE__);\n\t\tbreak;\n\t} /* switch over type */\n\n\tvp->length = alen;\n\treturn 0;\n}\n\nint fr_dhcp_decode(RADIUS_PACKET *packet)\n{\n\tint i;\n\tuint8_t *p, *next;\n\tuint32_t giaddr;\n\tVALUE_PAIR *head, *vp, **tail;\n\tVALUE_PAIR *maxms, *mtu;\n\tchar buffer[2048];\n\n\thead = NULL;\n\ttail = &head;\n\tp = packet->data;\n\t\n\tif ((fr_debug_flag > 2) && fr_log_fp) {\n\t\tfor (i = 0; i < packet->data_len; i++) {\n\t\t\tif ((i & 0x0f) == 0x00) fr_strerror_printf(\"%d: \", i);\n\t\t\tfprintf(fr_log_fp, \"%02x \", packet->data[i]);\n\t\t\tif ((i & 0x0f) == 0x0f) fprintf(fr_log_fp, \"\\n\");\n\t\t}\n\t\tfprintf(fr_log_fp, \"\\n\");\n\t}\n\n\tif (packet->data[1] != 1) {\n\t\tfr_strerror_printf(\"Packet is not Ethernet: %u\",\n\t\t      packet->data[1]);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tDecode the header.\n\t */\n\tfor (i = 0; i < 14; i++) {\n\t\tvp = pairmake(dhcp_header_names[i], NULL, T_OP_EQ);\n\t\tif (!vp) {\n\t\t\tfr_strerror_printf(\"Parse error %s\", fr_strerror());\n\t\t\tpairfree(&head);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((i == 11) && \n\t\t    (packet->data[1] == 1) &&\n\t\t    (packet->data[2] == 6)) {\n\t\t\tvp->type = PW_TYPE_ETHERNET;\n\t\t}\n\n\t\tswitch (vp->type) {\n\t\tcase PW_TYPE_BYTE:\n\t\t\tvp->vp_integer = p[0];\n\t\t\tvp->length = 1;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_SHORT:\n\t\t\tvp->vp_integer = (p[0] << 8) | p[1];\n\t\t\tvp->length = 2;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_INTEGER:\n\t\t\tmemcpy(&vp->vp_integer, p, 4);\n\t\t\tvp->vp_integer = ntohl(vp->vp_integer);\n\t\t\tvp->length = 4;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_IPADDR:\n\t\t\tmemcpy(&vp->vp_ipaddr, p, 4);\n\t\t\tvp->length = 4;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_STRING:\n\t\t\tmemcpy(vp->vp_strvalue, p, dhcp_header_sizes[i]);\n\t\t\tvp->vp_strvalue[dhcp_header_sizes[i]] = '\\0';\n\t\t\tvp->length = strlen(vp->vp_strvalue);\n\t\t\tif (vp->length == 0) {\n\t\t\t\tpairfree(&vp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_OCTETS:\n\t\t\tmemcpy(vp->vp_octets, p, packet->data[2]);\n\t\t\tvp->length = packet->data[2];\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_ETHERNET:\n\t\t\tmemcpy(vp->vp_ether, p, sizeof(vp->vp_ether));\n\t\t\tvp->length = sizeof(vp->vp_ether);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tfr_strerror_printf(\"BAD TYPE %d\", vp->type);\n\t\t\tpairfree(&vp);\n\t\t\tbreak;\n\t\t}\n\t\tp += dhcp_header_sizes[i];\n\n\t\tif (!vp) continue;\n\t\t\n\t\tif (fr_debug_flag > 1) {\n\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t}\n\t\t*tail = vp;\n\t\ttail = &vp->next;\n\t}\n\t\n\t/*\n\t *\tLoop over the options.\n\t */\n\tnext = packet->data + 240;\n\n\t/*\n\t *\tFIXME: This should also check sname && file fields.\n\t *\tSee the dhcp_get_option() function above.\n\t */\n\twhile (next < (packet->data + packet->data_len)) {\n\t\tint num_entries, alen;\n\t\tDICT_ATTR *da;\n\t\t\n\t\tp = next;\n\n\t\tif (*p == 0) break;\n\t\tif (*p == 255) break; /* end of options signifier */\n\t\tif ((p + 2) > (packet->data + packet->data_len)) break;\n\n\t\tnext = p + 2 + p[1];\n\n\t\tif (p[1] >= 253) {\n\t\t\tfr_strerror_printf(\"Attribute too long %u %u\",\n\t\t\t      p[0], p[1]);\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tda = dict_attrbyvalue(DHCP2ATTR(p[0]));\n\t\tif (!da) {\n\t\t\tfr_strerror_printf(\"Attribute not in our dictionary: %u\",\n\t\t\t      p[0]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvp = NULL;\n\t\tnum_entries = 1;\n\t\talen = p[1];\n\t\tp += 2;\n\n\t\t/*\n\t\t *\tCould be an array of bytes, integers, etc.\n\t\t */\n\t\tif (da->flags.array) {\n\t\t\tswitch (da->type) {\n\t\t\tcase PW_TYPE_BYTE:\n\t\t\t\tnum_entries = alen;\n\t\t\t\talen = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase PW_TYPE_SHORT: /* ignore any trailing data */\n\t\t\t\tnum_entries = alen >> 1;\n\t\t\t\talen = 2;\n\t\t\t\tbreak;\n\n\t\t\tcase PW_TYPE_IPADDR:\n\t\t\tcase PW_TYPE_INTEGER:\n\t\t\tcase PW_TYPE_DATE: /* ignore any trailing data */\n\t\t\t\tnum_entries = alen >> 2;\n\t\t\t\talen = 4;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tbreak; /* really an internal sanity failure */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tLoop over all of the entries, building VPs\n\t\t */\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tvp = pairmake(da->name, NULL, T_OP_EQ);\n\t\t\tif (!vp) {\n\t\t\t\tfr_strerror_printf(\"Cannot build attribute %s\",\n\t\t\t\t\tfr_strerror());\n\t\t\t\tpairfree(&head);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tHack for ease of use.\n\t\t\t */\n\t\t\tif ((da->attr == DHCP2ATTR(0x3d)) &&\n\t\t\t    !da->flags.array &&\n\t\t\t    (alen == 7) && (*p == 1) && (num_entries == 1)) {\n\t\t\t\tvp->type = PW_TYPE_ETHERNET;\n\t\t\t\tmemcpy(vp->vp_octets, p + 1, 6);\n\t\t\t\tvp->length = alen;\n\n\t\t\t} else if (fr_dhcp_attr2vp(vp, p, alen) < 0) {\n\t\t\t\t\tpairfree(&vp);\n\t\t\t\t\tpairfree(&head);\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (fr_debug_flag > 1) {\n\t\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t\t}\n\n\t\t\t*tail = vp;\n\t\t\twhile (*tail) tail = &vp->next;\n\t\t\tp += alen;\n\t\t} /* loop over array entries */\n\t} /* loop over the entire packet */\n\n\t/*\n\t *\tIf DHCP request, set ciaddr to zero.\n\t */\n\n\t/*\n\t *\tSet broadcast flag for broken vendors, but only if\n\t *\tgiaddr isn't set.\n\t */\n\tmemcpy(&giaddr, packet->data + 24, sizeof(giaddr));\n\tif (giaddr == htonl(INADDR_ANY)) {\n\t\t/*\n\t\t *\tDHCP Opcode is request\n\t\t */\n\t\tvp = pairfind(head, DHCP2ATTR(256));\n\t\tif (vp && vp->lvalue == 3) {\n\t\t\t/*\n\t\t\t *\tVendor is \"MSFT 98\"\n\t\t\t */\n\t\t\tvp = pairfind(head, DHCP2ATTR(63));\n\t\t\tif (vp && (strcmp(vp->vp_strvalue, \"MSFT 98\") == 0)) {\n\t\t\t\tvp = pairfind(head, DHCP2ATTR(262));\n\n\t\t\t\t/*\n\t\t\t\t *\tReply should be broadcast.\n\t\t\t\t */\n\t\t\t\tif (vp) vp->lvalue |= 0x8000;\n\t\t\t\tpacket->data[10] |= 0x80;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tFIXME: Nuke attributes that aren't used in the normal\n\t *\theader for discover/requests.\n\t */\n\tpacket->vps = head;\n\n\t/*\n\t *\tClient can request a LARGER size, but not a smaller\n\t *\tone.  They also cannot request a size larger than MTU.\n\t */\n\tmaxms = pairfind(packet->vps, DHCP2ATTR(57));\n\tmtu = pairfind(packet->vps, DHCP2ATTR(26));\n\n\tif (mtu && (mtu->vp_integer < DEFAULT_PACKET_SIZE)) {\n\t\tfr_strerror_printf(\"DHCP Fatal: Client says MTU is smaller than minimum permitted by the specification.\");\n\t\treturn -1;\n\t}\n\n\tif (maxms && (maxms->vp_integer < DEFAULT_PACKET_SIZE)) {\n\t\tfr_strerror_printf(\"DHCP WARNING: Client says maximum message size is smaller than minimum permitted by the specification: fixing it\");\n\t\tmaxms->vp_integer = DEFAULT_PACKET_SIZE;\n\t}\n\n\tif (maxms && mtu && (maxms->vp_integer > mtu->vp_integer)) {\n\t\tfr_strerror_printf(\"DHCP WARNING: Client says MTU is smaller than maximum message size: fixing it\");\n\t\tmaxms->vp_integer = mtu->vp_integer;\n\t}\n\n\tif (fr_debug_flag) fflush(stdout);\n\n\treturn 0;\n}\n\n\nstatic int attr_cmp(const void *one, const void *two)\n{\n\tconst VALUE_PAIR * const *a = one;\n\tconst VALUE_PAIR * const *b = two;\n\n\t/*\n\t *\tDHCP-Message-Type is first, for simplicity.\n\t */\n\tif (((*a)->attribute == DHCP2ATTR(53)) &&\n\t    (*b)->attribute != DHCP2ATTR(53)) return -1;\n\n\t/*\n\t *\tRelay-Agent is last\n\t */\n\tif (((*a)->attribute == DHCP2ATTR(82)) &&\n\t    (*b)->attribute != DHCP2ATTR(82)) return +1;\n\n\treturn ((*a)->attribute - (*b)->attribute);\n}\n\n\nstatic size_t fr_dhcp_vp2attr(VALUE_PAIR *vp, uint8_t *p, size_t room)\n{\n\tsize_t length;\n\tuint32_t lvalue;\n\n\t/*\n\t *\tFIXME: Check room!\n\t */\n\troom = room;\t\t/* -Wunused */\n\n\t/*\n\t *\tSearch for all attributes of the same\n\t *\ttype, and pack them into the same\n\t *\tattribute.\n\t */\n\tswitch (vp->type) {\n\tcase PW_TYPE_BYTE:\n\t\tlength = 1;\n\t\t*p = vp->vp_integer & 0xff;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_SHORT:\n\t\tlength = 2;\n\t\tp[0] = (vp->vp_integer >> 8) & 0xff;\n\t\tp[1] = vp->vp_integer & 0xff;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_INTEGER:\n\t\tlength = 4;\n\t\tlvalue = htonl(vp->vp_integer);\n\t\tmemcpy(p, &lvalue, 4);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_IPADDR:\n\t\tlength = 4;\n\t\tmemcpy(p, &vp->vp_ipaddr, 4);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_ETHERNET:\n\t\tlength = 6;\n\t\tmemcpy(p, &vp->vp_ether, 6);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_STRING:\n\t\tmemcpy(p, vp->vp_strvalue, vp->length);\n\t\tlength = vp->length;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_TLV:\t/* FIXME: split it on 255? */\n\t\tmemcpy(p, vp->vp_tlv, vp->length);\n\t\tlength = vp->length;\n\t\tbreak;\n\n\tcase PW_TYPE_OCTETS:\n\t\tmemcpy(p, vp->vp_octets, vp->length);\n\t\tlength = vp->length;\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tfr_strerror_printf(\"BAD TYPE2 %d\", vp->type);\n\t\tlength = 0;\n\t\tbreak;\n\t}\n\n\treturn length;\n}\n\nstatic VALUE_PAIR *fr_dhcp_vp2suboption(VALUE_PAIR *vps)\n{\n\tint length;\n\tunsigned int attribute;\n\tuint8_t *ptr;\n\tVALUE_PAIR *vp, *tlv;\n\n\tattribute = vps->attribute & 0xffff00ff;\n\n\ttlv = paircreate(attribute, PW_TYPE_TLV);\n\tif (!tlv) return NULL;\n\n\ttlv->length = 0;\n\tfor (vp = vps; vp != NULL; vp = vp->next) {\n\t\t/*\n\t\t *\tGroup the attributes ONLY until we see a\n\t\t *\tnon-TLV attribute.\n\t\t */\n\t\tif (!vp->flags.is_tlv ||\n\t\t    vp->flags.encoded ||\n\t\t    ((vp->attribute & 0xffff00ff) != attribute)) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttlv->length += vp->length + 2;\n\t}\n\n\tif (!tlv->length) {\n\t\tpairfree(&tlv);\n\t\treturn NULL;\n\t}\n\n\ttlv->vp_tlv = malloc(tlv->length);\n\tif (!tlv->vp_tlv) {\n\t\tpairfree(&tlv);\n\t\treturn NULL;\n\t}\n\n\tptr = tlv->vp_tlv;\n\tfor (vp = vps; vp != NULL; vp = vp->next) {\n\t\tif (!vp->flags.is_tlv ||\n\t\t    vp->flags.encoded ||\n\t\t    ((vp->attribute & 0xffff00ff) != attribute)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlength = fr_dhcp_vp2attr(vp, ptr + 2,\n\t\t\t\t\t tlv->vp_tlv + tlv->length - ptr);\n\t\tif (length > 255) return NULL;\n\n\t\t/*\n\t\t *\tPack the attribute.\n\t\t */\n\t\tptr[0] = (vp->attribute & 0xff00) >> 8;\n\t\tptr[1] = length;\n\n\t\tptr += length + 2;\n\t\tvp->flags.encoded = 1;\n\t}\n\n\treturn tlv;\n}\n\n\nint fr_dhcp_encode(RADIUS_PACKET *packet, RADIUS_PACKET *original)\n{\n\tint i, num_vps;\n\tuint8_t *p;\n\tVALUE_PAIR *vp;\n\tuint32_t lvalue, mms;\n\tsize_t dhcp_size, length;\n\tdhcp_packet_t *dhcp;\n\tchar buffer[1024];\n\n\tif (packet->data) return 0;\n\n\tpacket->data = malloc(MAX_PACKET_SIZE);\n\tif (!packet->data) return -1;\n\n\tpacket->data_len = MAX_PACKET_SIZE;\n\n\tif (packet->code == 0) packet->code = PW_DHCP_NAK;\n\n\t/*\n\t *\tIf there's a request, use it as a template.\n\t *\tOtherwise, assume that the caller has set up\n\t *\teverything appropriately.\n\t */\n\tif (original) {\n\t\tpacket->dst_ipaddr.af = AF_INET;\n\t\tpacket->src_ipaddr.af = AF_INET;\n\n\t\tpacket->dst_port = original->src_port;\n\t\tpacket->src_port = original->dst_port;\n\n\t\t/*\n\t\t *\tNote that for DHCP, we NEVER send the response\n\t\t *\tto the source IP address of the request.  It\n\t\t *\tmay have traversed multiple relays, and we\n\t\t *\tneed to send the request to the relay closest\n\t\t *\tto the client.\n\t\t *\n\t\t *\tif giaddr, send to giaddr.\n\t\t *\tif NAK, send broadcast packet\n\t\t *\tif ciaddr, unicast to ciaddr\n\t\t *\tif flags & 0x8000, broadcast (client request)\n\t\t *\tif sent from 0.0.0.0, broadcast response\n\t\t *\tunicast to client yiaddr\n\t\t */\n\t\t\n\t\t/*\n\t\t *\tFIXME: alignment issues.  We likely don't want to\n\t\t *\tde-reference the packet structure directly..\n\t\t */\n\t\tdhcp = (dhcp_packet_t *) original->data;\n\t\t\n\t\tif (dhcp->giaddr != htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->giaddr;\n\t\t\t\n\t\t\tif (dhcp->giaddr != htonl(INADDR_LOOPBACK)) {\n\t\t\t\tpacket->dst_port = original->dst_port;\n\t\t\t} else {\n\t\t\t\tpacket->dst_port = original->src_port; /* debugging */\n\t\t\t}\n\t\t\t\n\t\t} else if (packet->code == PW_DHCP_NAK) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);\n\t\t\t\n\t\t} else if (dhcp->ciaddr != htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->ciaddr;\n\t\t\t\n\t\t} else if ((dhcp->flags & 0x8000) != 0) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);\n\t\t\t\n\t\t} else if (packet->dst_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);\n\t\t\t\n\t\t} else if (dhcp->yiaddr != htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->yiaddr;\n\t\t\t\n\t\t} else {\n\t\t\t/* leave destination IP alone. */\n\t\t}\n\n\t\t/*\n\t\t *\tRewrite the source IP to be our own, if we know it.\n\t\t */\n\t\tif (packet->src_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_BROADCAST)) {\n\t\t\tpacket->src_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_ANY);\n\t\t}\n\t} else {\n\t\tmemset(packet->data, 0, packet->data_len);\n\t}\n\n\tif (fr_debug_flag > 1) {\n\t\tchar type_buf[64];\n\t\tconst char *name = type_buf;\n\t\tchar src_ip_buf[256], dst_ip_buf[256];\n\t\t\n\t\tif ((packet->code >= PW_DHCP_DISCOVER) &&\n\t\t    (packet->code <= PW_DHCP_INFORM)) {\n\t\t\tname = dhcp_message_types[packet->code - PW_DHCP_OFFSET];\n\t\t} else {\n\t\t\tsnprintf(type_buf, sizeof(type_buf), \"%d\",\n\t\t\t\t packet->code - PW_DHCP_OFFSET);\n\t\t}\n\n\t\tDEBUG(\"Sending %s of id %08x from %s:%d to %s:%d\",\n\t\t       name, (unsigned int) packet->id,\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t src_ip_buf, sizeof(src_ip_buf)),\n\t\t       packet->src_port,\n\t\t       inet_ntop(packet->dst_ipaddr.af,\n\t\t\t\t &packet->dst_ipaddr.ipaddr,\n\t\t\t\t dst_ip_buf, sizeof(dst_ip_buf)),\n\t\t       packet->dst_port);\n\t}\n\n\tp = packet->data;\n\n\tmms = DEFAULT_PACKET_SIZE; /* maximum message size */\n\n\tif (original) {\n\t\t/*\n\t\t *\tClients can request a LARGER size, but not a\n\t\t *\tsmaller one.  They also cannot request a size\n\t\t *\tlarger than MTU.\n\t\t */\n\t\tvp = pairfind(original->vps, DHCP2ATTR(57));\n\t\tif (vp && (vp->vp_integer > mms)) {\n\t\t\tmms = vp->vp_integer;\n\t\t\t\n\t\t\tif (mms > MAX_PACKET_SIZE) mms = MAX_PACKET_SIZE;\n\t\t}\n\t}\n\n\t/*\n\t *\tRFC 3118: Authentication option.\n\t */\n\tvp = pairfind(packet->vps, DHCP2ATTR(90));\n\tif (vp) {\n\t\tif (vp->length < 2) {\n\t\t\tmemset(vp->vp_octets + vp->length, 0,\n\t\t\t       2 - vp->length);\n\t\t\tvp->length = 2;\n\t\t}\n\n\t\tif (vp->length < 3) {\n\t\t\tstruct timeval tv;\n\n\t\t\tgettimeofday(&tv, NULL);\n\t\t\tvp->vp_octets[2] = 0;\n\t\t\ttimeval2ntp(&tv, vp->vp_octets + 3);\n\t\t\tvp->length = 3 + 8;\n\t\t}\n\n\t\t/*\n\t\t *\tConfiguration token (clear-text token)\n\t\t */\n\t\tif (vp->vp_octets[0] == 0) {\n\t\t\tVALUE_PAIR *pass;\n\t\t\tvp->vp_octets[1] = 0;\n\n\t\t\tpass = pairfind(packet->vps, PW_CLEARTEXT_PASSWORD);\n\t\t\tif (pass) {\n\t\t\t\tlength = pass->length;\n\t\t\t\tif ((length + 11) > sizeof(vp->vp_octets)) {\n\t\t\t\t\tlength -= ((length + 11) - sizeof(vp->vp_octets));\n\t\t\t\t}\n\t\t\t\tmemcpy(vp->vp_octets + 11, pass->vp_strvalue,\n\t\t\t\t       length);\n\t\t\t\tvp->length = length + 11;\n\t\t\t} else {\n\t\t\t\tvp->length = 11 + 8;\n\t\t\t\tmemset(vp->vp_octets + 11, 0, 8);\n\t\t\t\tvp->length = 11 + 8;\n\t\t\t}\n\t\t} else {\t/* we don't support this type! */\n\t\t\tfr_strerror_printf(\"DHCP-Authentication %d unsupported\",\n\t\t\t\tvp->vp_octets[0]);\n\t\t}\n\t}\n\n\tif (!original) {\n\t\t*p++ = 1;\t/* client message */\n\t} else {\n\t\t*p++ = 2;\t/* server message */\n\t}\n\t*p++ = 1;\t\t/* hardware type = ethernet */\n\t*p++ = 6;\t\t/* 6 bytes of ethernet */\n\t*p++ = 0;\t\t/* hops */\n\n\tif (original) {\t/* Xid */\n\t\tmemcpy(p, original->data + 4, 4);\n\t} else {\n\t\tlvalue = fr_rand();\n\t\tmemcpy(p, &lvalue, 4);\n\t}\n\tp += 4;\n\n\tmemset(p, 0, 2);\t/* secs are zero */\n\tp += 2;\n\n\tif (original) {\n\t\tmemcpy(p, original->data + 10, 6); /* copy flags && ciaddr */\n\t}\n\n\t/*\n\t *\tAllow the admin to set the broadcast flag.\n\t */\n\tvp = pairfind(packet->vps, DHCP2ATTR(262));\n\tif (vp) {\n\t\tp[0] |= (vp->vp_integer & 0xff00) >> 8;\n\t\tp[1] |= (vp->vp_integer & 0xff);\n\t}\n\n\tp += 6;\n\n\t/*\n\t *\tSet client IP address.\n\t */\n\tvp = pairfind(packet->vps, DHCP2ATTR(264)); /* Your IP address */\n\tif (vp) {\n\t\tlvalue = vp->vp_ipaddr;\n\t} else {\n\t\tlvalue = htonl(INADDR_ANY);\n\t}\n\tmemcpy(p, &lvalue, 4);\t/* your IP address */\n\tp += 4;\n\n\tvp = pairfind(packet->vps, DHCP2ATTR(265)); /* server IP address */\n\tif (!vp) vp = pairfind(packet->vps, DHCP2ATTR(54)); /* identifier */\n\tif (vp) {\n\t\tlvalue = vp->vp_ipaddr;\n\t} else {\n\t\tlvalue = htonl(INADDR_ANY);\n\t}\n\tmemcpy(p, &lvalue, 4);\t/* Server IP address */\n\tp += 4;\n\n\tif (original) {\n\t\tmemcpy(p, original->data + 24, 4); /* copy gateway IP address */\n\t} else {\n\t\tvp = pairfind(packet->vps, DHCP2ATTR(266));\n\t\tif (vp) {\n\t\t\tlvalue = vp->vp_ipaddr;\n\t\t} else {\n\t\t\tlvalue = htonl(INADDR_NONE);\n\t\t}\n\t\tmemcpy(p, &lvalue, 4);\n\t}\n\tp += 4;\n\n\tif (original) {\n\t\tmemcpy(p, original->data + 28, DHCP_CHADDR_LEN);\n\t} else {\n\t\tvp = pairfind(packet->vps, DHCP2ATTR(267));\n\t\tif (vp) {\n\t\t\tif (vp->length > DHCP_CHADDR_LEN) {\n\t\t\t\tmemcpy(p, vp->vp_octets, DHCP_CHADDR_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(p, vp->vp_octets, vp->length);\n\t\t\t}\n\t\t}\n\t}\n\tp += DHCP_CHADDR_LEN;\n\n\tmemset(p, 0, 192);\t/* bootp legacy */\n\tp += 192;\n\n\tlvalue = htonl(DHCP_OPTION_MAGIC_NUMBER); /* DHCP magic number */\n\tmemcpy(p, &lvalue, 4);\n\tp += 4;\n\n\t/*\n\t *\tPrint the header.\n\t */\n\tif (fr_debug_flag > 1) {\n\t\tuint8_t *pp = p;\n\n\t\tp = packet->data;\n\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tvp = pairmake(dhcp_header_names[i], NULL, T_OP_EQ);\n\t\t\tif (!vp) {\n\t\t\t\tfr_strerror_printf(\"Parse error %s\", fr_strerror());\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tswitch (vp->type) {\n\t\t\tcase PW_TYPE_BYTE:\n\t\t\t\tvp->vp_integer = p[0];\n\t\t\t\tvp->length = 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_SHORT:\n\t\t\t\tvp->vp_integer = (p[0] << 8) | p[1];\n\t\t\t\tvp->length = 2;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_INTEGER:\n\t\t\t\tmemcpy(&vp->vp_integer, p, 4);\n\t\t\t\tvp->vp_integer = ntohl(vp->vp_integer);\n\t\t\t\tvp->length = 4;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_IPADDR:\n\t\t\t\tmemcpy(&vp->vp_ipaddr, p, 4);\n\t\t\t\tvp->length = 4;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_STRING:\n\t\t\t\tmemcpy(vp->vp_strvalue, p, dhcp_header_sizes[i]);\n\t\t\t\tvp->vp_strvalue[dhcp_header_sizes[i]] = '\\0';\n\t\t\t\tvp->length = strlen(vp->vp_strvalue);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_OCTETS: /* only for Client HW Address */\n\t\t\t\tmemcpy(vp->vp_octets, p, packet->data[2]);\n\t\t\t\tvp->length = packet->data[2];\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_ETHERNET: /* only for Client HW Address */\n\t\t\t\tmemcpy(vp->vp_ether, p, sizeof(vp->vp_ether));\n\t\t\t\tvp->length = sizeof(vp->vp_ether);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tfr_strerror_printf(\"Internal sanity check failed %d %d\", vp->type, __LINE__);\n\t\t\t\tpairfree(&vp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tp += dhcp_header_sizes[i];\n\t\t\t\n\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t\tpairfree(&vp);\n\t\t}\n\n\t\t/*\n\t\t *\tJump over DHCP magic number, response, etc.\n\t\t */\n\t\tp = pp;\n\t}\n\n\t/*\n\t *\tBefore packing the attributes, re-order them so that\n\t *\tthe array ones are all contiguous.  This simplifies\n\t *\tthe later code.\n\t */\n\tnum_vps = 0;\n\tfor (vp = packet->vps; vp != NULL; vp = vp->next) {\n\t\tnum_vps++;\n\t}\n\tif (num_vps > 1) {\n\t\tVALUE_PAIR **array, **last;\n\n\t\tarray = malloc(num_vps * sizeof(VALUE_PAIR *));\n\t\t\n\t\ti = 0;\n\t\tfor (vp = packet->vps; vp != NULL; vp = vp->next) {\n\t\t\tarray[i++] = vp;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tSort the attributes.\n\t\t */\n\t\tqsort(array, (size_t) num_vps, sizeof(VALUE_PAIR *),\n\t\t      attr_cmp);\n\t\t\n\t\tlast = &packet->vps;\n\t\tfor (i = 0; i < num_vps; i++) {\n\t\t\t*last = array[i];\n\t\t\tarray[i]->next = NULL;\n\t\t\tlast = &(array[i]->next);\n\t\t}\n\t\tfree(array);\n\t}\n\n\tp[0] = 0x35;\t\t/* DHCP-Message-Type */\n\tp[1] = 1;\n\tp[2] = packet->code - PW_DHCP_OFFSET;\n\tp += 3;\n\n\t/*\n\t *\tPack in the attributes.\n\t */\n\tvp = packet->vps;\n\twhile (vp) {\n\t\tint num_entries = 1;\n\t\t\n\t\tVALUE_PAIR *same;\n\t\tuint8_t *plength, *pattr;\n\n\t\tif (!IS_DHCP_ATTR(vp)) goto next;\n\t\tif (vp->attribute == DHCP2ATTR(53)) goto next; /* already done */\n\t\tif (((vp->attribute & 0xffff) > 255) &&\n\t\t    (DHCP_BASE_ATTR(vp->attribute) != PW_DHCP_OPTION_82)) goto next;\n\n\t\tlength = vp->length;\n\n\t\tfor (same = vp->next; same != NULL; same = same->next) {\n\t\t\tif (same->attribute != vp->attribute) break;\n\t\t\tnum_entries++;\n\t\t}\n\n\t\t/*\n\t\t *\tFor client-identifier\n\t\t */\n\t\tif ((vp->type == PW_TYPE_ETHERNET) &&\n\t\t    (vp->length == 6) &&\n\t\t    (num_entries == 1)) {\n\t\t\tvp->type = PW_TYPE_OCTETS;\n\t\t\tmemmove(vp->vp_octets + 1, vp->vp_octets, 6);\n\t\t\tvp->vp_octets[0] = 1;\n\t\t}\n\n\t\tpattr = p;\n\t\t*(p++) = vp->attribute & 0xff;\n\t\tplength = p;\n\t\t*(p++) = 0;\t/* header isn't included in attr length */\n\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tif (fr_debug_flag > 1) {\n\t\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t\t}\n\n\t\t\tif (vp->flags.is_tlv) {\n\t\t\t\tVALUE_PAIR *tlv = fr_dhcp_vp2suboption(vp);\n\t\t\t\tif (vp) {\n\t\t\t\t\ttlv->next = vp->next;\n\t\t\t\t\tvp->next = tlv;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\tThe encoded flag MUST be set in the vp!\n\t\t\t\t */\n\t\t\t\tvp = vp->next;\n\t\t\t}\n\n\t\t\tlength = fr_dhcp_vp2attr(vp, p, 0);\n\n\t\t\t/*\n\t\t\t *\tThis will never happen due to FreeRADIUS\n\t\t\t *\tlimitations: sizeof(vp->vp_octets) < 255\n\t\t\t */\n\t\t\tif (length > 255) {\n\t\t\t\tfr_strerror_printf(\"WARNING Ignoring too long attribute %s!\", vp->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tMore than one attribute of the same type\n\t\t\t *\tin a row: they are packed together\n\t\t\t *\tinto the same TLV.  If we overflow,\n\t\t\t *\tgo bananas!\n\t\t\t */\n\t\t\tif ((*plength + length) > 255) {\n\t\t\t\tfr_strerror_printf(\"WARNING Ignoring too long attribute %s!\", vp->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t*plength += length;\n\t\t\tp += length;\n\n\t\t\tif (vp->next &&\n\t\t\t    (vp->next->attribute == vp->attribute))\n\t\t\t\tvp = vp->next;\n\t\t} /* loop over num_entries */\n\n\tnext:\n\t\tvp = vp->next;\n\t}\n\n\tp[0] = 0xff;\t\t/* end of option option */\n\tp[1] = 0x00;\n\tp += 2;\n\tdhcp_size = p - packet->data;\n\n\t/*\n\t *\tFIXME: if (dhcp_size > mms),\n\t *\t  then we put the extra options into the \"sname\" and \"file\"\n\t *\t  fields, AND set the \"end option option\" in the \"options\"\n\t *\t  field.  We also set the \"overload option\",\n\t *\t  and put options into the \"file\" field, followed by\n\t *\t  the \"sname\" field.  Where each option is completely\n\t *\t  enclosed in the \"file\" and/or \"sname\" field, AND\n\t *\t  followed by the \"end of option\", and MUST be followed\n\t *\t  by padding option.\n\t *\n\t *\tYuck.  That sucks...\n\t */\n\tpacket->data_len = dhcp_size;\n\n\tif (original) {\n\t\t/*\n\t\t *\tFIXME: This may set it to broadcast, which we don't\n\t\t *\twant.  Instead, set it to the real address of the\n\t\t *\tsocket.\n\t\t */\n\t\tpacket->src_ipaddr = original->dst_ipaddr;\n\t\n\t\tpacket->sockfd = original->sockfd;\n\t}\n\n\tif (packet->data_len < DEFAULT_PACKET_SIZE) {\n\t\tmemset(packet->data + packet->data_len, 0,\n\t\t       DEFAULT_PACKET_SIZE - packet->data_len);\n\t\tpacket->data_len = DEFAULT_PACKET_SIZE;\n\t}\n\n\tif ((fr_debug_flag > 2) && fr_log_fp) {\n\t\tfor (i = 0; i < packet->data_len; i++) {\n\t\t\tif ((i & 0x0f) == 0x00) fprintf(fr_log_fp, \"%d: \", i);\n\t\t\tfprintf(fr_log_fp, \"%02x \", packet->data[i]);\n\t\t\tif ((i & 0x0f) == 0x0f) fprintf(fr_log_fp, \"\\n\");\n\t\t}\n\t\tfprintf(fr_log_fp, \"\\n\");\n\t}\n\n\treturn 0;\n}\n#endif /* WITH_DHCP */\n"], "fixing_code": ["/*\n * dhcp.c\tFunctions to send/receive dhcp packets.\n *\n * Version:\t$Id$\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n *\n * Copyright 2008 The FreeRADIUS server project\n * Copyright 2008 Alan DeKok <aland@deployingradius.com>\n */\n\n#include\t<freeradius-devel/ident.h>\nRCSID(\"$Id$\")\n\n#include <freeradius-devel/libradius.h>\n#include <freeradius-devel/udpfromto.h>\n#include <freeradius-devel/dhcp.h>\n\n#ifdef WITH_DHCP\n#define DHCP_CHADDR_LEN\t(16)\n#define DHCP_SNAME_LEN\t(64)\n#define DHCP_FILE_LEN\t(128)\n#define DHCP_VEND_LEN\t(308)\n#define DHCP_OPTION_MAGIC_NUMBER (0x63825363)\n\n#ifndef INADDR_BROADCAST\n#define INADDR_BROADCAST INADDR_NONE\n#endif\n\ntypedef struct dhcp_packet_t {\n\tuint8_t\t\topcode;\n\tuint8_t\t\thtype;\n\tuint8_t\t\thlen;\n\tuint8_t\t\thops;\n\tuint32_t\txid;\t/* 4 */\n\tuint16_t\tsecs;\t/* 8 */\n\tuint16_t\tflags;\n\tuint32_t\tciaddr;\t/* 12 */\n\tuint32_t\tyiaddr;\t/* 16 */\n\tuint32_t\tsiaddr;\t/* 20 */\n\tuint32_t\tgiaddr;\t/* 24 */\n\tuint8_t\t\tchaddr[DHCP_CHADDR_LEN]; /* 28 */\n\tuint8_t\t\tsname[DHCP_SNAME_LEN]; /* 44 */\n\tuint8_t\t\tfile[DHCP_FILE_LEN]; /* 108 */\n\tuint32_t\toption_format; /* 236 */\n\tuint8_t\t\toptions[DHCP_VEND_LEN];\n} dhcp_packet_t;\n\ntypedef struct dhcp_option_t {\n\tuint8_t\t\tcode;\n\tuint8_t\t\tlength;\n} dhcp_option_t;\n\n/*\n *\tINADDR_ANY : 68 -> INADDR_BROADCAST : 67\tDISCOVER\n *\tINADDR_BROADCAST : 68 <- SERVER_IP : 67\t\tOFFER\n *\tINADDR_ANY : 68 -> INADDR_BROADCAST : 67\tREQUEST\n *\tINADDR_BROADCAST : 68 <- SERVER_IP : 67\t\tACK\n */\nstatic const char *dhcp_header_names[] = {\n\t\"DHCP-Opcode\",\n\t\"DHCP-Hardware-Type\",\n\t\"DHCP-Hardware-Address-Length\",\n\t\"DHCP-Hop-Count\",\n\t\"DHCP-Transaction-Id\",\n\t\"DHCP-Number-of-Seconds\",\n\t\"DHCP-Flags\",\n\t\"DHCP-Client-IP-Address\",\n\t\"DHCP-Your-IP-Address\",\n\t\"DHCP-Server-IP-Address\",\n\t\"DHCP-Gateway-IP-Address\",\n\t\"DHCP-Client-Hardware-Address\",\n\t\"DHCP-Server-Host-Name\",\n\t\"DHCP-Boot-Filename\",\n\n\tNULL\n};\n\nstatic const char *dhcp_message_types[] = {\n\t\"invalid\",\n\t\"DHCP-Discover\",\n\t\"DHCP-Offer\",\n\t\"DHCP-Request\",\n\t\"DHCP-Decline\",\n\t\"DHCP-Ack\",\n\t\"DHCP-NAK\",\n\t\"DHCP-Release\",\n\t\"DHCP-Inform\",\n\t\"DHCP-Force-Renew\",\n};\n\nstatic int dhcp_header_sizes[] = {\n\t1, 1, 1, 1,\n\t4, 2, 2, 4,\n\t4, 4, 4,\n\tDHCP_CHADDR_LEN,\n\tDHCP_SNAME_LEN,\n\tDHCP_FILE_LEN\n};\n\n\n/*\n *\tSome clients silently ignore responses less than 300 bytes.\n */\n#define MIN_PACKET_SIZE (244)\n#define DEFAULT_PACKET_SIZE (300)\n#define MAX_PACKET_SIZE (1500 - 40)\n\n#define DHCP_OPTION_FIELD (0)\n#define DHCP_FILE_FIELD\t  (1)\n#define DHCP_SNAME_FIELD  (2)\n\nstatic uint8_t *dhcp_get_option(dhcp_packet_t *packet, size_t packet_size,\n\t\t\t\tunsigned int option)\n\t\t\t\t\n{\n\tint overload = 0;\n\tint field = DHCP_OPTION_FIELD;\n\tsize_t where, size;\n\tuint8_t *data = packet->options;\n\n\twhere = 0;\n\tsize = packet_size - offsetof(dhcp_packet_t, options);\n\tdata = &packet->options[where];\n\n\twhile (where < size) {\n\t\tif (data[0] == 0) { /* padding */\n\t\t\twhere++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data[0] == 255) { /* end of options */\n\t\t\tif ((field == DHCP_OPTION_FIELD) &&\n\t\t\t    (overload & DHCP_FILE_FIELD)) {\n\t\t\t\tdata = packet->file;\n\t\t\t\twhere = 0;\n\t\t\t\tsize = sizeof(packet->file);\n\t\t\t\tfield = DHCP_FILE_FIELD;\n\t\t\t\tcontinue;\n\n\t\t\t} else if ((field == DHCP_FILE_FIELD) &&\n\t\t\t\t   (overload && DHCP_SNAME_FIELD)) {\n\t\t\t\tdata = packet->sname;\n\t\t\t\twhere = 0;\n\t\t\t\tsize = sizeof(packet->sname);\n\t\t\t\tfield = DHCP_SNAME_FIELD;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t *\tWe MUST have a real option here.\n\t\t */\n\t\tif ((where + 2) > size) {\n\t\t\tfr_strerror_printf(\"Options overflow field at %u\",\n\t\t\t\t\t   (unsigned int) (data - (uint8_t *) packet));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((where + 2 + data[1]) > size) {\n\t\t\tfr_strerror_printf(\"Option length overflows field at %u\",\n\t\t\t\t\t   (unsigned int) (data - (uint8_t *) packet));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (data[0] == option) return data;\n\n\t\tif (data[0] == 52) { /* overload sname and/or file */\n\t\t\toverload = data[3];\n\t\t}\n\n\t\twhere += data[1] + 2;\n\t\tdata += data[1] + 2;\n\t}\n\n\treturn NULL;\n}\n\n/*\n *\tDHCPv4 is only for IPv4.  Broadcast only works if udpfromto is\n *\tdefined.\n */\nRADIUS_PACKET *fr_dhcp_recv(int sockfd)\n{\n\tuint32_t\t\tmagic;\n\tstruct sockaddr_storage\tsrc;\n\tstruct sockaddr_storage\tdst;\n\tsocklen_t\t\tsizeof_src;\n\tsocklen_t\t        sizeof_dst;\n\tRADIUS_PACKET\t\t*packet;\n\tint port;\n\tuint8_t\t\t\t*code;\n\n\tpacket = rad_alloc(0);\n\tif (!packet) {\n\t\tfr_strerror_printf(\"Failed allocating packet\");\n\t\treturn NULL;\n\t}\n\tmemset(packet, 0, sizeof(packet));\n\n\tpacket->data = malloc(MAX_PACKET_SIZE);\n\tif (!packet->data) {\n\t\tfr_strerror_printf(\"Failed in malloc\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tpacket->sockfd = sockfd;\n\tsizeof_src = sizeof(src);\n#ifdef WITH_UDPFROMTO\n\tsizeof_dst = sizeof(dst);\n\tpacket->data_len = recvfromto(sockfd, packet->data, MAX_PACKET_SIZE, 0,\n\t\t\t\t      (struct sockaddr *)&src, &sizeof_src,\n\t\t\t\t      (struct sockaddr *)&dst, &sizeof_dst);\n#else\n\tpacket->data_len = recvfrom(sockfd, packet->data, MAX_PACKET_SIZE, 0,\n\t\t\t\t    (struct sockaddr *)&src, &sizeof_src);\n#endif\n\n\tif (packet->data_len <= 0) {\n\t\tfr_strerror_printf(\"Failed reading DHCP socket: %s\", strerror(errno));\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif (packet->data_len < MIN_PACKET_SIZE) {\n\t\tfr_strerror_printf(\"DHCP packet is too small (%d < %d)\",\n\t\t      packet->data_len, MIN_PACKET_SIZE);\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif (packet->data[1] != 1) {\n\t\tfr_strerror_printf(\"DHCP can only receive ethernet requests, not type %02x\",\n\t\t      packet->data[1]);\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif (packet->data[2] != 6) {\n\t\tfr_strerror_printf(\"Ethernet HW length is wrong length %d\",\n\t\t\tpacket->data[2]);\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(&magic, packet->data + 236, 4);\n\tmagic = ntohl(magic);\n\tif (magic != DHCP_OPTION_MAGIC_NUMBER) {\n\t\tfr_strerror_printf(\"Cannot do BOOTP\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t *\tCreate unique keys for the packet.\n\t */\n\tmemcpy(&magic, packet->data + 4, 4);\n\tpacket->id = ntohl(magic);\n\n\tcode = dhcp_get_option((dhcp_packet_t *) packet->data,\n\t\t\t       packet->data_len, 53);\n\tif (!code) {\n\t\tfr_strerror_printf(\"No message-type option was found in the packet\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tif ((code[1] < 1) || (code[2] == 0) || (code[2] > 8)) {\n\t\tfr_strerror_printf(\"Unknown value for message-type option\");\n\t\trad_free(&packet);\n\t\treturn NULL;\n\t}\n\n\tpacket->code = code[2] | PW_DHCP_OFFSET;\n\n\t/*\n\t *\tCreate a unique vector from the MAC address and the\n\t *\tDHCP opcode.  This is a hack for the RADIUS\n\t *\tinfrastructure in the rest of the server.\n\t *\n\t *\tNote: packet->data[2] == 6, which is smaller than\n\t *\tsizeof(packet->vector)\n\t *\n\t *\tFIXME:  Look for client-identifier in packet,\n\t *      and use that, too?\n\t */\n\tmemset(packet->vector, 0, sizeof(packet->vector));\n\tmemcpy(packet->vector, packet->data + 28, packet->data[2]);\n\tpacket->vector[packet->data[2]] = packet->code & 0xff;\n\n\t/*\n\t *\tFIXME: for DISCOVER / REQUEST: src_port == dst_port + 1\n\t *\tFIXME: for OFFER / ACK       : src_port = dst_port - 1\n\t */\n\n\t/*\n\t *\tUnique keys are xid, client mac, and client ID?\n\t */\n\n\t/*\n\t *\tFIXME: More checks, like DHCP packet type?\n\t */\n\n\tsizeof_dst = sizeof(dst);\n\n#ifndef WITH_UDPFROMTO\n\t/*\n\t *\tThis should never fail...\n\t */\n\tgetsockname(sockfd, (struct sockaddr *) &dst, &sizeof_dst);\n#endif\n\t\n\tfr_sockaddr2ipaddr(&dst, sizeof_dst, &packet->dst_ipaddr, &port);\n\tpacket->dst_port = port;\n\n\tfr_sockaddr2ipaddr(&src, sizeof_src, &packet->src_ipaddr, &port);\n\tpacket->src_port = port;\n\n\tif (fr_debug_flag > 1) {\n\t\tchar type_buf[64];\n\t\tconst char *name = type_buf;\n\t\tchar src_ip_buf[256], dst_ip_buf[256];\n\t\t\n\t\tif ((packet->code >= PW_DHCP_DISCOVER) &&\n\t\t    (packet->code <= PW_DHCP_INFORM)) {\n\t\t\tname = dhcp_message_types[packet->code - PW_DHCP_OFFSET];\n\t\t} else {\n\t\t\tsnprintf(type_buf, sizeof(type_buf), \"%d\",\n\t\t\t\t packet->code - PW_DHCP_OFFSET);\n\t\t}\n\n\t\tDEBUG(\"Received %s of id %08x from %s:%d to %s:%d\",\n\t\t       name, (unsigned int) packet->id,\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t src_ip_buf, sizeof(src_ip_buf)),\n\t\t       packet->src_port,\n\t\t       inet_ntop(packet->dst_ipaddr.af,\n\t\t\t\t &packet->dst_ipaddr.ipaddr,\n\t\t\t\t dst_ip_buf, sizeof(dst_ip_buf)),\n\t\t       packet->dst_port);\n\t}\n\n\treturn packet;\n}\n\n\n/*\n *\tSend a DHCP packet.\n */\nint fr_dhcp_send(RADIUS_PACKET *packet)\n{\n\tstruct sockaddr_storage\tdst;\n\tsocklen_t\t\tsizeof_dst;\n#ifdef WITH_UDPFROMTO\n\tstruct sockaddr_storage\tsrc;\n\tsocklen_t\t\tsizeof_src;\n#endif\n\n\tfr_ipaddr2sockaddr(&packet->dst_ipaddr, packet->dst_port,\n\t\t\t   &dst, &sizeof_dst);\n\n#ifndef WITH_UDPFROMTO\n\t/*\n\t *\tAssume that the packet is encoded before sending it.\n\t */\n\treturn sendto(packet->sockfd, packet->data, packet->data_len, 0,\n\t\t      (struct sockaddr *)&dst, sizeof_dst);\n#else\n\tfr_ipaddr2sockaddr(&packet->src_ipaddr, packet->src_port,\n\t\t\t   &src, &sizeof_src);\n\n\treturn sendfromto(packet->sockfd,\n\t\t\t  packet->data, packet->data_len, 0,\n\t\t\t  (struct sockaddr *)&src, sizeof_src,\n\t\t\t  (struct sockaddr *)&dst, sizeof_dst);\n#endif\n}\n\nstatic int fr_dhcp_attr2vp(VALUE_PAIR *vp, const uint8_t *p, size_t alen);\n\nstatic int decode_tlv(VALUE_PAIR *tlv, const uint8_t *data, size_t data_len)\n{\n\tconst uint8_t *p;\n\tVALUE_PAIR *head, **tail, *vp;\n\n\t/*\n\t *\tTake a pass at parsing it.\n\t */\n\tp = data;\n\twhile (p < (data + data_len)) {\n\t\tif ((p + 2) > (data + data_len)) goto make_tlv;\n\n\t\tif ((p + p[1] + 2) > (data + data_len)) goto make_tlv;\n\t\tp += 2 + p[1];\n\t}\n\n\t/*\n\t *\tGot here... must be well formed.\n\t */\n\thead = NULL;\n\ttail = &head;\n\n\tp = data;\n\twhile (p < (data + data_len)) {\n\t\tvp = paircreate(tlv->attribute | (p[0] << 8), PW_TYPE_OCTETS);\n\t\tif (!vp) {\n\t\t\tpairfree(&head);\n\t\t\tgoto make_tlv;\n\t\t}\n\n\t\tif (fr_dhcp_attr2vp(vp, p + 2, p[1]) < 0) {\n\t\t\tpairfree(&head);\n\t\t\tgoto make_tlv;\n\t\t}\n\n\t\t*tail = vp;\n\t\ttail = &(vp->next);\n\t\tp += 2 + p[1];\n\t}\n\n\t/*\n\t *\tThe caller allocated TLV, so we need to copy the FIRST\n\t *\tattribute over top of that.\n\t */\n\tmemcpy(tlv, head, sizeof(*tlv));\n\thead->next = NULL;\n\tpairfree(&head);\n\treturn 0;\n\nmake_tlv:\n\ttlv->vp_tlv = malloc(data_len);\n\tif (!tlv->vp_tlv) {\n\t\tfr_strerror_printf(\"No memory\");\n\t\treturn -1;\n\t}\n\tmemcpy(tlv->vp_tlv, data, data_len);\n\ttlv->length = data_len;\n\t\n\treturn 0;\n}\n\n\n/*\n *\tDecode ONE value into a VP\n */\nstatic int fr_dhcp_attr2vp(VALUE_PAIR *vp, const uint8_t *p, size_t alen)\n{\n\tswitch (vp->type) {\n\tcase PW_TYPE_BYTE:\n\t\tif (alen != 1) goto raw;\n\t\tvp->vp_integer = p[0];\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_SHORT:\n\t\tif (alen != 2) goto raw;\n\t\tvp->vp_integer = (p[0] << 8) | p[1];\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_INTEGER:\n\t\tif (alen != 4) goto raw;\n\t\tmemcpy(&vp->vp_integer, p, 4);\n\t\tvp->vp_integer = ntohl(vp->vp_integer);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_IPADDR:\n\t\tif (alen != 4) goto raw;\n\t\tmemcpy(&vp->vp_ipaddr, p , 4);\n\t\tvp->length = 4;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_STRING:\n\t\tif (alen > 253) return -1;\n\t\tmemcpy(vp->vp_strvalue, p , alen);\n\t\tvp->vp_strvalue[alen] = '\\0';\n\t\tbreak;\n\t\t\n\traw:\n\t\tvp->type = PW_TYPE_OCTETS;\n\n\tcase PW_TYPE_OCTETS:\n\t\tif (alen > 253) return -1;\n\t\tmemcpy(vp->vp_octets, p, alen);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_TLV:\n\t\treturn decode_tlv(vp, p, alen);\n\t\t\n\tdefault:\n\t\tfr_strerror_printf(\"Internal sanity check %d %d\", vp->type, __LINE__);\n\t\tbreak;\n\t} /* switch over type */\n\n\tvp->length = alen;\n\treturn 0;\n}\n\nint fr_dhcp_decode(RADIUS_PACKET *packet)\n{\n\tint i;\n\tuint8_t *p, *next;\n\tuint32_t giaddr;\n\tVALUE_PAIR *head, *vp, **tail;\n\tVALUE_PAIR *maxms, *mtu;\n\tchar buffer[2048];\n\n\thead = NULL;\n\ttail = &head;\n\tp = packet->data;\n\t\n\tif ((fr_debug_flag > 2) && fr_log_fp) {\n\t\tfor (i = 0; i < packet->data_len; i++) {\n\t\t\tif ((i & 0x0f) == 0x00) fr_strerror_printf(\"%d: \", i);\n\t\t\tfprintf(fr_log_fp, \"%02x \", packet->data[i]);\n\t\t\tif ((i & 0x0f) == 0x0f) fprintf(fr_log_fp, \"\\n\");\n\t\t}\n\t\tfprintf(fr_log_fp, \"\\n\");\n\t}\n\n\tif (packet->data[1] != 1) {\n\t\tfr_strerror_printf(\"Packet is not Ethernet: %u\",\n\t\t      packet->data[1]);\n\t\treturn -1;\n\t}\n\n\t/*\n\t *\tDecode the header.\n\t */\n\tfor (i = 0; i < 14; i++) {\n\t\tvp = pairmake(dhcp_header_names[i], NULL, T_OP_EQ);\n\t\tif (!vp) {\n\t\t\tfr_strerror_printf(\"Parse error %s\", fr_strerror());\n\t\t\tpairfree(&head);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((i == 11) && \n\t\t    (packet->data[1] == 1) &&\n\t\t    (packet->data[2] == 6)) {\n\t\t\tvp->type = PW_TYPE_ETHERNET;\n\t\t}\n\n\t\tswitch (vp->type) {\n\t\tcase PW_TYPE_BYTE:\n\t\t\tvp->vp_integer = p[0];\n\t\t\tvp->length = 1;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_SHORT:\n\t\t\tvp->vp_integer = (p[0] << 8) | p[1];\n\t\t\tvp->length = 2;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_INTEGER:\n\t\t\tmemcpy(&vp->vp_integer, p, 4);\n\t\t\tvp->vp_integer = ntohl(vp->vp_integer);\n\t\t\tvp->length = 4;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_IPADDR:\n\t\t\tmemcpy(&vp->vp_ipaddr, p, 4);\n\t\t\tvp->length = 4;\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_STRING:\n\t\t\tmemcpy(vp->vp_strvalue, p, dhcp_header_sizes[i]);\n\t\t\tvp->vp_strvalue[dhcp_header_sizes[i]] = '\\0';\n\t\t\tvp->length = strlen(vp->vp_strvalue);\n\t\t\tif (vp->length == 0) {\n\t\t\t\tpairfree(&vp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_OCTETS:\n\t\t\tmemcpy(vp->vp_octets, p, packet->data[2]);\n\t\t\tvp->length = packet->data[2];\n\t\t\tbreak;\n\t\t\t\n\t\tcase PW_TYPE_ETHERNET:\n\t\t\tmemcpy(vp->vp_ether, p, sizeof(vp->vp_ether));\n\t\t\tvp->length = sizeof(vp->vp_ether);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tfr_strerror_printf(\"BAD TYPE %d\", vp->type);\n\t\t\tpairfree(&vp);\n\t\t\tbreak;\n\t\t}\n\t\tp += dhcp_header_sizes[i];\n\n\t\tif (!vp) continue;\n\t\t\n\t\tif (fr_debug_flag > 1) {\n\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t}\n\t\t*tail = vp;\n\t\ttail = &vp->next;\n\t}\n\t\n\t/*\n\t *\tLoop over the options.\n\t */\n\tnext = packet->data + 240;\n\n\t/*\n\t *\tFIXME: This should also check sname && file fields.\n\t *\tSee the dhcp_get_option() function above.\n\t */\n\twhile (next < (packet->data + packet->data_len)) {\n\t\tint num_entries, alen;\n\t\tDICT_ATTR *da;\n\t\t\n\t\tp = next;\n\n\t\tif (*p == 0) break;\n\t\tif (*p == 255) break; /* end of options signifier */\n\t\tif ((p + 2) > (packet->data + packet->data_len)) break;\n\n\t\tnext = p + 2 + p[1];\n\n\t\tif (p[1] >= 253) {\n\t\t\tfr_strerror_printf(\"Attribute too long %u %u\",\n\t\t\t      p[0], p[1]);\n\t\t\tcontinue;\n\t\t}\n\t\t\t\t\n\t\tda = dict_attrbyvalue(DHCP2ATTR(p[0]));\n\t\tif (!da) {\n\t\t\tfr_strerror_printf(\"Attribute not in our dictionary: %u\",\n\t\t\t      p[0]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvp = NULL;\n\t\tnum_entries = 1;\n\t\talen = p[1];\n\t\tp += 2;\n\n\t\t/*\n\t\t *\tCould be an array of bytes, integers, etc.\n\t\t */\n\t\tif (da->flags.array) {\n\t\t\tswitch (da->type) {\n\t\t\tcase PW_TYPE_BYTE:\n\t\t\t\tnum_entries = alen;\n\t\t\t\talen = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase PW_TYPE_SHORT: /* ignore any trailing data */\n\t\t\t\tnum_entries = alen >> 1;\n\t\t\t\talen = 2;\n\t\t\t\tbreak;\n\n\t\t\tcase PW_TYPE_IPADDR:\n\t\t\tcase PW_TYPE_INTEGER:\n\t\t\tcase PW_TYPE_DATE: /* ignore any trailing data */\n\t\t\t\tnum_entries = alen >> 2;\n\t\t\t\talen = 4;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tbreak; /* really an internal sanity failure */\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tLoop over all of the entries, building VPs\n\t\t */\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tvp = pairmake(da->name, NULL, T_OP_EQ);\n\t\t\tif (!vp) {\n\t\t\t\tfr_strerror_printf(\"Cannot build attribute %s\",\n\t\t\t\t\tfr_strerror());\n\t\t\t\tpairfree(&head);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tHack for ease of use.\n\t\t\t */\n\t\t\tif ((da->attr == DHCP2ATTR(0x3d)) &&\n\t\t\t    !da->flags.array &&\n\t\t\t    (alen == 7) && (*p == 1) && (num_entries == 1)) {\n\t\t\t\tvp->type = PW_TYPE_ETHERNET;\n\t\t\t\tmemcpy(vp->vp_octets, p + 1, 6);\n\t\t\t\tvp->length = alen;\n\n\t\t\t} else if (fr_dhcp_attr2vp(vp, p, alen) < 0) {\n\t\t\t\t\tpairfree(&vp);\n\t\t\t\t\tpairfree(&head);\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (fr_debug_flag > 1) {\n\t\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t\t}\n\n\t\t\t*tail = vp;\n\t\t\twhile (*tail) tail = &(*tail)->next;\n\t\t\tp += alen;\n\t\t} /* loop over array entries */\n\t} /* loop over the entire packet */\n\n\t/*\n\t *\tIf DHCP request, set ciaddr to zero.\n\t */\n\n\t/*\n\t *\tSet broadcast flag for broken vendors, but only if\n\t *\tgiaddr isn't set.\n\t */\n\tmemcpy(&giaddr, packet->data + 24, sizeof(giaddr));\n\tif (giaddr == htonl(INADDR_ANY)) {\n\t\t/*\n\t\t *\tDHCP Opcode is request\n\t\t */\n\t\tvp = pairfind(head, DHCP2ATTR(256));\n\t\tif (vp && vp->lvalue == 3) {\n\t\t\t/*\n\t\t\t *\tVendor is \"MSFT 98\"\n\t\t\t */\n\t\t\tvp = pairfind(head, DHCP2ATTR(63));\n\t\t\tif (vp && (strcmp(vp->vp_strvalue, \"MSFT 98\") == 0)) {\n\t\t\t\tvp = pairfind(head, DHCP2ATTR(262));\n\n\t\t\t\t/*\n\t\t\t\t *\tReply should be broadcast.\n\t\t\t\t */\n\t\t\t\tif (vp) vp->lvalue |= 0x8000;\n\t\t\t\tpacket->data[10] |= 0x80;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t *\tFIXME: Nuke attributes that aren't used in the normal\n\t *\theader for discover/requests.\n\t */\n\tpacket->vps = head;\n\n\t/*\n\t *\tClient can request a LARGER size, but not a smaller\n\t *\tone.  They also cannot request a size larger than MTU.\n\t */\n\tmaxms = pairfind(packet->vps, DHCP2ATTR(57));\n\tmtu = pairfind(packet->vps, DHCP2ATTR(26));\n\n\tif (mtu && (mtu->vp_integer < DEFAULT_PACKET_SIZE)) {\n\t\tfr_strerror_printf(\"DHCP Fatal: Client says MTU is smaller than minimum permitted by the specification.\");\n\t\treturn -1;\n\t}\n\n\tif (maxms && (maxms->vp_integer < DEFAULT_PACKET_SIZE)) {\n\t\tfr_strerror_printf(\"DHCP WARNING: Client says maximum message size is smaller than minimum permitted by the specification: fixing it\");\n\t\tmaxms->vp_integer = DEFAULT_PACKET_SIZE;\n\t}\n\n\tif (maxms && mtu && (maxms->vp_integer > mtu->vp_integer)) {\n\t\tfr_strerror_printf(\"DHCP WARNING: Client says MTU is smaller than maximum message size: fixing it\");\n\t\tmaxms->vp_integer = mtu->vp_integer;\n\t}\n\n\tif (fr_debug_flag) fflush(stdout);\n\n\treturn 0;\n}\n\n\nstatic int attr_cmp(const void *one, const void *two)\n{\n\tconst VALUE_PAIR * const *a = one;\n\tconst VALUE_PAIR * const *b = two;\n\n\t/*\n\t *\tDHCP-Message-Type is first, for simplicity.\n\t */\n\tif (((*a)->attribute == DHCP2ATTR(53)) &&\n\t    (*b)->attribute != DHCP2ATTR(53)) return -1;\n\n\t/*\n\t *\tRelay-Agent is last\n\t */\n\tif (((*a)->attribute == DHCP2ATTR(82)) &&\n\t    (*b)->attribute != DHCP2ATTR(82)) return +1;\n\n\treturn ((*a)->attribute - (*b)->attribute);\n}\n\n\nstatic size_t fr_dhcp_vp2attr(VALUE_PAIR *vp, uint8_t *p, size_t room)\n{\n\tsize_t length;\n\tuint32_t lvalue;\n\n\t/*\n\t *\tFIXME: Check room!\n\t */\n\troom = room;\t\t/* -Wunused */\n\n\t/*\n\t *\tSearch for all attributes of the same\n\t *\ttype, and pack them into the same\n\t *\tattribute.\n\t */\n\tswitch (vp->type) {\n\tcase PW_TYPE_BYTE:\n\t\tlength = 1;\n\t\t*p = vp->vp_integer & 0xff;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_SHORT:\n\t\tlength = 2;\n\t\tp[0] = (vp->vp_integer >> 8) & 0xff;\n\t\tp[1] = vp->vp_integer & 0xff;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_INTEGER:\n\t\tlength = 4;\n\t\tlvalue = htonl(vp->vp_integer);\n\t\tmemcpy(p, &lvalue, 4);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_IPADDR:\n\t\tlength = 4;\n\t\tmemcpy(p, &vp->vp_ipaddr, 4);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_ETHERNET:\n\t\tlength = 6;\n\t\tmemcpy(p, &vp->vp_ether, 6);\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_STRING:\n\t\tmemcpy(p, vp->vp_strvalue, vp->length);\n\t\tlength = vp->length;\n\t\tbreak;\n\t\t\n\tcase PW_TYPE_TLV:\t/* FIXME: split it on 255? */\n\t\tmemcpy(p, vp->vp_tlv, vp->length);\n\t\tlength = vp->length;\n\t\tbreak;\n\n\tcase PW_TYPE_OCTETS:\n\t\tmemcpy(p, vp->vp_octets, vp->length);\n\t\tlength = vp->length;\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tfr_strerror_printf(\"BAD TYPE2 %d\", vp->type);\n\t\tlength = 0;\n\t\tbreak;\n\t}\n\n\treturn length;\n}\n\nstatic VALUE_PAIR *fr_dhcp_vp2suboption(VALUE_PAIR *vps)\n{\n\tint length;\n\tunsigned int attribute;\n\tuint8_t *ptr;\n\tVALUE_PAIR *vp, *tlv;\n\n\tattribute = vps->attribute & 0xffff00ff;\n\n\ttlv = paircreate(attribute, PW_TYPE_TLV);\n\tif (!tlv) return NULL;\n\n\ttlv->length = 0;\n\tfor (vp = vps; vp != NULL; vp = vp->next) {\n\t\t/*\n\t\t *\tGroup the attributes ONLY until we see a\n\t\t *\tnon-TLV attribute.\n\t\t */\n\t\tif (!vp->flags.is_tlv ||\n\t\t    vp->flags.encoded ||\n\t\t    ((vp->attribute & 0xffff00ff) != attribute)) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttlv->length += vp->length + 2;\n\t}\n\n\tif (!tlv->length) {\n\t\tpairfree(&tlv);\n\t\treturn NULL;\n\t}\n\n\ttlv->vp_tlv = malloc(tlv->length);\n\tif (!tlv->vp_tlv) {\n\t\tpairfree(&tlv);\n\t\treturn NULL;\n\t}\n\n\tptr = tlv->vp_tlv;\n\tfor (vp = vps; vp != NULL; vp = vp->next) {\n\t\tif (!vp->flags.is_tlv ||\n\t\t    vp->flags.encoded ||\n\t\t    ((vp->attribute & 0xffff00ff) != attribute)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlength = fr_dhcp_vp2attr(vp, ptr + 2,\n\t\t\t\t\t tlv->vp_tlv + tlv->length - ptr);\n\t\tif (length > 255) return NULL;\n\n\t\t/*\n\t\t *\tPack the attribute.\n\t\t */\n\t\tptr[0] = (vp->attribute & 0xff00) >> 8;\n\t\tptr[1] = length;\n\n\t\tptr += length + 2;\n\t\tvp->flags.encoded = 1;\n\t}\n\n\treturn tlv;\n}\n\n\nint fr_dhcp_encode(RADIUS_PACKET *packet, RADIUS_PACKET *original)\n{\n\tint i, num_vps;\n\tuint8_t *p;\n\tVALUE_PAIR *vp;\n\tuint32_t lvalue, mms;\n\tsize_t dhcp_size, length;\n\tdhcp_packet_t *dhcp;\n\tchar buffer[1024];\n\n\tif (packet->data) return 0;\n\n\tpacket->data = malloc(MAX_PACKET_SIZE);\n\tif (!packet->data) return -1;\n\n\tpacket->data_len = MAX_PACKET_SIZE;\n\n\tif (packet->code == 0) packet->code = PW_DHCP_NAK;\n\n\t/*\n\t *\tIf there's a request, use it as a template.\n\t *\tOtherwise, assume that the caller has set up\n\t *\teverything appropriately.\n\t */\n\tif (original) {\n\t\tpacket->dst_ipaddr.af = AF_INET;\n\t\tpacket->src_ipaddr.af = AF_INET;\n\n\t\tpacket->dst_port = original->src_port;\n\t\tpacket->src_port = original->dst_port;\n\n\t\t/*\n\t\t *\tNote that for DHCP, we NEVER send the response\n\t\t *\tto the source IP address of the request.  It\n\t\t *\tmay have traversed multiple relays, and we\n\t\t *\tneed to send the request to the relay closest\n\t\t *\tto the client.\n\t\t *\n\t\t *\tif giaddr, send to giaddr.\n\t\t *\tif NAK, send broadcast packet\n\t\t *\tif ciaddr, unicast to ciaddr\n\t\t *\tif flags & 0x8000, broadcast (client request)\n\t\t *\tif sent from 0.0.0.0, broadcast response\n\t\t *\tunicast to client yiaddr\n\t\t */\n\t\t\n\t\t/*\n\t\t *\tFIXME: alignment issues.  We likely don't want to\n\t\t *\tde-reference the packet structure directly..\n\t\t */\n\t\tdhcp = (dhcp_packet_t *) original->data;\n\t\t\n\t\tif (dhcp->giaddr != htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->giaddr;\n\t\t\t\n\t\t\tif (dhcp->giaddr != htonl(INADDR_LOOPBACK)) {\n\t\t\t\tpacket->dst_port = original->dst_port;\n\t\t\t} else {\n\t\t\t\tpacket->dst_port = original->src_port; /* debugging */\n\t\t\t}\n\t\t\t\n\t\t} else if (packet->code == PW_DHCP_NAK) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);\n\t\t\t\n\t\t} else if (dhcp->ciaddr != htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->ciaddr;\n\t\t\t\n\t\t} else if ((dhcp->flags & 0x8000) != 0) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);\n\t\t\t\n\t\t} else if (packet->dst_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_BROADCAST);\n\t\t\t\n\t\t} else if (dhcp->yiaddr != htonl(INADDR_ANY)) {\n\t\t\tpacket->dst_ipaddr.ipaddr.ip4addr.s_addr = dhcp->yiaddr;\n\t\t\t\n\t\t} else {\n\t\t\t/* leave destination IP alone. */\n\t\t}\n\n\t\t/*\n\t\t *\tRewrite the source IP to be our own, if we know it.\n\t\t */\n\t\tif (packet->src_ipaddr.ipaddr.ip4addr.s_addr == htonl(INADDR_BROADCAST)) {\n\t\t\tpacket->src_ipaddr.ipaddr.ip4addr.s_addr = htonl(INADDR_ANY);\n\t\t}\n\t} else {\n\t\tmemset(packet->data, 0, packet->data_len);\n\t}\n\n\tif (fr_debug_flag > 1) {\n\t\tchar type_buf[64];\n\t\tconst char *name = type_buf;\n\t\tchar src_ip_buf[256], dst_ip_buf[256];\n\t\t\n\t\tif ((packet->code >= PW_DHCP_DISCOVER) &&\n\t\t    (packet->code <= PW_DHCP_INFORM)) {\n\t\t\tname = dhcp_message_types[packet->code - PW_DHCP_OFFSET];\n\t\t} else {\n\t\t\tsnprintf(type_buf, sizeof(type_buf), \"%d\",\n\t\t\t\t packet->code - PW_DHCP_OFFSET);\n\t\t}\n\n\t\tDEBUG(\"Sending %s of id %08x from %s:%d to %s:%d\",\n\t\t       name, (unsigned int) packet->id,\n\t\t       inet_ntop(packet->src_ipaddr.af,\n\t\t\t\t &packet->src_ipaddr.ipaddr,\n\t\t\t\t src_ip_buf, sizeof(src_ip_buf)),\n\t\t       packet->src_port,\n\t\t       inet_ntop(packet->dst_ipaddr.af,\n\t\t\t\t &packet->dst_ipaddr.ipaddr,\n\t\t\t\t dst_ip_buf, sizeof(dst_ip_buf)),\n\t\t       packet->dst_port);\n\t}\n\n\tp = packet->data;\n\n\tmms = DEFAULT_PACKET_SIZE; /* maximum message size */\n\n\tif (original) {\n\t\t/*\n\t\t *\tClients can request a LARGER size, but not a\n\t\t *\tsmaller one.  They also cannot request a size\n\t\t *\tlarger than MTU.\n\t\t */\n\t\tvp = pairfind(original->vps, DHCP2ATTR(57));\n\t\tif (vp && (vp->vp_integer > mms)) {\n\t\t\tmms = vp->vp_integer;\n\t\t\t\n\t\t\tif (mms > MAX_PACKET_SIZE) mms = MAX_PACKET_SIZE;\n\t\t}\n\t}\n\n\t/*\n\t *\tRFC 3118: Authentication option.\n\t */\n\tvp = pairfind(packet->vps, DHCP2ATTR(90));\n\tif (vp) {\n\t\tif (vp->length < 2) {\n\t\t\tmemset(vp->vp_octets + vp->length, 0,\n\t\t\t       2 - vp->length);\n\t\t\tvp->length = 2;\n\t\t}\n\n\t\tif (vp->length < 3) {\n\t\t\tstruct timeval tv;\n\n\t\t\tgettimeofday(&tv, NULL);\n\t\t\tvp->vp_octets[2] = 0;\n\t\t\ttimeval2ntp(&tv, vp->vp_octets + 3);\n\t\t\tvp->length = 3 + 8;\n\t\t}\n\n\t\t/*\n\t\t *\tConfiguration token (clear-text token)\n\t\t */\n\t\tif (vp->vp_octets[0] == 0) {\n\t\t\tVALUE_PAIR *pass;\n\t\t\tvp->vp_octets[1] = 0;\n\n\t\t\tpass = pairfind(packet->vps, PW_CLEARTEXT_PASSWORD);\n\t\t\tif (pass) {\n\t\t\t\tlength = pass->length;\n\t\t\t\tif ((length + 11) > sizeof(vp->vp_octets)) {\n\t\t\t\t\tlength -= ((length + 11) - sizeof(vp->vp_octets));\n\t\t\t\t}\n\t\t\t\tmemcpy(vp->vp_octets + 11, pass->vp_strvalue,\n\t\t\t\t       length);\n\t\t\t\tvp->length = length + 11;\n\t\t\t} else {\n\t\t\t\tvp->length = 11 + 8;\n\t\t\t\tmemset(vp->vp_octets + 11, 0, 8);\n\t\t\t\tvp->length = 11 + 8;\n\t\t\t}\n\t\t} else {\t/* we don't support this type! */\n\t\t\tfr_strerror_printf(\"DHCP-Authentication %d unsupported\",\n\t\t\t\tvp->vp_octets[0]);\n\t\t}\n\t}\n\n\tif (!original) {\n\t\t*p++ = 1;\t/* client message */\n\t} else {\n\t\t*p++ = 2;\t/* server message */\n\t}\n\t*p++ = 1;\t\t/* hardware type = ethernet */\n\t*p++ = 6;\t\t/* 6 bytes of ethernet */\n\t*p++ = 0;\t\t/* hops */\n\n\tif (original) {\t/* Xid */\n\t\tmemcpy(p, original->data + 4, 4);\n\t} else {\n\t\tlvalue = fr_rand();\n\t\tmemcpy(p, &lvalue, 4);\n\t}\n\tp += 4;\n\n\tmemset(p, 0, 2);\t/* secs are zero */\n\tp += 2;\n\n\tif (original) {\n\t\tmemcpy(p, original->data + 10, 6); /* copy flags && ciaddr */\n\t}\n\n\t/*\n\t *\tAllow the admin to set the broadcast flag.\n\t */\n\tvp = pairfind(packet->vps, DHCP2ATTR(262));\n\tif (vp) {\n\t\tp[0] |= (vp->vp_integer & 0xff00) >> 8;\n\t\tp[1] |= (vp->vp_integer & 0xff);\n\t}\n\n\tp += 6;\n\n\t/*\n\t *\tSet client IP address.\n\t */\n\tvp = pairfind(packet->vps, DHCP2ATTR(264)); /* Your IP address */\n\tif (vp) {\n\t\tlvalue = vp->vp_ipaddr;\n\t} else {\n\t\tlvalue = htonl(INADDR_ANY);\n\t}\n\tmemcpy(p, &lvalue, 4);\t/* your IP address */\n\tp += 4;\n\n\tvp = pairfind(packet->vps, DHCP2ATTR(265)); /* server IP address */\n\tif (!vp) vp = pairfind(packet->vps, DHCP2ATTR(54)); /* identifier */\n\tif (vp) {\n\t\tlvalue = vp->vp_ipaddr;\n\t} else {\n\t\tlvalue = htonl(INADDR_ANY);\n\t}\n\tmemcpy(p, &lvalue, 4);\t/* Server IP address */\n\tp += 4;\n\n\tif (original) {\n\t\tmemcpy(p, original->data + 24, 4); /* copy gateway IP address */\n\t} else {\n\t\tvp = pairfind(packet->vps, DHCP2ATTR(266));\n\t\tif (vp) {\n\t\t\tlvalue = vp->vp_ipaddr;\n\t\t} else {\n\t\t\tlvalue = htonl(INADDR_NONE);\n\t\t}\n\t\tmemcpy(p, &lvalue, 4);\n\t}\n\tp += 4;\n\n\tif (original) {\n\t\tmemcpy(p, original->data + 28, DHCP_CHADDR_LEN);\n\t} else {\n\t\tvp = pairfind(packet->vps, DHCP2ATTR(267));\n\t\tif (vp) {\n\t\t\tif (vp->length > DHCP_CHADDR_LEN) {\n\t\t\t\tmemcpy(p, vp->vp_octets, DHCP_CHADDR_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(p, vp->vp_octets, vp->length);\n\t\t\t}\n\t\t}\n\t}\n\tp += DHCP_CHADDR_LEN;\n\n\tmemset(p, 0, 192);\t/* bootp legacy */\n\tp += 192;\n\n\tlvalue = htonl(DHCP_OPTION_MAGIC_NUMBER); /* DHCP magic number */\n\tmemcpy(p, &lvalue, 4);\n\tp += 4;\n\n\t/*\n\t *\tPrint the header.\n\t */\n\tif (fr_debug_flag > 1) {\n\t\tuint8_t *pp = p;\n\n\t\tp = packet->data;\n\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tvp = pairmake(dhcp_header_names[i], NULL, T_OP_EQ);\n\t\t\tif (!vp) {\n\t\t\t\tfr_strerror_printf(\"Parse error %s\", fr_strerror());\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tswitch (vp->type) {\n\t\t\tcase PW_TYPE_BYTE:\n\t\t\t\tvp->vp_integer = p[0];\n\t\t\t\tvp->length = 1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_SHORT:\n\t\t\t\tvp->vp_integer = (p[0] << 8) | p[1];\n\t\t\t\tvp->length = 2;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_INTEGER:\n\t\t\t\tmemcpy(&vp->vp_integer, p, 4);\n\t\t\t\tvp->vp_integer = ntohl(vp->vp_integer);\n\t\t\t\tvp->length = 4;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_IPADDR:\n\t\t\t\tmemcpy(&vp->vp_ipaddr, p, 4);\n\t\t\t\tvp->length = 4;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_STRING:\n\t\t\t\tmemcpy(vp->vp_strvalue, p, dhcp_header_sizes[i]);\n\t\t\t\tvp->vp_strvalue[dhcp_header_sizes[i]] = '\\0';\n\t\t\t\tvp->length = strlen(vp->vp_strvalue);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_OCTETS: /* only for Client HW Address */\n\t\t\t\tmemcpy(vp->vp_octets, p, packet->data[2]);\n\t\t\t\tvp->length = packet->data[2];\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PW_TYPE_ETHERNET: /* only for Client HW Address */\n\t\t\t\tmemcpy(vp->vp_ether, p, sizeof(vp->vp_ether));\n\t\t\t\tvp->length = sizeof(vp->vp_ether);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tfr_strerror_printf(\"Internal sanity check failed %d %d\", vp->type, __LINE__);\n\t\t\t\tpairfree(&vp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tp += dhcp_header_sizes[i];\n\t\t\t\n\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t\tpairfree(&vp);\n\t\t}\n\n\t\t/*\n\t\t *\tJump over DHCP magic number, response, etc.\n\t\t */\n\t\tp = pp;\n\t}\n\n\t/*\n\t *\tBefore packing the attributes, re-order them so that\n\t *\tthe array ones are all contiguous.  This simplifies\n\t *\tthe later code.\n\t */\n\tnum_vps = 0;\n\tfor (vp = packet->vps; vp != NULL; vp = vp->next) {\n\t\tnum_vps++;\n\t}\n\tif (num_vps > 1) {\n\t\tVALUE_PAIR **array, **last;\n\n\t\tarray = malloc(num_vps * sizeof(VALUE_PAIR *));\n\t\t\n\t\ti = 0;\n\t\tfor (vp = packet->vps; vp != NULL; vp = vp->next) {\n\t\t\tarray[i++] = vp;\n\t\t}\n\t\t\n\t\t/*\n\t\t *\tSort the attributes.\n\t\t */\n\t\tqsort(array, (size_t) num_vps, sizeof(VALUE_PAIR *),\n\t\t      attr_cmp);\n\t\t\n\t\tlast = &packet->vps;\n\t\tfor (i = 0; i < num_vps; i++) {\n\t\t\t*last = array[i];\n\t\t\tarray[i]->next = NULL;\n\t\t\tlast = &(array[i]->next);\n\t\t}\n\t\tfree(array);\n\t}\n\n\tp[0] = 0x35;\t\t/* DHCP-Message-Type */\n\tp[1] = 1;\n\tp[2] = packet->code - PW_DHCP_OFFSET;\n\tp += 3;\n\n\t/*\n\t *\tPack in the attributes.\n\t */\n\tvp = packet->vps;\n\twhile (vp) {\n\t\tint num_entries = 1;\n\t\t\n\t\tVALUE_PAIR *same;\n\t\tuint8_t *plength, *pattr;\n\n\t\tif (!IS_DHCP_ATTR(vp)) goto next;\n\t\tif (vp->attribute == DHCP2ATTR(53)) goto next; /* already done */\n\t\tif (((vp->attribute & 0xffff) > 255) &&\n\t\t    (DHCP_BASE_ATTR(vp->attribute) != PW_DHCP_OPTION_82)) goto next;\n\n\t\tlength = vp->length;\n\n\t\tfor (same = vp->next; same != NULL; same = same->next) {\n\t\t\tif (same->attribute != vp->attribute) break;\n\t\t\tnum_entries++;\n\t\t}\n\n\t\t/*\n\t\t *\tFor client-identifier\n\t\t */\n\t\tif ((vp->type == PW_TYPE_ETHERNET) &&\n\t\t    (vp->length == 6) &&\n\t\t    (num_entries == 1)) {\n\t\t\tvp->type = PW_TYPE_OCTETS;\n\t\t\tmemmove(vp->vp_octets + 1, vp->vp_octets, 6);\n\t\t\tvp->vp_octets[0] = 1;\n\t\t}\n\n\t\tpattr = p;\n\t\t*(p++) = vp->attribute & 0xff;\n\t\tplength = p;\n\t\t*(p++) = 0;\t/* header isn't included in attr length */\n\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tif (fr_debug_flag > 1) {\n\t\t\t\tvp_prints(buffer, sizeof(buffer), vp);\n\t\t\t\tfr_strerror_printf(\"\\t%s\", buffer);\n\t\t\t}\n\n\t\t\tif (vp->flags.is_tlv) {\n\t\t\t\tVALUE_PAIR *tlv = fr_dhcp_vp2suboption(vp);\n\t\t\t\tif (vp) {\n\t\t\t\t\ttlv->next = vp->next;\n\t\t\t\t\tvp->next = tlv;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t *\tThe encoded flag MUST be set in the vp!\n\t\t\t\t */\n\t\t\t\tvp = vp->next;\n\t\t\t}\n\n\t\t\tlength = fr_dhcp_vp2attr(vp, p, 0);\n\n\t\t\t/*\n\t\t\t *\tThis will never happen due to FreeRADIUS\n\t\t\t *\tlimitations: sizeof(vp->vp_octets) < 255\n\t\t\t */\n\t\t\tif (length > 255) {\n\t\t\t\tfr_strerror_printf(\"WARNING Ignoring too long attribute %s!\", vp->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t *\tMore than one attribute of the same type\n\t\t\t *\tin a row: they are packed together\n\t\t\t *\tinto the same TLV.  If we overflow,\n\t\t\t *\tgo bananas!\n\t\t\t */\n\t\t\tif ((*plength + length) > 255) {\n\t\t\t\tfr_strerror_printf(\"WARNING Ignoring too long attribute %s!\", vp->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t*plength += length;\n\t\t\tp += length;\n\n\t\t\tif (vp->next &&\n\t\t\t    (vp->next->attribute == vp->attribute))\n\t\t\t\tvp = vp->next;\n\t\t} /* loop over num_entries */\n\n\tnext:\n\t\tvp = vp->next;\n\t}\n\n\tp[0] = 0xff;\t\t/* end of option option */\n\tp[1] = 0x00;\n\tp += 2;\n\tdhcp_size = p - packet->data;\n\n\t/*\n\t *\tFIXME: if (dhcp_size > mms),\n\t *\t  then we put the extra options into the \"sname\" and \"file\"\n\t *\t  fields, AND set the \"end option option\" in the \"options\"\n\t *\t  field.  We also set the \"overload option\",\n\t *\t  and put options into the \"file\" field, followed by\n\t *\t  the \"sname\" field.  Where each option is completely\n\t *\t  enclosed in the \"file\" and/or \"sname\" field, AND\n\t *\t  followed by the \"end of option\", and MUST be followed\n\t *\t  by padding option.\n\t *\n\t *\tYuck.  That sucks...\n\t */\n\tpacket->data_len = dhcp_size;\n\n\tif (original) {\n\t\t/*\n\t\t *\tFIXME: This may set it to broadcast, which we don't\n\t\t *\twant.  Instead, set it to the real address of the\n\t\t *\tsocket.\n\t\t */\n\t\tpacket->src_ipaddr = original->dst_ipaddr;\n\t\n\t\tpacket->sockfd = original->sockfd;\n\t}\n\n\tif (packet->data_len < DEFAULT_PACKET_SIZE) {\n\t\tmemset(packet->data + packet->data_len, 0,\n\t\t       DEFAULT_PACKET_SIZE - packet->data_len);\n\t\tpacket->data_len = DEFAULT_PACKET_SIZE;\n\t}\n\n\tif ((fr_debug_flag > 2) && fr_log_fp) {\n\t\tfor (i = 0; i < packet->data_len; i++) {\n\t\t\tif ((i & 0x0f) == 0x00) fprintf(fr_log_fp, \"%d: \", i);\n\t\t\tfprintf(fr_log_fp, \"%02x \", packet->data[i]);\n\t\t\tif ((i & 0x0f) == 0x0f) fprintf(fr_log_fp, \"\\n\");\n\t\t}\n\t\tfprintf(fr_log_fp, \"\\n\");\n\t}\n\n\treturn 0;\n}\n#endif /* WITH_DHCP */\n"], "filenames": ["src/lib/dhcp.c"], "buggy_code_start_loc": [717], "buggy_code_end_loc": [718], "fixing_code_start_loc": [717], "fixing_code_end_loc": [718], "type": "CWE-399", "message": "The fr_dhcp_decode function in lib/dhcp.c in FreeRADIUS 2.1.9, in certain non-default builds, does not properly handle the DHCP Relay Agent Information option, which allows remote attackers to cause a denial of service (infinite loop and daemon outage) via a packet that has more than one sub-option. NOTE: some of these details are obtained from third party information.", "other": {"cve": {"id": "CVE-2010-3696", "sourceIdentifier": "secalert@redhat.com", "published": "2010-10-07T21:00:03.437", "lastModified": "2023-02-13T04:25:29.047", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The fr_dhcp_decode function in lib/dhcp.c in FreeRADIUS 2.1.9, in certain non-default builds, does not properly handle the DHCP Relay Agent Information option, which allows remote attackers to cause a denial of service (infinite loop and daemon outage) via a packet that has more than one sub-option. NOTE: some of these details are obtained from third party information."}, {"lang": "es", "value": "La funci\u00f3n fr_dhcp_decode en lib/dhcp.c en FreeRADIUS v2.1.9, en determinadas compilaciones (no por defecto), no maneja adecuadamente la opci\u00f3n DHCP Relay Agent Information, lo cual permite a atacantes remotos provocar una denegaci\u00f3n de servicio (bucle infinito y corte del servicio) a trav\u00e9s de un paquete que tiene m\u00e1s de una sub-opci\u00f3n. NOTA: algunos de estos detalles han sido obtenidos de informaci\u00f3n de terceros."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeradius:freeradius:2.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "CE0CFEA6-1AC0-41AA-BEF0-16FE1A933758"}]}]}], "references": [{"url": "http://freeradius.org/press/index.html#2.1.10", "source": "secalert@redhat.com"}, {"url": "http://github.com/alandekok/freeradius-server/commit/4dc7800b866f889a1247685bbaa6dd4238a56279", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2010/10/01/3", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2010/10/01/8", "source": "secalert@redhat.com"}, {"url": "https://bugs.freeradius.org/bugzilla/show_bug.cgi?id=77", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=639390", "source": "secalert@redhat.com"}]}, "github_commit_url": "http://github.com/alandekok/freeradius-server/commit/4dc7800b866f889a1247685bbaa6dd4238a56279"}}