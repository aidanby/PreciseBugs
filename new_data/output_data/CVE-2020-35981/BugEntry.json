{"buggy_code": ["\n/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#define GPAC_ISOM_CPRT_NOTICE \"IsoMedia File Produced with GPAC\"\n\n#include <gpac/revision.h>\n#define GPAC_ISOM_CPRT_NOTICE_VERSION GPAC_ISOM_CPRT_NOTICE\" \"GPAC_VERSION \"-rev\" GPAC_GIT_REVISION\n\nstatic GF_Err gf_isom_insert_copyright(GF_ISOFile *movie)\n{\n\tu32 i;\n\tGF_Box *a;\n\tGF_FreeSpaceBox *_free;\n\ti=0;\n\twhile ((a = (GF_Box *)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_FREE) {\n\t\t\t_free = (GF_FreeSpaceBox *)a;\n\t\t\tif (_free->dataSize) {\n\t\t\t\tif (!strcmp(_free->data, GPAC_ISOM_CPRT_NOTICE_VERSION)) return GF_OK;\n\t\t\t\tif (strstr(_free->data, GPAC_ISOM_CPRT_NOTICE)) {\n\t\t\t\t\tgf_free(_free->data);\n\t\t\t\t\t_free->data = gf_strdup(gf_sys_is_test_mode() ? GPAC_ISOM_CPRT_NOTICE : GPAC_ISOM_CPRT_NOTICE_VERSION);\n\t\t\t\t\t_free->dataSize = 1 + (u32) strlen(_free->data);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ta = gf_isom_box_new(GF_ISOM_BOX_TYPE_FREE);\n\tif (!a) return GF_OUT_OF_MEM;\n\t_free = (GF_FreeSpaceBox *)a;\n\t_free->data = gf_strdup(gf_sys_is_test_mode() ? GPAC_ISOM_CPRT_NOTICE : GPAC_ISOM_CPRT_NOTICE_VERSION);\n\t_free->dataSize = (u32) strlen(_free->data) + 1;\n\tif (!_free->data) return GF_OUT_OF_MEM;\n\treturn gf_list_add(movie->TopBoxes, _free);\n}\n\ntypedef struct\n{\n\t/*the curent sample of this track*/\n\tu32 sampleNumber;\n\t/*timeScale of the media (for interleaving)*/\n\tu32 timeScale;\n\t/*this is for generic, time-based interleaving. Expressed in Media TimeScale*/\n\tu64 chunkDur;\n\tu32 chunkSize;\n\tu32 constant_size, constant_dur;\n\n\tu64 DTSprev;\n\tu8 isDone;\n\tu64 prev_offset;\n\tGF_MediaBox *mdia;\n\tGF_SampleTableBox *stbl;\n\n\tu32 all_dref_mode;\n\n\t/*each writer has a sampleToChunck and ChunkOffset tables\n\tthese tables are filled during emulation mode and then will\treplace the table in the GF_SampleTableBox*/\n\tGF_SampleToChunkBox *stsc;\n\t/*we don't know if it's a large offset or not*/\n\tGF_Box *stco;\n\t//track uses a box requiring seeking into the moov during write, we cannot dispatch blocks\n\tBool prevent_dispatch;\n} TrackWriter;\n\ntypedef struct\n{\n\tchar *buffer;\n\tu32 alloc_size;\n\tGF_ISOFile *movie;\n\tu32 total_samples, nb_done;\n} MovieWriter;\n\nvoid CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}\n\nGF_Err ResetWriters(GF_List *writers)\n{\n\tu32 i;\n\tTrackWriter *writer;\n\ti=0;\n\twhile ((writer = (TrackWriter *)gf_list_enum(writers, &i))) {\n\t\twriter->isDone = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->sampleNumber = 1;\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stco->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tgf_free(((GF_ChunkOffsetBox *)writer->stco)->offsets);\n\t\t\t((GF_ChunkOffsetBox *)writer->stco)->offsets = NULL;\n\t\t\t((GF_ChunkOffsetBox *)writer->stco)->nb_entries = 0;\n\t\t\t((GF_ChunkOffsetBox *)writer->stco)->alloc_size = 0;\n\t\t} else {\n\t\t\tgf_free(((GF_ChunkLargeOffsetBox *)writer->stco)->offsets);\n\t\t\t((GF_ChunkLargeOffsetBox *)writer->stco)->offsets = NULL;\n\t\t\t((GF_ChunkLargeOffsetBox *)writer->stco)->nb_entries = 0;\n\t\t\t((GF_ChunkLargeOffsetBox *)writer->stco)->alloc_size = 0;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n{\n\tu32 i, trackCount;\n\tTrackWriter *writer;\n\tGF_TrackBox *trak;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmw->total_samples = mw->nb_done = 0;\n\tif (!movie->moov) return GF_OK;\n\n\ttrackCount = gf_list_count(movie->moov->trackList);\n\tfor (i = 0; i < trackCount; i++) {\n\t\ttrak = gf_isom_get_track(movie->moov, i+1);\n\n\t\tGF_SAFEALLOC(writer, TrackWriter);\n\t\tif (!writer) goto exit;\n\t\twriter->sampleNumber = 1;\n\t\twriter->mdia = trak->Media;\n\t\twriter->stbl = trak->Media->information->sampleTable;\n\t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n\t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n\n\t\tif (trak->sample_encryption)\n\t\t\twriter->prevent_dispatch = GF_TRUE;\n\n\t\twriter->isDone = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->constant_size = writer->constant_dur = 0;\n\t\tif (writer->stbl->SampleSize->sampleSize)\n\t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n\t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n\t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n\t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n\t\t}\n\t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n\t\t\twriter->constant_size = writer->constant_dur = 0;\n\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\t} else {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t}\n\t\tif (!writer->stco) return GF_OUT_OF_MEM;\n\t\t/*stops from chunk escape*/\n\t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n\t\t/*for progress, assume only one descIndex*/\n\t\tif (Media_IsSelfContained(writer->mdia, 1))\n\t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n\t\t/*optimization for interleaving: put audio last (this can be overridden by priorities)*/\n\t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n\t\t\tgf_list_add(writers, writer);\n\t\t} else {\n\t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n\t\t\t\tgf_list_add(writers, writer);\n\t\t\t} else {\n\t\t\t\tgf_list_insert(writers, writer, 0);\n\t\t\t}\n\t\t}\n\t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n\t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n\nexit:\n\tCleanWriters(writers);\n\treturn GF_OUT_OF_MEM;\n}\n\n\nstatic void ShiftMetaOffset(GF_MetaBox *meta, u64 offset)\n{\n\tu32 i, count;\n\tif (!meta->item_locations) return;\n\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\tif (iloc->data_reference_index) continue;\n\t\tif (iloc->construction_method == 2) continue;\n\t\tif (!iloc->base_offset) {\n\t\t\tGF_ItemExtentEntry *entry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\tif (entry && !entry->extent_length && !entry->original_extent_offset && (gf_list_count(iloc->extent_entries)==1) )\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tiloc->base_offset += offset;\n\t}\n}\n\nstatic GF_Err ShiftOffset(GF_ISOFile *file, GF_List *writers, u64 offset)\n{\n\tu32 i, j, k, l, last;\n\tTrackWriter *writer;\n\tGF_StscEntry *ent;\n\n\tif (file->meta) ShiftMetaOffset(file->meta, offset);\n\tif (file->moov && file->moov->meta) ShiftMetaOffset(file->moov->meta, offset);\n\n\ti=0;\n\twhile ((writer = (TrackWriter *)gf_list_enum(writers, &i))) {\n\t\tif (writer->mdia->mediaTrack->meta) ShiftMetaOffset(writer->mdia->mediaTrack->meta, offset);\n\n\t\t//we have to proceed entry by entry in case a part of the media is not self-contained...\n\t\tfor (j=0; j<writer->stsc->nb_entries; j++) {\n\t\t\tent = &writer->stsc->entries[j];\n\t\t\tif ((writer->all_dref_mode==ISOM_DREF_EXT) || !Media_IsSelfContained(writer->mdia, ent->sampleDescriptionIndex))\n\t\t\t\tcontinue;\n\n\t\t\t//OK, get the chunk(s) number(s) and \"shift\" its (their) offset(s).\n\t\t\tif (writer->stco->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\t\tGF_ChunkLargeOffsetBox *new_stco64 = NULL;\n\t\t\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *) writer->stco;\n\n\t\t\t\t//be carefull for the last entry, nextChunk is set to 0 in edit mode...\n\t\t\t\tlast = ent->nextChunk ? ent->nextChunk : stco->nb_entries + 1;\n\t\t\t\tfor (k = ent->firstChunk; k < last; k++) {\n\n\t\t\t\t\t//we need to rewrite the table: only allocate co64 if not done previously and convert all offsets\n\t\t\t\t\t//to co64. Then (whether co64 was created or not) adjust the offset\n\t\t\t\t\t//Do not reassign table until we are done with the current sampleToChunk processing\n\t\t\t\t\t//since we have a test on stco->offsets[k-1], we need to keep stco untouched\n\t\t\t\t\tif (new_stco64 || file->force_co64 || (stco->offsets[k-1] + offset > 0xFFFFFFFF)) {\n\t\t\t\t\t\tif (!new_stco64) {\n\t\t\t\t\t\t\tnew_stco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t\t\t\t\t\tif (!new_stco64) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\tnew_stco64->nb_entries = stco->nb_entries;\n\t\t\t\t\t\t\tnew_stco64->offsets = (u64 *) gf_malloc(new_stco64->nb_entries * sizeof(u64));\n\t\t\t\t\t\t\tif (!new_stco64->offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t//copy over the stco table\n\t\t\t\t\t\t\tfor (l = 0; l < new_stco64->nb_entries; l++) {\n\t\t\t\t\t\t\t\tnew_stco64->offsets[l] = (u64) stco->offsets[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_stco64->offsets[k-1] += offset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstco->offsets[k-1] += (u32) offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (new_stco64) {\n\t\t\t\t\t//done with this sampleToChunk entry, replace the box if we moved to co64\n\t\t\t\t\tgf_isom_box_del(writer->stco);\n\t\t\t\t\twriter->stco = (GF_Box *)new_stco64;\n\t\t\t\t\tnew_stco64 = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_ChunkLargeOffsetBox *stco64 = (GF_ChunkLargeOffsetBox *) writer->stco;\n\t\t\t\t//be carefull for the last entry ...\n\t\t\t\tlast = ent->nextChunk ? ent->nextChunk : stco64->nb_entries + 1;\n\t\t\t\tfor (k = ent->firstChunk; k < last; k++) {\n\t\t\t\t\tstco64->offsets[k-1] += offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n\n}\n\n#define COMP_BOX_COST_BYTES\t\t8\n\nGF_Err gf_isom_write_compressed_box(GF_ISOFile *mov, GF_Box *root_box, u32 repl_type, GF_BitStream *bs, u32 *box_csize)\n{\n#ifdef GPAC_DISABLE_ZLIB\n\treturn GF_NOT_SUPPORTED;\n#else\n\tGF_Err e;\n\tGF_BitStream *comp_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(root_box, comp_bs);\n\n\tif (!e) {\n\t\tu8 *box_data;\n\t\tu32 box_size, comp_size;\n\n\t\tif (box_csize)\n\t\t\t*box_csize = (u32) root_box->size;\n\n\t\tgf_bs_get_content(comp_bs, &box_data, &box_size);\n\t\tgf_gz_compress_payload_ex(&box_data, box_size, &comp_size, 8, GF_TRUE, NULL);\n\t\tif (mov->force_compress || (comp_size + COMP_BOX_COST_BYTES < box_size)) {\n\t\t\tif (bs) {\n\t\t\t\tgf_bs_write_u32(bs, comp_size+8);\n\t\t\t\tgf_bs_write_u32(bs, repl_type);\n\t\t\t\tgf_bs_write_data(bs, box_data, comp_size);\n\t\t\t}\n\t\t\tif (box_csize)\n\t\t\t\t*box_csize = comp_size + COMP_BOX_COST_BYTES;\n\t\t} else if (bs) {\n\t\t\tgf_bs_write_data(bs, box_data, box_size);\n\t\t}\n\t\tgf_free(box_data);\n\t}\n\tgf_bs_del(comp_bs);\n\treturn e;\n#endif /*GPAC_DISABLE_ZLIB*/\n}\n\n//replace the chunk and offset tables...\nstatic GF_Err WriteMoovAndMeta(GF_ISOFile *movie, GF_List *writers, GF_BitStream *bs)\n{\n\tu32 i;\n\tTrackWriter *writer;\n\tGF_Err e;\n\tGF_Box *stco;\n\tGF_SampleToChunkBox *stsc;\n\n\tif (movie->meta) {\n\t\t//write the moov box...\n\t\te = gf_isom_box_size((GF_Box *)movie->meta);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->meta, bs);\n\t\tif (e) return e;\n\t}\n\n\tif (movie->moov) {\n\t\tBool prevent_dispatch = GF_FALSE;\n\t\t//switch all our tables\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\t//don't delete them !!!\n\t\t\tstsc = writer->stbl->SampleToChunk;\n\t\t\tstco = writer->stbl->ChunkOffset;\n\t\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, stsc);\n\t\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, stco);\n\t\t\twriter->stbl->SampleToChunk = writer->stsc;\n\t\t\twriter->stbl->ChunkOffset = writer->stco;\n\t\t\tgf_list_insert(writer->stbl->child_boxes, writer->stsc, stsc_pos);\n\t\t\tgf_list_insert(writer->stbl->child_boxes, writer->stco, stco_pos);\n\t\t\twriter->stco = stco;\n\t\t\twriter->stsc = stsc;\n\t\t\tif (writer->prevent_dispatch)\n\t\t\t\tprevent_dispatch = GF_TRUE;\n\t\t}\n\t\tif (prevent_dispatch) {\n\t\t\tgf_bs_prevent_dispatch(bs, GF_TRUE);\n\t\t}\n\t\t//write the moov box...\n\t\te = gf_isom_box_size((GF_Box *)movie->moov);\n\t\tif (e) return e;\n\n\t\tif ((movie->compress_mode==GF_ISO_COMP_ALL) || (movie->compress_mode==GF_ISO_COMP_MOOV)) {\n\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->moov, GF_4CC('!', 'm', 'o', 'v'), bs, NULL);\n\t\t} else {\n\t\t\te = gf_isom_box_write((GF_Box *)movie->moov, bs);\n\t\t}\n\n\t\tif (prevent_dispatch) {\n\t\t\tgf_bs_prevent_dispatch(bs, GF_FALSE);\n\t\t}\n\n\t\t//and re-switch our table. We have to do it that way because it is\n\t\t//needed when the moov is written first\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\t//don't delete them !!!\n\t\t\tstsc = writer->stsc;\n\t\t\tstco = writer->stco;\n\t\t\twriter->stsc = writer->stbl->SampleToChunk;\n\t\t\twriter->stco = writer->stbl->ChunkOffset;\n\t\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\n\t\t\twriter->stbl->SampleToChunk = stsc;\n\t\t\twriter->stbl->ChunkOffset = stco;\n\t\t\tgf_list_insert(writer->stbl->child_boxes, stsc, stsc_pos);\n\t\t\tgf_list_insert(writer->stbl->child_boxes, stco, stco_pos);\n\t\t}\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n//compute the size of the moov as it will be written.\nu64 GetMoovAndMetaSize(GF_ISOFile *movie, GF_List *writers)\n{\n\tu32 i;\n\tu64 size;\n\n\tsize = 0;\n\tif (movie->moov) {\n\t\tTrackWriter *writer;\n\t\tgf_isom_box_size((GF_Box *)movie->moov);\n\t\tsize = movie->moov->size;\n\t\tif (size > 0xFFFFFFFF) size += 8;\n\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\tsize -= writer->stbl->ChunkOffset->size;\n\t\t\tsize -= writer->stbl->SampleToChunk->size;\n\t\t\tgf_isom_box_size((GF_Box *)writer->stsc);\n\t\t\tgf_isom_box_size(writer->stco);\n\t\t\tsize += writer->stsc->size;\n\t\t\tsize += writer->stco->size;\n\t\t}\n\t}\n\tif (movie->meta) {\n\t\tu64 msize;\n\t\tgf_isom_box_size((GF_Box *)movie->meta);\n\t\tmsize = movie->meta->size;\n\t\tif (msize > 0xFFFFFFFF) msize += 8;\n\t\tsize += msize;\n\t}\n\treturn size;\n}\n\nstatic void muxer_report_progress(MovieWriter *mw)\n{\n\tif (mw->movie->progress_cbk) {\n\t\tmw->movie->progress_cbk(mw->movie->progress_cbk_udta, mw->nb_done, mw->total_samples);\n\t} else {\n\t\tgf_set_progress(\"ISO File Writing\", mw->nb_done, mw->total_samples);\n\t}\n}\n\n//Write a sample to the file - this is only called for self-contained media\nGF_Err WriteSample(MovieWriter *mw, u32 size, u64 offset, u8 isEdited, GF_BitStream *bs, u32 nb_samp)\n{\n\tGF_DataMap *map;\n\tu32 bytes;\n\n\tif (!size) return GF_OK;\n\n\tif (size>mw->alloc_size) {\n\t\tmw->buffer = (char*)gf_realloc(mw->buffer, size);\n\t\tmw->alloc_size = size;\n\t}\n\n\tif (!mw->buffer) return GF_OUT_OF_MEM;\n\n\tif (isEdited) {\n\t\tmap = mw->movie->editFileMap;\n\t} else {\n\t\tmap = mw->movie->movieFileMap;\n\t}\n\t//get the payload...\n\tbytes = gf_isom_datamap_get_data(map, mw->buffer, size, offset);\n\tif (bytes != size)\n\t\treturn GF_IO_ERR;\n\t//write it to our stream...\n\tbytes = gf_bs_write_data(bs, mw->buffer, size);\n\tif (bytes != size)\n\t\treturn GF_IO_ERR;\n\n\tmw->nb_done+=nb_samp;\n\tmuxer_report_progress(mw);\n\treturn GF_OK;\n}\n\n//flush as much as possible from current chunk for constand size and duration (typically raw audio)\n// We don't want to write samples outside of the current source chunk\n//since the next chunk might be edited (different bitstream object), which would complexify WriteSample code\n//not flushing the chunk will work, but result in very slow writing of raw audio\nvoid update_writer_constant_dur(GF_ISOFile *movie, TrackWriter *tkw, GF_StscEntry *stsc_ent, u32 *nb_samp, u32 *samp_size, Bool is_flat)\n{\n\tu64 chunk_dur;\n\tu32 nb_in_run;\n\tu32 samp_idx_in_chunk, nb_samp_left_in_src_chunk;\n\tif (!tkw->constant_dur) return;\n\n\tsamp_idx_in_chunk = tkw->sampleNumber - tkw->stbl->SampleToChunk->firstSampleInCurrentChunk;\n\tnb_samp_left_in_src_chunk = stsc_ent->samplesPerChunk - samp_idx_in_chunk;\n\n\tif (nb_samp_left_in_src_chunk<=1) return;\n\n\tif (is_flat) {\n\t\tnb_in_run = nb_samp_left_in_src_chunk;\n\t} else {\n\n\t\tchunk_dur = movie->interleavingTime * tkw->timeScale;\n\t\tif (movie->moov && movie->moov->mvhd && movie->moov->mvhd->timeScale)\n\t\t\tchunk_dur /= movie->moov->mvhd->timeScale;\n\n\t\tchunk_dur -= tkw->chunkDur;\n\n\t\tif (chunk_dur <= tkw->chunkDur) return;\n\t\tchunk_dur -= tkw->constant_dur;\n\n\t\tnb_in_run = (u32) (chunk_dur / tkw->constant_dur);\n\n\t\tif (nb_in_run > nb_samp_left_in_src_chunk) {\n\t\t\tnb_in_run = nb_samp_left_in_src_chunk;\n\t\t}\n\t}\n\tif (tkw->sampleNumber + nb_in_run >= tkw->stbl->SampleSize->sampleCount) {\n\t\tnb_in_run = tkw->stbl->SampleSize->sampleCount - tkw->sampleNumber;\n\t}\n\n\tchunk_dur = nb_in_run * tkw->constant_dur;\n\n\ttkw->chunkDur += (u32) chunk_dur - tkw->constant_dur; //because tkw->chunkDur already include duration of first sample of chunk\n\ttkw->DTSprev += chunk_dur - tkw->constant_dur; //because nb_samp += nb_in_run-1\n\n\t*nb_samp = nb_in_run;\n\t*samp_size = nb_in_run * tkw->constant_size;\n}\n\n\n//replace the chunk and offset tables...\nstatic GF_Err store_meta_item_sample_ref_offsets(GF_ISOFile *movie, GF_List *writers, GF_MetaBox *meta)\n{\n\tu32 i, count;\n\tTrackWriter *writer;\n\tGF_Box *stco;\n\tGF_SampleToChunkBox *stsc;\n\n\tif (!movie->moov) return GF_OK;\n\tif (!meta->item_locations) return GF_OK;\n\tif (!meta->use_item_sample_sharing) return GF_OK;\n\n\t//switch all our tables\n\ti=0;\n\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t//don't delete them !!!\n\t\tstsc = writer->stbl->SampleToChunk;\n\t\tstco = writer->stbl->ChunkOffset;\n\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, stsc);\n\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, stco);\n\t\twriter->stbl->SampleToChunk = writer->stsc;\n\t\twriter->stbl->ChunkOffset = writer->stco;\n\t\tgf_list_insert(writer->stbl->child_boxes, writer->stsc, stsc_pos);\n\t\tgf_list_insert(writer->stbl->child_boxes, writer->stco, stco_pos);\n\t\twriter->stco = stco;\n\t\twriter->stsc = stsc;\n\t}\n\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_ItemExtentEntry *entry;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t}\n\t\tif (!iinf || !iinf->tk_id || !iinf->sample_num) continue;\n\n\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\tif (!entry) continue;\n\n\t\tGF_ISOSample *samp = gf_isom_get_sample_info(movie, gf_isom_get_track_by_id(movie, iinf->tk_id), iinf->sample_num, NULL, &entry->extent_offset);\n\t\tif (samp) gf_isom_sample_del(&samp);\n\t\tentry->extent_offset -= iloc->base_offset;\n\t}\n\n\t//and re-switch our table. We have to do it that way because it is\n\t//needed when the moov is written first\n\ti=0;\n\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t//don't delete them !!!\n\t\tstsc = writer->stsc;\n\t\tstco = writer->stco;\n\t\twriter->stsc = writer->stbl->SampleToChunk;\n\t\twriter->stco = writer->stbl->ChunkOffset;\n\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\n\t\twriter->stbl->SampleToChunk = stsc;\n\t\twriter->stbl->ChunkOffset = stco;\n\t\tgf_list_insert(writer->stbl->child_boxes, stsc, stsc_pos);\n\t\tgf_list_insert(writer->stbl->child_boxes, stco, stco_pos);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err DoWriteMeta(GF_ISOFile *file, GF_MetaBox *meta, GF_BitStream *bs, Bool Emulation, u64 baseOffset, u64 *mdatSize)\n{\n\tGF_ItemExtentEntry *entry;\n\tu64 maxExtendOffset, maxExtendSize;\n\tu32 i, j, count;\n\n\tmaxExtendOffset = 0;\n\tmaxExtendSize = 0;\n\tif (mdatSize) *mdatSize = 0;\n\tif (!meta->item_locations) return GF_OK;\n\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu64 it_size;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t\tiinf = NULL;\n\t\t}\n\n\t\tif (!iloc->base_offset && (gf_list_count(iloc->extent_entries)==1)) {\n\t\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\tif (!entry->extent_length && !entry->original_extent_offset && !entry->extent_index) {\n\t\t\t\tentry->extent_offset = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tit_size = 0;\n\t\t/*for self contained only*/\n\t\tif (!iloc->data_reference_index) {\n\t\t\tif (iloc->construction_method != 2) {\n\t\t\t\tiloc->base_offset = baseOffset;\n\t\t\t}\n\n\t\t\t/*new resource*/\n\t\t\tif (iinf && (iinf->full_path || (iinf->tk_id && iinf->sample_num))) {\n\t\t\t\tFILE *src=NULL;\n\n\t\t\t\tif (!iinf->data_len && iinf->full_path) {\n\t\t\t\t\tsrc = gf_fopen(iinf->full_path, \"rb\");\n\t\t\t\t\tif (!src) continue;\n\t\t\t\t\tit_size = gf_fsize(src);\n\t\t\t\t} else {\n\t\t\t\t\tit_size = iinf->data_len;\n\t\t\t\t}\n\t\t\t\tif (maxExtendSize<it_size) maxExtendSize = it_size;\n\n\t\t\t\tif (!gf_list_count(iloc->extent_entries)) {\n\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemExtentEntry);\n\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(iloc->extent_entries, entry);\n\t\t\t\t}\n\t\t\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\t\tentry->extent_offset = 0;\n\t\t\t\tentry->extent_length = it_size;\n\n\t\t\t\t//shared data, do not count it\n\t\t\t\tif (iinf->tk_id && iinf->sample_num) {\n\t\t\t\t\tit_size = 0;\n\t\t\t\t\tmaxExtendOffset = 0xFFFFFFFFFFUL;\n\t\t\t\t\tif (Emulation) {\n\t\t\t\t\t\tmeta->use_item_sample_sharing = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OK write to mdat*/\n\t\t\t\tif (!Emulation) {\n\t\t\t\t\tif (iinf->tk_id && iinf->sample_num) {\n\t\t\t\t\t}\n\t\t\t\t\telse if (src) {\n\t\t\t\t\t\tchar cache_data[4096];\n\t\t\t\t\t\tu64 remain = entry->extent_length;\n\t\t\t\t\t\twhile (remain) {\n\t\t\t\t\t\t\tu32 size_cache = (remain>4096) ? 4096 : (u32) remain;\n\t\t\t\t\t\t\tsize_t read = gf_fread(cache_data, size_cache, src);\n\t\t\t\t\t\t\tif (read ==(size_t) -1) break;\n\t\t\t\t\t\t\tgf_bs_write_data(bs, cache_data, (u32) read);\n\t\t\t\t\t\t\tremain -= (u32) read;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bs_write_data(bs, iinf->full_path, iinf->data_len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (src) gf_fclose(src);\n\t\t\t}\n\t\t\telse if (gf_list_count(iloc->extent_entries)) {\n\t\t\t\tj=0;\n\t\t\t\twhile ((entry = (GF_ItemExtentEntry *)gf_list_enum(iloc->extent_entries, &j))) {\n\t\t\t\t\tif (entry->extent_index) continue;\n\t\t\t\t\tif (j && (maxExtendOffset<it_size) ) maxExtendOffset = it_size;\n\t\t\t\t\t/*compute new offset*/\n\t\t\t\t\tentry->extent_offset = baseOffset + it_size;\n\n\t\t\t\t\tit_size += entry->extent_length;\n\t\t\t\t\tif (maxExtendSize<entry->extent_length) maxExtendSize = entry->extent_length;\n\n\t\t\t\t\t/*Reading from the input file*/\n\t\t\t\t\tif (!Emulation) {\n\t\t\t\t\t\tchar cache_data[4096];\n\t\t\t\t\t\tu64 remain = entry->extent_length;\n\t\t\t\t\t\tgf_bs_seek(file->movieFileMap->bs, entry->original_extent_offset + iloc->original_base_offset);\n\t\t\t\t\t\twhile (remain) {\n\t\t\t\t\t\t\tu32 size_cache = (remain>4096) ? 4096 : (u32) remain;\n\t\t\t\t\t\t\tgf_bs_read_data(file->movieFileMap->bs, cache_data, size_cache);\n\t\t\t\t\t\t\t/*Writing to the output file*/\n\t\t\t\t\t\t\tgf_bs_write_data(bs, cache_data, size_cache);\n\t\t\t\t\t\t\tremain -= size_cache;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbaseOffset += it_size;\n\t\t\tif (mdatSize)\n\t\t\t\t*mdatSize += it_size;\n\t\t} else {\n\t\t\t/*we MUST have at least one extent for the dref data*/\n\t\t\tif (!gf_list_count(iloc->extent_entries)) {\n\t\t\t\tGF_SAFEALLOC(entry, GF_ItemExtentEntry);\n\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\tgf_list_add(iloc->extent_entries, entry);\n\t\t\t}\n\t\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\tentry->extent_offset = 0;\n\t\t\t/*0 means full length of referenced file*/\n\t\t\tentry->extent_length = 0;\n\t\t}\n\t}\n\n\t/*update offset & size length fields*/\n\tif (baseOffset>0xFFFFFFFF) meta->item_locations->base_offset_size = 8;\n\telse if (baseOffset) meta->item_locations->base_offset_size = 4;\n\n\tif (maxExtendSize>0xFFFFFFFF) meta->item_locations->length_size = 8;\n\telse if (maxExtendSize) meta->item_locations->length_size = 4;\n\n\tif (maxExtendOffset>0xFFFFFFFF) meta->item_locations->offset_size = 8;\n\telse if (maxExtendOffset) meta->item_locations->offset_size = 4;\n\treturn GF_OK;\n}\n\n//this function writes track by track in the order of tracks inside the moov...\nGF_Err DoWrite(MovieWriter *mw, GF_List *writers, GF_BitStream *bs, u8 Emulation, u64 StartOffset)\n{\n\tu32 i;\n\tGF_Err e;\n\tTrackWriter *writer;\n\tu64 offset, sampOffset, predOffset;\n\tu32 chunkNumber, descIndex, sampSize;\n\tBool force;\n\tGF_StscEntry *stsc_ent;\n\tu64 size, mdatSize = 0;\n\tGF_ISOFile *movie = mw->movie;\n\n\t/*write meta content first - WE DON'T support fragmentation of resources in ISOM atm*/\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (movie->meta) {\n\t\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\t\tif (e) return e;\n\t\t\tmdatSize += size;\n\t\t\tStartOffset += size;\n\t\t}\n\t\tif (movie->moov && movie->moov->meta) {\n\t\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\t\tif (e) return e;\n\t\t\tmdatSize += size;\n\t\t\tStartOffset += size;\n\t\t}\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\tif (writer->mdia->mediaTrack->meta) {\n\t\t\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\t\t\tif (e) return e;\n\t\t\t\tmdatSize += size;\n\t\t\t\tStartOffset += size;\n\t\t\t}\n\t\t}\n\t}\n\n\toffset = StartOffset;\n\tpredOffset = 0;\n\ti=0;\n\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\twhile (!writer->isDone) {\n\t\t\tBool self_contained;\n\t\t\tu32 nb_samp=1;\n\t\t\t//To Check: are empty sample tables allowed ???\n\t\t\tif (writer->sampleNumber > writer->stbl->SampleSize->sampleCount) {\n\t\t\t\twriter->isDone = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = stbl_GetSampleInfos(writer->stbl, writer->sampleNumber, &sampOffset, &chunkNumber, &descIndex, &stsc_ent);\n\t\t\tif (e) return e;\n\t\t\te = stbl_GetSampleSize(writer->stbl->SampleSize, writer->sampleNumber, &sampSize);\n\t\t\tif (e) return e;\n\n\t\t\tupdate_writer_constant_dur(movie, writer, stsc_ent, &nb_samp, &sampSize, GF_TRUE);\n\n\t\t\t//update our chunks.\n\t\t\tforce = 0;\n\t\t\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\t\t\toffset = sampOffset;\n\t\t\t\tif (predOffset != offset)\n\t\t\t\t\tforce = 1;\n\t\t\t}\n\n\t\t\tif (writer->stbl->MaxChunkSize && (writer->chunkSize + sampSize > writer->stbl->MaxChunkSize)) {\n\t\t\t\twriter->chunkSize = 0;\n\t\t\t\tforce = 1;\n\t\t\t}\n\t\t\twriter->chunkSize += sampSize;\n\n\t\t\tself_contained = ((writer->all_dref_mode==ISOM_DREF_SELF) || Media_IsSelfContained(writer->mdia, descIndex) ) ? GF_TRUE : GF_FALSE;\n\n\t\t\t//update our global offset...\n\t\t\tif (self_contained) {\n\t\t\t\te = stbl_SetChunkAndOffset(writer->stbl, writer->sampleNumber, descIndex, writer->stsc, &writer->stco, offset, force, nb_samp);\n\t\t\t\tif (e) return e;\n\t\t\t\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\t\t\t\tpredOffset = sampOffset + sampSize;\n\t\t\t\t} else {\n\t\t\t\t\toffset += sampSize;\n\t\t\t\t\tmdatSize += sampSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (predOffset != offset) force = 1;\n\t\t\t\tpredOffset = sampOffset + sampSize;\n\t\t\t\t//we have a DataRef, so use the offset idicated in sampleToChunk and ChunkOffset tables...\n\t\t\t\te = stbl_SetChunkAndOffset(writer->stbl, writer->sampleNumber, descIndex, writer->stsc, &writer->stco, sampOffset, force, nb_samp);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//we write the sample if not emulation\n\t\t\tif (!Emulation) {\n\t\t\t\tif (self_contained) {\n\t\t\t\t\te = WriteSample(mw, sampSize, sampOffset, stsc_ent->isEdited, bs, 1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ok, the track is done\n\t\t\tif (writer->sampleNumber >= writer->stbl->SampleSize->sampleCount) {\n\t\t\t\twriter->isDone = 1;\n\t\t\t} else {\n\t\t\t\twriter->sampleNumber += nb_samp;\n\t\t\t}\n\t\t}\n\t}\n\t//set the mdatSize...\n\tmovie->mdat->dataSize = mdatSize;\n\treturn GF_OK;\n}\n\n\n//write the file track by track, with moov box before or after the mdat\nstatic GF_Err WriteFlat(MovieWriter *mw, u8 moovFirst, GF_BitStream *bs, Bool non_seakable, Bool for_fragments, GF_BitStream *moov_bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu64 offset, finalOffset, totSize, begin, firstSize, finalSize;\n\tGF_Box *a, *cprt_box=NULL;\n\tGF_List *writers = gf_list_new();\n\tGF_ISOFile *movie = mw->movie;\n\ts32 moov_meta_pos=-1;\n\n\t//in case we did a read on the file while producing it, seek to end of edit\n\ttotSize = gf_bs_get_size(bs);\n\tif (gf_bs_get_position(bs) != totSize) {\n\t\tgf_bs_seek(bs, totSize);\n\t}\n\tbegin = totSize = 0;\n\n\t//first setup the writers\n\te = SetupWriters(mw, writers, 0);\n\tif (e) goto exit;\n\n\tif (!moovFirst) {\n\t\tif ((movie->openMode == GF_ISOM_OPEN_WRITE) && !non_seakable) {\n\t\t\tbegin = 0;\n\t\t\ttotSize = gf_isom_datamap_get_offset(movie->editFileMap);\n\t\t\t/*start boxes have not been written yet, do it*/\n\t\t\tif (!totSize) {\n\t\t\t\tif (movie->is_jp2) {\n\t\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, 12);\n\t\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, GF_ISOM_BOX_TYPE_JP);\n\t\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, 0x0D0A870A);\n\t\t\t\t\ttotSize += 12;\n\t\t\t\t\tbegin += 12;\n\t\t\t\t}\n\t\t\t\tif (movie->brand) {\n\t\t\t\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\ttotSize += movie->brand->size;\n\t\t\t\t\tbegin += movie->brand->size;\n\t\t\t\t}\n\t\t\t\tif (movie->pdin) {\n\t\t\t\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\ttotSize += movie->pdin->size;\n\t\t\t\t\tbegin += movie->pdin->size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (movie->is_jp2) begin += 12;\n\t\t\t\tif (movie->brand) begin += movie->brand->size;\n\t\t\t\tif (movie->pdin) begin += movie->pdin->size;\n\t\t\t}\n\t\t\ttotSize -= begin;\n\t\t} else if (!non_seakable || for_fragments) {\n\t\t\tif (movie->is_jp2) {\n\t\t\t\tgf_bs_write_u32(bs, 12);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_JP);\n\t\t\t\tgf_bs_write_u32(bs, 0x0D0A870A);\n\t\t\t}\n\t\t\tif (movie->brand) {\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write((GF_Box *)movie->brand, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\t/*then progressive download*/\n\t\t\tif (movie->pdin) {\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write((GF_Box *)movie->pdin, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t}\n\n\t\t//if the moov is at the end, write directly\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\t\tswitch (a->type) {\n\t\t\t/*written by hand*/\n\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\tmoov_meta_pos = i-1;\n\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t\t\tcase GF_ISOM_BOX_TYPE_AFRA:\n\t\t\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t//in case we're capturing\n\t\t\t\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\t\t\t\t//emulate a write to recreate our tables (media data already written)\n\t\t\t\t\te = DoWrite(mw, writers, bs, 1, begin);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (non_seakable) {\n\t\t\t\t\tbegin = gf_bs_get_position(bs);\n\t\t\t\t\t//do a sim pass to get the true mdat size\n\t\t\t\t\te = DoWrite(mw, writers, bs, 1, begin);\n\t\t\t\t\tif (e) goto exit;\n\n\t\t\t\t\tif (movie->mdat->dataSize > 0xFFFFFFFF) {\n\t\t\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bs_write_u32(bs, (u32) movie->mdat->dataSize + 8);\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\t\tif (movie->mdat->dataSize > 0xFFFFFFFF) gf_bs_write_u64(bs, movie->mdat->dataSize + 8 + 8);\n\t\t\t\t\t//reset writers and write samples\n\t\t\t\t\tResetWriters(writers);\n\t\t\t\t\te = DoWrite(mw, writers, bs, 0, gf_bs_get_position(bs));\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tmovie->mdat->size = movie->mdat->dataSize;\n\t\t\t\t\ttotSize = 0;\n\t\t\t\t} else {\n\t\t\t\t\t//to avoid computing the size each time write always 4 + 4 + 8 bytes before\n\t\t\t\t\tbegin = gf_bs_get_position(bs);\n\t\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t\t\te = DoWrite(mw, writers, bs, 0, gf_bs_get_position(bs));\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\ttotSize = gf_bs_get_position(bs) - begin;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_ISOM_BOX_TYPE_FREE:\n\t\t\t\t//for backward compat with old arch, keep copyright before moov\n\t\t\t\tif (((GF_FreeSpaceBox*)a)->dataSize>4) {\n\t\t\t\t\tGF_FreeSpaceBox *fr = (GF_FreeSpaceBox*) a;\n\t\t\t\t\tif ((fr->dataSize>20) && !strncmp(fr->data, \"IsoMedia File\", 13)) {\n\t\t\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t\tcprt_box = a;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif (moov_meta_pos < 0) {\n\t\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (moov_bs) {\n\t\t\te = DoWrite(mw, writers, bs, 1, movie->mdat->bsOffset);\n\t\t\tif (e) goto exit;\n\n\t\t\tfirstSize = GetMoovAndMetaSize(movie, writers);\n\n\t\t\toffset = firstSize;\n\t\t\te = ShiftOffset(movie, writers, offset);\n\t\t\tif (e) goto exit;\n\t\t\t//get the size and see if it has changed (eg, we moved to 64 bit offsets)\n\t\t\tfinalSize = GetMoovAndMetaSize(movie, writers);\n\t\t\tif (firstSize != finalSize) {\n\t\t\t\tfinalOffset = finalSize;\n\t\t\t\t//OK, now we're sure about the final size.\n\t\t\t\t//we don't need to re-emulate, as the only thing that changed is the offset\n\t\t\t\t//so just shift the offset\n\t\t\t\te = ShiftOffset(movie, writers, finalOffset - offset);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t}\n\t\t//get real sample offsets for meta items\n\t\tif (movie->meta) {\n\t\t\tstore_meta_item_sample_ref_offsets(movie, writers, movie->meta);\n\t\t}\n\t\t//OK, write the movie box.\n\t\te = WriteMoovAndMeta(movie, writers, moov_bs ? moov_bs : bs);\n\t\tif (e) goto exit;\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\t\tswitch (a->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_AFRA:\n\t\t\tcase GF_ISOM_BOX_TYPE_ABST:\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*if data has been written, update mdat size*/\n\t\tif (totSize) {\n\t\t\toffset = gf_bs_get_position(bs);\n\t\t\te = gf_bs_seek(bs, begin);\n\t\t\tif (e) goto exit;\n\t\t\tif (totSize > 0xFFFFFFFF) {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32) totSize);\n\t\t\t}\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\t\tif (totSize > 0xFFFFFFFF) gf_bs_write_u64(bs, totSize);\n\t\t\te = gf_bs_seek(bs, offset);\n\t\t\tmovie->mdat->size = totSize;\n\t\t}\n\n\t\t//then the rest\n\t\ti = (u32) (moov_meta_pos + 1);\n\t\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\t\tif (a==cprt_box) continue;\n\n\t\t\tswitch (a->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t}\n\t\tgoto exit;\n\t}\n\n\t//nope, we have to write the moov first. The pb is that\n\t//1 - we don't know its size till the mdat is written\n\t//2 - we don't know the ofset at which the mdat will start...\n\t//3 - once the mdat is written, the chunkOffset table can have changed...\n\n\tif (movie->is_jp2) {\n\t\tgf_bs_write_u32(bs, 12);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_JP);\n\t\tgf_bs_write_u32(bs, 0x0D0A870A);\n\t}\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, bs);\n\t\tif (e) goto exit;\n\t}\n\t/*then progressive dnload*/\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, bs);\n\t\tif (e) goto exit;\n\t}\n\n\t//write all boxes before moov\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tmoov_meta_pos = i-1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\t//for backward compat with old arch keep out copyright after moov\n\t\tcase GF_ISOM_BOX_TYPE_FREE:\n\t\t\tif (((GF_FreeSpaceBox*)a)->dataSize>4) {\n\t\t\t\tGF_FreeSpaceBox *fr = (GF_FreeSpaceBox*) a;\n\t\t\t\tif ((fr->dataSize>20) && !strncmp(fr->data, \"IsoMedia File\", 13)) {\n\t\t\t\t\tcprt_box = a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tif (moov_meta_pos<0) {\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//What we will do is first emulate the write from the beginning...\n\t//note: this will set the size of the mdat\n\te = DoWrite(mw, writers, bs, 1, gf_bs_get_position(bs));\n\tif (e) goto exit;\n\n\tfirstSize = GetMoovAndMetaSize(movie, writers);\n\t//offset = (firstSize > 0xFFFFFFFF ? firstSize + 8 : firstSize) + 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\toffset = firstSize + 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\te = ShiftOffset(movie, writers, offset);\n\tif (e) goto exit;\n\t//get the size and see if it has changed (eg, we moved to 64 bit offsets)\n\tfinalSize = GetMoovAndMetaSize(movie, writers);\n\tif (firstSize != finalSize) {\n\t\tfinalOffset = finalSize + 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\t\t//OK, now we're sure about the final size.\n\t\t//we don't need to re-emulate, as the only thing that changed is the offset\n\t\t//so just shift the offset\n\t\te = ShiftOffset(movie, writers, finalOffset - offset);\n\t\tif (e) goto exit;\n\t}\n\t//now write our stuff\n\te = WriteMoovAndMeta(movie, writers, bs);\n\tif (e) goto exit;\n\te = gf_isom_box_size((GF_Box *)movie->mdat);\n\tif (e) goto exit;\n\te = gf_isom_box_write((GF_Box *)movie->mdat, bs);\n\tif (e) goto exit;\n\n\t//we don't need the offset as the moov is already written...\n\tResetWriters(writers);\n\te = DoWrite(mw, writers, bs, 0, 0);\n\tif (e) goto exit;\n\n\t//then the rest\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif ((i-1<= (u32) moov_meta_pos) && (a!=cprt_box)) continue;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\nexit:\n\tCleanWriters(writers);\n\tgf_list_del(writers);\n\treturn e;\n}\n\nGF_Err DoFullInterleave(MovieWriter *mw, GF_List *writers, GF_BitStream *bs, u8 Emulation, u64 StartOffset)\n{\n\n\tu32 i, tracksDone;\n\tTrackWriter *tmp, *curWriter, *prevWriter;\n\tGF_Err e;\n\tu64 DTS, DTStmp, TStmp;\n\ts64 res;\n\tu32 descIndex, sampSize, chunkNumber;\n\tu16 curGroupID, curTrackPriority;\n\tBool forceNewChunk, writeGroup;\n\tGF_StscEntry *stsc_ent;\n\t//this is used to emulate the write ...\n\tu64 offset, totSize, sampOffset;\n\tGF_ISOFile *movie = mw->movie;\n\n\ttotSize = 0;\n\tcurGroupID = 1;\n\n\tprevWriter = NULL;\n\t//we emulate a write from this offset...\n\toffset = StartOffset;\n\ttracksDone = 0;\n\n\t//browse each groups\n\twhile (1) {\n\t\twriteGroup = 1;\n\n\t\t//proceed a group\n\t\twhile (writeGroup) {\n\t\t\tu32 nb_samp = 1;\n\t\t\tBool self_contained, chunked_forced=GF_FALSE;\n\t\t\t//first get the appropriated sample for the min time in this group\n\t\t\tcurWriter = NULL;\n\t\t\tDTStmp = (u64) -1;\n\t\t\tTStmp = 0;\n\t\t\tcurTrackPriority = (u16) -1;\n\n\t\t\ti=0;\n\t\t\twhile ((tmp = (TrackWriter*)gf_list_enum(writers, &i))) {\n\n\t\t\t\t//is it done writing ?\n\t\t\t\t//is it in our group ??\n\t\t\t\tif (tmp->isDone || tmp->stbl->groupID != curGroupID) continue;\n\n\t\t\t\t//OK, get the current sample in this track\n\t\t\t\tstbl_GetSampleDTS(tmp->stbl->TimeToSample, tmp->sampleNumber, &DTS);\n\t\t\t\tres = TStmp ? DTStmp * tmp->timeScale - DTS * TStmp : 0;\n\t\t\t\tif (res < 0) continue;\n\t\t\t\tif ((!res) && curTrackPriority <= tmp->stbl->trackPriority) continue;\n\t\t\t\tcurWriter = tmp;\n\t\t\t\tcurTrackPriority = tmp->stbl->trackPriority;\n\t\t\t\tDTStmp = DTS;\n\t\t\t\tTStmp = tmp->timeScale;\n\t\t\t}\n\t\t\t//no sample found, we're done with this group\n\t\t\tif (!curWriter) {\n\t\t\t\t//we're done with the group\n\t\t\t\twriteGroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//To Check: are empty sample tables allowed ???\n\t\t\tif (curWriter->sampleNumber > curWriter->stbl->SampleSize->sampleCount) {\n\t\t\t\tcurWriter->isDone = 1;\n\t\t\t\ttracksDone ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te = stbl_GetSampleInfos(curWriter->stbl, curWriter->sampleNumber, &sampOffset, &chunkNumber, &descIndex, &stsc_ent);\n\t\t\tif (e) return e;\n\t\t\te = stbl_GetSampleSize(curWriter->stbl->SampleSize, curWriter->sampleNumber, &sampSize);\n\t\t\tif (e) return e;\n\n\t\t\tupdate_writer_constant_dur(movie, curWriter, stsc_ent, &nb_samp, &sampSize, GF_FALSE);\n\n\t\t\tif (curWriter->stbl->MaxChunkSize && (curWriter->chunkSize + sampSize > curWriter->stbl->MaxChunkSize)) {\n\t\t\t\tcurWriter->chunkSize = 0;\n\t\t\t\tchunked_forced = forceNewChunk = 1;\n\t\t\t}\n\t\t\tcurWriter->chunkSize += sampSize;\n\n\t\t\tself_contained = ((curWriter->all_dref_mode==ISOM_DREF_SELF) || Media_IsSelfContained(curWriter->mdia, descIndex) ) ? GF_TRUE : GF_FALSE;\n\n\t\t\t//do we actually write, or do we emulate ?\n\t\t\tif (Emulation) {\n\t\t\t\t//are we in the same track ??? If not, force a new chunk when adding this sample\n\t\t\t\tif (!chunked_forced) {\n\t\t\t\t\tif (curWriter != prevWriter) {\n\t\t\t\t\t\tforceNewChunk = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tforceNewChunk = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//update our offsets...\n\t\t\t\tif (self_contained) {\n\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, offset, forceNewChunk, nb_samp);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\toffset += sampSize;\n\t\t\t\t\ttotSize += sampSize;\n\t\t\t\t} else {\n//\t\t\t\t\tif (curWriter->prev_offset != sampOffset) forceNewChunk = 1;\n\t\t\t\t\tcurWriter->prev_offset = sampOffset + sampSize;\n\n\t\t\t\t\t//we have a DataRef, so use the offset idicated in sampleToChunk\n\t\t\t\t\t//and ChunkOffset tables...\n\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, sampOffset, chunked_forced, nb_samp);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//this is no game, we're writing ....\n\t\t\t\tif (self_contained) {\n\t\t\t\t\te = WriteSample(mw, sampSize, sampOffset, stsc_ent->isEdited, bs, 1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ok, the sample is done\n\t\t\tif (curWriter->sampleNumber == curWriter->stbl->SampleSize->sampleCount) {\n\t\t\t\tcurWriter->isDone = 1;\n\t\t\t\t//one more track done...\n\t\t\t\ttracksDone ++;\n\t\t\t} else {\n\t\t\t\tcurWriter->sampleNumber += nb_samp;\n\t\t\t}\n\t\t\tprevWriter = curWriter;\n\t\t}\n\t\t//if all our track are done, break\n\t\tif (tracksDone == gf_list_count(writers)) break;\n\t\t//go to next group\n\t\tcurGroupID ++;\n\t}\n\tif (movie->mdat)\n\t\tmovie->mdat->dataSize = totSize;\n\treturn GF_OK;\n}\n\n\n\n/*uncomment the following to easily test large file generation. This will prepend 4096*1MByte of 0 before the media data*/\n//#define TEST_LARGE_FILES\n\nGF_Err DoInterleave(MovieWriter *mw, GF_List *writers, GF_BitStream *bs, u8 Emulation, u64 StartOffset, Bool drift_inter)\n{\n\tu32 i, tracksDone;\n\tTrackWriter *tmp, *curWriter;\n\tGF_Err e;\n\tu32 descIndex, sampSize, chunkNumber;\n\tu64 DTS;\n\tu32 moov_timescale;\n\tu16 curGroupID;\n\tBool forceNewChunk, writeGroup;\n\tGF_StscEntry *stsc_ent;\n\t//this is used to emulate the write ...\n\tu64 offset, sampOffset, size, mdatSize;\n\tu32 count;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmdatSize = 0;\n\n#ifdef TEST_LARGE_FILES\n\tif (!Emulation) {\n\t\tchar *blank;\n\t\tu32 count, i;\n\t\ti = count = 0;\n\t\tblank = gf_malloc(sizeof(char)*1024*1024);\n\t\tmemset(blank, 0, sizeof(char)*1024*1024);\n\t\tcount = 4096;\n\t\tmemset(blank, 0, sizeof(char)*1024*1024);\n\t\twhile (i<count) {\n\t\t\tu32 res = gf_bs_write_data(bs, blank, 1024*1024);\n\t\t\tif (res != 1024*1024) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"error writing to disk: only %d bytes written\\n\", res));\n\t\t\t}\n\t\t\ti++;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"writing blank block: %.02f done - %d/%d \\r\", (100.0*i)/count , i, count));\n\t\t}\n\t\tgf_free(blank);\n\t}\n\tmdatSize = 4096*1024;\n\tmdatSize *= 1024;\n#endif\n\n\t/*write meta content first - WE DON'T support fragmentation of resources in ISOM atm*/\n\tif (movie->meta) {\n\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\tif (e) return e;\n\t\tmdatSize += size;\n\t\tStartOffset += (u32) size;\n\t}\n\tif (movie->moov) {\n\t\tif (movie->moov->meta) {\n\t\t\te = DoWriteMeta(movie, movie->moov->meta, bs, Emulation, StartOffset, &size);\n\t\t\tif (e) return e;\n\t\t\tmdatSize += size;\n\t\t\tStartOffset += (u32) size;\n\t\t}\n\t\ti=0;\n\t\twhile ((tmp = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\tif (tmp->mdia->mediaTrack->meta) {\n\t\t\t\te = DoWriteMeta(movie, tmp->mdia->mediaTrack->meta, bs, Emulation, StartOffset, &size);\n\t\t\t\tif (e) return e;\n\t\t\t\tmdatSize += size;\n\t\t\t\tStartOffset += (u32) size;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (movie->storageMode == GF_ISOM_STORE_TIGHT)\n\t\treturn DoFullInterleave(mw, writers, bs, Emulation, StartOffset);\n\n\tcurGroupID = 1;\n\t//we emulate a write from this offset...\n\toffset = StartOffset;\n\ttracksDone = 0;\n\n#ifdef TEST_LARGE_FILES\n\toffset += mdatSize;\n#endif\n\n\tmoov_timescale = movie->moov && movie->moov->mvhd ? movie->moov->mvhd->timeScale : 1000;\n\n\tcount = gf_list_count(writers);\n\t//browse each groups\n\twhile (1) {\n\t\t/*the max DTS the chunk of the current writer*/\n\t\tu64 chunkLastDTS = 0;\n\t\t/*the timescale related to the max DTS*/\n\t\tu32 chunkLastScale = 0;\n\n\t\twriteGroup = 1;\n\n\t\t//proceed a group\n\t\twhile (writeGroup) {\n\t\t\tcurWriter = NULL;\n\t\t\tfor (i=0 ; i < count; i++) {\n\t\t\t\ttmp = (TrackWriter*)gf_list_get(writers, i);\n\n\t\t\t\t//is it done writing ?\n\t\t\t\tif (tmp->isDone) continue;\n\n\t\t\t\t//is it in our group ??\n\t\t\t\tif (tmp->stbl->groupID != curGroupID) continue;\n\n\t\t\t\t//write till this chunk is full on this track...\n\t\t\t\twhile (1) {\n\t\t\t\t\tBool self_contained;\n\t\t\t\t\tu32 nb_samp = 1;\n\t\t\t\t\tu32 sample_dur;\n\t\t\t\t\tu64 chunk_prev_dur;\n\t\t\t\t\t//To Check: are empty sample tables allowed ???\n\t\t\t\t\tif (tmp->sampleNumber > tmp->stbl->SampleSize->sampleCount) {\n\t\t\t\t\t\ttmp->isDone = 1;\n\t\t\t\t\t\ttracksDone ++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t//OK, get the current sample in this track\n\t\t\t\t\tstbl_GetSampleDTS_and_Duration(tmp->stbl->TimeToSample, tmp->sampleNumber, &DTS, &sample_dur);\n\n\t\t\t\t\t//can this sample fit in our chunk ?\n\t\t\t\t\tif ( ( (DTS - tmp->DTSprev) + tmp->chunkDur) * moov_timescale > movie->interleavingTime * tmp->timeScale\n\t\t\t\t\t        /*drift check: reject sample if outside our check window*/\n\t\t\t\t\t        || (drift_inter && chunkLastDTS && ( ((u64)tmp->DTSprev*chunkLastScale) > ((u64)chunkLastDTS*tmp->timeScale)) )\n\t\t\t\t\t   ) {\n\t\t\t\t\t\t//in case the sample is longer than InterleaveTime\n\t\t\t\t\t\tif (!tmp->chunkDur) {\n\t\t\t\t\t\t\tforceNewChunk = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//this one is full. go to next one (exit the loop)\n\t\t\t\t\t\t\ttmp->chunkDur = 0;\n\t\t\t\t\t\t\t//forceNewChunk = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tforceNewChunk = tmp->chunkDur ? 0 : 1;\n\t\t\t\t\t}\n\t\t\t\t\t//OK, we can write this track\n\t\t\t\t\tcurWriter = tmp;\n\n\t\t\t\t\t//small check for first 2 samples (DTS = 0)\n\t\t\t\t\t//only in the old mode can chunkdur be 0 for dts 0\n\t\t\t\t\tif (tmp->sampleNumber == 2 && !tmp->chunkDur && gf_sys_old_arch_compat() ) {\n\t\t\t\t\t\tforceNewChunk = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tchunk_prev_dur = tmp->chunkDur;\n\t\t\t\t\t//FIXME we do not apply patch in test mode for now since this breaks all our hashes, remove this\n\t\t\t\t\t//once we move to filters permanently\n\t\t\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\t\t\ttmp->chunkDur += sample_dur;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//old style, compute based on DTS diff\n\t\t\t\t\t\ttmp->chunkDur += (u32) (DTS - tmp->DTSprev);\n\t\t\t\t\t}\n\t\t\t\t\ttmp->DTSprev = DTS;\n\n\t\t\t\t\te = stbl_GetSampleInfos(curWriter->stbl, curWriter->sampleNumber, &sampOffset, &chunkNumber, &descIndex, &stsc_ent);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\treturn e;\n\t\t\t\t\te = stbl_GetSampleSize(curWriter->stbl->SampleSize, curWriter->sampleNumber, &sampSize);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\treturn e;\n\n\t\t\t\t\tself_contained = ((curWriter->all_dref_mode==ISOM_DREF_SELF) || Media_IsSelfContained(curWriter->mdia, descIndex)) ? GF_TRUE : GF_FALSE;\n\n\t\t\t\t\tupdate_writer_constant_dur(movie, curWriter, stsc_ent, &nb_samp, &sampSize, GF_FALSE);\n\n\t\t\t\t\tif (curWriter->stbl->MaxChunkSize && (curWriter->chunkSize + sampSize > curWriter->stbl->MaxChunkSize)) {\n\t\t\t\t\t\tcurWriter->chunkSize = 0;\n\t\t\t\t\t\ttmp->chunkDur -= chunk_prev_dur;\n\t\t\t\t\t\tforceNewChunk = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcurWriter->chunkSize += sampSize;\n\n\t\t\t\t\t//do we actually write, or do we emulate ?\n\t\t\t\t\tif (Emulation) {\n\t\t\t\t\t\t//update our offsets...\n\t\t\t\t\t\tif (self_contained) {\n\t\t\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, offset, forceNewChunk, nb_samp);\n\t\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\toffset += sampSize;\n\t\t\t\t\t\t\tmdatSize += sampSize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (curWriter->prev_offset != sampOffset) forceNewChunk = 1;\n\t\t\t\t\t\t\tcurWriter->prev_offset = sampOffset + sampSize;\n\n\t\t\t\t\t\t\t//we have a DataRef, so use the offset idicated in sampleToChunk\n\t\t\t\t\t\t\t//and ChunkOffset tables...\n\t\t\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, sampOffset, forceNewChunk, nb_samp);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//we're writing ....\n\t\t\t\t\t\tif (self_contained) {\n\t\t\t\t\t\t\te = WriteSample(mw, sampSize, sampOffset, stsc_ent->isEdited, bs, nb_samp);\n\t\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//ok, the sample is done\n\t\t\t\t\tif (curWriter->sampleNumber >= curWriter->stbl->SampleSize->sampleCount) {\n\t\t\t\t\t\tcurWriter->isDone = 1;\n\t\t\t\t\t\t//one more track done...\n\t\t\t\t\t\ttracksDone ++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurWriter->sampleNumber += nb_samp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*record chunk end-time & track timescale for drift-controled interleaving*/\n\t\t\t\tif (drift_inter && curWriter) {\n\t\t\t\t\tchunkLastScale = curWriter->timeScale;\n\t\t\t\t\tchunkLastDTS = curWriter->DTSprev;\n\t\t\t\t\t/*add one interleave window drift - since the \"maxDTS\" is the previously written one, we will\n\t\t\t\t\thave the following cases:\n\t\t\t\t\t- sample doesn't fit: post-pone and force new chunk\n\t\t\t\t\t- sample time larger than previous chunk time + interleave: post-pone and force new chunk\n\t\t\t\t\t- otherwise store and track becomes current reference\n\n\t\t\t\t\tthis ensures a proper drift regulation (max DTS diff is less than the interleaving window)\n\t\t\t\t\t*/\n\t\t\t\t\tchunkLastDTS += curWriter->timeScale * movie->interleavingTime / moov_timescale;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no sample found, we're done with this group\n\t\t\tif (!curWriter) {\n\t\t\t\twriteGroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//if all our track are done, break\n\t\tif (tracksDone == gf_list_count(writers)) break;\n\t\t//go to next group\n\t\tcurGroupID ++;\n\t}\n\tif (movie->mdat) movie->mdat->dataSize = mdatSize;\n\treturn GF_OK;\n}\n\n\nstatic GF_Err WriteInterleaved(MovieWriter *mw, GF_BitStream *bs, Bool drift_inter)\n{\n\tGF_Err e;\n\tu32 i;\n\ts32 moov_meta_pos=-1;\n\tGF_Box *a, *cprt_box=NULL;\n\tu64 firstSize, finalSize, offset, finalOffset;\n\tGF_List *writers = gf_list_new();\n\tGF_ISOFile *movie = mw->movie;\n\n\t//first setup the writers\n\te = SetupWriters(mw, writers, 1);\n\tif (e) goto exit;\n\n\n\tif (movie->is_jp2) {\n\t\tgf_bs_write_u32(bs, 12);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_JP);\n\t\tgf_bs_write_u32(bs, 0x0D0A870A);\n\t}\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, bs);\n\t\tif (e) goto exit;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, bs);\n\t\tif (e) goto exit;\n\t}\n\n\t//write all boxes before moov\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tmoov_meta_pos = i-1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FREE:\n\t\t\t//for backward compat with old arch, keep copyright before moov\n\t\t\tif (((GF_FreeSpaceBox*)a)->dataSize>4) {\n\t\t\t\tGF_FreeSpaceBox *fr = (GF_FreeSpaceBox*) a;\n\t\t\t\tif ((fr->dataSize>20) && !strncmp(fr->data, \"IsoMedia File\", 13)) {\n\t\t\t\t\tcprt_box = a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tif (moov_meta_pos<0) {\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\te = DoInterleave(mw, writers, bs, 1, gf_bs_get_position(bs), drift_inter);\n\tif (e) goto exit;\n\n\tfirstSize = GetMoovAndMetaSize(movie, writers);\n\toffset = firstSize;\n\tif (movie->mdat && movie->mdat->dataSize) offset += 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\te = ShiftOffset(movie, writers, offset);\n\tif (e) goto exit;\n\t//get the size and see if it has changed (eg, we moved to 64 bit offsets)\n\tfinalSize = GetMoovAndMetaSize(movie, writers);\n\tif (firstSize != finalSize) {\n\t\tfinalOffset = finalSize;\n\t\tif (movie->mdat && movie->mdat->dataSize) finalOffset += 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\t\t//OK, now we're sure about the final size -> shift the offsets\n\t\t//we don't need to re-emulate, as the only thing that changed is the offset\n\t\t//so just shift the offset\n\t\te = ShiftOffset(movie, writers, finalOffset - offset);\n\t\tif (e) goto exit;\n\t\t/*firstSize = */GetMoovAndMetaSize(movie, writers);\n\t}\n\t//get real sample offsets for meta items\n\tif (movie->meta) {\n\t\tstore_meta_item_sample_ref_offsets(movie, writers, movie->meta);\n\t}\n\t//now write our stuff\n\te = WriteMoovAndMeta(movie, writers, bs);\n\tif (e) goto exit;\n\n\t/*we have 8 extra bytes for large size (not computed in gf_isom_box_size) */\n\tif (movie->mdat && movie->mdat->dataSize) {\n\t\tif (movie->mdat->dataSize > 0xFFFFFFFF) movie->mdat->dataSize += 8;\n\t\te = gf_isom_box_size((GF_Box *)movie->mdat);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->mdat, bs);\n\t\tif (e) goto exit;\n\t}\n\n\t//we don't need the offset as we are writing...\n\tResetWriters(writers);\n\te = DoInterleave(mw, writers, bs, 0, 0, drift_inter);\n\tif (e) goto exit;\n\n\t//then the rest\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif ((i-1 < (u32) moov_meta_pos) && (a != cprt_box))\n\t\t\tcontinue;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\nexit:\n\tCleanWriters(writers);\n\tgf_list_del(writers);\n\treturn e;\n}\n\nextern u32 default_write_buffering_size;\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final);\n\nGF_Err WriteToFile(GF_ISOFile *movie, Bool for_fragments)\n{\n\tMovieWriter mw;\n\tGF_Err e = GF_OK;\n\tif (!movie) return GF_BAD_PARAM;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_copyright(movie);\n\tif (e) return e;\n\n\tmemset(&mw, 0, sizeof(mw));\n\tmw.movie = movie;\n\n\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tGF_TrackBox *trak;\n\t\tif (gf_sys_is_test_mode()) {\n\t\t\tmovie->moov->mvhd->creationTime = 0;\n\t\t\tmovie->moov->mvhd->modificationTime = 0;\n\t\t}\n\t\ti=0;\n\t\twhile ( (trak = gf_list_enum(movie->moov->trackList, &i))) {\n\t\t\tif (gf_sys_is_test_mode()) {\n\t\t\t\ttrak->Header->creationTime = 0;\n\t\t\t\ttrak->Header->modificationTime = 0;\n\t\t\t\tif (trak->Media->handler->nameUTF8 && strstr(trak->Media->handler->nameUTF8, \"@GPAC\")) {\n\t\t\t\t\tgf_free(trak->Media->handler->nameUTF8);\n\t\t\t\t\ttrak->Media->handler->nameUTF8 = gf_strdup(\"MediaHandler\");\n\t\t\t\t}\n\t\t\t\ttrak->Media->mediaHeader->creationTime = 0;\n\t\t\t\ttrak->Media->mediaHeader->modificationTime = 0;\n\t\t\t}\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\tgf_isom_flush_chunk(trak, GF_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\t//capture mode: we don't need a new bitstream\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\t\tGF_BitStream *bs, *moov_bs=NULL;\n\t\t\tu64 mdat_end = gf_bs_get_position(movie->editFileMap->bs);\n\t\t\tu64 mdat_start = movie->mdat->bsOffset;\n\t\t\tu64 mdat_size = mdat_end - mdat_start;\n\n\t\t\tif (for_fragments) {\n\t\t\t\tif (!movie->on_block_out) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tbs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\t\t\t\te = WriteFlat(&mw, 0, bs, GF_TRUE, GF_TRUE, NULL);\n\t\t\t\tmovie->fragmented_file_pos = gf_bs_get_position(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t//seek at end in case we had a read of the file\n\t\t\tgf_bs_seek(movie->editFileMap->bs, gf_bs_get_size(movie->editFileMap->bs) );\n\n\t\t\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && mdat_start && mdat_size) {\n\t\t\t\tmoov_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t}\n\t\t\t//write as non-seekable\n\t\t\te = WriteFlat(&mw, 0, movie->editFileMap->bs, GF_TRUE, GF_FALSE, moov_bs);\n\n\t\t\tmovie->fragmented_file_pos = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\tif (mdat_start && mdat_size) {\n\t\t\t\tu8 data[16];\n\t\t\t\tif (!movie->on_block_out) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block patch callback, cannot patch mdat size in flat storage\\n\"));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\n\t\t\t\t//create a patch packet for mdat covering out 16 bytes (cf FlushCapture)\n\t\t\t\tbs = gf_bs_new(data, 16, GF_BITSTREAM_WRITE);\n\t\t\t\tgf_bs_write_u32(bs, (mdat_size>0xFFFFFFFF) ? 1 : (u32) mdat_size);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif  (mdat_size>0xFFFFFFFF)\n\t\t\t\t\tgf_bs_write_u64(bs, mdat_size);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tmovie->on_block_patch(movie->on_block_out_usr_data, data, 16, mdat_start, GF_FALSE);\n\t\t\t}\n\n\t\t\tif (moov_bs) {\n\t\t\t\tu8 *moov_data;\n\t\t\t\tu32 moov_size;\n\n\t\t\t\tgf_bs_get_content(moov_bs, &moov_data, &moov_size);\n\t\t\t\tgf_bs_del(moov_bs);\n\n\t\t\t\tmovie->on_block_patch(movie->on_block_out_usr_data, moov_data, moov_size, mdat_start, GF_TRUE);\n\t\t\t\tgf_free(moov_data);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_BitStream *moov_bs = NULL;\n\t\t\tif ((movie->storageMode==GF_ISOM_STORE_STREAMABLE) || (movie->storageMode==GF_ISOM_STORE_FASTSTART) ) {\n\t\t\t\tmoov_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t}\n\t\t\te = WriteFlat(&mw, 0, movie->editFileMap->bs, GF_FALSE, GF_FALSE, moov_bs);\n\t\t\tif (moov_bs) {\n\t\t\t\tu8 *moov_data;\n\t\t\t\tu32 moov_size;\n\n\t\t\t\tgf_bs_get_content(moov_bs, &moov_data, &moov_size);\n\t\t\t\tgf_bs_del(moov_bs);\n\t\t\t\tif (!e)\n\t\t\t\t\te = gf_bs_insert_data(movie->editFileMap->bs, moov_data, moov_size, movie->mdat->bsOffset);\n\t\t\t\t\t\n\t\t\t\tgf_free(moov_data);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tFILE *stream=NULL;\n\t\tBool is_stdout = GF_FALSE;\n\t\tGF_BitStream *bs=NULL;\n\t\tif (!strcmp(movie->finalName, \"_gpac_isobmff_redirect\")) {\n\t\t\tif (!movie->on_block_out) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\tbs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\t\t\tis_stdout = GF_TRUE;\n\t\t} else {\n\t\t\tif (!strcmp(movie->finalName, \"std\"))\n\t\t\t\tis_stdout = GF_TRUE;\n\n\t\t\t//OK, we need a new bitstream\n\t\t\tstream = is_stdout ? stdout : gf_fopen(movie->finalName, \"w+b\");\n\t\t\tif (!stream)\n\t\t\t\treturn GF_IO_ERR;\n\t\t\tbs = gf_bs_from_file(stream, GF_BITSTREAM_WRITE);\n\t\t}\n\t\tif (!bs) {\n\t\t\tif (!is_stdout)\n\t\t\t\tgf_fclose(stream);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t\tswitch (movie->storageMode) {\n\t\tcase GF_ISOM_STORE_TIGHT:\n\t\tcase GF_ISOM_STORE_INTERLEAVED:\n\t\t\te = WriteInterleaved(&mw, bs, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\t\t\te = WriteInterleaved(&mw, bs, 1);\n\t\t\tbreak;\n\t\tcase GF_ISOM_STORE_STREAMABLE:\n\t\t\te = WriteFlat(&mw, 1, bs, is_stdout, GF_FALSE, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = WriteFlat(&mw, 0, bs, is_stdout, GF_FALSE, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_bs_del(bs);\n\t\tif (!is_stdout)\n\t\t\tgf_fclose(stream);\n\t}\n\tif (mw.buffer) gf_free(mw.buffer);\n\tif (mw.nb_done<mw.total_samples) {\n\t\tmw.nb_done = mw.total_samples;\n\t\tmuxer_report_progress(&mw);\n\t}\n\treturn e;\n}\n\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n"], "fixing_code": ["\n/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#define GPAC_ISOM_CPRT_NOTICE \"IsoMedia File Produced with GPAC\"\n\n#include <gpac/revision.h>\n#define GPAC_ISOM_CPRT_NOTICE_VERSION GPAC_ISOM_CPRT_NOTICE\" \"GPAC_VERSION \"-rev\" GPAC_GIT_REVISION\n\nstatic GF_Err gf_isom_insert_copyright(GF_ISOFile *movie)\n{\n\tu32 i;\n\tGF_Box *a;\n\tGF_FreeSpaceBox *_free;\n\ti=0;\n\twhile ((a = (GF_Box *)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_FREE) {\n\t\t\t_free = (GF_FreeSpaceBox *)a;\n\t\t\tif (_free->dataSize) {\n\t\t\t\tif (!strcmp(_free->data, GPAC_ISOM_CPRT_NOTICE_VERSION)) return GF_OK;\n\t\t\t\tif (strstr(_free->data, GPAC_ISOM_CPRT_NOTICE)) {\n\t\t\t\t\tgf_free(_free->data);\n\t\t\t\t\t_free->data = gf_strdup(gf_sys_is_test_mode() ? GPAC_ISOM_CPRT_NOTICE : GPAC_ISOM_CPRT_NOTICE_VERSION);\n\t\t\t\t\t_free->dataSize = 1 + (u32) strlen(_free->data);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ta = gf_isom_box_new(GF_ISOM_BOX_TYPE_FREE);\n\tif (!a) return GF_OUT_OF_MEM;\n\t_free = (GF_FreeSpaceBox *)a;\n\t_free->data = gf_strdup(gf_sys_is_test_mode() ? GPAC_ISOM_CPRT_NOTICE : GPAC_ISOM_CPRT_NOTICE_VERSION);\n\t_free->dataSize = (u32) strlen(_free->data) + 1;\n\tif (!_free->data) return GF_OUT_OF_MEM;\n\treturn gf_list_add(movie->TopBoxes, _free);\n}\n\ntypedef struct\n{\n\t/*the curent sample of this track*/\n\tu32 sampleNumber;\n\t/*timeScale of the media (for interleaving)*/\n\tu32 timeScale;\n\t/*this is for generic, time-based interleaving. Expressed in Media TimeScale*/\n\tu64 chunkDur;\n\tu32 chunkSize;\n\tu32 constant_size, constant_dur;\n\n\tu64 DTSprev;\n\tu8 isDone;\n\tu64 prev_offset;\n\tGF_MediaBox *mdia;\n\tGF_SampleTableBox *stbl;\n\n\tu32 all_dref_mode;\n\n\t/*each writer has a sampleToChunck and ChunkOffset tables\n\tthese tables are filled during emulation mode and then will\treplace the table in the GF_SampleTableBox*/\n\tGF_SampleToChunkBox *stsc;\n\t/*we don't know if it's a large offset or not*/\n\tGF_Box *stco;\n\t//track uses a box requiring seeking into the moov during write, we cannot dispatch blocks\n\tBool prevent_dispatch;\n} TrackWriter;\n\ntypedef struct\n{\n\tchar *buffer;\n\tu32 alloc_size;\n\tGF_ISOFile *movie;\n\tu32 total_samples, nb_done;\n} MovieWriter;\n\nvoid CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}\n\nGF_Err ResetWriters(GF_List *writers)\n{\n\tu32 i;\n\tTrackWriter *writer;\n\ti=0;\n\twhile ((writer = (TrackWriter *)gf_list_enum(writers, &i))) {\n\t\twriter->isDone = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->sampleNumber = 1;\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stco->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tgf_free(((GF_ChunkOffsetBox *)writer->stco)->offsets);\n\t\t\t((GF_ChunkOffsetBox *)writer->stco)->offsets = NULL;\n\t\t\t((GF_ChunkOffsetBox *)writer->stco)->nb_entries = 0;\n\t\t\t((GF_ChunkOffsetBox *)writer->stco)->alloc_size = 0;\n\t\t} else {\n\t\t\tgf_free(((GF_ChunkLargeOffsetBox *)writer->stco)->offsets);\n\t\t\t((GF_ChunkLargeOffsetBox *)writer->stco)->offsets = NULL;\n\t\t\t((GF_ChunkLargeOffsetBox *)writer->stco)->nb_entries = 0;\n\t\t\t((GF_ChunkLargeOffsetBox *)writer->stco)->alloc_size = 0;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n{\n\tu32 i, trackCount;\n\tTrackWriter *writer;\n\tGF_TrackBox *trak;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmw->total_samples = mw->nb_done = 0;\n\tif (!movie->moov) return GF_OK;\n\n\ttrackCount = gf_list_count(movie->moov->trackList);\n\tfor (i = 0; i < trackCount; i++) {\n\t\tGF_SampleTableBox *stbl;\n\t\ttrak = gf_isom_get_track(movie->moov, i+1);\n\n\t\tstbl = (trak->Media && trak->Media->information) ? trak->Media->information->sampleTable : NULL;\n\t\tif (!stbl || !stbl->SampleSize || !stbl->ChunkOffset || !stbl->SampleToChunk) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tGF_SAFEALLOC(writer, TrackWriter);\n\t\tif (!writer) goto exit;\n\t\twriter->sampleNumber = 1;\n\t\twriter->mdia = trak->Media;\n\t\twriter->stbl = trak->Media->information->sampleTable;\n\t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n\t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n\n\t\tif (trak->sample_encryption)\n\t\t\twriter->prevent_dispatch = GF_TRUE;\n\n\t\twriter->isDone = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->constant_size = writer->constant_dur = 0;\n\t\tif (writer->stbl->SampleSize->sampleSize)\n\t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n\t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n\t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n\t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n\t\t}\n\t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n\t\t\twriter->constant_size = writer->constant_dur = 0;\n\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\t} else {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t}\n\t\tif (!writer->stco) return GF_OUT_OF_MEM;\n\t\t/*stops from chunk escape*/\n\t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n\t\t/*for progress, assume only one descIndex*/\n\t\tif (Media_IsSelfContained(writer->mdia, 1))\n\t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n\t\t/*optimization for interleaving: put audio last (this can be overridden by priorities)*/\n\t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n\t\t\tgf_list_add(writers, writer);\n\t\t} else {\n\t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n\t\t\t\tgf_list_add(writers, writer);\n\t\t\t} else {\n\t\t\t\tgf_list_insert(writers, writer, 0);\n\t\t\t}\n\t\t}\n\t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n\t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n\nexit:\n\tCleanWriters(writers);\n\treturn GF_OUT_OF_MEM;\n}\n\n\nstatic void ShiftMetaOffset(GF_MetaBox *meta, u64 offset)\n{\n\tu32 i, count;\n\tif (!meta->item_locations) return;\n\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\tif (iloc->data_reference_index) continue;\n\t\tif (iloc->construction_method == 2) continue;\n\t\tif (!iloc->base_offset) {\n\t\t\tGF_ItemExtentEntry *entry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\tif (entry && !entry->extent_length && !entry->original_extent_offset && (gf_list_count(iloc->extent_entries)==1) )\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tiloc->base_offset += offset;\n\t}\n}\n\nstatic GF_Err ShiftOffset(GF_ISOFile *file, GF_List *writers, u64 offset)\n{\n\tu32 i, j, k, l, last;\n\tTrackWriter *writer;\n\tGF_StscEntry *ent;\n\n\tif (file->meta) ShiftMetaOffset(file->meta, offset);\n\tif (file->moov && file->moov->meta) ShiftMetaOffset(file->moov->meta, offset);\n\n\ti=0;\n\twhile ((writer = (TrackWriter *)gf_list_enum(writers, &i))) {\n\t\tif (writer->mdia->mediaTrack->meta) ShiftMetaOffset(writer->mdia->mediaTrack->meta, offset);\n\n\t\t//we have to proceed entry by entry in case a part of the media is not self-contained...\n\t\tfor (j=0; j<writer->stsc->nb_entries; j++) {\n\t\t\tent = &writer->stsc->entries[j];\n\t\t\tif ((writer->all_dref_mode==ISOM_DREF_EXT) || !Media_IsSelfContained(writer->mdia, ent->sampleDescriptionIndex))\n\t\t\t\tcontinue;\n\n\t\t\t//OK, get the chunk(s) number(s) and \"shift\" its (their) offset(s).\n\t\t\tif (writer->stco->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\t\tGF_ChunkLargeOffsetBox *new_stco64 = NULL;\n\t\t\t\tGF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *) writer->stco;\n\n\t\t\t\t//be carefull for the last entry, nextChunk is set to 0 in edit mode...\n\t\t\t\tlast = ent->nextChunk ? ent->nextChunk : stco->nb_entries + 1;\n\t\t\t\tfor (k = ent->firstChunk; k < last; k++) {\n\n\t\t\t\t\t//we need to rewrite the table: only allocate co64 if not done previously and convert all offsets\n\t\t\t\t\t//to co64. Then (whether co64 was created or not) adjust the offset\n\t\t\t\t\t//Do not reassign table until we are done with the current sampleToChunk processing\n\t\t\t\t\t//since we have a test on stco->offsets[k-1], we need to keep stco untouched\n\t\t\t\t\tif (new_stco64 || file->force_co64 || (stco->offsets[k-1] + offset > 0xFFFFFFFF)) {\n\t\t\t\t\t\tif (!new_stco64) {\n\t\t\t\t\t\t\tnew_stco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t\t\t\t\t\tif (!new_stco64) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\tnew_stco64->nb_entries = stco->nb_entries;\n\t\t\t\t\t\t\tnew_stco64->offsets = (u64 *) gf_malloc(new_stco64->nb_entries * sizeof(u64));\n\t\t\t\t\t\t\tif (!new_stco64->offsets) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t//copy over the stco table\n\t\t\t\t\t\t\tfor (l = 0; l < new_stco64->nb_entries; l++) {\n\t\t\t\t\t\t\t\tnew_stco64->offsets[l] = (u64) stco->offsets[l];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_stco64->offsets[k-1] += offset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstco->offsets[k-1] += (u32) offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (new_stco64) {\n\t\t\t\t\t//done with this sampleToChunk entry, replace the box if we moved to co64\n\t\t\t\t\tgf_isom_box_del(writer->stco);\n\t\t\t\t\twriter->stco = (GF_Box *)new_stco64;\n\t\t\t\t\tnew_stco64 = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_ChunkLargeOffsetBox *stco64 = (GF_ChunkLargeOffsetBox *) writer->stco;\n\t\t\t\t//be carefull for the last entry ...\n\t\t\t\tlast = ent->nextChunk ? ent->nextChunk : stco64->nb_entries + 1;\n\t\t\t\tfor (k = ent->firstChunk; k < last; k++) {\n\t\t\t\t\tstco64->offsets[k-1] += offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n\n}\n\n#define COMP_BOX_COST_BYTES\t\t8\n\nGF_Err gf_isom_write_compressed_box(GF_ISOFile *mov, GF_Box *root_box, u32 repl_type, GF_BitStream *bs, u32 *box_csize)\n{\n#ifdef GPAC_DISABLE_ZLIB\n\treturn GF_NOT_SUPPORTED;\n#else\n\tGF_Err e;\n\tGF_BitStream *comp_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(root_box, comp_bs);\n\n\tif (!e) {\n\t\tu8 *box_data;\n\t\tu32 box_size, comp_size;\n\n\t\tif (box_csize)\n\t\t\t*box_csize = (u32) root_box->size;\n\n\t\tgf_bs_get_content(comp_bs, &box_data, &box_size);\n\t\tgf_gz_compress_payload_ex(&box_data, box_size, &comp_size, 8, GF_TRUE, NULL);\n\t\tif (mov->force_compress || (comp_size + COMP_BOX_COST_BYTES < box_size)) {\n\t\t\tif (bs) {\n\t\t\t\tgf_bs_write_u32(bs, comp_size+8);\n\t\t\t\tgf_bs_write_u32(bs, repl_type);\n\t\t\t\tgf_bs_write_data(bs, box_data, comp_size);\n\t\t\t}\n\t\t\tif (box_csize)\n\t\t\t\t*box_csize = comp_size + COMP_BOX_COST_BYTES;\n\t\t} else if (bs) {\n\t\t\tgf_bs_write_data(bs, box_data, box_size);\n\t\t}\n\t\tgf_free(box_data);\n\t}\n\tgf_bs_del(comp_bs);\n\treturn e;\n#endif /*GPAC_DISABLE_ZLIB*/\n}\n\n//replace the chunk and offset tables...\nstatic GF_Err WriteMoovAndMeta(GF_ISOFile *movie, GF_List *writers, GF_BitStream *bs)\n{\n\tu32 i;\n\tTrackWriter *writer;\n\tGF_Err e;\n\tGF_Box *stco;\n\tGF_SampleToChunkBox *stsc;\n\n\tif (movie->meta) {\n\t\t//write the moov box...\n\t\te = gf_isom_box_size((GF_Box *)movie->meta);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->meta, bs);\n\t\tif (e) return e;\n\t}\n\n\tif (movie->moov) {\n\t\tBool prevent_dispatch = GF_FALSE;\n\t\t//switch all our tables\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\t//don't delete them !!!\n\t\t\tstsc = writer->stbl->SampleToChunk;\n\t\t\tstco = writer->stbl->ChunkOffset;\n\t\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, stsc);\n\t\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, stco);\n\t\t\twriter->stbl->SampleToChunk = writer->stsc;\n\t\t\twriter->stbl->ChunkOffset = writer->stco;\n\t\t\tgf_list_insert(writer->stbl->child_boxes, writer->stsc, stsc_pos);\n\t\t\tgf_list_insert(writer->stbl->child_boxes, writer->stco, stco_pos);\n\t\t\twriter->stco = stco;\n\t\t\twriter->stsc = stsc;\n\t\t\tif (writer->prevent_dispatch)\n\t\t\t\tprevent_dispatch = GF_TRUE;\n\t\t}\n\t\tif (prevent_dispatch) {\n\t\t\tgf_bs_prevent_dispatch(bs, GF_TRUE);\n\t\t}\n\t\t//write the moov box...\n\t\te = gf_isom_box_size((GF_Box *)movie->moov);\n\t\tif (e) return e;\n\n\t\tif ((movie->compress_mode==GF_ISO_COMP_ALL) || (movie->compress_mode==GF_ISO_COMP_MOOV)) {\n\t\t\te = gf_isom_write_compressed_box(movie, (GF_Box *) movie->moov, GF_4CC('!', 'm', 'o', 'v'), bs, NULL);\n\t\t} else {\n\t\t\te = gf_isom_box_write((GF_Box *)movie->moov, bs);\n\t\t}\n\n\t\tif (prevent_dispatch) {\n\t\t\tgf_bs_prevent_dispatch(bs, GF_FALSE);\n\t\t}\n\n\t\t//and re-switch our table. We have to do it that way because it is\n\t\t//needed when the moov is written first\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\t//don't delete them !!!\n\t\t\tstsc = writer->stsc;\n\t\t\tstco = writer->stco;\n\t\t\twriter->stsc = writer->stbl->SampleToChunk;\n\t\t\twriter->stco = writer->stbl->ChunkOffset;\n\t\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\n\t\t\twriter->stbl->SampleToChunk = stsc;\n\t\t\twriter->stbl->ChunkOffset = stco;\n\t\t\tgf_list_insert(writer->stbl->child_boxes, stsc, stsc_pos);\n\t\t\tgf_list_insert(writer->stbl->child_boxes, stco, stco_pos);\n\t\t}\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n//compute the size of the moov as it will be written.\nu64 GetMoovAndMetaSize(GF_ISOFile *movie, GF_List *writers)\n{\n\tu32 i;\n\tu64 size;\n\n\tsize = 0;\n\tif (movie->moov) {\n\t\tTrackWriter *writer;\n\t\tgf_isom_box_size((GF_Box *)movie->moov);\n\t\tsize = movie->moov->size;\n\t\tif (size > 0xFFFFFFFF) size += 8;\n\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\tsize -= writer->stbl->ChunkOffset->size;\n\t\t\tsize -= writer->stbl->SampleToChunk->size;\n\t\t\tgf_isom_box_size((GF_Box *)writer->stsc);\n\t\t\tgf_isom_box_size(writer->stco);\n\t\t\tsize += writer->stsc->size;\n\t\t\tsize += writer->stco->size;\n\t\t}\n\t}\n\tif (movie->meta) {\n\t\tu64 msize;\n\t\tgf_isom_box_size((GF_Box *)movie->meta);\n\t\tmsize = movie->meta->size;\n\t\tif (msize > 0xFFFFFFFF) msize += 8;\n\t\tsize += msize;\n\t}\n\treturn size;\n}\n\nstatic void muxer_report_progress(MovieWriter *mw)\n{\n\tif (mw->movie->progress_cbk) {\n\t\tmw->movie->progress_cbk(mw->movie->progress_cbk_udta, mw->nb_done, mw->total_samples);\n\t} else {\n\t\tgf_set_progress(\"ISO File Writing\", mw->nb_done, mw->total_samples);\n\t}\n}\n\n//Write a sample to the file - this is only called for self-contained media\nGF_Err WriteSample(MovieWriter *mw, u32 size, u64 offset, u8 isEdited, GF_BitStream *bs, u32 nb_samp)\n{\n\tGF_DataMap *map;\n\tu32 bytes;\n\n\tif (!size) return GF_OK;\n\n\tif (size>mw->alloc_size) {\n\t\tmw->buffer = (char*)gf_realloc(mw->buffer, size);\n\t\tmw->alloc_size = size;\n\t}\n\n\tif (!mw->buffer) return GF_OUT_OF_MEM;\n\n\tif (isEdited) {\n\t\tmap = mw->movie->editFileMap;\n\t} else {\n\t\tmap = mw->movie->movieFileMap;\n\t}\n\t//get the payload...\n\tbytes = gf_isom_datamap_get_data(map, mw->buffer, size, offset);\n\tif (bytes != size)\n\t\treturn GF_IO_ERR;\n\t//write it to our stream...\n\tbytes = gf_bs_write_data(bs, mw->buffer, size);\n\tif (bytes != size)\n\t\treturn GF_IO_ERR;\n\n\tmw->nb_done+=nb_samp;\n\tmuxer_report_progress(mw);\n\treturn GF_OK;\n}\n\n//flush as much as possible from current chunk for constand size and duration (typically raw audio)\n// We don't want to write samples outside of the current source chunk\n//since the next chunk might be edited (different bitstream object), which would complexify WriteSample code\n//not flushing the chunk will work, but result in very slow writing of raw audio\nvoid update_writer_constant_dur(GF_ISOFile *movie, TrackWriter *tkw, GF_StscEntry *stsc_ent, u32 *nb_samp, u32 *samp_size, Bool is_flat)\n{\n\tu64 chunk_dur;\n\tu32 nb_in_run;\n\tu32 samp_idx_in_chunk, nb_samp_left_in_src_chunk;\n\tif (!tkw->constant_dur) return;\n\n\tsamp_idx_in_chunk = tkw->sampleNumber - tkw->stbl->SampleToChunk->firstSampleInCurrentChunk;\n\tnb_samp_left_in_src_chunk = stsc_ent->samplesPerChunk - samp_idx_in_chunk;\n\n\tif (nb_samp_left_in_src_chunk<=1) return;\n\n\tif (is_flat) {\n\t\tnb_in_run = nb_samp_left_in_src_chunk;\n\t} else {\n\n\t\tchunk_dur = movie->interleavingTime * tkw->timeScale;\n\t\tif (movie->moov && movie->moov->mvhd && movie->moov->mvhd->timeScale)\n\t\t\tchunk_dur /= movie->moov->mvhd->timeScale;\n\n\t\tchunk_dur -= tkw->chunkDur;\n\n\t\tif (chunk_dur <= tkw->chunkDur) return;\n\t\tchunk_dur -= tkw->constant_dur;\n\n\t\tnb_in_run = (u32) (chunk_dur / tkw->constant_dur);\n\n\t\tif (nb_in_run > nb_samp_left_in_src_chunk) {\n\t\t\tnb_in_run = nb_samp_left_in_src_chunk;\n\t\t}\n\t}\n\tif (tkw->sampleNumber + nb_in_run >= tkw->stbl->SampleSize->sampleCount) {\n\t\tnb_in_run = tkw->stbl->SampleSize->sampleCount - tkw->sampleNumber;\n\t}\n\n\tchunk_dur = nb_in_run * tkw->constant_dur;\n\n\ttkw->chunkDur += (u32) chunk_dur - tkw->constant_dur; //because tkw->chunkDur already include duration of first sample of chunk\n\ttkw->DTSprev += chunk_dur - tkw->constant_dur; //because nb_samp += nb_in_run-1\n\n\t*nb_samp = nb_in_run;\n\t*samp_size = nb_in_run * tkw->constant_size;\n}\n\n\n//replace the chunk and offset tables...\nstatic GF_Err store_meta_item_sample_ref_offsets(GF_ISOFile *movie, GF_List *writers, GF_MetaBox *meta)\n{\n\tu32 i, count;\n\tTrackWriter *writer;\n\tGF_Box *stco;\n\tGF_SampleToChunkBox *stsc;\n\n\tif (!movie->moov) return GF_OK;\n\tif (!meta->item_locations) return GF_OK;\n\tif (!meta->use_item_sample_sharing) return GF_OK;\n\n\t//switch all our tables\n\ti=0;\n\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t//don't delete them !!!\n\t\tstsc = writer->stbl->SampleToChunk;\n\t\tstco = writer->stbl->ChunkOffset;\n\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, stsc);\n\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, stco);\n\t\twriter->stbl->SampleToChunk = writer->stsc;\n\t\twriter->stbl->ChunkOffset = writer->stco;\n\t\tgf_list_insert(writer->stbl->child_boxes, writer->stsc, stsc_pos);\n\t\tgf_list_insert(writer->stbl->child_boxes, writer->stco, stco_pos);\n\t\twriter->stco = stco;\n\t\twriter->stsc = stsc;\n\t}\n\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_ItemExtentEntry *entry;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t}\n\t\tif (!iinf || !iinf->tk_id || !iinf->sample_num) continue;\n\n\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\tif (!entry) continue;\n\n\t\tGF_ISOSample *samp = gf_isom_get_sample_info(movie, gf_isom_get_track_by_id(movie, iinf->tk_id), iinf->sample_num, NULL, &entry->extent_offset);\n\t\tif (samp) gf_isom_sample_del(&samp);\n\t\tentry->extent_offset -= iloc->base_offset;\n\t}\n\n\t//and re-switch our table. We have to do it that way because it is\n\t//needed when the moov is written first\n\ti=0;\n\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t//don't delete them !!!\n\t\tstsc = writer->stsc;\n\t\tstco = writer->stco;\n\t\twriter->stsc = writer->stbl->SampleToChunk;\n\t\twriter->stco = writer->stbl->ChunkOffset;\n\t\ts32 stsc_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\ts32 stco_pos = gf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\n\t\twriter->stbl->SampleToChunk = stsc;\n\t\twriter->stbl->ChunkOffset = stco;\n\t\tgf_list_insert(writer->stbl->child_boxes, stsc, stsc_pos);\n\t\tgf_list_insert(writer->stbl->child_boxes, stco, stco_pos);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err DoWriteMeta(GF_ISOFile *file, GF_MetaBox *meta, GF_BitStream *bs, Bool Emulation, u64 baseOffset, u64 *mdatSize)\n{\n\tGF_ItemExtentEntry *entry;\n\tu64 maxExtendOffset, maxExtendSize;\n\tu32 i, j, count;\n\n\tmaxExtendOffset = 0;\n\tmaxExtendSize = 0;\n\tif (mdatSize) *mdatSize = 0;\n\tif (!meta->item_locations) return GF_OK;\n\n\tcount = gf_list_count(meta->item_locations->location_entries);\n\tfor (i=0; i<count; i++) {\n\t\tu64 it_size;\n\t\tGF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i);\n\t\t/*get item info*/\n\t\tGF_ItemInfoEntryBox *iinf = NULL;\n\t\tj=0;\n\t\twhile ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &j))) {\n\t\t\tif (iinf->item_ID==iloc->item_ID) break;\n\t\t\tiinf = NULL;\n\t\t}\n\n\t\tif (!iloc->base_offset && (gf_list_count(iloc->extent_entries)==1)) {\n\t\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\tif (!entry->extent_length && !entry->original_extent_offset && !entry->extent_index) {\n\t\t\t\tentry->extent_offset = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tit_size = 0;\n\t\t/*for self contained only*/\n\t\tif (!iloc->data_reference_index) {\n\t\t\tif (iloc->construction_method != 2) {\n\t\t\t\tiloc->base_offset = baseOffset;\n\t\t\t}\n\n\t\t\t/*new resource*/\n\t\t\tif (iinf && (iinf->full_path || (iinf->tk_id && iinf->sample_num))) {\n\t\t\t\tFILE *src=NULL;\n\n\t\t\t\tif (!iinf->data_len && iinf->full_path) {\n\t\t\t\t\tsrc = gf_fopen(iinf->full_path, \"rb\");\n\t\t\t\t\tif (!src) continue;\n\t\t\t\t\tit_size = gf_fsize(src);\n\t\t\t\t} else {\n\t\t\t\t\tit_size = iinf->data_len;\n\t\t\t\t}\n\t\t\t\tif (maxExtendSize<it_size) maxExtendSize = it_size;\n\n\t\t\t\tif (!gf_list_count(iloc->extent_entries)) {\n\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemExtentEntry);\n\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(iloc->extent_entries, entry);\n\t\t\t\t}\n\t\t\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\t\tentry->extent_offset = 0;\n\t\t\t\tentry->extent_length = it_size;\n\n\t\t\t\t//shared data, do not count it\n\t\t\t\tif (iinf->tk_id && iinf->sample_num) {\n\t\t\t\t\tit_size = 0;\n\t\t\t\t\tmaxExtendOffset = 0xFFFFFFFFFFUL;\n\t\t\t\t\tif (Emulation) {\n\t\t\t\t\t\tmeta->use_item_sample_sharing = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*OK write to mdat*/\n\t\t\t\tif (!Emulation) {\n\t\t\t\t\tif (iinf->tk_id && iinf->sample_num) {\n\t\t\t\t\t}\n\t\t\t\t\telse if (src) {\n\t\t\t\t\t\tchar cache_data[4096];\n\t\t\t\t\t\tu64 remain = entry->extent_length;\n\t\t\t\t\t\twhile (remain) {\n\t\t\t\t\t\t\tu32 size_cache = (remain>4096) ? 4096 : (u32) remain;\n\t\t\t\t\t\t\tsize_t read = gf_fread(cache_data, size_cache, src);\n\t\t\t\t\t\t\tif (read ==(size_t) -1) break;\n\t\t\t\t\t\t\tgf_bs_write_data(bs, cache_data, (u32) read);\n\t\t\t\t\t\t\tremain -= (u32) read;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bs_write_data(bs, iinf->full_path, iinf->data_len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (src) gf_fclose(src);\n\t\t\t}\n\t\t\telse if (gf_list_count(iloc->extent_entries)) {\n\t\t\t\tj=0;\n\t\t\t\twhile ((entry = (GF_ItemExtentEntry *)gf_list_enum(iloc->extent_entries, &j))) {\n\t\t\t\t\tif (entry->extent_index) continue;\n\t\t\t\t\tif (j && (maxExtendOffset<it_size) ) maxExtendOffset = it_size;\n\t\t\t\t\t/*compute new offset*/\n\t\t\t\t\tentry->extent_offset = baseOffset + it_size;\n\n\t\t\t\t\tit_size += entry->extent_length;\n\t\t\t\t\tif (maxExtendSize<entry->extent_length) maxExtendSize = entry->extent_length;\n\n\t\t\t\t\t/*Reading from the input file*/\n\t\t\t\t\tif (!Emulation) {\n\t\t\t\t\t\tchar cache_data[4096];\n\t\t\t\t\t\tu64 remain = entry->extent_length;\n\t\t\t\t\t\tgf_bs_seek(file->movieFileMap->bs, entry->original_extent_offset + iloc->original_base_offset);\n\t\t\t\t\t\twhile (remain) {\n\t\t\t\t\t\t\tu32 size_cache = (remain>4096) ? 4096 : (u32) remain;\n\t\t\t\t\t\t\tgf_bs_read_data(file->movieFileMap->bs, cache_data, size_cache);\n\t\t\t\t\t\t\t/*Writing to the output file*/\n\t\t\t\t\t\t\tgf_bs_write_data(bs, cache_data, size_cache);\n\t\t\t\t\t\t\tremain -= size_cache;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbaseOffset += it_size;\n\t\t\tif (mdatSize)\n\t\t\t\t*mdatSize += it_size;\n\t\t} else {\n\t\t\t/*we MUST have at least one extent for the dref data*/\n\t\t\tif (!gf_list_count(iloc->extent_entries)) {\n\t\t\t\tGF_SAFEALLOC(entry, GF_ItemExtentEntry);\n\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\tgf_list_add(iloc->extent_entries, entry);\n\t\t\t}\n\t\t\tentry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0);\n\t\t\tentry->extent_offset = 0;\n\t\t\t/*0 means full length of referenced file*/\n\t\t\tentry->extent_length = 0;\n\t\t}\n\t}\n\n\t/*update offset & size length fields*/\n\tif (baseOffset>0xFFFFFFFF) meta->item_locations->base_offset_size = 8;\n\telse if (baseOffset) meta->item_locations->base_offset_size = 4;\n\n\tif (maxExtendSize>0xFFFFFFFF) meta->item_locations->length_size = 8;\n\telse if (maxExtendSize) meta->item_locations->length_size = 4;\n\n\tif (maxExtendOffset>0xFFFFFFFF) meta->item_locations->offset_size = 8;\n\telse if (maxExtendOffset) meta->item_locations->offset_size = 4;\n\treturn GF_OK;\n}\n\n//this function writes track by track in the order of tracks inside the moov...\nGF_Err DoWrite(MovieWriter *mw, GF_List *writers, GF_BitStream *bs, u8 Emulation, u64 StartOffset)\n{\n\tu32 i;\n\tGF_Err e;\n\tTrackWriter *writer;\n\tu64 offset, sampOffset, predOffset;\n\tu32 chunkNumber, descIndex, sampSize;\n\tBool force;\n\tGF_StscEntry *stsc_ent;\n\tu64 size, mdatSize = 0;\n\tGF_ISOFile *movie = mw->movie;\n\n\t/*write meta content first - WE DON'T support fragmentation of resources in ISOM atm*/\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (movie->meta) {\n\t\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\t\tif (e) return e;\n\t\t\tmdatSize += size;\n\t\t\tStartOffset += size;\n\t\t}\n\t\tif (movie->moov && movie->moov->meta) {\n\t\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\t\tif (e) return e;\n\t\t\tmdatSize += size;\n\t\t\tStartOffset += size;\n\t\t}\n\t\ti=0;\n\t\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\tif (writer->mdia->mediaTrack->meta) {\n\t\t\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\t\t\tif (e) return e;\n\t\t\t\tmdatSize += size;\n\t\t\t\tStartOffset += size;\n\t\t\t}\n\t\t}\n\t}\n\n\toffset = StartOffset;\n\tpredOffset = 0;\n\ti=0;\n\twhile ((writer = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\twhile (!writer->isDone) {\n\t\t\tBool self_contained;\n\t\t\tu32 nb_samp=1;\n\t\t\t//To Check: are empty sample tables allowed ???\n\t\t\tif (writer->sampleNumber > writer->stbl->SampleSize->sampleCount) {\n\t\t\t\twriter->isDone = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = stbl_GetSampleInfos(writer->stbl, writer->sampleNumber, &sampOffset, &chunkNumber, &descIndex, &stsc_ent);\n\t\t\tif (e) return e;\n\t\t\te = stbl_GetSampleSize(writer->stbl->SampleSize, writer->sampleNumber, &sampSize);\n\t\t\tif (e) return e;\n\n\t\t\tupdate_writer_constant_dur(movie, writer, stsc_ent, &nb_samp, &sampSize, GF_TRUE);\n\n\t\t\t//update our chunks.\n\t\t\tforce = 0;\n\t\t\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\t\t\toffset = sampOffset;\n\t\t\t\tif (predOffset != offset)\n\t\t\t\t\tforce = 1;\n\t\t\t}\n\n\t\t\tif (writer->stbl->MaxChunkSize && (writer->chunkSize + sampSize > writer->stbl->MaxChunkSize)) {\n\t\t\t\twriter->chunkSize = 0;\n\t\t\t\tforce = 1;\n\t\t\t}\n\t\t\twriter->chunkSize += sampSize;\n\n\t\t\tself_contained = ((writer->all_dref_mode==ISOM_DREF_SELF) || Media_IsSelfContained(writer->mdia, descIndex) ) ? GF_TRUE : GF_FALSE;\n\n\t\t\t//update our global offset...\n\t\t\tif (self_contained) {\n\t\t\t\te = stbl_SetChunkAndOffset(writer->stbl, writer->sampleNumber, descIndex, writer->stsc, &writer->stco, offset, force, nb_samp);\n\t\t\t\tif (e) return e;\n\t\t\t\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\t\t\t\tpredOffset = sampOffset + sampSize;\n\t\t\t\t} else {\n\t\t\t\t\toffset += sampSize;\n\t\t\t\t\tmdatSize += sampSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (predOffset != offset) force = 1;\n\t\t\t\tpredOffset = sampOffset + sampSize;\n\t\t\t\t//we have a DataRef, so use the offset idicated in sampleToChunk and ChunkOffset tables...\n\t\t\t\te = stbl_SetChunkAndOffset(writer->stbl, writer->sampleNumber, descIndex, writer->stsc, &writer->stco, sampOffset, force, nb_samp);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//we write the sample if not emulation\n\t\t\tif (!Emulation) {\n\t\t\t\tif (self_contained) {\n\t\t\t\t\te = WriteSample(mw, sampSize, sampOffset, stsc_ent->isEdited, bs, 1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ok, the track is done\n\t\t\tif (writer->sampleNumber >= writer->stbl->SampleSize->sampleCount) {\n\t\t\t\twriter->isDone = 1;\n\t\t\t} else {\n\t\t\t\twriter->sampleNumber += nb_samp;\n\t\t\t}\n\t\t}\n\t}\n\t//set the mdatSize...\n\tmovie->mdat->dataSize = mdatSize;\n\treturn GF_OK;\n}\n\n\n//write the file track by track, with moov box before or after the mdat\nstatic GF_Err WriteFlat(MovieWriter *mw, u8 moovFirst, GF_BitStream *bs, Bool non_seakable, Bool for_fragments, GF_BitStream *moov_bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu64 offset, finalOffset, totSize, begin, firstSize, finalSize;\n\tGF_Box *a, *cprt_box=NULL;\n\tGF_List *writers = gf_list_new();\n\tGF_ISOFile *movie = mw->movie;\n\ts32 moov_meta_pos=-1;\n\n\t//in case we did a read on the file while producing it, seek to end of edit\n\ttotSize = gf_bs_get_size(bs);\n\tif (gf_bs_get_position(bs) != totSize) {\n\t\tgf_bs_seek(bs, totSize);\n\t}\n\tbegin = totSize = 0;\n\n\t//first setup the writers\n\te = SetupWriters(mw, writers, 0);\n\tif (e) goto exit;\n\n\tif (!moovFirst) {\n\t\tif ((movie->openMode == GF_ISOM_OPEN_WRITE) && !non_seakable) {\n\t\t\tbegin = 0;\n\t\t\ttotSize = gf_isom_datamap_get_offset(movie->editFileMap);\n\t\t\t/*start boxes have not been written yet, do it*/\n\t\t\tif (!totSize) {\n\t\t\t\tif (movie->is_jp2) {\n\t\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, 12);\n\t\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, GF_ISOM_BOX_TYPE_JP);\n\t\t\t\t\tgf_bs_write_u32(movie->editFileMap->bs, 0x0D0A870A);\n\t\t\t\t\ttotSize += 12;\n\t\t\t\t\tbegin += 12;\n\t\t\t\t}\n\t\t\t\tif (movie->brand) {\n\t\t\t\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\ttotSize += movie->brand->size;\n\t\t\t\t\tbegin += movie->brand->size;\n\t\t\t\t}\n\t\t\t\tif (movie->pdin) {\n\t\t\t\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\ttotSize += movie->pdin->size;\n\t\t\t\t\tbegin += movie->pdin->size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (movie->is_jp2) begin += 12;\n\t\t\t\tif (movie->brand) begin += movie->brand->size;\n\t\t\t\tif (movie->pdin) begin += movie->pdin->size;\n\t\t\t}\n\t\t\ttotSize -= begin;\n\t\t} else if (!non_seakable || for_fragments) {\n\t\t\tif (movie->is_jp2) {\n\t\t\t\tgf_bs_write_u32(bs, 12);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_JP);\n\t\t\t\tgf_bs_write_u32(bs, 0x0D0A870A);\n\t\t\t}\n\t\t\tif (movie->brand) {\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write((GF_Box *)movie->brand, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\t/*then progressive download*/\n\t\t\tif (movie->pdin) {\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write((GF_Box *)movie->pdin, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t}\n\n\t\t//if the moov is at the end, write directly\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\t\tswitch (a->type) {\n\t\t\t/*written by hand*/\n\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\tmoov_meta_pos = i-1;\n\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t\t\tcase GF_ISOM_BOX_TYPE_AFRA:\n\t\t\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t//in case we're capturing\n\t\t\t\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\t\t\t\t//emulate a write to recreate our tables (media data already written)\n\t\t\t\t\te = DoWrite(mw, writers, bs, 1, begin);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (non_seakable) {\n\t\t\t\t\tbegin = gf_bs_get_position(bs);\n\t\t\t\t\t//do a sim pass to get the true mdat size\n\t\t\t\t\te = DoWrite(mw, writers, bs, 1, begin);\n\t\t\t\t\tif (e) goto exit;\n\n\t\t\t\t\tif (movie->mdat->dataSize > 0xFFFFFFFF) {\n\t\t\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_bs_write_u32(bs, (u32) movie->mdat->dataSize + 8);\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\t\tif (movie->mdat->dataSize > 0xFFFFFFFF) gf_bs_write_u64(bs, movie->mdat->dataSize + 8 + 8);\n\t\t\t\t\t//reset writers and write samples\n\t\t\t\t\tResetWriters(writers);\n\t\t\t\t\te = DoWrite(mw, writers, bs, 0, gf_bs_get_position(bs));\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tmovie->mdat->size = movie->mdat->dataSize;\n\t\t\t\t\ttotSize = 0;\n\t\t\t\t} else {\n\t\t\t\t\t//to avoid computing the size each time write always 4 + 4 + 8 bytes before\n\t\t\t\t\tbegin = gf_bs_get_position(bs);\n\t\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t\t\te = DoWrite(mw, writers, bs, 0, gf_bs_get_position(bs));\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\ttotSize = gf_bs_get_position(bs) - begin;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_ISOM_BOX_TYPE_FREE:\n\t\t\t\t//for backward compat with old arch, keep copyright before moov\n\t\t\t\tif (((GF_FreeSpaceBox*)a)->dataSize>4) {\n\t\t\t\t\tGF_FreeSpaceBox *fr = (GF_FreeSpaceBox*) a;\n\t\t\t\t\tif ((fr->dataSize>20) && !strncmp(fr->data, \"IsoMedia File\", 13)) {\n\t\t\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t\tcprt_box = a;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif (moov_meta_pos < 0) {\n\t\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (moov_bs) {\n\t\t\te = DoWrite(mw, writers, bs, 1, movie->mdat->bsOffset);\n\t\t\tif (e) goto exit;\n\n\t\t\tfirstSize = GetMoovAndMetaSize(movie, writers);\n\n\t\t\toffset = firstSize;\n\t\t\te = ShiftOffset(movie, writers, offset);\n\t\t\tif (e) goto exit;\n\t\t\t//get the size and see if it has changed (eg, we moved to 64 bit offsets)\n\t\t\tfinalSize = GetMoovAndMetaSize(movie, writers);\n\t\t\tif (firstSize != finalSize) {\n\t\t\t\tfinalOffset = finalSize;\n\t\t\t\t//OK, now we're sure about the final size.\n\t\t\t\t//we don't need to re-emulate, as the only thing that changed is the offset\n\t\t\t\t//so just shift the offset\n\t\t\t\te = ShiftOffset(movie, writers, finalOffset - offset);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t}\n\t\t//get real sample offsets for meta items\n\t\tif (movie->meta) {\n\t\t\tstore_meta_item_sample_ref_offsets(movie, writers, movie->meta);\n\t\t}\n\t\t//OK, write the movie box.\n\t\te = WriteMoovAndMeta(movie, writers, moov_bs ? moov_bs : bs);\n\t\tif (e) goto exit;\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\t\tswitch (a->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_AFRA:\n\t\t\tcase GF_ISOM_BOX_TYPE_ABST:\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*if data has been written, update mdat size*/\n\t\tif (totSize) {\n\t\t\toffset = gf_bs_get_position(bs);\n\t\t\te = gf_bs_seek(bs, begin);\n\t\t\tif (e) goto exit;\n\t\t\tif (totSize > 0xFFFFFFFF) {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32) totSize);\n\t\t\t}\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\t\tif (totSize > 0xFFFFFFFF) gf_bs_write_u64(bs, totSize);\n\t\t\te = gf_bs_seek(bs, offset);\n\t\t\tmovie->mdat->size = totSize;\n\t\t}\n\n\t\t//then the rest\n\t\ti = (u32) (moov_meta_pos + 1);\n\t\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\t\tif (a==cprt_box) continue;\n\n\t\t\tswitch (a->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t}\n\t\tgoto exit;\n\t}\n\n\t//nope, we have to write the moov first. The pb is that\n\t//1 - we don't know its size till the mdat is written\n\t//2 - we don't know the ofset at which the mdat will start...\n\t//3 - once the mdat is written, the chunkOffset table can have changed...\n\n\tif (movie->is_jp2) {\n\t\tgf_bs_write_u32(bs, 12);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_JP);\n\t\tgf_bs_write_u32(bs, 0x0D0A870A);\n\t}\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, bs);\n\t\tif (e) goto exit;\n\t}\n\t/*then progressive dnload*/\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, bs);\n\t\tif (e) goto exit;\n\t}\n\n\t//write all boxes before moov\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tmoov_meta_pos = i-1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\t//for backward compat with old arch keep out copyright after moov\n\t\tcase GF_ISOM_BOX_TYPE_FREE:\n\t\t\tif (((GF_FreeSpaceBox*)a)->dataSize>4) {\n\t\t\t\tGF_FreeSpaceBox *fr = (GF_FreeSpaceBox*) a;\n\t\t\t\tif ((fr->dataSize>20) && !strncmp(fr->data, \"IsoMedia File\", 13)) {\n\t\t\t\t\tcprt_box = a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tif (moov_meta_pos<0) {\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//What we will do is first emulate the write from the beginning...\n\t//note: this will set the size of the mdat\n\te = DoWrite(mw, writers, bs, 1, gf_bs_get_position(bs));\n\tif (e) goto exit;\n\n\tfirstSize = GetMoovAndMetaSize(movie, writers);\n\t//offset = (firstSize > 0xFFFFFFFF ? firstSize + 8 : firstSize) + 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\toffset = firstSize + 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\te = ShiftOffset(movie, writers, offset);\n\tif (e) goto exit;\n\t//get the size and see if it has changed (eg, we moved to 64 bit offsets)\n\tfinalSize = GetMoovAndMetaSize(movie, writers);\n\tif (firstSize != finalSize) {\n\t\tfinalOffset = finalSize + 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\t\t//OK, now we're sure about the final size.\n\t\t//we don't need to re-emulate, as the only thing that changed is the offset\n\t\t//so just shift the offset\n\t\te = ShiftOffset(movie, writers, finalOffset - offset);\n\t\tif (e) goto exit;\n\t}\n\t//now write our stuff\n\te = WriteMoovAndMeta(movie, writers, bs);\n\tif (e) goto exit;\n\te = gf_isom_box_size((GF_Box *)movie->mdat);\n\tif (e) goto exit;\n\te = gf_isom_box_write((GF_Box *)movie->mdat, bs);\n\tif (e) goto exit;\n\n\t//we don't need the offset as the moov is already written...\n\tResetWriters(writers);\n\te = DoWrite(mw, writers, bs, 0, 0);\n\tif (e) goto exit;\n\n\t//then the rest\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif ((i-1<= (u32) moov_meta_pos) && (a!=cprt_box)) continue;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\nexit:\n\tCleanWriters(writers);\n\tgf_list_del(writers);\n\treturn e;\n}\n\nGF_Err DoFullInterleave(MovieWriter *mw, GF_List *writers, GF_BitStream *bs, u8 Emulation, u64 StartOffset)\n{\n\n\tu32 i, tracksDone;\n\tTrackWriter *tmp, *curWriter, *prevWriter;\n\tGF_Err e;\n\tu64 DTS, DTStmp, TStmp;\n\ts64 res;\n\tu32 descIndex, sampSize, chunkNumber;\n\tu16 curGroupID, curTrackPriority;\n\tBool forceNewChunk, writeGroup;\n\tGF_StscEntry *stsc_ent;\n\t//this is used to emulate the write ...\n\tu64 offset, totSize, sampOffset;\n\tGF_ISOFile *movie = mw->movie;\n\n\ttotSize = 0;\n\tcurGroupID = 1;\n\n\tprevWriter = NULL;\n\t//we emulate a write from this offset...\n\toffset = StartOffset;\n\ttracksDone = 0;\n\n\t//browse each groups\n\twhile (1) {\n\t\twriteGroup = 1;\n\n\t\t//proceed a group\n\t\twhile (writeGroup) {\n\t\t\tu32 nb_samp = 1;\n\t\t\tBool self_contained, chunked_forced=GF_FALSE;\n\t\t\t//first get the appropriated sample for the min time in this group\n\t\t\tcurWriter = NULL;\n\t\t\tDTStmp = (u64) -1;\n\t\t\tTStmp = 0;\n\t\t\tcurTrackPriority = (u16) -1;\n\n\t\t\ti=0;\n\t\t\twhile ((tmp = (TrackWriter*)gf_list_enum(writers, &i))) {\n\n\t\t\t\t//is it done writing ?\n\t\t\t\t//is it in our group ??\n\t\t\t\tif (tmp->isDone || tmp->stbl->groupID != curGroupID) continue;\n\n\t\t\t\t//OK, get the current sample in this track\n\t\t\t\tstbl_GetSampleDTS(tmp->stbl->TimeToSample, tmp->sampleNumber, &DTS);\n\t\t\t\tres = TStmp ? DTStmp * tmp->timeScale - DTS * TStmp : 0;\n\t\t\t\tif (res < 0) continue;\n\t\t\t\tif ((!res) && curTrackPriority <= tmp->stbl->trackPriority) continue;\n\t\t\t\tcurWriter = tmp;\n\t\t\t\tcurTrackPriority = tmp->stbl->trackPriority;\n\t\t\t\tDTStmp = DTS;\n\t\t\t\tTStmp = tmp->timeScale;\n\t\t\t}\n\t\t\t//no sample found, we're done with this group\n\t\t\tif (!curWriter) {\n\t\t\t\t//we're done with the group\n\t\t\t\twriteGroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//To Check: are empty sample tables allowed ???\n\t\t\tif (curWriter->sampleNumber > curWriter->stbl->SampleSize->sampleCount) {\n\t\t\t\tcurWriter->isDone = 1;\n\t\t\t\ttracksDone ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te = stbl_GetSampleInfos(curWriter->stbl, curWriter->sampleNumber, &sampOffset, &chunkNumber, &descIndex, &stsc_ent);\n\t\t\tif (e) return e;\n\t\t\te = stbl_GetSampleSize(curWriter->stbl->SampleSize, curWriter->sampleNumber, &sampSize);\n\t\t\tif (e) return e;\n\n\t\t\tupdate_writer_constant_dur(movie, curWriter, stsc_ent, &nb_samp, &sampSize, GF_FALSE);\n\n\t\t\tif (curWriter->stbl->MaxChunkSize && (curWriter->chunkSize + sampSize > curWriter->stbl->MaxChunkSize)) {\n\t\t\t\tcurWriter->chunkSize = 0;\n\t\t\t\tchunked_forced = forceNewChunk = 1;\n\t\t\t}\n\t\t\tcurWriter->chunkSize += sampSize;\n\n\t\t\tself_contained = ((curWriter->all_dref_mode==ISOM_DREF_SELF) || Media_IsSelfContained(curWriter->mdia, descIndex) ) ? GF_TRUE : GF_FALSE;\n\n\t\t\t//do we actually write, or do we emulate ?\n\t\t\tif (Emulation) {\n\t\t\t\t//are we in the same track ??? If not, force a new chunk when adding this sample\n\t\t\t\tif (!chunked_forced) {\n\t\t\t\t\tif (curWriter != prevWriter) {\n\t\t\t\t\t\tforceNewChunk = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tforceNewChunk = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//update our offsets...\n\t\t\t\tif (self_contained) {\n\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, offset, forceNewChunk, nb_samp);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\toffset += sampSize;\n\t\t\t\t\ttotSize += sampSize;\n\t\t\t\t} else {\n//\t\t\t\t\tif (curWriter->prev_offset != sampOffset) forceNewChunk = 1;\n\t\t\t\t\tcurWriter->prev_offset = sampOffset + sampSize;\n\n\t\t\t\t\t//we have a DataRef, so use the offset idicated in sampleToChunk\n\t\t\t\t\t//and ChunkOffset tables...\n\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, sampOffset, chunked_forced, nb_samp);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//this is no game, we're writing ....\n\t\t\t\tif (self_contained) {\n\t\t\t\t\te = WriteSample(mw, sampSize, sampOffset, stsc_ent->isEdited, bs, 1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//ok, the sample is done\n\t\t\tif (curWriter->sampleNumber == curWriter->stbl->SampleSize->sampleCount) {\n\t\t\t\tcurWriter->isDone = 1;\n\t\t\t\t//one more track done...\n\t\t\t\ttracksDone ++;\n\t\t\t} else {\n\t\t\t\tcurWriter->sampleNumber += nb_samp;\n\t\t\t}\n\t\t\tprevWriter = curWriter;\n\t\t}\n\t\t//if all our track are done, break\n\t\tif (tracksDone == gf_list_count(writers)) break;\n\t\t//go to next group\n\t\tcurGroupID ++;\n\t}\n\tif (movie->mdat)\n\t\tmovie->mdat->dataSize = totSize;\n\treturn GF_OK;\n}\n\n\n\n/*uncomment the following to easily test large file generation. This will prepend 4096*1MByte of 0 before the media data*/\n//#define TEST_LARGE_FILES\n\nGF_Err DoInterleave(MovieWriter *mw, GF_List *writers, GF_BitStream *bs, u8 Emulation, u64 StartOffset, Bool drift_inter)\n{\n\tu32 i, tracksDone;\n\tTrackWriter *tmp, *curWriter;\n\tGF_Err e;\n\tu32 descIndex, sampSize, chunkNumber;\n\tu64 DTS;\n\tu32 moov_timescale;\n\tu16 curGroupID;\n\tBool forceNewChunk, writeGroup;\n\tGF_StscEntry *stsc_ent;\n\t//this is used to emulate the write ...\n\tu64 offset, sampOffset, size, mdatSize;\n\tu32 count;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmdatSize = 0;\n\n#ifdef TEST_LARGE_FILES\n\tif (!Emulation) {\n\t\tchar *blank;\n\t\tu32 count, i;\n\t\ti = count = 0;\n\t\tblank = gf_malloc(sizeof(char)*1024*1024);\n\t\tmemset(blank, 0, sizeof(char)*1024*1024);\n\t\tcount = 4096;\n\t\tmemset(blank, 0, sizeof(char)*1024*1024);\n\t\twhile (i<count) {\n\t\t\tu32 res = gf_bs_write_data(bs, blank, 1024*1024);\n\t\t\tif (res != 1024*1024) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"error writing to disk: only %d bytes written\\n\", res));\n\t\t\t}\n\t\t\ti++;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"writing blank block: %.02f done - %d/%d \\r\", (100.0*i)/count , i, count));\n\t\t}\n\t\tgf_free(blank);\n\t}\n\tmdatSize = 4096*1024;\n\tmdatSize *= 1024;\n#endif\n\n\t/*write meta content first - WE DON'T support fragmentation of resources in ISOM atm*/\n\tif (movie->meta) {\n\t\te = DoWriteMeta(movie, movie->meta, bs, Emulation, StartOffset, &size);\n\t\tif (e) return e;\n\t\tmdatSize += size;\n\t\tStartOffset += (u32) size;\n\t}\n\tif (movie->moov) {\n\t\tif (movie->moov->meta) {\n\t\t\te = DoWriteMeta(movie, movie->moov->meta, bs, Emulation, StartOffset, &size);\n\t\t\tif (e) return e;\n\t\t\tmdatSize += size;\n\t\t\tStartOffset += (u32) size;\n\t\t}\n\t\ti=0;\n\t\twhile ((tmp = (TrackWriter*)gf_list_enum(writers, &i))) {\n\t\t\tif (tmp->mdia->mediaTrack->meta) {\n\t\t\t\te = DoWriteMeta(movie, tmp->mdia->mediaTrack->meta, bs, Emulation, StartOffset, &size);\n\t\t\t\tif (e) return e;\n\t\t\t\tmdatSize += size;\n\t\t\t\tStartOffset += (u32) size;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (movie->storageMode == GF_ISOM_STORE_TIGHT)\n\t\treturn DoFullInterleave(mw, writers, bs, Emulation, StartOffset);\n\n\tcurGroupID = 1;\n\t//we emulate a write from this offset...\n\toffset = StartOffset;\n\ttracksDone = 0;\n\n#ifdef TEST_LARGE_FILES\n\toffset += mdatSize;\n#endif\n\n\tmoov_timescale = movie->moov && movie->moov->mvhd ? movie->moov->mvhd->timeScale : 1000;\n\n\tcount = gf_list_count(writers);\n\t//browse each groups\n\twhile (1) {\n\t\t/*the max DTS the chunk of the current writer*/\n\t\tu64 chunkLastDTS = 0;\n\t\t/*the timescale related to the max DTS*/\n\t\tu32 chunkLastScale = 0;\n\n\t\twriteGroup = 1;\n\n\t\t//proceed a group\n\t\twhile (writeGroup) {\n\t\t\tcurWriter = NULL;\n\t\t\tfor (i=0 ; i < count; i++) {\n\t\t\t\ttmp = (TrackWriter*)gf_list_get(writers, i);\n\n\t\t\t\t//is it done writing ?\n\t\t\t\tif (tmp->isDone) continue;\n\n\t\t\t\t//is it in our group ??\n\t\t\t\tif (tmp->stbl->groupID != curGroupID) continue;\n\n\t\t\t\t//write till this chunk is full on this track...\n\t\t\t\twhile (1) {\n\t\t\t\t\tBool self_contained;\n\t\t\t\t\tu32 nb_samp = 1;\n\t\t\t\t\tu32 sample_dur;\n\t\t\t\t\tu64 chunk_prev_dur;\n\t\t\t\t\t//To Check: are empty sample tables allowed ???\n\t\t\t\t\tif (tmp->sampleNumber > tmp->stbl->SampleSize->sampleCount) {\n\t\t\t\t\t\ttmp->isDone = 1;\n\t\t\t\t\t\ttracksDone ++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t//OK, get the current sample in this track\n\t\t\t\t\tstbl_GetSampleDTS_and_Duration(tmp->stbl->TimeToSample, tmp->sampleNumber, &DTS, &sample_dur);\n\n\t\t\t\t\t//can this sample fit in our chunk ?\n\t\t\t\t\tif ( ( (DTS - tmp->DTSprev) + tmp->chunkDur) * moov_timescale > movie->interleavingTime * tmp->timeScale\n\t\t\t\t\t        /*drift check: reject sample if outside our check window*/\n\t\t\t\t\t        || (drift_inter && chunkLastDTS && ( ((u64)tmp->DTSprev*chunkLastScale) > ((u64)chunkLastDTS*tmp->timeScale)) )\n\t\t\t\t\t   ) {\n\t\t\t\t\t\t//in case the sample is longer than InterleaveTime\n\t\t\t\t\t\tif (!tmp->chunkDur) {\n\t\t\t\t\t\t\tforceNewChunk = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//this one is full. go to next one (exit the loop)\n\t\t\t\t\t\t\ttmp->chunkDur = 0;\n\t\t\t\t\t\t\t//forceNewChunk = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tforceNewChunk = tmp->chunkDur ? 0 : 1;\n\t\t\t\t\t}\n\t\t\t\t\t//OK, we can write this track\n\t\t\t\t\tcurWriter = tmp;\n\n\t\t\t\t\t//small check for first 2 samples (DTS = 0)\n\t\t\t\t\t//only in the old mode can chunkdur be 0 for dts 0\n\t\t\t\t\tif (tmp->sampleNumber == 2 && !tmp->chunkDur && gf_sys_old_arch_compat() ) {\n\t\t\t\t\t\tforceNewChunk = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tchunk_prev_dur = tmp->chunkDur;\n\t\t\t\t\t//FIXME we do not apply patch in test mode for now since this breaks all our hashes, remove this\n\t\t\t\t\t//once we move to filters permanently\n\t\t\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\t\t\ttmp->chunkDur += sample_dur;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//old style, compute based on DTS diff\n\t\t\t\t\t\ttmp->chunkDur += (u32) (DTS - tmp->DTSprev);\n\t\t\t\t\t}\n\t\t\t\t\ttmp->DTSprev = DTS;\n\n\t\t\t\t\te = stbl_GetSampleInfos(curWriter->stbl, curWriter->sampleNumber, &sampOffset, &chunkNumber, &descIndex, &stsc_ent);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\treturn e;\n\t\t\t\t\te = stbl_GetSampleSize(curWriter->stbl->SampleSize, curWriter->sampleNumber, &sampSize);\n\t\t\t\t\tif (e)\n\t\t\t\t\t\treturn e;\n\n\t\t\t\t\tself_contained = ((curWriter->all_dref_mode==ISOM_DREF_SELF) || Media_IsSelfContained(curWriter->mdia, descIndex)) ? GF_TRUE : GF_FALSE;\n\n\t\t\t\t\tupdate_writer_constant_dur(movie, curWriter, stsc_ent, &nb_samp, &sampSize, GF_FALSE);\n\n\t\t\t\t\tif (curWriter->stbl->MaxChunkSize && (curWriter->chunkSize + sampSize > curWriter->stbl->MaxChunkSize)) {\n\t\t\t\t\t\tcurWriter->chunkSize = 0;\n\t\t\t\t\t\ttmp->chunkDur -= chunk_prev_dur;\n\t\t\t\t\t\tforceNewChunk = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcurWriter->chunkSize += sampSize;\n\n\t\t\t\t\t//do we actually write, or do we emulate ?\n\t\t\t\t\tif (Emulation) {\n\t\t\t\t\t\t//update our offsets...\n\t\t\t\t\t\tif (self_contained) {\n\t\t\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, offset, forceNewChunk, nb_samp);\n\t\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\toffset += sampSize;\n\t\t\t\t\t\t\tmdatSize += sampSize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (curWriter->prev_offset != sampOffset) forceNewChunk = 1;\n\t\t\t\t\t\t\tcurWriter->prev_offset = sampOffset + sampSize;\n\n\t\t\t\t\t\t\t//we have a DataRef, so use the offset idicated in sampleToChunk\n\t\t\t\t\t\t\t//and ChunkOffset tables...\n\t\t\t\t\t\t\te = stbl_SetChunkAndOffset(curWriter->stbl, curWriter->sampleNumber, descIndex, curWriter->stsc, &curWriter->stco, sampOffset, forceNewChunk, nb_samp);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//we're writing ....\n\t\t\t\t\t\tif (self_contained) {\n\t\t\t\t\t\t\te = WriteSample(mw, sampSize, sampOffset, stsc_ent->isEdited, bs, nb_samp);\n\t\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//ok, the sample is done\n\t\t\t\t\tif (curWriter->sampleNumber >= curWriter->stbl->SampleSize->sampleCount) {\n\t\t\t\t\t\tcurWriter->isDone = 1;\n\t\t\t\t\t\t//one more track done...\n\t\t\t\t\t\ttracksDone ++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurWriter->sampleNumber += nb_samp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*record chunk end-time & track timescale for drift-controled interleaving*/\n\t\t\t\tif (drift_inter && curWriter) {\n\t\t\t\t\tchunkLastScale = curWriter->timeScale;\n\t\t\t\t\tchunkLastDTS = curWriter->DTSprev;\n\t\t\t\t\t/*add one interleave window drift - since the \"maxDTS\" is the previously written one, we will\n\t\t\t\t\thave the following cases:\n\t\t\t\t\t- sample doesn't fit: post-pone and force new chunk\n\t\t\t\t\t- sample time larger than previous chunk time + interleave: post-pone and force new chunk\n\t\t\t\t\t- otherwise store and track becomes current reference\n\n\t\t\t\t\tthis ensures a proper drift regulation (max DTS diff is less than the interleaving window)\n\t\t\t\t\t*/\n\t\t\t\t\tchunkLastDTS += curWriter->timeScale * movie->interleavingTime / moov_timescale;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no sample found, we're done with this group\n\t\t\tif (!curWriter) {\n\t\t\t\twriteGroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t//if all our track are done, break\n\t\tif (tracksDone == gf_list_count(writers)) break;\n\t\t//go to next group\n\t\tcurGroupID ++;\n\t}\n\tif (movie->mdat) movie->mdat->dataSize = mdatSize;\n\treturn GF_OK;\n}\n\n\nstatic GF_Err WriteInterleaved(MovieWriter *mw, GF_BitStream *bs, Bool drift_inter)\n{\n\tGF_Err e;\n\tu32 i;\n\ts32 moov_meta_pos=-1;\n\tGF_Box *a, *cprt_box=NULL;\n\tu64 firstSize, finalSize, offset, finalOffset;\n\tGF_List *writers = gf_list_new();\n\tGF_ISOFile *movie = mw->movie;\n\n\t//first setup the writers\n\te = SetupWriters(mw, writers, 1);\n\tif (e) goto exit;\n\n\n\tif (movie->is_jp2) {\n\t\tgf_bs_write_u32(bs, 12);\n\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_JP);\n\t\tgf_bs_write_u32(bs, 0x0D0A870A);\n\t}\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, bs);\n\t\tif (e) goto exit;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, bs);\n\t\tif (e) goto exit;\n\t}\n\n\t//write all boxes before moov\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tmoov_meta_pos = i-1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FREE:\n\t\t\t//for backward compat with old arch, keep copyright before moov\n\t\t\tif (((GF_FreeSpaceBox*)a)->dataSize>4) {\n\t\t\t\tGF_FreeSpaceBox *fr = (GF_FreeSpaceBox*) a;\n\t\t\t\tif ((fr->dataSize>20) && !strncmp(fr->data, \"IsoMedia File\", 13)) {\n\t\t\t\t\tcprt_box = a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tif (moov_meta_pos<0) {\n\t\t\t\te = gf_isom_box_size(a);\n\t\t\t\tif (e) goto exit;\n\t\t\t\te = gf_isom_box_write(a, bs);\n\t\t\t\tif (e) goto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\te = DoInterleave(mw, writers, bs, 1, gf_bs_get_position(bs), drift_inter);\n\tif (e) goto exit;\n\n\tfirstSize = GetMoovAndMetaSize(movie, writers);\n\toffset = firstSize;\n\tif (movie->mdat && movie->mdat->dataSize) offset += 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\te = ShiftOffset(movie, writers, offset);\n\tif (e) goto exit;\n\t//get the size and see if it has changed (eg, we moved to 64 bit offsets)\n\tfinalSize = GetMoovAndMetaSize(movie, writers);\n\tif (firstSize != finalSize) {\n\t\tfinalOffset = finalSize;\n\t\tif (movie->mdat && movie->mdat->dataSize) finalOffset += 8 + (movie->mdat->dataSize > 0xFFFFFFFF ? 8 : 0);\n\t\t//OK, now we're sure about the final size -> shift the offsets\n\t\t//we don't need to re-emulate, as the only thing that changed is the offset\n\t\t//so just shift the offset\n\t\te = ShiftOffset(movie, writers, finalOffset - offset);\n\t\tif (e) goto exit;\n\t\t/*firstSize = */GetMoovAndMetaSize(movie, writers);\n\t}\n\t//get real sample offsets for meta items\n\tif (movie->meta) {\n\t\tstore_meta_item_sample_ref_offsets(movie, writers, movie->meta);\n\t}\n\t//now write our stuff\n\te = WriteMoovAndMeta(movie, writers, bs);\n\tif (e) goto exit;\n\n\t/*we have 8 extra bytes for large size (not computed in gf_isom_box_size) */\n\tif (movie->mdat && movie->mdat->dataSize) {\n\t\tif (movie->mdat->dataSize > 0xFFFFFFFF) movie->mdat->dataSize += 8;\n\t\te = gf_isom_box_size((GF_Box *)movie->mdat);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *)movie->mdat, bs);\n\t\tif (e) goto exit;\n\t}\n\n\t//we don't need the offset as we are writing...\n\tResetWriters(writers);\n\te = DoInterleave(mw, writers, bs, 0, 0, drift_inter);\n\tif (e) goto exit;\n\n\t//then the rest\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif ((i-1 < (u32) moov_meta_pos) && (a != cprt_box))\n\t\t\tcontinue;\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = gf_isom_box_size(a);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_isom_box_write(a, bs);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\nexit:\n\tCleanWriters(writers);\n\tgf_list_del(writers);\n\treturn e;\n}\n\nextern u32 default_write_buffering_size;\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final);\n\nGF_Err WriteToFile(GF_ISOFile *movie, Bool for_fragments)\n{\n\tMovieWriter mw;\n\tGF_Err e = GF_OK;\n\tif (!movie) return GF_BAD_PARAM;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_copyright(movie);\n\tif (e) return e;\n\n\tmemset(&mw, 0, sizeof(mw));\n\tmw.movie = movie;\n\n\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tGF_TrackBox *trak;\n\t\tif (gf_sys_is_test_mode()) {\n\t\t\tmovie->moov->mvhd->creationTime = 0;\n\t\t\tmovie->moov->mvhd->modificationTime = 0;\n\t\t}\n\t\ti=0;\n\t\twhile ( (trak = gf_list_enum(movie->moov->trackList, &i))) {\n\t\t\tif (gf_sys_is_test_mode()) {\n\t\t\t\ttrak->Header->creationTime = 0;\n\t\t\t\ttrak->Header->modificationTime = 0;\n\t\t\t\tif (trak->Media->handler->nameUTF8 && strstr(trak->Media->handler->nameUTF8, \"@GPAC\")) {\n\t\t\t\t\tgf_free(trak->Media->handler->nameUTF8);\n\t\t\t\t\ttrak->Media->handler->nameUTF8 = gf_strdup(\"MediaHandler\");\n\t\t\t\t}\n\t\t\t\ttrak->Media->mediaHeader->creationTime = 0;\n\t\t\t\ttrak->Media->mediaHeader->modificationTime = 0;\n\t\t\t}\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\tgf_isom_flush_chunk(trak, GF_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\t//capture mode: we don't need a new bitstream\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\t\tGF_BitStream *bs, *moov_bs=NULL;\n\t\t\tu64 mdat_end = gf_bs_get_position(movie->editFileMap->bs);\n\t\t\tu64 mdat_start = movie->mdat->bsOffset;\n\t\t\tu64 mdat_size = mdat_end - mdat_start;\n\n\t\t\tif (for_fragments) {\n\t\t\t\tif (!movie->on_block_out) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tbs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\t\t\t\te = WriteFlat(&mw, 0, bs, GF_TRUE, GF_TRUE, NULL);\n\t\t\t\tmovie->fragmented_file_pos = gf_bs_get_position(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t//seek at end in case we had a read of the file\n\t\t\tgf_bs_seek(movie->editFileMap->bs, gf_bs_get_size(movie->editFileMap->bs) );\n\n\t\t\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && mdat_start && mdat_size) {\n\t\t\t\tmoov_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t}\n\t\t\t//write as non-seekable\n\t\t\te = WriteFlat(&mw, 0, movie->editFileMap->bs, GF_TRUE, GF_FALSE, moov_bs);\n\n\t\t\tmovie->fragmented_file_pos = gf_bs_get_position(movie->editFileMap->bs);\n\n\t\t\tif (mdat_start && mdat_size) {\n\t\t\t\tu8 data[16];\n\t\t\t\tif (!movie->on_block_out) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block patch callback, cannot patch mdat size in flat storage\\n\"));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\n\t\t\t\t//create a patch packet for mdat covering out 16 bytes (cf FlushCapture)\n\t\t\t\tbs = gf_bs_new(data, 16, GF_BITSTREAM_WRITE);\n\t\t\t\tgf_bs_write_u32(bs, (mdat_size>0xFFFFFFFF) ? 1 : (u32) mdat_size);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif  (mdat_size>0xFFFFFFFF)\n\t\t\t\t\tgf_bs_write_u64(bs, mdat_size);\n\t\t\t\telse\n\t\t\t\t\tgf_bs_write_u64(bs, 0);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tmovie->on_block_patch(movie->on_block_out_usr_data, data, 16, mdat_start, GF_FALSE);\n\t\t\t}\n\n\t\t\tif (moov_bs) {\n\t\t\t\tu8 *moov_data;\n\t\t\t\tu32 moov_size;\n\n\t\t\t\tgf_bs_get_content(moov_bs, &moov_data, &moov_size);\n\t\t\t\tgf_bs_del(moov_bs);\n\n\t\t\t\tmovie->on_block_patch(movie->on_block_out_usr_data, moov_data, moov_size, mdat_start, GF_TRUE);\n\t\t\t\tgf_free(moov_data);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_BitStream *moov_bs = NULL;\n\t\t\tif ((movie->storageMode==GF_ISOM_STORE_STREAMABLE) || (movie->storageMode==GF_ISOM_STORE_FASTSTART) ) {\n\t\t\t\tmoov_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t}\n\t\t\te = WriteFlat(&mw, 0, movie->editFileMap->bs, GF_FALSE, GF_FALSE, moov_bs);\n\t\t\tif (moov_bs) {\n\t\t\t\tu8 *moov_data;\n\t\t\t\tu32 moov_size;\n\n\t\t\t\tgf_bs_get_content(moov_bs, &moov_data, &moov_size);\n\t\t\t\tgf_bs_del(moov_bs);\n\t\t\t\tif (!e)\n\t\t\t\t\te = gf_bs_insert_data(movie->editFileMap->bs, moov_data, moov_size, movie->mdat->bsOffset);\n\t\t\t\t\t\n\t\t\t\tgf_free(moov_data);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tFILE *stream=NULL;\n\t\tBool is_stdout = GF_FALSE;\n\t\tGF_BitStream *bs=NULL;\n\t\tif (!strcmp(movie->finalName, \"_gpac_isobmff_redirect\")) {\n\t\t\tif (!movie->on_block_out) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\tbs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\t\t\tis_stdout = GF_TRUE;\n\t\t} else {\n\t\t\tif (!strcmp(movie->finalName, \"std\"))\n\t\t\t\tis_stdout = GF_TRUE;\n\n\t\t\t//OK, we need a new bitstream\n\t\t\tstream = is_stdout ? stdout : gf_fopen(movie->finalName, \"w+b\");\n\t\t\tif (!stream)\n\t\t\t\treturn GF_IO_ERR;\n\t\t\tbs = gf_bs_from_file(stream, GF_BITSTREAM_WRITE);\n\t\t}\n\t\tif (!bs) {\n\t\t\tif (!is_stdout)\n\t\t\t\tgf_fclose(stream);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\n\t\tswitch (movie->storageMode) {\n\t\tcase GF_ISOM_STORE_TIGHT:\n\t\tcase GF_ISOM_STORE_INTERLEAVED:\n\t\t\te = WriteInterleaved(&mw, bs, 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\t\t\te = WriteInterleaved(&mw, bs, 1);\n\t\t\tbreak;\n\t\tcase GF_ISOM_STORE_STREAMABLE:\n\t\t\te = WriteFlat(&mw, 1, bs, is_stdout, GF_FALSE, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = WriteFlat(&mw, 0, bs, is_stdout, GF_FALSE, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_bs_del(bs);\n\t\tif (!is_stdout)\n\t\t\tgf_fclose(stream);\n\t}\n\tif (mw.buffer) gf_free(mw.buffer);\n\tif (mw.nb_done<mw.total_samples) {\n\t\tmw.nb_done = mw.total_samples;\n\t\tmuxer_report_progress(&mw);\n\t}\n\treturn e;\n}\n\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n"], "filenames": ["src/isomedia/isom_store.c"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [153], "fixing_code_start_loc": [153], "fixing_code_end_loc": [160], "type": "CWE-476", "message": "An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is an invalid pointer dereference in the function SetupWriters() in isomedia/isom_store.c.", "other": {"cve": {"id": "CVE-2020-35981", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-21T16:15:08.720", "lastModified": "2021-04-23T19:54:16.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is an invalid pointer dereference in the function SetupWriters() in isomedia/isom_store.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en GPAC versiones 0.8.0 y 1.0.1.&#xa0;Se presenta una desreferencia del puntero no v\u00e1lida en la funci\u00f3n SetupWriters() en el archivo isomedia/isom_store.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "93EEFCFD-7417-40E6-84BF-4EA630F2A8A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/dae9900580a8888969481cd72035408091edb11b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1659", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/dae9900580a8888969481cd72035408091edb11b"}}