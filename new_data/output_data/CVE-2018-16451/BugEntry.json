{"buggy_code": ["/*\n * Copyright (C) Andrew Tridgell 1995-1999\n *\n * This software may be distributed either under the terms of the\n * BSD-style license that accompanies tcpdump or the GNU GPL version 2\n * or later\n */\n\n/* \\summary: SMB/CIFS printer */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include <string.h>\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"smb.h\"\n\nstatic const char tstr[] = \"[|SMB]\";\n\nstatic int request = 0;\nstatic int unicodestr = 0;\n\nconst u_char *startbuf = NULL;\n\nstruct smbdescript {\n    const char *req_f1;\n    const char *req_f2;\n    const char *rep_f1;\n    const char *rep_f2;\n    void (*fn)(netdissect_options *, const u_char *, const u_char *, const u_char *, const u_char *);\n};\n\nstruct smbdescriptint {\n    const char *req_f1;\n    const char *req_f2;\n    const char *rep_f1;\n    const char *rep_f2;\n    void (*fn)(netdissect_options *, const u_char *, const u_char *, int, int);\n};\n\nstruct smbfns\n{\n    int id;\n    const char *name;\n    int flags;\n    struct smbdescript descript;\n};\n\nstruct smbfnsint\n{\n    int id;\n    const char *name;\n    int flags;\n    struct smbdescriptint descript;\n};\n\n#define DEFDESCRIPT\t{ NULL, NULL, NULL, NULL, NULL }\n\n#define FLG_CHAIN\t(1 << 0)\n\nstatic const struct smbfns *\nsmbfind(int id, const struct smbfns *list)\n{\n    int sindex;\n\n    for (sindex = 0; list[sindex].name; sindex++)\n\tif (list[sindex].id == id)\n\t    return(&list[sindex]);\n\n    return(&list[0]);\n}\n\nstatic const struct smbfnsint *\nsmbfindint(int id, const struct smbfnsint *list)\n{\n    int sindex;\n\n    for (sindex = 0; list[sindex].name; sindex++)\n\tif (list[sindex].id == id)\n\t    return(&list[sindex]);\n\n    return(&list[0]);\n}\n\nstatic void\ntrans2_findfirst(netdissect_options *ndo,\n                 const u_char *param, const u_char *data, int pcnt, int dcnt)\n{\n    const char *fmt;\n\n    if (request)\n\tfmt = \"Attribute=[A]\\nSearchCount=[d]\\nFlags=[w]\\nLevel=[dP4]\\nFile=[S]\\n\";\n    else\n\tfmt = \"Handle=[w]\\nCount=[d]\\nEOS=[w]\\nEoffset=[d]\\nLastNameOfs=[w]\\n\";\n\n    smb_fdata(ndo, param, fmt, param + pcnt, unicodestr);\n    if (dcnt) {\n\tND_PRINT((ndo, \"data:\\n\"));\n\tsmb_print_data(ndo, data, dcnt);\n    }\n}\n\nstatic void\ntrans2_qfsinfo(netdissect_options *ndo,\n               const u_char *param, const u_char *data, int pcnt, int dcnt)\n{\n    static int level = 0;\n    const char *fmt=\"\";\n\n    if (request) {\n\tND_TCHECK2(*param, 2);\n\tlevel = EXTRACT_LE_16BITS(param);\n\tfmt = \"InfoLevel=[d]\\n\";\n\tsmb_fdata(ndo, param, fmt, param + pcnt, unicodestr);\n    } else {\n\tswitch (level) {\n\tcase 1:\n\t    fmt = \"idFileSystem=[W]\\nSectorUnit=[D]\\nUnit=[D]\\nAvail=[D]\\nSectorSize=[d]\\n\";\n\t    break;\n\tcase 2:\n\t    fmt = \"CreationTime=[T2]VolNameLength=[lb]\\nVolumeLabel=[c]\\n\";\n\t    break;\n\tcase 0x105:\n\t    fmt = \"Capabilities=[W]\\nMaxFileLen=[D]\\nVolNameLen=[lD]\\nVolume=[C]\\n\";\n\t    break;\n\tdefault:\n\t    fmt = \"UnknownLevel\\n\";\n\t    break;\n\t}\n\tsmb_fdata(ndo, data, fmt, data + dcnt, unicodestr);\n    }\n    if (dcnt) {\n\tND_PRINT((ndo, \"data:\\n\"));\n\tsmb_print_data(ndo, data, dcnt);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic const struct smbfnsint trans2_fns[] = {\n    { 0, \"TRANSACT2_OPEN\", 0,\n\t{ \"Flags2=[w]\\nMode=[w]\\nSearchAttrib=[A]\\nAttrib=[A]\\nTime=[T2]\\nOFun=[w]\\nSize=[D]\\nRes=([w, w, w, w, w])\\nPath=[S]\",\n\t  NULL,\n\t  \"Handle=[d]\\nAttrib=[A]\\nTime=[T2]\\nSize=[D]\\nAccess=[w]\\nType=[w]\\nState=[w]\\nAction=[w]\\nInode=[W]\\nOffErr=[d]\\n|EALength=[d]\\n\",\n\t  NULL, NULL }},\n    { 1, \"TRANSACT2_FINDFIRST\", 0,\n\t{ NULL, NULL, NULL, NULL, trans2_findfirst }},\n    { 2, \"TRANSACT2_FINDNEXT\", 0, DEFDESCRIPT },\n    { 3, \"TRANSACT2_QFSINFO\", 0,\n\t{ NULL, NULL, NULL, NULL, trans2_qfsinfo }},\n    { 4, \"TRANSACT2_SETFSINFO\", 0, DEFDESCRIPT },\n    { 5, \"TRANSACT2_QPATHINFO\", 0, DEFDESCRIPT },\n    { 6, \"TRANSACT2_SETPATHINFO\", 0, DEFDESCRIPT },\n    { 7, \"TRANSACT2_QFILEINFO\", 0, DEFDESCRIPT },\n    { 8, \"TRANSACT2_SETFILEINFO\", 0, DEFDESCRIPT },\n    { 9, \"TRANSACT2_FSCTL\", 0, DEFDESCRIPT },\n    { 10, \"TRANSACT2_IOCTL\", 0, DEFDESCRIPT },\n    { 11, \"TRANSACT2_FINDNOTIFYFIRST\", 0, DEFDESCRIPT },\n    { 12, \"TRANSACT2_FINDNOTIFYNEXT\", 0, DEFDESCRIPT },\n    { 13, \"TRANSACT2_MKDIR\", 0, DEFDESCRIPT },\n    { -1, NULL, 0, DEFDESCRIPT }\n};\n\n\nstatic void\nprint_trans2(netdissect_options *ndo,\n             const u_char *words, const u_char *dat, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    static const struct smbfnsint *fn = &trans2_fns[0];\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    const char *f1 = NULL, *f2 = NULL;\n    int pcnt, dcnt;\n\n    ND_TCHECK(words[0]);\n    if (request) {\n\tND_TCHECK2(w[14 * 2], 2);\n\tpcnt = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdcnt = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tfn = smbfindint(EXTRACT_LE_16BITS(w + 14 * 2), trans2_fns);\n    } else {\n\tif (words[0] == 0) {\n\t    ND_PRINT((ndo, \"%s\\n\", fn->name));\n\t    ND_PRINT((ndo, \"Trans2Interim\\n\"));\n\t    return;\n\t}\n\tND_TCHECK2(w[7 * 2], 2);\n\tpcnt = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdcnt = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n    }\n\n    ND_PRINT((ndo, \"%s param_length=%d data_length=%d\\n\", fn->name, pcnt, dcnt));\n\n    if (request) {\n\tif (words[0] == 8) {\n\t    smb_fdata(ndo, words + 1,\n\t\t\"Trans2Secondary\\nTotParam=[d]\\nTotData=[d]\\nParamCnt=[d]\\nParamOff=[d]\\nParamDisp=[d]\\nDataCnt=[d]\\nDataOff=[d]\\nDataDisp=[d]\\nHandle=[d]\\n\",\n\t\tmaxbuf, unicodestr);\n\t    return;\n\t} else {\n\t    smb_fdata(ndo, words + 1,\n\t\t\"TotParam=[d]\\nTotData=[d]\\nMaxParam=[d]\\nMaxData=[d]\\nMaxSetup=[b][P1]\\nFlags=[w]\\nTimeOut=[D]\\nRes1=[w]\\nParamCnt=[d]\\nParamOff=[d]\\nDataCnt=[d]\\nDataOff=[d]\\nSetupCnt=[b][P1]\\n\",\n\t\twords + 1 + 14 * 2, unicodestr);\n\t}\n\tf1 = fn->descript.req_f1;\n\tf2 = fn->descript.req_f2;\n    } else {\n\tsmb_fdata(ndo, words + 1,\n\t    \"TotParam=[d]\\nTotData=[d]\\nRes1=[w]\\nParamCnt=[d]\\nParamOff=[d]\\nParamDisp[d]\\nDataCnt=[d]\\nDataOff=[d]\\nDataDisp=[d]\\nSetupCnt=[b][P1]\\n\",\n\t    words + 1 + 10 * 2, unicodestr);\n\tf1 = fn->descript.rep_f1;\n\tf2 = fn->descript.rep_f2;\n    }\n\n    ND_TCHECK2(*dat, 2);\n    bcc = EXTRACT_LE_16BITS(dat);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (fn->descript.fn)\n\t(*fn->descript.fn)(ndo, param, data, pcnt, dcnt);\n    else {\n\tsmb_fdata(ndo, param, f1 ? f1 : \"Parameters=\\n\", param + pcnt, unicodestr);\n\tsmb_fdata(ndo, data, f2 ? f2 : \"Data=\\n\", data + dcnt, unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nprint_browse(netdissect_options *ndo,\n             const u_char *param, int paramlen, const u_char *data, int datalen)\n{\n    const u_char *maxbuf = data + datalen;\n    int command;\n\n    ND_TCHECK(data[0]);\n    command = data[0];\n\n    smb_fdata(ndo, param, \"BROWSE PACKET\\n|Param \", param+paramlen, unicodestr);\n\n    switch (command) {\n    case 0xF:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (LocalMasterAnnouncement)\\nUpdateCount=[w]\\nRes1=[B]\\nAnnounceInterval=[d]\\nName=[n2]\\nMajorVersion=[B]\\nMinorVersion=[B]\\nServerType=[W]\\nElectionVersion=[w]\\nBrowserConstant=[w]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x1:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (HostAnnouncement)\\nUpdateCount=[w]\\nRes1=[B]\\nAnnounceInterval=[d]\\nName=[n2]\\nMajorVersion=[B]\\nMinorVersion=[B]\\nServerType=[W]\\nElectionVersion=[w]\\nBrowserConstant=[w]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x2:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (AnnouncementRequest)\\nFlags=[B]\\nReplySystemName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xc:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (WorkgroupAnnouncement)\\nUpdateCount=[w]\\nRes1=[B]\\nAnnounceInterval=[d]\\nName=[n2]\\nMajorVersion=[B]\\nMinorVersion=[B]\\nServerType=[W]\\nCommentPointer=[W]\\nServerName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x8:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (ElectionFrame)\\nElectionVersion=[B]\\nOSSummary=[W]\\nUptime=[(W, W)]\\nServerName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xb:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (BecomeBackupBrowser)\\nName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x9:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (GetBackupList)\\nListCount?=[B]\\nToken=[W]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xa:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (BackupListResponse)\\nServerCount?=[B]\\nToken=[W]\\n*Name=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xd:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (MasterAnnouncement)\\nMasterName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xe:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (ResetBrowser)\\nOptions=[B]\\n\", maxbuf, unicodestr);\n\tbreak;\n\n    default:\n\tdata = smb_fdata(ndo, data, \"Unknown Browser Frame \", maxbuf, unicodestr);\n\tbreak;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\nstatic void\nprint_ipc(netdissect_options *ndo,\n          const u_char *param, int paramlen, const u_char *data, int datalen)\n{\n    if (paramlen)\n\tsmb_fdata(ndo, param, \"Command=[w]\\nStr1=[S]\\nStr2=[S]\\n\", param + paramlen,\n\t    unicodestr);\n    if (datalen)\n\tsmb_fdata(ndo, data, \"IPC \", data + datalen, unicodestr);\n}\n\n\nstatic void\nprint_trans(netdissect_options *ndo,\n            const u_char *words, const u_char *data1, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    const char *f1, *f2, *f3, *f4;\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    int datalen, paramlen;\n\n    if (request) {\n\tND_TCHECK2(w[12 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nMaxParmCnt=[d] \\nMaxDataCnt=[d]\\nMaxSCnt=[d] \\nTransFlags=[w] \\nRes1=[w] \\nRes2=[w] \\nRes3=[w]\\nParamCnt=[d] \\nParamOff=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nSUCnt=[d]\\n\";\n\tf2 = \"|Name=[S]\\n\";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    } else {\n\tND_TCHECK2(w[7 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nRes1=[d]\\nParamCnt=[d] \\nParamOff=[d] \\nRes2=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nRes3=[d]\\nLsetup=[d]\\n\";\n\tf2 = \"|Unknown \";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    }\n\n    smb_fdata(ndo, words + 1, f1, min(words + 1 + 2 * words[0], maxbuf),\n        unicodestr);\n\n    ND_TCHECK2(*data1, 2);\n    bcc = EXTRACT_LE_16BITS(data1);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tsmb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);\n\n\tif (strcmp((const char *)(data1 + 2), \"\\\\MAILSLOT\\\\BROWSE\") == 0) {\n\t    print_browse(ndo, param, paramlen, data, datalen);\n\t    return;\n\t}\n\n\tif (strcmp((const char *)(data1 + 2), \"\\\\PIPE\\\\LANMAN\") == 0) {\n\t    print_ipc(ndo, param, paramlen, data, datalen);\n\t    return;\n\t}\n\n\tif (paramlen)\n\t    smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr);\n\tif (datalen)\n\t    smb_fdata(ndo, data, f4, min(data + datalen, maxbuf), unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\nstatic void\nprint_negprot(netdissect_options *ndo,\n              const u_char *words, const u_char *data, const u_char *buf _U_, const u_char *maxbuf)\n{\n    u_int wct, bcc;\n    const char *f1 = NULL, *f2 = NULL;\n\n    ND_TCHECK(words[0]);\n    wct = words[0];\n    if (request)\n\tf2 = \"*|Dialect=[Y]\\n\";\n    else {\n\tif (wct == 1)\n\t    f1 = \"Core Protocol\\nDialectIndex=[d]\";\n\telse if (wct == 17)\n\t    f1 = \"NT1 Protocol\\nDialectIndex=[d]\\nSecMode=[B]\\nMaxMux=[d]\\nNumVcs=[d]\\nMaxBuffer=[D]\\nRawSize=[D]\\nSessionKey=[W]\\nCapabilities=[W]\\nServerTime=[T3]TimeZone=[d]\\nCryptKey=\";\n\telse if (wct == 13)\n\t    f1 = \"Coreplus/Lanman1/Lanman2 Protocol\\nDialectIndex=[d]\\nSecMode=[w]\\nMaxXMit=[d]\\nMaxMux=[d]\\nMaxVcs=[d]\\nBlkMode=[w]\\nSessionKey=[W]\\nServerTime=[T1]TimeZone=[d]\\nRes=[W]\\nCryptKey=\";\n    }\n\n    if (f1)\n\tsmb_fdata(ndo, words + 1, f1, min(words + 1 + wct * 2, maxbuf),\n\t    unicodestr);\n    else\n\tsmb_print_data(ndo, words + 1, min(wct * 2, PTR_DIFF(maxbuf, words + 1)));\n\n    ND_TCHECK2(*data, 2);\n    bcc = EXTRACT_LE_16BITS(data);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tif (f2)\n\t    smb_fdata(ndo, data + 2, f2, min(data + 2 + EXTRACT_LE_16BITS(data),\n\t\tmaxbuf), unicodestr);\n\telse\n\t    smb_print_data(ndo, data + 2, min(EXTRACT_LE_16BITS(data), PTR_DIFF(maxbuf, data + 2)));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nprint_sesssetup(netdissect_options *ndo,\n                const u_char *words, const u_char *data, const u_char *buf _U_, const u_char *maxbuf)\n{\n    u_int wct, bcc;\n    const char *f1 = NULL, *f2 = NULL;\n\n    ND_TCHECK(words[0]);\n    wct = words[0];\n    if (request) {\n\tif (wct == 10)\n\t    f1 = \"Com2=[w]\\nOff2=[d]\\nBufSize=[d]\\nMpxMax=[d]\\nVcNum=[d]\\nSessionKey=[W]\\nPassLen=[d]\\nCryptLen=[d]\\nCryptOff=[d]\\nPass&Name=\\n\";\n\telse\n\t    f1 = \"Com2=[B]\\nRes1=[B]\\nOff2=[d]\\nMaxBuffer=[d]\\nMaxMpx=[d]\\nVcNumber=[d]\\nSessionKey=[W]\\nCaseInsensitivePasswordLength=[d]\\nCaseSensitivePasswordLength=[d]\\nRes=[W]\\nCapabilities=[W]\\nPass1&Pass2&Account&Domain&OS&LanMan=\\n\";\n    } else {\n\tif (wct == 3) {\n\t    f1 = \"Com2=[w]\\nOff2=[d]\\nAction=[w]\\n\";\n\t} else if (wct == 13) {\n\t    f1 = \"Com2=[B]\\nRes=[B]\\nOff2=[d]\\nAction=[w]\\n\";\n\t    f2 = \"NativeOS=[S]\\nNativeLanMan=[S]\\nPrimaryDomain=[S]\\n\";\n\t}\n    }\n\n    if (f1)\n\tsmb_fdata(ndo, words + 1, f1, min(words + 1 + wct * 2, maxbuf),\n\t    unicodestr);\n    else\n\tsmb_print_data(ndo, words + 1, min(wct * 2, PTR_DIFF(maxbuf, words + 1)));\n\n    ND_TCHECK2(*data, 2);\n    bcc = EXTRACT_LE_16BITS(data);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tif (f2)\n\t    smb_fdata(ndo, data + 2, f2, min(data + 2 + EXTRACT_LE_16BITS(data),\n\t\tmaxbuf), unicodestr);\n\telse\n\t    smb_print_data(ndo, data + 2, min(EXTRACT_LE_16BITS(data), PTR_DIFF(maxbuf, data + 2)));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nprint_lockingandx(netdissect_options *ndo,\n                  const u_char *words, const u_char *data, const u_char *buf _U_, const u_char *maxbuf)\n{\n    u_int wct, bcc;\n    const u_char *maxwords;\n    const char *f1 = NULL, *f2 = NULL;\n\n    ND_TCHECK(words[0]);\n    wct = words[0];\n    if (request) {\n\tf1 = \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nLockType=[w]\\nTimeOut=[D]\\nUnlockCount=[d]\\nLockCount=[d]\\n\";\n\tND_TCHECK(words[7]);\n\tif (words[7] & 0x10)\n\t    f2 = \"*Process=[d]\\n[P2]Offset=[M]\\nLength=[M]\\n\";\n\telse\n\t    f2 = \"*Process=[d]\\nOffset=[D]\\nLength=[D]\\n\";\n    } else {\n\tf1 = \"Com2=[w]\\nOff2=[d]\\n\";\n    }\n\n    maxwords = min(words + 1 + wct * 2, maxbuf);\n    if (wct)\n\tsmb_fdata(ndo, words + 1, f1, maxwords, unicodestr);\n\n    ND_TCHECK2(*data, 2);\n    bcc = EXTRACT_LE_16BITS(data);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tif (f2)\n\t    smb_fdata(ndo, data + 2, f2, min(data + 2 + EXTRACT_LE_16BITS(data),\n\t\tmaxbuf), unicodestr);\n\telse\n\t    smb_print_data(ndo, data + 2, min(EXTRACT_LE_16BITS(data), PTR_DIFF(maxbuf, data + 2)));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\nstatic const struct smbfns smb_fns[] = {\n    { -1, \"SMBunknown\", 0, DEFDESCRIPT },\n\n    { SMBtcon, \"SMBtcon\", 0,\n\t{ NULL, \"Path=[Z]\\nPassword=[Z]\\nDevice=[Z]\\n\",\n\t  \"MaxXmit=[d]\\nTreeId=[d]\\n\", NULL,\n\t  NULL } },\n\n    { SMBtdis, \"SMBtdis\", 0, DEFDESCRIPT },\n    { SMBexit,  \"SMBexit\", 0, DEFDESCRIPT },\n    { SMBioctl, \"SMBioctl\", 0, DEFDESCRIPT },\n\n    { SMBecho, \"SMBecho\", 0,\n\t{ \"ReverbCount=[d]\\n\", NULL,\n\t  \"SequenceNum=[d]\\n\", NULL,\n\t  NULL } },\n\n    { SMBulogoffX, \"SMBulogoffX\", FLG_CHAIN, DEFDESCRIPT },\n\n    { SMBgetatr, \"SMBgetatr\", 0,\n\t{ NULL, \"Path=[Z]\\n\",\n\t  \"Attribute=[A]\\nTime=[T2]Size=[D]\\nRes=([w,w,w,w,w])\\n\", NULL,\n\t  NULL } },\n\n    { SMBsetatr, \"SMBsetatr\", 0,\n\t{ \"Attribute=[A]\\nTime=[T2]Res=([w,w,w,w,w])\\n\", \"Path=[Z]\\n\",\n\t  NULL, NULL, NULL } },\n\n    { SMBchkpth, \"SMBchkpth\", 0,\n       { NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBsearch, \"SMBsearch\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBopen, \"SMBopen\", 0,\n\t{ \"Mode=[w]\\nAttribute=[A]\\n\", \"Path=[Z]\\n\",\n\t  \"Handle=[d]\\nOAttrib=[A]\\nTime=[T2]Size=[D]\\nAccess=[w]\\n\",\n\t  NULL, NULL } },\n\n    { SMBcreate, \"SMBcreate\", 0,\n\t{ \"Attrib=[A]\\nTime=[T2]\", \"Path=[Z]\\n\", \"Handle=[d]\\n\", NULL, NULL } },\n\n    { SMBmknew, \"SMBmknew\", 0,\n\t{ \"Attrib=[A]\\nTime=[T2]\", \"Path=[Z]\\n\", \"Handle=[d]\\n\", NULL, NULL } },\n\n    { SMBunlink, \"SMBunlink\", 0,\n\t{ \"Attrib=[A]\\n\", \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBread, \"SMBread\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\nRes=([w,w,w,w])\\n\", NULL, NULL } },\n\n    { SMBwrite, \"SMBwrite\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBclose, \"SMBclose\", 0,\n\t{ \"Handle=[d]\\nTime=[T2]\", NULL, NULL, NULL, NULL } },\n\n    { SMBmkdir, \"SMBmkdir\", 0,\n\t{ NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBrmdir, \"SMBrmdir\", 0,\n\t{ NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBdskattr, \"SMBdskattr\", 0,\n\t{ NULL, NULL,\n\t  \"TotalUnits=[d]\\nBlocksPerUnit=[d]\\nBlockSize=[d]\\nFreeUnits=[d]\\nMedia=[w]\\n\",\n\t  NULL, NULL } },\n\n    { SMBmv, \"SMBmv\", 0,\n\t{ \"Attrib=[A]\\n\", \"OldPath=[Z]\\nNewPath=[Z]\\n\", NULL, NULL, NULL } },\n\n    /*\n     * this is a Pathworks specific call, allowing the\n     * changing of the root path\n     */\n    { pSETDIR, \"SMBsetdir\", 0, { NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBlseek, \"SMBlseek\", 0,\n\t{ \"Handle=[d]\\nMode=[w]\\nOffset=[D]\\n\", \"Offset=[D]\\n\", NULL, NULL, NULL } },\n\n    { SMBflush, \"SMBflush\", 0, { \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsplopen, \"SMBsplopen\", 0,\n\t{ \"SetupLen=[d]\\nMode=[w]\\n\", \"Ident=[Z]\\n\", \"Handle=[d]\\n\",\n\t  NULL, NULL } },\n\n    { SMBsplclose, \"SMBsplclose\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsplretq, \"SMBsplretq\", 0,\n\t{ \"MaxCount=[d]\\nStartIndex=[d]\\n\", NULL,\n\t  \"Count=[d]\\nIndex=[d]\\n\",\n\t  \"*Time=[T2]Status=[B]\\nJobID=[d]\\nSize=[D]\\nRes=[B]Name=[s16]\\n\",\n\t  NULL } },\n\n    { SMBsplwr, \"SMBsplwr\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBlock, \"SMBlock\", 0,\n\t{ \"Handle=[d]\\nCount=[D]\\nOffset=[D]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBunlock, \"SMBunlock\", 0,\n\t{ \"Handle=[d]\\nCount=[D]\\nOffset=[D]\\n\", NULL, NULL, NULL, NULL } },\n\n    /* CORE+ PROTOCOL FOLLOWS */\n\n    { SMBreadbraw, \"SMBreadbraw\", 0,\n\t{ \"Handle=[d]\\nOffset=[D]\\nMaxCount=[d]\\nMinCount=[d]\\nTimeOut=[D]\\nRes=[d]\\n\",\n\t  NULL, NULL, NULL, NULL } },\n\n    { SMBwritebraw, \"SMBwritebraw\", 0,\n\t{ \"Handle=[d]\\nTotalCount=[d]\\nRes=[w]\\nOffset=[D]\\nTimeOut=[D]\\nWMode=[w]\\nRes2=[W]\\n|DataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL, \"WriteRawAck\", NULL, NULL } },\n\n    { SMBwritec, \"SMBwritec\", 0,\n\t{ NULL, NULL, \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBwriteclose, \"SMBwriteclose\", 0,\n\t{ \"Handle=[d]\\nCount=[d]\\nOffset=[D]\\nTime=[T2]Res=([w,w,w,w,w,w])\",\n\t  NULL, \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBlockread, \"SMBlockread\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\nRes=([w,w,w,w])\\n\", NULL, NULL } },\n\n    { SMBwriteunlock, \"SMBwriteunlock\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBreadBmpx, \"SMBreadBmpx\", 0,\n\t{ \"Handle=[d]\\nOffset=[D]\\nMaxCount=[d]\\nMinCount=[d]\\nTimeOut=[D]\\nRes=[w]\\n\",\n\t  NULL,\n\t  \"Offset=[D]\\nTotCount=[d]\\nRemaining=[d]\\nRes=([w,w])\\nDataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL, NULL } },\n\n    { SMBwriteBmpx, \"SMBwriteBmpx\", 0,\n\t{ \"Handle=[d]\\nTotCount=[d]\\nRes=[w]\\nOffset=[D]\\nTimeOut=[D]\\nWMode=[w]\\nRes2=[W]\\nDataSize=[d]\\nDataOff=[d]\\n\", NULL,\n\t  \"Remaining=[d]\\n\", NULL, NULL } },\n\n    { SMBwriteBs, \"SMBwriteBs\", 0,\n\t{ \"Handle=[d]\\nTotCount=[d]\\nOffset=[D]\\nRes=[W]\\nDataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL, \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBsetattrE, \"SMBsetattrE\", 0,\n\t{ \"Handle=[d]\\nCreationTime=[T2]AccessTime=[T2]ModifyTime=[T2]\", NULL,\n\t  NULL, NULL, NULL } },\n\n    { SMBgetattrE, \"SMBgetattrE\", 0,\n\t{ \"Handle=[d]\\n\", NULL,\n\t  \"CreationTime=[T2]AccessTime=[T2]ModifyTime=[T2]Size=[D]\\nAllocSize=[D]\\nAttribute=[A]\\n\",\n\t  NULL, NULL } },\n\n    { SMBtranss, \"SMBtranss\", 0, DEFDESCRIPT },\n    { SMBioctls, \"SMBioctls\", 0, DEFDESCRIPT },\n\n    { SMBcopy, \"SMBcopy\", 0,\n\t{ \"TreeID2=[d]\\nOFun=[w]\\nFlags=[w]\\n\", \"Path=[S]\\nNewPath=[S]\\n\",\n\t  \"CopyCount=[d]\\n\",  \"|ErrStr=[S]\\n\",  NULL } },\n\n    { SMBmove, \"SMBmove\", 0,\n\t{ \"TreeID2=[d]\\nOFun=[w]\\nFlags=[w]\\n\", \"Path=[S]\\nNewPath=[S]\\n\",\n\t  \"MoveCount=[d]\\n\",  \"|ErrStr=[S]\\n\",  NULL } },\n\n    { SMBopenX, \"SMBopenX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nFlags=[w]\\nMode=[w]\\nSearchAttrib=[A]\\nAttrib=[A]\\nTime=[T2]OFun=[w]\\nSize=[D]\\nTimeOut=[D]\\nRes=[W]\\n\",\n\t  \"Path=[S]\\n\",\n\t  \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nAttrib=[A]\\nTime=[T2]Size=[D]\\nAccess=[w]\\nType=[w]\\nState=[w]\\nAction=[w]\\nFileID=[W]\\nRes=[w]\\n\",\n\t  NULL, NULL } },\n\n    { SMBreadX, \"SMBreadX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nOffset=[D]\\nMaxCount=[d]\\nMinCount=[d]\\nTimeOut=[D]\\nCountLeft=[d]\\n\",\n\t  NULL,\n\t  \"Com2=[w]\\nOff2=[d]\\nRemaining=[d]\\nRes=[W]\\nDataSize=[d]\\nDataOff=[d]\\nRes=([w,w,w,w])\\n\",\n\t  NULL, NULL } },\n\n    { SMBwriteX, \"SMBwriteX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nOffset=[D]\\nTimeOut=[D]\\nWMode=[w]\\nCountLeft=[d]\\nRes=[w]\\nDataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL,\n\t  \"Com2=[w]\\nOff2=[d]\\nCount=[d]\\nRemaining=[d]\\nRes=[W]\\n\",\n\t  NULL, NULL } },\n\n    { SMBffirst, \"SMBffirst\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBfunique, \"SMBfunique\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBfclose, \"SMBfclose\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBfindnclose, \"SMBfindnclose\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBfindclose, \"SMBfindclose\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsends, \"SMBsends\", 0,\n\t{ NULL, \"Source=[Z]\\nDest=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBsendstrt, \"SMBsendstrt\", 0,\n\t{ NULL, \"Source=[Z]\\nDest=[Z]\\n\", \"GroupID=[d]\\n\", NULL, NULL } },\n\n    { SMBsendend, \"SMBsendend\", 0,\n\t{ \"GroupID=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsendtxt, \"SMBsendtxt\", 0,\n\t{ \"GroupID=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsendb, \"SMBsendb\", 0,\n\t{ NULL, \"Source=[Z]\\nDest=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBfwdname, \"SMBfwdname\", 0, DEFDESCRIPT },\n    { SMBcancelf, \"SMBcancelf\", 0, DEFDESCRIPT },\n    { SMBgetmac, \"SMBgetmac\", 0, DEFDESCRIPT },\n\n    { SMBnegprot, \"SMBnegprot\", 0,\n\t{ NULL, NULL, NULL, NULL, print_negprot } },\n\n    { SMBsesssetupX, \"SMBsesssetupX\", FLG_CHAIN,\n\t{ NULL, NULL, NULL, NULL, print_sesssetup } },\n\n    { SMBtconX, \"SMBtconX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nFlags=[w]\\nPassLen=[d]\\nPasswd&Path&Device=\\n\",\n\t  NULL, \"Com2=[w]\\nOff2=[d]\\n\", \"ServiceType=[R]\\n\", NULL } },\n\n    { SMBlockingX, \"SMBlockingX\", FLG_CHAIN,\n\t{ NULL, NULL, NULL, NULL, print_lockingandx } },\n\n    { SMBtrans2, \"SMBtrans2\", 0, { NULL, NULL, NULL, NULL, print_trans2 } },\n\n    { SMBtranss2, \"SMBtranss2\", 0, DEFDESCRIPT },\n    { SMBctemp, \"SMBctemp\", 0, DEFDESCRIPT },\n    { SMBreadBs, \"SMBreadBs\", 0, DEFDESCRIPT },\n    { SMBtrans, \"SMBtrans\", 0, { NULL, NULL, NULL, NULL, print_trans } },\n\n    { SMBnttrans, \"SMBnttrans\", 0, DEFDESCRIPT },\n    { SMBnttranss, \"SMBnttranss\", 0, DEFDESCRIPT },\n\n    { SMBntcreateX, \"SMBntcreateX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nRes=[b]\\nNameLen=[ld]\\nFlags=[W]\\nRootDirectoryFid=[D]\\nAccessMask=[W]\\nAllocationSize=[L]\\nExtFileAttributes=[W]\\nShareAccess=[W]\\nCreateDisposition=[W]\\nCreateOptions=[W]\\nImpersonationLevel=[W]\\nSecurityFlags=[b]\\n\",\n\t  \"Path=[C]\\n\",\n\t  \"Com2=[w]\\nOff2=[d]\\nOplockLevel=[b]\\nFid=[d]\\nCreateAction=[W]\\nCreateTime=[T3]LastAccessTime=[T3]LastWriteTime=[T3]ChangeTime=[T3]ExtFileAttributes=[W]\\nAllocationSize=[L]\\nEndOfFile=[L]\\nFileType=[w]\\nDeviceState=[w]\\nDirectory=[b]\\n\",\n\t  NULL, NULL } },\n\n    { SMBntcancel, \"SMBntcancel\", 0, DEFDESCRIPT },\n\n    { -1, NULL, 0, DEFDESCRIPT }\n};\n\n\n/*\n * print a SMB message\n */\nstatic void\nprint_smb(netdissect_options *ndo,\n          const u_char *buf, const u_char *maxbuf)\n{\n    uint16_t flags2;\n    int nterrcodes;\n    int command;\n    uint32_t nterror;\n    const u_char *words, *maxwords, *data;\n    const struct smbfns *fn;\n    const char *fmt_smbheader =\n        \"[P4]SMB Command   =  [B]\\nError class   =  [BP1]\\nError code    =  [d]\\nFlags1        =  [B]\\nFlags2        =  [B][P13]\\nTree ID       =  [d]\\nProc ID       =  [d]\\nUID           =  [d]\\nMID           =  [d]\\nWord Count    =  [b]\\n\";\n    int smboffset;\n\n    ND_TCHECK(buf[9]);\n    request = (buf[9] & 0x80) ? 0 : 1;\n    startbuf = buf;\n\n    command = buf[4];\n\n    fn = smbfind(command, smb_fns);\n\n    if (ndo->ndo_vflag > 1)\n\tND_PRINT((ndo, \"\\n\"));\n\n    ND_PRINT((ndo, \"SMB PACKET: %s (%s)\\n\", fn->name, request ? \"REQUEST\" : \"REPLY\"));\n\n    if (ndo->ndo_vflag < 2)\n\treturn;\n\n    ND_TCHECK_16BITS(&buf[10]);\n    flags2 = EXTRACT_LE_16BITS(&buf[10]);\n    unicodestr = flags2 & 0x8000;\n    nterrcodes = flags2 & 0x4000;\n\n    /* print out the header */\n    smb_fdata(ndo, buf, fmt_smbheader, buf + 33, unicodestr);\n\n    if (nterrcodes) {\n    \tnterror = EXTRACT_LE_32BITS(&buf[5]);\n\tif (nterror)\n\t    ND_PRINT((ndo, \"NTError = %s\\n\", nt_errstr(nterror)));\n    } else {\n\tif (buf[5])\n\t    ND_PRINT((ndo, \"SMBError = %s\\n\", smb_errstr(buf[5], EXTRACT_LE_16BITS(&buf[7]))));\n    }\n\n    smboffset = 32;\n\n    for (;;) {\n\tconst char *f1, *f2;\n\tint wct;\n\tu_int bcc;\n\tint newsmboffset;\n\n\twords = buf + smboffset;\n\tND_TCHECK(words[0]);\n\twct = words[0];\n\tdata = words + 1 + wct * 2;\n\tmaxwords = min(data, maxbuf);\n\n\tif (request) {\n\t    f1 = fn->descript.req_f1;\n\t    f2 = fn->descript.req_f2;\n\t} else {\n\t    f1 = fn->descript.rep_f1;\n\t    f2 = fn->descript.rep_f2;\n\t}\n\n\tif (fn->descript.fn)\n\t    (*fn->descript.fn)(ndo, words, data, buf, maxbuf);\n\telse {\n\t    if (wct) {\n\t\tif (f1)\n\t\t    smb_fdata(ndo, words + 1, f1, words + 1 + wct * 2, unicodestr);\n\t\telse {\n\t\t    int i;\n\t\t    int v;\n\n\t\t    for (i = 0; &words[1 + 2 * i] < maxwords; i++) {\n\t\t\tND_TCHECK2(words[1 + 2 * i], 2);\n\t\t\tv = EXTRACT_LE_16BITS(words + 1 + 2 * i);\n\t\t\tND_PRINT((ndo, \"smb_vwv[%d]=%d (0x%X)\\n\", i, v, v));\n\t\t    }\n\t\t}\n\t    }\n\n\t    ND_TCHECK2(*data, 2);\n\t    bcc = EXTRACT_LE_16BITS(data);\n\t    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n\t    if (f2) {\n\t\tif (bcc > 0)\n\t\t    smb_fdata(ndo, data + 2, f2, data + 2 + bcc, unicodestr);\n\t    } else {\n\t\tif (bcc > 0) {\n\t\t    ND_PRINT((ndo, \"smb_buf[]=\\n\"));\n\t\t    smb_print_data(ndo, data + 2, min(bcc, PTR_DIFF(maxbuf, data + 2)));\n\t\t}\n\t    }\n\t}\n\n\tif ((fn->flags & FLG_CHAIN) == 0)\n\t    break;\n\tif (wct == 0)\n\t    break;\n\tND_TCHECK(words[1]);\n\tcommand = words[1];\n\tif (command == 0xFF)\n\t    break;\n\tND_TCHECK2(words[3], 2);\n\tnewsmboffset = EXTRACT_LE_16BITS(words + 3);\n\n\tfn = smbfind(command, smb_fns);\n\n\tND_PRINT((ndo, \"\\nSMB PACKET: %s (%s) (CHAINED)\\n\",\n\t    fn->name, request ? \"REQUEST\" : \"REPLY\"));\n\tif (newsmboffset <= smboffset) {\n\t    ND_PRINT((ndo, \"Bad andX offset: %u <= %u\\n\", newsmboffset, smboffset));\n\t    break;\n\t}\n\tsmboffset = newsmboffset;\n    }\n\n    ND_PRINT((ndo, \"\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\n/*\n * print a NBT packet received across tcp on port 139\n */\nvoid\nnbt_tcp_print(netdissect_options *ndo,\n              const u_char *data, int length)\n{\n    int caplen;\n    int type;\n    u_int nbt_len;\n    const u_char *maxbuf;\n\n    if (length < 4)\n\tgoto trunc;\n    if (ndo->ndo_snapend < data)\n\tgoto trunc;\n    caplen = ndo->ndo_snapend - data;\n    if (caplen < 4)\n\tgoto trunc;\n    maxbuf = data + caplen;\n    ND_TCHECK_8BITS(data);\n    type = data[0];\n    ND_TCHECK_16BITS(data + 2);\n    nbt_len = EXTRACT_16BITS(data + 2);\n    length -= 4;\n    caplen -= 4;\n\n    startbuf = data;\n\n    if (ndo->ndo_vflag < 2) {\n\tND_PRINT((ndo, \" NBT Session Packet: \"));\n\tswitch (type) {\n\tcase 0x00:\n\t    ND_PRINT((ndo, \"Session Message\"));\n\t    break;\n\n\tcase 0x81:\n\t    ND_PRINT((ndo, \"Session Request\"));\n\t    break;\n\n\tcase 0x82:\n\t    ND_PRINT((ndo, \"Session Granted\"));\n\t    break;\n\n\tcase 0x83:\n\t  {\n\t    int ecode;\n\n\t    if (nbt_len < 4)\n\t\tgoto trunc;\n\t    if (length < 4)\n\t\tgoto trunc;\n\t    if (caplen < 4)\n\t\tgoto trunc;\n\t    ecode = data[4];\n\n\t    ND_PRINT((ndo, \"Session Reject, \"));\n\t    switch (ecode) {\n\t    case 0x80:\n\t\tND_PRINT((ndo, \"Not listening on called name\"));\n\t\tbreak;\n\t    case 0x81:\n\t\tND_PRINT((ndo, \"Not listening for calling name\"));\n\t\tbreak;\n\t    case 0x82:\n\t\tND_PRINT((ndo, \"Called name not present\"));\n\t\tbreak;\n\t    case 0x83:\n\t\tND_PRINT((ndo, \"Called name present, but insufficient resources\"));\n\t\tbreak;\n\t    default:\n\t\tND_PRINT((ndo, \"Unspecified error 0x%X\", ecode));\n\t\tbreak;\n\t    }\n\t  }\n\t    break;\n\n\tcase 0x85:\n\t    ND_PRINT((ndo, \"Session Keepalive\"));\n\t    break;\n\n\tdefault:\n\t    data = smb_fdata(ndo, data, \"Unknown packet type [rB]\", maxbuf, 0);\n\t    break;\n\t}\n    } else {\n\tND_PRINT((ndo, \"\\n>>> NBT Session Packet\\n\"));\n\tswitch (type) {\n\tcase 0x00:\n\t    data = smb_fdata(ndo, data, \"[P1]NBT Session Message\\nFlags=[B]\\nLength=[rd]\\n\",\n\t\tdata + 4, 0);\n\t    if (data == NULL)\n\t\tbreak;\n\t    if (nbt_len >= 4 && caplen >= 4 && memcmp(data,\"\\377SMB\",4) == 0) {\n\t\tif ((int)nbt_len > caplen) {\n\t\t    if ((int)nbt_len > length)\n\t\t\tND_PRINT((ndo, \"WARNING: Packet is continued in later TCP segments\\n\"));\n\t\t    else\n\t\t\tND_PRINT((ndo, \"WARNING: Short packet. Try increasing the snap length by %d\\n\",\n\t\t\t    nbt_len - caplen));\n\t\t}\n\t\tprint_smb(ndo, data, maxbuf > data + nbt_len ? data + nbt_len : maxbuf);\n\t    } else\n\t\tND_PRINT((ndo, \"Session packet:(raw data or continuation?)\\n\"));\n\t    break;\n\n\tcase 0x81:\n\t    data = smb_fdata(ndo, data,\n\t\t\"[P1]NBT Session Request\\nFlags=[B]\\nLength=[rd]\\nDestination=[n1]\\nSource=[n1]\\n\",\n\t\tmaxbuf, 0);\n\t    break;\n\n\tcase 0x82:\n\t    data = smb_fdata(ndo, data, \"[P1]NBT Session Granted\\nFlags=[B]\\nLength=[rd]\\n\", maxbuf, 0);\n\t    break;\n\n\tcase 0x83:\n\t  {\n\t    const u_char *origdata;\n\t    int ecode;\n\n\t    origdata = data;\n\t    data = smb_fdata(ndo, data, \"[P1]NBT SessionReject\\nFlags=[B]\\nLength=[rd]\\nReason=[B]\\n\",\n\t\tmaxbuf, 0);\n\t    if (data == NULL)\n\t\tbreak;\n\t    if (nbt_len >= 1 && caplen >= 1) {\n\t\tecode = origdata[4];\n\t\tswitch (ecode) {\n\t\tcase 0x80:\n\t\t    ND_PRINT((ndo, \"Not listening on called name\\n\"));\n\t\t    break;\n\t\tcase 0x81:\n\t\t    ND_PRINT((ndo, \"Not listening for calling name\\n\"));\n\t\t    break;\n\t\tcase 0x82:\n\t\t    ND_PRINT((ndo, \"Called name not present\\n\"));\n\t\t    break;\n\t\tcase 0x83:\n\t\t    ND_PRINT((ndo, \"Called name present, but insufficient resources\\n\"));\n\t\t    break;\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \"Unspecified error 0x%X\\n\", ecode));\n\t\t    break;\n\t\t}\n\t    }\n\t  }\n\t    break;\n\n\tcase 0x85:\n\t    data = smb_fdata(ndo, data, \"[P1]NBT Session Keepalive\\nFlags=[B]\\nLength=[rd]\\n\", maxbuf, 0);\n\t    break;\n\n\tdefault:\n\t    data = smb_fdata(ndo, data, \"NBT - Unknown packet type\\nType=[B]\\n\", maxbuf, 0);\n\t    break;\n\t}\n\tND_PRINT((ndo, \"\\n\"));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic const struct tok opcode_str[] = {\n\t{ 0,  \"QUERY\"                   },\n\t{ 5,  \"REGISTRATION\"            },\n\t{ 6,  \"RELEASE\"                 },\n\t{ 7,  \"WACK\"                    },\n\t{ 8,  \"REFRESH(8)\"              },\n\t{ 9,  \"REFRESH\"                 },\n\t{ 15, \"MULTIHOMED REGISTRATION\" },\n\t{ 0, NULL }\n};\n\n/*\n * print a NBT packet received across udp on port 137\n */\nvoid\nnbt_udp137_print(netdissect_options *ndo,\n                 const u_char *data, int length)\n{\n    const u_char *maxbuf = data + length;\n    int name_trn_id, response, opcode, nm_flags, rcode;\n    int qdcount, ancount, nscount, arcount;\n    const u_char *p;\n    int total, i;\n\n    ND_TCHECK2(data[10], 2);\n    name_trn_id = EXTRACT_16BITS(data);\n    response = (data[2] >> 7);\n    opcode = (data[2] >> 3) & 0xF;\n    nm_flags = ((data[2] & 0x7) << 4) + (data[3] >> 4);\n    rcode = data[3] & 0xF;\n    qdcount = EXTRACT_16BITS(data + 4);\n    ancount = EXTRACT_16BITS(data + 6);\n    nscount = EXTRACT_16BITS(data + 8);\n    arcount = EXTRACT_16BITS(data + 10);\n    startbuf = data;\n\n    if (maxbuf <= data)\n\treturn;\n\n    if (ndo->ndo_vflag > 1)\n\tND_PRINT((ndo, \"\\n>>> \"));\n\n    ND_PRINT((ndo, \"NBT UDP PACKET(137): %s\", tok2str(opcode_str, \"OPUNKNOWN\", opcode)));\n    if (response) {\n        ND_PRINT((ndo, \"; %s\", rcode ? \"NEGATIVE\" : \"POSITIVE\"));\n    }\n    ND_PRINT((ndo, \"; %s; %s\", response ? \"RESPONSE\" : \"REQUEST\",\n              (nm_flags & 1) ? \"BROADCAST\" : \"UNICAST\"));\n\n    if (ndo->ndo_vflag < 2)\n\treturn;\n\n    ND_PRINT((ndo, \"\\nTrnID=0x%X\\nOpCode=%d\\nNmFlags=0x%X\\nRcode=%d\\nQueryCount=%d\\nAnswerCount=%d\\nAuthorityCount=%d\\nAddressRecCount=%d\\n\",\n\tname_trn_id, opcode, nm_flags, rcode, qdcount, ancount, nscount,\n\tarcount));\n\n    p = data + 12;\n\n    total = ancount + nscount + arcount;\n\n    if (qdcount > 100 || total > 100) {\n\tND_PRINT((ndo, \"Corrupt packet??\\n\"));\n\treturn;\n    }\n\n    if (qdcount) {\n\tND_PRINT((ndo, \"QuestionRecords:\\n\"));\n\tfor (i = 0; i < qdcount; i++) {\n\t    p = smb_fdata(ndo, p,\n\t\t\"|Name=[n1]\\nQuestionType=[rw]\\nQuestionClass=[rw]\\n#\",\n\t\tmaxbuf, 0);\n\t    if (p == NULL)\n\t\tgoto out;\n\t}\n    }\n\n    if (total) {\n\tND_PRINT((ndo, \"\\nResourceRecords:\\n\"));\n\tfor (i = 0; i < total; i++) {\n\t    int rdlen;\n\t    int restype;\n\n\t    p = smb_fdata(ndo, p, \"Name=[n1]\\n#\", maxbuf, 0);\n\t    if (p == NULL)\n\t\tgoto out;\n\t    ND_TCHECK_16BITS(p);\n\t    restype = EXTRACT_16BITS(p);\n\t    p = smb_fdata(ndo, p, \"ResType=[rw]\\nResClass=[rw]\\nTTL=[rD]\\n\", p + 8, 0);\n\t    if (p == NULL)\n\t\tgoto out;\n\t    ND_TCHECK_16BITS(p);\n\t    rdlen = EXTRACT_16BITS(p);\n\t    ND_PRINT((ndo, \"ResourceLength=%d\\nResourceData=\\n\", rdlen));\n\t    p += 2;\n\t    if (rdlen == 6) {\n\t\tp = smb_fdata(ndo, p, \"AddrType=[rw]\\nAddress=[b.b.b.b]\\n\", p + rdlen, 0);\n\t\tif (p == NULL)\n\t\t    goto out;\n\t    } else {\n\t\tif (restype == 0x21) {\n\t\t    int numnames;\n\n\t\t    ND_TCHECK(*p);\n\t\t    numnames = p[0];\n\t\t    p = smb_fdata(ndo, p, \"NumNames=[B]\\n\", p + 1, 0);\n\t\t    if (p == NULL)\n\t\t\tgoto out;\n\t\t    while (numnames--) {\n\t\t\tp = smb_fdata(ndo, p, \"Name=[n2]\\t#\", maxbuf, 0);\n\t\t\tif (p == NULL)\n\t\t\t    goto out;\n\t\t\tND_TCHECK(*p);\n\t\t\tif (p[0] & 0x80)\n\t\t\t    ND_PRINT((ndo, \"<GROUP> \"));\n\t\t\tswitch (p[0] & 0x60) {\n\t\t\tcase 0x00: ND_PRINT((ndo, \"B \")); break;\n\t\t\tcase 0x20: ND_PRINT((ndo, \"P \")); break;\n\t\t\tcase 0x40: ND_PRINT((ndo, \"M \")); break;\n\t\t\tcase 0x60: ND_PRINT((ndo, \"_ \")); break;\n\t\t\t}\n\t\t\tif (p[0] & 0x10)\n\t\t\t    ND_PRINT((ndo, \"<DEREGISTERING> \"));\n\t\t\tif (p[0] & 0x08)\n\t\t\t    ND_PRINT((ndo, \"<CONFLICT> \"));\n\t\t\tif (p[0] & 0x04)\n\t\t\t    ND_PRINT((ndo, \"<ACTIVE> \"));\n\t\t\tif (p[0] & 0x02)\n\t\t\t    ND_PRINT((ndo, \"<PERMANENT> \"));\n\t\t\tND_PRINT((ndo, \"\\n\"));\n\t\t\tp += 2;\n\t\t    }\n\t\t} else {\n\t\t    smb_print_data(ndo, p, min(rdlen, length - (p - data)));\n\t\t    p += rdlen;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (p < maxbuf)\n\tsmb_fdata(ndo, p, \"AdditionalData:\\n\", maxbuf, 0);\n\nout:\n    ND_PRINT((ndo, \"\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n/*\n * Print an SMB-over-TCP packet received across tcp on port 445\n */\nvoid\nsmb_tcp_print(netdissect_options *ndo,\n              const u_char * data, int length)\n{\n    int caplen;\n    u_int smb_len;\n    const u_char *maxbuf;\n\n    if (length < 4)\n\tgoto trunc;\n    if (ndo->ndo_snapend < data)\n\tgoto trunc;\n    caplen = ndo->ndo_snapend - data;\n    if (caplen < 4)\n\tgoto trunc;\n    maxbuf = data + caplen;\n    smb_len = EXTRACT_24BITS(data + 1);\n    length -= 4;\n    caplen -= 4;\n\n    startbuf = data;\n    data += 4;\n\n    if (smb_len >= 4 && caplen >= 4 && memcmp(data,\"\\377SMB\",4) == 0) {\n\tif ((int)smb_len > caplen) {\n\t    if ((int)smb_len > length)\n\t\tND_PRINT((ndo, \" WARNING: Packet is continued in later TCP segments\\n\"));\n\t    else\n\t\tND_PRINT((ndo, \" WARNING: Short packet. Try increasing the snap length by %d\\n\",\n\t\t    smb_len - caplen));\n\t} else\n\t    ND_PRINT((ndo, \" \"));\n\tprint_smb(ndo, data, maxbuf > data + smb_len ? data + smb_len : maxbuf);\n    } else\n\tND_PRINT((ndo, \" SMB-over-TCP packet:(raw data or continuation?)\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n/*\n * print a NBT packet received across udp on port 138\n */\nvoid\nnbt_udp138_print(netdissect_options *ndo,\n                 const u_char *data, int length)\n{\n    const u_char *maxbuf = data + length;\n\n    if (maxbuf > ndo->ndo_snapend)\n\tmaxbuf = ndo->ndo_snapend;\n    if (maxbuf <= data)\n\treturn;\n    startbuf = data;\n\n    if (ndo->ndo_vflag < 2) {\n\tND_PRINT((ndo, \"NBT UDP PACKET(138)\"));\n\treturn;\n    }\n\n    data = smb_fdata(ndo, data,\n\t\"\\n>>> NBT UDP PACKET(138) Res=[rw] ID=[rw] IP=[b.b.b.b] Port=[rd] Length=[rd] Res2=[rw]\\nSourceName=[n1]\\nDestName=[n1]\\n#\",\n\tmaxbuf, 0);\n\n    if (data != NULL) {\n\t/* If there isn't enough data for \"\\377SMB\", don't check for it. */\n\tif (&data[3] >= maxbuf)\n\t    goto out;\n\n\tif (memcmp(data, \"\\377SMB\",4) == 0)\n\t    print_smb(ndo, data, maxbuf);\n    }\nout:\n    ND_PRINT((ndo, \"\\n\"));\n}\n\n\n/*\n   print netbeui frames\n*/\nstatic struct nbf_strings {\n\tconst char\t*name;\n\tconst char\t*nonverbose;\n\tconst char\t*verbose;\n} nbf_strings[0x20] = {\n\t{ \"Add Group Name Query\", \", [P23]Name to add=[n2]#\",\n\t  \"[P5]ResponseCorrelator=[w]\\n[P16]Name to add=[n2]\\n\" },\n\t{ \"Add Name Query\", \", [P23]Name to add=[n2]#\",\n\t  \"[P5]ResponseCorrelator=[w]\\n[P16]Name to add=[n2]\\n\" },\n\t{ \"Name In Conflict\", NULL, NULL },\n\t{ \"Status Query\", NULL, NULL },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Terminate Trace\", NULL, NULL },\n\t{ \"Datagram\", NULL,\n\t  \"[P7]Destination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Broadcast Datagram\", NULL,\n\t  \"[P7]Destination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Name Query\", \", [P7]Name=[n2]#\",\n\t  \"[P1]SessionNumber=[B]\\nNameType=[B][P2]\\nResponseCorrelator=[w]\\nName=[n2]\\nName of sender=[n2]\\n\" },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Add Name Response\", \", [P1]GroupName=[w] [P4]Destination=[n2] Source=[n2]#\",\n\t  \"AddNameInProcess=[B]\\nGroupName=[w]\\nTransmitCorrelator=[w][P2]\\nDestination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Name Recognized\", NULL,\n\t  \"[P1]Data2=[w]\\nTransmitCorrelator=[w]\\nResponseCorelator=[w]\\nDestination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Status Response\", NULL, NULL },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Terminate Trace\", NULL, NULL },\n\t{ \"Data Ack\", NULL,\n\t  \"[P3]TransmitCorrelator=[w][P2]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Data First/Middle\", NULL,\n\t  \"Flags=[{RECEIVE_CONTINUE|NO_ACK||PIGGYBACK_ACK_INCLUDED|}]\\nResyncIndicator=[w][P2]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Data Only/Last\", NULL,\n\t  \"Flags=[{|NO_ACK|PIGGYBACK_ACK_ALLOWED|PIGGYBACK_ACK_INCLUDED|}]\\nResyncIndicator=[w][P2]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Session Confirm\", NULL,\n\t  \"Data1=[B]\\nData2=[w]\\nTransmitCorrelator=[w]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Session End\", NULL,\n\t  \"[P1]Data2=[w][P4]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Session Initialize\", NULL,\n\t  \"Data1=[B]\\nData2=[w]\\nTransmitCorrelator=[w]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"No Receive\", NULL,\n\t  \"Flags=[{|SEND_NO_ACK}]\\nDataBytesAccepted=[b][P4]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Receive Outstanding\", NULL,\n\t  \"[P1]DataBytesAccepted=[b][P4]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Receive Continue\", NULL,\n\t  \"[P2]TransmitCorrelator=[w]\\n[P2]RemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Session Alive\", NULL, NULL }\n};\n\nvoid\nnetbeui_print(netdissect_options *ndo,\n              u_short control, const u_char *data, int length)\n{\n    const u_char *maxbuf = data + length;\n    int len;\n    int command;\n    const u_char *data2;\n    int is_truncated = 0;\n\n    if (maxbuf > ndo->ndo_snapend)\n\tmaxbuf = ndo->ndo_snapend;\n    ND_TCHECK(data[4]);\n    len = EXTRACT_LE_16BITS(data);\n    command = data[4];\n    data2 = data + len;\n    if (data2 >= maxbuf) {\n\tdata2 = maxbuf;\n\tis_truncated = 1;\n    }\n\n    startbuf = data;\n\n    if (ndo->ndo_vflag < 2) {\n\tND_PRINT((ndo, \"NBF Packet: \"));\n\tdata = smb_fdata(ndo, data, \"[P5]#\", maxbuf, 0);\n    } else {\n\tND_PRINT((ndo, \"\\n>>> NBF Packet\\nType=0x%X \", control));\n\tdata = smb_fdata(ndo, data, \"Length=[d] Signature=[w] Command=[B]\\n#\", maxbuf, 0);\n    }\n    if (data == NULL)\n\tgoto out;\n\n    if (command > 0x1f || nbf_strings[command].name == NULL) {\n\tif (ndo->ndo_vflag < 2)\n\t    data = smb_fdata(ndo, data, \"Unknown NBF Command#\", data2, 0);\n\telse\n\t    data = smb_fdata(ndo, data, \"Unknown NBF Command\\n\", data2, 0);\n    } else {\n\tif (ndo->ndo_vflag < 2) {\n\t    ND_PRINT((ndo, \"%s\", nbf_strings[command].name));\n\t    if (nbf_strings[command].nonverbose != NULL)\n\t\tdata = smb_fdata(ndo, data, nbf_strings[command].nonverbose, data2, 0);\n\t} else {\n\t    ND_PRINT((ndo, \"%s:\\n\", nbf_strings[command].name));\n\t    if (nbf_strings[command].verbose != NULL)\n\t\tdata = smb_fdata(ndo, data, nbf_strings[command].verbose, data2, 0);\n\t    else\n\t\tND_PRINT((ndo, \"\\n\"));\n\t}\n    }\n\n    if (ndo->ndo_vflag < 2)\n\treturn;\n\n    if (data == NULL)\n\tgoto out;\n\n    if (is_truncated) {\n\t/* data2 was past the end of the buffer */\n\tgoto out;\n    }\n\n    /* If this isn't a command that would contain an SMB message, quit. */\n    if (command != 0x08 && command != 0x09 && command != 0x15 &&\n        command != 0x16)\n\tgoto out;\n\n    /* If there isn't enough data for \"\\377SMB\", don't look for it. */\n    if (&data2[3] >= maxbuf)\n\tgoto out;\n\n    if (memcmp(data2, \"\\377SMB\",4) == 0)\n\tprint_smb(ndo, data2, maxbuf);\n    else {\n\tint i;\n\tfor (i = 0; i < 128; i++) {\n\t    if (&data2[i + 3] >= maxbuf)\n\t\tbreak;\n\t    if (memcmp(&data2[i], \"\\377SMB\", 4) == 0) {\n\t\tND_PRINT((ndo, \"found SMB packet at %d\\n\", i));\n\t\tprint_smb(ndo, &data2[i], maxbuf);\n\t\tbreak;\n\t    }\n\t}\n    }\n\nout:\n    ND_PRINT((ndo, \"\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\n/*\n * print IPX-Netbios frames\n */\nvoid\nipx_netbios_print(netdissect_options *ndo,\n                  const u_char *data, u_int length)\n{\n    /*\n     * this is a hack till I work out how to parse the rest of the\n     * NetBIOS-over-IPX stuff\n     */\n    int i;\n    const u_char *maxbuf;\n\n    maxbuf = data + length;\n    /* Don't go past the end of the captured data in the packet. */\n    if (maxbuf > ndo->ndo_snapend)\n\tmaxbuf = ndo->ndo_snapend;\n    startbuf = data;\n    for (i = 0; i < 128; i++) {\n\tif (&data[i + 4] > maxbuf)\n\t    break;\n\tif (memcmp(&data[i], \"\\377SMB\", 4) == 0) {\n\t    smb_fdata(ndo, data, \"\\n>>> IPX transport \", &data[i], 0);\n\t    print_smb(ndo, &data[i], maxbuf);\n\t    ND_PRINT((ndo, \"\\n\"));\n\t    break;\n\t}\n    }\n    if (i == 128)\n\tsmb_fdata(ndo, data, \"\\n>>> Unknown IPX \", maxbuf, 0);\n}\n"], "fixing_code": ["/*\n * Copyright (C) Andrew Tridgell 1995-1999\n *\n * This software may be distributed either under the terms of the\n * BSD-style license that accompanies tcpdump or the GNU GPL version 2\n * or later\n */\n\n/* \\summary: SMB/CIFS printer */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include <string.h>\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"smb.h\"\n\nstatic const char tstr[] = \"[|SMB]\";\n\nstatic int request = 0;\nstatic int unicodestr = 0;\n\nconst u_char *startbuf = NULL;\n\nstruct smbdescript {\n    const char *req_f1;\n    const char *req_f2;\n    const char *rep_f1;\n    const char *rep_f2;\n    void (*fn)(netdissect_options *, const u_char *, const u_char *, const u_char *, const u_char *);\n};\n\nstruct smbdescriptint {\n    const char *req_f1;\n    const char *req_f2;\n    const char *rep_f1;\n    const char *rep_f2;\n    void (*fn)(netdissect_options *, const u_char *, const u_char *, int, int);\n};\n\nstruct smbfns\n{\n    int id;\n    const char *name;\n    int flags;\n    struct smbdescript descript;\n};\n\nstruct smbfnsint\n{\n    int id;\n    const char *name;\n    int flags;\n    struct smbdescriptint descript;\n};\n\n#define DEFDESCRIPT\t{ NULL, NULL, NULL, NULL, NULL }\n\n#define FLG_CHAIN\t(1 << 0)\n\nstatic const struct smbfns *\nsmbfind(int id, const struct smbfns *list)\n{\n    int sindex;\n\n    for (sindex = 0; list[sindex].name; sindex++)\n\tif (list[sindex].id == id)\n\t    return(&list[sindex]);\n\n    return(&list[0]);\n}\n\nstatic const struct smbfnsint *\nsmbfindint(int id, const struct smbfnsint *list)\n{\n    int sindex;\n\n    for (sindex = 0; list[sindex].name; sindex++)\n\tif (list[sindex].id == id)\n\t    return(&list[sindex]);\n\n    return(&list[0]);\n}\n\nstatic void\ntrans2_findfirst(netdissect_options *ndo,\n                 const u_char *param, const u_char *data, int pcnt, int dcnt)\n{\n    const char *fmt;\n\n    if (request)\n\tfmt = \"Attribute=[A]\\nSearchCount=[d]\\nFlags=[w]\\nLevel=[dP4]\\nFile=[S]\\n\";\n    else\n\tfmt = \"Handle=[w]\\nCount=[d]\\nEOS=[w]\\nEoffset=[d]\\nLastNameOfs=[w]\\n\";\n\n    smb_fdata(ndo, param, fmt, param + pcnt, unicodestr);\n    if (dcnt) {\n\tND_PRINT((ndo, \"data:\\n\"));\n\tsmb_print_data(ndo, data, dcnt);\n    }\n}\n\nstatic void\ntrans2_qfsinfo(netdissect_options *ndo,\n               const u_char *param, const u_char *data, int pcnt, int dcnt)\n{\n    static int level = 0;\n    const char *fmt=\"\";\n\n    if (request) {\n\tND_TCHECK2(*param, 2);\n\tlevel = EXTRACT_LE_16BITS(param);\n\tfmt = \"InfoLevel=[d]\\n\";\n\tsmb_fdata(ndo, param, fmt, param + pcnt, unicodestr);\n    } else {\n\tswitch (level) {\n\tcase 1:\n\t    fmt = \"idFileSystem=[W]\\nSectorUnit=[D]\\nUnit=[D]\\nAvail=[D]\\nSectorSize=[d]\\n\";\n\t    break;\n\tcase 2:\n\t    fmt = \"CreationTime=[T2]VolNameLength=[lb]\\nVolumeLabel=[c]\\n\";\n\t    break;\n\tcase 0x105:\n\t    fmt = \"Capabilities=[W]\\nMaxFileLen=[D]\\nVolNameLen=[lD]\\nVolume=[C]\\n\";\n\t    break;\n\tdefault:\n\t    fmt = \"UnknownLevel\\n\";\n\t    break;\n\t}\n\tsmb_fdata(ndo, data, fmt, data + dcnt, unicodestr);\n    }\n    if (dcnt) {\n\tND_PRINT((ndo, \"data:\\n\"));\n\tsmb_print_data(ndo, data, dcnt);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic const struct smbfnsint trans2_fns[] = {\n    { 0, \"TRANSACT2_OPEN\", 0,\n\t{ \"Flags2=[w]\\nMode=[w]\\nSearchAttrib=[A]\\nAttrib=[A]\\nTime=[T2]\\nOFun=[w]\\nSize=[D]\\nRes=([w, w, w, w, w])\\nPath=[S]\",\n\t  NULL,\n\t  \"Handle=[d]\\nAttrib=[A]\\nTime=[T2]\\nSize=[D]\\nAccess=[w]\\nType=[w]\\nState=[w]\\nAction=[w]\\nInode=[W]\\nOffErr=[d]\\n|EALength=[d]\\n\",\n\t  NULL, NULL }},\n    { 1, \"TRANSACT2_FINDFIRST\", 0,\n\t{ NULL, NULL, NULL, NULL, trans2_findfirst }},\n    { 2, \"TRANSACT2_FINDNEXT\", 0, DEFDESCRIPT },\n    { 3, \"TRANSACT2_QFSINFO\", 0,\n\t{ NULL, NULL, NULL, NULL, trans2_qfsinfo }},\n    { 4, \"TRANSACT2_SETFSINFO\", 0, DEFDESCRIPT },\n    { 5, \"TRANSACT2_QPATHINFO\", 0, DEFDESCRIPT },\n    { 6, \"TRANSACT2_SETPATHINFO\", 0, DEFDESCRIPT },\n    { 7, \"TRANSACT2_QFILEINFO\", 0, DEFDESCRIPT },\n    { 8, \"TRANSACT2_SETFILEINFO\", 0, DEFDESCRIPT },\n    { 9, \"TRANSACT2_FSCTL\", 0, DEFDESCRIPT },\n    { 10, \"TRANSACT2_IOCTL\", 0, DEFDESCRIPT },\n    { 11, \"TRANSACT2_FINDNOTIFYFIRST\", 0, DEFDESCRIPT },\n    { 12, \"TRANSACT2_FINDNOTIFYNEXT\", 0, DEFDESCRIPT },\n    { 13, \"TRANSACT2_MKDIR\", 0, DEFDESCRIPT },\n    { -1, NULL, 0, DEFDESCRIPT }\n};\n\n\nstatic void\nprint_trans2(netdissect_options *ndo,\n             const u_char *words, const u_char *dat, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    static const struct smbfnsint *fn = &trans2_fns[0];\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    const char *f1 = NULL, *f2 = NULL;\n    int pcnt, dcnt;\n\n    ND_TCHECK(words[0]);\n    if (request) {\n\tND_TCHECK2(w[14 * 2], 2);\n\tpcnt = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdcnt = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tfn = smbfindint(EXTRACT_LE_16BITS(w + 14 * 2), trans2_fns);\n    } else {\n\tif (words[0] == 0) {\n\t    ND_PRINT((ndo, \"%s\\n\", fn->name));\n\t    ND_PRINT((ndo, \"Trans2Interim\\n\"));\n\t    return;\n\t}\n\tND_TCHECK2(w[7 * 2], 2);\n\tpcnt = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdcnt = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n    }\n\n    ND_PRINT((ndo, \"%s param_length=%d data_length=%d\\n\", fn->name, pcnt, dcnt));\n\n    if (request) {\n\tif (words[0] == 8) {\n\t    smb_fdata(ndo, words + 1,\n\t\t\"Trans2Secondary\\nTotParam=[d]\\nTotData=[d]\\nParamCnt=[d]\\nParamOff=[d]\\nParamDisp=[d]\\nDataCnt=[d]\\nDataOff=[d]\\nDataDisp=[d]\\nHandle=[d]\\n\",\n\t\tmaxbuf, unicodestr);\n\t    return;\n\t} else {\n\t    smb_fdata(ndo, words + 1,\n\t\t\"TotParam=[d]\\nTotData=[d]\\nMaxParam=[d]\\nMaxData=[d]\\nMaxSetup=[b][P1]\\nFlags=[w]\\nTimeOut=[D]\\nRes1=[w]\\nParamCnt=[d]\\nParamOff=[d]\\nDataCnt=[d]\\nDataOff=[d]\\nSetupCnt=[b][P1]\\n\",\n\t\twords + 1 + 14 * 2, unicodestr);\n\t}\n\tf1 = fn->descript.req_f1;\n\tf2 = fn->descript.req_f2;\n    } else {\n\tsmb_fdata(ndo, words + 1,\n\t    \"TotParam=[d]\\nTotData=[d]\\nRes1=[w]\\nParamCnt=[d]\\nParamOff=[d]\\nParamDisp[d]\\nDataCnt=[d]\\nDataOff=[d]\\nDataDisp=[d]\\nSetupCnt=[b][P1]\\n\",\n\t    words + 1 + 10 * 2, unicodestr);\n\tf1 = fn->descript.rep_f1;\n\tf2 = fn->descript.rep_f2;\n    }\n\n    ND_TCHECK2(*dat, 2);\n    bcc = EXTRACT_LE_16BITS(dat);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (fn->descript.fn)\n\t(*fn->descript.fn)(ndo, param, data, pcnt, dcnt);\n    else {\n\tsmb_fdata(ndo, param, f1 ? f1 : \"Parameters=\\n\", param + pcnt, unicodestr);\n\tsmb_fdata(ndo, data, f2 ? f2 : \"Data=\\n\", data + dcnt, unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nprint_browse(netdissect_options *ndo,\n             const u_char *param, int paramlen, const u_char *data, int datalen)\n{\n    const u_char *maxbuf = data + datalen;\n    int command;\n\n    ND_TCHECK(data[0]);\n    command = data[0];\n\n    smb_fdata(ndo, param, \"BROWSE PACKET\\n|Param \", param+paramlen, unicodestr);\n\n    switch (command) {\n    case 0xF:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (LocalMasterAnnouncement)\\nUpdateCount=[w]\\nRes1=[B]\\nAnnounceInterval=[d]\\nName=[n2]\\nMajorVersion=[B]\\nMinorVersion=[B]\\nServerType=[W]\\nElectionVersion=[w]\\nBrowserConstant=[w]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x1:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (HostAnnouncement)\\nUpdateCount=[w]\\nRes1=[B]\\nAnnounceInterval=[d]\\nName=[n2]\\nMajorVersion=[B]\\nMinorVersion=[B]\\nServerType=[W]\\nElectionVersion=[w]\\nBrowserConstant=[w]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x2:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (AnnouncementRequest)\\nFlags=[B]\\nReplySystemName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xc:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (WorkgroupAnnouncement)\\nUpdateCount=[w]\\nRes1=[B]\\nAnnounceInterval=[d]\\nName=[n2]\\nMajorVersion=[B]\\nMinorVersion=[B]\\nServerType=[W]\\nCommentPointer=[W]\\nServerName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x8:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (ElectionFrame)\\nElectionVersion=[B]\\nOSSummary=[W]\\nUptime=[(W, W)]\\nServerName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xb:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (BecomeBackupBrowser)\\nName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0x9:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (GetBackupList)\\nListCount?=[B]\\nToken=[W]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xa:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (BackupListResponse)\\nServerCount?=[B]\\nToken=[W]\\n*Name=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xd:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (MasterAnnouncement)\\nMasterName=[S]\\n\",\n\t    maxbuf, unicodestr);\n\tbreak;\n\n    case 0xe:\n\tdata = smb_fdata(ndo, data,\n\t    \"BROWSE PACKET:\\nType=[B] (ResetBrowser)\\nOptions=[B]\\n\", maxbuf, unicodestr);\n\tbreak;\n\n    default:\n\tdata = smb_fdata(ndo, data, \"Unknown Browser Frame \", maxbuf, unicodestr);\n\tbreak;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\nstatic void\nprint_ipc(netdissect_options *ndo,\n          const u_char *param, int paramlen, const u_char *data, int datalen)\n{\n    if (paramlen)\n\tsmb_fdata(ndo, param, \"Command=[w]\\nStr1=[S]\\nStr2=[S]\\n\", param + paramlen,\n\t    unicodestr);\n    if (datalen)\n\tsmb_fdata(ndo, data, \"IPC \", data + datalen, unicodestr);\n}\n\n\nstatic void\nprint_trans(netdissect_options *ndo,\n            const u_char *words, const u_char *data1, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    const char *f1, *f2, *f3, *f4;\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    int datalen, paramlen;\n\n    if (request) {\n\tND_TCHECK2(w[12 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nMaxParmCnt=[d] \\nMaxDataCnt=[d]\\nMaxSCnt=[d] \\nTransFlags=[w] \\nRes1=[w] \\nRes2=[w] \\nRes3=[w]\\nParamCnt=[d] \\nParamOff=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nSUCnt=[d]\\n\";\n\tf2 = \"|Name=[S]\\n\";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    } else {\n\tND_TCHECK2(w[7 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nRes1=[d]\\nParamCnt=[d] \\nParamOff=[d] \\nRes2=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nRes3=[d]\\nLsetup=[d]\\n\";\n\tf2 = \"|Unknown \";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    }\n\n    smb_fdata(ndo, words + 1, f1, min(words + 1 + 2 * words[0], maxbuf),\n        unicodestr);\n\n    ND_TCHECK2(*data1, 2);\n    bcc = EXTRACT_LE_16BITS(data1);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tsmb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);\n#define MAILSLOT_BROWSE_STR \"\\\\MAILSLOT\\\\BROWSE\"\n\tND_TCHECK2(*(data1 + 2), strlen(MAILSLOT_BROWSE_STR) + 1);\n\tif (strcmp((const char *)(data1 + 2), MAILSLOT_BROWSE_STR) == 0) {\n\t    print_browse(ndo, param, paramlen, data, datalen);\n\t    return;\n\t}\n#undef MAILSLOT_BROWSE_STR\n\n#define PIPE_LANMAN_STR \"\\\\PIPE\\\\LANMAN\"\n\tND_TCHECK2(*(data1 + 2), strlen(PIPE_LANMAN_STR) + 1);\n\tif (strcmp((const char *)(data1 + 2), PIPE_LANMAN_STR) == 0) {\n\t    print_ipc(ndo, param, paramlen, data, datalen);\n\t    return;\n\t}\n#undef PIPE_LANMAN_STR\n\n\tif (paramlen)\n\t    smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr);\n\tif (datalen)\n\t    smb_fdata(ndo, data, f4, min(data + datalen, maxbuf), unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\nstatic void\nprint_negprot(netdissect_options *ndo,\n              const u_char *words, const u_char *data, const u_char *buf _U_, const u_char *maxbuf)\n{\n    u_int wct, bcc;\n    const char *f1 = NULL, *f2 = NULL;\n\n    ND_TCHECK(words[0]);\n    wct = words[0];\n    if (request)\n\tf2 = \"*|Dialect=[Y]\\n\";\n    else {\n\tif (wct == 1)\n\t    f1 = \"Core Protocol\\nDialectIndex=[d]\";\n\telse if (wct == 17)\n\t    f1 = \"NT1 Protocol\\nDialectIndex=[d]\\nSecMode=[B]\\nMaxMux=[d]\\nNumVcs=[d]\\nMaxBuffer=[D]\\nRawSize=[D]\\nSessionKey=[W]\\nCapabilities=[W]\\nServerTime=[T3]TimeZone=[d]\\nCryptKey=\";\n\telse if (wct == 13)\n\t    f1 = \"Coreplus/Lanman1/Lanman2 Protocol\\nDialectIndex=[d]\\nSecMode=[w]\\nMaxXMit=[d]\\nMaxMux=[d]\\nMaxVcs=[d]\\nBlkMode=[w]\\nSessionKey=[W]\\nServerTime=[T1]TimeZone=[d]\\nRes=[W]\\nCryptKey=\";\n    }\n\n    if (f1)\n\tsmb_fdata(ndo, words + 1, f1, min(words + 1 + wct * 2, maxbuf),\n\t    unicodestr);\n    else\n\tsmb_print_data(ndo, words + 1, min(wct * 2, PTR_DIFF(maxbuf, words + 1)));\n\n    ND_TCHECK2(*data, 2);\n    bcc = EXTRACT_LE_16BITS(data);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tif (f2)\n\t    smb_fdata(ndo, data + 2, f2, min(data + 2 + EXTRACT_LE_16BITS(data),\n\t\tmaxbuf), unicodestr);\n\telse\n\t    smb_print_data(ndo, data + 2, min(EXTRACT_LE_16BITS(data), PTR_DIFF(maxbuf, data + 2)));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nprint_sesssetup(netdissect_options *ndo,\n                const u_char *words, const u_char *data, const u_char *buf _U_, const u_char *maxbuf)\n{\n    u_int wct, bcc;\n    const char *f1 = NULL, *f2 = NULL;\n\n    ND_TCHECK(words[0]);\n    wct = words[0];\n    if (request) {\n\tif (wct == 10)\n\t    f1 = \"Com2=[w]\\nOff2=[d]\\nBufSize=[d]\\nMpxMax=[d]\\nVcNum=[d]\\nSessionKey=[W]\\nPassLen=[d]\\nCryptLen=[d]\\nCryptOff=[d]\\nPass&Name=\\n\";\n\telse\n\t    f1 = \"Com2=[B]\\nRes1=[B]\\nOff2=[d]\\nMaxBuffer=[d]\\nMaxMpx=[d]\\nVcNumber=[d]\\nSessionKey=[W]\\nCaseInsensitivePasswordLength=[d]\\nCaseSensitivePasswordLength=[d]\\nRes=[W]\\nCapabilities=[W]\\nPass1&Pass2&Account&Domain&OS&LanMan=\\n\";\n    } else {\n\tif (wct == 3) {\n\t    f1 = \"Com2=[w]\\nOff2=[d]\\nAction=[w]\\n\";\n\t} else if (wct == 13) {\n\t    f1 = \"Com2=[B]\\nRes=[B]\\nOff2=[d]\\nAction=[w]\\n\";\n\t    f2 = \"NativeOS=[S]\\nNativeLanMan=[S]\\nPrimaryDomain=[S]\\n\";\n\t}\n    }\n\n    if (f1)\n\tsmb_fdata(ndo, words + 1, f1, min(words + 1 + wct * 2, maxbuf),\n\t    unicodestr);\n    else\n\tsmb_print_data(ndo, words + 1, min(wct * 2, PTR_DIFF(maxbuf, words + 1)));\n\n    ND_TCHECK2(*data, 2);\n    bcc = EXTRACT_LE_16BITS(data);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tif (f2)\n\t    smb_fdata(ndo, data + 2, f2, min(data + 2 + EXTRACT_LE_16BITS(data),\n\t\tmaxbuf), unicodestr);\n\telse\n\t    smb_print_data(ndo, data + 2, min(EXTRACT_LE_16BITS(data), PTR_DIFF(maxbuf, data + 2)));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nprint_lockingandx(netdissect_options *ndo,\n                  const u_char *words, const u_char *data, const u_char *buf _U_, const u_char *maxbuf)\n{\n    u_int wct, bcc;\n    const u_char *maxwords;\n    const char *f1 = NULL, *f2 = NULL;\n\n    ND_TCHECK(words[0]);\n    wct = words[0];\n    if (request) {\n\tf1 = \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nLockType=[w]\\nTimeOut=[D]\\nUnlockCount=[d]\\nLockCount=[d]\\n\";\n\tND_TCHECK(words[7]);\n\tif (words[7] & 0x10)\n\t    f2 = \"*Process=[d]\\n[P2]Offset=[M]\\nLength=[M]\\n\";\n\telse\n\t    f2 = \"*Process=[d]\\nOffset=[D]\\nLength=[D]\\n\";\n    } else {\n\tf1 = \"Com2=[w]\\nOff2=[d]\\n\";\n    }\n\n    maxwords = min(words + 1 + wct * 2, maxbuf);\n    if (wct)\n\tsmb_fdata(ndo, words + 1, f1, maxwords, unicodestr);\n\n    ND_TCHECK2(*data, 2);\n    bcc = EXTRACT_LE_16BITS(data);\n    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n    if (bcc > 0) {\n\tif (f2)\n\t    smb_fdata(ndo, data + 2, f2, min(data + 2 + EXTRACT_LE_16BITS(data),\n\t\tmaxbuf), unicodestr);\n\telse\n\t    smb_print_data(ndo, data + 2, min(EXTRACT_LE_16BITS(data), PTR_DIFF(maxbuf, data + 2)));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\nstatic const struct smbfns smb_fns[] = {\n    { -1, \"SMBunknown\", 0, DEFDESCRIPT },\n\n    { SMBtcon, \"SMBtcon\", 0,\n\t{ NULL, \"Path=[Z]\\nPassword=[Z]\\nDevice=[Z]\\n\",\n\t  \"MaxXmit=[d]\\nTreeId=[d]\\n\", NULL,\n\t  NULL } },\n\n    { SMBtdis, \"SMBtdis\", 0, DEFDESCRIPT },\n    { SMBexit,  \"SMBexit\", 0, DEFDESCRIPT },\n    { SMBioctl, \"SMBioctl\", 0, DEFDESCRIPT },\n\n    { SMBecho, \"SMBecho\", 0,\n\t{ \"ReverbCount=[d]\\n\", NULL,\n\t  \"SequenceNum=[d]\\n\", NULL,\n\t  NULL } },\n\n    { SMBulogoffX, \"SMBulogoffX\", FLG_CHAIN, DEFDESCRIPT },\n\n    { SMBgetatr, \"SMBgetatr\", 0,\n\t{ NULL, \"Path=[Z]\\n\",\n\t  \"Attribute=[A]\\nTime=[T2]Size=[D]\\nRes=([w,w,w,w,w])\\n\", NULL,\n\t  NULL } },\n\n    { SMBsetatr, \"SMBsetatr\", 0,\n\t{ \"Attribute=[A]\\nTime=[T2]Res=([w,w,w,w,w])\\n\", \"Path=[Z]\\n\",\n\t  NULL, NULL, NULL } },\n\n    { SMBchkpth, \"SMBchkpth\", 0,\n       { NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBsearch, \"SMBsearch\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBopen, \"SMBopen\", 0,\n\t{ \"Mode=[w]\\nAttribute=[A]\\n\", \"Path=[Z]\\n\",\n\t  \"Handle=[d]\\nOAttrib=[A]\\nTime=[T2]Size=[D]\\nAccess=[w]\\n\",\n\t  NULL, NULL } },\n\n    { SMBcreate, \"SMBcreate\", 0,\n\t{ \"Attrib=[A]\\nTime=[T2]\", \"Path=[Z]\\n\", \"Handle=[d]\\n\", NULL, NULL } },\n\n    { SMBmknew, \"SMBmknew\", 0,\n\t{ \"Attrib=[A]\\nTime=[T2]\", \"Path=[Z]\\n\", \"Handle=[d]\\n\", NULL, NULL } },\n\n    { SMBunlink, \"SMBunlink\", 0,\n\t{ \"Attrib=[A]\\n\", \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBread, \"SMBread\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\nRes=([w,w,w,w])\\n\", NULL, NULL } },\n\n    { SMBwrite, \"SMBwrite\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBclose, \"SMBclose\", 0,\n\t{ \"Handle=[d]\\nTime=[T2]\", NULL, NULL, NULL, NULL } },\n\n    { SMBmkdir, \"SMBmkdir\", 0,\n\t{ NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBrmdir, \"SMBrmdir\", 0,\n\t{ NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBdskattr, \"SMBdskattr\", 0,\n\t{ NULL, NULL,\n\t  \"TotalUnits=[d]\\nBlocksPerUnit=[d]\\nBlockSize=[d]\\nFreeUnits=[d]\\nMedia=[w]\\n\",\n\t  NULL, NULL } },\n\n    { SMBmv, \"SMBmv\", 0,\n\t{ \"Attrib=[A]\\n\", \"OldPath=[Z]\\nNewPath=[Z]\\n\", NULL, NULL, NULL } },\n\n    /*\n     * this is a Pathworks specific call, allowing the\n     * changing of the root path\n     */\n    { pSETDIR, \"SMBsetdir\", 0, { NULL, \"Path=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBlseek, \"SMBlseek\", 0,\n\t{ \"Handle=[d]\\nMode=[w]\\nOffset=[D]\\n\", \"Offset=[D]\\n\", NULL, NULL, NULL } },\n\n    { SMBflush, \"SMBflush\", 0, { \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsplopen, \"SMBsplopen\", 0,\n\t{ \"SetupLen=[d]\\nMode=[w]\\n\", \"Ident=[Z]\\n\", \"Handle=[d]\\n\",\n\t  NULL, NULL } },\n\n    { SMBsplclose, \"SMBsplclose\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsplretq, \"SMBsplretq\", 0,\n\t{ \"MaxCount=[d]\\nStartIndex=[d]\\n\", NULL,\n\t  \"Count=[d]\\nIndex=[d]\\n\",\n\t  \"*Time=[T2]Status=[B]\\nJobID=[d]\\nSize=[D]\\nRes=[B]Name=[s16]\\n\",\n\t  NULL } },\n\n    { SMBsplwr, \"SMBsplwr\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBlock, \"SMBlock\", 0,\n\t{ \"Handle=[d]\\nCount=[D]\\nOffset=[D]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBunlock, \"SMBunlock\", 0,\n\t{ \"Handle=[d]\\nCount=[D]\\nOffset=[D]\\n\", NULL, NULL, NULL, NULL } },\n\n    /* CORE+ PROTOCOL FOLLOWS */\n\n    { SMBreadbraw, \"SMBreadbraw\", 0,\n\t{ \"Handle=[d]\\nOffset=[D]\\nMaxCount=[d]\\nMinCount=[d]\\nTimeOut=[D]\\nRes=[d]\\n\",\n\t  NULL, NULL, NULL, NULL } },\n\n    { SMBwritebraw, \"SMBwritebraw\", 0,\n\t{ \"Handle=[d]\\nTotalCount=[d]\\nRes=[w]\\nOffset=[D]\\nTimeOut=[D]\\nWMode=[w]\\nRes2=[W]\\n|DataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL, \"WriteRawAck\", NULL, NULL } },\n\n    { SMBwritec, \"SMBwritec\", 0,\n\t{ NULL, NULL, \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBwriteclose, \"SMBwriteclose\", 0,\n\t{ \"Handle=[d]\\nCount=[d]\\nOffset=[D]\\nTime=[T2]Res=([w,w,w,w,w,w])\",\n\t  NULL, \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBlockread, \"SMBlockread\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\nRes=([w,w,w,w])\\n\", NULL, NULL } },\n\n    { SMBwriteunlock, \"SMBwriteunlock\", 0,\n\t{ \"Handle=[d]\\nByteCount=[d]\\nOffset=[D]\\nCountLeft=[d]\\n\", NULL,\n\t  \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBreadBmpx, \"SMBreadBmpx\", 0,\n\t{ \"Handle=[d]\\nOffset=[D]\\nMaxCount=[d]\\nMinCount=[d]\\nTimeOut=[D]\\nRes=[w]\\n\",\n\t  NULL,\n\t  \"Offset=[D]\\nTotCount=[d]\\nRemaining=[d]\\nRes=([w,w])\\nDataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL, NULL } },\n\n    { SMBwriteBmpx, \"SMBwriteBmpx\", 0,\n\t{ \"Handle=[d]\\nTotCount=[d]\\nRes=[w]\\nOffset=[D]\\nTimeOut=[D]\\nWMode=[w]\\nRes2=[W]\\nDataSize=[d]\\nDataOff=[d]\\n\", NULL,\n\t  \"Remaining=[d]\\n\", NULL, NULL } },\n\n    { SMBwriteBs, \"SMBwriteBs\", 0,\n\t{ \"Handle=[d]\\nTotCount=[d]\\nOffset=[D]\\nRes=[W]\\nDataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL, \"Count=[d]\\n\", NULL, NULL } },\n\n    { SMBsetattrE, \"SMBsetattrE\", 0,\n\t{ \"Handle=[d]\\nCreationTime=[T2]AccessTime=[T2]ModifyTime=[T2]\", NULL,\n\t  NULL, NULL, NULL } },\n\n    { SMBgetattrE, \"SMBgetattrE\", 0,\n\t{ \"Handle=[d]\\n\", NULL,\n\t  \"CreationTime=[T2]AccessTime=[T2]ModifyTime=[T2]Size=[D]\\nAllocSize=[D]\\nAttribute=[A]\\n\",\n\t  NULL, NULL } },\n\n    { SMBtranss, \"SMBtranss\", 0, DEFDESCRIPT },\n    { SMBioctls, \"SMBioctls\", 0, DEFDESCRIPT },\n\n    { SMBcopy, \"SMBcopy\", 0,\n\t{ \"TreeID2=[d]\\nOFun=[w]\\nFlags=[w]\\n\", \"Path=[S]\\nNewPath=[S]\\n\",\n\t  \"CopyCount=[d]\\n\",  \"|ErrStr=[S]\\n\",  NULL } },\n\n    { SMBmove, \"SMBmove\", 0,\n\t{ \"TreeID2=[d]\\nOFun=[w]\\nFlags=[w]\\n\", \"Path=[S]\\nNewPath=[S]\\n\",\n\t  \"MoveCount=[d]\\n\",  \"|ErrStr=[S]\\n\",  NULL } },\n\n    { SMBopenX, \"SMBopenX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nFlags=[w]\\nMode=[w]\\nSearchAttrib=[A]\\nAttrib=[A]\\nTime=[T2]OFun=[w]\\nSize=[D]\\nTimeOut=[D]\\nRes=[W]\\n\",\n\t  \"Path=[S]\\n\",\n\t  \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nAttrib=[A]\\nTime=[T2]Size=[D]\\nAccess=[w]\\nType=[w]\\nState=[w]\\nAction=[w]\\nFileID=[W]\\nRes=[w]\\n\",\n\t  NULL, NULL } },\n\n    { SMBreadX, \"SMBreadX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nOffset=[D]\\nMaxCount=[d]\\nMinCount=[d]\\nTimeOut=[D]\\nCountLeft=[d]\\n\",\n\t  NULL,\n\t  \"Com2=[w]\\nOff2=[d]\\nRemaining=[d]\\nRes=[W]\\nDataSize=[d]\\nDataOff=[d]\\nRes=([w,w,w,w])\\n\",\n\t  NULL, NULL } },\n\n    { SMBwriteX, \"SMBwriteX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nHandle=[d]\\nOffset=[D]\\nTimeOut=[D]\\nWMode=[w]\\nCountLeft=[d]\\nRes=[w]\\nDataSize=[d]\\nDataOff=[d]\\n\",\n\t  NULL,\n\t  \"Com2=[w]\\nOff2=[d]\\nCount=[d]\\nRemaining=[d]\\nRes=[W]\\n\",\n\t  NULL, NULL } },\n\n    { SMBffirst, \"SMBffirst\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBfunique, \"SMBfunique\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBfclose, \"SMBfclose\", 0,\n\t{ \"Count=[d]\\nAttrib=[A]\\n\",\n\t  \"Path=[Z]\\nBlkType=[B]\\nBlkLen=[d]\\n|Res1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\n\",\n\t  \"Count=[d]\\n\",\n\t  \"BlkType=[B]\\nBlkLen=[d]\\n*\\nRes1=[B]\\nMask=[s11]\\nSrv1=[B]\\nDirIndex=[d]\\nSrv2=[w]\\nRes2=[W]\\nAttrib=[a]\\nTime=[T1]Size=[D]\\nName=[s13]\\n\",\n\t  NULL } },\n\n    { SMBfindnclose, \"SMBfindnclose\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBfindclose, \"SMBfindclose\", 0,\n\t{ \"Handle=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsends, \"SMBsends\", 0,\n\t{ NULL, \"Source=[Z]\\nDest=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBsendstrt, \"SMBsendstrt\", 0,\n\t{ NULL, \"Source=[Z]\\nDest=[Z]\\n\", \"GroupID=[d]\\n\", NULL, NULL } },\n\n    { SMBsendend, \"SMBsendend\", 0,\n\t{ \"GroupID=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsendtxt, \"SMBsendtxt\", 0,\n\t{ \"GroupID=[d]\\n\", NULL, NULL, NULL, NULL } },\n\n    { SMBsendb, \"SMBsendb\", 0,\n\t{ NULL, \"Source=[Z]\\nDest=[Z]\\n\", NULL, NULL, NULL } },\n\n    { SMBfwdname, \"SMBfwdname\", 0, DEFDESCRIPT },\n    { SMBcancelf, \"SMBcancelf\", 0, DEFDESCRIPT },\n    { SMBgetmac, \"SMBgetmac\", 0, DEFDESCRIPT },\n\n    { SMBnegprot, \"SMBnegprot\", 0,\n\t{ NULL, NULL, NULL, NULL, print_negprot } },\n\n    { SMBsesssetupX, \"SMBsesssetupX\", FLG_CHAIN,\n\t{ NULL, NULL, NULL, NULL, print_sesssetup } },\n\n    { SMBtconX, \"SMBtconX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nFlags=[w]\\nPassLen=[d]\\nPasswd&Path&Device=\\n\",\n\t  NULL, \"Com2=[w]\\nOff2=[d]\\n\", \"ServiceType=[R]\\n\", NULL } },\n\n    { SMBlockingX, \"SMBlockingX\", FLG_CHAIN,\n\t{ NULL, NULL, NULL, NULL, print_lockingandx } },\n\n    { SMBtrans2, \"SMBtrans2\", 0, { NULL, NULL, NULL, NULL, print_trans2 } },\n\n    { SMBtranss2, \"SMBtranss2\", 0, DEFDESCRIPT },\n    { SMBctemp, \"SMBctemp\", 0, DEFDESCRIPT },\n    { SMBreadBs, \"SMBreadBs\", 0, DEFDESCRIPT },\n    { SMBtrans, \"SMBtrans\", 0, { NULL, NULL, NULL, NULL, print_trans } },\n\n    { SMBnttrans, \"SMBnttrans\", 0, DEFDESCRIPT },\n    { SMBnttranss, \"SMBnttranss\", 0, DEFDESCRIPT },\n\n    { SMBntcreateX, \"SMBntcreateX\", FLG_CHAIN,\n\t{ \"Com2=[w]\\nOff2=[d]\\nRes=[b]\\nNameLen=[ld]\\nFlags=[W]\\nRootDirectoryFid=[D]\\nAccessMask=[W]\\nAllocationSize=[L]\\nExtFileAttributes=[W]\\nShareAccess=[W]\\nCreateDisposition=[W]\\nCreateOptions=[W]\\nImpersonationLevel=[W]\\nSecurityFlags=[b]\\n\",\n\t  \"Path=[C]\\n\",\n\t  \"Com2=[w]\\nOff2=[d]\\nOplockLevel=[b]\\nFid=[d]\\nCreateAction=[W]\\nCreateTime=[T3]LastAccessTime=[T3]LastWriteTime=[T3]ChangeTime=[T3]ExtFileAttributes=[W]\\nAllocationSize=[L]\\nEndOfFile=[L]\\nFileType=[w]\\nDeviceState=[w]\\nDirectory=[b]\\n\",\n\t  NULL, NULL } },\n\n    { SMBntcancel, \"SMBntcancel\", 0, DEFDESCRIPT },\n\n    { -1, NULL, 0, DEFDESCRIPT }\n};\n\n\n/*\n * print a SMB message\n */\nstatic void\nprint_smb(netdissect_options *ndo,\n          const u_char *buf, const u_char *maxbuf)\n{\n    uint16_t flags2;\n    int nterrcodes;\n    int command;\n    uint32_t nterror;\n    const u_char *words, *maxwords, *data;\n    const struct smbfns *fn;\n    const char *fmt_smbheader =\n        \"[P4]SMB Command   =  [B]\\nError class   =  [BP1]\\nError code    =  [d]\\nFlags1        =  [B]\\nFlags2        =  [B][P13]\\nTree ID       =  [d]\\nProc ID       =  [d]\\nUID           =  [d]\\nMID           =  [d]\\nWord Count    =  [b]\\n\";\n    int smboffset;\n\n    ND_TCHECK(buf[9]);\n    request = (buf[9] & 0x80) ? 0 : 1;\n    startbuf = buf;\n\n    command = buf[4];\n\n    fn = smbfind(command, smb_fns);\n\n    if (ndo->ndo_vflag > 1)\n\tND_PRINT((ndo, \"\\n\"));\n\n    ND_PRINT((ndo, \"SMB PACKET: %s (%s)\\n\", fn->name, request ? \"REQUEST\" : \"REPLY\"));\n\n    if (ndo->ndo_vflag < 2)\n\treturn;\n\n    ND_TCHECK_16BITS(&buf[10]);\n    flags2 = EXTRACT_LE_16BITS(&buf[10]);\n    unicodestr = flags2 & 0x8000;\n    nterrcodes = flags2 & 0x4000;\n\n    /* print out the header */\n    smb_fdata(ndo, buf, fmt_smbheader, buf + 33, unicodestr);\n\n    if (nterrcodes) {\n    \tnterror = EXTRACT_LE_32BITS(&buf[5]);\n\tif (nterror)\n\t    ND_PRINT((ndo, \"NTError = %s\\n\", nt_errstr(nterror)));\n    } else {\n\tif (buf[5])\n\t    ND_PRINT((ndo, \"SMBError = %s\\n\", smb_errstr(buf[5], EXTRACT_LE_16BITS(&buf[7]))));\n    }\n\n    smboffset = 32;\n\n    for (;;) {\n\tconst char *f1, *f2;\n\tint wct;\n\tu_int bcc;\n\tint newsmboffset;\n\n\twords = buf + smboffset;\n\tND_TCHECK(words[0]);\n\twct = words[0];\n\tdata = words + 1 + wct * 2;\n\tmaxwords = min(data, maxbuf);\n\n\tif (request) {\n\t    f1 = fn->descript.req_f1;\n\t    f2 = fn->descript.req_f2;\n\t} else {\n\t    f1 = fn->descript.rep_f1;\n\t    f2 = fn->descript.rep_f2;\n\t}\n\n\tif (fn->descript.fn)\n\t    (*fn->descript.fn)(ndo, words, data, buf, maxbuf);\n\telse {\n\t    if (wct) {\n\t\tif (f1)\n\t\t    smb_fdata(ndo, words + 1, f1, words + 1 + wct * 2, unicodestr);\n\t\telse {\n\t\t    int i;\n\t\t    int v;\n\n\t\t    for (i = 0; &words[1 + 2 * i] < maxwords; i++) {\n\t\t\tND_TCHECK2(words[1 + 2 * i], 2);\n\t\t\tv = EXTRACT_LE_16BITS(words + 1 + 2 * i);\n\t\t\tND_PRINT((ndo, \"smb_vwv[%d]=%d (0x%X)\\n\", i, v, v));\n\t\t    }\n\t\t}\n\t    }\n\n\t    ND_TCHECK2(*data, 2);\n\t    bcc = EXTRACT_LE_16BITS(data);\n\t    ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n\t    if (f2) {\n\t\tif (bcc > 0)\n\t\t    smb_fdata(ndo, data + 2, f2, data + 2 + bcc, unicodestr);\n\t    } else {\n\t\tif (bcc > 0) {\n\t\t    ND_PRINT((ndo, \"smb_buf[]=\\n\"));\n\t\t    smb_print_data(ndo, data + 2, min(bcc, PTR_DIFF(maxbuf, data + 2)));\n\t\t}\n\t    }\n\t}\n\n\tif ((fn->flags & FLG_CHAIN) == 0)\n\t    break;\n\tif (wct == 0)\n\t    break;\n\tND_TCHECK(words[1]);\n\tcommand = words[1];\n\tif (command == 0xFF)\n\t    break;\n\tND_TCHECK2(words[3], 2);\n\tnewsmboffset = EXTRACT_LE_16BITS(words + 3);\n\n\tfn = smbfind(command, smb_fns);\n\n\tND_PRINT((ndo, \"\\nSMB PACKET: %s (%s) (CHAINED)\\n\",\n\t    fn->name, request ? \"REQUEST\" : \"REPLY\"));\n\tif (newsmboffset <= smboffset) {\n\t    ND_PRINT((ndo, \"Bad andX offset: %u <= %u\\n\", newsmboffset, smboffset));\n\t    break;\n\t}\n\tsmboffset = newsmboffset;\n    }\n\n    ND_PRINT((ndo, \"\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\n/*\n * print a NBT packet received across tcp on port 139\n */\nvoid\nnbt_tcp_print(netdissect_options *ndo,\n              const u_char *data, int length)\n{\n    int caplen;\n    int type;\n    u_int nbt_len;\n    const u_char *maxbuf;\n\n    if (length < 4)\n\tgoto trunc;\n    if (ndo->ndo_snapend < data)\n\tgoto trunc;\n    caplen = ndo->ndo_snapend - data;\n    if (caplen < 4)\n\tgoto trunc;\n    maxbuf = data + caplen;\n    ND_TCHECK_8BITS(data);\n    type = data[0];\n    ND_TCHECK_16BITS(data + 2);\n    nbt_len = EXTRACT_16BITS(data + 2);\n    length -= 4;\n    caplen -= 4;\n\n    startbuf = data;\n\n    if (ndo->ndo_vflag < 2) {\n\tND_PRINT((ndo, \" NBT Session Packet: \"));\n\tswitch (type) {\n\tcase 0x00:\n\t    ND_PRINT((ndo, \"Session Message\"));\n\t    break;\n\n\tcase 0x81:\n\t    ND_PRINT((ndo, \"Session Request\"));\n\t    break;\n\n\tcase 0x82:\n\t    ND_PRINT((ndo, \"Session Granted\"));\n\t    break;\n\n\tcase 0x83:\n\t  {\n\t    int ecode;\n\n\t    if (nbt_len < 4)\n\t\tgoto trunc;\n\t    if (length < 4)\n\t\tgoto trunc;\n\t    if (caplen < 4)\n\t\tgoto trunc;\n\t    ecode = data[4];\n\n\t    ND_PRINT((ndo, \"Session Reject, \"));\n\t    switch (ecode) {\n\t    case 0x80:\n\t\tND_PRINT((ndo, \"Not listening on called name\"));\n\t\tbreak;\n\t    case 0x81:\n\t\tND_PRINT((ndo, \"Not listening for calling name\"));\n\t\tbreak;\n\t    case 0x82:\n\t\tND_PRINT((ndo, \"Called name not present\"));\n\t\tbreak;\n\t    case 0x83:\n\t\tND_PRINT((ndo, \"Called name present, but insufficient resources\"));\n\t\tbreak;\n\t    default:\n\t\tND_PRINT((ndo, \"Unspecified error 0x%X\", ecode));\n\t\tbreak;\n\t    }\n\t  }\n\t    break;\n\n\tcase 0x85:\n\t    ND_PRINT((ndo, \"Session Keepalive\"));\n\t    break;\n\n\tdefault:\n\t    data = smb_fdata(ndo, data, \"Unknown packet type [rB]\", maxbuf, 0);\n\t    break;\n\t}\n    } else {\n\tND_PRINT((ndo, \"\\n>>> NBT Session Packet\\n\"));\n\tswitch (type) {\n\tcase 0x00:\n\t    data = smb_fdata(ndo, data, \"[P1]NBT Session Message\\nFlags=[B]\\nLength=[rd]\\n\",\n\t\tdata + 4, 0);\n\t    if (data == NULL)\n\t\tbreak;\n\t    if (nbt_len >= 4 && caplen >= 4 && memcmp(data,\"\\377SMB\",4) == 0) {\n\t\tif ((int)nbt_len > caplen) {\n\t\t    if ((int)nbt_len > length)\n\t\t\tND_PRINT((ndo, \"WARNING: Packet is continued in later TCP segments\\n\"));\n\t\t    else\n\t\t\tND_PRINT((ndo, \"WARNING: Short packet. Try increasing the snap length by %d\\n\",\n\t\t\t    nbt_len - caplen));\n\t\t}\n\t\tprint_smb(ndo, data, maxbuf > data + nbt_len ? data + nbt_len : maxbuf);\n\t    } else\n\t\tND_PRINT((ndo, \"Session packet:(raw data or continuation?)\\n\"));\n\t    break;\n\n\tcase 0x81:\n\t    data = smb_fdata(ndo, data,\n\t\t\"[P1]NBT Session Request\\nFlags=[B]\\nLength=[rd]\\nDestination=[n1]\\nSource=[n1]\\n\",\n\t\tmaxbuf, 0);\n\t    break;\n\n\tcase 0x82:\n\t    data = smb_fdata(ndo, data, \"[P1]NBT Session Granted\\nFlags=[B]\\nLength=[rd]\\n\", maxbuf, 0);\n\t    break;\n\n\tcase 0x83:\n\t  {\n\t    const u_char *origdata;\n\t    int ecode;\n\n\t    origdata = data;\n\t    data = smb_fdata(ndo, data, \"[P1]NBT SessionReject\\nFlags=[B]\\nLength=[rd]\\nReason=[B]\\n\",\n\t\tmaxbuf, 0);\n\t    if (data == NULL)\n\t\tbreak;\n\t    if (nbt_len >= 1 && caplen >= 1) {\n\t\tecode = origdata[4];\n\t\tswitch (ecode) {\n\t\tcase 0x80:\n\t\t    ND_PRINT((ndo, \"Not listening on called name\\n\"));\n\t\t    break;\n\t\tcase 0x81:\n\t\t    ND_PRINT((ndo, \"Not listening for calling name\\n\"));\n\t\t    break;\n\t\tcase 0x82:\n\t\t    ND_PRINT((ndo, \"Called name not present\\n\"));\n\t\t    break;\n\t\tcase 0x83:\n\t\t    ND_PRINT((ndo, \"Called name present, but insufficient resources\\n\"));\n\t\t    break;\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \"Unspecified error 0x%X\\n\", ecode));\n\t\t    break;\n\t\t}\n\t    }\n\t  }\n\t    break;\n\n\tcase 0x85:\n\t    data = smb_fdata(ndo, data, \"[P1]NBT Session Keepalive\\nFlags=[B]\\nLength=[rd]\\n\", maxbuf, 0);\n\t    break;\n\n\tdefault:\n\t    data = smb_fdata(ndo, data, \"NBT - Unknown packet type\\nType=[B]\\n\", maxbuf, 0);\n\t    break;\n\t}\n\tND_PRINT((ndo, \"\\n\"));\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic const struct tok opcode_str[] = {\n\t{ 0,  \"QUERY\"                   },\n\t{ 5,  \"REGISTRATION\"            },\n\t{ 6,  \"RELEASE\"                 },\n\t{ 7,  \"WACK\"                    },\n\t{ 8,  \"REFRESH(8)\"              },\n\t{ 9,  \"REFRESH\"                 },\n\t{ 15, \"MULTIHOMED REGISTRATION\" },\n\t{ 0, NULL }\n};\n\n/*\n * print a NBT packet received across udp on port 137\n */\nvoid\nnbt_udp137_print(netdissect_options *ndo,\n                 const u_char *data, int length)\n{\n    const u_char *maxbuf = data + length;\n    int name_trn_id, response, opcode, nm_flags, rcode;\n    int qdcount, ancount, nscount, arcount;\n    const u_char *p;\n    int total, i;\n\n    ND_TCHECK2(data[10], 2);\n    name_trn_id = EXTRACT_16BITS(data);\n    response = (data[2] >> 7);\n    opcode = (data[2] >> 3) & 0xF;\n    nm_flags = ((data[2] & 0x7) << 4) + (data[3] >> 4);\n    rcode = data[3] & 0xF;\n    qdcount = EXTRACT_16BITS(data + 4);\n    ancount = EXTRACT_16BITS(data + 6);\n    nscount = EXTRACT_16BITS(data + 8);\n    arcount = EXTRACT_16BITS(data + 10);\n    startbuf = data;\n\n    if (maxbuf <= data)\n\treturn;\n\n    if (ndo->ndo_vflag > 1)\n\tND_PRINT((ndo, \"\\n>>> \"));\n\n    ND_PRINT((ndo, \"NBT UDP PACKET(137): %s\", tok2str(opcode_str, \"OPUNKNOWN\", opcode)));\n    if (response) {\n        ND_PRINT((ndo, \"; %s\", rcode ? \"NEGATIVE\" : \"POSITIVE\"));\n    }\n    ND_PRINT((ndo, \"; %s; %s\", response ? \"RESPONSE\" : \"REQUEST\",\n              (nm_flags & 1) ? \"BROADCAST\" : \"UNICAST\"));\n\n    if (ndo->ndo_vflag < 2)\n\treturn;\n\n    ND_PRINT((ndo, \"\\nTrnID=0x%X\\nOpCode=%d\\nNmFlags=0x%X\\nRcode=%d\\nQueryCount=%d\\nAnswerCount=%d\\nAuthorityCount=%d\\nAddressRecCount=%d\\n\",\n\tname_trn_id, opcode, nm_flags, rcode, qdcount, ancount, nscount,\n\tarcount));\n\n    p = data + 12;\n\n    total = ancount + nscount + arcount;\n\n    if (qdcount > 100 || total > 100) {\n\tND_PRINT((ndo, \"Corrupt packet??\\n\"));\n\treturn;\n    }\n\n    if (qdcount) {\n\tND_PRINT((ndo, \"QuestionRecords:\\n\"));\n\tfor (i = 0; i < qdcount; i++) {\n\t    p = smb_fdata(ndo, p,\n\t\t\"|Name=[n1]\\nQuestionType=[rw]\\nQuestionClass=[rw]\\n#\",\n\t\tmaxbuf, 0);\n\t    if (p == NULL)\n\t\tgoto out;\n\t}\n    }\n\n    if (total) {\n\tND_PRINT((ndo, \"\\nResourceRecords:\\n\"));\n\tfor (i = 0; i < total; i++) {\n\t    int rdlen;\n\t    int restype;\n\n\t    p = smb_fdata(ndo, p, \"Name=[n1]\\n#\", maxbuf, 0);\n\t    if (p == NULL)\n\t\tgoto out;\n\t    ND_TCHECK_16BITS(p);\n\t    restype = EXTRACT_16BITS(p);\n\t    p = smb_fdata(ndo, p, \"ResType=[rw]\\nResClass=[rw]\\nTTL=[rD]\\n\", p + 8, 0);\n\t    if (p == NULL)\n\t\tgoto out;\n\t    ND_TCHECK_16BITS(p);\n\t    rdlen = EXTRACT_16BITS(p);\n\t    ND_PRINT((ndo, \"ResourceLength=%d\\nResourceData=\\n\", rdlen));\n\t    p += 2;\n\t    if (rdlen == 6) {\n\t\tp = smb_fdata(ndo, p, \"AddrType=[rw]\\nAddress=[b.b.b.b]\\n\", p + rdlen, 0);\n\t\tif (p == NULL)\n\t\t    goto out;\n\t    } else {\n\t\tif (restype == 0x21) {\n\t\t    int numnames;\n\n\t\t    ND_TCHECK(*p);\n\t\t    numnames = p[0];\n\t\t    p = smb_fdata(ndo, p, \"NumNames=[B]\\n\", p + 1, 0);\n\t\t    if (p == NULL)\n\t\t\tgoto out;\n\t\t    while (numnames--) {\n\t\t\tp = smb_fdata(ndo, p, \"Name=[n2]\\t#\", maxbuf, 0);\n\t\t\tif (p == NULL)\n\t\t\t    goto out;\n\t\t\tND_TCHECK(*p);\n\t\t\tif (p[0] & 0x80)\n\t\t\t    ND_PRINT((ndo, \"<GROUP> \"));\n\t\t\tswitch (p[0] & 0x60) {\n\t\t\tcase 0x00: ND_PRINT((ndo, \"B \")); break;\n\t\t\tcase 0x20: ND_PRINT((ndo, \"P \")); break;\n\t\t\tcase 0x40: ND_PRINT((ndo, \"M \")); break;\n\t\t\tcase 0x60: ND_PRINT((ndo, \"_ \")); break;\n\t\t\t}\n\t\t\tif (p[0] & 0x10)\n\t\t\t    ND_PRINT((ndo, \"<DEREGISTERING> \"));\n\t\t\tif (p[0] & 0x08)\n\t\t\t    ND_PRINT((ndo, \"<CONFLICT> \"));\n\t\t\tif (p[0] & 0x04)\n\t\t\t    ND_PRINT((ndo, \"<ACTIVE> \"));\n\t\t\tif (p[0] & 0x02)\n\t\t\t    ND_PRINT((ndo, \"<PERMANENT> \"));\n\t\t\tND_PRINT((ndo, \"\\n\"));\n\t\t\tp += 2;\n\t\t    }\n\t\t} else {\n\t\t    smb_print_data(ndo, p, min(rdlen, length - (p - data)));\n\t\t    p += rdlen;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (p < maxbuf)\n\tsmb_fdata(ndo, p, \"AdditionalData:\\n\", maxbuf, 0);\n\nout:\n    ND_PRINT((ndo, \"\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n/*\n * Print an SMB-over-TCP packet received across tcp on port 445\n */\nvoid\nsmb_tcp_print(netdissect_options *ndo,\n              const u_char * data, int length)\n{\n    int caplen;\n    u_int smb_len;\n    const u_char *maxbuf;\n\n    if (length < 4)\n\tgoto trunc;\n    if (ndo->ndo_snapend < data)\n\tgoto trunc;\n    caplen = ndo->ndo_snapend - data;\n    if (caplen < 4)\n\tgoto trunc;\n    maxbuf = data + caplen;\n    smb_len = EXTRACT_24BITS(data + 1);\n    length -= 4;\n    caplen -= 4;\n\n    startbuf = data;\n    data += 4;\n\n    if (smb_len >= 4 && caplen >= 4 && memcmp(data,\"\\377SMB\",4) == 0) {\n\tif ((int)smb_len > caplen) {\n\t    if ((int)smb_len > length)\n\t\tND_PRINT((ndo, \" WARNING: Packet is continued in later TCP segments\\n\"));\n\t    else\n\t\tND_PRINT((ndo, \" WARNING: Short packet. Try increasing the snap length by %d\\n\",\n\t\t    smb_len - caplen));\n\t} else\n\t    ND_PRINT((ndo, \" \"));\n\tprint_smb(ndo, data, maxbuf > data + smb_len ? data + smb_len : maxbuf);\n    } else\n\tND_PRINT((ndo, \" SMB-over-TCP packet:(raw data or continuation?)\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n/*\n * print a NBT packet received across udp on port 138\n */\nvoid\nnbt_udp138_print(netdissect_options *ndo,\n                 const u_char *data, int length)\n{\n    const u_char *maxbuf = data + length;\n\n    if (maxbuf > ndo->ndo_snapend)\n\tmaxbuf = ndo->ndo_snapend;\n    if (maxbuf <= data)\n\treturn;\n    startbuf = data;\n\n    if (ndo->ndo_vflag < 2) {\n\tND_PRINT((ndo, \"NBT UDP PACKET(138)\"));\n\treturn;\n    }\n\n    data = smb_fdata(ndo, data,\n\t\"\\n>>> NBT UDP PACKET(138) Res=[rw] ID=[rw] IP=[b.b.b.b] Port=[rd] Length=[rd] Res2=[rw]\\nSourceName=[n1]\\nDestName=[n1]\\n#\",\n\tmaxbuf, 0);\n\n    if (data != NULL) {\n\t/* If there isn't enough data for \"\\377SMB\", don't check for it. */\n\tif (&data[3] >= maxbuf)\n\t    goto out;\n\n\tif (memcmp(data, \"\\377SMB\",4) == 0)\n\t    print_smb(ndo, data, maxbuf);\n    }\nout:\n    ND_PRINT((ndo, \"\\n\"));\n}\n\n\n/*\n   print netbeui frames\n*/\nstatic struct nbf_strings {\n\tconst char\t*name;\n\tconst char\t*nonverbose;\n\tconst char\t*verbose;\n} nbf_strings[0x20] = {\n\t{ \"Add Group Name Query\", \", [P23]Name to add=[n2]#\",\n\t  \"[P5]ResponseCorrelator=[w]\\n[P16]Name to add=[n2]\\n\" },\n\t{ \"Add Name Query\", \", [P23]Name to add=[n2]#\",\n\t  \"[P5]ResponseCorrelator=[w]\\n[P16]Name to add=[n2]\\n\" },\n\t{ \"Name In Conflict\", NULL, NULL },\n\t{ \"Status Query\", NULL, NULL },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Terminate Trace\", NULL, NULL },\n\t{ \"Datagram\", NULL,\n\t  \"[P7]Destination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Broadcast Datagram\", NULL,\n\t  \"[P7]Destination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Name Query\", \", [P7]Name=[n2]#\",\n\t  \"[P1]SessionNumber=[B]\\nNameType=[B][P2]\\nResponseCorrelator=[w]\\nName=[n2]\\nName of sender=[n2]\\n\" },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Add Name Response\", \", [P1]GroupName=[w] [P4]Destination=[n2] Source=[n2]#\",\n\t  \"AddNameInProcess=[B]\\nGroupName=[w]\\nTransmitCorrelator=[w][P2]\\nDestination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Name Recognized\", NULL,\n\t  \"[P1]Data2=[w]\\nTransmitCorrelator=[w]\\nResponseCorelator=[w]\\nDestination=[n2]\\nSource=[n2]\\n\" },\n\t{ \"Status Response\", NULL, NULL },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Terminate Trace\", NULL, NULL },\n\t{ \"Data Ack\", NULL,\n\t  \"[P3]TransmitCorrelator=[w][P2]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Data First/Middle\", NULL,\n\t  \"Flags=[{RECEIVE_CONTINUE|NO_ACK||PIGGYBACK_ACK_INCLUDED|}]\\nResyncIndicator=[w][P2]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Data Only/Last\", NULL,\n\t  \"Flags=[{|NO_ACK|PIGGYBACK_ACK_ALLOWED|PIGGYBACK_ACK_INCLUDED|}]\\nResyncIndicator=[w][P2]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Session Confirm\", NULL,\n\t  \"Data1=[B]\\nData2=[w]\\nTransmitCorrelator=[w]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Session End\", NULL,\n\t  \"[P1]Data2=[w][P4]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Session Initialize\", NULL,\n\t  \"Data1=[B]\\nData2=[w]\\nTransmitCorrelator=[w]\\nResponseCorelator=[w]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"No Receive\", NULL,\n\t  \"Flags=[{|SEND_NO_ACK}]\\nDataBytesAccepted=[b][P4]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Receive Outstanding\", NULL,\n\t  \"[P1]DataBytesAccepted=[b][P4]\\nRemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ \"Receive Continue\", NULL,\n\t  \"[P2]TransmitCorrelator=[w]\\n[P2]RemoteSessionNumber=[B]\\nLocalSessionNumber=[B]\\n\" },\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ NULL, NULL, NULL },\t/* not used */\n\t{ \"Session Alive\", NULL, NULL }\n};\n\nvoid\nnetbeui_print(netdissect_options *ndo,\n              u_short control, const u_char *data, int length)\n{\n    const u_char *maxbuf = data + length;\n    int len;\n    int command;\n    const u_char *data2;\n    int is_truncated = 0;\n\n    if (maxbuf > ndo->ndo_snapend)\n\tmaxbuf = ndo->ndo_snapend;\n    ND_TCHECK(data[4]);\n    len = EXTRACT_LE_16BITS(data);\n    command = data[4];\n    data2 = data + len;\n    if (data2 >= maxbuf) {\n\tdata2 = maxbuf;\n\tis_truncated = 1;\n    }\n\n    startbuf = data;\n\n    if (ndo->ndo_vflag < 2) {\n\tND_PRINT((ndo, \"NBF Packet: \"));\n\tdata = smb_fdata(ndo, data, \"[P5]#\", maxbuf, 0);\n    } else {\n\tND_PRINT((ndo, \"\\n>>> NBF Packet\\nType=0x%X \", control));\n\tdata = smb_fdata(ndo, data, \"Length=[d] Signature=[w] Command=[B]\\n#\", maxbuf, 0);\n    }\n    if (data == NULL)\n\tgoto out;\n\n    if (command > 0x1f || nbf_strings[command].name == NULL) {\n\tif (ndo->ndo_vflag < 2)\n\t    data = smb_fdata(ndo, data, \"Unknown NBF Command#\", data2, 0);\n\telse\n\t    data = smb_fdata(ndo, data, \"Unknown NBF Command\\n\", data2, 0);\n    } else {\n\tif (ndo->ndo_vflag < 2) {\n\t    ND_PRINT((ndo, \"%s\", nbf_strings[command].name));\n\t    if (nbf_strings[command].nonverbose != NULL)\n\t\tdata = smb_fdata(ndo, data, nbf_strings[command].nonverbose, data2, 0);\n\t} else {\n\t    ND_PRINT((ndo, \"%s:\\n\", nbf_strings[command].name));\n\t    if (nbf_strings[command].verbose != NULL)\n\t\tdata = smb_fdata(ndo, data, nbf_strings[command].verbose, data2, 0);\n\t    else\n\t\tND_PRINT((ndo, \"\\n\"));\n\t}\n    }\n\n    if (ndo->ndo_vflag < 2)\n\treturn;\n\n    if (data == NULL)\n\tgoto out;\n\n    if (is_truncated) {\n\t/* data2 was past the end of the buffer */\n\tgoto out;\n    }\n\n    /* If this isn't a command that would contain an SMB message, quit. */\n    if (command != 0x08 && command != 0x09 && command != 0x15 &&\n        command != 0x16)\n\tgoto out;\n\n    /* If there isn't enough data for \"\\377SMB\", don't look for it. */\n    if (&data2[3] >= maxbuf)\n\tgoto out;\n\n    if (memcmp(data2, \"\\377SMB\",4) == 0)\n\tprint_smb(ndo, data2, maxbuf);\n    else {\n\tint i;\n\tfor (i = 0; i < 128; i++) {\n\t    if (&data2[i + 3] >= maxbuf)\n\t\tbreak;\n\t    if (memcmp(&data2[i], \"\\377SMB\", 4) == 0) {\n\t\tND_PRINT((ndo, \"found SMB packet at %d\\n\", i));\n\t\tprint_smb(ndo, &data2[i], maxbuf);\n\t\tbreak;\n\t    }\n\t}\n    }\n\nout:\n    ND_PRINT((ndo, \"\\n\"));\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n\n\n/*\n * print IPX-Netbios frames\n */\nvoid\nipx_netbios_print(netdissect_options *ndo,\n                  const u_char *data, u_int length)\n{\n    /*\n     * this is a hack till I work out how to parse the rest of the\n     * NetBIOS-over-IPX stuff\n     */\n    int i;\n    const u_char *maxbuf;\n\n    maxbuf = data + length;\n    /* Don't go past the end of the captured data in the packet. */\n    if (maxbuf > ndo->ndo_snapend)\n\tmaxbuf = ndo->ndo_snapend;\n    startbuf = data;\n    for (i = 0; i < 128; i++) {\n\tif (&data[i + 4] > maxbuf)\n\t    break;\n\tif (memcmp(&data[i], \"\\377SMB\", 4) == 0) {\n\t    smb_fdata(ndo, data, \"\\n>>> IPX transport \", &data[i], 0);\n\t    print_smb(ndo, &data[i], maxbuf);\n\t    ND_PRINT((ndo, \"\\n\"));\n\t    break;\n\t}\n    }\n    if (i == 128)\n\tsmb_fdata(ndo, data, \"\\n>>> Unknown IPX \", maxbuf, 0);\n}\n"], "filenames": ["print-smb.c"], "buggy_code_start_loc": [374], "buggy_code_end_loc": [383], "fixing_code_start_loc": [374], "fixing_code_end_loc": [389], "type": "CWE-125", "message": "The SMB parser in tcpdump before 4.9.3 has buffer over-reads in print-smb.c:print_trans() for \\MAILSLOT\\BROWSE and \\PIPE\\LANMAN.", "other": {"cve": {"id": "CVE-2018-16451", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-03T16:15:12.757", "lastModified": "2020-01-20T13:15:15.577", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The SMB parser in tcpdump before 4.9.3 has buffer over-reads in print-smb.c:print_trans() for \\MAILSLOT\\BROWSE and \\PIPE\\LANMAN."}, {"lang": "es", "value": "El analizador SMB en tcpdump versiones anteriores a 4.9.3, presenta lecturas excesivas del b\u00fafer en print-smb.c:print_trans() para \\MAILSLOT\\BROWSE y \\PIPE\\LANMAN."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.3", "matchCriteriaId": "CA59BD9C-6C0C-4584-A8CC-8C652E9D36AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.15.2", "matchCriteriaId": "F15588EA-D854-4694-97C6-53D9AA8B6F2D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00050.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00053.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2019/Dec/26", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/blob/tcpdump-4.9/CHANGES", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/96480ab95308cd9234b4f09b175ebf60e17792c6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/62XY42U6HY3H2APR5EHNWCZ7SAQNMMJN/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNYXF3IY2X65IOD422SA6EQUULSGW7FN/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R2UDPOSGVJQIYC33SQBXMDXHH4QDSDMU/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Dec/23", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Oct/28", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200120-0001/", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210788", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4252-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4252-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4547", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/96480ab95308cd9234b4f09b175ebf60e17792c6"}}