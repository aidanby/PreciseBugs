{"buggy_code": ["// Copyright 2021 The Gitea Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage typesniffer\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"code.gitea.io/gitea/modules/util\"\n)\n\n// Use at most this many bytes to determine Content Type.\nconst sniffLen = 1024\n\n// SvgMimeType MIME type of SVG images.\nconst SvgMimeType = \"image/svg+xml\"\n\nvar (\n\tsvgTagRegex      = regexp.MustCompile(`(?si)\\A\\s*(?:(<!--.*?-->|<!DOCTYPE\\s+svg([\\s:]+.*?>|>))\\s*)*<svg[\\s>\\/]`)\n\tsvgTagInXMLRegex = regexp.MustCompile(`(?si)\\A<\\?xml\\b.*?\\?>\\s*(?:(<!--.*?-->|<!DOCTYPE\\s+svg([\\s:]+.*?>|>))\\s*)*<svg[\\s>\\/]`)\n)\n\n// SniffedType contains information about a blobs type.\ntype SniffedType struct {\n\tcontentType string\n}\n\n// IsText etects if content format is plain text.\nfunc (ct SniffedType) IsText() bool {\n\treturn strings.Contains(ct.contentType, \"text/\")\n}\n\n// IsImage detects if data is an image format\nfunc (ct SniffedType) IsImage() bool {\n\treturn strings.Contains(ct.contentType, \"image/\")\n}\n\n// IsSvgImage detects if data is an SVG image format\nfunc (ct SniffedType) IsSvgImage() bool {\n\treturn strings.Contains(ct.contentType, SvgMimeType)\n}\n\n// IsPDF detects if data is a PDF format\nfunc (ct SniffedType) IsPDF() bool {\n\treturn strings.Contains(ct.contentType, \"application/pdf\")\n}\n\n// IsVideo detects if data is an video format\nfunc (ct SniffedType) IsVideo() bool {\n\treturn strings.Contains(ct.contentType, \"video/\")\n}\n\n// IsAudio detects if data is an video format\nfunc (ct SniffedType) IsAudio() bool {\n\treturn strings.Contains(ct.contentType, \"audio/\")\n}\n\n// IsRepresentableAsText returns true if file content can be represented as\n// plain text or is empty.\nfunc (ct SniffedType) IsRepresentableAsText() bool {\n\treturn ct.IsText() || ct.IsSvgImage()\n}\n\n// DetectContentType extends http.DetectContentType with more content types. Defaults to text/unknown if input is empty.\nfunc DetectContentType(data []byte) SniffedType {\n\tif len(data) == 0 {\n\t\treturn SniffedType{\"text/unknown\"}\n\t}\n\n\tct := http.DetectContentType(data)\n\n\tif len(data) > sniffLen {\n\t\tdata = data[:sniffLen]\n\t}\n\n\tif (strings.Contains(ct, \"text/plain\") || strings.Contains(ct, \"text/html\")) && svgTagRegex.Match(data) ||\n\t\tstrings.Contains(ct, \"text/xml\") && svgTagInXMLRegex.Match(data) {\n\t\t// SVG is unsupported. https://github.com/golang/go/issues/15888\n\t\tct = SvgMimeType\n\t}\n\n\treturn SniffedType{ct}\n}\n\n// DetectContentTypeFromReader guesses the content type contained in the reader.\nfunc DetectContentTypeFromReader(r io.Reader) (SniffedType, error) {\n\tbuf := make([]byte, sniffLen)\n\tn, err := util.ReadAtMost(r, buf)\n\tif err != nil {\n\t\treturn SniffedType{}, fmt.Errorf(\"DetectContentTypeFromReader io error: %w\", err)\n\t}\n\tbuf = buf[:n]\n\n\treturn DetectContentType(buf), nil\n}\n", "// Copyright 2021 The Gitea Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage common\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"code.gitea.io/gitea/modules/charset\"\n\t\"code.gitea.io/gitea/modules/context\"\n\t\"code.gitea.io/gitea/modules/git\"\n\t\"code.gitea.io/gitea/modules/httpcache\"\n\t\"code.gitea.io/gitea/modules/log\"\n\t\"code.gitea.io/gitea/modules/setting\"\n\t\"code.gitea.io/gitea/modules/typesniffer\"\n\t\"code.gitea.io/gitea/modules/util\"\n)\n\n// ServeBlob download a git.Blob\nfunc ServeBlob(ctx *context.Context, blob *git.Blob, lastModified time.Time) error {\n\tif httpcache.HandleGenericETagTimeCache(ctx.Req, ctx.Resp, `\"`+blob.ID.String()+`\"`, lastModified) {\n\t\treturn nil\n\t}\n\n\tdataRc, err := blob.DataAsync()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err = dataRc.Close(); err != nil {\n\t\t\tlog.Error(\"ServeBlob: Close: %v\", err)\n\t\t}\n\t}()\n\n\treturn ServeData(ctx, ctx.Repo.TreePath, blob.Size(), dataRc)\n}\n\n// ServeData download file from io.Reader\nfunc ServeData(ctx *context.Context, name string, size int64, reader io.Reader) error {\n\tbuf := make([]byte, 1024)\n\tn, err := util.ReadAtMost(reader, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n >= 0 {\n\t\tbuf = buf[:n]\n\t}\n\n\tctx.Resp.Header().Set(\"Cache-Control\", \"public,max-age=86400\")\n\n\tif size >= 0 {\n\t\tctx.Resp.Header().Set(\"Content-Length\", fmt.Sprintf(\"%d\", size))\n\t} else {\n\t\tlog.Error(\"ServeData called to serve data: %s with size < 0: %d\", name, size)\n\t}\n\tname = path.Base(name)\n\n\t// Google Chrome dislike commas in filenames, so let's change it to a space\n\tname = strings.ReplaceAll(name, \",\", \" \")\n\n\tst := typesniffer.DetectContentType(buf)\n\n\tmappedMimeType := \"\"\n\tif setting.MimeTypeMap.Enabled {\n\t\tfileExtension := strings.ToLower(filepath.Ext(name))\n\t\tmappedMimeType = setting.MimeTypeMap.Map[fileExtension]\n\t}\n\tif st.IsText() || ctx.FormBool(\"render\") {\n\t\tcs, err := charset.DetectEncoding(buf)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Detect raw file %s charset failed: %v, using by default utf-8\", name, err)\n\t\t\tcs = \"utf-8\"\n\t\t}\n\t\tif mappedMimeType == \"\" {\n\t\t\tmappedMimeType = \"text/plain\"\n\t\t}\n\t\tctx.Resp.Header().Set(\"Content-Type\", mappedMimeType+\"; charset=\"+strings.ToLower(cs))\n\t} else {\n\t\tctx.Resp.Header().Set(\"Access-Control-Expose-Headers\", \"Content-Disposition\")\n\t\tif mappedMimeType != \"\" {\n\t\t\tctx.Resp.Header().Set(\"Content-Type\", mappedMimeType)\n\t\t}\n\t\tif (st.IsImage() || st.IsPDF()) && (setting.UI.SVG.Enabled || !st.IsSvgImage()) {\n\t\t\tctx.Resp.Header().Set(\"Content-Disposition\", fmt.Sprintf(`inline; filename=\"%s\"`, name))\n\t\t\tif st.IsSvgImage() {\n\t\t\t\tctx.Resp.Header().Set(\"Content-Security-Policy\", \"default-src 'none'; style-src 'unsafe-inline'; sandbox\")\n\t\t\t\tctx.Resp.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\t\t\t\tctx.Resp.Header().Set(\"Content-Type\", typesniffer.SvgMimeType)\n\t\t\t}\n\t\t} else {\n\t\t\tctx.Resp.Header().Set(\"Content-Disposition\", fmt.Sprintf(`attachment; filename=\"%s\"`, name))\n\t\t}\n\t}\n\n\t_, err = ctx.Resp.Write(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = io.Copy(ctx.Resp, reader)\n\treturn err\n}\n"], "fixing_code": ["// Copyright 2021 The Gitea Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage typesniffer\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"code.gitea.io/gitea/modules/util\"\n)\n\n// Use at most this many bytes to determine Content Type.\nconst sniffLen = 1024\n\nconst (\n\t// SvgMimeType MIME type of SVG images.\n\tSvgMimeType = \"image/svg+xml\"\n\t// ApplicationOctetStream MIME type of binary files.\n\tApplicationOctetStream = \"application/octet-stream\"\n)\n\nvar (\n\tsvgTagRegex      = regexp.MustCompile(`(?si)\\A\\s*(?:(<!--.*?-->|<!DOCTYPE\\s+svg([\\s:]+.*?>|>))\\s*)*<svg[\\s>\\/]`)\n\tsvgTagInXMLRegex = regexp.MustCompile(`(?si)\\A<\\?xml\\b.*?\\?>\\s*(?:(<!--.*?-->|<!DOCTYPE\\s+svg([\\s:]+.*?>|>))\\s*)*<svg[\\s>\\/]`)\n)\n\n// SniffedType contains information about a blobs type.\ntype SniffedType struct {\n\tcontentType string\n}\n\n// IsText etects if content format is plain text.\nfunc (ct SniffedType) IsText() bool {\n\treturn strings.Contains(ct.contentType, \"text/\")\n}\n\n// IsImage detects if data is an image format\nfunc (ct SniffedType) IsImage() bool {\n\treturn strings.Contains(ct.contentType, \"image/\")\n}\n\n// IsSvgImage detects if data is an SVG image format\nfunc (ct SniffedType) IsSvgImage() bool {\n\treturn strings.Contains(ct.contentType, SvgMimeType)\n}\n\n// IsPDF detects if data is a PDF format\nfunc (ct SniffedType) IsPDF() bool {\n\treturn strings.Contains(ct.contentType, \"application/pdf\")\n}\n\n// IsVideo detects if data is an video format\nfunc (ct SniffedType) IsVideo() bool {\n\treturn strings.Contains(ct.contentType, \"video/\")\n}\n\n// IsAudio detects if data is an video format\nfunc (ct SniffedType) IsAudio() bool {\n\treturn strings.Contains(ct.contentType, \"audio/\")\n}\n\n// IsRepresentableAsText returns true if file content can be represented as\n// plain text or is empty.\nfunc (ct SniffedType) IsRepresentableAsText() bool {\n\treturn ct.IsText() || ct.IsSvgImage()\n}\n\n// DetectContentType extends http.DetectContentType with more content types. Defaults to text/unknown if input is empty.\nfunc DetectContentType(data []byte) SniffedType {\n\tif len(data) == 0 {\n\t\treturn SniffedType{\"text/unknown\"}\n\t}\n\n\tct := http.DetectContentType(data)\n\n\tif len(data) > sniffLen {\n\t\tdata = data[:sniffLen]\n\t}\n\n\tif (strings.Contains(ct, \"text/plain\") || strings.Contains(ct, \"text/html\")) && svgTagRegex.Match(data) ||\n\t\tstrings.Contains(ct, \"text/xml\") && svgTagInXMLRegex.Match(data) {\n\t\t// SVG is unsupported. https://github.com/golang/go/issues/15888\n\t\tct = SvgMimeType\n\t}\n\n\treturn SniffedType{ct}\n}\n\n// DetectContentTypeFromReader guesses the content type contained in the reader.\nfunc DetectContentTypeFromReader(r io.Reader) (SniffedType, error) {\n\tbuf := make([]byte, sniffLen)\n\tn, err := util.ReadAtMost(r, buf)\n\tif err != nil {\n\t\treturn SniffedType{}, fmt.Errorf(\"DetectContentTypeFromReader io error: %w\", err)\n\t}\n\tbuf = buf[:n]\n\n\treturn DetectContentType(buf), nil\n}\n", "// Copyright 2021 The Gitea Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage common\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"code.gitea.io/gitea/modules/charset\"\n\t\"code.gitea.io/gitea/modules/context\"\n\t\"code.gitea.io/gitea/modules/git\"\n\t\"code.gitea.io/gitea/modules/httpcache\"\n\t\"code.gitea.io/gitea/modules/log\"\n\t\"code.gitea.io/gitea/modules/setting\"\n\t\"code.gitea.io/gitea/modules/typesniffer\"\n\t\"code.gitea.io/gitea/modules/util\"\n)\n\n// ServeBlob download a git.Blob\nfunc ServeBlob(ctx *context.Context, blob *git.Blob, lastModified time.Time) error {\n\tif httpcache.HandleGenericETagTimeCache(ctx.Req, ctx.Resp, `\"`+blob.ID.String()+`\"`, lastModified) {\n\t\treturn nil\n\t}\n\n\tdataRc, err := blob.DataAsync()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err = dataRc.Close(); err != nil {\n\t\t\tlog.Error(\"ServeBlob: Close: %v\", err)\n\t\t}\n\t}()\n\n\treturn ServeData(ctx, ctx.Repo.TreePath, blob.Size(), dataRc)\n}\n\n// ServeData download file from io.Reader\nfunc ServeData(ctx *context.Context, name string, size int64, reader io.Reader) error {\n\tbuf := make([]byte, 1024)\n\tn, err := util.ReadAtMost(reader, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n >= 0 {\n\t\tbuf = buf[:n]\n\t}\n\n\tctx.Resp.Header().Set(\"Cache-Control\", \"public,max-age=86400\")\n\n\tif size >= 0 {\n\t\tctx.Resp.Header().Set(\"Content-Length\", fmt.Sprintf(\"%d\", size))\n\t} else {\n\t\tlog.Error(\"ServeData called to serve data: %s with size < 0: %d\", name, size)\n\t}\n\tname = path.Base(name)\n\n\t// Google Chrome dislike commas in filenames, so let's change it to a space\n\tname = strings.ReplaceAll(name, \",\", \" \")\n\n\tst := typesniffer.DetectContentType(buf)\n\n\tmappedMimeType := \"\"\n\tif setting.MimeTypeMap.Enabled {\n\t\tfileExtension := strings.ToLower(filepath.Ext(name))\n\t\tmappedMimeType = setting.MimeTypeMap.Map[fileExtension]\n\t}\n\tif st.IsText() || ctx.FormBool(\"render\") {\n\t\tcs, err := charset.DetectEncoding(buf)\n\t\tif err != nil {\n\t\t\tlog.Error(\"Detect raw file %s charset failed: %v, using by default utf-8\", name, err)\n\t\t\tcs = \"utf-8\"\n\t\t}\n\t\tif mappedMimeType == \"\" {\n\t\t\tmappedMimeType = \"text/plain\"\n\t\t}\n\t\tctx.Resp.Header().Set(\"Content-Type\", mappedMimeType+\"; charset=\"+strings.ToLower(cs))\n\t} else {\n\t\tctx.Resp.Header().Set(\"Access-Control-Expose-Headers\", \"Content-Disposition\")\n\t\tif mappedMimeType != \"\" {\n\t\t\tctx.Resp.Header().Set(\"Content-Type\", mappedMimeType)\n\t\t}\n\t\tif (st.IsImage() || st.IsPDF()) && (setting.UI.SVG.Enabled || !st.IsSvgImage()) {\n\t\t\tctx.Resp.Header().Set(\"Content-Disposition\", fmt.Sprintf(`inline; filename=\"%s\"`, name))\n\t\t\tif st.IsSvgImage() || st.IsPDF() {\n\t\t\t\tctx.Resp.Header().Set(\"Content-Security-Policy\", \"default-src 'none'; style-src 'unsafe-inline'; sandbox\")\n\t\t\t\tctx.Resp.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\t\t\t\tif st.IsSvgImage() {\n\t\t\t\t\tctx.Resp.Header().Set(\"Content-Type\", typesniffer.SvgMimeType)\n\t\t\t\t} else {\n\t\t\t\t\tctx.Resp.Header().Set(\"Content-Type\", typesniffer.ApplicationOctetStream)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tctx.Resp.Header().Set(\"Content-Disposition\", fmt.Sprintf(`attachment; filename=\"%s\"`, name))\n\t\t}\n\t}\n\n\t_, err = ctx.Resp.Write(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = io.Copy(ctx.Resp, reader)\n\treturn err\n}\n"], "filenames": ["modules/typesniffer/typesniffer.go", "routers/common/repo.go"], "buggy_code_start_loc": [20, 91], "buggy_code_end_loc": [22, 95], "fixing_code_start_loc": [20, 91], "fixing_code_end_loc": [26, 99], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository go-gitea/gitea prior to 1.16.9.", "other": {"cve": {"id": "CVE-2022-1928", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-29T14:15:08.213", "lastModified": "2022-11-16T19:57:28.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository go-gitea/gitea prior to 1.16.9."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Almacenado en el repositorio de GitHub go-gitea/gitea versiones anteriores a 1.16.9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitea:gitea:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.9", "matchCriteriaId": "C3579D3E-0B48-4B91-9CAE-17E492E4B702"}]}]}], "references": [{"url": "https://github.com/go-gitea/gitea/commit/65e0688a5c9dacad50e71024b7529fdf0e3c2e9c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6336ec42-5c4d-4f61-ae38-2bb539f433d2", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-14", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/go-gitea/gitea/commit/65e0688a5c9dacad50e71024b7529fdf0e3c2e9c"}}