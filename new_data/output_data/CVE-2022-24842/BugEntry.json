{"buggy_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sort\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/minio/madmin-go\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/config/dns\"\n\t\"github.com/minio/minio/internal/logger\"\n\tiampolicy \"github.com/minio/pkg/iam/policy\"\n)\n\n// RemoveUser - DELETE /minio/admin/v3/remove-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) RemoveUser(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"RemoveUser\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.DeleteUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\tok, _, err := globalIAMSys.IsTempUser(accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tif ok {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalIAMSys.DeleteUser(ctx, accessKey, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: true,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// ListBucketUsers - GET /minio/admin/v3/list-users?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListBucketUsers\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, iampolicy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListBucketUsers(bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// ListUsers - GET /minio/admin/v3/list-users\nfunc (a adminAPIHandlers) ListUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListUsers\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, iampolicy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListUsers()\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// GetUserInfo - GET /minio/admin/v3/user-info\nfunc (a adminAPIHandlers) GetUserInfo(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"GetUserInfo\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tvars := mux.Vars(r)\n\tname := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif name == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to view one's own info.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.GetUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tuserInfo, err := globalIAMSys.GetUserInfo(ctx, name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, data)\n}\n\n// UpdateGroupMembers - PUT /minio/admin/v3/update-group-members\nfunc (a adminAPIHandlers) UpdateGroupMembers(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"UpdateGroupMembers\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.AddUserToGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tdata, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tvar updReq madmin.GroupAddRemove\n\terr = json.Unmarshal(data, &updReq)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tif updReq.IsRemove {\n\t\terr = globalIAMSys.RemoveUsersFromGroup(ctx, updReq.Group, updReq.Members)\n\t} else {\n\t\terr = globalIAMSys.AddUsersToGroup(ctx, updReq.Group, updReq.Members)\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: updReq,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// GetGroup - /minio/admin/v3/group?group=mygroup1\nfunc (a adminAPIHandlers) GetGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"GetGroup\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.GetGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\n\tgdesc, err := globalIAMSys.GetGroupDescription(group)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(gdesc)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// ListGroups - GET /minio/admin/v3/groups\nfunc (a adminAPIHandlers) ListGroups(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListGroups\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ListGroupsAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tgroups, err := globalIAMSys.ListGroups(ctx)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(groups)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// SetGroupStatus - PUT /minio/admin/v3/set-group-status?group=mygroup1&status=enabled\nfunc (a adminAPIHandlers) SetGroupStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"SetGroupStatus\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.EnableGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\tstatus := vars[\"status\"]\n\n\tvar err error\n\tswitch status {\n\tcase statusEnabled:\n\t\terr = globalIAMSys.SetGroupStatus(ctx, group, true)\n\tcase statusDisabled:\n\t\terr = globalIAMSys.SetGroupStatus(ctx, group, false)\n\tdefault:\n\t\terr = errInvalidArgument\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: madmin.GroupAddRemove{\n\t\t\t\tGroup:    group,\n\t\t\t\tStatus:   madmin.GroupStatus(status),\n\t\t\t\tIsRemove: false,\n\t\t\t},\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// SetUserStatus - PUT /minio/admin/v3/set-user-status?accessKey=<access_key>&status=[enabled|disabled]\nfunc (a adminAPIHandlers) SetUserStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"SetUserStatus\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.EnableUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\tstatus := vars[\"status\"]\n\n\t// This API is not allowed to lookup master access key user status\n\tif accessKey == globalActiveCred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalIAMSys.SetUserStatus(ctx, accessKey, madmin.AccountStatus(status)); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq: &madmin.AddOrUpdateUserReq{\n\t\t\t\tStatus: madmin.AccountStatus(status),\n\t\t\t},\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// AddUser - PUT /minio/admin/v3/add-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) AddUser(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AddUser\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Not allowed to add a user with same access key as root credential\n\tif owner && accessKey == cred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tuserCred, exists := globalIAMSys.GetUser(ctx, accessKey)\n\tif exists && (userCred.IsTemp() || userCred.IsServiceAccount()) {\n\t\t// Updating STS credential is not allowed, and this API does not\n\t\t// support updating service accounts.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n\t\t// Incoming access key matches parent user then we should\n\t\t// reject password change requests.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif accessKey == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to change one's own password.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.CreateUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tif r.ContentLength > maxEConfigJSONSize || r.ContentLength == -1 {\n\t\t// More than maxConfigSize bytes were available\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\tconfigBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tvar ureq madmin.AddOrUpdateUserReq\n\tif err = json.Unmarshal(configBytes, &ureq); err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tif err = globalIAMSys.CreateUser(ctx, accessKey, ureq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq:     &ureq,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// AddServiceAccount - PUT /minio/admin/v3/add-service-account\nfunc (a adminAPIHandlers) AddServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AddServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar createReq madmin.AddServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &createReq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar (\n\t\ttargetUser   string\n\t\ttargetGroups []string\n\t)\n\n\t// If the request did not set a TargetUser, the service account is\n\t// created for the request sender.\n\ttargetUser = createReq.TargetUser\n\tif targetUser == \"\" {\n\t\ttargetUser = cred.AccessKey\n\t}\n\n\topts := newServiceAccountOpts{\n\t\taccessKey: createReq.AccessKey,\n\t\tsecretKey: createReq.SecretKey,\n\t\tclaims:    make(map[string]interface{}),\n\t}\n\n\t// Find the user for the request sender (as it may be sent via a service\n\t// account or STS account):\n\trequestorUser := cred.AccessKey\n\trequestorParentUser := cred.AccessKey\n\trequestorGroups := cred.Groups\n\trequestorIsDerivedCredential := false\n\tif cred.IsServiceAccount() || cred.IsTemp() {\n\t\trequestorParentUser = cred.ParentUser\n\t\trequestorIsDerivedCredential = true\n\t}\n\n\t// Check if we are creating svc account for request sender.\n\tisSvcAccForRequestor := false\n\tif targetUser == requestorUser || targetUser == requestorParentUser {\n\t\tisSvcAccForRequestor = true\n\t}\n\n\t// If we are creating svc account for request sender, ensure\n\t// that targetUser is a real user (i.e. not derived\n\t// credentials).\n\tif isSvcAccForRequestor {\n\t\t// Check if adding service account is explicitly denied.\n\t\t//\n\t\t// This allows turning off service accounts for request sender,\n\t\t// if there is no deny statement this call is implicitly enabled.\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     requestorUser,\n\t\t\tGroups:          requestorGroups,\n\t\t\tAction:          iampolicy.CreateServiceAccountAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t\tDenyOnly:        true,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\n\t\tif requestorIsDerivedCredential {\n\t\t\tif requestorParentUser == \"\" {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx,\n\t\t\t\t\terrors.New(\"service accounts cannot be generated for temporary credentials without parent\")), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttargetUser = requestorParentUser\n\t\t}\n\t\ttargetGroups = requestorGroups\n\n\t\t// In case of LDAP/OIDC we need to set `opts.claims` to ensure\n\t\t// it is associated with the LDAP/OIDC user properly.\n\t\tfor k, v := range cred.Claims {\n\t\t\tif k == expClaim {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\topts.claims[k] = v\n\t\t}\n\t} else {\n\t\t// Need permission if we are creating a service acccount for a\n\t\t// user <> to the request sender\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     requestorUser,\n\t\t\tGroups:          requestorGroups,\n\t\t\tAction:          iampolicy.CreateServiceAccountAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t\tDenyOnly:        true,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\n\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n\t\t// query their groups:\n\t\tif globalLDAPConfig.Enabled {\n\t\t\topts.claims[ldapUserN] = targetUser // simple username\n\t\t\ttargetUser, targetGroups, err = globalLDAPConfig.LookupUserDN(targetUser)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.claims[ldapUser] = targetUser // username DN\n\t\t}\n\n\t\t// NOTE: if not using LDAP, then internal IDP or open ID is\n\t\t// being used - in the former, group info is enforced when\n\t\t// generated credentials are used to make requests, and in the\n\t\t// latter, a group notion is not supported.\n\t}\n\n\tvar sp *iampolicy.Policy\n\tif len(createReq.Policy) > 0 {\n\t\tsp, err = iampolicy.ParseConfig(bytes.NewReader(createReq.Policy))\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\topts.sessionPolicy = sp\n\tnewCred, err := globalIAMSys.NewServiceAccount(ctx, targetUser, targetGroups, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call hook for cluster-replication if the service account is not for a\n\t// root user.\n\tif newCred.ParentUser != globalActiveCred.AccessKey {\n\t\terr = globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tCreate: &madmin.SRSvcAccCreate{\n\t\t\t\t\tParent:        newCred.ParentUser,\n\t\t\t\t\tAccessKey:     newCred.AccessKey,\n\t\t\t\t\tSecretKey:     newCred.SecretKey,\n\t\t\t\t\tGroups:        newCred.Groups,\n\t\t\t\t\tClaims:        opts.claims,\n\t\t\t\t\tSessionPolicy: createReq.Policy,\n\t\t\t\t\tStatus:        auth.AccountOn,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tcreateResp := madmin.AddServiceAccountResp{\n\t\tCredentials: madmin.Credentials{\n\t\t\tAccessKey: newCred.AccessKey,\n\t\t\tSecretKey: newCred.SecretKey,\n\t\t},\n\t}\n\n\tdata, err := json.Marshal(createResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// UpdateServiceAccount - POST /minio/admin/v3/update-service-account\nfunc (a adminAPIHandlers) UpdateServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"UpdateServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.UpdateServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar updateReq madmin.UpdateServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &updateReq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar sp *iampolicy.Policy\n\tif len(updateReq.NewPolicy) > 0 {\n\t\tsp, err = iampolicy.ParseConfig(bytes.NewReader(updateReq.NewPolicy))\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\topts := updateServiceAccountOpts{\n\t\tsecretKey:     updateReq.NewSecretKey,\n\t\tstatus:        updateReq.NewStatus,\n\t\tsessionPolicy: sp,\n\t}\n\terr = globalIAMSys.UpdateServiceAccount(ctx, accessKey, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\terr = globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tUpdate: &madmin.SRSvcAccUpdate{\n\t\t\t\t\tAccessKey:     accessKey,\n\t\t\t\t\tSecretKey:     opts.secretKey,\n\t\t\t\t\tStatus:        opts.status,\n\t\t\t\t\tSessionPolicy: updateReq.NewPolicy,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// InfoServiceAccount - GET /minio/admin/v3/info-service-account\nfunc (a adminAPIHandlers) InfoServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"InfoServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, policy, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.ListServiceAccountsAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar svcAccountPolicy iampolicy.Policy\n\n\tif policy != nil {\n\t\tsvcAccountPolicy = *policy\n\t} else {\n\t\tpoliciesNames, err := globalIAMSys.PolicyDBGet(svcAccount.ParentUser, false)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tsvcAccountPolicy = globalIAMSys.GetCombinedPolicy(policiesNames...)\n\t}\n\n\tpolicyJSON, err := json.MarshalIndent(svcAccountPolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tinfoResp := madmin.InfoServiceAccountResp{\n\t\tParentUser:    svcAccount.ParentUser,\n\t\tAccountStatus: svcAccount.Status,\n\t\tImpliedPolicy: policy == nil,\n\t\tPolicy:        string(policyJSON),\n\t}\n\n\tdata, err := json.Marshal(infoResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// ListServiceAccounts - GET /minio/admin/v3/list-service-accounts\nfunc (a adminAPIHandlers) ListServiceAccounts(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListServiceAccounts\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tvar targetAccount string\n\n\t// If listing is requested for a specific user (who is not the request\n\t// sender), check that the user has permissions.\n\tuser := r.Form.Get(\"user\")\n\tif user != \"\" && user != cred.AccessKey {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          iampolicy.ListServiceAccountsAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t\ttargetAccount = user\n\t} else {\n\t\ttargetAccount = cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\ttargetAccount = cred.ParentUser\n\t\t}\n\t}\n\n\tserviceAccounts, err := globalIAMSys.ListServiceAccounts(ctx, targetAccount)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar serviceAccountsNames []string\n\n\tfor _, svc := range serviceAccounts {\n\t\tserviceAccountsNames = append(serviceAccountsNames, svc.AccessKey)\n\t}\n\n\tlistResp := madmin.ListServiceAccountsResp{\n\t\tAccounts: serviceAccountsNames,\n\t}\n\n\tdata, err := json.Marshal(listResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// DeleteServiceAccount - DELETE /minio/admin/v3/delete-service-account\nfunc (a adminAPIHandlers) DeleteServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"DeleteServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tserviceAccount := mux.Vars(r)[\"accessKey\"]\n\tif serviceAccount == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, serviceAccount)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tadminPrivilege := globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.RemoveServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t})\n\n\tif !adminPrivilege {\n\t\tparentUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\tparentUser = cred.ParentUser\n\t\t}\n\t\tif parentUser != svcAccount.ParentUser {\n\t\t\t// The service account belongs to another user but return not\n\t\t\t// found error to mitigate brute force attacks. or the\n\t\t\t// serviceAccount doesn't exist.\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminServiceAccountNotFound), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = globalIAMSys.DeleteServiceAccount(ctx, serviceAccount, true)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\terr = globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tDelete: &madmin.SRSvcAccDelete{\n\t\t\t\t\tAccessKey: serviceAccount,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// AccountInfoHandler returns usage\nfunc (a adminAPIHandlers) AccountInfoHandler(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AccountInfo\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\tr.Header.Set(\"prefix\", \"\")\n\n\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t// Check if we are asked to return prefix usage\n\tenablePrefixUsage := r.Form.Get(\"prefix-usage\") == \"true\"\n\n\tisAllowedAccess := func(bucketName string) (rd, wr bool) {\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\trd = true\n\t\t}\n\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.PutObjectAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\twr = true\n\t\t}\n\n\t\treturn rd, wr\n\t}\n\n\tvar dataUsageInfo DataUsageInfo\n\tvar err error\n\tif !globalIsGateway {\n\t\t// Load the latest calculated data usage\n\t\tdataUsageInfo, _ = loadDataUsageFromBackend(ctx, objectAPI)\n\t}\n\n\t// If etcd, dns federation configured list buckets from etcd.\n\tvar buckets []BucketInfo\n\tif globalDNSConfig != nil && globalBucketFederation {\n\t\tdnsBuckets, err := globalDNSConfig.List()\n\t\tif err != nil && !IsErrIgnored(err,\n\t\t\tdns.ErrNoEntriesFound,\n\t\t\tdns.ErrDomainMissing) {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tfor _, dnsRecords := range dnsBuckets {\n\t\t\tbuckets = append(buckets, BucketInfo{\n\t\t\t\tName:    dnsRecords[0].Key,\n\t\t\t\tCreated: dnsRecords[0].CreationDate,\n\t\t\t})\n\t\t}\n\t\tsort.Slice(buckets, func(i, j int) bool {\n\t\t\treturn buckets[i].Name < buckets[j].Name\n\t\t})\n\t} else {\n\t\tbuckets, err = objectAPI.ListBuckets(ctx)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\taccountName := cred.AccessKey\n\tif cred.IsTemp() || cred.IsServiceAccount() {\n\t\t// For derived credentials, check the parent user's permissions.\n\t\taccountName = cred.ParentUser\n\t}\n\tpolicies, err := globalIAMSys.PolicyDBGet(accountName, false, cred.Groups...)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbuf, err := json.MarshalIndent(globalIAMSys.GetCombinedPolicy(policies...), \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tacctInfo := madmin.AccountInfo{\n\t\tAccountName: accountName,\n\t\tServer:      objectAPI.BackendInfo(),\n\t\tPolicy:      buf,\n\t}\n\n\tfor _, bucket := range buckets {\n\t\trd, wr := isAllowedAccess(bucket.Name)\n\t\tif rd || wr {\n\t\t\t// Fetch the data usage of the current bucket\n\t\t\tvar size uint64\n\t\t\tvar objectsCount uint64\n\t\t\tvar objectsHist map[string]uint64\n\t\t\tif !dataUsageInfo.LastUpdate.IsZero() {\n\t\t\t\tsize = dataUsageInfo.BucketsUsage[bucket.Name].Size\n\t\t\t\tobjectsCount = dataUsageInfo.BucketsUsage[bucket.Name].ObjectsCount\n\t\t\t\tobjectsHist = dataUsageInfo.BucketsUsage[bucket.Name].ObjectSizesHistogram\n\t\t\t}\n\t\t\t// Fetch the prefix usage of the current bucket\n\t\t\tvar prefixUsage map[string]uint64\n\t\t\tif enablePrefixUsage {\n\t\t\t\tprefixUsage, _ = loadPrefixUsageFromBackend(ctx, objectAPI, bucket.Name)\n\t\t\t}\n\n\t\t\tlcfg, _ := globalBucketObjectLockSys.Get(bucket.Name)\n\t\t\tquota, _ := globalBucketQuotaSys.Get(ctx, bucket.Name)\n\t\t\trcfg, _ := globalBucketMetadataSys.GetReplicationConfig(ctx, bucket.Name)\n\t\t\ttcfg, _ := globalBucketMetadataSys.GetTaggingConfig(bucket.Name)\n\n\t\t\tacctInfo.Buckets = append(acctInfo.Buckets, madmin.BucketAccessInfo{\n\t\t\t\tName:                 bucket.Name,\n\t\t\t\tCreated:              bucket.Created,\n\t\t\t\tSize:                 size,\n\t\t\t\tObjects:              objectsCount,\n\t\t\t\tObjectSizesHistogram: objectsHist,\n\t\t\t\tPrefixUsage:          prefixUsage,\n\t\t\t\tDetails: &madmin.BucketDetails{\n\t\t\t\t\tVersioning:          globalBucketVersioningSys.Enabled(bucket.Name),\n\t\t\t\t\tVersioningSuspended: globalBucketVersioningSys.Suspended(bucket.Name),\n\t\t\t\t\tReplication:         rcfg != nil,\n\t\t\t\t\tLocking:             lcfg.LockEnabled,\n\t\t\t\t\tQuota:               quota,\n\t\t\t\t\tTagging:             tcfg,\n\t\t\t\t},\n\t\t\t\tAccess: madmin.AccountAccess{\n\t\t\t\t\tRead:  rd,\n\t\t\t\t\tWrite: wr,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tusageInfoJSON, err := json.Marshal(acctInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, usageInfoJSON)\n}\n\n// InfoCannedPolicy - GET /minio/admin/v3/info-canned-policy?name={policyName}\n//\n// Newer API response with policy timestamps is returned with query parameter\n// `v=2` like:\n//\n// GET /minio/admin/v3/info-canned-policy?name={policyName}&v=2\n//\n// The newer API will eventually become the default (and only) one. The older\n// response is to return only the policy JSON. The newer response returns\n// timestamps along with the policy JSON. Both versions are supported for now,\n// for smooth transition to new API.\nfunc (a adminAPIHandlers) InfoCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"InfoCannedPolicy\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.GetPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tname := mux.Vars(r)[\"name\"]\n\tpolicies := newMappedPolicy(name).toSlice()\n\tif len(policies) != 1 {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errTooManyPolicies), r.URL)\n\t\treturn\n\t}\n\n\tpolicyDoc, err := globalIAMSys.InfoPolicy(name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Is the new API version being requested?\n\tinfoPolicyAPIVersion := r.Form.Get(\"v\")\n\tif infoPolicyAPIVersion == \"2\" {\n\t\tbuf, err := json.MarshalIndent(policyDoc, \"\", \" \")\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tw.Write(buf)\n\t\treturn\n\t} else if infoPolicyAPIVersion != \"\" {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errors.New(\"invalid version parameter 'v' supplied\")), r.URL)\n\t\treturn\n\t}\n\n\t// Return the older API response value of just the policy json.\n\tbuf, err := json.MarshalIndent(policyDoc.Policy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tw.Write(buf)\n}\n\n// ListBucketPolicies - GET /minio/admin/v3/list-canned-policies?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListBucketPolicies\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]iampolicy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// ListCannedPolicies - GET /minio/admin/v3/list-canned-policies\nfunc (a adminAPIHandlers) ListCannedPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListCannedPolicies\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]iampolicy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// RemoveCannedPolicy - DELETE /minio/admin/v3/remove-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) RemoveCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"RemoveCannedPolicy\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.DeletePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\tif err := globalIAMSys.DeletePolicy(ctx, policyName, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy deletion to\n\t// other minio clusters.\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicy,\n\t\tName: policyName,\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// AddCannedPolicy - PUT /minio/admin/v3/add-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) AddCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AddCannedPolicy\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.CreatePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\t// Error out if Content-Length is missing.\n\tif r.ContentLength <= 0 {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)\n\t\treturn\n\t}\n\n\t// Error out if Content-Length is beyond allowed size.\n\tif r.ContentLength > maxBucketPolicySize {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicyBytes, err := ioutil.ReadAll(io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicy, err := iampolicy.ParseConfig(bytes.NewReader(iamPolicyBytes))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Version in policy must not be empty\n\tif iamPolicy.Version == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrMalformedPolicy), r.URL)\n\t\treturn\n\t}\n\n\tif err = globalIAMSys.SetPolicy(ctx, policyName, *iamPolicy); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy to\n\t// other minio clusters.\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType:   madmin.SRIAMItemPolicy,\n\t\tName:   policyName,\n\t\tPolicy: iamPolicyBytes,\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// SetPolicyForUserOrGroup - PUT /minio/admin/v3/set-policy?policy=xxx&user-or-group=?[&is-group]\nfunc (a adminAPIHandlers) SetPolicyForUserOrGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"SetPolicyForUserOrGroup\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.AttachPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"policyName\"]\n\tentityName := vars[\"userOrGroup\"]\n\tisGroup := vars[\"isGroup\"] == \"true\"\n\n\tif !isGroup {\n\t\tok, _, err := globalIAMSys.IsTempUser(entityName)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif ok {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err := globalIAMSys.PolicyDBSet(ctx, entityName, policyName, isGroup); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: entityName,\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      policyName,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go\"\n\tminio \"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/credentials\"\n\tcr \"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\t\"github.com/minio/minio-go/v7/pkg/signer\"\n\t\"github.com/minio/minio/internal/auth\"\n)\n\nconst (\n\ttestDefaultTimeout = 30 * time.Second\n)\n\n// API suite container for IAM\ntype TestSuiteIAM struct {\n\tTestSuiteCommon\n\n\t// Flag to turn on tests for etcd backend IAM\n\twithEtcdBackend bool\n\n\tendpoint string\n\tadm      *madmin.AdminClient\n\tclient   *minio.Client\n}\n\nfunc newTestSuiteIAM(c TestSuiteCommon, withEtcdBackend bool) *TestSuiteIAM {\n\treturn &TestSuiteIAM{TestSuiteCommon: c, withEtcdBackend: withEtcdBackend}\n}\n\nfunc (s *TestSuiteIAM) iamSetup(c *check) {\n\tvar err error\n\t// strip url scheme from endpoint\n\ts.endpoint = strings.TrimPrefix(s.endPoint, \"http://\")\n\tif s.secure {\n\t\ts.endpoint = strings.TrimPrefix(s.endPoint, \"https://\")\n\t}\n\n\ts.adm, err = madmin.New(s.endpoint, s.accessKey, s.secretKey, s.secure)\n\tif err != nil {\n\t\tc.Fatalf(\"error creating admin client: %v\", err)\n\t}\n\t// Set transport, so that TLS is handled correctly.\n\ts.adm.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\ts.client, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(s.accessKey, s.secretKey, \"\"),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating minio client: %v\", err)\n\t}\n}\n\nconst (\n\tEnvTestEtcdBackend = \"ETCD_SERVER\"\n)\n\nfunc (s *TestSuiteIAM) setUpEtcd(c *check, etcdServer string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"etcd\",\n\t\t\"endpoints=\" + etcdServer,\n\t\t\"path_prefix=\" + mustGetUUID(),\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup Etcd for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc (s *TestSuiteIAM) SetUpSuite(c *check) {\n\t// If etcd backend is specified and etcd server is not present, the test\n\t// is skipped.\n\tetcdServer := os.Getenv(EnvTestEtcdBackend)\n\tif s.withEtcdBackend && etcdServer == \"\" {\n\t\tc.Skip(\"Skipping etcd backend IAM test as no etcd server is configured.\")\n\t}\n\n\ts.TestSuiteCommon.SetUpSuite(c)\n\n\ts.iamSetup(c)\n\n\tif s.withEtcdBackend {\n\t\ts.setUpEtcd(c, etcdServer)\n\t}\n}\n\nfunc (s *TestSuiteIAM) RestartIAMSuite(c *check) {\n\ts.TestSuiteCommon.RestartTestServer(c)\n\n\ts.iamSetup(c)\n}\n\nfunc (s *TestSuiteIAM) getAdminClient(c *check, accessKey, secretKey, sessionToken string) *madmin.AdminClient {\n\tmadmClnt, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user admin client: %s\", err)\n\t}\n\tmadmClnt.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\treturn madmClnt\n}\n\nfunc (s *TestSuiteIAM) getUserClient(c *check, accessKey, secretKey, sessionToken string) *minio.Client {\n\tclient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user minio client: %s\", err)\n\t}\n\treturn client\n}\n\nfunc TestIAMInternalIDPServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tsuite := testCase\n\t\t\t\tc := &check{t, testCase.serverType}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.TestUserCreate(c)\n\t\t\t\tsuite.TestUserPolicyEscalationBug(c)\n\t\t\t\tsuite.TestPolicyCreate(c)\n\t\t\t\tsuite.TestCannedPolicies(c)\n\t\t\t\tsuite.TestGroupAddRemove(c)\n\t\t\t\tsuite.TestServiceAccountOpsByAdmin(c)\n\t\t\t\tsuite.TestServiceAccountOpsByUser(c)\n\t\t\t\tsuite.TestAddServiceAccountPerms(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a user.\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr := s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 2. Check new user appears in listing\n\tusersMap, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok := usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user not listed: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountEnabled)\n\n\t// 3. Associate policy and check that user can access\n\terr = s.adm.SetPolicy(ctx, \"readwrite\", accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to set policy: %v\", err)\n\t}\n\tclient := s.getUserClient(c, accessKey, secretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 3.10. Check that user's password can be updated.\n\t_, newSecretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, newSecretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to update user's secret key: %v\", err)\n\t}\n\t// 3.10.1 Check that old password no longer works.\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user was unexpectedly able to create bucket with bad password!\")\n\t}\n\t// 3.10.2 Check that new password works.\n\tclient = s.getUserClient(c, accessKey, newSecretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 4. Check that user can be disabled and verify it.\n\terr = s.adm.SetUserStatus(ctx, accessKey, madmin.AccountDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"could not set user account to disabled\")\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok = usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user was not listed after disabling: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountDisabled)\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not disabled!\")\n\t}\n\n\t// 5. Check that user can be deleted and verify it.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\t_, ok = usersMap[accessKey]\n\tif ok {\n\t\tc.Fatalf(\"user not deleted: %s\", accessKey)\n\t}\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not deleted!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserPolicyEscalationBug(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 2. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 2.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 2.2 create and associate policy to user\n\tpolicy := \"mypolicy-test-user-update\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 2.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 2.3 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"bucket was deleted unexpectedly or got unexpected err: %v\", err)\n\t}\n\n\t// 3. Craft a request to update the user's permissions\n\tep := s.adm.GetEndpointURL()\n\turlValue := url.Values{}\n\turlValue.Add(\"accessKey\", accessKey)\n\tu, err := url.Parse(fmt.Sprintf(\"%s://%s/minio/admin/v3/add-user?%s\", ep.Scheme, ep.Host, s3utils.QueryEncode(urlValue)))\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected url parse err: %v\", err)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, u.String(), nil)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected new request err: %v\", err)\n\t}\n\treqBodyArg := madmin.UserInfo{\n\t\tSecretKey:  secretKey,\n\t\tPolicyName: \"consoleAdmin\",\n\t\tStatus:     madmin.AccountEnabled,\n\t}\n\tbuf, err := json.Marshal(reqBodyArg)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected json encode err: %v\", err)\n\t}\n\tbuf, err = madmin.EncryptData(secretKey, buf)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected encryption err: %v\", err)\n\t}\n\n\treq.ContentLength = int64(len(buf))\n\tsum := sha256.Sum256(buf)\n\treq.Header.Set(\"X-Amz-Content-Sha256\", hex.EncodeToString(sum[:]))\n\treq.Body = ioutil.NopCloser(bytes.NewReader(buf))\n\treq = signer.SignV4(*req, accessKey, secretKey, \"\", \"\")\n\n\t// 3.1 Execute the request.\n\tresp, err := s.TestSuiteCommon.client.Do(req)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected request err: %v\", err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tc.Fatalf(\"got unexpected response: %#v\\n\", resp)\n\t}\n\n\t// 3.2 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"User was able to escalate privileges (Err=%v)!\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestAddServiceAccountPerms(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a policy\n\tpolicy1 := \"deny-svc\"\n\tpolicy2 := \"allow-svc\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Deny\",\n   \"Action\": [\n    \"admin:CreateServiceAccount\"\n   ]\n  }\n ]\n}`)\n\n\tnewPolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::testbucket/*\"\n   ]\n  }\n ]\n}`)\n\n\terr := s.adm.AddCannedPolicy(ctx, policy1, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\terr = s.adm.AddCannedPolicy(ctx, policy2, newPolicyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy1+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, \"testbucket\")\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy1, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tadmClnt := s.getAdminClient(c, accessKey, secretKey, \"\")\n\n\t// 3.3 check user does not have explicit permissions to create service account.\n\tc.mustNotCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy1]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy2, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 3.3 check user can create service account implicitly.\n\tc.mustCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t_, ok = ps[policy2]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy1)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy2)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestPolicyCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 1. Create a policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.4 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 5. Check that policy cannot be deleted when attached to a user.\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err == nil {\n\t\tc.Fatalf(\"policy could be unexpectedly deleted!\")\n\t}\n\n\t// 6. Delete the user and then delete the policy.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestCannedPolicies(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tpolicies, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list policies: %v\", err)\n\t}\n\n\tdefaultPolicies := []string{\n\t\t\"readwrite\",\n\t\t\"readonly\",\n\t\t\"writeonly\",\n\t\t\"diagnostics\",\n\t\t\"consoleAdmin\",\n\t}\n\n\tfor _, v := range defaultPolicies {\n\t\tif _, ok := policies[v]; !ok {\n\t\t\tc.Fatalf(\"Failed to find %s in policies list\", v)\n\t\t}\n\t}\n\n\tbucket := getRandomBucketName()\n\terr = s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\n\t// Check that default policies can be overwritten.\n\terr = s.adm.AddCannedPolicy(ctx, \"readwrite\", policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tinfo, err := s.adm.InfoCannedPolicy(ctx, \"readwrite\")\n\tif err != nil {\n\t\tc.Fatalf(\"policy info err: %v\", err)\n\t}\n\n\tinfoStr := string(info)\n\tif !strings.Contains(infoStr, `\"s3:PutObject\"`) || !strings.Contains(infoStr, \":\"+bucket+\"/\") {\n\t\tc.Fatalf(\"policy contains unexpected content!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestGroupAddRemove(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 1. Add user to a new group\n\tgroup := \"mygroup\"\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   group,\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to add user to group: %v\", err)\n\t}\n\n\t// 2. Check that user has no access\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3. Associate policy to group and check user got access.\n\terr = s.adm.SetPolicy(ctx, policy, group, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.1 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.2 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. List groups and members and verify\n\tgroups, err := s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif !set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group not present!\")\n\t}\n\tgroupInfo, err := s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(set.CreateStringSet(groupInfo.Members...), set.CreateStringSet(accessKey))\n\tc.Assert(groupInfo.Policy, policy)\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\n\t// 5. Disable/enable the group and verify that user access is revoked/restored.\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupDisabled))\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// 6. Verify that group cannot be deleted with users.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"group was removed!\")\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\n\t// 7. Remove user from group and verify access is revoked.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tMembers:  []string{accessKey},\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 7.1 verify group still exists\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(len(groupInfo.Members), 0)\n\n\t// 8. Delete group and verify\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tgroups, err = s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group still present!\")\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err == nil {\n\t\tc.Fatalf(\"group appears to exist\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(accessKey, secretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, accessKey, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, accessKey, cr.AccessKey, false)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByAdmin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 1. Create a service account for the user\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, s.adm)\n\n\t// 1.2 Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, s.adm, accessKey, cr.AccessKey)\n\n\t// 1.3 Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, s.adm, accessKey, cr.AccessKey, false)\n\n\t// 2. Check that svc account can access the bucket\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 3. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, s.adm, accessKey, bucket)\n}\n\nfunc (c *check) mustCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) madmin.Credentials {\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to create a user: %v\", err)\n\t}\n\treturn madmin.Credentials{\n\t\tAccessKey: randUser,\n\t\tSecretKey: randPass,\n\t}\n}\n\nfunc (c *check) mustGetIAMUserInfo(ctx context.Context, admClnt *madmin.AdminClient, accessKey string) madmin.UserInfo {\n\tui, err := admClnt.GetUserInfo(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to get user info: %v\", err)\n\t}\n\treturn ui\n}\n\nfunc (c *check) mustNotCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) {\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to create a user\")\n\t}\n}\n\nfunc (c *check) mustCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) madmin.Credentials {\n\tcr, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"user should be able to create service accounts %s\", err)\n\t}\n\treturn cr\n}\n\nfunc (c *check) mustNotCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) {\n\t_, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"user was able to add service accounts unexpectedly!\")\n\t}\n}\n\nfunc (c *check) mustNotListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif !ok || v.Err == nil {\n\t\tc.Fatalf(\"user was able to list unexpectedly!\")\n\t}\n}\n\nfunc (c *check) mustListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif ok && v.Err != nil {\n\t\tmsg := fmt.Sprintf(\"user was unable to list: %v\", v.Err)\n\t\tc.Fatalf(msg)\n\t}\n}\n\nfunc (c *check) assertSvcAccS3Access(ctx context.Context, s *TestSuiteIAM, cr madmin.Credentials, bucket string) {\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccAppearsInListing(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string) {\n\tlistResp, err := madmClient.ListServiceAccounts(ctx, parentAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list svc accounts: %v\", err)\n\t}\n\tif !set.CreateStringSet(listResp.Accounts...).Contains(svcAK) {\n\t\tc.Fatalf(\"service account did not appear in listing!\")\n\t}\n}\n\nfunc (c *check) assertSvcAccInfoQueryable(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string, skipParentUserCheck bool) {\n\tinfoResp, err := madmClient.InfoServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to get svc acc info: %v\", err)\n\t}\n\tif !skipParentUserCheck {\n\t\tc.Assert(infoResp.ParentUser, parentAK)\n\t}\n\tc.Assert(infoResp.AccountStatus, \"on\")\n\tc.Assert(infoResp.ImpliedPolicy, true)\n}\n\n// This test assumes that the policy for `accessKey` allows listing on the given\n// bucket. It creates a session policy that restricts listing on the bucket and\n// then enables it again in a session policy update call.\nfunc (c *check) assertSvcAccSessionPolicyUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t// This policy does not allow listing objects.\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tPolicy:     policyBytes,\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\n\t// This policy allows listing objects.\n\tnewPolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewPolicy: newPolicyBytes,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update session policy for svc acc: %v\", err)\n\t}\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccSecretKeyAndStatusUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t_, svcSK2 := mustGenerateCredentials(c)\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewSecretKey: svcSK2,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\t// old creds should not work:\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\t// new creds work:\n\tsvcClient2 := s.getUserClient(c, cr.AccessKey, svcSK2, \"\")\n\tc.mustListObjects(ctx, svcClient2, bucket)\n\n\t// update status to disabled\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewStatus: \"off\",\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient2, bucket)\n}\n\nfunc (c *check) assertSvcAccDeletion(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\terr = madmClient.DeleteServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to delete svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n}\n\nfunc mustGenerateCredentials(c *check) (string, string) {\n\tak, sk, err := auth.GenerateCredentials()\n\tif err != nil {\n\t\tc.Fatalf(\"unable to generate credentials: %v\", err)\n\t}\n\treturn ak, sk\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go\"\n\tminio \"github.com/minio/minio-go/v7\"\n\tcr \"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n)\n\nfunc runAllIAMSTSTests(suite *TestSuiteIAM, c *check) {\n\tsuite.SetUpSuite(c)\n\t// The STS for root test needs to be the first one after setup.\n\tsuite.TestSTSForRoot(c)\n\tsuite.TestSTS(c)\n\tsuite.TestSTSWithGroupPolicy(c)\n\tsuite.TearDownSuite(c)\n}\n\nfunc TestIAMInternalIDPSTSServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\trunAllIAMSTSTests(testCase, &check{t, testCase.serverType})\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithGroupPolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// confirm that the user is unable to access the bucket - we have not\n\t// yet set any policy\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   \"test-group\",\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to add user to group: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, \"test-group\", true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket - permission comes\n\t// from group.\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// Create STS user.\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\t// Check that STS user client has access coming from parent user's\n\t// group.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\n// TestSTSForRoot - needs to be the first test after server setup due to the\n// buckets list check.\nfunc (s *TestSuiteIAM) TestSTSForRoot(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: globalActiveCred.AccessKey,\n\t\t\tSecretKey: globalActiveCred.SecretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that a bucket can be created\n\tbucket2 := getRandomBucketName()\n\terr = minioClient.MakeBucket(ctx, bucket2, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Validate that admin APIs can be called - create an madmin client with\n\t// user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\taccInfo, err := userAdmClient.AccountInfo(ctx, madmin.AccountOpts{})\n\tif err != nil {\n\t\tc.Fatalf(\"root user STS should be able to get account info: %v\", err)\n\t}\n\n\tgotBuckets := set.NewStringSet()\n\tfor _, b := range accInfo.Buckets {\n\t\tgotBuckets.Add(b.Name)\n\t\tif !(b.Access.Read && b.Access.Write) {\n\t\t\tc.Fatalf(\"root user should have read and write access to bucket: %v\", b.Name)\n\t\t}\n\t}\n\tshouldHaveBuckets := set.CreateStringSet(bucket2, bucket)\n\tif !gotBuckets.Equals(shouldHaveBuckets) {\n\t\tc.Fatalf(\"root user should have access to all buckets\")\n\t}\n}\n\n// SetUpLDAP - expects to setup an LDAP test server using the test LDAP\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpLDAP(c *check, serverAddr string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_ldap\",\n\t\tfmt.Sprintf(\"server_addr=%s\", serverAddr),\n\t\t\"server_insecure=on\",\n\t\t\"lookup_bind_dn=cn=admin,dc=min,dc=io\",\n\t\t\"lookup_bind_password=admin\",\n\t\t\"user_dn_search_base_dn=dc=min,dc=io\",\n\t\t\"user_dn_search_filter=(uid=%s)\",\n\t\t\"group_search_base_dn=ou=swengg,dc=min,dc=io\",\n\t\t\"group_search_filter=(&(objectclass=groupofnames)(member=%d))\",\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup LDAP for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nconst (\n\tEnvTestLDAPServer = \"LDAP_TEST_SERVER\"\n)\n\nfunc TestIAMWithLDAPServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tldapServer := os.Getenv(EnvTestLDAPServer)\n\t\t\t\tif ldapServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping LDAP test as no LDAP server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpLDAP(c, ldapServer)\n\t\t\t\tsuite.TestLDAPSTS(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccounts(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccountsWithGroups(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create STS cred with no associated policy!\")\n\t}\n\n\t// Attempting to set a non-existent policy should fail.\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy+\"x\", userDN, false)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to set non-existent policy\")\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that user listing does not return any entries\n\tusersList, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"list users should not fail: %v\", err)\n\t}\n\tif len(usersList) > 0 {\n\t\tc.Fatalf(\"expected listing to be empty: %v\", usersList)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n\n\t// Remove the policy assignment on the user DN:\n\terr = s.adm.SetPolicy(ctx, \"\", userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to remove policy setting: %v\", err)\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create a user with no associated policy!\")\n\t}\n\n\t// Set policy via group and validate policy assignment.\n\tgroupDN := \"cn=projectb,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set group policy: %v\", err)\n\t}\n\n\tvalue, err = ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tc.Assert(err.Error(), \"Access Denied.\")\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccounts(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n\n// In this test, the parent users gets their permissions from a group, rather\n// than having a policy set directly on them.\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithGroups(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tgroupDN := \"cn=projecta,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\t// fmt.Printf(\"TOKEN: %s\\n\", token)\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSAddUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\tc.mustNotCreateIAMUser(ctx, userAdmClient)\n\n\t// Create admin user policy.\n\tpolicyBytes = []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"admin:*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tcr := c.mustCreateIAMUser(ctx, userAdmClient)\n\n\tuserInfo := c.mustGetIAMUserInfo(ctx, userAdmClient, cr.AccessKey)\n\tc.Assert(userInfo.Status, madmin.AccountEnabled)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAcc(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n\nvar testAppParams = OpenIDClientAppParams{\n\tClientID:     \"minio-client-app\",\n\tClientSecret: \"minio-client-app-secret\",\n\tProviderURL:  \"http://127.0.0.1:5556/dex\",\n\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n}\n\nconst (\n\tEnvTestOpenIDServer = \"OPENID_TEST_SERVER\"\n)\n\n// SetUpOpenID - expects to setup an OpenID test server using the test OpenID\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpOpenID(c *check, serverAddr string, rolePolicy string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_openid\",\n\t\tfmt.Sprintf(\"config_url=%s/.well-known/openid-configuration\", serverAddr),\n\t\t\"client_id=minio-client-app\",\n\t\t\"client_secret=minio-client-app-secret\",\n\t\t\"scopes=openid,groups\",\n\t\t\"redirect_uri=http://127.0.0.1:10000/oauth_callback\",\n\t}\n\tif rolePolicy != \"\" {\n\t\tconfigCmds = append(configCmds, fmt.Sprintf(\"role_policy=%s\", rolePolicy))\n\t} else {\n\t\tconfigCmds = append(configCmds, \"claim_name=groups\")\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup OpenID for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc TestIAMWithOpenIDServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"\")\n\t\t\t\tsuite.TestOpenIDSTS(c)\n\t\t\t\tsuite.TestOpenIDServiceAcc(c)\n\t\t\t\tsuite.TestOpenIDSTSAddUser(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithRolePolicyServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"readwrite\")\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c)\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicy(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nconst (\n\ttestRoleARN = \"arn:minio:iam:::role/nOybJqMNzNmroqEKq5D0EUsRZw0\"\n)\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n"], "fixing_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"sort\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/minio/madmin-go\"\n\t\"github.com/minio/minio/internal/auth\"\n\t\"github.com/minio/minio/internal/config/dns\"\n\t\"github.com/minio/minio/internal/logger\"\n\tiampolicy \"github.com/minio/pkg/iam/policy\"\n)\n\n// RemoveUser - DELETE /minio/admin/v3/remove-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) RemoveUser(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"RemoveUser\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.DeleteUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\tok, _, err := globalIAMSys.IsTempUser(accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tif ok {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalIAMSys.DeleteUser(ctx, accessKey, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: true,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// ListBucketUsers - GET /minio/admin/v3/list-users?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListBucketUsers\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, iampolicy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListBucketUsers(bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// ListUsers - GET /minio/admin/v3/list-users\nfunc (a adminAPIHandlers) ListUsers(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListUsers\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, cred := validateAdminReq(ctx, w, r, iampolicy.ListUsersAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\n\tallCredentials, err := globalIAMSys.ListUsers()\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(allCredentials)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\teconfigData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, econfigData)\n}\n\n// GetUserInfo - GET /minio/admin/v3/user-info\nfunc (a adminAPIHandlers) GetUserInfo(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"GetUserInfo\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tvars := mux.Vars(r)\n\tname := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif name == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to view one's own info.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.GetUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tuserInfo, err := globalIAMSys.GetUserInfo(ctx, name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(userInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, data)\n}\n\n// UpdateGroupMembers - PUT /minio/admin/v3/update-group-members\nfunc (a adminAPIHandlers) UpdateGroupMembers(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"UpdateGroupMembers\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.AddUserToGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tdata, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tvar updReq madmin.GroupAddRemove\n\terr = json.Unmarshal(data, &updReq)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tif updReq.IsRemove {\n\t\terr = globalIAMSys.RemoveUsersFromGroup(ctx, updReq.Group, updReq.Members)\n\t} else {\n\t\terr = globalIAMSys.AddUsersToGroup(ctx, updReq.Group, updReq.Members)\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: updReq,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// GetGroup - /minio/admin/v3/group?group=mygroup1\nfunc (a adminAPIHandlers) GetGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"GetGroup\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.GetGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\n\tgdesc, err := globalIAMSys.GetGroupDescription(group)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(gdesc)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// ListGroups - GET /minio/admin/v3/groups\nfunc (a adminAPIHandlers) ListGroups(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListGroups\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ListGroupsAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tgroups, err := globalIAMSys.ListGroups(ctx)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbody, err := json.Marshal(groups)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, body)\n}\n\n// SetGroupStatus - PUT /minio/admin/v3/set-group-status?group=mygroup1&status=enabled\nfunc (a adminAPIHandlers) SetGroupStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"SetGroupStatus\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.EnableGroupAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tgroup := vars[\"group\"]\n\tstatus := vars[\"status\"]\n\n\tvar err error\n\tswitch status {\n\tcase statusEnabled:\n\t\terr = globalIAMSys.SetGroupStatus(ctx, group, true)\n\tcase statusDisabled:\n\t\terr = globalIAMSys.SetGroupStatus(ctx, group, false)\n\tdefault:\n\t\terr = errInvalidArgument\n\t}\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemGroupInfo,\n\t\tGroupInfo: &madmin.SRGroupInfo{\n\t\t\tUpdateReq: madmin.GroupAddRemove{\n\t\t\t\tGroup:    group,\n\t\t\t\tStatus:   madmin.GroupStatus(status),\n\t\t\t\tIsRemove: false,\n\t\t\t},\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// SetUserStatus - PUT /minio/admin/v3/set-user-status?accessKey=<access_key>&status=[enabled|disabled]\nfunc (a adminAPIHandlers) SetUserStatus(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"SetUserStatus\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.EnableUserAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\tstatus := vars[\"status\"]\n\n\t// This API is not allowed to lookup master access key user status\n\tif accessKey == globalActiveCred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalIAMSys.SetUserStatus(ctx, accessKey, madmin.AccountStatus(status)); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq: &madmin.AddOrUpdateUserReq{\n\t\t\t\tStatus: madmin.AccountStatus(status),\n\t\t\t},\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// AddUser - PUT /minio/admin/v3/add-user?accessKey=<access_key>\nfunc (a adminAPIHandlers) AddUser(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AddUser\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tvars := mux.Vars(r)\n\taccessKey := vars[\"accessKey\"]\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Not allowed to add a user with same access key as root credential\n\tif owner && accessKey == cred.AccessKey {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tuserCred, exists := globalIAMSys.GetUser(ctx, accessKey)\n\tif exists && (userCred.IsTemp() || userCred.IsServiceAccount()) {\n\t\t// Updating STS credential is not allowed, and this API does not\n\t\t// support updating service accounts.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tif (cred.IsTemp() || cred.IsServiceAccount()) && cred.ParentUser == accessKey {\n\t\t// Incoming access key matches parent user then we should\n\t\t// reject password change requests.\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAddUserInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tcheckDenyOnly := false\n\tif accessKey == cred.AccessKey {\n\t\t// Check that there is no explicit deny - otherwise it's allowed\n\t\t// to change one's own password.\n\t\tcheckDenyOnly = true\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tGroups:          cred.Groups,\n\t\tAction:          iampolicy.CreateUserAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t\tDenyOnly:        checkDenyOnly,\n\t}) {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\treturn\n\t}\n\n\tif r.ContentLength > maxEConfigJSONSize || r.ContentLength == -1 {\n\t\t// More than maxConfigSize bytes were available\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\tconfigBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tvar ureq madmin.AddOrUpdateUserReq\n\tif err = json.Unmarshal(configBytes, &ureq); err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminConfigBadJSON), r.URL)\n\t\treturn\n\t}\n\n\tif err = globalIAMSys.CreateUser(ctx, accessKey, ureq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemIAMUser,\n\t\tIAMUser: &madmin.SRIAMUser{\n\t\t\tAccessKey:   accessKey,\n\t\t\tIsDeleteReq: false,\n\t\t\tUserReq:     &ureq,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// AddServiceAccount - PUT /minio/admin/v3/add-service-account\nfunc (a adminAPIHandlers) AddServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AddServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar createReq madmin.AddServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &createReq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar (\n\t\ttargetUser   string\n\t\ttargetGroups []string\n\t)\n\n\t// If the request did not set a TargetUser, the service account is\n\t// created for the request sender.\n\ttargetUser = createReq.TargetUser\n\tif targetUser == \"\" {\n\t\ttargetUser = cred.AccessKey\n\t}\n\n\topts := newServiceAccountOpts{\n\t\taccessKey: createReq.AccessKey,\n\t\tsecretKey: createReq.SecretKey,\n\t\tclaims:    make(map[string]interface{}),\n\t}\n\n\t// Find the user for the request sender (as it may be sent via a service\n\t// account or STS account):\n\trequestorUser := cred.AccessKey\n\trequestorParentUser := cred.AccessKey\n\trequestorGroups := cred.Groups\n\trequestorIsDerivedCredential := false\n\tif cred.IsServiceAccount() || cred.IsTemp() {\n\t\trequestorParentUser = cred.ParentUser\n\t\trequestorIsDerivedCredential = true\n\t}\n\n\t// Check if we are creating svc account for request sender.\n\tisSvcAccForRequestor := false\n\tif targetUser == requestorUser || targetUser == requestorParentUser {\n\t\tisSvcAccForRequestor = true\n\t}\n\n\t// If we are creating svc account for request sender, ensure\n\t// that targetUser is a real user (i.e. not derived\n\t// credentials).\n\tif isSvcAccForRequestor {\n\t\t// Check if adding service account is explicitly denied.\n\t\t//\n\t\t// This allows turning off service accounts for request sender,\n\t\t// if there is no deny statement this call is implicitly enabled.\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     requestorUser,\n\t\t\tGroups:          requestorGroups,\n\t\t\tAction:          iampolicy.CreateServiceAccountAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t\tDenyOnly:        true,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\n\t\tif requestorIsDerivedCredential {\n\t\t\tif requestorParentUser == \"\" {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx,\n\t\t\t\t\terrors.New(\"service accounts cannot be generated for temporary credentials without parent\")), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttargetUser = requestorParentUser\n\t\t}\n\t\ttargetGroups = requestorGroups\n\n\t\t// In case of LDAP/OIDC we need to set `opts.claims` to ensure\n\t\t// it is associated with the LDAP/OIDC user properly.\n\t\tfor k, v := range cred.Claims {\n\t\t\tif k == expClaim {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\topts.claims[k] = v\n\t\t}\n\t} else {\n\t\t// Need permission if we are creating a service acccount for a\n\t\t// user <> to the request sender\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     requestorUser,\n\t\t\tGroups:          requestorGroups,\n\t\t\tAction:          iampolicy.CreateServiceAccountAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\n\t\t// In case of LDAP we need to resolve the targetUser to a DN and\n\t\t// query their groups:\n\t\tif globalLDAPConfig.Enabled {\n\t\t\topts.claims[ldapUserN] = targetUser // simple username\n\t\t\ttargetUser, targetGroups, err = globalLDAPConfig.LookupUserDN(targetUser)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.claims[ldapUser] = targetUser // username DN\n\t\t}\n\n\t\t// NOTE: if not using LDAP, then internal IDP or open ID is\n\t\t// being used - in the former, group info is enforced when\n\t\t// generated credentials are used to make requests, and in the\n\t\t// latter, a group notion is not supported.\n\t}\n\n\tvar sp *iampolicy.Policy\n\tif len(createReq.Policy) > 0 {\n\t\tsp, err = iampolicy.ParseConfig(bytes.NewReader(createReq.Policy))\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\topts.sessionPolicy = sp\n\tnewCred, err := globalIAMSys.NewServiceAccount(ctx, targetUser, targetGroups, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call hook for cluster-replication if the service account is not for a\n\t// root user.\n\tif newCred.ParentUser != globalActiveCred.AccessKey {\n\t\terr = globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tCreate: &madmin.SRSvcAccCreate{\n\t\t\t\t\tParent:        newCred.ParentUser,\n\t\t\t\t\tAccessKey:     newCred.AccessKey,\n\t\t\t\t\tSecretKey:     newCred.SecretKey,\n\t\t\t\t\tGroups:        newCred.Groups,\n\t\t\t\t\tClaims:        opts.claims,\n\t\t\t\t\tSessionPolicy: createReq.Policy,\n\t\t\t\t\tStatus:        auth.AccountOn,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tcreateResp := madmin.AddServiceAccountResp{\n\t\tCredentials: madmin.Credentials{\n\t\t\tAccessKey: newCred.AccessKey,\n\t\t\tSecretKey: newCred.SecretKey,\n\t\t},\n\t}\n\n\tdata, err := json.Marshal(createResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(password, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// UpdateServiceAccount - POST /minio/admin/v3/update-service-account\nfunc (a adminAPIHandlers) UpdateServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"UpdateServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.UpdateServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tpassword := cred.SecretKey\n\treqBytes, err := madmin.DecryptData(password, io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar updateReq madmin.UpdateServiceAccountReq\n\tif err = json.Unmarshal(reqBytes, &updateReq); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErrWithErr(ErrAdminConfigBadJSON, err), r.URL)\n\t\treturn\n\t}\n\n\tvar sp *iampolicy.Policy\n\tif len(updateReq.NewPolicy) > 0 {\n\t\tsp, err = iampolicy.ParseConfig(bytes.NewReader(updateReq.NewPolicy))\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\topts := updateServiceAccountOpts{\n\t\tsecretKey:     updateReq.NewSecretKey,\n\t\tstatus:        updateReq.NewStatus,\n\t\tsessionPolicy: sp,\n\t}\n\terr = globalIAMSys.UpdateServiceAccount(ctx, accessKey, opts)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\terr = globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tUpdate: &madmin.SRSvcAccUpdate{\n\t\t\t\t\tAccessKey:     accessKey,\n\t\t\t\t\tSecretKey:     opts.secretKey,\n\t\t\t\t\tStatus:        opts.status,\n\t\t\t\t\tSessionPolicy: updateReq.NewPolicy,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// InfoServiceAccount - GET /minio/admin/v3/info-service-account\nfunc (a adminAPIHandlers) InfoServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"InfoServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\taccessKey := mux.Vars(r)[\"accessKey\"]\n\tif accessKey == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrInvalidRequest), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, policy, err := globalIAMSys.GetServiceAccount(ctx, accessKey)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.ListServiceAccountsAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t}) {\n\t\trequestUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\trequestUser = cred.ParentUser\n\t\t}\n\n\t\tif requestUser != svcAccount.ParentUser {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar svcAccountPolicy iampolicy.Policy\n\n\tif policy != nil {\n\t\tsvcAccountPolicy = *policy\n\t} else {\n\t\tpoliciesNames, err := globalIAMSys.PolicyDBGet(svcAccount.ParentUser, false)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tsvcAccountPolicy = globalIAMSys.GetCombinedPolicy(policiesNames...)\n\t}\n\n\tpolicyJSON, err := json.MarshalIndent(svcAccountPolicy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tinfoResp := madmin.InfoServiceAccountResp{\n\t\tParentUser:    svcAccount.ParentUser,\n\t\tAccountStatus: svcAccount.Status,\n\t\tImpliedPolicy: policy == nil,\n\t\tPolicy:        string(policyJSON),\n\t}\n\n\tdata, err := json.Marshal(infoResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// ListServiceAccounts - GET /minio/admin/v3/list-service-accounts\nfunc (a adminAPIHandlers) ListServiceAccounts(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListServiceAccounts\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tvar targetAccount string\n\n\t// If listing is requested for a specific user (who is not the request\n\t// sender), check that the user has permissions.\n\tuser := r.Form.Get(\"user\")\n\tif user != \"\" && user != cred.AccessKey {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tAction:          iampolicy.ListServiceAccountsAdminAction,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n\t\t\treturn\n\t\t}\n\t\ttargetAccount = user\n\t} else {\n\t\ttargetAccount = cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\ttargetAccount = cred.ParentUser\n\t\t}\n\t}\n\n\tserviceAccounts, err := globalIAMSys.ListServiceAccounts(ctx, targetAccount)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tvar serviceAccountsNames []string\n\n\tfor _, svc := range serviceAccounts {\n\t\tserviceAccountsNames = append(serviceAccountsNames, svc.AccessKey)\n\t}\n\n\tlistResp := madmin.ListServiceAccountsResp{\n\t\tAccounts: serviceAccountsNames,\n\t}\n\n\tdata, err := json.Marshal(listResp)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tencryptedData, err := madmin.EncryptData(cred.SecretKey, data)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, encryptedData)\n}\n\n// DeleteServiceAccount - DELETE /minio/admin/v3/delete-service-account\nfunc (a adminAPIHandlers) DeleteServiceAccount(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"DeleteServiceAccount\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\tserviceAccount := mux.Vars(r)[\"accessKey\"]\n\tif serviceAccount == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminInvalidArgument), r.URL)\n\t\treturn\n\t}\n\n\tsvcAccount, _, err := globalIAMSys.GetServiceAccount(ctx, serviceAccount)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tadminPrivilege := globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     cred.AccessKey,\n\t\tAction:          iampolicy.RemoveServiceAccountAdminAction,\n\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims,\n\t})\n\n\tif !adminPrivilege {\n\t\tparentUser := cred.AccessKey\n\t\tif cred.ParentUser != \"\" {\n\t\t\tparentUser = cred.ParentUser\n\t\t}\n\t\tif parentUser != svcAccount.ParentUser {\n\t\t\t// The service account belongs to another user but return not\n\t\t\t// found error to mitigate brute force attacks. or the\n\t\t\t// serviceAccount doesn't exist.\n\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAdminServiceAccountNotFound), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = globalIAMSys.DeleteServiceAccount(ctx, serviceAccount, true)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call site replication hook - non-root user accounts are replicated.\n\tif svcAccount.ParentUser != globalActiveCred.AccessKey {\n\t\terr = globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\t\tType: madmin.SRIAMItemSvcAcc,\n\t\t\tSvcAccChange: &madmin.SRSvcAccChange{\n\t\t\t\tDelete: &madmin.SRSvcAccDelete{\n\t\t\t\t\tAccessKey: serviceAccount,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\twriteSuccessNoContent(w)\n}\n\n// AccountInfoHandler returns usage\nfunc (a adminAPIHandlers) AccountInfoHandler(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AccountInfo\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\t// Get current object layer instance.\n\tobjectAPI := newObjectLayerFn()\n\tif objectAPI == nil || globalNotificationSys == nil {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrServerNotInitialized), r.URL)\n\t\treturn\n\t}\n\n\tcred, claims, owner, s3Err := validateAdminSignature(ctx, r, \"\")\n\tif s3Err != ErrNone {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL)\n\t\treturn\n\t}\n\n\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\tr.Header.Set(\"prefix\", \"\")\n\n\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t// Check if we are asked to return prefix usage\n\tenablePrefixUsage := r.Form.Get(\"prefix-usage\") == \"true\"\n\n\tisAllowedAccess := func(bucketName string) (rd, wr bool) {\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\trd = true\n\t\t}\n\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     cred.AccessKey,\n\t\t\tGroups:          cred.Groups,\n\t\t\tAction:          iampolicy.PutObjectAction,\n\t\t\tBucketName:      bucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", cred.AccessKey, claims),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          claims,\n\t\t}) {\n\t\t\twr = true\n\t\t}\n\n\t\treturn rd, wr\n\t}\n\n\tvar dataUsageInfo DataUsageInfo\n\tvar err error\n\tif !globalIsGateway {\n\t\t// Load the latest calculated data usage\n\t\tdataUsageInfo, _ = loadDataUsageFromBackend(ctx, objectAPI)\n\t}\n\n\t// If etcd, dns federation configured list buckets from etcd.\n\tvar buckets []BucketInfo\n\tif globalDNSConfig != nil && globalBucketFederation {\n\t\tdnsBuckets, err := globalDNSConfig.List()\n\t\tif err != nil && !IsErrIgnored(err,\n\t\t\tdns.ErrNoEntriesFound,\n\t\t\tdns.ErrDomainMissing) {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tfor _, dnsRecords := range dnsBuckets {\n\t\t\tbuckets = append(buckets, BucketInfo{\n\t\t\t\tName:    dnsRecords[0].Key,\n\t\t\t\tCreated: dnsRecords[0].CreationDate,\n\t\t\t})\n\t\t}\n\t\tsort.Slice(buckets, func(i, j int) bool {\n\t\t\treturn buckets[i].Name < buckets[j].Name\n\t\t})\n\t} else {\n\t\tbuckets, err = objectAPI.ListBuckets(ctx)\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\taccountName := cred.AccessKey\n\tif cred.IsTemp() || cred.IsServiceAccount() {\n\t\t// For derived credentials, check the parent user's permissions.\n\t\taccountName = cred.ParentUser\n\t}\n\tpolicies, err := globalIAMSys.PolicyDBGet(accountName, false, cred.Groups...)\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tbuf, err := json.MarshalIndent(globalIAMSys.GetCombinedPolicy(policies...), \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tacctInfo := madmin.AccountInfo{\n\t\tAccountName: accountName,\n\t\tServer:      objectAPI.BackendInfo(),\n\t\tPolicy:      buf,\n\t}\n\n\tfor _, bucket := range buckets {\n\t\trd, wr := isAllowedAccess(bucket.Name)\n\t\tif rd || wr {\n\t\t\t// Fetch the data usage of the current bucket\n\t\t\tvar size uint64\n\t\t\tvar objectsCount uint64\n\t\t\tvar objectsHist map[string]uint64\n\t\t\tif !dataUsageInfo.LastUpdate.IsZero() {\n\t\t\t\tsize = dataUsageInfo.BucketsUsage[bucket.Name].Size\n\t\t\t\tobjectsCount = dataUsageInfo.BucketsUsage[bucket.Name].ObjectsCount\n\t\t\t\tobjectsHist = dataUsageInfo.BucketsUsage[bucket.Name].ObjectSizesHistogram\n\t\t\t}\n\t\t\t// Fetch the prefix usage of the current bucket\n\t\t\tvar prefixUsage map[string]uint64\n\t\t\tif enablePrefixUsage {\n\t\t\t\tprefixUsage, _ = loadPrefixUsageFromBackend(ctx, objectAPI, bucket.Name)\n\t\t\t}\n\n\t\t\tlcfg, _ := globalBucketObjectLockSys.Get(bucket.Name)\n\t\t\tquota, _ := globalBucketQuotaSys.Get(ctx, bucket.Name)\n\t\t\trcfg, _ := globalBucketMetadataSys.GetReplicationConfig(ctx, bucket.Name)\n\t\t\ttcfg, _ := globalBucketMetadataSys.GetTaggingConfig(bucket.Name)\n\n\t\t\tacctInfo.Buckets = append(acctInfo.Buckets, madmin.BucketAccessInfo{\n\t\t\t\tName:                 bucket.Name,\n\t\t\t\tCreated:              bucket.Created,\n\t\t\t\tSize:                 size,\n\t\t\t\tObjects:              objectsCount,\n\t\t\t\tObjectSizesHistogram: objectsHist,\n\t\t\t\tPrefixUsage:          prefixUsage,\n\t\t\t\tDetails: &madmin.BucketDetails{\n\t\t\t\t\tVersioning:          globalBucketVersioningSys.Enabled(bucket.Name),\n\t\t\t\t\tVersioningSuspended: globalBucketVersioningSys.Suspended(bucket.Name),\n\t\t\t\t\tReplication:         rcfg != nil,\n\t\t\t\t\tLocking:             lcfg.LockEnabled,\n\t\t\t\t\tQuota:               quota,\n\t\t\t\t\tTagging:             tcfg,\n\t\t\t\t},\n\t\t\t\tAccess: madmin.AccountAccess{\n\t\t\t\t\tRead:  rd,\n\t\t\t\t\tWrite: wr,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tusageInfoJSON, err := json.Marshal(acctInfo)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\twriteSuccessResponseJSON(w, usageInfoJSON)\n}\n\n// InfoCannedPolicy - GET /minio/admin/v3/info-canned-policy?name={policyName}\n//\n// Newer API response with policy timestamps is returned with query parameter\n// `v=2` like:\n//\n// GET /minio/admin/v3/info-canned-policy?name={policyName}&v=2\n//\n// The newer API will eventually become the default (and only) one. The older\n// response is to return only the policy JSON. The newer response returns\n// timestamps along with the policy JSON. Both versions are supported for now,\n// for smooth transition to new API.\nfunc (a adminAPIHandlers) InfoCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"InfoCannedPolicy\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.GetPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tname := mux.Vars(r)[\"name\"]\n\tpolicies := newMappedPolicy(name).toSlice()\n\tif len(policies) != 1 {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errTooManyPolicies), r.URL)\n\t\treturn\n\t}\n\n\tpolicyDoc, err := globalIAMSys.InfoPolicy(name)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Is the new API version being requested?\n\tinfoPolicyAPIVersion := r.Form.Get(\"v\")\n\tif infoPolicyAPIVersion == \"2\" {\n\t\tbuf, err := json.MarshalIndent(policyDoc, \"\", \" \")\n\t\tif err != nil {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tw.Write(buf)\n\t\treturn\n\t} else if infoPolicyAPIVersion != \"\" {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errors.New(\"invalid version parameter 'v' supplied\")), r.URL)\n\t\treturn\n\t}\n\n\t// Return the older API response value of just the policy json.\n\tbuf, err := json.MarshalIndent(policyDoc.Policy, \"\", \" \")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\tw.Write(buf)\n}\n\n// ListBucketPolicies - GET /minio/admin/v3/list-canned-policies?bucket={bucket}\nfunc (a adminAPIHandlers) ListBucketPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListBucketPolicies\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tbucket := mux.Vars(r)[\"bucket\"]\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, bucket)\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]iampolicy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// ListCannedPolicies - GET /minio/admin/v3/list-canned-policies\nfunc (a adminAPIHandlers) ListCannedPolicies(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"ListCannedPolicies\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.ListUserPoliciesAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tpolicies, err := globalIAMSys.ListPolicies(ctx, \"\")\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tnewPolicies := make(map[string]iampolicy.Policy)\n\tfor name, p := range policies {\n\t\t_, err = json.Marshal(p)\n\t\tif err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\t\tnewPolicies[name] = p\n\t}\n\tif err = json.NewEncoder(w).Encode(newPolicies); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// RemoveCannedPolicy - DELETE /minio/admin/v3/remove-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) RemoveCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"RemoveCannedPolicy\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.DeletePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\tif err := globalIAMSys.DeletePolicy(ctx, policyName, true); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy deletion to\n\t// other minio clusters.\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicy,\n\t\tName: policyName,\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// AddCannedPolicy - PUT /minio/admin/v3/add-canned-policy?name=<policy_name>\nfunc (a adminAPIHandlers) AddCannedPolicy(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"AddCannedPolicy\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.CreatePolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"name\"]\n\n\t// Error out if Content-Length is missing.\n\tif r.ContentLength <= 0 {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrMissingContentLength), r.URL)\n\t\treturn\n\t}\n\n\t// Error out if Content-Length is beyond allowed size.\n\tif r.ContentLength > maxBucketPolicySize {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrEntityTooLarge), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicyBytes, err := ioutil.ReadAll(io.LimitReader(r.Body, r.ContentLength))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tiamPolicy, err := iampolicy.ParseConfig(bytes.NewReader(iamPolicyBytes))\n\tif err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Version in policy must not be empty\n\tif iamPolicy.Version == \"\" {\n\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrMalformedPolicy), r.URL)\n\t\treturn\n\t}\n\n\tif err = globalIAMSys.SetPolicy(ctx, policyName, *iamPolicy); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\t// Call cluster-replication policy creation hook to replicate policy to\n\t// other minio clusters.\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType:   madmin.SRIAMItemPolicy,\n\t\tName:   policyName,\n\t\tPolicy: iamPolicyBytes,\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n\n// SetPolicyForUserOrGroup - PUT /minio/admin/v3/set-policy?policy=xxx&user-or-group=?[&is-group]\nfunc (a adminAPIHandlers) SetPolicyForUserOrGroup(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"SetPolicyForUserOrGroup\")\n\n\tdefer logger.AuditLog(ctx, w, r, mustGetClaimsFromToken(r))\n\n\tobjectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.AttachPolicyAdminAction)\n\tif objectAPI == nil {\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tpolicyName := vars[\"policyName\"]\n\tentityName := vars[\"userOrGroup\"]\n\tisGroup := vars[\"isGroup\"] == \"true\"\n\n\tif !isGroup {\n\t\tok, _, err := globalIAMSys.IsTempUser(entityName)\n\t\tif err != nil && err != errNoSuchUser {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\t\treturn\n\t\t}\n\t\tif ok {\n\t\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, errIAMActionNotAllowed), r.URL)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif err := globalIAMSys.PolicyDBSet(ctx, entityName, policyName, isGroup); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n\n\tif err := globalSiteReplicationSys.IAMChangeHook(ctx, madmin.SRIAMItem{\n\t\tType: madmin.SRIAMItemPolicyMapping,\n\t\tPolicyMapping: &madmin.SRPolicyMapping{\n\t\t\tUserOrGroup: entityName,\n\t\t\tIsGroup:     isGroup,\n\t\t\tPolicy:      policyName,\n\t\t},\n\t}); err != nil {\n\t\twriteErrorResponseJSON(ctx, w, toAdminAPIErr(ctx, err), r.URL)\n\t\treturn\n\t}\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go\"\n\tminio \"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/credentials\"\n\tcr \"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\t\"github.com/minio/minio-go/v7/pkg/signer\"\n\t\"github.com/minio/minio/internal/auth\"\n)\n\nconst (\n\ttestDefaultTimeout = 30 * time.Second\n)\n\n// API suite container for IAM\ntype TestSuiteIAM struct {\n\tTestSuiteCommon\n\n\t// Flag to turn on tests for etcd backend IAM\n\twithEtcdBackend bool\n\n\tendpoint string\n\tadm      *madmin.AdminClient\n\tclient   *minio.Client\n}\n\nfunc newTestSuiteIAM(c TestSuiteCommon, withEtcdBackend bool) *TestSuiteIAM {\n\treturn &TestSuiteIAM{TestSuiteCommon: c, withEtcdBackend: withEtcdBackend}\n}\n\nfunc (s *TestSuiteIAM) iamSetup(c *check) {\n\tvar err error\n\t// strip url scheme from endpoint\n\ts.endpoint = strings.TrimPrefix(s.endPoint, \"http://\")\n\tif s.secure {\n\t\ts.endpoint = strings.TrimPrefix(s.endPoint, \"https://\")\n\t}\n\n\ts.adm, err = madmin.New(s.endpoint, s.accessKey, s.secretKey, s.secure)\n\tif err != nil {\n\t\tc.Fatalf(\"error creating admin client: %v\", err)\n\t}\n\t// Set transport, so that TLS is handled correctly.\n\ts.adm.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\ts.client, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(s.accessKey, s.secretKey, \"\"),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating minio client: %v\", err)\n\t}\n}\n\nconst (\n\tEnvTestEtcdBackend = \"ETCD_SERVER\"\n)\n\nfunc (s *TestSuiteIAM) setUpEtcd(c *check, etcdServer string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"etcd\",\n\t\t\"endpoints=\" + etcdServer,\n\t\t\"path_prefix=\" + mustGetUUID(),\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup Etcd for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc (s *TestSuiteIAM) SetUpSuite(c *check) {\n\t// If etcd backend is specified and etcd server is not present, the test\n\t// is skipped.\n\tetcdServer := os.Getenv(EnvTestEtcdBackend)\n\tif s.withEtcdBackend && etcdServer == \"\" {\n\t\tc.Skip(\"Skipping etcd backend IAM test as no etcd server is configured.\")\n\t}\n\n\ts.TestSuiteCommon.SetUpSuite(c)\n\n\ts.iamSetup(c)\n\n\tif s.withEtcdBackend {\n\t\ts.setUpEtcd(c, etcdServer)\n\t}\n}\n\nfunc (s *TestSuiteIAM) RestartIAMSuite(c *check) {\n\ts.TestSuiteCommon.RestartTestServer(c)\n\n\ts.iamSetup(c)\n}\n\nfunc (s *TestSuiteIAM) getAdminClient(c *check, accessKey, secretKey, sessionToken string) *madmin.AdminClient {\n\tmadmClnt, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user admin client: %s\", err)\n\t}\n\tmadmClnt.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\treturn madmClnt\n}\n\nfunc (s *TestSuiteIAM) getUserClient(c *check, accessKey, secretKey, sessionToken string) *minio.Client {\n\tclient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     credentials.NewStaticV4(accessKey, secretKey, sessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"error creating user minio client: %s\", err)\n\t}\n\treturn client\n}\n\nfunc TestIAMInternalIDPServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tsuite := testCase\n\t\t\t\tc := &check{t, testCase.serverType}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.TestUserCreate(c)\n\t\t\t\tsuite.TestUserPolicyEscalationBug(c)\n\t\t\t\tsuite.TestPolicyCreate(c)\n\t\t\t\tsuite.TestCannedPolicies(c)\n\t\t\t\tsuite.TestGroupAddRemove(c)\n\t\t\t\tsuite.TestServiceAccountOpsByAdmin(c)\n\t\t\t\tsuite.TestServiceAccountOpsByUser(c)\n\t\t\t\tsuite.TestAddServiceAccountPerms(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a user.\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr := s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 2. Check new user appears in listing\n\tusersMap, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok := usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user not listed: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountEnabled)\n\n\t// 3. Associate policy and check that user can access\n\terr = s.adm.SetPolicy(ctx, \"readwrite\", accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to set policy: %v\", err)\n\t}\n\tclient := s.getUserClient(c, accessKey, secretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 3.10. Check that user's password can be updated.\n\t_, newSecretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, newSecretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to update user's secret key: %v\", err)\n\t}\n\t// 3.10.1 Check that old password no longer works.\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user was unexpectedly able to create bucket with bad password!\")\n\t}\n\t// 3.10.2 Check that new password works.\n\tclient = s.getUserClient(c, accessKey, newSecretKey, \"\")\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"user could not create bucket: %v\", err)\n\t}\n\n\t// 4. Check that user can be disabled and verify it.\n\terr = s.adm.SetUserStatus(ctx, accessKey, madmin.AccountDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"could not set user account to disabled\")\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\tv, ok = usersMap[accessKey]\n\tif !ok {\n\t\tc.Fatalf(\"user was not listed after disabling: %s\", accessKey)\n\t}\n\tc.Assert(v.Status, madmin.AccountDisabled)\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not disabled!\")\n\t}\n\n\t// 5. Check that user can be deleted and verify it.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\tusersMap, err = s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"error listing: %v\", err)\n\t}\n\t_, ok = usersMap[accessKey]\n\tif ok {\n\t\tc.Fatalf(\"user not deleted: %s\", accessKey)\n\t}\n\terr = client.MakeBucket(ctx, getRandomBucketName(), minio.MakeBucketOptions{})\n\tif err == nil {\n\t\tc.Fatalf(\"user account was not deleted!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestUserPolicyEscalationBug(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 2. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 2.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 2.2 create and associate policy to user\n\tpolicy := \"mypolicy-test-user-update\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 2.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 2.3 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"bucket was deleted unexpectedly or got unexpected err: %v\", err)\n\t}\n\n\t// 3. Craft a request to update the user's permissions\n\tep := s.adm.GetEndpointURL()\n\turlValue := url.Values{}\n\turlValue.Add(\"accessKey\", accessKey)\n\tu, err := url.Parse(fmt.Sprintf(\"%s://%s/minio/admin/v3/add-user?%s\", ep.Scheme, ep.Host, s3utils.QueryEncode(urlValue)))\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected url parse err: %v\", err)\n\t}\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, u.String(), nil)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected new request err: %v\", err)\n\t}\n\treqBodyArg := madmin.UserInfo{\n\t\tSecretKey:  secretKey,\n\t\tPolicyName: \"consoleAdmin\",\n\t\tStatus:     madmin.AccountEnabled,\n\t}\n\tbuf, err := json.Marshal(reqBodyArg)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected json encode err: %v\", err)\n\t}\n\tbuf, err = madmin.EncryptData(secretKey, buf)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected encryption err: %v\", err)\n\t}\n\n\treq.ContentLength = int64(len(buf))\n\tsum := sha256.Sum256(buf)\n\treq.Header.Set(\"X-Amz-Content-Sha256\", hex.EncodeToString(sum[:]))\n\treq.Body = ioutil.NopCloser(bytes.NewReader(buf))\n\treq = signer.SignV4(*req, accessKey, secretKey, \"\", \"\")\n\n\t// 3.1 Execute the request.\n\tresp, err := s.TestSuiteCommon.client.Do(req)\n\tif err != nil {\n\t\tc.Fatalf(\"unexpected request err: %v\", err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tc.Fatalf(\"got unexpected response: %#v\\n\", resp)\n\t}\n\n\t// 3.2 check that user cannot delete the bucket\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil || err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"User was able to escalate privileges (Err=%v)!\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestAddServiceAccountPerms(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\t// 1. Create a policy\n\tpolicy1 := \"deny-svc\"\n\tpolicy2 := \"allow-svc\"\n\tpolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Deny\",\n   \"Action\": [\n    \"admin:CreateServiceAccount\"\n   ]\n  }\n ]\n}`)\n\n\tnewPolicyBytes := []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::testbucket/*\"\n   ]\n  }\n ]\n}`)\n\n\terr := s.adm.AddCannedPolicy(ctx, policy1, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\terr = s.adm.AddCannedPolicy(ctx, policy2, newPolicyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy1+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, \"testbucket\")\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy1, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tadmClnt := s.getAdminClient(c, accessKey, secretKey, \"\")\n\n\t// 3.3 check user does not have explicit permissions to create service account.\n\tc.mustNotCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy1]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy2, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 3.3 check user can create service account implicitly.\n\tc.mustCreateSvcAccount(ctx, accessKey, admClnt)\n\n\t_, ok = ps[policy2]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy1)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n\n\terr = s.adm.RemoveCannedPolicy(ctx, policy2)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestPolicyCreate(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// 1. Create a policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\t// 2. Verify that policy json is validated by server\n\tinvalidPolicyBytes := policyBytes[:len(policyBytes)-1]\n\terr = s.adm.AddCannedPolicy(ctx, policy+\"invalid\", invalidPolicyBytes)\n\tif err == nil {\n\t\tc.Fatalf(\"invalid policy creation success\")\n\t}\n\n\t// 3. Create a user, associate policy and verify access\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\t// 3.1 check that user does not have any access to the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3.2 associate policy to user\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.3 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.4 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. Verify the policy appears in listing\n\tps, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"policy list err: %v\", err)\n\t}\n\t_, ok := ps[policy]\n\tif !ok {\n\t\tc.Fatalf(\"policy was missing!\")\n\t}\n\n\t// 5. Check that policy cannot be deleted when attached to a user.\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err == nil {\n\t\tc.Fatalf(\"policy could be unexpectedly deleted!\")\n\t}\n\n\t// 6. Delete the user and then delete the policy.\n\terr = s.adm.RemoveUser(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"user could not be deleted: %v\", err)\n\t}\n\terr = s.adm.RemoveCannedPolicy(ctx, policy)\n\tif err != nil {\n\t\tc.Fatalf(\"policy del err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestCannedPolicies(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tpolicies, err := s.adm.ListCannedPolicies(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list policies: %v\", err)\n\t}\n\n\tdefaultPolicies := []string{\n\t\t\"readwrite\",\n\t\t\"readonly\",\n\t\t\"writeonly\",\n\t\t\"diagnostics\",\n\t\t\"consoleAdmin\",\n\t}\n\n\tfor _, v := range defaultPolicies {\n\t\tif _, ok := policies[v]; !ok {\n\t\t\tc.Fatalf(\"Failed to find %s in policies list\", v)\n\t\t}\n\t}\n\n\tbucket := getRandomBucketName()\n\terr = s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\n\t// Check that default policies can be overwritten.\n\terr = s.adm.AddCannedPolicy(ctx, \"readwrite\", policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tinfo, err := s.adm.InfoCannedPolicy(ctx, \"readwrite\")\n\tif err != nil {\n\t\tc.Fatalf(\"policy info err: %v\", err)\n\t}\n\n\tinfoStr := string(info)\n\tif !strings.Contains(infoStr, `\"s3:PutObject\"`) || !strings.Contains(infoStr, \":\"+bucket+\"/\") {\n\t\tc.Fatalf(\"policy contains unexpected content!\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestGroupAddRemove(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// 1. Add user to a new group\n\tgroup := \"mygroup\"\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   group,\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to add user to group: %v\", err)\n\t}\n\n\t// 2. Check that user has no access\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 3. Associate policy to group and check user got access.\n\terr = s.adm.SetPolicy(ctx, policy, group, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\t// 3.1 check user has access to bucket\n\tc.mustListObjects(ctx, uClient, bucket)\n\t// 3.2 Check that user cannot exceed their permissions\n\terr = uClient.RemoveBucket(ctx, bucket)\n\tif err == nil {\n\t\tc.Fatalf(\"bucket was deleted!\")\n\t}\n\n\t// 4. List groups and members and verify\n\tgroups, err := s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif !set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group not present!\")\n\t}\n\tgroupInfo, err := s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(set.CreateStringSet(groupInfo.Members...), set.CreateStringSet(accessKey))\n\tc.Assert(groupInfo.Policy, policy)\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\n\t// 5. Disable/enable the group and verify that user access is revoked/restored.\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupDisabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupDisabled))\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.SetGroupStatus(ctx, group, madmin.GroupEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"group set status err: %v\", err)\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Status, string(madmin.GroupEnabled))\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// 6. Verify that group cannot be deleted with users.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"group was removed!\")\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\n\t// 7. Remove user from group and verify access is revoked.\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tMembers:  []string{accessKey},\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\t// 7.1 verify group still exists\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err != nil {\n\t\tc.Fatalf(\"group desc err: %v\", err)\n\t}\n\tc.Assert(groupInfo.Name, group)\n\tc.Assert(len(groupInfo.Members), 0)\n\n\t// 8. Delete group and verify\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:    group,\n\t\tIsRemove: true,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"group update err: %v\", err)\n\t}\n\tgroups, err = s.adm.ListGroups(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"group list err: %v\", err)\n\t}\n\tif set.CreateStringSet(groups...).Contains(group) {\n\t\tc.Fatalf(\"created group still present!\")\n\t}\n\tgroupInfo, err = s.adm.GetGroupDescription(ctx, group)\n\tif err == nil {\n\t\tc.Fatalf(\"group appears to exist\")\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(accessKey, secretKey, \"\"),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, accessKey, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, accessKey, cr.AccessKey, false)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, accessKey, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestServiceAccountOpsByAdmin(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// 1. Create a service account for the user\n\tcr := c.mustCreateSvcAccount(ctx, accessKey, s.adm)\n\n\t// 1.2 Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, s.adm, accessKey, cr.AccessKey)\n\n\t// 1.3 Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, s.adm, accessKey, cr.AccessKey, false)\n\n\t// 2. Check that svc account can access the bucket\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 3. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, s.adm, accessKey, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, s.adm, accessKey, bucket)\n}\n\nfunc (c *check) mustCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) madmin.Credentials {\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to create a user: %v\", err)\n\t}\n\treturn madmin.Credentials{\n\t\tAccessKey: randUser,\n\t\tSecretKey: randPass,\n\t}\n}\n\nfunc (c *check) mustGetIAMUserInfo(ctx context.Context, admClnt *madmin.AdminClient, accessKey string) madmin.UserInfo {\n\tui, err := admClnt.GetUserInfo(ctx, accessKey)\n\tif err != nil {\n\t\tc.Fatalf(\"should be able to get user info: %v\", err)\n\t}\n\treturn ui\n}\n\nfunc (c *check) mustNotCreateIAMUser(ctx context.Context, admClnt *madmin.AdminClient) {\n\trandUser := mustGetUUID()\n\trandPass := mustGetUUID()\n\terr := admClnt.AddUser(ctx, randUser, randPass)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to create a user\")\n\t}\n}\n\nfunc (c *check) mustCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) madmin.Credentials {\n\tcr, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"user should be able to create service accounts %s\", err)\n\t}\n\treturn cr\n}\n\nfunc (c *check) mustNotCreateSvcAccount(ctx context.Context, tgtUser string, admClnt *madmin.AdminClient) {\n\t_, err := admClnt.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: tgtUser,\n\t})\n\tif err == nil {\n\t\tc.Fatalf(\"user was able to add service accounts unexpectedly!\")\n\t}\n}\n\nfunc (c *check) mustNotListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif !ok || v.Err == nil {\n\t\tc.Fatalf(\"user was able to list unexpectedly!\")\n\t}\n}\n\nfunc (c *check) mustListObjects(ctx context.Context, client *minio.Client, bucket string) {\n\tres := client.ListObjects(ctx, bucket, minio.ListObjectsOptions{})\n\tv, ok := <-res\n\tif ok && v.Err != nil {\n\t\tmsg := fmt.Sprintf(\"user was unable to list: %v\", v.Err)\n\t\tc.Fatalf(msg)\n\t}\n}\n\nfunc (c *check) assertSvcAccS3Access(ctx context.Context, s *TestSuiteIAM, cr madmin.Credentials, bucket string) {\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccAppearsInListing(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string) {\n\tlistResp, err := madmClient.ListServiceAccounts(ctx, parentAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to list svc accounts: %v\", err)\n\t}\n\tif !set.CreateStringSet(listResp.Accounts...).Contains(svcAK) {\n\t\tc.Fatalf(\"service account did not appear in listing!\")\n\t}\n}\n\nfunc (c *check) assertSvcAccInfoQueryable(ctx context.Context, madmClient *madmin.AdminClient, parentAK, svcAK string, skipParentUserCheck bool) {\n\tinfoResp, err := madmClient.InfoServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to get svc acc info: %v\", err)\n\t}\n\tif !skipParentUserCheck {\n\t\tc.Assert(infoResp.ParentUser, parentAK)\n\t}\n\tc.Assert(infoResp.AccountStatus, \"on\")\n\tc.Assert(infoResp.ImpliedPolicy, true)\n}\n\n// This test assumes that the policy for `accessKey` allows listing on the given\n// bucket. It creates a session policy that restricts listing on the bucket and\n// then enables it again in a session policy update call.\nfunc (c *check) assertSvcAccSessionPolicyUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\n\t// This policy does not allow listing objects.\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tPolicy:     policyBytes,\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\n\t// This policy allows listing objects.\n\tnewPolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewPolicy: newPolicyBytes,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update session policy for svc acc: %v\", err)\n\t}\n\tc.mustListObjects(ctx, svcClient, bucket)\n}\n\nfunc (c *check) assertSvcAccSecretKeyAndStatusUpdate(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\t_, svcSK2 := mustGenerateCredentials(c)\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewSecretKey: svcSK2,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\t// old creds should not work:\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n\t// new creds work:\n\tsvcClient2 := s.getUserClient(c, cr.AccessKey, svcSK2, \"\")\n\tc.mustListObjects(ctx, svcClient2, bucket)\n\n\t// update status to disabled\n\terr = madmClient.UpdateServiceAccount(ctx, svcAK, madmin.UpdateServiceAccountReq{\n\t\tNewStatus: \"off\",\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to update secret key for svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient2, bucket)\n}\n\nfunc (c *check) assertSvcAccDeletion(ctx context.Context, s *TestSuiteIAM, madmClient *madmin.AdminClient, accessKey, bucket string) {\n\tsvcAK, svcSK := mustGenerateCredentials(c)\n\tcr, err := madmClient.AddServiceAccount(ctx, madmin.AddServiceAccountReq{\n\t\tTargetUser: accessKey,\n\t\tAccessKey:  svcAK,\n\t\tSecretKey:  svcSK,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to create svc acc: %v\", err)\n\t}\n\tsvcClient := s.getUserClient(c, cr.AccessKey, cr.SecretKey, \"\")\n\tc.mustListObjects(ctx, svcClient, bucket)\n\n\terr = madmClient.DeleteServiceAccount(ctx, svcAK)\n\tif err != nil {\n\t\tc.Fatalf(\"unable to delete svc acc: %v\", err)\n\t}\n\tc.mustNotListObjects(ctx, svcClient, bucket)\n}\n\nfunc mustGenerateCredentials(c *check) (string, string) {\n\tak, sk, err := auth.GenerateCredentials()\n\tif err != nil {\n\t\tc.Fatalf(\"unable to generate credentials: %v\", err)\n\t}\n\treturn ak, sk\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/minio/madmin-go\"\n\tminio \"github.com/minio/minio-go/v7\"\n\tcr \"github.com/minio/minio-go/v7/pkg/credentials\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n)\n\nfunc runAllIAMSTSTests(suite *TestSuiteIAM, c *check) {\n\tsuite.SetUpSuite(c)\n\t// The STS for root test needs to be the first one after setup.\n\tsuite.TestSTSForRoot(c)\n\tsuite.TestSTS(c)\n\tsuite.TestSTSWithGroupPolicy(c)\n\tsuite.TearDownSuite(c)\n}\n\nfunc TestIAMInternalIDPSTSServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\trunAllIAMSTSTests(testCase, &check{t, testCase.serverType})\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, accessKey, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestSTSWithGroupPolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Create policy, user and associate policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\taccessKey, secretKey := mustGenerateCredentials(c)\n\terr = s.adm.SetUser(ctx, accessKey, secretKey, madmin.AccountEnabled)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set user: %v\", err)\n\t}\n\n\t// confirm that the user is unable to access the bucket - we have not\n\t// yet set any policy\n\tuClient := s.getUserClient(c, accessKey, secretKey, \"\")\n\tc.mustNotListObjects(ctx, uClient, bucket)\n\n\terr = s.adm.UpdateGroupMembers(ctx, madmin.GroupAddRemove{\n\t\tGroup:   \"test-group\",\n\t\tMembers: []string{accessKey},\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"unable to add user to group: %v\", err)\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, \"test-group\", true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\t// confirm that the user is able to access the bucket - permission comes\n\t// from group.\n\tc.mustListObjects(ctx, uClient, bucket)\n\n\t// Create STS user.\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: accessKey,\n\t\t\tSecretKey: secretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\t// Check that STS user client has access coming from parent user's\n\t// group.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\n// TestSTSForRoot - needs to be the first test after server setup due to the\n// buckets list check.\nfunc (s *TestSuiteIAM) TestSTSForRoot(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\tassumeRole := cr.STSAssumeRole{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tOptions: cr.STSAssumeRoleOptions{\n\t\t\tAccessKey: globalActiveCred.AccessKey,\n\t\t\tSecretKey: globalActiveCred.SecretKey,\n\t\t\tLocation:  \"\",\n\t\t},\n\t}\n\n\tvalue, err := assumeRole.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"err calling assumeRole: %v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that a bucket can be created\n\tbucket2 := getRandomBucketName()\n\terr = minioClient.MakeBucket(ctx, bucket2, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket creat error: %v\", err)\n\t}\n\n\t// Validate that admin APIs can be called - create an madmin client with\n\t// user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\taccInfo, err := userAdmClient.AccountInfo(ctx, madmin.AccountOpts{})\n\tif err != nil {\n\t\tc.Fatalf(\"root user STS should be able to get account info: %v\", err)\n\t}\n\n\tgotBuckets := set.NewStringSet()\n\tfor _, b := range accInfo.Buckets {\n\t\tgotBuckets.Add(b.Name)\n\t\tif !(b.Access.Read && b.Access.Write) {\n\t\t\tc.Fatalf(\"root user should have read and write access to bucket: %v\", b.Name)\n\t\t}\n\t}\n\tshouldHaveBuckets := set.CreateStringSet(bucket2, bucket)\n\tif !gotBuckets.Equals(shouldHaveBuckets) {\n\t\tc.Fatalf(\"root user should have access to all buckets\")\n\t}\n}\n\n// SetUpLDAP - expects to setup an LDAP test server using the test LDAP\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpLDAP(c *check, serverAddr string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_ldap\",\n\t\tfmt.Sprintf(\"server_addr=%s\", serverAddr),\n\t\t\"server_insecure=on\",\n\t\t\"lookup_bind_dn=cn=admin,dc=min,dc=io\",\n\t\t\"lookup_bind_password=admin\",\n\t\t\"user_dn_search_base_dn=dc=min,dc=io\",\n\t\t\"user_dn_search_filter=(uid=%s)\",\n\t\t\"group_search_base_dn=ou=swengg,dc=min,dc=io\",\n\t\t\"group_search_filter=(&(objectclass=groupofnames)(member=%d))\",\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup LDAP for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nconst (\n\tEnvTestLDAPServer = \"LDAP_TEST_SERVER\"\n)\n\nfunc TestIAMWithLDAPServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\tldapServer := os.Getenv(EnvTestLDAPServer)\n\t\t\t\tif ldapServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping LDAP test as no LDAP server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpLDAP(c, ldapServer)\n\t\t\t\tsuite.TestLDAPSTS(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccounts(c)\n\t\t\t\tsuite.TestLDAPSTSServiceAccountsWithGroups(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create STS cred with no associated policy!\")\n\t}\n\n\t// Attempting to set a non-existent policy should fail.\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy+\"x\", userDN, false)\n\tif err == nil {\n\t\tc.Fatalf(\"should not be able to set non-existent policy\")\n\t}\n\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that user listing does not return any entries\n\tusersList, err := s.adm.ListUsers(ctx)\n\tif err != nil {\n\t\tc.Fatalf(\"list users should not fail: %v\", err)\n\t}\n\tif len(usersList) > 0 {\n\t\tc.Fatalf(\"expected listing to be empty: %v\", usersList)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n\n\t// Remove the policy assignment on the user DN:\n\terr = s.adm.SetPolicy(ctx, \"\", userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to remove policy setting: %v\", err)\n\t}\n\n\t_, err = ldapID.Retrieve()\n\tif err == nil {\n\t\tc.Fatalf(\"Expected to fail to create a user with no associated policy!\")\n\t}\n\n\t// Set policy via group and validate policy assignment.\n\tgroupDN := \"cn=projectb,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set group policy: %v\", err)\n\t}\n\n\tvalue, err = ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err = minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tc.Assert(err.Error(), \"Access Denied.\")\n}\n\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccounts(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tuserDN := \"uid=dillon,ou=people,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, userDN, false)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\n// In this test, the parent users gets their permissions from a group, rather\n// than having a policy set directly on them.\nfunc (s *TestSuiteIAM) TestLDAPSTSServiceAccountsWithGroups(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Create policy\n\tpolicy := \"mypolicy\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tgroupDN := \"cn=projecta,ou=groups,ou=swengg,dc=min,dc=io\"\n\terr = s.adm.SetPolicy(ctx, policy, groupDN, true)\n\tif err != nil {\n\t\tc.Fatalf(\"Unable to set policy: %v\", err)\n\t}\n\n\tldapID := cr.LDAPIdentity{\n\t\tClient:       s.TestSuiteCommon.client,\n\t\tSTSEndpoint:  s.endPoint,\n\t\tLDAPUsername: \"dillon\",\n\t\tLDAPPassword: \"dillon\",\n\t}\n\n\tvalue, err := ldapID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Check that the LDAP sts cred is actually working.\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTS(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\t// fmt.Printf(\"TOKEN: %s\\n\", token)\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n\n\t// Validate that the client cannot remove any objects\n\terr = minioClient.RemoveObject(ctx, bucket, \"someobject\", minio.RemoveObjectOptions{})\n\tif err.Error() != \"Access Denied.\" {\n\t\tc.Fatalf(\"unexpected non-access-denied err: %v\", err)\n\t}\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSAddUser(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\tc.mustNotCreateIAMUser(ctx, userAdmClient)\n\n\t// Create admin user policy.\n\tpolicyBytes = []byte(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"admin:*\"\n   ]\n  }\n ]\n}`)\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tcr := c.mustCreateIAMUser(ctx, userAdmClient)\n\n\tuserInfo := c.mustGetIAMUserInfo(ctx, userAdmClient, cr.AccessKey)\n\tc.Assert(userInfo.Status, madmin.AccountEnabled)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAcc(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\t// Create policy - with name as one of the groups in OpenID the user is\n\t// a member of.\n\tpolicy := \"projecta\"\n\tpolicyBytes := []byte(fmt.Sprintf(`{\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n  {\n   \"Effect\": \"Allow\",\n   \"Action\": [\n    \"s3:PutObject\",\n    \"s3:GetObject\",\n    \"s3:ListBucket\"\n   ],\n   \"Resource\": [\n    \"arn:aws:s3:::%s/*\"\n   ]\n  }\n ]\n}`, bucket))\n\terr = s.adm.AddCannedPolicy(ctx, policy, policyBytes)\n\tif err != nil {\n\t\tc.Fatalf(\"policy add error: %v\", err)\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 6. Check that service account cannot be created for some other user.\n\tc.mustNotCreateSvcAccount(ctx, globalActiveCred.AccessKey, userAdmClient)\n}\n\nvar testAppParams = OpenIDClientAppParams{\n\tClientID:     \"minio-client-app\",\n\tClientSecret: \"minio-client-app-secret\",\n\tProviderURL:  \"http://127.0.0.1:5556/dex\",\n\tRedirectURL:  \"http://127.0.0.1:10000/oauth_callback\",\n}\n\nconst (\n\tEnvTestOpenIDServer = \"OPENID_TEST_SERVER\"\n)\n\n// SetUpOpenID - expects to setup an OpenID test server using the test OpenID\n// container and canned data from https://github.com/minio/minio-ldap-testing\nfunc (s *TestSuiteIAM) SetUpOpenID(c *check, serverAddr string, rolePolicy string) {\n\tctx, cancel := context.WithTimeout(context.Background(), testDefaultTimeout)\n\tdefer cancel()\n\n\tconfigCmds := []string{\n\t\t\"identity_openid\",\n\t\tfmt.Sprintf(\"config_url=%s/.well-known/openid-configuration\", serverAddr),\n\t\t\"client_id=minio-client-app\",\n\t\t\"client_secret=minio-client-app-secret\",\n\t\t\"scopes=openid,groups\",\n\t\t\"redirect_uri=http://127.0.0.1:10000/oauth_callback\",\n\t}\n\tif rolePolicy != \"\" {\n\t\tconfigCmds = append(configCmds, fmt.Sprintf(\"role_policy=%s\", rolePolicy))\n\t} else {\n\t\tconfigCmds = append(configCmds, \"claim_name=groups\")\n\t}\n\t_, err := s.adm.SetConfigKV(ctx, strings.Join(configCmds, \" \"))\n\tif err != nil {\n\t\tc.Fatalf(\"unable to setup OpenID for tests: %v\", err)\n\t}\n\n\ts.RestartIAMSuite(c)\n}\n\nfunc TestIAMWithOpenIDServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"\")\n\t\t\t\tsuite.TestOpenIDSTS(c)\n\t\t\t\tsuite.TestOpenIDServiceAcc(c)\n\t\t\t\tsuite.TestOpenIDSTSAddUser(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestIAMWithOpenIDWithRolePolicyServerSuite(t *testing.T) {\n\tbaseTestCases := []TestSuiteCommon{\n\t\t// Init and run test on FS backend with signature v4.\n\t\t{serverType: \"FS\", signer: signerV4},\n\t\t// Init and run test on FS backend, with tls enabled.\n\t\t{serverType: \"FS\", signer: signerV4, secure: true},\n\t\t// Init and run test on Erasure backend.\n\t\t{serverType: \"Erasure\", signer: signerV4},\n\t\t// Init and run test on ErasureSet backend.\n\t\t{serverType: \"ErasureSet\", signer: signerV4},\n\t}\n\ttestCases := []*TestSuiteIAM{}\n\tfor _, bt := range baseTestCases {\n\t\ttestCases = append(testCases,\n\t\t\tnewTestSuiteIAM(bt, false),\n\t\t\tnewTestSuiteIAM(bt, true),\n\t\t)\n\t}\n\tfor i, testCase := range testCases {\n\t\tetcdStr := \"\"\n\t\tif testCase.withEtcdBackend {\n\t\t\tetcdStr = \" (with etcd backend)\"\n\t\t}\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"Test: %d, ServerType: %s%s\", i+1, testCase.serverType, etcdStr),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tc := &check{t, testCase.serverType}\n\t\t\t\tsuite := testCase\n\n\t\t\t\topenIDServer := os.Getenv(EnvTestOpenIDServer)\n\t\t\t\tif openIDServer == \"\" {\n\t\t\t\t\tc.Skip(\"Skipping OpenID test as no OpenID server is provided.\")\n\t\t\t\t}\n\n\t\t\t\tsuite.SetUpSuite(c)\n\t\t\t\tsuite.SetUpOpenID(c, openIDServer, \"readwrite\")\n\t\t\t\tsuite.TestOpenIDSTSWithRolePolicy(c)\n\t\t\t\tsuite.TestOpenIDServiceAccWithRolePolicy(c)\n\t\t\t\tsuite.TearDownSuite(c)\n\t\t\t},\n\t\t)\n\t}\n}\n\nconst (\n\ttestRoleARN = \"arn:minio:iam:::role/nOybJqMNzNmroqEKq5D0EUsRZw0\"\n)\n\nfunc (s *TestSuiteIAM) TestOpenIDSTSWithRolePolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\t// fmt.Printf(\"value: %#v\\n\", value)\n\n\tminioClient, err := minio.New(s.endpoint, &minio.Options{\n\t\tCreds:     cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure:    s.secure,\n\t\tTransport: s.TestSuiteCommon.client.Transport,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Error initializing client: %v\", err)\n\t}\n\n\t// Validate that the client from sts creds can access the bucket.\n\tc.mustListObjects(ctx, minioClient, bucket)\n}\n\nfunc (s *TestSuiteIAM) TestOpenIDServiceAccWithRolePolicy(c *check) {\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\n\tbucket := getRandomBucketName()\n\terr := s.client.MakeBucket(ctx, bucket, minio.MakeBucketOptions{})\n\tif err != nil {\n\t\tc.Fatalf(\"bucket create error: %v\", err)\n\t}\n\n\t// Generate web identity STS token by interacting with OpenID IDP.\n\ttoken, err := MockOpenIDTestUserInteraction(ctx, testAppParams, \"dillon@example.io\", \"dillon\")\n\tif err != nil {\n\t\tc.Fatalf(\"mock user err: %v\", err)\n\t}\n\n\twebID := cr.STSWebIdentity{\n\t\tClient:      s.TestSuiteCommon.client,\n\t\tSTSEndpoint: s.endPoint,\n\t\tGetWebIDTokenExpiry: func() (*cr.WebIdentityToken, error) {\n\t\t\treturn &cr.WebIdentityToken{\n\t\t\t\tToken: token,\n\t\t\t}, nil\n\t\t},\n\t\tRoleARN: testRoleARN,\n\t}\n\n\tvalue, err := webID.Retrieve()\n\tif err != nil {\n\t\tc.Fatalf(\"Expected to generate STS creds, got err: %#v\", err)\n\t}\n\n\t// Create an madmin client with user creds\n\tuserAdmClient, err := madmin.NewWithOptions(s.endpoint, &madmin.Options{\n\t\tCreds:  cr.NewStaticV4(value.AccessKeyID, value.SecretAccessKey, value.SessionToken),\n\t\tSecure: s.secure,\n\t})\n\tif err != nil {\n\t\tc.Fatalf(\"Err creating user admin client: %v\", err)\n\t}\n\tuserAdmClient.SetCustomTransport(s.TestSuiteCommon.client.Transport)\n\n\t// Create svc acc\n\tcr := c.mustCreateSvcAccount(ctx, value.AccessKeyID, userAdmClient)\n\n\t// 1. Check that svc account appears in listing\n\tc.assertSvcAccAppearsInListing(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey)\n\n\t// 2. Check that svc account info can be queried\n\tc.assertSvcAccInfoQueryable(ctx, userAdmClient, value.AccessKeyID, cr.AccessKey, true)\n\n\t// 3. Check S3 access\n\tc.assertSvcAccS3Access(ctx, s, cr, bucket)\n\n\t// 4. Check that svc account can restrict the policy, and that the\n\t// session policy can be updated.\n\tc.assertSvcAccSessionPolicyUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 4. Check that service account's secret key and account status can be\n\t// updated.\n\tc.assertSvcAccSecretKeyAndStatusUpdate(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n\n\t// 5. Check that service account can be deleted.\n\tc.assertSvcAccDeletion(ctx, s, userAdmClient, value.AccessKeyID, bucket)\n}\n"], "filenames": ["cmd/admin-handlers-users.go", "cmd/admin-handlers-users_test.go", "cmd/sts-handlers_test.go"], "buggy_code_start_loc": [608, 892, 627], "buggy_code_end_loc": [609, 892, 981], "fixing_code_start_loc": [607, 893, 628], "fixing_code_end_loc": [607, 896, 991], "type": "CWE-269", "message": "MinIO is a High Performance Object Storage released under GNU Affero General Public License v3.0. A security issue was found where an non-admin user is able to create service accounts for root or other admin users and then is able to assume their access policies via the generated credentials. This in turn allows the user to escalate privilege to that of the root user. This vulnerability has been resolved in pull request #14729 and is included in `RELEASE.2022-04-12T06-55-35Z`. Users unable to upgrade may workaround this issue by explicitly adding a `admin:CreateServiceAccount` deny policy, however, this, in turn, denies the user the ability to create their own service accounts as well.", "other": {"cve": {"id": "CVE-2022-24842", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-12T18:15:09.690", "lastModified": "2022-04-23T02:11:08.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MinIO is a High Performance Object Storage released under GNU Affero General Public License v3.0. A security issue was found where an non-admin user is able to create service accounts for root or other admin users and then is able to assume their access policies via the generated credentials. This in turn allows the user to escalate privilege to that of the root user. This vulnerability has been resolved in pull request #14729 and is included in `RELEASE.2022-04-12T06-55-35Z`. Users unable to upgrade may workaround this issue by explicitly adding a `admin:CreateServiceAccount` deny policy, however, this, in turn, denies the user the ability to create their own service accounts as well."}, {"lang": "es", "value": "MinIO es un almacenamiento de objetos de alto rendimiento publicado bajo la Licencia P\u00fablica General Affero versi\u00f3n v3.0 de GNU. Se ha encontrado un problema de seguridad en el que un usuario no administrador es capaz de crear cuentas de servicio para el usuario root u otros usuarios administradores y luego es capaz de asumir sus pol\u00edticas de acceso por medio de las credenciales generadas. Esto, a su vez, permite al usuario escalar sus privilegios a los del usuario root. Esta vulnerabilidad ha sido resuelta en el pull request #14729 y es incluida en 'RELEASE.2022-04-12T06-55-35Z\". Los usuarios que no puedan actualizar pueden mitigar este problema al a\u00f1adir expl\u00edcitamente una pol\u00edtica de denegaci\u00f3n \"admin:CreateServiceAccount\", pero esto, a su vez, deniega al usuario la capacidad de crear sus propias cuentas de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionStartIncluding": "2021-12-09t06-19-41z", "versionEndExcluding": "2022-04-12t06-55-35z", "matchCriteriaId": "3D2E3996-716E-4C51-A15F-6420BD59FA82"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/66b14a0d32684d527ae8018dc6d9d46ccce58ae3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/14729", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-2j69-jjmg-534q", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/66b14a0d32684d527ae8018dc6d9d46ccce58ae3"}}