{"buggy_code": ["#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gd_tga.h\"\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n/*!\t\\brief Creates a gdImage from a TGA file\n *\tCreates a gdImage from a TGA binary file via a gdIOCtx.\n *\t\\param infile Pointer to TGA binary file\n *\t\\return gdImagePtr\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTga(FILE *fp)\n{\n\tgdImagePtr image;\n\tgdIOCtx* in = gdNewFileCtx(fp);\n\tif (in == NULL) return NULL;\n\timage = gdImageCreateFromTgaCtx(in);\n\tin->gd_free( in );\n\treturn image;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromTgaCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n\n/*!\t\\brief Creates a gdImage from a gdIOCtx\n *\tCreates a gdImage from a gdIOCtx referencing a TGA binary file.\n *\t\\param ctx Pointer to a gdIOCtx structure\n *\t\\return gdImagePtr\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}\n\n/*!\t\\brief Reads a TGA header.\n *\tReads the header block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 1 on sucess, -1 on failure\n */\nint read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Reads a TGA image data into buffer.\n *\tReads the image data block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 0 on sucess, -1 on failure\n */\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tuint8_t* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint j = 0;\n\tuint8_t encoded_pixels;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < image_block_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif (encoded_pixels != 0) {\n\t\t\t\t\n\t\t\t\t\tif (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {\n\t\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n\t\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif (encoded_pixels != 0) {\n\t\t\t\t\n\t\t\t\t\tif (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {\n\t\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n\t\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer_caret += pixel_block_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Cleans up a TGA structure.\n *\tDereferences the bitmap referenced in a TGA structure, then the structure itself\n *\t\\param tga Pointer to TGA structure\n */\nvoid free_tga(oTga * tga)\n{\n\tif (tga) {\n\t\tif (tga->ident)\n\t\t\tgdFree(tga->ident);\n\t\tif (tga->bitmap)\n\t\t\tgdFree(tga->bitmap);\n\t\tgdFree(tga);\n\t}\n}\n"], "fixing_code": ["#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gd_tga.h\"\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n/*!\t\\brief Creates a gdImage from a TGA file\n *\tCreates a gdImage from a TGA binary file via a gdIOCtx.\n *\t\\param infile Pointer to TGA binary file\n *\t\\return gdImagePtr\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTga(FILE *fp)\n{\n\tgdImagePtr image;\n\tgdIOCtx* in = gdNewFileCtx(fp);\n\tif (in == NULL) return NULL;\n\timage = gdImageCreateFromTgaCtx(in);\n\tin->gd_free( in );\n\treturn image;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromTgaCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n\n/*!\t\\brief Creates a gdImage from a gdIOCtx\n *\tCreates a gdImage from a gdIOCtx referencing a TGA binary file.\n *\t\\param ctx Pointer to a gdIOCtx structure\n *\t\\return gdImagePtr\n */\nBGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\t/*\tint pixel_block_size = 0;\n\t\tint image_block_size = 0; */\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\t/*TODO: Will this be used?\n\t\tpixel_block_size = tga->bits / 8;\n\t\timage_block_size = (tga->width * tga->height) * pixel_block_size;\n\t*/\n\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\n\t/*!\t\\brief Populate GD image object\n\t *  Copy the pixel data from our tga bitmap buffer into the GD image\n\t *  Disable blending and save the alpha channel per default\n\t */\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\n\t/* TODO: use alphabits as soon as we support 24bit and other alpha bps (ie != 8bits) */\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\n\tfree_tga(tga);\n\n\treturn image;\n}\n\n/*!\t\\brief Reads a TGA header.\n *\tReads the header block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 1 on sucess, -1 on failure\n */\nint read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Reads a TGA image data into buffer.\n *\tReads the image data block from a binary TGA file populating the referenced TGA structure.\n *\t\\param ctx Pointer to TGA binary file\n *\t\\param tga Pointer to TGA structure\n *\t\\return int 0 on sucess, -1 on failure\n */\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tuint8_t* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tuint8_t encoded_pixels;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < image_block_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & !TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n/*!\t\\brief Cleans up a TGA structure.\n *\tDereferences the bitmap referenced in a TGA structure, then the structure itself\n *\t\\param tga Pointer to TGA structure\n */\nvoid free_tga(oTga * tga)\n{\n\tif (tga) {\n\t\tif (tga->ident)\n\t\t\tgdFree(tga->ident);\n\t\tif (tga->bitmap)\n\t\t\tgdFree(tga->bitmap);\n\t\tgdFree(tga);\n\t}\n}\n"], "filenames": ["src/gd_tga.c"], "buggy_code_start_loc": [199], "buggy_code_end_loc": [319], "fixing_code_start_loc": [198], "fixing_code_end_loc": [310], "type": "CWE-125", "message": "The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA image.", "other": {"cve": {"id": "CVE-2016-6905", "sourceIdentifier": "cve@mitre.org", "published": "2016-10-03T21:59:05.957", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA image."}, {"lang": "es", "value": "La funci\u00f3n read_image_tga en gd_tga.c en el GD Graphics Library (tambi\u00e9n conocido como libgd) en versiones anteriores a 2.2.3 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de fuera de l\u00edmites) a trav\u00e9s de una imagen TGA manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.2", "matchCriteriaId": "CABE614C-FFD3-4B02-B5DF-658185F8D874"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}], "references": [{"url": "http://libgd.github.io/release-2.2.3.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00121.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-09/msg00078.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/23/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91743", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/libgd/libgd/commit/01c61f8ab110a77ae64b5ca67c244c728c506f03", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/libgd/libgd/commit/3c2b605d72e8b080dace1d98a6e50b46c1d12186", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/libgd/libgd/issues/248", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/libgd/libgd/pull/251", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/01c61f8ab110a77ae64b5ca67c244c728c506f03"}}