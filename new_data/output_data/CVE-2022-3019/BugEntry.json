{"buggy_code": ["import {\n  Entity,\n  Column,\n  PrimaryGeneratedColumn,\n  CreateDateColumn,\n  UpdateDateColumn,\n  OneToOne,\n  JoinColumn,\n  BaseEntity,\n  ManyToOne,\n  ManyToMany,\n  JoinTable,\n} from 'typeorm';\nimport { User } from './user.entity';\nimport { Thread } from './thread.entity';\nimport { Organization } from './organization.entity';\n\n@Entity({ name: 'comments' })\nexport class Comment extends BaseEntity {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'thread_id' })\n  threadId: string;\n\n  @Column({ name: 'comment' })\n  comment: string;\n\n  @Column({ default: false, name: 'is_read' })\n  isRead: boolean;\n\n  @Column({ name: 'app_versions_id' })\n  appVersionsId: string;\n\n  @Column({ name: 'user_id' })\n  userId: string;\n\n  @Column({ name: 'organization_id' })\n  organizationId: string;\n\n  @CreateDateColumn({ default: () => 'now()', name: 'created_at' })\n  createdAt: Date;\n\n  @UpdateDateColumn({ default: () => 'now()', name: 'updated_at' })\n  updatedAt: Date;\n\n  @OneToOne(() => User, (user) => user.id, { eager: true })\n  @JoinColumn({ name: 'user_id' })\n  user: User;\n\n  @ManyToMany(() => User, (user) => user.id, {\n    cascade: true,\n  })\n  @JoinTable({\n    name: 'comment_users',\n    joinColumn: {\n      name: 'comment_id',\n    },\n    inverseJoinColumn: {\n      name: 'user_id',\n    },\n  })\n  mentionedUsers: User[];\n\n  @OneToOne(() => Thread, (thread) => thread.id)\n  @JoinColumn({ name: 'thread_id' })\n  thread: Thread;\n\n  @ManyToOne(() => User, (app) => app.id)\n  @JoinColumn({ name: 'organization_id' })\n  organization: Organization;\n}\n", "import { Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\n\nimport { Comment } from '../entities/comment.entity';\nimport { CommentRepository } from '../repositories/comment.repository';\nimport { CreateCommentDto, UpdateCommentDto } from '../dto/comment.dto';\nimport { groupBy, head } from 'lodash';\nimport { EmailService } from './email.service';\nimport { Repository } from 'typeorm';\nimport { AppVersion } from 'src/entities/app_version.entity';\nimport { User } from 'src/entities/user.entity';\nimport { CommentUsers } from 'src/entities/comment_user.entity';\n\n@Injectable()\nexport class CommentService {\n  constructor(\n    @InjectRepository(CommentRepository)\n    private commentRepository: CommentRepository,\n    @InjectRepository(AppVersion)\n    private appVersionsRepository: Repository<AppVersion>,\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(CommentUsers)\n    private commentUsersRepository: Repository<CommentUsers>,\n    private emailService: EmailService\n  ) {}\n\n  public async createComment(createCommentDto: CreateCommentDto, user: User): Promise<Comment> {\n    try {\n      const comment = await this.commentRepository.createComment(createCommentDto, user.id, user.organizationId);\n\n      // todo: move mentioned user emails to a queue service\n      const [appLink, commentLink, appName] = await this.getAppLinks(createCommentDto.appVersionsId, comment);\n\n      for (const userId of createCommentDto.mentionedUsers) {\n        const mentionedUser = await this.usersRepository.findOne({ where: { id: userId }, relations: ['avatar'] });\n        if (!mentionedUser) return null; // todo: invite user\n        void this.emailService.sendCommentMentionEmail(\n          mentionedUser.email,\n          user.firstName,\n          appName,\n          appLink,\n          commentLink,\n          comment.createdAt.toUTCString(),\n          comment.comment,\n          mentionedUser.avatar?.data.toString('base64')\n        );\n        void this.commentUsersRepository.save(\n          this.commentUsersRepository.create({ commentId: comment.id, userId: mentionedUser.id })\n        );\n      }\n      return comment;\n    } catch (error) {\n      throw new InternalServerErrorException(error);\n    }\n  }\n\n  private async getAppLinks(appVersionsId: string, comment: Comment) {\n    const appVersion = await this.appVersionsRepository.findOne({ where: { id: appVersionsId }, relations: ['app'] });\n    const appLink = `${process.env.TOOLJET_HOST}/apps/${appVersion.app.id}`;\n    const commentLink = `${appLink}?threadId=${comment.threadId}&commentId=${comment.id}`;\n\n    return [appLink, commentLink, appVersion.app.name];\n  }\n\n  public async getComments(threadId: string, appVersionsId: string): Promise<Comment[]> {\n    return await this.commentRepository.find({\n      where: {\n        threadId,\n        appVersionsId,\n      },\n      order: {\n        createdAt: 'ASC',\n      },\n    });\n  }\n\n  public async getOrganizationComments(organizationId: string, appVersionsId: string): Promise<Comment[]> {\n    return await this.commentRepository.find({\n      where: {\n        organizationId,\n        appVersionsId,\n      },\n      order: {\n        createdAt: 'ASC',\n      },\n    });\n  }\n\n  public async getNotifications(\n    appId: string,\n    userId: string,\n    isResolved = false,\n    appVersionsId: string\n  ): Promise<Comment[]> {\n    const comments = await this.commentRepository.find({\n      where: {\n        thread: { appId, isResolved },\n        appVersionsId,\n      },\n      order: {\n        createdAt: 'DESC',\n      },\n      relations: ['thread'],\n    });\n\n    const groupedComments = groupBy(comments, 'threadId');\n\n    const _comments = [];\n\n    Object.keys(groupedComments).map((k) => {\n      _comments.push({ comment: head(groupedComments[k]), count: groupedComments[k].length });\n    });\n\n    return _comments;\n  }\n\n  public async getComment(commentId: string): Promise<Comment> {\n    const foundComment = await this.commentRepository.findOne({ where: { id: commentId } });\n    if (!foundComment) {\n      throw new NotFoundException('Comment not found');\n    }\n    return foundComment;\n  }\n\n  public async editComment(commentId: string, updateCommentDto: UpdateCommentDto): Promise<Comment> {\n    const editedComment = await this.commentRepository.findOne({ where: { id: commentId } });\n    if (!editedComment) {\n      throw new NotFoundException('Comment not found');\n    }\n    return this.commentRepository.editComment(updateCommentDto, editedComment);\n  }\n\n  public async deleteComment(commentId: string): Promise<void> {\n    await this.commentRepository.delete(commentId);\n  }\n}\n"], "fixing_code": ["import {\n  Entity,\n  Column,\n  PrimaryGeneratedColumn,\n  CreateDateColumn,\n  UpdateDateColumn,\n  OneToOne,\n  JoinColumn,\n  BaseEntity,\n  ManyToOne,\n  ManyToMany,\n  JoinTable,\n} from 'typeorm';\nimport { User } from './user.entity';\nimport { Thread } from './thread.entity';\nimport { Organization } from './organization.entity';\n\n@Entity({ name: 'comments' })\nexport class Comment extends BaseEntity {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'thread_id' })\n  threadId: string;\n\n  @Column({ name: 'comment' })\n  comment: string;\n\n  @Column({ default: false, name: 'is_read' })\n  isRead: boolean;\n\n  @Column({ name: 'app_versions_id' })\n  appVersionsId: string;\n\n  @Column({ name: 'user_id' })\n  userId: string;\n\n  @Column({ name: 'organization_id' })\n  organizationId: string;\n\n  @CreateDateColumn({ default: () => 'now()', name: 'created_at' })\n  createdAt: Date;\n\n  @UpdateDateColumn({ default: () => 'now()', name: 'updated_at' })\n  updatedAt: Date;\n\n  @OneToOne(() => User, (user) => user.id)\n  @JoinColumn({ name: 'user_id' })\n  user: User;\n\n  @ManyToMany(() => User, (user) => user.id, {\n    cascade: true,\n  })\n  @JoinTable({\n    name: 'comment_users',\n    joinColumn: {\n      name: 'comment_id',\n    },\n    inverseJoinColumn: {\n      name: 'user_id',\n    },\n  })\n  mentionedUsers: User[];\n\n  @OneToOne(() => Thread, (thread) => thread.id)\n  @JoinColumn({ name: 'thread_id' })\n  thread: Thread;\n\n  @ManyToOne(() => User, (app) => app.id)\n  @JoinColumn({ name: 'organization_id' })\n  organization: Organization;\n}\n", "import { Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\n\nimport { Comment } from '../entities/comment.entity';\nimport { CommentRepository } from '../repositories/comment.repository';\nimport { CreateCommentDto, UpdateCommentDto } from '../dto/comment.dto';\nimport { groupBy, head } from 'lodash';\nimport { EmailService } from './email.service';\nimport { createQueryBuilder, Repository } from 'typeorm';\nimport { AppVersion } from 'src/entities/app_version.entity';\nimport { User } from 'src/entities/user.entity';\nimport { CommentUsers } from 'src/entities/comment_user.entity';\n\n@Injectable()\nexport class CommentService {\n  constructor(\n    @InjectRepository(CommentRepository)\n    private commentRepository: CommentRepository,\n    @InjectRepository(AppVersion)\n    private appVersionsRepository: Repository<AppVersion>,\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(CommentUsers)\n    private commentUsersRepository: Repository<CommentUsers>,\n    private emailService: EmailService\n  ) { }\n\n  public async createComment(createCommentDto: CreateCommentDto, user: User): Promise<Comment> {\n    try {\n      const comment = await this.commentRepository.createComment(createCommentDto, user.id, user.organizationId);\n\n      // todo: move mentioned user emails to a queue service\n      const [appLink, commentLink, appName] = await this.getAppLinks(createCommentDto.appVersionsId, comment);\n\n      for (const userId of createCommentDto.mentionedUsers) {\n        const mentionedUser = await this.usersRepository.findOne({ where: { id: userId }, relations: ['avatar'] });\n        if (!mentionedUser) return null; // todo: invite user\n        void this.emailService.sendCommentMentionEmail(\n          mentionedUser.email,\n          user.firstName,\n          appName,\n          appLink,\n          commentLink,\n          comment.createdAt.toUTCString(),\n          comment.comment,\n          mentionedUser.avatar?.data.toString('base64')\n        );\n        void this.commentUsersRepository.save(\n          this.commentUsersRepository.create({ commentId: comment.id, userId: mentionedUser.id })\n        );\n      }\n      return comment;\n    } catch (error) {\n      throw new InternalServerErrorException(error);\n    }\n  }\n\n  private async getAppLinks(appVersionsId: string, comment: Comment) {\n    const appVersion = await this.appVersionsRepository.findOne({ where: { id: appVersionsId }, relations: ['app'] });\n    const appLink = `${process.env.TOOLJET_HOST}/apps/${appVersion.app.id}`;\n    const commentLink = `${appLink}?threadId=${comment.threadId}&commentId=${comment.id}`;\n\n    return [appLink, commentLink, appVersion.app.name];\n  }\n\n  public async getComments(threadId: string, appVersionsId: string): Promise<Comment[]> {\n    return await createQueryBuilder(Comment, 'comment')\n      .innerJoin('comment.user', 'user')\n      .addSelect(['user.id', 'user.firstName', 'user.lastName'])\n      .andWhere('comment.threadId = :threadId', {\n        threadId,\n      })\n      .andWhere('comment.appVersionsId = :appVersionsId', {\n        appVersionsId,\n      })\n      .orderBy('comment.createdAt', 'ASC')\n      .getMany();\n  }\n\n  public async getOrganizationComments(organizationId: string, appVersionsId: string): Promise<Comment[]> {\n    return await this.commentRepository.find({\n      where: {\n        organizationId,\n        appVersionsId,\n      },\n      order: {\n        createdAt: 'ASC',\n      },\n    });\n  }\n\n  public async getNotifications(\n    appId: string,\n    userId: string,\n    isResolved = false,\n    appVersionsId: string\n  ): Promise<Comment[]> {\n    const comments = await createQueryBuilder(Comment, 'comment')\n      .innerJoin('comment.user', 'user')\n      .addSelect(['user.id', 'user.firstName', 'user.lastName'])\n      .innerJoin('comment.thread', 'thread')\n      .addSelect(['thread.id'])\n      .andWhere('thread.appId = :appId', {\n        appId,\n      })\n      .andWhere('thread.isResolved = :isResolved', {\n        isResolved,\n      })\n      .andWhere('comment.appVersionsId = :appVersionsId', {\n        appVersionsId,\n      })\n      .orderBy('comment.createdAt', 'DESC')\n      .getMany();\n\n    const groupedComments = groupBy(comments, 'threadId');\n\n    const _comments = [];\n\n    Object.keys(groupedComments).map((k) => {\n      _comments.push({ comment: head(groupedComments[k]), count: groupedComments[k].length });\n    });\n\n    return _comments;\n  }\n\n  public async getComment(commentId: string): Promise<Comment> {\n    const foundComment = await this.commentRepository.findOne({ where: { id: commentId } });\n    if (!foundComment) {\n      throw new NotFoundException('Comment not found');\n    }\n    return foundComment;\n  }\n\n  public async editComment(commentId: string, updateCommentDto: UpdateCommentDto): Promise<Comment> {\n    const editedComment = await this.commentRepository.findOne({ where: { id: commentId } });\n    if (!editedComment) {\n      throw new NotFoundException('Comment not found');\n    }\n    return this.commentRepository.editComment(updateCommentDto, editedComment);\n  }\n\n  public async deleteComment(commentId: string): Promise<void> {\n    await this.commentRepository.delete(commentId);\n  }\n}\n"], "filenames": ["server/src/entities/comment.entity.ts", "server/src/services/comment.service.ts"], "buggy_code_start_loc": [47, 9], "buggy_code_end_loc": [48, 106], "fixing_code_start_loc": [47, 9], "fixing_code_end_loc": [48, 114], "type": "CWE-639", "message": "The forgot password token basically just makes us capable of taking over the account of whoever comment in an app that we can see (bruteforcing comment id's might also be an option but I wouldn't count on it, since it would take a long time to find a valid one).", "other": {"cve": {"id": "CVE-2022-3019", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-29T06:15:09.923", "lastModified": "2022-09-01T19:57:43.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The forgot password token basically just makes us capable of taking over the account of whoever comment in an app that we can see (bruteforcing comment id's might also be an option but I wouldn't count on it, since it would take a long time to find a valid one)."}, {"lang": "es", "value": "El token forgot password b\u00e1sicamente nos hace capaces de apoderarnos de la cuenta de cualquiera que comente en una aplicaci\u00f3n que podamos visualizar (forzar bruscamente los id's de los comentarios tambi\u00e9n podr\u00eda ser una opci\u00f3n, pero yo no contar\u00eda con ello, ya que tomar\u00eda mucho tiempo encontrar uno v\u00e1lido)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tooljet:tooljet:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.23.0", "matchCriteriaId": "657656BE-EADC-4117-9024-144CA7CE2A3D"}]}]}], "references": [{"url": "https://github.com/tooljet/tooljet/commit/45e0d3302d92df7d7f2d609c31cea71165600b79", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a610300b-ce3c-4995-8337-11942b3621bf", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tooljet/tooljet/commit/45e0d3302d92df7d7f2d609c31cea71165600b79"}}