{"buggy_code": ["/* Copyright (c) 2003-2018 Dovecot authors, see the included COPYING file */\n\n#include \"lib.h\"\n#include \"str.h\"\n#include \"strescape.h\"\n#include \"ostream.h\"\n#include \"auth-client-private.h\"\n#include \"auth-server-connection.h\"\n#include \"auth-client-request.h\"\n\n\nstruct auth_client_request {\n\tpool_t pool;\n\n\tstruct auth_server_connection *conn;\n\tunsigned int id;\n\ttime_t created;\n\n\tauth_request_callback_t *callback;\n\tvoid *context;\n};\n\nstatic void auth_server_send_new_request(struct auth_server_connection *conn,\n\t\t\t\t\t struct auth_client_request *request,\n\t\t\t\t\t const struct auth_request_info *info)\n{\n\tstring_t *str;\n\n\tstr = t_str_new(512);\n\tstr_printfa(str, \"AUTH\\t%u\\t\", request->id);\n\tstr_append_tabescaped(str, info->mech);\n\tstr_append(str, \"\\tservice=\");\n\tstr_append_tabescaped(str, info->service);\n\n\tif ((info->flags & AUTH_REQUEST_FLAG_SUPPORT_FINAL_RESP) != 0)\n\t\tstr_append(str, \"\\tfinal-resp-ok\");\n\tif ((info->flags & AUTH_REQUEST_FLAG_SECURED) != 0) {\n\t\tstr_append(str, \"\\tsecured\");\n\t\tif ((info->flags & AUTH_REQUEST_FLAG_TRANSPORT_SECURITY_TLS) != 0)\n\t\t\tstr_append(str, \"=tls\");\n\t} else {\n\t\ti_assert((info->flags & AUTH_REQUEST_FLAG_TRANSPORT_SECURITY_TLS) == 0);\n\t}\n\tif ((info->flags & AUTH_REQUEST_FLAG_NO_PENALTY) != 0)\n\t\tstr_append(str, \"\\tno-penalty\");\n\tif ((info->flags & AUTH_REQUEST_FLAG_VALID_CLIENT_CERT) != 0)\n\t\tstr_append(str, \"\\tvalid-client-cert\");\n\tif ((info->flags & AUTH_REQUEST_FLAG_DEBUG) != 0)\n\t\tstr_append(str, \"\\tdebug\");\n\n\tif (info->session_id != NULL) {\n\t\tstr_append(str, \"\\tsession=\");\n\t\tstr_append_tabescaped(str, info->session_id);\n\t}\n\tif (info->cert_username != NULL) {\n\t\tstr_append(str, \"\\tcert_username=\");\n\t\tstr_append_tabescaped(str, info->cert_username);\n\t}\n\tif (info->local_ip.family != 0)\n\t\tstr_printfa(str, \"\\tlip=%s\", net_ip2addr(&info->local_ip));\n\tif (info->remote_ip.family != 0)\n\t\tstr_printfa(str, \"\\trip=%s\", net_ip2addr(&info->remote_ip));\n\tif (info->local_port != 0)\n\t\tstr_printfa(str, \"\\tlport=%u\", info->local_port);\n\tif (info->remote_port != 0)\n\t\tstr_printfa(str, \"\\trport=%u\", info->remote_port);\n\n\t/* send the real_* variants only when they differ from the unreal\n\t   ones */\n\tif (info->real_local_ip.family != 0 &&\n\t    !net_ip_compare(&info->real_local_ip, &info->local_ip)) {\n\t\tstr_printfa(str, \"\\treal_lip=%s\",\n\t\t\t    net_ip2addr(&info->real_local_ip));\n\t}\n\tif (info->real_remote_ip.family != 0 &&\n\t    !net_ip_compare(&info->real_remote_ip, &info->remote_ip)) {\n\t\tstr_printfa(str, \"\\treal_rip=%s\",\n\t\t\t    net_ip2addr(&info->real_remote_ip));\n\t}\n\tif (info->real_local_port != 0 &&\n\t    info->real_local_port != info->local_port)\n\t\tstr_printfa(str, \"\\treal_lport=%u\", info->real_local_port);\n\tif (info->real_remote_port != 0 &&\n\t    info->real_remote_port != info->remote_port)\n\t\tstr_printfa(str, \"\\treal_rport=%u\", info->real_remote_port);\n\tif (info->local_name != NULL &&\n\t    *info->local_name != '\\0') {\n\t\tstr_append(str, \"\\tlocal_name=\");\n\t\tstr_append_tabescaped(str, info->local_name);\n\t}\n\tif (info->ssl_cipher_bits != 0 && info->ssl_cipher != NULL) {\n\t\tstr_append(str, \"\\tssl_cipher=\");\n\t\tstr_append_tabescaped(str, info->ssl_cipher);\n\t\tstr_printfa(str, \"\\tssl_cipher_bits=%u\", info->ssl_cipher_bits);\n\t\tif (info->ssl_pfs != NULL) {\n\t\t\tstr_append(str, \"\\tssl_pfs=\");\n\t\t\tstr_append_tabescaped(str, info->ssl_pfs);\n\t\t}\n\t}\n\tif (info->ssl_protocol != NULL) {\n\t\tstr_append(str, \"\\tssl_protocol=\");\n\t\tstr_append_tabescaped(str, info->ssl_protocol);\n\t}\n\tif (info->client_id != NULL &&\n\t    *info->client_id != '\\0') {\n\t\tstr_append(str, \"\\tclient_id=\");\n\t\tstr_append_tabescaped(str, info->client_id);\n\t}\n\tif (info->forward_fields != NULL &&\n\t    *info->forward_fields != '\\0') {\n\t\tstr_append(str, \"\\tforward_fields=\");\n\t\tstr_append_tabescaped(str, info->forward_fields);\n\t}\n\tif (info->initial_resp_base64 != NULL) {\n\t\tstr_append(str, \"\\tresp=\");\n\t\tstr_append_tabescaped(str, info->initial_resp_base64);\n\t}\n\tstr_append_c(str, '\\n');\n\n\tif (o_stream_send(conn->output, str_data(str), str_len(str)) < 0)\n\t\ti_error(\"Error sending request to auth server: %m\");\n}\n\nstruct auth_client_request *\nauth_client_request_new(struct auth_client *client,\n\t\t\tconst struct auth_request_info *request_info,\n\t\t\tauth_request_callback_t *callback, void *context)\n{\n\tstruct auth_client_request *request;\n\tpool_t pool;\n\n\tpool = pool_alloconly_create(\"auth client request\", 512);\n\trequest = p_new(pool, struct auth_client_request, 1);\n\trequest->pool = pool;\n\trequest->conn = client->conn;\n\n\trequest->callback = callback;\n\trequest->context = context;\n\n\trequest->id =\n\t\tauth_server_connection_add_request(request->conn, request);\n\trequest->created = ioloop_time;\n\tT_BEGIN {\n\t\tauth_server_send_new_request(request->conn, request, request_info);\n\t} T_END;\n\treturn request;\n}\n\nvoid auth_client_request_continue(struct auth_client_request *request,\n                                  const char *data_base64)\n{\n\tstruct const_iovec iov[3];\n\tconst char *prefix;\n\n\tprefix = t_strdup_printf(\"CONT\\t%u\\t\", request->id);\n\n\tiov[0].iov_base = prefix;\n\tiov[0].iov_len = strlen(prefix);\n\tiov[1].iov_base = data_base64;\n\tiov[1].iov_len = strlen(data_base64);\n\tiov[2].iov_base = \"\\n\";\n\tiov[2].iov_len = 1;\n\n\tif (o_stream_sendv(request->conn->output, iov, 3) < 0)\n\t\ti_error(\"Error sending continue request to auth server: %m\");\n}\n\nstatic void ATTR_NULL(3, 4)\ncall_callback(struct auth_client_request *request,\n\t      enum auth_request_status status,\n\t      const char *data_base64,\n\t      const char *const *args)\n{\n\tauth_request_callback_t *callback = request->callback;\n\n\tif (status != AUTH_REQUEST_STATUS_CONTINUE)\n\t\trequest->callback = NULL;\n\tcallback(request, status, data_base64, args, request->context);\n}\n\nvoid auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}\n\nunsigned int auth_client_request_get_id(struct auth_client_request *request)\n{\n\treturn request->id;\n}\n\nunsigned int\nauth_client_request_get_server_pid(struct auth_client_request *request)\n{\n\treturn request->conn->server_pid;\n}\n\nconst char *auth_client_request_get_cookie(struct auth_client_request *request)\n{\n\treturn request->conn->cookie;\n}\n\nbool auth_client_request_is_aborted(struct auth_client_request *request)\n{\n\treturn request->callback == NULL;\n}\n\ntime_t auth_client_request_get_create_time(struct auth_client_request *request)\n{\n\treturn request->created;\n}\n\nvoid auth_client_request_server_input(struct auth_client_request *request,\n\t\t\t\t      enum auth_request_status status,\n\t\t\t\t      const char *const *args)\n{\n\tconst char *const *tmp, *base64_data = NULL;\n\n\tif (request->callback == NULL) {\n\t\t/* aborted already */\n\t\treturn;\n\t}\n\n\tswitch (status) {\n\tcase AUTH_REQUEST_STATUS_OK:\n\t\tfor (tmp = args; *tmp != NULL; tmp++) {\n\t\t\tif (strncmp(*tmp, \"resp=\", 5) == 0) {\n\t\t\t\tbase64_data = *tmp + 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AUTH_REQUEST_STATUS_CONTINUE:\n\t\tbase64_data = args[0];\n\t\targs = NULL;\n\t\tbreak;\n\tcase AUTH_REQUEST_STATUS_FAIL:\n\tcase AUTH_REQUEST_STATUS_INTERNAL_FAIL:\n\tcase AUTH_REQUEST_STATUS_ABORT:\n\t\tbreak;\n\t}\n\n\tcall_callback(request, status, base64_data, args);\n\tif (status != AUTH_REQUEST_STATUS_CONTINUE)\n\t\tpool_unref(&request->pool);\n}\n\nvoid auth_client_send_cancel(struct auth_client *client, unsigned int id)\n{\n\tconst char *str = t_strdup_printf(\"CANCEL\\t%u\\n\", id);\n\n\tif (o_stream_send_str(client->conn->output, str) < 0)\n\t\ti_error(\"Error sending request to auth server: %m\");\n}\n"], "fixing_code": ["/* Copyright (c) 2003-2018 Dovecot authors, see the included COPYING file */\n\n#include \"lib.h\"\n#include \"str.h\"\n#include \"strescape.h\"\n#include \"ostream.h\"\n#include \"auth-client-private.h\"\n#include \"auth-server-connection.h\"\n#include \"auth-client-request.h\"\n\n\nstruct auth_client_request {\n\tpool_t pool;\n\n\tstruct auth_server_connection *conn;\n\tunsigned int id;\n\ttime_t created;\n\n\tauth_request_callback_t *callback;\n\tvoid *context;\n};\n\nstatic void auth_server_send_new_request(struct auth_server_connection *conn,\n\t\t\t\t\t struct auth_client_request *request,\n\t\t\t\t\t const struct auth_request_info *info)\n{\n\tstring_t *str;\n\n\tstr = t_str_new(512);\n\tstr_printfa(str, \"AUTH\\t%u\\t\", request->id);\n\tstr_append_tabescaped(str, info->mech);\n\tstr_append(str, \"\\tservice=\");\n\tstr_append_tabescaped(str, info->service);\n\n\tif ((info->flags & AUTH_REQUEST_FLAG_SUPPORT_FINAL_RESP) != 0)\n\t\tstr_append(str, \"\\tfinal-resp-ok\");\n\tif ((info->flags & AUTH_REQUEST_FLAG_SECURED) != 0) {\n\t\tstr_append(str, \"\\tsecured\");\n\t\tif ((info->flags & AUTH_REQUEST_FLAG_TRANSPORT_SECURITY_TLS) != 0)\n\t\t\tstr_append(str, \"=tls\");\n\t} else {\n\t\ti_assert((info->flags & AUTH_REQUEST_FLAG_TRANSPORT_SECURITY_TLS) == 0);\n\t}\n\tif ((info->flags & AUTH_REQUEST_FLAG_NO_PENALTY) != 0)\n\t\tstr_append(str, \"\\tno-penalty\");\n\tif ((info->flags & AUTH_REQUEST_FLAG_VALID_CLIENT_CERT) != 0)\n\t\tstr_append(str, \"\\tvalid-client-cert\");\n\tif ((info->flags & AUTH_REQUEST_FLAG_DEBUG) != 0)\n\t\tstr_append(str, \"\\tdebug\");\n\n\tif (info->session_id != NULL) {\n\t\tstr_append(str, \"\\tsession=\");\n\t\tstr_append_tabescaped(str, info->session_id);\n\t}\n\tif (info->cert_username != NULL) {\n\t\tstr_append(str, \"\\tcert_username=\");\n\t\tstr_append_tabescaped(str, info->cert_username);\n\t}\n\tif (info->local_ip.family != 0)\n\t\tstr_printfa(str, \"\\tlip=%s\", net_ip2addr(&info->local_ip));\n\tif (info->remote_ip.family != 0)\n\t\tstr_printfa(str, \"\\trip=%s\", net_ip2addr(&info->remote_ip));\n\tif (info->local_port != 0)\n\t\tstr_printfa(str, \"\\tlport=%u\", info->local_port);\n\tif (info->remote_port != 0)\n\t\tstr_printfa(str, \"\\trport=%u\", info->remote_port);\n\n\t/* send the real_* variants only when they differ from the unreal\n\t   ones */\n\tif (info->real_local_ip.family != 0 &&\n\t    !net_ip_compare(&info->real_local_ip, &info->local_ip)) {\n\t\tstr_printfa(str, \"\\treal_lip=%s\",\n\t\t\t    net_ip2addr(&info->real_local_ip));\n\t}\n\tif (info->real_remote_ip.family != 0 &&\n\t    !net_ip_compare(&info->real_remote_ip, &info->remote_ip)) {\n\t\tstr_printfa(str, \"\\treal_rip=%s\",\n\t\t\t    net_ip2addr(&info->real_remote_ip));\n\t}\n\tif (info->real_local_port != 0 &&\n\t    info->real_local_port != info->local_port)\n\t\tstr_printfa(str, \"\\treal_lport=%u\", info->real_local_port);\n\tif (info->real_remote_port != 0 &&\n\t    info->real_remote_port != info->remote_port)\n\t\tstr_printfa(str, \"\\treal_rport=%u\", info->real_remote_port);\n\tif (info->local_name != NULL &&\n\t    *info->local_name != '\\0') {\n\t\tstr_append(str, \"\\tlocal_name=\");\n\t\tstr_append_tabescaped(str, info->local_name);\n\t}\n\tif (info->ssl_cipher_bits != 0 && info->ssl_cipher != NULL) {\n\t\tstr_append(str, \"\\tssl_cipher=\");\n\t\tstr_append_tabescaped(str, info->ssl_cipher);\n\t\tstr_printfa(str, \"\\tssl_cipher_bits=%u\", info->ssl_cipher_bits);\n\t\tif (info->ssl_pfs != NULL) {\n\t\t\tstr_append(str, \"\\tssl_pfs=\");\n\t\t\tstr_append_tabescaped(str, info->ssl_pfs);\n\t\t}\n\t}\n\tif (info->ssl_protocol != NULL) {\n\t\tstr_append(str, \"\\tssl_protocol=\");\n\t\tstr_append_tabescaped(str, info->ssl_protocol);\n\t}\n\tif (info->client_id != NULL &&\n\t    *info->client_id != '\\0') {\n\t\tstr_append(str, \"\\tclient_id=\");\n\t\tstr_append_tabescaped(str, info->client_id);\n\t}\n\tif (info->forward_fields != NULL &&\n\t    *info->forward_fields != '\\0') {\n\t\tstr_append(str, \"\\tforward_fields=\");\n\t\tstr_append_tabescaped(str, info->forward_fields);\n\t}\n\tif (info->initial_resp_base64 != NULL) {\n\t\tstr_append(str, \"\\tresp=\");\n\t\tstr_append_tabescaped(str, info->initial_resp_base64);\n\t}\n\tstr_append_c(str, '\\n');\n\n\tif (o_stream_send(conn->output, str_data(str), str_len(str)) < 0)\n\t\ti_error(\"Error sending request to auth server: %m\");\n}\n\nstruct auth_client_request *\nauth_client_request_new(struct auth_client *client,\n\t\t\tconst struct auth_request_info *request_info,\n\t\t\tauth_request_callback_t *callback, void *context)\n{\n\tstruct auth_client_request *request;\n\tpool_t pool;\n\n\tpool = pool_alloconly_create(\"auth client request\", 512);\n\trequest = p_new(pool, struct auth_client_request, 1);\n\trequest->pool = pool;\n\trequest->conn = client->conn;\n\n\trequest->callback = callback;\n\trequest->context = context;\n\n\trequest->id =\n\t\tauth_server_connection_add_request(request->conn, request);\n\trequest->created = ioloop_time;\n\tT_BEGIN {\n\t\tauth_server_send_new_request(request->conn, request, request_info);\n\t} T_END;\n\treturn request;\n}\n\nvoid auth_client_request_continue(struct auth_client_request *request,\n                                  const char *data_base64)\n{\n\tstruct const_iovec iov[3];\n\tconst char *prefix;\n\n\tprefix = t_strdup_printf(\"CONT\\t%u\\t\", request->id);\n\n\tiov[0].iov_base = prefix;\n\tiov[0].iov_len = strlen(prefix);\n\tiov[1].iov_base = data_base64;\n\tiov[1].iov_len = strlen(data_base64);\n\tiov[2].iov_base = \"\\n\";\n\tiov[2].iov_len = 1;\n\n\tif (o_stream_sendv(request->conn->output, iov, 3) < 0)\n\t\ti_error(\"Error sending continue request to auth server: %m\");\n}\n\nstatic void ATTR_NULL(3, 4)\ncall_callback(struct auth_client_request *request,\n\t      enum auth_request_status status,\n\t      const char *data_base64,\n\t      const char *const *args)\n{\n\tauth_request_callback_t *callback = request->callback;\n\n\tif (status != AUTH_REQUEST_STATUS_CONTINUE)\n\t\trequest->callback = NULL;\n\tcallback(request, status, data_base64, args, request->context);\n}\n\nvoid auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}\n\nunsigned int auth_client_request_get_id(struct auth_client_request *request)\n{\n\treturn request->id;\n}\n\nunsigned int\nauth_client_request_get_server_pid(struct auth_client_request *request)\n{\n\treturn request->conn->server_pid;\n}\n\nconst char *auth_client_request_get_cookie(struct auth_client_request *request)\n{\n\treturn request->conn->cookie;\n}\n\nbool auth_client_request_is_aborted(struct auth_client_request *request)\n{\n\treturn request->callback == NULL;\n}\n\ntime_t auth_client_request_get_create_time(struct auth_client_request *request)\n{\n\treturn request->created;\n}\n\nvoid auth_client_request_server_input(struct auth_client_request *request,\n\t\t\t\t      enum auth_request_status status,\n\t\t\t\t      const char *const *args)\n{\n\tconst char *const *tmp, *base64_data = NULL;\n\n\tif (request->callback == NULL) {\n\t\t/* aborted already */\n\t\treturn;\n\t}\n\n\tswitch (status) {\n\tcase AUTH_REQUEST_STATUS_OK:\n\t\tfor (tmp = args; *tmp != NULL; tmp++) {\n\t\t\tif (strncmp(*tmp, \"resp=\", 5) == 0) {\n\t\t\t\tbase64_data = *tmp + 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AUTH_REQUEST_STATUS_CONTINUE:\n\t\tbase64_data = args[0];\n\t\targs = NULL;\n\t\tbreak;\n\tcase AUTH_REQUEST_STATUS_FAIL:\n\tcase AUTH_REQUEST_STATUS_INTERNAL_FAIL:\n\tcase AUTH_REQUEST_STATUS_ABORT:\n\t\tbreak;\n\t}\n\n\tcall_callback(request, status, base64_data, args);\n\tif (status != AUTH_REQUEST_STATUS_CONTINUE)\n\t\tpool_unref(&request->pool);\n}\n\nvoid auth_client_send_cancel(struct auth_client *client, unsigned int id)\n{\n\tconst char *str = t_strdup_printf(\"CANCEL\\t%u\\n\", id);\n\n\tif (o_stream_send_str(client->conn->output, str) < 0)\n\t\ti_error(\"Error sending request to auth server: %m\");\n}\n"], "filenames": ["src/lib-auth/auth-client-request.c"], "buggy_code_start_loc": [188], "buggy_code_end_loc": [188], "fixing_code_start_loc": [189], "fixing_code_end_loc": [190], "type": "CWE-772", "message": "A flaw was found in dovecot 2.0 up to 2.2.33 and 2.3.0. An abort of SASL authentication results in a memory leak in dovecot's auth client used by login processes. The leak has impact in high performance configuration where same login processes are reused and can cause the process to crash due to memory exhaustion.", "other": {"cve": {"id": "CVE-2017-15132", "sourceIdentifier": "secalert@redhat.com", "published": "2018-01-25T20:29:00.213", "lastModified": "2019-10-09T23:24:15.657", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in dovecot 2.0 up to 2.2.33 and 2.3.0. An abort of SASL authentication results in a memory leak in dovecot's auth client used by login processes. The leak has impact in high performance configuration where same login processes are reused and can cause the process to crash due to memory exhaustion."}, {"lang": "es", "value": "Se ha detectado un fallo en dovecot desde la versi\u00f3n 2.0 hasta la 2.2.33 y 2.3.0. El aborto de una autenticaci\u00f3n SASL resulta en una fuga de memoria en el cliente de autenticaci\u00f3n de dovecot utilizado por los procesos de inicio de sesi\u00f3n. La fuga provoca un impacto en la configuraci\u00f3n de alto rendimiento en donde los mismos procesos de inicio de sesi\u00f3n se reutilizan y pueden provocar que el proceso se cierre de manera inesperada al agotarse la memoria."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dovecot:dovecot:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.2.33", "matchCriteriaId": "F64EF3A1-D4E6-4B36-A8ED-1F5D6A7E179A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dovecot:dovecot:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "891476A9-DA14-4647-A40F-19093E099954"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1532768", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dovecot/core/commit/1a29ed2f96da1be22fa5a4d96c7583aa81b8b060.patch", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/03/msg00036.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3556-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3556-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4130", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.dovecot.org/list/dovecot-news/2018-February/000370.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/dovecot/core/commit/1a29ed2f96da1be22fa5a4d96c7583aa81b8b060.patch"}}