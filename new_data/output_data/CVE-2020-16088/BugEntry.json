{"buggy_code": ["/*\t$OpenBSD: ca.c,v 1.64 2020/07/15 14:45:15 tobhe Exp $\t*/\n\n/*\n * Copyright (c) 2010-2013 Reyk Floeter <reyk@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/queue.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <string.h>\n#include <signal.h>\n#include <syslog.h>\n#include <errno.h>\n#include <err.h>\n#include <pwd.h>\n#include <event.h>\n\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include <openssl/engine.h>\n#include <openssl/ssl.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/rsa.h>\n\n#include \"iked.h\"\n#include \"ikev2.h\"\n\nvoid\t ca_run(struct privsep *, struct privsep_proc *, void *);\nvoid\t ca_shutdown(struct privsep_proc *);\nvoid\t ca_reset(struct privsep *);\nint\t ca_reload(struct iked *);\n\nint\t ca_getreq(struct iked *, struct imsg *);\nint\t ca_getcert(struct iked *, struct imsg *);\nint\t ca_getauth(struct iked *, struct imsg *);\nX509\t*ca_by_subjectpubkey(X509_STORE *, uint8_t *, size_t);\nX509\t*ca_by_issuer(X509_STORE *, X509_NAME *, struct iked_static_id *);\nX509\t*ca_by_subjectaltname(X509_STORE *, struct iked_static_id *);\nvoid\t ca_store_certs_info(const char *, X509_STORE *);\nint\t ca_subjectpubkey_digest(X509 *, uint8_t *, unsigned int *);\nint\t ca_x509_subject_cmp(X509 *, struct iked_static_id *);\nint\t ca_validate_pubkey(struct iked *, struct iked_static_id *,\n\t    void *, size_t, struct iked_id *);\nint\t ca_validate_cert(struct iked *, struct iked_static_id *,\n\t    void *, size_t);\nint\t ca_privkey_to_method(struct iked_id *);\nstruct ibuf *\n\t ca_x509_serialize(X509 *);\nint\t ca_x509_subjectaltname_do(X509 *, int, const char *,\n\t    struct iked_static_id *, struct iked_id *);\nint\t ca_x509_subjectaltname_cmp(X509 *, struct iked_static_id *);\nint\t ca_x509_subjectaltname_log(X509 *, const char *);\nint\t ca_x509_subjectaltname_get(X509 *cert, struct iked_id *);\nint\t ca_dispatch_parent(int, struct privsep_proc *, struct imsg *);\nint\t ca_dispatch_ikev2(int, struct privsep_proc *, struct imsg *);\n\nstatic struct privsep_proc procs[] = {\n\t{ \"parent\",\tPROC_PARENT,\tca_dispatch_parent },\n\t{ \"ikev2\",\tPROC_IKEV2,\tca_dispatch_ikev2 }\n};\n\nstruct ca_store {\n\tX509_STORE\t*ca_cas;\n\tX509_LOOKUP\t*ca_calookup;\n\n\tX509_STORE\t*ca_certs;\n\tX509_LOOKUP\t*ca_certlookup;\n\n\tstruct iked_id\t ca_privkey;\n\tstruct iked_id\t ca_pubkey;\n\n\tuint8_t\t\t ca_privkey_method;\n};\n\npid_t\ncaproc(struct privsep *ps, struct privsep_proc *p)\n{\n\treturn (proc_run(ps, p, procs, nitems(procs), ca_run, NULL));\n}\n\nvoid\nca_run(struct privsep *ps, struct privsep_proc *p, void *arg)\n{\n\tstruct iked\t*env = ps->ps_env;\n\tstruct ca_store\t*store;\n\n\t/*\n\t * pledge in the ca process:\n\t * stdio - for malloc and basic I/O including events.\n\t * rpath - for certificate files.\n\t * recvfd - for ocsp sockets.\n\t */\n\tif (pledge(\"stdio rpath recvfd\", NULL) == -1)\n\t\tfatal(\"pledge\");\n\n\tif ((store = calloc(1, sizeof(*store))) == NULL)\n\t\tfatal(\"%s: failed to allocate cert store\", __func__);\n\n\tenv->sc_priv = store;\n\tp->p_shutdown = ca_shutdown;\n}\n\nvoid\nca_shutdown(struct privsep_proc *p)\n{\n\tstruct iked             *env = p->p_env;\n\tstruct ca_store\t\t*store;\n\n\tif (env == NULL)\n\t\treturn;\n\tibuf_release(env->sc_certreq);\n\tif ((store = env->sc_priv) == NULL)\n\t\treturn;\n\tibuf_release(store->ca_pubkey.id_buf);\n\tibuf_release(store->ca_privkey.id_buf);\n\tfree(store);\n}\n\nvoid\nca_getkey(struct privsep *ps, struct iked_id *key, enum imsg_type type)\n{\n\tstruct iked\t*env = ps->ps_env;\n\tstruct ca_store\t*store = env->sc_priv;\n\tstruct iked_id\t*id;\n\tconst char\t*name;\n\n\tif (store == NULL)\n\t\tfatalx(\"%s: invalid store\", __func__);\n\n\tif (type == IMSG_PRIVKEY) {\n\t\tname = \"private\";\n\t\tid = &store->ca_privkey;\n\n\t\tstore->ca_privkey_method = ca_privkey_to_method(key);\n\t\tif (store->ca_privkey_method == IKEV2_AUTH_NONE)\n\t\t\tfatalx(\"ca: failed to get auth method for privkey\");\n\t} else if (type == IMSG_PUBKEY) {\n\t\tname = \"public\";\n\t\tid = &store->ca_pubkey;\n\t} else\n\t\tfatalx(\"%s: invalid type %d\", __func__, type);\n\n\tlog_debug(\"%s: received %s key type %s length %zd\", __func__,\n\t    name, print_map(key->id_type, ikev2_cert_map),\n\t    ibuf_length(key->id_buf));\n\n\t/* clear old key and copy new one */\n\tibuf_release(id->id_buf);\n\tmemcpy(id, key, sizeof(*id));\n}\n\nvoid\nca_reset(struct privsep *ps)\n{\n\tstruct iked\t*env = ps->ps_env;\n\tstruct ca_store\t*store = env->sc_priv;\n\n\tif (store->ca_privkey.id_type == IKEV2_ID_NONE ||\n\t    store->ca_pubkey.id_type == IKEV2_ID_NONE)\n\t\tfatalx(\"ca_reset: keys not loaded\");\n\n\tif (store->ca_cas != NULL)\n\t\tX509_STORE_free(store->ca_cas);\n\tif (store->ca_certs != NULL)\n\t\tX509_STORE_free(store->ca_certs);\n\n\tif ((store->ca_cas = X509_STORE_new()) == NULL)\n\t\tfatalx(\"ca_reset: failed to get ca store\");\n\tif ((store->ca_calookup = X509_STORE_add_lookup(store->ca_cas,\n\t    X509_LOOKUP_file())) == NULL)\n\t\tfatalx(\"ca_reset: failed to add ca lookup\");\n\n\tif ((store->ca_certs = X509_STORE_new()) == NULL)\n\t\tfatalx(\"ca_reset: failed to get cert store\");\n\tif ((store->ca_certlookup = X509_STORE_add_lookup(store->ca_certs,\n\t    X509_LOOKUP_file())) == NULL)\n\t\tfatalx(\"ca_reset: failed to add cert lookup\");\n\n\tif (ca_reload(env) != 0)\n\t\tfatal(\"ca_reset: reload\");\n}\n\nint\nca_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)\n{\n\tstruct iked\t\t*env = p->p_env;\n\tunsigned int\t\t mode;\n\n\tswitch (imsg->hdr.type) {\n\tcase IMSG_CTL_RESET:\n\t\tIMSG_SIZE_CHECK(imsg, &mode);\n\t\tmemcpy(&mode, imsg->data, sizeof(mode));\n\t\tif (mode == RESET_ALL || mode == RESET_CA) {\n\t\t\tlog_debug(\"%s: config reset\", __func__);\n\t\t\tca_reset(&env->sc_ps);\n\t\t}\n\t\tbreak;\n\tcase IMSG_OCSP_FD:\n\t\tocsp_receive_fd(env, imsg);\n\t\tbreak;\n\tcase IMSG_OCSP_URL:\n\t\tconfig_getocsp(env, imsg);\n\t\tbreak;\n\tcase IMSG_PRIVKEY:\n\tcase IMSG_PUBKEY:\n\t\tconfig_getkey(env, imsg);\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nint\nca_dispatch_ikev2(int fd, struct privsep_proc *p, struct imsg *imsg)\n{\n\tstruct iked\t*env = p->p_env;\n\n\tswitch (imsg->hdr.type) {\n\tcase IMSG_CERTREQ:\n\t\tca_getreq(env, imsg);\n\t\tbreak;\n\tcase IMSG_CERT:\n\t\tca_getcert(env, imsg);\n\t\tbreak;\n\tcase IMSG_AUTH:\n\t\tca_getauth(env, imsg);\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nint\nca_setcert(struct iked *env, struct iked_sahdr *sh, struct iked_id *id,\n    uint8_t type, uint8_t *data, size_t len, enum privsep_procid procid)\n{\n\tstruct iovec\t\tiov[4];\n\tint\t\t\tiovcnt = 0;\n\tstruct iked_static_id\tidb;\n\n\t/* Must send the cert and a valid Id to the ca process */\n\tif (procid == PROC_CERT) {\n\t\tif (id == NULL || id->id_type == IKEV2_ID_NONE ||\n\t\t    ibuf_length(id->id_buf) > IKED_ID_SIZE)\n\t\t\treturn (-1);\n\t\tbzero(&idb, sizeof(idb));\n\n\t\t/* Convert to a static Id */\n\t\tidb.id_type = id->id_type;\n\t\tidb.id_offset = id->id_offset;\n\t\tidb.id_length = ibuf_length(id->id_buf);\n\t\tmemcpy(&idb.id_data, ibuf_data(id->id_buf),\n\t\t    ibuf_length(id->id_buf));\n\n\t\tiov[iovcnt].iov_base = &idb;\n\t\tiov[iovcnt].iov_len = sizeof(idb);\n\t\tiovcnt++;\n\t}\n\n\tiov[iovcnt].iov_base = sh;\n\tiov[iovcnt].iov_len = sizeof(*sh);\n\tiovcnt++;\n\tiov[iovcnt].iov_base = &type;\n\tiov[iovcnt].iov_len = sizeof(type);\n\tiovcnt++;\n\tif (data != NULL) {\n\t\tiov[iovcnt].iov_base = data;\n\t\tiov[iovcnt].iov_len = len;\n\t\tiovcnt++;\n\t}\n\n\tif (proc_composev(&env->sc_ps, procid, IMSG_CERT, iov, iovcnt) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\nint\nca_setreq(struct iked *env, struct iked_sa *sa,\n    struct iked_static_id *localid, uint8_t type, uint8_t more, uint8_t *data,\n    size_t len, enum privsep_procid procid)\n{\n\tstruct iovec\t\tiov[5];\n\tint\t\t\tiovcnt = 0;\n\tstruct iked_static_id\tidb;\n\tstruct iked_id\t\tid;\n\tint\t\t\tret = -1;\n\n\t/* Convert to a static Id */\n\tbzero(&id, sizeof(id));\n\tif (ikev2_policy2id(localid, &id, 1) != 0)\n\t\treturn (-1);\n\n\tbzero(&idb, sizeof(idb));\n\tidb.id_type = id.id_type;\n\tidb.id_offset = id.id_offset;\n\tidb.id_length = ibuf_length(id.id_buf);\n\tmemcpy(&idb.id_data, ibuf_data(id.id_buf),\n\t    ibuf_length(id.id_buf));\n\tiov[iovcnt].iov_base = &idb;\n\tiov[iovcnt].iov_len = sizeof(idb);\n\tiovcnt++;\n\n\tiov[iovcnt].iov_base = &sa->sa_hdr;\n\tiov[iovcnt].iov_len = sizeof(sa->sa_hdr);\n\tiovcnt++;\n\tiov[iovcnt].iov_base = &type;\n\tiov[iovcnt].iov_len = sizeof(type);\n\tiovcnt++;\n\tiov[iovcnt].iov_base = &more;\n\tiov[iovcnt].iov_len = sizeof(more);\n\tiovcnt++;\n\tif (data != NULL) {\n\t\tiov[iovcnt].iov_base = data;\n\t\tiov[iovcnt].iov_len = len;\n\t\tiovcnt++;\n\t}\n\n\tif (proc_composev(&env->sc_ps, procid, IMSG_CERTREQ, iov, iovcnt) == -1)\n\t\tgoto done;\n\n\tsa_stateflags(sa, IKED_REQ_CERTREQ);\n\n\tret = 0;\n done:\n\tibuf_release(id.id_buf);\n\treturn (ret);\n}\n\nstatic int\nauth_sig_compatible(uint8_t type)\n{\n\tswitch (type) {\n\tcase IKEV2_AUTH_RSA_SIG:\n\tcase IKEV2_AUTH_ECDSA_256:\n\tcase IKEV2_AUTH_ECDSA_384:\n\tcase IKEV2_AUTH_ECDSA_521:\n\tcase IKEV2_AUTH_SIG_ANY:\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\nca_setauth(struct iked *env, struct iked_sa *sa,\n    struct ibuf *authmsg, enum privsep_procid id)\n{\n\tstruct iovec\t\t iov[3];\n\tint\t\t\t iovcnt = 3;\n\tstruct iked_policy\t*policy = sa->sa_policy;\n\tuint8_t\t\t\t type = policy->pol_auth.auth_method;\n\n\tif (id == PROC_CERT) {\n\t\t/* switch encoding to IKEV2_AUTH_SIG if SHA2 is supported */\n\t\tif (sa->sa_sigsha2 && auth_sig_compatible(type)) {\n\t\t\tlog_debug(\"%s: switching %s to SIG\", __func__,\n\t\t\t    print_map(type, ikev2_auth_map));\n\t\t\ttype = IKEV2_AUTH_SIG;\n\t\t} else if (!sa->sa_sigsha2 && type == IKEV2_AUTH_SIG_ANY) {\n\t\t\tlog_debug(\"%s: switching SIG to RSA_SIG(*)\", __func__);\n\t\t\t/* XXX ca might auto-switch to ECDSA */\n\t\t\ttype = IKEV2_AUTH_RSA_SIG;\n\t\t} else if (type == IKEV2_AUTH_SIG) {\n\t\t\tlog_debug(\"%s: using SIG (RFC7427)\", __func__);\n\t\t}\n\t}\n\n\tif (type == IKEV2_AUTH_SHARED_KEY_MIC) {\n\t\tsa->sa_stateflags |= IKED_REQ_AUTH;\n\t\treturn (ikev2_msg_authsign(env, sa,\n\t\t    &policy->pol_auth, authmsg));\n\t}\n\n\tiov[0].iov_base = &sa->sa_hdr;\n\tiov[0].iov_len = sizeof(sa->sa_hdr);\n\tiov[1].iov_base = &type;\n\tiov[1].iov_len = sizeof(type);\n\tif (type == IKEV2_AUTH_NONE)\n\t\tiovcnt--;\n\telse {\n\t\tiov[2].iov_base = ibuf_data(authmsg);\n\t\tiov[2].iov_len = ibuf_size(authmsg);\n\t\tlog_debug(\"%s: auth length %zu\", __func__, ibuf_size(authmsg));\n\t}\n\n\tif (proc_composev(&env->sc_ps, id, IMSG_AUTH, iov, iovcnt) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\nint\nca_getcert(struct iked *env, struct imsg *imsg)\n{\n\tstruct iked_sahdr\t sh;\n\tuint8_t\t\t\t type;\n\tuint8_t\t\t\t*ptr;\n\tsize_t\t\t\t len;\n\tstruct iked_static_id\t id;\n\tunsigned int\t\t i;\n\tstruct iovec\t\t iov[3];\n\tint\t\t\t iovcnt = 3, cmd, ret = 0;\n\tstruct iked_id\t\t key;\n\n\tptr = (uint8_t *)imsg->data;\n\tlen = IMSG_DATA_SIZE(imsg);\n\ti = sizeof(id) + sizeof(sh) + sizeof(type);\n\tif (len < i)\n\t\treturn (-1);\n\n\tmemcpy(&id, ptr, sizeof(id));\n\tif (id.id_type == IKEV2_ID_NONE)\n\t\treturn (-1);\n\tmemcpy(&sh, ptr + sizeof(id), sizeof(sh));\n\tmemcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(uint8_t));\n\n\tptr += i;\n\tlen -= i;\n\n\tbzero(&key, sizeof(key));\n\n\tswitch (type) {\n\tcase IKEV2_CERT_X509_CERT:\n\t\tret = ca_validate_cert(env, &id, ptr, len);\n\t\tif (ret == 0 && env->sc_ocsp_url) {\n\t\t\tret = ocsp_validate_cert(env, &id, ptr, len, sh, type);\n\t\t\tif (ret == 0)\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase IKEV2_CERT_RSA_KEY:\n\tcase IKEV2_CERT_ECDSA:\n\t\tret = ca_validate_pubkey(env, &id, ptr, len, NULL);\n\t\tbreak;\n\tcase IKEV2_CERT_NONE:\n\t\t/* Fallback to public key */\n\t\tret = ca_validate_pubkey(env, &id, NULL, 0, &key);\n\t\tif (ret == 0) {\n\t\t\tptr = ibuf_data(key.id_buf);\n\t\t\tlen = ibuf_length(key.id_buf);\n\t\t\ttype = key.id_type;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unsupported cert type %d\", __func__, type);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\tcmd = IMSG_CERTVALID;\n\telse\n\t\tcmd = IMSG_CERTINVALID;\n\n\tiov[0].iov_base = &sh;\n\tiov[0].iov_len = sizeof(sh);\n\tiov[1].iov_base = &type;\n\tiov[1].iov_len = sizeof(type);\n\tiov[2].iov_base = ptr;\n\tiov[2].iov_len = len;\n\n\tif (proc_composev(&env->sc_ps, PROC_IKEV2, cmd, iov, iovcnt) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\nint\nca_getreq(struct iked *env, struct imsg *imsg)\n{\n\tstruct ca_store\t\t*store = env->sc_priv;\n\tstruct iked_sahdr\t sh;\n\tuint8_t\t\t\t type, more;\n\tuint8_t\t\t\t*ptr;\n\tsize_t\t\t\t len;\n\tunsigned int\t\t i;\n\tX509\t\t\t*ca = NULL, *cert = NULL;\n\tstruct ibuf\t\t*buf;\n\tstruct iked_static_id\t id;\n\tchar\t\t\t idstr[IKED_ID_SIZE];\n\n\tptr = (uint8_t *)imsg->data;\n\tlen = IMSG_DATA_SIZE(imsg);\n\ti = sizeof(id) + sizeof(type) + sizeof(sh) + sizeof(more);\n\tif (len < i)\n\t\treturn (-1);\n\n\tmemcpy(&id, ptr, sizeof(id));\n\tif (id.id_type == IKEV2_ID_NONE)\n\t\treturn (-1);\n\tmemcpy(&sh, ptr + sizeof(id), sizeof(sh));\n\tmemcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(type));\n\tmemcpy(&more, ptr + sizeof(id) + sizeof(sh) + sizeof(type), sizeof(more));\n\n\tptr += i;\n\tlen -= i;\n\n\tswitch (type) {\n\tcase IKEV2_CERT_RSA_KEY:\n\tcase IKEV2_CERT_ECDSA:\n\t\t/*\n\t\t * Find a local raw public key that matches the type\n\t\t * received in the CERTREQ payoad\n\t\t */\n\t\tif (store->ca_pubkey.id_type != type ||\n\t\t    store->ca_pubkey.id_buf == NULL)\n\t\t\tgoto fallback;\n\n\t\tbuf = ibuf_dup(store->ca_pubkey.id_buf);\n\t\tlog_debug(\"%s: using local public key of type %s\", __func__,\n\t\t    print_map(type, ikev2_cert_map));\n\t\tbreak;\n\tcase IKEV2_CERT_X509_CERT:\n\t\tif (len == 0 || len % SHA_DIGEST_LENGTH) {\n\t\t\tlog_info(\"%s: invalid CERTREQ data.\",\n\t\t\t    SPI_SH(&sh, __func__));\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Find a local certificate signed by any of the CAs\n\t\t * received in the CERTREQ payload\n\t\t */\n\t\tfor (i = 0; i < len; i += SHA_DIGEST_LENGTH) {\n\t\t\tif ((ca = ca_by_subjectpubkey(store->ca_cas, ptr + i,\n\t\t\t    SHA_DIGEST_LENGTH)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tlog_debug(\"%s: found CA %s\", __func__, ca->name);\n\n\t\t\tif ((cert = ca_by_issuer(store->ca_certs,\n\t\t\t    X509_get_subject_name(ca), &id)) != NULL) {\n\t\t\t\t/* XXX\n\t\t\t\t * should we re-validate our own cert here?\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Fallthrough */\n\tcase IKEV2_CERT_NONE:\n fallback:\n\t\t/*\n\t\t * If no certificate or key matching any of the trust-anchors\n\t\t * was found and this was the last CERTREQ, try to find one with\n\t\t * subjectAltName matching the ID\n\t\t */\n\t\tif (more)\n\t\t\treturn (0);\n\n\t\tif (cert == NULL)\n\t\t\tcert = ca_by_subjectaltname(store->ca_certs, &id);\n\n\t\t/* If there is no matching certificate use local raw pubkey */\n\t\tif (cert == NULL) {\n\t\t\tif (ikev2_print_static_id(&id, idstr, sizeof(idstr)) == -1)\n\t\t\t\treturn (-1);\n\t\t\tlog_info(\"%s: no valid local certificate found for %s\",\n\t\t\t    SPI_SH(&sh, __func__), idstr);\n\t\t\tca_store_certs_info(SPI_SH(&sh, __func__),\n\t\t\t    store->ca_certs);\n\t\t\tif (store->ca_pubkey.id_buf == NULL)\n\t\t\t\treturn (-1);\n\t\t\tbuf = ibuf_dup(store->ca_pubkey.id_buf);\n\t\t\ttype = store->ca_pubkey.id_type;\n\t\t\tlog_info(\"%s: using local public key of type %s\",\n\t\t\t    SPI_SH(&sh, __func__),\n\t\t\t    print_map(type, ikev2_cert_map));\n\t\t\tbreak;\n\t\t}\n\n\t\tlog_debug(\"%s: found local certificate %s\", __func__,\n\t\t    cert->name);\n\n\t\tif ((buf = ca_x509_serialize(cert)) == NULL)\n\t\t\treturn (-1);\n\t\tbreak;\n\tdefault:\n\t\tlog_warnx(\"%s: unknown cert type requested\",\n\t\t    SPI_SH(&sh, __func__));\n\t\treturn (-1);\n\t}\n\n\tca_setcert(env, &sh, NULL, type,\n\t    ibuf_data(buf), ibuf_size(buf), PROC_IKEV2);\n\tibuf_release(buf);\n\n\treturn (0);\n}\n\nint\nca_getauth(struct iked *env, struct imsg *imsg)\n{\n\tstruct ca_store\t\t*store = env->sc_priv;\n\tstruct iked_sahdr\t sh;\n\tuint8_t\t\t\t method;\n\tuint8_t\t\t\t*ptr;\n\tsize_t\t\t\t len;\n\tunsigned int\t\t i;\n\tint\t\t\t ret = -1;\n\tstruct iked_sa\t\t sa;\n\tstruct iked_policy\t policy;\n\tstruct iked_id\t\t*id;\n\tstruct ibuf\t\t*authmsg;\n\n\tptr = (uint8_t *)imsg->data;\n\tlen = IMSG_DATA_SIZE(imsg);\n\ti = sizeof(method) + sizeof(sh);\n\tif (len <= i)\n\t\treturn (-1);\n\n\tmemcpy(&sh, ptr, sizeof(sh));\n\tmemcpy(&method, ptr + sizeof(sh), sizeof(uint8_t));\n\tif (method == IKEV2_AUTH_SHARED_KEY_MIC)\n\t\treturn (-1);\n\n\tptr += i;\n\tlen -= i;\n\n\tif ((authmsg = ibuf_new(ptr, len)) == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * Create fake SA and policy\n\t */\n\tbzero(&sa, sizeof(sa));\n\tbzero(&policy, sizeof(policy));\n\tmemcpy(&sa.sa_hdr, &sh, sizeof(sh));\n\tsa.sa_policy = &policy;\n\tif (sh.sh_initiator)\n\t\tid = &sa.sa_icert;\n\telse\n\t\tid = &sa.sa_rcert;\n\tmemcpy(id, &store->ca_privkey, sizeof(*id));\n\tpolicy.pol_auth.auth_method = method == IKEV2_AUTH_SIG ?\n\t    method : store->ca_privkey_method;\n\n\tif (ikev2_msg_authsign(env, &sa, &policy.pol_auth, authmsg) != 0) {\n\t\tlog_debug(\"%s: AUTH sign failed\", __func__);\n\t\tpolicy.pol_auth.auth_method = IKEV2_AUTH_NONE;\n\t}\n\n\tret = ca_setauth(env, &sa, sa.sa_localauth.id_buf, PROC_IKEV2);\n\n\tibuf_release(sa.sa_localauth.id_buf);\n\tsa.sa_localauth.id_buf = NULL;\n\tibuf_release(authmsg);\n\n\treturn (ret);\n}\n\nint\nca_reload(struct iked *env)\n{\n\tstruct ca_store\t\t*store = env->sc_priv;\n\tuint8_t\t\t\t md[EVP_MAX_MD_SIZE];\n\tchar\t\t\t file[PATH_MAX];\n\tstruct iovec\t\t iov[2];\n\tstruct dirent\t\t*entry;\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*x509;\n\tDIR\t\t\t*dir;\n\tint\t\t\t i, len, iovcnt = 0;\n\n\t/*\n\t * Load CAs\n\t */\n\tif ((dir = opendir(IKED_CA_DIR)) == NULL)\n\t\treturn (-1);\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif ((entry->d_type != DT_REG) &&\n\t\t    (entry->d_type != DT_LNK))\n\t\t\tcontinue;\n\n\t\tif (snprintf(file, sizeof(file), \"%s%s\",\n\t\t    IKED_CA_DIR, entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tif (!X509_load_cert_file(store->ca_calookup, file,\n\t\t    X509_FILETYPE_PEM)) {\n\t\t\tlog_warn(\"%s: failed to load ca file %s\", __func__,\n\t\t\t    entry->d_name);\n\t\t\tca_sslerror(__func__);\n\t\t\tcontinue;\n\t\t}\n\t\tlog_debug(\"%s: loaded ca file %s\", __func__, entry->d_name);\n\t}\n\tclosedir(dir);\n\n\t/*\n\t * Load CRLs for the CAs\n\t */\n\tif ((dir = opendir(IKED_CRL_DIR)) == NULL)\n\t\treturn (-1);\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif ((entry->d_type != DT_REG) &&\n\t\t    (entry->d_type != DT_LNK))\n\t\t\tcontinue;\n\n\t\tif (snprintf(file, sizeof(file), \"%s%s\",\n\t\t    IKED_CRL_DIR, entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tif (!X509_load_crl_file(store->ca_calookup, file,\n\t\t    X509_FILETYPE_PEM)) {\n\t\t\tlog_warn(\"%s: failed to load crl file %s\", __func__,\n\t\t\t    entry->d_name);\n\t\t\tca_sslerror(__func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Only enable CRL checks if we actually loaded a CRL */\n\t\tX509_STORE_set_flags(store->ca_cas, X509_V_FLAG_CRL_CHECK);\n\n\t\tlog_debug(\"%s: loaded crl file %s\", __func__, entry->d_name);\n\t}\n\tclosedir(dir);\n\n\t/*\n\t * Save CAs signatures for the IKEv2 CERTREQ\n\t */\n\tibuf_release(env->sc_certreq);\n\tif ((env->sc_certreq = ibuf_new(NULL, 0)) == NULL)\n\t\treturn (-1);\n\n\th = store->ca_cas->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tx509 = xo->data.x509;\n\t\tlen = sizeof(md);\n\t\tca_subjectpubkey_digest(x509, md, &len);\n\t\tlog_debug(\"%s: %s\", __func__, x509->name);\n\n\t\tif (ibuf_add(env->sc_certreq, md, len) != 0) {\n\t\t\tibuf_release(env->sc_certreq);\n\t\t\tenv->sc_certreq = NULL;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (ibuf_length(env->sc_certreq)) {\n\t\tenv->sc_certreqtype = IKEV2_CERT_X509_CERT;\n\t\tiov[0].iov_base = &env->sc_certreqtype;\n\t\tiov[0].iov_len = sizeof(env->sc_certreqtype);\n\t\tiovcnt++;\n\t\tiov[1].iov_base = ibuf_data(env->sc_certreq);\n\t\tiov[1].iov_len = ibuf_length(env->sc_certreq);\n\t\tiovcnt++;\n\n\t\tlog_debug(\"%s: loaded %zu ca certificate%s\", __func__,\n\t\t    ibuf_length(env->sc_certreq) / SHA_DIGEST_LENGTH,\n\t\t    ibuf_length(env->sc_certreq) == SHA_DIGEST_LENGTH ?\n\t\t    \"\" : \"s\");\n\n\t\t(void)proc_composev(&env->sc_ps, PROC_IKEV2, IMSG_CERTREQ,\n\t\t    iov, iovcnt);\n\t}\n\n\t/*\n\t * Load certificates\n\t */\n\tif ((dir = opendir(IKED_CERT_DIR)) == NULL)\n\t\treturn (-1);\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif ((entry->d_type != DT_REG) &&\n\t\t    (entry->d_type != DT_LNK))\n\t\t\tcontinue;\n\n\t\tif (snprintf(file, sizeof(file), \"%s%s\",\n\t\t    IKED_CERT_DIR, entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tif (!X509_load_cert_file(store->ca_certlookup, file,\n\t\t    X509_FILETYPE_PEM)) {\n\t\t\tlog_warn(\"%s: failed to load cert file %s\", __func__,\n\t\t\t    entry->d_name);\n\t\t\tca_sslerror(__func__);\n\t\t\tcontinue;\n\t\t}\n\t\tlog_debug(\"%s: loaded cert file %s\", __func__, entry->d_name);\n\t}\n\tclosedir(dir);\n\n\th = store->ca_certs->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tx509 = xo->data.x509;\n\n\t\t(void)ca_validate_cert(env, NULL, x509, 0);\n\t}\n\n\tif (!env->sc_certreqtype)\n\t\tenv->sc_certreqtype = store->ca_pubkey.id_type;\n\n\tlog_debug(\"%s: local cert type %s\", __func__,\n\t    print_map(env->sc_certreqtype, ikev2_cert_map));\n\n\tiov[0].iov_base = &env->sc_certreqtype;\n\tiov[0].iov_len = sizeof(env->sc_certreqtype);\n\tif (iovcnt == 0)\n\t\tiovcnt++;\n\t(void)proc_composev(&env->sc_ps, PROC_IKEV2, IMSG_CERTREQ, iov, iovcnt);\n\n\treturn (0);\n}\n\nX509 *\nca_by_subjectpubkey(X509_STORE *ctx, uint8_t *sig, size_t siglen)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*ca;\n\tint\t\t\t i;\n\tunsigned int\t\t len;\n\tuint8_t\t\t\t md[EVP_MAX_MD_SIZE];\n\n\th = ctx->objs;\n\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tca = xo->data.x509;\n\t\tlen = sizeof(md);\n\t\tca_subjectpubkey_digest(ca, md, &len);\n\n\t\tif (len == siglen && memcmp(md, sig, len) == 0)\n\t\t\treturn (ca);\n\t}\n\n\treturn (NULL);\n}\n\nX509 *\nca_by_issuer(X509_STORE *ctx, X509_NAME *subject, struct iked_static_id *id)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*cert;\n\tint\t\t\t i;\n\tX509_NAME\t\t*issuer;\n\n\tif (subject == NULL)\n\t\treturn (NULL);\n\n\th = ctx->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tcert = xo->data.x509;\n\t\tif ((issuer = X509_get_issuer_name(cert)) == NULL)\n\t\t\tcontinue;\n\t\telse if (X509_NAME_cmp(subject, issuer) == 0) {\n\t\t\tswitch (id->id_type) {\n\t\t\tcase IKEV2_ID_ASN1_DN:\n\t\t\t\tif (ca_x509_subject_cmp(cert, id) == 0)\n\t\t\t\t\treturn (cert);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ca_x509_subjectaltname_cmp(cert, id) == 0)\n\t\t\t\t\treturn (cert);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nX509 *\nca_by_subjectaltname(X509_STORE *ctx, struct iked_static_id *id)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*cert;\n\tint\t\t\t i;\n\n\th = ctx->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tcert = xo->data.x509;\n\t\tswitch (id->id_type) {\n\t\tcase IKEV2_ID_ASN1_DN:\n\t\t\tif (ca_x509_subject_cmp(cert, id) == 0)\n\t\t\t\treturn (cert);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ca_x509_subjectaltname_cmp(cert, id) == 0)\n\t\t\t\treturn (cert);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nvoid\nca_store_certs_info(const char *msg, X509_STORE *ctx)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*cert;\n\tint\t\t\t i;\n\n\th = ctx->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\t\tcert = xo->data.x509;\n\t\tca_cert_info(msg, cert);\n\t}\n}\n\nvoid\nca_cert_info(const char *msg, X509 *cert)\n{\n\tASN1_INTEGER\t*asn1_serial;\n\tBUF_MEM\t\t*memptr;\n\tBIO\t\t*rawserial = NULL;\n\tchar\t\t buf[BUFSIZ];\n\n\tif ((asn1_serial = X509_get_serialNumber(cert)) == NULL ||\n\t    (rawserial = BIO_new(BIO_s_mem())) == NULL ||\n\t    i2a_ASN1_INTEGER(rawserial, asn1_serial) <= 0)\n\t\tgoto out;\n\tif (X509_NAME_oneline(X509_get_issuer_name(cert), buf, sizeof(buf)))\n\t\tlog_info(\"%s: issuer: %s\", msg, buf);\n\tBIO_get_mem_ptr(rawserial, &memptr);\n\tif (memptr->data != NULL && memptr->length < INT32_MAX)\n\t\tlog_info(\"%s: serial: %.*s\", msg, (int)memptr->length,\n\t\t    memptr->data);\n\tif (X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof(buf)))\n\t\tlog_info(\"%s: subject: %s\", msg, buf);\n\tca_x509_subjectaltname_log(cert, msg);\nout:\n\tif (rawserial)\n\t\tBIO_free(rawserial);\n}\n\nint\nca_subjectpubkey_digest(X509 *x509, uint8_t *md, unsigned int *size)\n{\n\tEVP_PKEY\t*pkey;\n\tuint8_t\t\t*buf = NULL;\n\tint\t\t buflen;\n\n\tif (*size < SHA_DIGEST_LENGTH)\n\t\treturn (-1);\n\n\t/*\n\t * Generate a SHA-1 digest of the Subject Public Key Info\n\t * element in the X.509 certificate, an ASN.1 sequence\n\t * that includes the public key type (eg. RSA) and the\n\t * public key value (see 3.7 of RFC7296).\n\t */\n\tif ((pkey = X509_get_pubkey(x509)) == NULL)\n\t\treturn (-1);\n\tbuflen = i2d_PUBKEY(pkey, &buf);\n\tEVP_PKEY_free(pkey);\n\tif (buflen == 0)\n\t\treturn (-1);\n\tif (!EVP_Digest(buf, buflen, md, size, EVP_sha1(), NULL)) {\n\t\tfree(buf);\n\t\treturn (-1);\n\t}\n\tfree(buf);\n\n\treturn (0);\n}\n\nstruct ibuf *\nca_x509_serialize(X509 *x509)\n{\n\tlong\t\t len;\n\tstruct ibuf\t*buf;\n\tuint8_t\t\t*d = NULL;\n\tBIO\t\t*out;\n\n\tif ((out = BIO_new(BIO_s_mem())) == NULL)\n\t\treturn (NULL);\n\tif (!i2d_X509_bio(out, x509)) {\n\t\tBIO_free(out);\n\t\treturn (NULL);\n\t}\n\n\tlen = BIO_get_mem_data(out, &d);\n\tbuf = ibuf_new(d, len);\n\tBIO_free(out);\n\n\treturn (buf);\n}\n\nint\nca_pubkey_serialize(EVP_PKEY *key, struct iked_id *id)\n{\n\tRSA\t\t*rsa = NULL;\n\tEC_KEY\t\t*ec = NULL;\n\tuint8_t\t\t*d;\n\tint\t\t len = 0;\n\tint\t\t ret = -1;\n\n\tswitch (key->type) {\n\tcase EVP_PKEY_RSA:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((rsa = EVP_PKEY_get1_RSA(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_RSAPublicKey(rsa, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_RSAPublicKey(rsa, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_RSA_KEY;\n\t\tbreak;\n\tcase EVP_PKEY_EC:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((ec = EVP_PKEY_get1_EC_KEY(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_EC_PUBKEY(ec, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_EC_PUBKEY(ec, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_ECDSA;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unsupported key type %d\", __func__, key->type);\n\t\treturn (-1);\n\t}\n\n\tlog_debug(\"%s: type %s length %d\", __func__,\n\t    print_map(id->id_type, ikev2_cert_map), len);\n\n\tret = 0;\n done:\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n\tif (ec != NULL)\n\t\tEC_KEY_free(ec);\n\treturn (ret);\n}\n\nint\nca_privkey_serialize(EVP_PKEY *key, struct iked_id *id)\n{\n\tRSA\t\t*rsa = NULL;\n\tEC_KEY\t\t*ec = NULL;\n\tuint8_t\t\t*d;\n\tint\t\t len = 0;\n\tint\t\t ret = -1;\n\n\tswitch (key->type) {\n\tcase EVP_PKEY_RSA:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((rsa = EVP_PKEY_get1_RSA(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_RSAPrivateKey(rsa, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_RSAPrivateKey(rsa, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_RSA_KEY;\n\t\tbreak;\n\tcase EVP_PKEY_EC:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((ec = EVP_PKEY_get1_EC_KEY(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_ECPrivateKey(ec, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_ECPrivateKey(ec, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_ECDSA;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unsupported key type %d\", __func__, key->type);\n\t\treturn (-1);\n\t}\n\n\tlog_debug(\"%s: type %s length %d\", __func__,\n\t    print_map(id->id_type, ikev2_cert_map), len);\n\n\tret = 0;\n done:\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n\tif (ec != NULL)\n\t\tEC_KEY_free(ec);\n\treturn (ret);\n}\n\nint\nca_privkey_to_method(struct iked_id *privkey)\n{\n\tBIO\t\t*rawcert = NULL;\n\tEC_KEY\t\t*ec = NULL;\n\tconst EC_GROUP\t*group = NULL;\n\tuint8_t\t method = IKEV2_AUTH_NONE;\n\n\tswitch (privkey->id_type) {\n\tcase IKEV2_CERT_RSA_KEY:\n\t\tmethod = IKEV2_AUTH_RSA_SIG;\n\t\tbreak;\n\tcase IKEV2_CERT_ECDSA:\n\t\tif ((rawcert = BIO_new_mem_buf(ibuf_data(privkey->id_buf),\n\t\t    ibuf_length(privkey->id_buf))) == NULL)\n\t\t\tgoto out;\n\t\tif ((ec = d2i_ECPrivateKey_bio(rawcert, NULL)) == NULL)\n\t\t\tgoto out;\n\t\tif ((group = EC_KEY_get0_group(ec)) == NULL)\n\t\t\tgoto out;\n\t\tswitch (EC_GROUP_get_degree(group)) {\n\t\tcase 256:\n\t\t\tmethod = IKEV2_AUTH_ECDSA_256;\n\t\t\tbreak;\n\t\tcase 384:\n\t\t\tmethod = IKEV2_AUTH_ECDSA_384;\n\t\t\tbreak;\n\t\tcase 521:\n\t\t\tmethod = IKEV2_AUTH_ECDSA_521;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlog_debug(\"%s: type %s method %s\", __func__,\n\t    print_map(privkey->id_type, ikev2_cert_map),\n\t    print_map(method, ikev2_auth_map));\n\n out:\n\tif (ec != NULL)\n\t\tEC_KEY_free(ec);\n\tif (rawcert != NULL)\n\t\tBIO_free(rawcert);\n\n\treturn (method);\n}\n\nchar *\nca_asn1_name(uint8_t *asn1, size_t len)\n{\n\tX509_NAME\t*name = NULL;\n\tchar\t\t*str = NULL;\n\tconst uint8_t\t*p;\n\n\tp = asn1;\n\tif ((name = d2i_X509_NAME(NULL, &p, len)) == NULL)\n\t\treturn (NULL);\n\tstr = X509_NAME_oneline(name, NULL, 0);\n\tX509_NAME_free(name);\n\n\treturn (str);\n}\n\n/*\n * Copy 'src' to 'dst' until 'marker' is found while unescaping '\\'\n * characters. The return value tells the caller where to continue\n * parsing (might be the end of the string) or NULL on error.\n */\nstatic char *\nca_x509_name_unescape(char *src, char *dst, char marker)\n{\n\twhile (*src) {\n\t\tif (*src == marker) {\n\t\t\tsrc++;\n\t\t\tbreak;\n\t\t}\n\t\tif (*src == '\\\\') {\n\t\t\tsrc++;\n\t\t\tif (!*src) {\n\t\t\t\tlog_warnx(\"%s: '\\\\' at end of string\",\n\t\t\t\t    __func__);\n\t\t\t\t*dst = '\\0';\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t\t*dst++ = *src++;\n\t}\n\t*dst = '\\0';\n\treturn (src);\n}\n/*\n * Parse an X509 subject name where 'subject' is in the format\n *    /type0=value0/type1=value1/type2=...\n * where characters may be escaped by '\\'.\n * See lib/libssl/src/apps/apps.c:parse_name()\n */\nvoid *\nca_x509_name_parse(char *subject)\n{\n\tchar\t\t*cp, *value = NULL, *type = NULL;\n\tsize_t\t\t maxlen;\n\tX509_NAME\t*name = NULL;\n\n\tif (*subject != '/') {\n\t\tlog_warnx(\"%s: leading '/' missing in '%s'\", __func__, subject);\n\t\tgoto err;\n\t}\n\n\t/* length of subject is upper bound for unescaped type/value */\n\tmaxlen = strlen(subject) + 1;\n\n\tif ((type = calloc(1, maxlen)) == NULL ||\n\t    (value = calloc(1, maxlen)) == NULL ||\n\t    (name = X509_NAME_new()) == NULL)\n\t\tgoto err;\n\n\tcp = subject + 1;\n\twhile (*cp) {\n\t\t/* unescape type, terminated by '=' */\n\t\tcp = ca_x509_name_unescape(cp, type, '=');\n\t\tif (cp == NULL) {\n\t\t\tlog_warnx(\"%s: could not parse type\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\tif (!*cp) {\n\t\t\tlog_warnx(\"%s: missing value\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\t/* unescape value, terminated by '/' */\n\t\tcp = ca_x509_name_unescape(cp, value, '/');\n\t\tif (cp == NULL) {\n\t\t\tlog_warnx(\"%s: could not parse value\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\tif (!*type || !*value) {\n\t\t\tlog_warnx(\"%s: empty type or value\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\tlog_debug(\"%s: setting '%s' to '%s'\", __func__, type, value);\n\t\tif (!X509_NAME_add_entry_by_txt(name, type, MBSTRING_ASC,\n\t\t    value, -1, -1, 0)) {\n\t\t\tlog_warnx(\"%s: setting '%s' to '%s' failed\", __func__,\n\t\t\t    type, value);\n\t\t\tca_sslerror(__func__);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree(type);\n\tfree(value);\n\treturn (name);\n\nerr:\n\tX509_NAME_free(name);\n\tfree(type);\n\tfree(value);\n\treturn (NULL);\n}\n\nint\nca_validate_pubkey(struct iked *env, struct iked_static_id *id,\n    void *data, size_t len, struct iked_id *out)\n{\n\tBIO\t\t*rawcert = NULL;\n\tRSA\t\t*peerrsa = NULL, *localrsa = NULL;\n\tEC_KEY\t\t*peerec = NULL;\n\tEVP_PKEY\t*peerkey = NULL, *localkey = NULL;\n\tint\t\t ret = -1;\n\tFILE\t\t*fp = NULL;\n\tchar\t\t idstr[IKED_ID_SIZE];\n\tchar\t\t file[PATH_MAX];\n\tstruct iked_id\t idp;\n\n\tswitch (id->id_type) {\n\tcase IKEV2_ID_IPV4:\n\tcase IKEV2_ID_FQDN:\n\tcase IKEV2_ID_UFQDN:\n\tcase IKEV2_ID_IPV6:\n\t\tbreak;\n\tdefault:\n\t\t/* Some types like ASN1_DN will not be mapped to file names */\n\t\tlog_debug(\"%s: unsupported public key type %s\",\n\t\t    __func__, print_map(id->id_type, ikev2_id_map));\n\t\treturn (-1);\n\t}\n\n\tbzero(&idp, sizeof(idp));\n\tif ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)\n\t\tgoto done;\n\n\tidp.id_type = id->id_type;\n\tidp.id_offset = id->id_offset;\n\tif (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)\n\t\tgoto done;\n\n\tif (len == 0 && data) {\n\t\t/* Data is already an public key */\n\t\tpeerkey = (EVP_PKEY *)data;\n\t}\n\tif (len > 0) {\n\t\tif ((rawcert = BIO_new_mem_buf(data, len)) == NULL)\n\t\t\tgoto done;\n\n\t\tif ((peerkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else if (BIO_reset(rawcert) == 1 &&\n\t\t    (peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_debug(\"%s: unknown key type received\", __func__);\n\t\t\tgoto sslerr;\n\t\t}\n\t}\n\n\tlc_idtype(idstr);\n\tif (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||\n\t    strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {\n\t\tlog_debug(\"%s: public key id too long %s\", __func__, idstr);\n\t\tgoto done;\n\t}\n\n\tif ((fp = fopen(file, \"r\")) == NULL) {\n\t\t/* Log to debug when called from ca_validate_cert */\n\t\tlogit(len == 0 ? LOG_DEBUG : LOG_INFO,\n\t\t    \"%s: could not open public key %s\", __func__, file);\n\t\tgoto done;\n\t}\n\tlocalkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);\n\tif (localkey == NULL) {\n\t\t/* reading PKCS #8 failed, try PEM RSA */\n\t\trewind(fp);\n\t\tlocalrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);\n\t\tfclose(fp);\n\t\tif (localrsa == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((localkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif (!EVP_PKEY_set1_RSA(localkey, localrsa))\n\t\t\tgoto sslerr;\n\t} else {\n\t\tfclose(fp);\n\t}\n\tif (localkey == NULL)\n\t\tgoto sslerr;\n\n\tif (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {\n\t\tlog_debug(\"%s: public key does not match %s\", __func__, file);\n\t\tgoto done;\n\t}\n\n\tlog_debug(\"%s: valid public key in file %s\", __func__, file);\n\n\tif (out && ca_pubkey_serialize(localkey, out))\n\t\tgoto done;\n\n\tret = 0;\n sslerr:\n\tif (ret != 0)\n\t\tca_sslerror(__func__);\n done:\n\tibuf_release(idp.id_buf);\n\tif (localkey != NULL)\n\t\tEVP_PKEY_free(localkey);\n\tif (peerrsa != NULL)\n\t\tRSA_free(peerrsa);\n\tif (peerec != NULL)\n\t\tEC_KEY_free(peerec);\n\tif (localrsa != NULL)\n\t\tRSA_free(localrsa);\n\tif (rawcert != NULL) {\n\t\tBIO_free(rawcert);\n\t\tif (peerkey != NULL)\n\t\t\tEVP_PKEY_free(peerkey);\n\t}\n\n\treturn (ret);\n}\n\nint\nca_validate_cert(struct iked *env, struct iked_static_id *id,\n    void *data, size_t len)\n{\n\tstruct ca_store\t*store = env->sc_priv;\n\tX509_STORE_CTX\t csc;\n\tBIO\t\t*rawcert = NULL;\n\tX509\t\t*cert = NULL;\n\tEVP_PKEY\t*pkey;\n\tint\t\t ret = -1, result, error;\n\tX509_NAME\t*subject;\n\tconst char\t*errstr = \"failed\";\n\n\tif (len == 0) {\n\t\t/* Data is already an X509 certificate */\n\t\tcert = (X509 *)data;\n\t} else {\n\t\t/* Convert data to X509 certificate */\n\t\tif ((rawcert = BIO_new_mem_buf(data, len)) == NULL)\n\t\t\tgoto done;\n\t\tif ((cert = d2i_X509_bio(rawcert, NULL)) == NULL)\n\t\t\tgoto done;\n\t}\n\n\t/* Certificate needs a valid subjectName */\n\tif ((subject = X509_get_subject_name(cert)) == NULL) {\n\t\terrstr = \"invalid subject\";\n\t\tgoto done;\n\t}\n\n\tif (id != NULL) {\n\t\tif ((pkey = X509_get_pubkey(cert)) == NULL) {\n\t\t\terrstr = \"no public key in cert\";\n\t\t\tgoto done;\n\t\t}\n\t\tret = ca_validate_pubkey(env, id, pkey, 0, NULL);\n\t\tEVP_PKEY_free(pkey);\n\t\tif (ret == 0) {\n\t\t\terrstr = \"in public key file, ok\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tswitch (id->id_type) {\n\t\tcase IKEV2_ID_ASN1_DN:\n\t\t\tif (ca_x509_subject_cmp(cert, id) < 0) {\n\t\t\t\terrstr = \"ASN1_DN identifier mismatch\";\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ca_x509_subjectaltname_cmp(cert, id) != 0) {\n\t\t\t\terrstr = \"invalid subjectAltName extension\";\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbzero(&csc, sizeof(csc));\n\tX509_STORE_CTX_init(&csc, store->ca_cas, cert, NULL);\n\tif (store->ca_cas->param->flags & X509_V_FLAG_CRL_CHECK) {\n\t\tX509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK);\n\t\tX509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK_ALL);\n\t}\n\n\tresult = X509_verify_cert(&csc);\n\terror = csc.error;\n\tX509_STORE_CTX_cleanup(&csc);\n\tif (error != 0) {\n\t\terrstr = X509_verify_cert_error_string(error);\n\t\tgoto done;\n\t}\n\n\tif (!result) {\n\t\t/* XXX should we accept self-signed certificates? */\n\t\terrstr = \"rejecting self-signed certificate\";\n\t\tgoto done;\n\t}\n\n\t/* Success */\n\tret = 0;\n\terrstr = \"ok\";\n\n done:\n\tif (cert != NULL)\n\t\tlog_debug(\"%s: %s %.100s\", __func__, cert->name, errstr);\n\n\tif (rawcert != NULL) {\n\t\tBIO_free(rawcert);\n\t\tif (cert != NULL)\n\t\t\tX509_free(cert);\n\t}\n\n\treturn (ret);\n}\n\n/* check if subject from cert matches the id */\nint\nca_x509_subject_cmp(X509 *cert, struct iked_static_id *id)\n{\n\tX509_NAME\t*subject, *idname = NULL;\n\tconst uint8_t\t*idptr;\n\tsize_t\t\t idlen;\n\tint\t\t ret = -1;\n\n\tif (id->id_type != IKEV2_ID_ASN1_DN)\n\t\treturn (-1);\n\tif ((subject = X509_get_subject_name(cert)) == NULL)\n\t\treturn (-1);\n\tif (id->id_length <= id->id_offset)\n\t\treturn (-1);\n\tidlen = id->id_length - id->id_offset;\n\tidptr = id->id_data + id->id_offset;\n\tif ((idname = d2i_X509_NAME(NULL, &idptr, idlen)) == NULL)\n\t\treturn (-1);\n\tif (X509_NAME_cmp(subject, idname) == 0)\n\t\tret = 0;\n\tX509_NAME_free(idname);\n\treturn (ret);\n}\n\n#define MODE_ALT_LOG\t1\n#define MODE_ALT_GET\t2\n#define MODE_ALT_CMP\t3\nint\nca_x509_subjectaltname_do(X509 *cert, int mode, const char *logmsg,\n    struct iked_static_id *id, struct iked_id *retid)\n{\n\tSTACK_OF(GENERAL_NAME) *stack = NULL;\n\tGENERAL_NAME *entry;\n\tASN1_STRING *cstr;\n\tchar idstr[IKED_ID_SIZE];\n\tint idx, ret, i, type, len;\n\tuint8_t *data;\n\n\tret = -1;\n\tidx = -1;\n\twhile ((stack = X509_get_ext_d2i(cert, NID_subject_alt_name,\n\t    NULL, &idx)) != NULL) {\n\t\tfor (i = 0; i < sk_GENERAL_NAME_num(stack); i++) {\n\t\t\tentry = sk_GENERAL_NAME_value(stack, i);\n\t\t\tswitch (entry->type) {\n\t\t\tcase GEN_DNS:\n\t\t\t\tcstr = entry->d.dNSName;\n\t\t\t\tif (ASN1_STRING_type(cstr) != V_ASN1_IA5STRING)\n\t\t\t\t\tcontinue;\n\t\t\t\ttype = IKEV2_ID_FQDN;\n\t\t\t\tbreak;\n\t\t\tcase GEN_EMAIL:\n\t\t\t\tcstr = entry->d.rfc822Name;\n\t\t\t\tif (ASN1_STRING_type(cstr) != V_ASN1_IA5STRING)\n\t\t\t\t\tcontinue;\n\t\t\t\ttype = IKEV2_ID_UFQDN;\n\t\t\t\tbreak;\n\t\t\tcase GEN_IPADD:\n\t\t\t\tcstr = entry->d.iPAddress;\n\t\t\t\tswitch (ASN1_STRING_length(cstr)) {\n\t\t\t\tcase 4:\n\t\t\t\t\ttype = IKEV2_ID_IPV4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\ttype = IKEV2_ID_IPV6;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog_debug(\"%s: invalid subjectAltName\"\n\t\t\t\t\t   \" IP address\", __func__);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = ASN1_STRING_length(cstr);\n\t\t\tdata = ASN1_STRING_data(cstr);\n\t\t\tif (mode == MODE_ALT_LOG) {\n\t\t\t\tstruct iked_id sanid;\n\n\t\t\t\tbzero(&sanid, sizeof(sanid));\n\t\t\t\tsanid.id_offset = 0;\n\t\t\t\tsanid.id_type = type;\n\t\t\t\tif ((sanid.id_buf = ibuf_new(data, len))\n\t\t\t\t    == NULL) {\n\t\t\t\t\tlog_debug(\"%s: failed to get id buffer\",\n\t\t\t\t\t     __func__);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tikev2_print_id(&sanid, idstr, sizeof(idstr));\n\t\t\t\tlog_info(\"%s: altname: %s\", logmsg, idstr);\n\t\t\t\tibuf_release(sanid.id_buf);\n\t\t\t\tsanid.id_buf = NULL;\n\t\t\t}\n\t\t\t/* Compare length and data */\n\t\t\tif (mode == MODE_ALT_CMP) {\n\t\t\t\tif (type == id->id_type &&\n\t\t\t\t    (len == (id->id_length - id->id_offset)) &&\n\t\t\t\t    (memcmp(id->id_data + id->id_offset,\n\t\t\t\t    data, len)) == 0) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Get first ID */\n\t\t\tif (mode == MODE_ALT_GET) {\n\t\t\t\tibuf_release(retid->id_buf);\n\t\t\t\tif ((retid->id_buf = ibuf_new(data, len)) == NULL) {\n\t\t\t\t\tlog_debug(\"%s: failed to get id buffer\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\tret = -2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tretid->id_offset = 0;\n\t\t\t\tikev2_print_id(retid, idstr, sizeof(idstr));\n\t\t\t\tlog_debug(\"%s: %s\", __func__, idstr);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsk_GENERAL_NAME_pop_free(stack, GENERAL_NAME_free);\n\t\tif (ret != -1)\n\t\t\tbreak;\n\t}\n\tif (idx == -1)\n\t\tlog_debug(\"%s: did not find subjectAltName in certificate\",\n\t\t    __func__);\n\treturn ret;\n}\n\nint\nca_x509_subjectaltname_log(X509 *cert, const char *logmsg)\n{\n\treturn ca_x509_subjectaltname_do(cert, MODE_ALT_LOG, logmsg, NULL, NULL);\n}\n\nint\nca_x509_subjectaltname_cmp(X509 *cert, struct iked_static_id *id)\n{\n\treturn ca_x509_subjectaltname_do(cert, MODE_ALT_CMP, NULL, id, NULL);\n}\n\nint\nca_x509_subjectaltname_get(X509 *cert, struct iked_id *retid)\n{\n\treturn ca_x509_subjectaltname_do(cert, MODE_ALT_GET, NULL, NULL, retid);\n}\n\nvoid\nca_sslinit(void)\n{\n\tOpenSSL_add_all_algorithms();\n\tERR_load_crypto_strings();\n\n\t/* Init hardware crypto engines. */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n}\n\nvoid\nca_sslerror(const char *caller)\n{\n\tunsigned long\t error;\n\n\twhile ((error = ERR_get_error()) != 0)\n\t\tlog_warnx(\"%s: %s: %.100s\", __func__, caller,\n\t\t    ERR_error_string(error, NULL));\n}\n"], "fixing_code": ["/*\t$OpenBSD: ca.c,v 1.65 2020/07/27 14:22:53 tobhe Exp $\t*/\n\n/*\n * Copyright (c) 2010-2013 Reyk Floeter <reyk@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/queue.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <string.h>\n#include <signal.h>\n#include <syslog.h>\n#include <errno.h>\n#include <err.h>\n#include <pwd.h>\n#include <event.h>\n\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include <openssl/engine.h>\n#include <openssl/ssl.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <openssl/pem.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/rsa.h>\n\n#include \"iked.h\"\n#include \"ikev2.h\"\n\nvoid\t ca_run(struct privsep *, struct privsep_proc *, void *);\nvoid\t ca_shutdown(struct privsep_proc *);\nvoid\t ca_reset(struct privsep *);\nint\t ca_reload(struct iked *);\n\nint\t ca_getreq(struct iked *, struct imsg *);\nint\t ca_getcert(struct iked *, struct imsg *);\nint\t ca_getauth(struct iked *, struct imsg *);\nX509\t*ca_by_subjectpubkey(X509_STORE *, uint8_t *, size_t);\nX509\t*ca_by_issuer(X509_STORE *, X509_NAME *, struct iked_static_id *);\nX509\t*ca_by_subjectaltname(X509_STORE *, struct iked_static_id *);\nvoid\t ca_store_certs_info(const char *, X509_STORE *);\nint\t ca_subjectpubkey_digest(X509 *, uint8_t *, unsigned int *);\nint\t ca_x509_subject_cmp(X509 *, struct iked_static_id *);\nint\t ca_validate_pubkey(struct iked *, struct iked_static_id *,\n\t    void *, size_t, struct iked_id *);\nint\t ca_validate_cert(struct iked *, struct iked_static_id *,\n\t    void *, size_t);\nint\t ca_privkey_to_method(struct iked_id *);\nstruct ibuf *\n\t ca_x509_serialize(X509 *);\nint\t ca_x509_subjectaltname_do(X509 *, int, const char *,\n\t    struct iked_static_id *, struct iked_id *);\nint\t ca_x509_subjectaltname_cmp(X509 *, struct iked_static_id *);\nint\t ca_x509_subjectaltname_log(X509 *, const char *);\nint\t ca_x509_subjectaltname_get(X509 *cert, struct iked_id *);\nint\t ca_dispatch_parent(int, struct privsep_proc *, struct imsg *);\nint\t ca_dispatch_ikev2(int, struct privsep_proc *, struct imsg *);\n\nstatic struct privsep_proc procs[] = {\n\t{ \"parent\",\tPROC_PARENT,\tca_dispatch_parent },\n\t{ \"ikev2\",\tPROC_IKEV2,\tca_dispatch_ikev2 }\n};\n\nstruct ca_store {\n\tX509_STORE\t*ca_cas;\n\tX509_LOOKUP\t*ca_calookup;\n\n\tX509_STORE\t*ca_certs;\n\tX509_LOOKUP\t*ca_certlookup;\n\n\tstruct iked_id\t ca_privkey;\n\tstruct iked_id\t ca_pubkey;\n\n\tuint8_t\t\t ca_privkey_method;\n};\n\npid_t\ncaproc(struct privsep *ps, struct privsep_proc *p)\n{\n\treturn (proc_run(ps, p, procs, nitems(procs), ca_run, NULL));\n}\n\nvoid\nca_run(struct privsep *ps, struct privsep_proc *p, void *arg)\n{\n\tstruct iked\t*env = ps->ps_env;\n\tstruct ca_store\t*store;\n\n\t/*\n\t * pledge in the ca process:\n\t * stdio - for malloc and basic I/O including events.\n\t * rpath - for certificate files.\n\t * recvfd - for ocsp sockets.\n\t */\n\tif (pledge(\"stdio rpath recvfd\", NULL) == -1)\n\t\tfatal(\"pledge\");\n\n\tif ((store = calloc(1, sizeof(*store))) == NULL)\n\t\tfatal(\"%s: failed to allocate cert store\", __func__);\n\n\tenv->sc_priv = store;\n\tp->p_shutdown = ca_shutdown;\n}\n\nvoid\nca_shutdown(struct privsep_proc *p)\n{\n\tstruct iked             *env = p->p_env;\n\tstruct ca_store\t\t*store;\n\n\tif (env == NULL)\n\t\treturn;\n\tibuf_release(env->sc_certreq);\n\tif ((store = env->sc_priv) == NULL)\n\t\treturn;\n\tibuf_release(store->ca_pubkey.id_buf);\n\tibuf_release(store->ca_privkey.id_buf);\n\tfree(store);\n}\n\nvoid\nca_getkey(struct privsep *ps, struct iked_id *key, enum imsg_type type)\n{\n\tstruct iked\t*env = ps->ps_env;\n\tstruct ca_store\t*store = env->sc_priv;\n\tstruct iked_id\t*id;\n\tconst char\t*name;\n\n\tif (store == NULL)\n\t\tfatalx(\"%s: invalid store\", __func__);\n\n\tif (type == IMSG_PRIVKEY) {\n\t\tname = \"private\";\n\t\tid = &store->ca_privkey;\n\n\t\tstore->ca_privkey_method = ca_privkey_to_method(key);\n\t\tif (store->ca_privkey_method == IKEV2_AUTH_NONE)\n\t\t\tfatalx(\"ca: failed to get auth method for privkey\");\n\t} else if (type == IMSG_PUBKEY) {\n\t\tname = \"public\";\n\t\tid = &store->ca_pubkey;\n\t} else\n\t\tfatalx(\"%s: invalid type %d\", __func__, type);\n\n\tlog_debug(\"%s: received %s key type %s length %zd\", __func__,\n\t    name, print_map(key->id_type, ikev2_cert_map),\n\t    ibuf_length(key->id_buf));\n\n\t/* clear old key and copy new one */\n\tibuf_release(id->id_buf);\n\tmemcpy(id, key, sizeof(*id));\n}\n\nvoid\nca_reset(struct privsep *ps)\n{\n\tstruct iked\t*env = ps->ps_env;\n\tstruct ca_store\t*store = env->sc_priv;\n\n\tif (store->ca_privkey.id_type == IKEV2_ID_NONE ||\n\t    store->ca_pubkey.id_type == IKEV2_ID_NONE)\n\t\tfatalx(\"ca_reset: keys not loaded\");\n\n\tif (store->ca_cas != NULL)\n\t\tX509_STORE_free(store->ca_cas);\n\tif (store->ca_certs != NULL)\n\t\tX509_STORE_free(store->ca_certs);\n\n\tif ((store->ca_cas = X509_STORE_new()) == NULL)\n\t\tfatalx(\"ca_reset: failed to get ca store\");\n\tif ((store->ca_calookup = X509_STORE_add_lookup(store->ca_cas,\n\t    X509_LOOKUP_file())) == NULL)\n\t\tfatalx(\"ca_reset: failed to add ca lookup\");\n\n\tif ((store->ca_certs = X509_STORE_new()) == NULL)\n\t\tfatalx(\"ca_reset: failed to get cert store\");\n\tif ((store->ca_certlookup = X509_STORE_add_lookup(store->ca_certs,\n\t    X509_LOOKUP_file())) == NULL)\n\t\tfatalx(\"ca_reset: failed to add cert lookup\");\n\n\tif (ca_reload(env) != 0)\n\t\tfatal(\"ca_reset: reload\");\n}\n\nint\nca_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)\n{\n\tstruct iked\t\t*env = p->p_env;\n\tunsigned int\t\t mode;\n\n\tswitch (imsg->hdr.type) {\n\tcase IMSG_CTL_RESET:\n\t\tIMSG_SIZE_CHECK(imsg, &mode);\n\t\tmemcpy(&mode, imsg->data, sizeof(mode));\n\t\tif (mode == RESET_ALL || mode == RESET_CA) {\n\t\t\tlog_debug(\"%s: config reset\", __func__);\n\t\t\tca_reset(&env->sc_ps);\n\t\t}\n\t\tbreak;\n\tcase IMSG_OCSP_FD:\n\t\tocsp_receive_fd(env, imsg);\n\t\tbreak;\n\tcase IMSG_OCSP_URL:\n\t\tconfig_getocsp(env, imsg);\n\t\tbreak;\n\tcase IMSG_PRIVKEY:\n\tcase IMSG_PUBKEY:\n\t\tconfig_getkey(env, imsg);\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nint\nca_dispatch_ikev2(int fd, struct privsep_proc *p, struct imsg *imsg)\n{\n\tstruct iked\t*env = p->p_env;\n\n\tswitch (imsg->hdr.type) {\n\tcase IMSG_CERTREQ:\n\t\tca_getreq(env, imsg);\n\t\tbreak;\n\tcase IMSG_CERT:\n\t\tca_getcert(env, imsg);\n\t\tbreak;\n\tcase IMSG_AUTH:\n\t\tca_getauth(env, imsg);\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nint\nca_setcert(struct iked *env, struct iked_sahdr *sh, struct iked_id *id,\n    uint8_t type, uint8_t *data, size_t len, enum privsep_procid procid)\n{\n\tstruct iovec\t\tiov[4];\n\tint\t\t\tiovcnt = 0;\n\tstruct iked_static_id\tidb;\n\n\t/* Must send the cert and a valid Id to the ca process */\n\tif (procid == PROC_CERT) {\n\t\tif (id == NULL || id->id_type == IKEV2_ID_NONE ||\n\t\t    ibuf_length(id->id_buf) > IKED_ID_SIZE)\n\t\t\treturn (-1);\n\t\tbzero(&idb, sizeof(idb));\n\n\t\t/* Convert to a static Id */\n\t\tidb.id_type = id->id_type;\n\t\tidb.id_offset = id->id_offset;\n\t\tidb.id_length = ibuf_length(id->id_buf);\n\t\tmemcpy(&idb.id_data, ibuf_data(id->id_buf),\n\t\t    ibuf_length(id->id_buf));\n\n\t\tiov[iovcnt].iov_base = &idb;\n\t\tiov[iovcnt].iov_len = sizeof(idb);\n\t\tiovcnt++;\n\t}\n\n\tiov[iovcnt].iov_base = sh;\n\tiov[iovcnt].iov_len = sizeof(*sh);\n\tiovcnt++;\n\tiov[iovcnt].iov_base = &type;\n\tiov[iovcnt].iov_len = sizeof(type);\n\tiovcnt++;\n\tif (data != NULL) {\n\t\tiov[iovcnt].iov_base = data;\n\t\tiov[iovcnt].iov_len = len;\n\t\tiovcnt++;\n\t}\n\n\tif (proc_composev(&env->sc_ps, procid, IMSG_CERT, iov, iovcnt) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\nint\nca_setreq(struct iked *env, struct iked_sa *sa,\n    struct iked_static_id *localid, uint8_t type, uint8_t more, uint8_t *data,\n    size_t len, enum privsep_procid procid)\n{\n\tstruct iovec\t\tiov[5];\n\tint\t\t\tiovcnt = 0;\n\tstruct iked_static_id\tidb;\n\tstruct iked_id\t\tid;\n\tint\t\t\tret = -1;\n\n\t/* Convert to a static Id */\n\tbzero(&id, sizeof(id));\n\tif (ikev2_policy2id(localid, &id, 1) != 0)\n\t\treturn (-1);\n\n\tbzero(&idb, sizeof(idb));\n\tidb.id_type = id.id_type;\n\tidb.id_offset = id.id_offset;\n\tidb.id_length = ibuf_length(id.id_buf);\n\tmemcpy(&idb.id_data, ibuf_data(id.id_buf),\n\t    ibuf_length(id.id_buf));\n\tiov[iovcnt].iov_base = &idb;\n\tiov[iovcnt].iov_len = sizeof(idb);\n\tiovcnt++;\n\n\tiov[iovcnt].iov_base = &sa->sa_hdr;\n\tiov[iovcnt].iov_len = sizeof(sa->sa_hdr);\n\tiovcnt++;\n\tiov[iovcnt].iov_base = &type;\n\tiov[iovcnt].iov_len = sizeof(type);\n\tiovcnt++;\n\tiov[iovcnt].iov_base = &more;\n\tiov[iovcnt].iov_len = sizeof(more);\n\tiovcnt++;\n\tif (data != NULL) {\n\t\tiov[iovcnt].iov_base = data;\n\t\tiov[iovcnt].iov_len = len;\n\t\tiovcnt++;\n\t}\n\n\tif (proc_composev(&env->sc_ps, procid, IMSG_CERTREQ, iov, iovcnt) == -1)\n\t\tgoto done;\n\n\tsa_stateflags(sa, IKED_REQ_CERTREQ);\n\n\tret = 0;\n done:\n\tibuf_release(id.id_buf);\n\treturn (ret);\n}\n\nstatic int\nauth_sig_compatible(uint8_t type)\n{\n\tswitch (type) {\n\tcase IKEV2_AUTH_RSA_SIG:\n\tcase IKEV2_AUTH_ECDSA_256:\n\tcase IKEV2_AUTH_ECDSA_384:\n\tcase IKEV2_AUTH_ECDSA_521:\n\tcase IKEV2_AUTH_SIG_ANY:\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nint\nca_setauth(struct iked *env, struct iked_sa *sa,\n    struct ibuf *authmsg, enum privsep_procid id)\n{\n\tstruct iovec\t\t iov[3];\n\tint\t\t\t iovcnt = 3;\n\tstruct iked_policy\t*policy = sa->sa_policy;\n\tuint8_t\t\t\t type = policy->pol_auth.auth_method;\n\n\tif (id == PROC_CERT) {\n\t\t/* switch encoding to IKEV2_AUTH_SIG if SHA2 is supported */\n\t\tif (sa->sa_sigsha2 && auth_sig_compatible(type)) {\n\t\t\tlog_debug(\"%s: switching %s to SIG\", __func__,\n\t\t\t    print_map(type, ikev2_auth_map));\n\t\t\ttype = IKEV2_AUTH_SIG;\n\t\t} else if (!sa->sa_sigsha2 && type == IKEV2_AUTH_SIG_ANY) {\n\t\t\tlog_debug(\"%s: switching SIG to RSA_SIG(*)\", __func__);\n\t\t\t/* XXX ca might auto-switch to ECDSA */\n\t\t\ttype = IKEV2_AUTH_RSA_SIG;\n\t\t} else if (type == IKEV2_AUTH_SIG) {\n\t\t\tlog_debug(\"%s: using SIG (RFC7427)\", __func__);\n\t\t}\n\t}\n\n\tif (type == IKEV2_AUTH_SHARED_KEY_MIC) {\n\t\tsa->sa_stateflags |= IKED_REQ_AUTH;\n\t\treturn (ikev2_msg_authsign(env, sa,\n\t\t    &policy->pol_auth, authmsg));\n\t}\n\n\tiov[0].iov_base = &sa->sa_hdr;\n\tiov[0].iov_len = sizeof(sa->sa_hdr);\n\tiov[1].iov_base = &type;\n\tiov[1].iov_len = sizeof(type);\n\tif (type == IKEV2_AUTH_NONE)\n\t\tiovcnt--;\n\telse {\n\t\tiov[2].iov_base = ibuf_data(authmsg);\n\t\tiov[2].iov_len = ibuf_size(authmsg);\n\t\tlog_debug(\"%s: auth length %zu\", __func__, ibuf_size(authmsg));\n\t}\n\n\tif (proc_composev(&env->sc_ps, id, IMSG_AUTH, iov, iovcnt) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\nint\nca_getcert(struct iked *env, struct imsg *imsg)\n{\n\tstruct iked_sahdr\t sh;\n\tuint8_t\t\t\t type;\n\tuint8_t\t\t\t*ptr;\n\tsize_t\t\t\t len;\n\tstruct iked_static_id\t id;\n\tunsigned int\t\t i;\n\tstruct iovec\t\t iov[3];\n\tint\t\t\t iovcnt = 3, cmd, ret = 0;\n\tstruct iked_id\t\t key;\n\n\tptr = (uint8_t *)imsg->data;\n\tlen = IMSG_DATA_SIZE(imsg);\n\ti = sizeof(id) + sizeof(sh) + sizeof(type);\n\tif (len < i)\n\t\treturn (-1);\n\n\tmemcpy(&id, ptr, sizeof(id));\n\tif (id.id_type == IKEV2_ID_NONE)\n\t\treturn (-1);\n\tmemcpy(&sh, ptr + sizeof(id), sizeof(sh));\n\tmemcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(uint8_t));\n\n\tptr += i;\n\tlen -= i;\n\n\tbzero(&key, sizeof(key));\n\n\tswitch (type) {\n\tcase IKEV2_CERT_X509_CERT:\n\t\tret = ca_validate_cert(env, &id, ptr, len);\n\t\tif (ret == 0 && env->sc_ocsp_url) {\n\t\t\tret = ocsp_validate_cert(env, &id, ptr, len, sh, type);\n\t\t\tif (ret == 0)\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase IKEV2_CERT_RSA_KEY:\n\tcase IKEV2_CERT_ECDSA:\n\t\tret = ca_validate_pubkey(env, &id, ptr, len, NULL);\n\t\tbreak;\n\tcase IKEV2_CERT_NONE:\n\t\t/* Fallback to public key */\n\t\tret = ca_validate_pubkey(env, &id, NULL, 0, &key);\n\t\tif (ret == 0) {\n\t\t\tptr = ibuf_data(key.id_buf);\n\t\t\tlen = ibuf_length(key.id_buf);\n\t\t\ttype = key.id_type;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unsupported cert type %d\", __func__, type);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\tcmd = IMSG_CERTVALID;\n\telse\n\t\tcmd = IMSG_CERTINVALID;\n\n\tiov[0].iov_base = &sh;\n\tiov[0].iov_len = sizeof(sh);\n\tiov[1].iov_base = &type;\n\tiov[1].iov_len = sizeof(type);\n\tiov[2].iov_base = ptr;\n\tiov[2].iov_len = len;\n\n\tif (proc_composev(&env->sc_ps, PROC_IKEV2, cmd, iov, iovcnt) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\nint\nca_getreq(struct iked *env, struct imsg *imsg)\n{\n\tstruct ca_store\t\t*store = env->sc_priv;\n\tstruct iked_sahdr\t sh;\n\tuint8_t\t\t\t type, more;\n\tuint8_t\t\t\t*ptr;\n\tsize_t\t\t\t len;\n\tunsigned int\t\t i;\n\tX509\t\t\t*ca = NULL, *cert = NULL;\n\tstruct ibuf\t\t*buf;\n\tstruct iked_static_id\t id;\n\tchar\t\t\t idstr[IKED_ID_SIZE];\n\n\tptr = (uint8_t *)imsg->data;\n\tlen = IMSG_DATA_SIZE(imsg);\n\ti = sizeof(id) + sizeof(type) + sizeof(sh) + sizeof(more);\n\tif (len < i)\n\t\treturn (-1);\n\n\tmemcpy(&id, ptr, sizeof(id));\n\tif (id.id_type == IKEV2_ID_NONE)\n\t\treturn (-1);\n\tmemcpy(&sh, ptr + sizeof(id), sizeof(sh));\n\tmemcpy(&type, ptr + sizeof(id) + sizeof(sh), sizeof(type));\n\tmemcpy(&more, ptr + sizeof(id) + sizeof(sh) + sizeof(type), sizeof(more));\n\n\tptr += i;\n\tlen -= i;\n\n\tswitch (type) {\n\tcase IKEV2_CERT_RSA_KEY:\n\tcase IKEV2_CERT_ECDSA:\n\t\t/*\n\t\t * Find a local raw public key that matches the type\n\t\t * received in the CERTREQ payoad\n\t\t */\n\t\tif (store->ca_pubkey.id_type != type ||\n\t\t    store->ca_pubkey.id_buf == NULL)\n\t\t\tgoto fallback;\n\n\t\tbuf = ibuf_dup(store->ca_pubkey.id_buf);\n\t\tlog_debug(\"%s: using local public key of type %s\", __func__,\n\t\t    print_map(type, ikev2_cert_map));\n\t\tbreak;\n\tcase IKEV2_CERT_X509_CERT:\n\t\tif (len == 0 || len % SHA_DIGEST_LENGTH) {\n\t\t\tlog_info(\"%s: invalid CERTREQ data.\",\n\t\t\t    SPI_SH(&sh, __func__));\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Find a local certificate signed by any of the CAs\n\t\t * received in the CERTREQ payload\n\t\t */\n\t\tfor (i = 0; i < len; i += SHA_DIGEST_LENGTH) {\n\t\t\tif ((ca = ca_by_subjectpubkey(store->ca_cas, ptr + i,\n\t\t\t    SHA_DIGEST_LENGTH)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tlog_debug(\"%s: found CA %s\", __func__, ca->name);\n\n\t\t\tif ((cert = ca_by_issuer(store->ca_certs,\n\t\t\t    X509_get_subject_name(ca), &id)) != NULL) {\n\t\t\t\t/* XXX\n\t\t\t\t * should we re-validate our own cert here?\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Fallthrough */\n\tcase IKEV2_CERT_NONE:\n fallback:\n\t\t/*\n\t\t * If no certificate or key matching any of the trust-anchors\n\t\t * was found and this was the last CERTREQ, try to find one with\n\t\t * subjectAltName matching the ID\n\t\t */\n\t\tif (more)\n\t\t\treturn (0);\n\n\t\tif (cert == NULL)\n\t\t\tcert = ca_by_subjectaltname(store->ca_certs, &id);\n\n\t\t/* If there is no matching certificate use local raw pubkey */\n\t\tif (cert == NULL) {\n\t\t\tif (ikev2_print_static_id(&id, idstr, sizeof(idstr)) == -1)\n\t\t\t\treturn (-1);\n\t\t\tlog_info(\"%s: no valid local certificate found for %s\",\n\t\t\t    SPI_SH(&sh, __func__), idstr);\n\t\t\tca_store_certs_info(SPI_SH(&sh, __func__),\n\t\t\t    store->ca_certs);\n\t\t\tif (store->ca_pubkey.id_buf == NULL)\n\t\t\t\treturn (-1);\n\t\t\tbuf = ibuf_dup(store->ca_pubkey.id_buf);\n\t\t\ttype = store->ca_pubkey.id_type;\n\t\t\tlog_info(\"%s: using local public key of type %s\",\n\t\t\t    SPI_SH(&sh, __func__),\n\t\t\t    print_map(type, ikev2_cert_map));\n\t\t\tbreak;\n\t\t}\n\n\t\tlog_debug(\"%s: found local certificate %s\", __func__,\n\t\t    cert->name);\n\n\t\tif ((buf = ca_x509_serialize(cert)) == NULL)\n\t\t\treturn (-1);\n\t\tbreak;\n\tdefault:\n\t\tlog_warnx(\"%s: unknown cert type requested\",\n\t\t    SPI_SH(&sh, __func__));\n\t\treturn (-1);\n\t}\n\n\tca_setcert(env, &sh, NULL, type,\n\t    ibuf_data(buf), ibuf_size(buf), PROC_IKEV2);\n\tibuf_release(buf);\n\n\treturn (0);\n}\n\nint\nca_getauth(struct iked *env, struct imsg *imsg)\n{\n\tstruct ca_store\t\t*store = env->sc_priv;\n\tstruct iked_sahdr\t sh;\n\tuint8_t\t\t\t method;\n\tuint8_t\t\t\t*ptr;\n\tsize_t\t\t\t len;\n\tunsigned int\t\t i;\n\tint\t\t\t ret = -1;\n\tstruct iked_sa\t\t sa;\n\tstruct iked_policy\t policy;\n\tstruct iked_id\t\t*id;\n\tstruct ibuf\t\t*authmsg;\n\n\tptr = (uint8_t *)imsg->data;\n\tlen = IMSG_DATA_SIZE(imsg);\n\ti = sizeof(method) + sizeof(sh);\n\tif (len <= i)\n\t\treturn (-1);\n\n\tmemcpy(&sh, ptr, sizeof(sh));\n\tmemcpy(&method, ptr + sizeof(sh), sizeof(uint8_t));\n\tif (method == IKEV2_AUTH_SHARED_KEY_MIC)\n\t\treturn (-1);\n\n\tptr += i;\n\tlen -= i;\n\n\tif ((authmsg = ibuf_new(ptr, len)) == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * Create fake SA and policy\n\t */\n\tbzero(&sa, sizeof(sa));\n\tbzero(&policy, sizeof(policy));\n\tmemcpy(&sa.sa_hdr, &sh, sizeof(sh));\n\tsa.sa_policy = &policy;\n\tif (sh.sh_initiator)\n\t\tid = &sa.sa_icert;\n\telse\n\t\tid = &sa.sa_rcert;\n\tmemcpy(id, &store->ca_privkey, sizeof(*id));\n\tpolicy.pol_auth.auth_method = method == IKEV2_AUTH_SIG ?\n\t    method : store->ca_privkey_method;\n\n\tif (ikev2_msg_authsign(env, &sa, &policy.pol_auth, authmsg) != 0) {\n\t\tlog_debug(\"%s: AUTH sign failed\", __func__);\n\t\tpolicy.pol_auth.auth_method = IKEV2_AUTH_NONE;\n\t}\n\n\tret = ca_setauth(env, &sa, sa.sa_localauth.id_buf, PROC_IKEV2);\n\n\tibuf_release(sa.sa_localauth.id_buf);\n\tsa.sa_localauth.id_buf = NULL;\n\tibuf_release(authmsg);\n\n\treturn (ret);\n}\n\nint\nca_reload(struct iked *env)\n{\n\tstruct ca_store\t\t*store = env->sc_priv;\n\tuint8_t\t\t\t md[EVP_MAX_MD_SIZE];\n\tchar\t\t\t file[PATH_MAX];\n\tstruct iovec\t\t iov[2];\n\tstruct dirent\t\t*entry;\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*x509;\n\tDIR\t\t\t*dir;\n\tint\t\t\t i, len, iovcnt = 0;\n\n\t/*\n\t * Load CAs\n\t */\n\tif ((dir = opendir(IKED_CA_DIR)) == NULL)\n\t\treturn (-1);\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif ((entry->d_type != DT_REG) &&\n\t\t    (entry->d_type != DT_LNK))\n\t\t\tcontinue;\n\n\t\tif (snprintf(file, sizeof(file), \"%s%s\",\n\t\t    IKED_CA_DIR, entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tif (!X509_load_cert_file(store->ca_calookup, file,\n\t\t    X509_FILETYPE_PEM)) {\n\t\t\tlog_warn(\"%s: failed to load ca file %s\", __func__,\n\t\t\t    entry->d_name);\n\t\t\tca_sslerror(__func__);\n\t\t\tcontinue;\n\t\t}\n\t\tlog_debug(\"%s: loaded ca file %s\", __func__, entry->d_name);\n\t}\n\tclosedir(dir);\n\n\t/*\n\t * Load CRLs for the CAs\n\t */\n\tif ((dir = opendir(IKED_CRL_DIR)) == NULL)\n\t\treturn (-1);\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif ((entry->d_type != DT_REG) &&\n\t\t    (entry->d_type != DT_LNK))\n\t\t\tcontinue;\n\n\t\tif (snprintf(file, sizeof(file), \"%s%s\",\n\t\t    IKED_CRL_DIR, entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tif (!X509_load_crl_file(store->ca_calookup, file,\n\t\t    X509_FILETYPE_PEM)) {\n\t\t\tlog_warn(\"%s: failed to load crl file %s\", __func__,\n\t\t\t    entry->d_name);\n\t\t\tca_sslerror(__func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Only enable CRL checks if we actually loaded a CRL */\n\t\tX509_STORE_set_flags(store->ca_cas, X509_V_FLAG_CRL_CHECK);\n\n\t\tlog_debug(\"%s: loaded crl file %s\", __func__, entry->d_name);\n\t}\n\tclosedir(dir);\n\n\t/*\n\t * Save CAs signatures for the IKEv2 CERTREQ\n\t */\n\tibuf_release(env->sc_certreq);\n\tif ((env->sc_certreq = ibuf_new(NULL, 0)) == NULL)\n\t\treturn (-1);\n\n\th = store->ca_cas->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tx509 = xo->data.x509;\n\t\tlen = sizeof(md);\n\t\tca_subjectpubkey_digest(x509, md, &len);\n\t\tlog_debug(\"%s: %s\", __func__, x509->name);\n\n\t\tif (ibuf_add(env->sc_certreq, md, len) != 0) {\n\t\t\tibuf_release(env->sc_certreq);\n\t\t\tenv->sc_certreq = NULL;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (ibuf_length(env->sc_certreq)) {\n\t\tenv->sc_certreqtype = IKEV2_CERT_X509_CERT;\n\t\tiov[0].iov_base = &env->sc_certreqtype;\n\t\tiov[0].iov_len = sizeof(env->sc_certreqtype);\n\t\tiovcnt++;\n\t\tiov[1].iov_base = ibuf_data(env->sc_certreq);\n\t\tiov[1].iov_len = ibuf_length(env->sc_certreq);\n\t\tiovcnt++;\n\n\t\tlog_debug(\"%s: loaded %zu ca certificate%s\", __func__,\n\t\t    ibuf_length(env->sc_certreq) / SHA_DIGEST_LENGTH,\n\t\t    ibuf_length(env->sc_certreq) == SHA_DIGEST_LENGTH ?\n\t\t    \"\" : \"s\");\n\n\t\t(void)proc_composev(&env->sc_ps, PROC_IKEV2, IMSG_CERTREQ,\n\t\t    iov, iovcnt);\n\t}\n\n\t/*\n\t * Load certificates\n\t */\n\tif ((dir = opendir(IKED_CERT_DIR)) == NULL)\n\t\treturn (-1);\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tif ((entry->d_type != DT_REG) &&\n\t\t    (entry->d_type != DT_LNK))\n\t\t\tcontinue;\n\n\t\tif (snprintf(file, sizeof(file), \"%s%s\",\n\t\t    IKED_CERT_DIR, entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tif (!X509_load_cert_file(store->ca_certlookup, file,\n\t\t    X509_FILETYPE_PEM)) {\n\t\t\tlog_warn(\"%s: failed to load cert file %s\", __func__,\n\t\t\t    entry->d_name);\n\t\t\tca_sslerror(__func__);\n\t\t\tcontinue;\n\t\t}\n\t\tlog_debug(\"%s: loaded cert file %s\", __func__, entry->d_name);\n\t}\n\tclosedir(dir);\n\n\th = store->ca_certs->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tx509 = xo->data.x509;\n\n\t\t(void)ca_validate_cert(env, NULL, x509, 0);\n\t}\n\n\tif (!env->sc_certreqtype)\n\t\tenv->sc_certreqtype = store->ca_pubkey.id_type;\n\n\tlog_debug(\"%s: local cert type %s\", __func__,\n\t    print_map(env->sc_certreqtype, ikev2_cert_map));\n\n\tiov[0].iov_base = &env->sc_certreqtype;\n\tiov[0].iov_len = sizeof(env->sc_certreqtype);\n\tif (iovcnt == 0)\n\t\tiovcnt++;\n\t(void)proc_composev(&env->sc_ps, PROC_IKEV2, IMSG_CERTREQ, iov, iovcnt);\n\n\treturn (0);\n}\n\nX509 *\nca_by_subjectpubkey(X509_STORE *ctx, uint8_t *sig, size_t siglen)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*ca;\n\tint\t\t\t i;\n\tunsigned int\t\t len;\n\tuint8_t\t\t\t md[EVP_MAX_MD_SIZE];\n\n\th = ctx->objs;\n\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tca = xo->data.x509;\n\t\tlen = sizeof(md);\n\t\tca_subjectpubkey_digest(ca, md, &len);\n\n\t\tif (len == siglen && memcmp(md, sig, len) == 0)\n\t\t\treturn (ca);\n\t}\n\n\treturn (NULL);\n}\n\nX509 *\nca_by_issuer(X509_STORE *ctx, X509_NAME *subject, struct iked_static_id *id)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*cert;\n\tint\t\t\t i;\n\tX509_NAME\t\t*issuer;\n\n\tif (subject == NULL)\n\t\treturn (NULL);\n\n\th = ctx->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tcert = xo->data.x509;\n\t\tif ((issuer = X509_get_issuer_name(cert)) == NULL)\n\t\t\tcontinue;\n\t\telse if (X509_NAME_cmp(subject, issuer) == 0) {\n\t\t\tswitch (id->id_type) {\n\t\t\tcase IKEV2_ID_ASN1_DN:\n\t\t\t\tif (ca_x509_subject_cmp(cert, id) == 0)\n\t\t\t\t\treturn (cert);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ca_x509_subjectaltname_cmp(cert, id) == 0)\n\t\t\t\t\treturn (cert);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nX509 *\nca_by_subjectaltname(X509_STORE *ctx, struct iked_static_id *id)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*cert;\n\tint\t\t\t i;\n\n\th = ctx->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\n\t\tcert = xo->data.x509;\n\t\tswitch (id->id_type) {\n\t\tcase IKEV2_ID_ASN1_DN:\n\t\t\tif (ca_x509_subject_cmp(cert, id) == 0)\n\t\t\t\treturn (cert);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ca_x509_subjectaltname_cmp(cert, id) == 0)\n\t\t\t\treturn (cert);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nvoid\nca_store_certs_info(const char *msg, X509_STORE *ctx)\n{\n\tSTACK_OF(X509_OBJECT)\t*h;\n\tX509_OBJECT\t\t*xo;\n\tX509\t\t\t*cert;\n\tint\t\t\t i;\n\n\th = ctx->objs;\n\tfor (i = 0; i < sk_X509_OBJECT_num(h); i++) {\n\t\txo = sk_X509_OBJECT_value(h, i);\n\t\tif (xo->type != X509_LU_X509)\n\t\t\tcontinue;\n\t\tcert = xo->data.x509;\n\t\tca_cert_info(msg, cert);\n\t}\n}\n\nvoid\nca_cert_info(const char *msg, X509 *cert)\n{\n\tASN1_INTEGER\t*asn1_serial;\n\tBUF_MEM\t\t*memptr;\n\tBIO\t\t*rawserial = NULL;\n\tchar\t\t buf[BUFSIZ];\n\n\tif ((asn1_serial = X509_get_serialNumber(cert)) == NULL ||\n\t    (rawserial = BIO_new(BIO_s_mem())) == NULL ||\n\t    i2a_ASN1_INTEGER(rawserial, asn1_serial) <= 0)\n\t\tgoto out;\n\tif (X509_NAME_oneline(X509_get_issuer_name(cert), buf, sizeof(buf)))\n\t\tlog_info(\"%s: issuer: %s\", msg, buf);\n\tBIO_get_mem_ptr(rawserial, &memptr);\n\tif (memptr->data != NULL && memptr->length < INT32_MAX)\n\t\tlog_info(\"%s: serial: %.*s\", msg, (int)memptr->length,\n\t\t    memptr->data);\n\tif (X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof(buf)))\n\t\tlog_info(\"%s: subject: %s\", msg, buf);\n\tca_x509_subjectaltname_log(cert, msg);\nout:\n\tif (rawserial)\n\t\tBIO_free(rawserial);\n}\n\nint\nca_subjectpubkey_digest(X509 *x509, uint8_t *md, unsigned int *size)\n{\n\tEVP_PKEY\t*pkey;\n\tuint8_t\t\t*buf = NULL;\n\tint\t\t buflen;\n\n\tif (*size < SHA_DIGEST_LENGTH)\n\t\treturn (-1);\n\n\t/*\n\t * Generate a SHA-1 digest of the Subject Public Key Info\n\t * element in the X.509 certificate, an ASN.1 sequence\n\t * that includes the public key type (eg. RSA) and the\n\t * public key value (see 3.7 of RFC7296).\n\t */\n\tif ((pkey = X509_get_pubkey(x509)) == NULL)\n\t\treturn (-1);\n\tbuflen = i2d_PUBKEY(pkey, &buf);\n\tEVP_PKEY_free(pkey);\n\tif (buflen == 0)\n\t\treturn (-1);\n\tif (!EVP_Digest(buf, buflen, md, size, EVP_sha1(), NULL)) {\n\t\tfree(buf);\n\t\treturn (-1);\n\t}\n\tfree(buf);\n\n\treturn (0);\n}\n\nstruct ibuf *\nca_x509_serialize(X509 *x509)\n{\n\tlong\t\t len;\n\tstruct ibuf\t*buf;\n\tuint8_t\t\t*d = NULL;\n\tBIO\t\t*out;\n\n\tif ((out = BIO_new(BIO_s_mem())) == NULL)\n\t\treturn (NULL);\n\tif (!i2d_X509_bio(out, x509)) {\n\t\tBIO_free(out);\n\t\treturn (NULL);\n\t}\n\n\tlen = BIO_get_mem_data(out, &d);\n\tbuf = ibuf_new(d, len);\n\tBIO_free(out);\n\n\treturn (buf);\n}\n\nint\nca_pubkey_serialize(EVP_PKEY *key, struct iked_id *id)\n{\n\tRSA\t\t*rsa = NULL;\n\tEC_KEY\t\t*ec = NULL;\n\tuint8_t\t\t*d;\n\tint\t\t len = 0;\n\tint\t\t ret = -1;\n\n\tswitch (key->type) {\n\tcase EVP_PKEY_RSA:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((rsa = EVP_PKEY_get1_RSA(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_RSAPublicKey(rsa, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_RSAPublicKey(rsa, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_RSA_KEY;\n\t\tbreak;\n\tcase EVP_PKEY_EC:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((ec = EVP_PKEY_get1_EC_KEY(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_EC_PUBKEY(ec, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_EC_PUBKEY(ec, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_ECDSA;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unsupported key type %d\", __func__, key->type);\n\t\treturn (-1);\n\t}\n\n\tlog_debug(\"%s: type %s length %d\", __func__,\n\t    print_map(id->id_type, ikev2_cert_map), len);\n\n\tret = 0;\n done:\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n\tif (ec != NULL)\n\t\tEC_KEY_free(ec);\n\treturn (ret);\n}\n\nint\nca_privkey_serialize(EVP_PKEY *key, struct iked_id *id)\n{\n\tRSA\t\t*rsa = NULL;\n\tEC_KEY\t\t*ec = NULL;\n\tuint8_t\t\t*d;\n\tint\t\t len = 0;\n\tint\t\t ret = -1;\n\n\tswitch (key->type) {\n\tcase EVP_PKEY_RSA:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((rsa = EVP_PKEY_get1_RSA(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_RSAPrivateKey(rsa, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_RSAPrivateKey(rsa, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_RSA_KEY;\n\t\tbreak;\n\tcase EVP_PKEY_EC:\n\t\tid->id_type = 0;\n\t\tid->id_offset = 0;\n\t\tibuf_release(id->id_buf);\n\t\tid->id_buf = NULL;\n\n\t\tif ((ec = EVP_PKEY_get1_EC_KEY(key)) == NULL)\n\t\t\tgoto done;\n\t\tif ((len = i2d_ECPrivateKey(ec, NULL)) <= 0)\n\t\t\tgoto done;\n\t\tif ((id->id_buf = ibuf_new(NULL, len)) == NULL)\n\t\t\tgoto done;\n\n\t\td = ibuf_data(id->id_buf);\n\t\tif (i2d_ECPrivateKey(ec, &d) != len) {\n\t\t\tibuf_release(id->id_buf);\n\t\t\tid->id_buf = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tid->id_type = IKEV2_CERT_ECDSA;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unsupported key type %d\", __func__, key->type);\n\t\treturn (-1);\n\t}\n\n\tlog_debug(\"%s: type %s length %d\", __func__,\n\t    print_map(id->id_type, ikev2_cert_map), len);\n\n\tret = 0;\n done:\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n\tif (ec != NULL)\n\t\tEC_KEY_free(ec);\n\treturn (ret);\n}\n\nint\nca_privkey_to_method(struct iked_id *privkey)\n{\n\tBIO\t\t*rawcert = NULL;\n\tEC_KEY\t\t*ec = NULL;\n\tconst EC_GROUP\t*group = NULL;\n\tuint8_t\t method = IKEV2_AUTH_NONE;\n\n\tswitch (privkey->id_type) {\n\tcase IKEV2_CERT_RSA_KEY:\n\t\tmethod = IKEV2_AUTH_RSA_SIG;\n\t\tbreak;\n\tcase IKEV2_CERT_ECDSA:\n\t\tif ((rawcert = BIO_new_mem_buf(ibuf_data(privkey->id_buf),\n\t\t    ibuf_length(privkey->id_buf))) == NULL)\n\t\t\tgoto out;\n\t\tif ((ec = d2i_ECPrivateKey_bio(rawcert, NULL)) == NULL)\n\t\t\tgoto out;\n\t\tif ((group = EC_KEY_get0_group(ec)) == NULL)\n\t\t\tgoto out;\n\t\tswitch (EC_GROUP_get_degree(group)) {\n\t\tcase 256:\n\t\t\tmethod = IKEV2_AUTH_ECDSA_256;\n\t\t\tbreak;\n\t\tcase 384:\n\t\t\tmethod = IKEV2_AUTH_ECDSA_384;\n\t\t\tbreak;\n\t\tcase 521:\n\t\t\tmethod = IKEV2_AUTH_ECDSA_521;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlog_debug(\"%s: type %s method %s\", __func__,\n\t    print_map(privkey->id_type, ikev2_cert_map),\n\t    print_map(method, ikev2_auth_map));\n\n out:\n\tif (ec != NULL)\n\t\tEC_KEY_free(ec);\n\tif (rawcert != NULL)\n\t\tBIO_free(rawcert);\n\n\treturn (method);\n}\n\nchar *\nca_asn1_name(uint8_t *asn1, size_t len)\n{\n\tX509_NAME\t*name = NULL;\n\tchar\t\t*str = NULL;\n\tconst uint8_t\t*p;\n\n\tp = asn1;\n\tif ((name = d2i_X509_NAME(NULL, &p, len)) == NULL)\n\t\treturn (NULL);\n\tstr = X509_NAME_oneline(name, NULL, 0);\n\tX509_NAME_free(name);\n\n\treturn (str);\n}\n\n/*\n * Copy 'src' to 'dst' until 'marker' is found while unescaping '\\'\n * characters. The return value tells the caller where to continue\n * parsing (might be the end of the string) or NULL on error.\n */\nstatic char *\nca_x509_name_unescape(char *src, char *dst, char marker)\n{\n\twhile (*src) {\n\t\tif (*src == marker) {\n\t\t\tsrc++;\n\t\t\tbreak;\n\t\t}\n\t\tif (*src == '\\\\') {\n\t\t\tsrc++;\n\t\t\tif (!*src) {\n\t\t\t\tlog_warnx(\"%s: '\\\\' at end of string\",\n\t\t\t\t    __func__);\n\t\t\t\t*dst = '\\0';\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t\t*dst++ = *src++;\n\t}\n\t*dst = '\\0';\n\treturn (src);\n}\n/*\n * Parse an X509 subject name where 'subject' is in the format\n *    /type0=value0/type1=value1/type2=...\n * where characters may be escaped by '\\'.\n * See lib/libssl/src/apps/apps.c:parse_name()\n */\nvoid *\nca_x509_name_parse(char *subject)\n{\n\tchar\t\t*cp, *value = NULL, *type = NULL;\n\tsize_t\t\t maxlen;\n\tX509_NAME\t*name = NULL;\n\n\tif (*subject != '/') {\n\t\tlog_warnx(\"%s: leading '/' missing in '%s'\", __func__, subject);\n\t\tgoto err;\n\t}\n\n\t/* length of subject is upper bound for unescaped type/value */\n\tmaxlen = strlen(subject) + 1;\n\n\tif ((type = calloc(1, maxlen)) == NULL ||\n\t    (value = calloc(1, maxlen)) == NULL ||\n\t    (name = X509_NAME_new()) == NULL)\n\t\tgoto err;\n\n\tcp = subject + 1;\n\twhile (*cp) {\n\t\t/* unescape type, terminated by '=' */\n\t\tcp = ca_x509_name_unescape(cp, type, '=');\n\t\tif (cp == NULL) {\n\t\t\tlog_warnx(\"%s: could not parse type\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\tif (!*cp) {\n\t\t\tlog_warnx(\"%s: missing value\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\t/* unescape value, terminated by '/' */\n\t\tcp = ca_x509_name_unescape(cp, value, '/');\n\t\tif (cp == NULL) {\n\t\t\tlog_warnx(\"%s: could not parse value\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\tif (!*type || !*value) {\n\t\t\tlog_warnx(\"%s: empty type or value\", __func__);\n\t\t\tgoto err;\n\t\t}\n\t\tlog_debug(\"%s: setting '%s' to '%s'\", __func__, type, value);\n\t\tif (!X509_NAME_add_entry_by_txt(name, type, MBSTRING_ASC,\n\t\t    value, -1, -1, 0)) {\n\t\t\tlog_warnx(\"%s: setting '%s' to '%s' failed\", __func__,\n\t\t\t    type, value);\n\t\t\tca_sslerror(__func__);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree(type);\n\tfree(value);\n\treturn (name);\n\nerr:\n\tX509_NAME_free(name);\n\tfree(type);\n\tfree(value);\n\treturn (NULL);\n}\n\nint\nca_validate_pubkey(struct iked *env, struct iked_static_id *id,\n    void *data, size_t len, struct iked_id *out)\n{\n\tBIO\t\t*rawcert = NULL;\n\tRSA\t\t*peerrsa = NULL, *localrsa = NULL;\n\tEC_KEY\t\t*peerec = NULL;\n\tEVP_PKEY\t*peerkey = NULL, *localkey = NULL;\n\tint\t\t ret = -1;\n\tFILE\t\t*fp = NULL;\n\tchar\t\t idstr[IKED_ID_SIZE];\n\tchar\t\t file[PATH_MAX];\n\tstruct iked_id\t idp;\n\n\tswitch (id->id_type) {\n\tcase IKEV2_ID_IPV4:\n\tcase IKEV2_ID_FQDN:\n\tcase IKEV2_ID_UFQDN:\n\tcase IKEV2_ID_IPV6:\n\t\tbreak;\n\tdefault:\n\t\t/* Some types like ASN1_DN will not be mapped to file names */\n\t\tlog_debug(\"%s: unsupported public key type %s\",\n\t\t    __func__, print_map(id->id_type, ikev2_id_map));\n\t\treturn (-1);\n\t}\n\n\tbzero(&idp, sizeof(idp));\n\tif ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)\n\t\tgoto done;\n\n\tidp.id_type = id->id_type;\n\tidp.id_offset = id->id_offset;\n\tif (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)\n\t\tgoto done;\n\n\tif (len == 0 && data) {\n\t\t/* Data is already an public key */\n\t\tpeerkey = (EVP_PKEY *)data;\n\t}\n\tif (len > 0) {\n\t\tif ((rawcert = BIO_new_mem_buf(data, len)) == NULL)\n\t\t\tgoto done;\n\n\t\tif ((peerkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else if (BIO_reset(rawcert) == 1 &&\n\t\t    (peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_debug(\"%s: unknown key type received\", __func__);\n\t\t\tgoto sslerr;\n\t\t}\n\t}\n\n\tlc_idtype(idstr);\n\tif (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||\n\t    strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {\n\t\tlog_debug(\"%s: public key id too long %s\", __func__, idstr);\n\t\tgoto done;\n\t}\n\n\tif ((fp = fopen(file, \"r\")) == NULL) {\n\t\t/* Log to debug when called from ca_validate_cert */\n\t\tlogit(len == 0 ? LOG_DEBUG : LOG_INFO,\n\t\t    \"%s: could not open public key %s\", __func__, file);\n\t\tgoto done;\n\t}\n\tlocalkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);\n\tif (localkey == NULL) {\n\t\t/* reading PKCS #8 failed, try PEM RSA */\n\t\trewind(fp);\n\t\tlocalrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);\n\t\tfclose(fp);\n\t\tif (localrsa == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((localkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif (!EVP_PKEY_set1_RSA(localkey, localrsa))\n\t\t\tgoto sslerr;\n\t} else {\n\t\tfclose(fp);\n\t}\n\tif (localkey == NULL)\n\t\tgoto sslerr;\n\n\tif (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {\n\t\tlog_debug(\"%s: public key does not match %s\", __func__, file);\n\t\tgoto done;\n\t}\n\n\tlog_debug(\"%s: valid public key in file %s\", __func__, file);\n\n\tif (out && ca_pubkey_serialize(localkey, out))\n\t\tgoto done;\n\n\tret = 0;\n sslerr:\n\tif (ret != 0)\n\t\tca_sslerror(__func__);\n done:\n\tibuf_release(idp.id_buf);\n\tif (localkey != NULL)\n\t\tEVP_PKEY_free(localkey);\n\tif (peerrsa != NULL)\n\t\tRSA_free(peerrsa);\n\tif (peerec != NULL)\n\t\tEC_KEY_free(peerec);\n\tif (localrsa != NULL)\n\t\tRSA_free(localrsa);\n\tif (rawcert != NULL) {\n\t\tBIO_free(rawcert);\n\t\tif (peerkey != NULL)\n\t\t\tEVP_PKEY_free(peerkey);\n\t}\n\n\treturn (ret);\n}\n\nint\nca_validate_cert(struct iked *env, struct iked_static_id *id,\n    void *data, size_t len)\n{\n\tstruct ca_store\t*store = env->sc_priv;\n\tX509_STORE_CTX\t csc;\n\tBIO\t\t*rawcert = NULL;\n\tX509\t\t*cert = NULL;\n\tEVP_PKEY\t*pkey;\n\tint\t\t ret = -1, result, error;\n\tX509_NAME\t*subject;\n\tconst char\t*errstr = \"failed\";\n\n\tif (len == 0) {\n\t\t/* Data is already an X509 certificate */\n\t\tcert = (X509 *)data;\n\t} else {\n\t\t/* Convert data to X509 certificate */\n\t\tif ((rawcert = BIO_new_mem_buf(data, len)) == NULL)\n\t\t\tgoto done;\n\t\tif ((cert = d2i_X509_bio(rawcert, NULL)) == NULL)\n\t\t\tgoto done;\n\t}\n\n\t/* Certificate needs a valid subjectName */\n\tif ((subject = X509_get_subject_name(cert)) == NULL) {\n\t\terrstr = \"invalid subject\";\n\t\tgoto done;\n\t}\n\n\tif (id != NULL) {\n\t\tif ((pkey = X509_get_pubkey(cert)) == NULL) {\n\t\t\terrstr = \"no public key in cert\";\n\t\t\tgoto done;\n\t\t}\n\t\tret = ca_validate_pubkey(env, id, pkey, 0, NULL);\n\t\tEVP_PKEY_free(pkey);\n\t\tif (ret == 0) {\n\t\t\terrstr = \"in public key file, ok\";\n\t\t\tgoto done;\n\t\t}\n\n\t\tswitch (id->id_type) {\n\t\tcase IKEV2_ID_ASN1_DN:\n\t\t\tif (ca_x509_subject_cmp(cert, id) < 0) {\n\t\t\t\terrstr = \"ASN1_DN identifier mismatch\";\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ca_x509_subjectaltname_cmp(cert, id) != 0) {\n\t\t\t\terrstr = \"invalid subjectAltName extension\";\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbzero(&csc, sizeof(csc));\n\tX509_STORE_CTX_init(&csc, store->ca_cas, cert, NULL);\n\tif (store->ca_cas->param->flags & X509_V_FLAG_CRL_CHECK) {\n\t\tX509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK);\n\t\tX509_STORE_CTX_set_flags(&csc, X509_V_FLAG_CRL_CHECK_ALL);\n\t}\n\n\tresult = X509_verify_cert(&csc);\n\terror = csc.error;\n\tX509_STORE_CTX_cleanup(&csc);\n\tif (error != 0) {\n\t\terrstr = X509_verify_cert_error_string(error);\n\t\tgoto done;\n\t}\n\n\tif (!result) {\n\t\t/* XXX should we accept self-signed certificates? */\n\t\terrstr = \"rejecting self-signed certificate\";\n\t\tgoto done;\n\t}\n\n\t/* Success */\n\tret = 0;\n\terrstr = \"ok\";\n\n done:\n\tif (cert != NULL)\n\t\tlog_debug(\"%s: %s %.100s\", __func__, cert->name, errstr);\n\n\tif (rawcert != NULL) {\n\t\tBIO_free(rawcert);\n\t\tif (cert != NULL)\n\t\t\tX509_free(cert);\n\t}\n\n\treturn (ret);\n}\n\n/* check if subject from cert matches the id */\nint\nca_x509_subject_cmp(X509 *cert, struct iked_static_id *id)\n{\n\tX509_NAME\t*subject, *idname = NULL;\n\tconst uint8_t\t*idptr;\n\tsize_t\t\t idlen;\n\tint\t\t ret = -1;\n\n\tif (id->id_type != IKEV2_ID_ASN1_DN)\n\t\treturn (-1);\n\tif ((subject = X509_get_subject_name(cert)) == NULL)\n\t\treturn (-1);\n\tif (id->id_length <= id->id_offset)\n\t\treturn (-1);\n\tidlen = id->id_length - id->id_offset;\n\tidptr = id->id_data + id->id_offset;\n\tif ((idname = d2i_X509_NAME(NULL, &idptr, idlen)) == NULL)\n\t\treturn (-1);\n\tif (X509_NAME_cmp(subject, idname) == 0)\n\t\tret = 0;\n\tX509_NAME_free(idname);\n\treturn (ret);\n}\n\n#define MODE_ALT_LOG\t1\n#define MODE_ALT_GET\t2\n#define MODE_ALT_CMP\t3\nint\nca_x509_subjectaltname_do(X509 *cert, int mode, const char *logmsg,\n    struct iked_static_id *id, struct iked_id *retid)\n{\n\tSTACK_OF(GENERAL_NAME) *stack = NULL;\n\tGENERAL_NAME *entry;\n\tASN1_STRING *cstr;\n\tchar idstr[IKED_ID_SIZE];\n\tint idx, ret, i, type, len;\n\tuint8_t *data;\n\n\tret = -1;\n\tidx = -1;\n\twhile ((stack = X509_get_ext_d2i(cert, NID_subject_alt_name,\n\t    NULL, &idx)) != NULL) {\n\t\tfor (i = 0; i < sk_GENERAL_NAME_num(stack); i++) {\n\t\t\tentry = sk_GENERAL_NAME_value(stack, i);\n\t\t\tswitch (entry->type) {\n\t\t\tcase GEN_DNS:\n\t\t\t\tcstr = entry->d.dNSName;\n\t\t\t\tif (ASN1_STRING_type(cstr) != V_ASN1_IA5STRING)\n\t\t\t\t\tcontinue;\n\t\t\t\ttype = IKEV2_ID_FQDN;\n\t\t\t\tbreak;\n\t\t\tcase GEN_EMAIL:\n\t\t\t\tcstr = entry->d.rfc822Name;\n\t\t\t\tif (ASN1_STRING_type(cstr) != V_ASN1_IA5STRING)\n\t\t\t\t\tcontinue;\n\t\t\t\ttype = IKEV2_ID_UFQDN;\n\t\t\t\tbreak;\n\t\t\tcase GEN_IPADD:\n\t\t\t\tcstr = entry->d.iPAddress;\n\t\t\t\tswitch (ASN1_STRING_length(cstr)) {\n\t\t\t\tcase 4:\n\t\t\t\t\ttype = IKEV2_ID_IPV4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\ttype = IKEV2_ID_IPV6;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog_debug(\"%s: invalid subjectAltName\"\n\t\t\t\t\t   \" IP address\", __func__);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = ASN1_STRING_length(cstr);\n\t\t\tdata = ASN1_STRING_data(cstr);\n\t\t\tif (mode == MODE_ALT_LOG) {\n\t\t\t\tstruct iked_id sanid;\n\n\t\t\t\tbzero(&sanid, sizeof(sanid));\n\t\t\t\tsanid.id_offset = 0;\n\t\t\t\tsanid.id_type = type;\n\t\t\t\tif ((sanid.id_buf = ibuf_new(data, len))\n\t\t\t\t    == NULL) {\n\t\t\t\t\tlog_debug(\"%s: failed to get id buffer\",\n\t\t\t\t\t     __func__);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tikev2_print_id(&sanid, idstr, sizeof(idstr));\n\t\t\t\tlog_info(\"%s: altname: %s\", logmsg, idstr);\n\t\t\t\tibuf_release(sanid.id_buf);\n\t\t\t\tsanid.id_buf = NULL;\n\t\t\t}\n\t\t\t/* Compare length and data */\n\t\t\tif (mode == MODE_ALT_CMP) {\n\t\t\t\tif (type == id->id_type &&\n\t\t\t\t    (len == (id->id_length - id->id_offset)) &&\n\t\t\t\t    (memcmp(id->id_data + id->id_offset,\n\t\t\t\t    data, len)) == 0) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Get first ID */\n\t\t\tif (mode == MODE_ALT_GET) {\n\t\t\t\tibuf_release(retid->id_buf);\n\t\t\t\tif ((retid->id_buf = ibuf_new(data, len)) == NULL) {\n\t\t\t\t\tlog_debug(\"%s: failed to get id buffer\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\tret = -2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tretid->id_offset = 0;\n\t\t\t\tikev2_print_id(retid, idstr, sizeof(idstr));\n\t\t\t\tlog_debug(\"%s: %s\", __func__, idstr);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsk_GENERAL_NAME_pop_free(stack, GENERAL_NAME_free);\n\t\tif (ret != -1)\n\t\t\tbreak;\n\t}\n\tif (idx == -1)\n\t\tlog_debug(\"%s: did not find subjectAltName in certificate\",\n\t\t    __func__);\n\treturn ret;\n}\n\nint\nca_x509_subjectaltname_log(X509 *cert, const char *logmsg)\n{\n\treturn ca_x509_subjectaltname_do(cert, MODE_ALT_LOG, logmsg, NULL, NULL);\n}\n\nint\nca_x509_subjectaltname_cmp(X509 *cert, struct iked_static_id *id)\n{\n\treturn ca_x509_subjectaltname_do(cert, MODE_ALT_CMP, NULL, id, NULL);\n}\n\nint\nca_x509_subjectaltname_get(X509 *cert, struct iked_id *retid)\n{\n\treturn ca_x509_subjectaltname_do(cert, MODE_ALT_GET, NULL, NULL, retid);\n}\n\nvoid\nca_sslinit(void)\n{\n\tOpenSSL_add_all_algorithms();\n\tERR_load_crypto_strings();\n\n\t/* Init hardware crypto engines. */\n\tENGINE_load_builtin_engines();\n\tENGINE_register_all_complete();\n}\n\nvoid\nca_sslerror(const char *caller)\n{\n\tunsigned long\t error;\n\n\twhile ((error = ERR_get_error()) != 0)\n\t\tlog_warnx(\"%s: %s: %.100s\", __func__, caller,\n\t\t    ERR_error_string(error, NULL));\n}\n"], "filenames": ["sbin/iked/ca.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [1424], "fixing_code_start_loc": [1], "fixing_code_end_loc": [1424], "type": "CWE-287", "message": "iked in OpenIKED, as used in OpenBSD through 6.7, allows authentication bypass because ca.c has the wrong logic for checking whether a public key matches.", "other": {"cve": {"id": "CVE-2020-16088", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-28T12:15:12.067", "lastModified": "2022-01-04T16:32:52.703", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "iked in OpenIKED, as used in OpenBSD through 6.7, allows authentication bypass because ca.c has the wrong logic for checking whether a public key matches."}, {"lang": "es", "value": "iked en OpenIKED, como es usado en OpenBSD versiones hasta 6.7, permite omitir una autenticaci\u00f3n porque el archivo ca.c presenta  una l\u00f3gica equivocada para comprobar si una clave p\u00fablica coincide"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.7", "matchCriteriaId": "9A2FECEE-1724-4D96-8165-3AA952EDD4DC"}]}]}], "references": [{"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/6.7/common/014_iked.patch.sig", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xcllnt/openiked/commits/master", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openiked.org/security.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115"}}