{"buggy_code": ["/*\n * MMS protocol common definitions.\n * Copyright (c) 2006,2007 Ryan Martell\n * Copyright (c) 2007 Bj\u00f6rn Axelsson\n * Copyright (c) 2010 Zhentan Feng <spyfeng at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n#include \"mms.h\"\n#include \"asf.h\"\n#include \"libavutil/intreadwrite.h\"\n\n#define MMS_MAX_STREAMS 256    /**< arbitrary sanity check value */\n\nint ff_mms_read_header(MMSContext *mms, uint8_t *buf, const int size)\n{\n    char *pos;\n    int size_to_copy;\n    int remaining_size = mms->asf_header_size - mms->asf_header_read_size;\n    size_to_copy = FFMIN(size, remaining_size);\n    pos = mms->asf_header + mms->asf_header_read_size;\n    memcpy(buf, pos, size_to_copy);\n    if (mms->asf_header_read_size == mms->asf_header_size) {\n        av_freep(&mms->asf_header); // which contains asf header\n    }\n    mms->asf_header_read_size += size_to_copy;\n    return size_to_copy;\n}\n\nint ff_mms_read_data(MMSContext *mms, uint8_t *buf, const int size)\n{\n    int read_size;\n    read_size = FFMIN(size, mms->remaining_in_len);\n    memcpy(buf, mms->read_in_ptr, read_size);\n    mms->remaining_in_len -= read_size;\n    mms->read_in_ptr      += read_size;\n    return read_size;\n}\n\nint ff_mms_asf_header_parser(MMSContext *mms)\n{\n    uint8_t *p = mms->asf_header;\n    uint8_t *end;\n    int flags, stream_id;\n    mms->stream_num = 0;\n\n    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||\n        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"Corrupt stream (invalid ASF header, size=%d)\\n\",\n               mms->asf_header_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    end = mms->asf_header + mms->asf_header_size;\n\n    p += sizeof(ff_asf_guid) + 14;\n    while(end - p >= sizeof(ff_asf_guid) + 8) {\n        uint64_t chunksize;\n        if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {\n            chunksize = 50; // see Reference [2] section 5.1\n        } else {\n            chunksize = AV_RL64(p + sizeof(ff_asf_guid));\n        }\n        if (!chunksize || chunksize > end - p) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n                   chunksize);\n            return AVERROR_INVALIDDATA;\n        }\n        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n            /* read packet size */\n            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {\n                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);\n                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (too large pkt_len %d)\\n\",\n                           mms->asf_packet_len);\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n            stream_id = flags & 0x7F;\n            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,\n            //we can calculate the packet size by stream_num.\n            //Please see function send_stream_selection_request().\n            if (mms->stream_num < MMS_MAX_STREAMS &&\n                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n                mms->streams = av_fast_realloc(mms->streams,\n                                   &mms->nb_streams_allocated,\n                                   (mms->stream_num + 1) * sizeof(MMSStream));\n                if (!mms->streams)\n                    return AVERROR(ENOMEM);\n                mms->streams[mms->stream_num].id = stream_id;\n                mms->stream_num++;\n            } else {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Corrupt stream (too many A/V streams)\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n            if (end - p >= 88) {\n                int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);\n                uint64_t skip_bytes = 88;\n                while (stream_count--) {\n                    if (end - p < skip_bytes + 4) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next stream name length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);\n                }\n                while (ext_len_count--) {\n                    if (end - p < skip_bytes + 22) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next extension system info length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);\n                }\n                if (end - p < skip_bytes) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (the last extension system info length is invalid)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                if (chunksize - skip_bytes > 24)\n                    chunksize = skip_bytes;\n            }\n        } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n            chunksize = 46; // see references [2] section 3.4. This should be set 46.\n        }\n        p += chunksize;\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * MMS protocol common definitions.\n * Copyright (c) 2006,2007 Ryan Martell\n * Copyright (c) 2007 Bj\u00f6rn Axelsson\n * Copyright (c) 2010 Zhentan Feng <spyfeng at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n#include \"mms.h\"\n#include \"asf.h\"\n#include \"libavutil/intreadwrite.h\"\n\n#define MMS_MAX_STREAMS 256    /**< arbitrary sanity check value */\n\nint ff_mms_read_header(MMSContext *mms, uint8_t *buf, const int size)\n{\n    char *pos;\n    int size_to_copy;\n    int remaining_size = mms->asf_header_size - mms->asf_header_read_size;\n    size_to_copy = FFMIN(size, remaining_size);\n    pos = mms->asf_header + mms->asf_header_read_size;\n    memcpy(buf, pos, size_to_copy);\n    if (mms->asf_header_read_size == mms->asf_header_size) {\n        av_freep(&mms->asf_header); // which contains asf header\n    }\n    mms->asf_header_read_size += size_to_copy;\n    return size_to_copy;\n}\n\nint ff_mms_read_data(MMSContext *mms, uint8_t *buf, const int size)\n{\n    int read_size;\n    read_size = FFMIN(size, mms->remaining_in_len);\n    memcpy(buf, mms->read_in_ptr, read_size);\n    mms->remaining_in_len -= read_size;\n    mms->read_in_ptr      += read_size;\n    return read_size;\n}\n\nint ff_mms_asf_header_parser(MMSContext *mms)\n{\n    uint8_t *p = mms->asf_header;\n    uint8_t *end;\n    int flags, stream_id;\n    mms->stream_num = 0;\n\n    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||\n        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"Corrupt stream (invalid ASF header, size=%d)\\n\",\n               mms->asf_header_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    end = mms->asf_header + mms->asf_header_size;\n\n    p += sizeof(ff_asf_guid) + 14;\n    while(end - p >= sizeof(ff_asf_guid) + 8) {\n        uint64_t chunksize;\n        if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {\n            chunksize = 50; // see Reference [2] section 5.1\n        } else {\n            chunksize = AV_RL64(p + sizeof(ff_asf_guid));\n        }\n        if (!chunksize || chunksize > end - p) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n                   chunksize);\n            return AVERROR_INVALIDDATA;\n        }\n        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n            /* read packet size */\n            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {\n                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);\n                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (too large pkt_len %d)\\n\",\n                           mms->asf_packet_len);\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n            if (end - p >= (sizeof(ff_asf_guid) * 3 + 26)) {\n                flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n                stream_id = flags & 0x7F;\n                //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,\n                //we can calculate the packet size by stream_num.\n                //Please see function send_stream_selection_request().\n                if (mms->stream_num < MMS_MAX_STREAMS &&\n                        46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n                    mms->streams = av_fast_realloc(mms->streams,\n                                       &mms->nb_streams_allocated,\n                                       (mms->stream_num + 1) * sizeof(MMSStream));\n                    if (!mms->streams)\n                        return AVERROR(ENOMEM);\n                    mms->streams[mms->stream_num].id = stream_id;\n                    mms->stream_num++;\n                } else {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (too many A/V streams)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n        } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n            if (end - p >= 88) {\n                int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);\n                uint64_t skip_bytes = 88;\n                while (stream_count--) {\n                    if (end - p < skip_bytes + 4) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next stream name length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);\n                }\n                while (ext_len_count--) {\n                    if (end - p < skip_bytes + 22) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next extension system info length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);\n                }\n                if (end - p < skip_bytes) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (the last extension system info length is invalid)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                if (chunksize - skip_bytes > 24)\n                    chunksize = skip_bytes;\n            }\n        } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n            chunksize = 46; // see references [2] section 3.4. This should be set 46.\n            if (chunksize > end - p) {\n                av_log(NULL, AV_LOG_ERROR,\n                    \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n                    chunksize);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        p += chunksize;\n    }\n\n    return 0;\n}\n"], "filenames": ["libavformat/mms.c"], "buggy_code_start_loc": [97], "buggy_code_end_loc": [145], "fixing_code_start_loc": [97], "fixing_code_end_loc": [154], "type": "CWE-125", "message": "FFmpeg before commit cced03dd667a5df6df8fd40d8de0bff477ee02e8 contains multiple out of array access vulnerabilities in the mms protocol that can result in attackers accessing out of bound data. This attack appear to be exploitable via network connectivity. This vulnerability appears to have been fixed in cced03dd667a5df6df8fd40d8de0bff477ee02e8 and later.", "other": {"cve": {"id": "CVE-2018-1999010", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-23T15:29:00.297", "lastModified": "2019-03-27T19:11:17.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFmpeg before commit cced03dd667a5df6df8fd40d8de0bff477ee02e8 contains multiple out of array access vulnerabilities in the mms protocol that can result in attackers accessing out of bound data. This attack appear to be exploitable via network connectivity. This vulnerability appears to have been fixed in cced03dd667a5df6df8fd40d8de0bff477ee02e8 and later."}, {"lang": "es", "value": "FFmpeg antes del commit con ID cced03dd667a5df6df8fd40d8de0bff477ee02e8 contiene m\u00faltiples vulnerabilidades de acceso fuera de array en el protocolo mms que puede resultar en que los atacantes accedan a datos fuera de l\u00edmites. Este ataque parece ser explotable mediante conectividad de red. La vulnerabilidad parece haber sido solucionada en cced03dd667a5df6df8fd40d8de0bff477ee02e8 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.3", "matchCriteriaId": "19ED68BA-9916-415D-AB95-6F3246D52E65"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104896", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8"}}