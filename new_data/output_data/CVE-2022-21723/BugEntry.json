{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/scanner.h>\n#include <pj/ctype.h>\n#include <pj/string.h>\n#include <pj/except.h>\n#include <pj/os.h>\n#include <pj/log.h>\n#include <pj/errno.h>\n#include <pj/assert.h>\n\n#define THIS_FILE   \"scanner.c\"\n\n#define PJ_SCAN_IS_SPACE(c)\t\t((c)==' ' || (c)=='\\t')\n#define PJ_SCAN_IS_NEWLINE(c)\t\t((c)=='\\r' || (c)=='\\n')\n#define PJ_SCAN_IS_PROBABLY_SPACE(c)\t((c) <= 32)\n#define PJ_SCAN_CHECK_EOF(s)\t\t(s != scanner->end)\n\n\n#if defined(PJ_SCANNER_USE_BITWISE) && PJ_SCANNER_USE_BITWISE != 0\n#  include \"scanner_cis_bitwise.c\"\n#else\n#  include \"scanner_cis_uint.c\"\n#endif\n\n\nstatic void pj_scan_syntax_err(pj_scanner *scanner)\n{\n    (*scanner->callback)(scanner);\n}\n\n\nPJ_DEF(void) pj_cis_add_range(pj_cis_t *cis, int cstart, int cend)\n{\n    /* Can not set zero. This is the requirement of the parser. */\n    pj_assert(cstart > 0);\n\n    while (cstart != cend) {\n        PJ_CIS_SET(cis, cstart);\n\t++cstart;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_alpha(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, 'a', 'z'+1);\n    pj_cis_add_range( cis, 'A', 'Z'+1);\n}\n\nPJ_DEF(void) pj_cis_add_num(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, '0', '9'+1);\n}\n\nPJ_DEF(void) pj_cis_add_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_SET(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_cis( pj_cis_t *cis, const pj_cis_t *rhs)\n{\n    int i;\n    for (i=0; i<256; ++i) {\n\tif (PJ_CIS_ISSET(rhs, i))\n\t    PJ_CIS_SET(cis, i);\n    }\n}\n\nPJ_DEF(void) pj_cis_del_range( pj_cis_t *cis, int cstart, int cend)\n{\n    while (cstart != cend) {\n        PJ_CIS_CLR(cis, cstart);\n        cstart++;\n    }\n}\n\nPJ_DEF(void) pj_cis_del_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_CLR(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_invert( pj_cis_t *cis )\n{\n    unsigned i;\n    /* Can not set zero. This is the requirement of the parser. */\n    for (i=1; i<256; ++i) {\n\tif (PJ_CIS_ISSET(cis,i))\n            PJ_CIS_CLR(cis,i);\n        else\n            PJ_CIS_SET(cis,i);\n    }\n}\n\nPJ_DEF(void) pj_scan_init( pj_scanner *scanner, char *bufstart, \n\t\t\t   pj_size_t buflen, unsigned options, \n\t\t\t   pj_syn_err_func_ptr callback )\n{\n    PJ_CHECK_STACK();\n\n    scanner->begin = scanner->curptr = bufstart;\n    scanner->end = bufstart + buflen;\n    scanner->line = 1;\n    scanner->start_line = scanner->begin;\n    scanner->callback = callback;\n    scanner->skip_ws = options;\n\n    if (scanner->skip_ws) \n\tpj_scan_skip_whitespace(scanner);\n}\n\n\nPJ_DEF(void) pj_scan_fini( pj_scanner *scanner )\n{\n    PJ_CHECK_STACK();\n    PJ_UNUSED_ARG(scanner);\n}\n\nPJ_DEF(void) pj_scan_skip_whitespace( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n\n    while (PJ_SCAN_IS_SPACE(*s)) {\n\t++s;\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_NEWLINE)) {\n\tfor (;;) {\n\t    if (*s == '\\r') {\n\t\t++s;\n\t\tif (*s == '\\n') ++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (*s == '\\n') {\n\t\t++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (PJ_SCAN_IS_SPACE(*s)) {\n\t\tdo {\n\t\t    ++s;\n\t\t} while (PJ_SCAN_IS_SPACE(*s));\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_WS_HEADER)==PJ_SCAN_AUTOSKIP_WS_HEADER) {\n\t/* Check for header continuation. */\n\tscanner->curptr = s;\n\n\tif (*s == '\\r') {\n\t    ++s;\n\t}\n\tif (*s == '\\n') {\n\t    ++s;\n\t}\n\tscanner->start_line = s;\n\n\tif (PJ_SCAN_IS_SPACE(*s)) {\n\t    register char *t = s;\n\t    do {\n\t\t++t;\n\t    } while (PJ_SCAN_IS_SPACE(*t));\n\n\t    ++scanner->line;\n\t    scanner->curptr = t;\n\t}\n    } else {\n\tscanner->curptr = s;\n    }\n}\n\nPJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}\n\nPJ_DEF(int) pj_scan_peek( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    /* Don't need to check EOF with PJ_SCAN_CHECK_EOF(s) */\n    while (pj_cis_match(spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(int) pj_scan_peek_n( pj_scanner *scanner,\n\t\t\t     pj_size_t len, pj_str_t *out)\n{\n    char *endpos = scanner->curptr + len;\n\n    if (endpos > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    pj_strset(out, scanner->curptr, len);\n    return *endpos;\n}\n\n\nPJ_DEF(int) pj_scan_peek_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, \n\t\t\t\tpj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match( spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* EOF is detected implicitly */\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    /* No need to check EOF here (PJ_SCAN_CHECK_EOF(s)) because\n     * buffer is NULL terminated and pj_cis_match(spec,0) should be\n     * false.\n     */\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* Must not match character '%' */\n    pj_assert(pj_cis_match(spec,'%')==0);\n\n    /* EOF is detected implicitly */\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n\t\n    } while (*s == '%');\n\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_quote( pj_scanner *scanner,\n\t\t\t\tint begin_quote, int end_quote, \n\t\t\t\tpj_str_t *out)\n{\n    char beg = (char)begin_quote;\n    char end = (char)end_quote;\n    pj_scan_get_quotes(scanner, &beg, &end, 1, out);\n}\n\nPJ_DEF(void) pj_scan_get_quotes(pj_scanner *scanner,\n                                const char *begin_quote, const char *end_quote,\n                                int qsize, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    int qpair = -1;\n    int i;\n\n    pj_assert(qsize > 0);\n\n    /* Check and eat the begin_quote. */\n    for (i = 0; i < qsize; ++i) {\n\tif (*s == begin_quote[i]) {\n\t    qpair = i;\n\t    break;\n\t}\n    }\n    if (qpair == -1) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    /* Loop until end_quote is found. \n     */\n    do {\n\t/* loop until end_quote is found. */\n\twhile (PJ_SCAN_CHECK_EOF(s) && *s != '\\n' && *s != end_quote[qpair]) {\n\t    ++s;\n\t}\n\n\t/* check that no backslash character precedes the end_quote. */\n\tif (*s == end_quote[qpair]) {\n\t    if (*(s-1) == '\\\\') {\n\t\tchar *q = s-2;\n\t\tchar *r = s-2;\n\n\t\twhile (r != scanner->begin && *r == '\\\\') {\n\t\t    --r;\n\t\t}\n\t\t/* break from main loop if we have odd number of backslashes */\n\t\tif (((unsigned)(q-r) & 0x01) == 1) {\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    } else {\n\t\t/* end_quote is not preceeded by backslash. break now. */\n\t\tbreak;\n\t    }\n\t} else {\n\t    /* loop ended by non-end_quote character. break now. */\n\t    break;\n\t}\n    } while (1);\n\n    /* Check and eat the end quote. */\n    if (*s != end_quote[qpair]) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    pj_strset(out, scanner->curptr, N);\n    \n    scanner->curptr += N;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    int chr = *scanner->curptr;\n\n    if (!chr) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n\n    ++scanner->curptr;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}\n\n\nPJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n\n    /**\n     * This probably is a bug, see PROTOS test #2480.\n     * This would cause scanner to incorrectly eat two new lines, e.g.\n     * when parsing:\n     *   \n     *\tContent-Length: 120\\r\\n\n     *\t\\r\\n\n     *\t<space><space><space>...\n     *\n     * When pj_scan_get_newline() is called to parse the first newline\n     * in the Content-Length header, it will eat the second newline\n     * too because it thinks that it's a header continuation.\n     *\n     * if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n     *    pj_scan_skip_whitespace(scanner);\n     * }\n     */\n}\n\n\nPJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\nPJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    scanner->curptr += N;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_strcmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strncmp(scanner->curptr, s, len);\n}\n\n\nPJ_DEF(int) pj_scan_stricmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return pj_ansi_strnicmp(scanner->curptr, s, len);\n}\n\nPJ_DEF(int) pj_scan_stricmp_alnum( pj_scanner *scanner, const char *s, \n\t\t\t\t   int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strnicmp_alnum(scanner->curptr, s, len);\n}\n\nPJ_DEF(void) pj_scan_save_state( const pj_scanner *scanner, \n\t\t\t\t pj_scan_state *state)\n{\n    state->curptr = scanner->curptr;\n    state->line = scanner->line;\n    state->start_line = scanner->start_line;\n}\n\n\nPJ_DEF(void) pj_scan_restore_state( pj_scanner *scanner, \n\t\t\t\t    pj_scan_state *state)\n{\n    scanner->curptr = state->curptr;\n    scanner->line = state->line;\n    scanner->start_line = state->start_line;\n}\n\n\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/scanner.h>\n#include <pj/ctype.h>\n#include <pj/string.h>\n#include <pj/except.h>\n#include <pj/os.h>\n#include <pj/log.h>\n#include <pj/errno.h>\n#include <pj/assert.h>\n\n#define THIS_FILE   \"scanner.c\"\n\n#define PJ_SCAN_IS_SPACE(c)\t\t((c)==' ' || (c)=='\\t')\n#define PJ_SCAN_IS_NEWLINE(c)\t\t((c)=='\\r' || (c)=='\\n')\n#define PJ_SCAN_IS_PROBABLY_SPACE(c)\t((c) <= 32)\n#define PJ_SCAN_CHECK_EOF(s)\t\t(s != scanner->end)\n\n\n#if defined(PJ_SCANNER_USE_BITWISE) && PJ_SCANNER_USE_BITWISE != 0\n#  include \"scanner_cis_bitwise.c\"\n#else\n#  include \"scanner_cis_uint.c\"\n#endif\n\n\nstatic void pj_scan_syntax_err(pj_scanner *scanner)\n{\n    (*scanner->callback)(scanner);\n}\n\n\nPJ_DEF(void) pj_cis_add_range(pj_cis_t *cis, int cstart, int cend)\n{\n    /* Can not set zero. This is the requirement of the parser. */\n    pj_assert(cstart > 0);\n\n    while (cstart != cend) {\n        PJ_CIS_SET(cis, cstart);\n\t++cstart;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_alpha(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, 'a', 'z'+1);\n    pj_cis_add_range( cis, 'A', 'Z'+1);\n}\n\nPJ_DEF(void) pj_cis_add_num(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, '0', '9'+1);\n}\n\nPJ_DEF(void) pj_cis_add_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_SET(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_cis( pj_cis_t *cis, const pj_cis_t *rhs)\n{\n    int i;\n    for (i=0; i<256; ++i) {\n\tif (PJ_CIS_ISSET(rhs, i))\n\t    PJ_CIS_SET(cis, i);\n    }\n}\n\nPJ_DEF(void) pj_cis_del_range( pj_cis_t *cis, int cstart, int cend)\n{\n    while (cstart != cend) {\n        PJ_CIS_CLR(cis, cstart);\n        cstart++;\n    }\n}\n\nPJ_DEF(void) pj_cis_del_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_CLR(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_invert( pj_cis_t *cis )\n{\n    unsigned i;\n    /* Can not set zero. This is the requirement of the parser. */\n    for (i=1; i<256; ++i) {\n\tif (PJ_CIS_ISSET(cis,i))\n            PJ_CIS_CLR(cis,i);\n        else\n            PJ_CIS_SET(cis,i);\n    }\n}\n\nPJ_DEF(void) pj_scan_init( pj_scanner *scanner, char *bufstart, \n\t\t\t   pj_size_t buflen, unsigned options, \n\t\t\t   pj_syn_err_func_ptr callback )\n{\n    PJ_CHECK_STACK();\n\n    scanner->begin = scanner->curptr = bufstart;\n    scanner->end = bufstart + buflen;\n    scanner->line = 1;\n    scanner->start_line = scanner->begin;\n    scanner->callback = callback;\n    scanner->skip_ws = options;\n\n    if (scanner->skip_ws) \n\tpj_scan_skip_whitespace(scanner);\n}\n\n\nPJ_DEF(void) pj_scan_fini( pj_scanner *scanner )\n{\n    PJ_CHECK_STACK();\n    PJ_UNUSED_ARG(scanner);\n}\n\nPJ_DEF(void) pj_scan_skip_whitespace( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n\n    while (PJ_SCAN_IS_SPACE(*s)) {\n\t++s;\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_NEWLINE)) {\n\tfor (;;) {\n\t    if (*s == '\\r') {\n\t\t++s;\n\t\tif (*s == '\\n') ++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (*s == '\\n') {\n\t\t++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (PJ_SCAN_IS_SPACE(*s)) {\n\t\tdo {\n\t\t    ++s;\n\t\t} while (PJ_SCAN_IS_SPACE(*s));\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_WS_HEADER)==PJ_SCAN_AUTOSKIP_WS_HEADER) {\n\t/* Check for header continuation. */\n\tscanner->curptr = s;\n\n\tif (*s == '\\r') {\n\t    ++s;\n\t}\n\tif (*s == '\\n') {\n\t    ++s;\n\t}\n\tscanner->start_line = s;\n\n\tif (PJ_SCAN_IS_SPACE(*s)) {\n\t    register char *t = s;\n\t    do {\n\t\t++t;\n\t    } while (PJ_SCAN_IS_SPACE(*t));\n\n\t    ++scanner->line;\n\t    scanner->curptr = t;\n\t}\n    } else {\n\tscanner->curptr = s;\n    }\n}\n\nPJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}\n\nPJ_DEF(int) pj_scan_peek( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    /* Don't need to check EOF with PJ_SCAN_CHECK_EOF(s) */\n    while (pj_cis_match(spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(int) pj_scan_peek_n( pj_scanner *scanner,\n\t\t\t     pj_size_t len, pj_str_t *out)\n{\n    char *endpos = scanner->curptr + len;\n\n    if (endpos > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    pj_strset(out, scanner->curptr, len);\n    return *endpos;\n}\n\n\nPJ_DEF(int) pj_scan_peek_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, \n\t\t\t\tpj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match( spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* EOF is detected implicitly */\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    /* No need to check EOF here (PJ_SCAN_CHECK_EOF(s)) because\n     * buffer is NULL terminated and pj_cis_match(spec,0) should be\n     * false.\n     */\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* Must not match character '%' */\n    pj_assert(pj_cis_match(spec,'%')==0);\n\n    /* EOF is detected implicitly */\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n\t\n    } while (*s == '%');\n\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_quote( pj_scanner *scanner,\n\t\t\t\tint begin_quote, int end_quote, \n\t\t\t\tpj_str_t *out)\n{\n    char beg = (char)begin_quote;\n    char end = (char)end_quote;\n    pj_scan_get_quotes(scanner, &beg, &end, 1, out);\n}\n\nPJ_DEF(void) pj_scan_get_quotes(pj_scanner *scanner,\n                                const char *begin_quote, const char *end_quote,\n                                int qsize, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    int qpair = -1;\n    int i;\n\n    pj_assert(qsize > 0);\n\n    /* Check and eat the begin_quote. */\n    for (i = 0; i < qsize; ++i) {\n\tif (*s == begin_quote[i]) {\n\t    qpair = i;\n\t    break;\n\t}\n    }\n    if (qpair == -1) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    /* Loop until end_quote is found. \n     */\n    do {\n\t/* loop until end_quote is found. */\n\twhile (PJ_SCAN_CHECK_EOF(s) && *s != '\\n' && *s != end_quote[qpair]) {\n\t    ++s;\n\t}\n\n\t/* check that no backslash character precedes the end_quote. */\n\tif (*s == end_quote[qpair]) {\n\t    if (*(s-1) == '\\\\') {\n\t\tchar *q = s-2;\n\t\tchar *r = s-2;\n\n\t\twhile (r != scanner->begin && *r == '\\\\') {\n\t\t    --r;\n\t\t}\n\t\t/* break from main loop if we have odd number of backslashes */\n\t\tif (((unsigned)(q-r) & 0x01) == 1) {\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    } else {\n\t\t/* end_quote is not preceeded by backslash. break now. */\n\t\tbreak;\n\t    }\n\t} else {\n\t    /* loop ended by non-end_quote character. break now. */\n\t    break;\n\t}\n    } while (1);\n\n    /* Check and eat the end quote. */\n    if (*s != end_quote[qpair]) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    pj_strset(out, scanner->curptr, N);\n    \n    scanner->curptr += N;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n    int chr;\n\n    if (s >= scanner->end || !*s) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n\n    chr = *s;\n\n    ++s;\n    scanner->curptr = s;\n    if (PJ_SCAN_CHECK_EOF(s) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n    \tscanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}\n\n\nPJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n\n    /**\n     * This probably is a bug, see PROTOS test #2480.\n     * This would cause scanner to incorrectly eat two new lines, e.g.\n     * when parsing:\n     *   \n     *\tContent-Length: 120\\r\\n\n     *\t\\r\\n\n     *\t<space><space><space>...\n     *\n     * When pj_scan_get_newline() is called to parse the first newline\n     * in the Content-Length header, it will eat the second newline\n     * too because it thinks that it's a header continuation.\n     *\n     * if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n     *    pj_scan_skip_whitespace(scanner);\n     * }\n     */\n}\n\n\nPJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\nPJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    scanner->curptr += N;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_strcmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strncmp(scanner->curptr, s, len);\n}\n\n\nPJ_DEF(int) pj_scan_stricmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return pj_ansi_strnicmp(scanner->curptr, s, len);\n}\n\nPJ_DEF(int) pj_scan_stricmp_alnum( pj_scanner *scanner, const char *s, \n\t\t\t\t   int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strnicmp_alnum(scanner->curptr, s, len);\n}\n\nPJ_DEF(void) pj_scan_save_state( const pj_scanner *scanner, \n\t\t\t\t pj_scan_state *state)\n{\n    state->curptr = scanner->curptr;\n    state->line = scanner->line;\n    state->start_line = scanner->start_line;\n}\n\n\nPJ_DEF(void) pj_scan_restore_state( pj_scanner *scanner, \n\t\t\t\t    pj_scan_state *state)\n{\n    scanner->curptr = state->curptr;\n    scanner->line = state->line;\n    scanner->start_line = state->start_line;\n}\n\n\n"], "filenames": ["pjlib-util/src/pjlib-util/scanner.c"], "buggy_code_start_loc": [447], "buggy_code_end_loc": [457], "fixing_code_start_loc": [447], "fixing_code_end_loc": [462], "type": "CWE-125", "message": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions 2.11.1 and prior, parsing an incoming SIP message that contains a malformed multipart can potentially cause out-of-bound read access. This issue affects all PJSIP users that accept SIP multipart. The patch is available as commit in the `master` branch. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-21723", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-27T00:15:07.737", "lastModified": "2023-02-02T18:30:15.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions 2.11.1 and prior, parsing an incoming SIP message that contains a malformed multipart can potentially cause out-of-bound read access. This issue affects all PJSIP users that accept SIP multipart. The patch is available as commit in the `master` branch. There are no known workarounds."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C que implementa protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En las versiones 2.11.1 y anteriores, el an\u00e1lisis de un mensaje SIP entrante que contiene una multiparte malformada puede causar potencialmente un acceso de lectura fuera de l\u00edmites. Este problema afecta a todos los usuarios de PJSIP que aceptan multipartes SIP. El parche est\u00e1 disponible como commit en la rama \"master\". No se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "FC49FD2F-9A64-4F92-9B73-50E37BEB207E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert1:*:*:*:*:*:*", "matchCriteriaId": "E64BCD44-2298-4710-9CC3-DF82E6A8DF94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert10:*:*:*:*:*:*", "matchCriteriaId": "91CCAB0C-C0F8-4619-AAE1-F6F13FF31570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert11:*:*:*:*:*:*", "matchCriteriaId": "F2B7CBB3-E037-416B-AD16-9A553D6A4775"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert12:*:*:*:*:*:*", "matchCriteriaId": "DE7DDFE1-6A06-477A-AB45-D00053CFA7EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert2:*:*:*:*:*:*", "matchCriteriaId": "A35C117A-6EFB-42EB-AD2A-EA7866606927"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert3:*:*:*:*:*:*", "matchCriteriaId": "40003CBE-792F-4875-9E60-6F1CE0BBAA8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert4:*:*:*:*:*:*", "matchCriteriaId": "46A7AA7B-13F2-496A-99ED-1CC13234E8CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert5:*:*:*:*:*:*", "matchCriteriaId": "147663CB-B48D-4D89-96BF-F92FF96F347F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert6:*:*:*:*:*:*", "matchCriteriaId": "27DBBC83-930A-4ECE-8C1E-47481D881B0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert7:*:*:*:*:*:*", "matchCriteriaId": "B987A13D-A363-4DCE-BBA1-E35E81ACBA60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert8:*:*:*:*:*:*", "matchCriteriaId": "01A5B7F9-FAD2-4C0C-937D-CF1086512130"}, {"vulnerable": true, "criteria": "cpe:2.3:a:asterisk:certified_asterisk:16.8.0:cert9:*:*:*:*:*:*", "matchCriteriaId": "F60B4271-F987-4932-86EE-45ED099661E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.0.0", "versionEndExcluding": "16.24.1", "matchCriteriaId": "DE99C3B4-20EC-4AC8-9A0A-C690E2DBED99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "18.0.0", "versionEndExcluding": "18.10.1", "matchCriteriaId": "C109B569-DE0D-4AE4-A128-239077CCC05F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sangoma:asterisk:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.0.0", "versionEndExcluding": "19.2.1", "matchCriteriaId": "44E4E3A7-8CB3-491C-98F6-F78345533E3B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/166227/Asterisk-Project-Security-Advisory-AST-2022-006.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/2", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/commit/077b465c33f0aec05a49cd2ca456f9a1b112e896", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-7fw8-54cv-r7pm", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00021.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5285", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/077b465c33f0aec05a49cd2ca456f9a1b112e896"}}