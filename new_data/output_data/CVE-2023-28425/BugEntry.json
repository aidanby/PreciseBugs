{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h> /* isnan(), isinf() */\n\n/* Forward declarations */\nint getGenericCommand(client *c);\n\n/*-----------------------------------------------------------------------------\n * String Commands\n *----------------------------------------------------------------------------*/\n\nstatic int checkStringLength(client *c, long long size, long long append) {\n    if (mustObeyClient(c))\n        return C_OK;\n    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */\n    long long total = (uint64_t)size + append;\n    /* Test configured max-bulk-len represending a limit of the biggest string object,\n     * and also test for overflow. */\n    if (total > server.proto_max_bulk_len || total < size || total < append) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}\n\n/* The setGenericCommand() function implements the SET operation with different\n * options and variants. This function is called in order to implement the\n * following commands: SET, SETEX, PSETEX, SETNX, GETSET.\n *\n * 'flags' changes the behavior of the command (NX, XX or GET, see below).\n *\n * 'expire' represents an expire to set in form of a Redis object as passed\n * by the user. It is interpreted according to the specified 'unit'.\n *\n * 'ok_reply' and 'abort_reply' is what the function will reply to the client\n * if the operation is performed, or when it is not because of NX or\n * XX flags.\n *\n * If ok_reply is NULL \"+OK\" is used.\n * If abort_reply is NULL, \"$-1\" is used. */\n\n#define OBJ_NO_FLAGS 0\n#define OBJ_SET_NX (1<<0)          /* Set if key not exists. */\n#define OBJ_SET_XX (1<<1)          /* Set if key exists. */\n#define OBJ_EX (1<<2)              /* Set if time in seconds is given */\n#define OBJ_PX (1<<3)              /* Set if time in ms in given */\n#define OBJ_KEEPTTL (1<<4)         /* Set and keep the ttl */\n#define OBJ_SET_GET (1<<5)         /* Set if want to get key before set */\n#define OBJ_EXAT (1<<6)            /* Set if timestamp in second is given */\n#define OBJ_PXAT (1<<7)            /* Set if timestamp in ms is given */\n#define OBJ_PERSIST (1<<8)         /* Set if we need to remove the ttl */\n\n/* Forward declaration */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds);\n\nvoid setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {\n    long long milliseconds = 0; /* initialized to avoid any harmness warning */\n    int found = 0;\n    int setkey_flags = 0;\n\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    if (flags & OBJ_SET_GET) {\n        if (getGenericCommand(c) == C_ERR) return;\n    }\n\n    found = (lookupKeyWrite(c->db,key) != NULL);\n\n    if ((flags & OBJ_SET_NX && found) ||\n        (flags & OBJ_SET_XX && !found))\n    {\n        if (!(flags & OBJ_SET_GET)) {\n            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);\n        }\n        return;\n    }\n\n    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */\n    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;\n    setkey_flags |= found ? SETKEY_ALREADY_EXIST : SETKEY_DOESNT_EXIST;\n\n    setKey(c,c->db,key,val,setkey_flags);\n    server.dirty++;\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",key,c->db->id);\n\n    if (expire) {\n        setExpire(c,c->db,key,milliseconds);\n        /* Propagate as SET Key Value PXAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c, 5, shared.set, key, val, shared.pxat, milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",key,c->db->id);\n    }\n\n    if (!(flags & OBJ_SET_GET)) {\n        addReply(c, ok_reply ? ok_reply : shared.ok);\n    }\n\n    /* Propagate without the GET argument (Isn't needed if we had expire since in that case we completely re-written the command argv) */\n    if ((flags & OBJ_SET_GET) && !expire) {\n        int argc = 0;\n        int j;\n        robj **argv = zmalloc((c->argc-1)*sizeof(robj*));\n        for (j=0; j < c->argc; j++) {\n            char *a = c->argv[j]->ptr;\n            /* Skip GET which may be repeated multiple times. */\n            if (j >= 3 &&\n                (a[0] == 'g' || a[0] == 'G') &&\n                (a[1] == 'e' || a[1] == 'E') &&\n                (a[2] == 't' || a[2] == 'T') && a[3] == '\\0')\n                continue;\n            argv[argc++] = c->argv[j];\n            incrRefCount(c->argv[j]);\n        }\n        replaceClientCommandVector(c, argc, argv);\n    }\n}\n\n/*\n * Extract the `expire` argument of a given GET/SET command as an absolute timestamp in milliseconds.\n *\n * \"client\" is the client that sent the `expire` argument.\n * \"expire\" is the `expire` argument to be extracted.\n * \"flags\" represents the behavior of the command (e.g. PX or EX).\n * \"unit\" is the original unit of the given `expire` argument (e.g. UNIT_SECONDS).\n * \"milliseconds\" is output argument.\n *\n * If return C_OK, \"milliseconds\" output argument will be set to the resulting absolute timestamp.\n * If return C_ERR, an error reply has been added to the given client.\n */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {\n    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);\n    if (ret != C_OK) {\n        return ret;\n    }\n\n    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {\n        /* Negative value provided or multiplication is gonna overflow. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    if (unit == UNIT_SECONDS) *milliseconds *= 1000;\n\n    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {\n        *milliseconds += commandTimeSnapshot();\n    }\n\n    if (*milliseconds <= 0) {\n        /* Overflow detected. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    return C_OK;\n}\n\n#define COMMAND_GET 0\n#define COMMAND_SET 1\n/*\n * The parseExtendedStringArgumentsOrReply() function performs the common validation for extended\n * string arguments used in SET and GET command.\n *\n * Get specific commands - PERSIST/DEL\n * Set specific commands - XX/NX/GET\n * Common commands - EX/EXAT/PX/PXAT/KEEPTTL\n *\n * Function takes pointers to client, flags, unit, pointer to pointer of expire obj if needed\n * to be determined and command_type which can be COMMAND_GET or COMMAND_SET.\n *\n * If there are any syntax violations C_ERR is returned else C_OK is returned.\n *\n * Input flags are updated upon parsing the arguments. Unit and expire are updated if there are any\n * EX/EXAT/PX/PXAT arguments. Unit is updated to millisecond if PX/PXAT is set.\n */\nint parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {\n\n    int j = command_type == COMMAND_GET ? 2 : 3;\n    for (; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];\n\n        if ((opt[0] == 'n' || opt[0] == 'N') &&\n            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_NX;\n        } else if ((opt[0] == 'x' || opt[0] == 'X') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_XX;\n        } else if ((opt[0] == 'g' || opt[0] == 'G') &&\n                   (opt[1] == 'e' || opt[1] == 'E') &&\n                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\\0' &&\n                   (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_GET;\n        } else if (!strcasecmp(opt, \"KEEPTTL\") && !(*flags & OBJ_PERSIST) &&\n            !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n            !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_KEEPTTL;\n        } else if (!strcasecmp(opt,\"PERSIST\") && (command_type == COMMAND_GET) &&\n               !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n               !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) &&\n               !(*flags & OBJ_KEEPTTL))\n        {\n            *flags |= OBJ_PERSIST;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EXAT) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EX;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_PX;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EXAT;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PX) && next)\n        {\n            *flags |= OBJ_PXAT;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* SET key value [NX] [XX] [KEEPTTL] [GET] [EX <seconds>] [PX <milliseconds>]\n *     [EXAT <seconds-timestamp>][PXAT <milliseconds-timestamp>] */\nvoid setCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {\n        return;\n    }\n\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}\n\nvoid setnxCommand(client *c) {\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);\n}\n\nvoid setexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_EX,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);\n}\n\nvoid psetexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_PX,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);\n}\n\nint getGenericCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return C_OK;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return C_ERR;\n    }\n\n    addReplyBulk(c,o);\n    return C_OK;\n}\n\nvoid getCommand(client *c) {\n    getGenericCommand(c);\n}\n\n/*\n * GETEX <key> [PERSIST][EX seconds][PX milliseconds][EXAT seconds-timestamp][PXAT milliseconds-timestamp]\n *\n * The getexCommand() function implements extended options and variants of the GET command. Unlike GET\n * command this command is not read-only.\n *\n * The default behavior when no options are specified is same as GET and does not alter any TTL.\n *\n * Only one of the below options can be used at a given time.\n *\n * 1. PERSIST removes any TTL associated with the key.\n * 2. EX Set expiry TTL in seconds.\n * 3. PX Set expiry TTL in milliseconds.\n * 4. EXAT Same like EX instead of specifying the number of seconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n * 5. PXAT Same like PX instead of specifying the number of milliseconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n *\n * Command would either return the bulk string, error or nil.\n */\nvoid getexCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_GET) != C_OK) {\n        return;\n    }\n\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return;\n    }\n\n    /* Validate the expiration time value first */\n    long long milliseconds = 0;\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    /* We need to do this before we expire the key or delete it */\n    addReplyBulk(c,o);\n\n    /* This command is never propagated as is. It is either propagated as PEXPIRE[AT],DEL,UNLINK or PERSIST.\n     * This why it doesn't need special handling in feedAppendOnlyFile to convert relative expire time to absolute one. */\n    if (((flags & OBJ_PXAT) || (flags & OBJ_EXAT)) && checkAlreadyExpired(milliseconds)) {\n        /* When PXAT/EXAT absolute timestamp is specified, there can be a chance that timestamp\n         * has already elapsed so delete the key in that case. */\n        int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c->db, c->argv[1]) :\n                      dbSyncDelete(c->db, c->argv[1]);\n        serverAssert(deleted);\n        robj *aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;\n        rewriteClientCommandVector(c,2,aux,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    } else if (expire) {\n        setExpire(c,c->db,c->argv[1],milliseconds);\n        /* Propagate as PXEXPIREAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag and the key has not expired. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c,3,shared.pexpireat,c->argv[1],milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",c->argv[1],c->db->id);\n        server.dirty++;\n    } else if (flags & OBJ_PERSIST) {\n        if (removeExpire(c->db, c->argv[1])) {\n            signalModifiedKey(c, c->db, c->argv[1]);\n            rewriteClientCommandVector(c, 2, shared.persist, c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"persist\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    }\n}\n\nvoid getdelCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    if (dbSyncDelete(c->db, c->argv[1])) {\n        /* Propagate as DEL command */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid getsetCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setKey(c,c->db,c->argv[1],c->argv[2],0);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Propagate as SET command */\n    rewriteClientCommandArgument(c,0,shared.set);\n}\n\nvoid setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}\n\nvoid getrangeCommand(client *c) {\n    robj *o;\n    long long start, end;\n    char *str, llbuf[32];\n    size_t strlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)\n        return;\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)\n        return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n\n    if (o->encoding == OBJ_ENCODING_INT) {\n        str = llbuf;\n        strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);\n    } else {\n        str = o->ptr;\n        strlen = sdslen(str);\n    }\n\n    /* Convert negative indexes */\n    if (start < 0 && end < 0 && start > end) {\n        addReply(c,shared.emptybulk);\n        return;\n    }\n    if (start < 0) start = strlen+start;\n    if (end < 0) end = strlen+end;\n    if (start < 0) start = 0;\n    if (end < 0) end = 0;\n    if ((unsigned long long)end >= strlen) end = strlen-1;\n\n    /* Precondition: end >= 0 && end < strlen, so the only condition where\n     * nothing can be returned is: start > end. */\n    if (start > end || strlen == 0) {\n        addReply(c,shared.emptybulk);\n    } else {\n        addReplyBulkCBuffer(c,(char*)str+start,end-start+1);\n    }\n}\n\nvoid mgetCommand(client *c) {\n    int j;\n\n    addReplyArrayLen(c,c->argc-1);\n    for (j = 1; j < c->argc; j++) {\n        robj *o = lookupKeyRead(c->db,c->argv[j]);\n        if (o == NULL) {\n            addReplyNull(c);\n        } else {\n            if (o->type != OBJ_STRING) {\n                addReplyNull(c);\n            } else {\n                addReplyBulk(c,o);\n            }\n        }\n    }\n}\n\nvoid msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}\n\nvoid msetCommand(client *c) {\n    msetGenericCommand(c,0);\n}\n\nvoid msetnxCommand(client *c) {\n    msetGenericCommand(c,1);\n}\n\nvoid incrDecrCommand(client *c, long long incr) {\n    long long value, oldvalue;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n\n    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&\n        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&\n        value >= LONG_MIN && value <= LONG_MAX)\n    {\n        new = o;\n        o->ptr = (void*)((long)value);\n    } else {\n        new = createStringObjectFromLongLongForValue(value);\n        if (o) {\n            dbReplaceValue(c->db,c->argv[1],new);\n        } else {\n            dbAdd(c->db,c->argv[1],new);\n        }\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrby\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c, value);\n}\n\nvoid incrCommand(client *c) {\n    incrDecrCommand(c,1);\n}\n\nvoid decrCommand(client *c) {\n    incrDecrCommand(c,-1);\n}\n\nvoid incrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    incrDecrCommand(c,incr);\n}\n\nvoid decrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    /* Overflow check: negating LLONG_MIN will cause an overflow */\n    if (incr == LLONG_MIN) {\n        addReplyError(c, \"decrement would overflow\");\n        return;\n    }\n    incrDecrCommand(c,-incr);\n}\n\nvoid incrbyfloatCommand(client *c) {\n    long double incr, value;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||\n        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)\n        return;\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    new = createStringObjectFromLongDouble(value,1);\n    if (o)\n        dbReplaceValue(c->db,c->argv[1],new);\n    else\n        dbAdd(c->db,c->argv[1],new);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyBulk(c,new);\n\n    /* Always replicate INCRBYFLOAT as a SET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    rewriteClientCommandArgument(c,0,shared.set);\n    rewriteClientCommandArgument(c,2,new);\n    rewriteClientCommandArgument(c,3,shared.keepttl);\n}\n\nvoid appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}\n\nvoid strlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n    addReplyLongLong(c,stringObjectLen(o));\n}\n\n/* LCS key1 key2 [LEN] [IDX] [MINMATCHLEN <len>] [WITHMATCHLEN] */\nvoid lcsCommand(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    obja = lookupKeyRead(c->db,c->argv[1]);\n    objb = lookupKeyRead(c->db,c->argv[2]);\n    if ((obja && obja->type != OBJ_STRING) ||\n        (objb && objb->type != OBJ_STRING))\n    {\n        addReplyError(c,\n            \"The specified keys must contain string values\");\n        /* Don't cleanup the objects, we need to do that\n         * only after calling getDecodedObject(). */\n        obja = NULL;\n        objb = NULL;\n        goto cleanup;\n    }\n    obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n    objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n    a = obja->ptr;\n    b = objb->ptr;\n\n    for (j = 3; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Detect string truncation or later overflows. */\n    if (sdslen(a) >= UINT32_MAX-1 || sdslen(b) >= UINT32_MAX-1) {\n        addReplyError(c, \"String too long for LCS\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*i] */\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Try to allocate the LCS table, and abort on overflow or insufficient memory. */\n    unsigned long long lcssize = (unsigned long long)(alen+1)*(blen+1); /* Can't overflow due to the size limits above. */\n    unsigned long long lcsalloc = lcssize * sizeof(uint32_t);\n    uint32_t *lcs = NULL;\n    if (lcsalloc < SIZE_MAX && lcsalloc / lcssize == sizeof(uint32_t)) {\n        if (lcsalloc > (size_t)server.proto_max_bulk_len) {\n            addReplyError(c, \"Insufficient memory, transient memory for LCS exceeds proto-max-bulk-len\");\n            goto cleanup;\n        }\n        lcs = ztrymalloc(lcsalloc);\n    }\n    if (!lcs) {\n        addReplyError(c, \"Insufficient memory, failed allocating transient memory for LCS\");\n        goto cleanup;\n    }\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deferred length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}\n\n", "start_server {tags {\"string\"}} {\n    test {SET and GET an item} {\n        r set x foobar\n        r get x\n    } {foobar}\n\n    test {SET and GET an empty item} {\n        r set x {}\n        r get x\n    } {}\n\n    test {Very big payload in GET/SET} {\n        set buf [string repeat \"abcd\" 1000000]\n        r set foo $buf\n        r get foo\n    } [string repeat \"abcd\" 1000000]\n\n    tags {\"slow\"} {\n        test {Very big payload random access} {\n            set err {}\n            array set payload {}\n            for {set j 0} {$j < 100} {incr j} {\n                set size [expr 1+[randomInt 100000]]\n                set buf [string repeat \"pl-$j\" $size]\n                set payload($j) $buf\n                r set bigpayload_$j $buf\n            }\n            for {set j 0} {$j < 1000} {incr j} {\n                set index [randomInt 100]\n                set buf [r get bigpayload_$index]\n                if {$buf != $payload($index)} {\n                    set err \"Values differ: I set '$payload($index)' but I read back '$buf'\"\n                    break\n                }\n            }\n            unset payload\n            set _ $err\n        } {}\n\n        test {SET 10000 numeric keys and access all them in reverse order} {\n            r flushdb\n            set err {}\n            for {set x 0} {$x < 10000} {incr x} {\n                r set $x $x\n            }\n            set sum 0\n            for {set x 9999} {$x >= 0} {incr x -1} {\n                set val [r get $x]\n                if {$val ne $x} {\n                    set err \"Element at position $x is $val instead of $x\"\n                    break\n                }\n            }\n            set _ $err\n        } {}\n\n        test {DBSIZE should be 10000 now} {\n            r dbsize\n        } {10000}\n    }\n\n    test \"SETNX target key missing\" {\n        r del novar\n        assert_equal 1 [r setnx novar foobared]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX target key exists\" {\n        r set novar foobared\n        assert_equal 0 [r setnx novar blabla]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX against not-expired volatile key\" {\n        r set x 10\n        r expire x 10000\n        assert_equal 0 [r setnx x 20]\n        assert_equal 10 [r get x]\n    }\n\n    test \"SETNX against expired volatile key\" {\n        # Make it very unlikely for the key this test uses to be expired by the\n        # active expiry cycle. This is tightly coupled to the implementation of\n        # active expiry and dbAdd() but currently the only way to test that\n        # SETNX expires a key when it should have been.\n        for {set x 0} {$x < 9999} {incr x} {\n            r setex key-$x 3600 value\n        }\n\n        # This will be one of 10000 expiring keys. A cycle is executed every\n        # 100ms, sampling 10 keys for being expired or not.  This key will be\n        # expired for at most 1s when we wait 2s, resulting in a total sample\n        # of 100 keys. The probability of the success of this test being a\n        # false positive is therefore approx. 1%.\n        r set x 10\n        r expire x 1\n\n        # Wait for the key to expire\n        after 2000\n\n        assert_equal 1 [r setnx x 20]\n        assert_equal 20 [r get x]\n    }\n\n    test \"GETEX EX option\" {\n        r del foo\n        r set foo bar\n        r getex foo ex 10\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PX option\" {\n        r del foo\n        r set foo bar\n        r getex foo px 10000\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX EXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo pxat [expr [clock milliseconds] + 10000]\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX PERSIST option\" {\n        r del foo\n        r set foo bar ex 10\n        assert_range [r ttl foo] 5 10\n        r getex foo persist\n        assert_equal -1 [r ttl foo]\n    }\n\n    test \"GETEX no option\" {\n        r del foo\n        r set foo bar\n        r getex foo\n        assert_equal bar [r getex foo]\n    }\n\n    test \"GETEX syntax errors\" {\n        set ex {}\n        catch {r getex foo non-existent-option} ex\n        set ex\n    } {*syntax*}\n\n    test \"GETEX no arguments\" {\n         set ex {}\n         catch {r getex} ex\n         set ex\n     } {*wrong number of arguments for 'getex' command}\n\n    test \"GETDEL command\" {\n        r del foo\n        r set foo bar\n        assert_equal bar [r getdel foo ]\n        assert_equal {} [r getdel foo ]\n    }\n\n    test {GETDEL propagate as DEL command to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getdel foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {GETEX without argument does not propagate to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getex foo\n        r del foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {MGET} {\n        r flushdb\n        r set foo{t} BAR\n        r set bar{t} FOO\n        r mget foo{t} bar{t}\n    } {BAR FOO}\n\n    test {MGET against non existing key} {\n        r mget foo{t} baazz{t} bar{t}\n    } {BAR {} FOO}\n\n    test {MGET against non-string key} {\n        r sadd myset{t} ciao\n        r sadd myset{t} bau\n        r mget foo{t} baazz{t} bar{t} myset{t}\n    } {BAR {} FOO {}}\n\n    test {GETSET (set new value)} {\n        r del foo\n        list [r getset foo xyz] [r get foo]\n    } {{} xyz}\n\n    test {GETSET (replace old value)} {\n        r set foo bar\n        list [r getset foo xyz] [r get foo]\n    } {bar xyz}\n\n    test {MSET base case} {\n        r mset x{t} 10 y{t} \"foo bar\" z{t} \"x x x x x x x\\n\\n\\r\\n\"\n        r mget x{t} y{t} z{t}\n    } [list 10 {foo bar} \"x x x x x x x\\n\\n\\r\\n\"]\n\n    test {MSET/MSETNX wrong number of args} {\n        assert_error {*wrong number of arguments for 'mset' command} {r mset x{t} 10 y{t} \"foo bar\" z{t}}\n        assert_error {*wrong number of arguments for 'msetnx' command} {r msetnx x{t} 20 y{t} \"foo bar\" z{t}}\n    }\n\n    test {MSETNX with already existent key} {\n        list [r msetnx x1{t} xxx y2{t} yyy x{t} 20] [r exists x1{t}] [r exists y2{t}]\n    } {0 0 0}\n\n    test {MSETNX with not existing keys} {\n        list [r msetnx x1{t} xxx y2{t} yyy] [r get x1{t}] [r get y2{t}]\n    } {1 xxx yyy}\n\n    test \"STRLEN against non-existing key\" {\n        assert_equal 0 [r strlen notakey]\n    }\n\n    test \"STRLEN against integer-encoded value\" {\n        r set myinteger -555\n        assert_equal 4 [r strlen myinteger]\n    }\n\n    test \"STRLEN against plain string\" {\n        r set mystring \"foozzz0123456789 baz\"\n        assert_equal 20 [r strlen mystring]\n    }\n\n    test \"SETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r setbit mykey 1 1]\n        assert_equal [binary format B* 01000000] [r get mykey]\n    }\n\n    test \"SETBIT against string-encoded key\" {\n        # Ascii \"@\" is integer 64 = 01 00 00 00\n        r set mykey \"@\"\n\n        assert_equal 0 [r setbit mykey 2 1]\n        assert_equal [binary format B* 01100000] [r get mykey]\n        assert_equal 1 [r setbit mykey 1 0]\n        assert_equal [binary format B* 00100000] [r get mykey]\n    }\n\n    test \"SETBIT against integer-encoded key\" {\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        r set mykey 1\n        assert_encoding int mykey\n\n        assert_equal 0 [r setbit mykey 6 1]\n        assert_equal [binary format B* 00110011] [r get mykey]\n        assert_equal 1 [r setbit mykey 2 0]\n        assert_equal [binary format B* 00010011] [r get mykey]\n    }\n\n    test \"SETBIT against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setbit mykey 0 1}\n    }\n\n    test \"SETBIT with out of range bit offset\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey [expr 4*1024*1024*1024] 1}\n        assert_error \"*out of range*\" {r setbit mykey -1 1}\n    }\n\n    test \"SETBIT with non-bit argument\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey 0 -1}\n        assert_error \"*out of range*\" {r setbit mykey 0  2}\n        assert_error \"*out of range*\" {r setbit mykey 0 10}\n        assert_error \"*out of range*\" {r setbit mykey 0 20}\n    }\n\n    test \"SETBIT fuzzing\" {\n        set str \"\"\n        set len [expr 256*8]\n        r del mykey\n\n        for {set i 0} {$i < 2000} {incr i} {\n            set bitnum [randomInt $len]\n            set bitval [randomInt 2]\n            set fmt [format \"%%-%ds%%d%%-s\" $bitnum]\n            set head [string range $str 0 $bitnum-1]\n            set tail [string range $str $bitnum+1 end]\n            set str [string map {\" \" 0} [format $fmt $head $bitval $tail]]\n\n            r setbit mykey $bitnum $bitval\n            assert_equal [binary format B* $str] [r get mykey]\n        }\n    }\n\n    test \"GETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r getbit mykey 0]\n    }\n\n    test \"GETBIT against string-encoded key\" {\n        # Single byte with 2nd and 3rd bit set\n        r set mykey \"`\"\n\n        # In-range\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 1 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 0 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"GETBIT against integer-encoded key\" {\n        r set mykey 1\n        assert_encoding int mykey\n\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 0 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 1 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"SETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal 3 [r setrange mykey 0 foo]\n        assert_equal \"foo\" [r get mykey]\n\n        r del mykey\n        assert_equal 0 [r setrange mykey 0 \"\"]\n        assert_equal 0 [r exists mykey]\n\n        r del mykey\n        assert_equal 4 [r setrange mykey 1 foo]\n        assert_equal \"\\000foo\" [r get mykey]\n    }\n\n    test \"SETRANGE against string-encoded key\" {\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 b]\n        assert_equal \"boo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 \"\"]\n        assert_equal \"foo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 1 b]\n        assert_equal \"fbo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 7 [r setrange mykey 4 bar]\n        assert_equal \"foo\\000bar\" [r get mykey]\n    }\n\n    test \"SETRANGE against integer-encoded key\" {\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 2]\n        assert_encoding raw mykey\n        assert_equal 2234 [r get mykey]\n\n        # Shouldn't change encoding when nothing is set\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 \"\"]\n        assert_encoding int mykey\n        assert_equal 1234 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 1 3]\n        assert_encoding raw mykey\n        assert_equal 1334 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 6 [r setrange mykey 5 2]\n        assert_encoding raw mykey\n        assert_equal \"1234\\0002\" [r get mykey]\n    }\n\n    test \"SETRANGE against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setrange mykey 0 bar}\n    }\n\n    test \"SETRANGE with out of range offset\" {\n        r del mykey\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n\n        r set mykey \"hello\"\n        assert_error \"*out of range*\" {r setrange mykey -1 world}\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n    }\n\n    test \"GETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal \"\" [r getrange mykey 0 -1]\n    }\n\n    test \"GETRANGE against string value\" {\n        r set mykey \"Hello World\"\n        assert_equal \"Hell\" [r getrange mykey 0 3]\n        assert_equal \"Hello World\" [r getrange mykey 0 -1]\n        assert_equal \"orld\" [r getrange mykey -4 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \" World\" [r getrange mykey 5 5000]\n        assert_equal \"Hello World\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE against integer-encoded value\" {\n        r set mykey 1234\n        assert_equal \"123\" [r getrange mykey 0 2]\n        assert_equal \"1234\" [r getrange mykey 0 -1]\n        assert_equal \"234\" [r getrange mykey -3 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \"4\" [r getrange mykey 3 5000]\n        assert_equal \"1234\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE fuzzing\" {\n        for {set i 0} {$i < 1000} {incr i} {\n            r set bin [set bin [randstring 0 1024 binary]]\n            set _start [set start [randomInt 1500]]\n            set _end [set end [randomInt 1500]]\n            if {$_start < 0} {set _start \"end-[abs($_start)-1]\"}\n            if {$_end < 0} {set _end \"end-[abs($_end)-1]\"}\n            assert_equal [string range $bin $_start $_end] [r getrange bin $start $end]\n        }\n    }\n\n    test \"Coverage: SUBSTR\" {\n        r set key abcde\n        assert_equal \"a\" [r substr key 0 0]\n        assert_equal \"abcd\" [r substr key 0 3]\n        assert_equal \"bcde\" [r substr key -4 -1]\n    }\n    \nif {[string match {*jemalloc*} [s mem_allocator]]} {\n    test {trim on SET with big value} {\n        # set a big value to trigger increasing the query buf\n        r set key [string repeat A 100000] \n        # set a smaller value but > PROTO_MBULK_BIG_ARG (32*1024) Redis will try to save the query buf itself on the DB.\n        r set key [string repeat A 33000]\n        # asset the value was trimmed\n        assert {[r memory usage key] < 42000}; # 42K to count for Jemalloc's additional memory overhead. \n    }\n} ;# if jemalloc\n\n    test {Extended SET can detect syntax errors} {\n        set e {}\n        catch {r set foo bar non-existing-option} e\n        set e\n    } {*syntax*}\n\n    test {Extended SET NX option} {\n        r del foo\n        set v1 [r set foo 1 nx]\n        set v2 [r set foo 2 nx]\n        list $v1 $v2 [r get foo]\n    } {OK {} 1}\n\n    test {Extended SET XX option} {\n        r del foo\n        set v1 [r set foo 1 xx]\n        r set foo bar\n        set v2 [r set foo 2 xx]\n        list $v1 $v2 [r get foo]\n    } {{} OK 2}\n\n    test {Extended SET GET option} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo bar2 GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar2}\n\n    test {Extended SET GET option with no previous value} {\n        r del foo\n        set old_value [r set foo bar GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with XX} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar baz}\n\n    test {Extended SET GET option with XX and no previous value} {\n        r del foo\n        set old_value [r set foo bar GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} {}}\n\n    test {Extended SET GET option with NX} {\n        r del foo\n        set old_value [r set foo bar GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with NX and previous value} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar}\n\n    test {Extended SET GET with incorrect type should result in wrong type error} {\n      r del foo\n      r rpush foo waffle\n      catch {r set foo bar GET} err1\n      assert_equal \"waffle\" [r rpop foo]\n      set err1\n    } {*WRONGTYPE*}\n\n    test {Extended SET EX option} {\n        r del foo\n        r set foo bar ex 10\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {Extended SET PX option} {\n        r del foo\n        r set foo bar px 10000\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test \"Extended SET EXAT option\" {\n        r del foo\n        r set foo bar exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"Extended SET PXAT option\" {\n        r del foo\n        r set foo bar pxat [expr [clock milliseconds] + 10000]\n        assert_range [r ttl foo] 5 10\n    }\n    test {Extended SET using multiple options at once} {\n        r set foo val\n        assert {[r set foo bar xx px 10000] eq {OK}}\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {GETRANGE with huge ranges, Github issue #1844} {\n        r set foo bar\n        r getrange foo 0 4294967297\n    } {bar}\n\n    set rna1 {CACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTTCGTCCGGGTGTG}\n    set rna2 {ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n    set rnalcs {ACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n\n    test {LCS basic} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t}\n    } $rnalcs\n\n    test {LCS len} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t} LEN\n    } [string length $rnalcs]\n\n    test {LCS indexes} {\n        dict get [r LCS virus1{t} virus2{t} IDX] matches\n    } {{{238 238} {239 239}} {{236 236} {238 238}} {{229 230} {236 237}} {{224 224} {235 235}} {{1 222} {13 234}}}\n\n    test {LCS indexes with match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN] matches\n    } {{{238 238} {239 239} 1} {{236 236} {238 238} 1} {{229 230} {236 237} 2} {{224 224} {235 235} 1} {{1 222} {13 234} 222}}\n\n    test {LCS indexes with match len and minimum match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN MINMATCHLEN 5] matches\n    } {{{1 222} {13 234} 222}}\n\n    test {SETRANGE with huge offset} {\n        foreach value {9223372036854775807 2147483647} {\n            catch {[r setrange K $value A]} res\n            # expecting a different error on 32 and 64 bit systems\n            if {![string match \"*string exceeds maximum allowed size*\" $res] && ![string match \"*out of range*\" $res]} {\n                assert_equal $res \"expecting an error\"\n           }\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h> /* isnan(), isinf() */\n\n/* Forward declarations */\nint getGenericCommand(client *c);\n\n/*-----------------------------------------------------------------------------\n * String Commands\n *----------------------------------------------------------------------------*/\n\nstatic int checkStringLength(client *c, long long size, long long append) {\n    if (mustObeyClient(c))\n        return C_OK;\n    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */\n    long long total = (uint64_t)size + append;\n    /* Test configured max-bulk-len represending a limit of the biggest string object,\n     * and also test for overflow. */\n    if (total > server.proto_max_bulk_len || total < size || total < append) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}\n\n/* The setGenericCommand() function implements the SET operation with different\n * options and variants. This function is called in order to implement the\n * following commands: SET, SETEX, PSETEX, SETNX, GETSET.\n *\n * 'flags' changes the behavior of the command (NX, XX or GET, see below).\n *\n * 'expire' represents an expire to set in form of a Redis object as passed\n * by the user. It is interpreted according to the specified 'unit'.\n *\n * 'ok_reply' and 'abort_reply' is what the function will reply to the client\n * if the operation is performed, or when it is not because of NX or\n * XX flags.\n *\n * If ok_reply is NULL \"+OK\" is used.\n * If abort_reply is NULL, \"$-1\" is used. */\n\n#define OBJ_NO_FLAGS 0\n#define OBJ_SET_NX (1<<0)          /* Set if key not exists. */\n#define OBJ_SET_XX (1<<1)          /* Set if key exists. */\n#define OBJ_EX (1<<2)              /* Set if time in seconds is given */\n#define OBJ_PX (1<<3)              /* Set if time in ms in given */\n#define OBJ_KEEPTTL (1<<4)         /* Set and keep the ttl */\n#define OBJ_SET_GET (1<<5)         /* Set if want to get key before set */\n#define OBJ_EXAT (1<<6)            /* Set if timestamp in second is given */\n#define OBJ_PXAT (1<<7)            /* Set if timestamp in ms is given */\n#define OBJ_PERSIST (1<<8)         /* Set if we need to remove the ttl */\n\n/* Forward declaration */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds);\n\nvoid setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {\n    long long milliseconds = 0; /* initialized to avoid any harmness warning */\n    int found = 0;\n    int setkey_flags = 0;\n\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    if (flags & OBJ_SET_GET) {\n        if (getGenericCommand(c) == C_ERR) return;\n    }\n\n    found = (lookupKeyWrite(c->db,key) != NULL);\n\n    if ((flags & OBJ_SET_NX && found) ||\n        (flags & OBJ_SET_XX && !found))\n    {\n        if (!(flags & OBJ_SET_GET)) {\n            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);\n        }\n        return;\n    }\n\n    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */\n    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;\n    setkey_flags |= found ? SETKEY_ALREADY_EXIST : SETKEY_DOESNT_EXIST;\n\n    setKey(c,c->db,key,val,setkey_flags);\n    server.dirty++;\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",key,c->db->id);\n\n    if (expire) {\n        setExpire(c,c->db,key,milliseconds);\n        /* Propagate as SET Key Value PXAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c, 5, shared.set, key, val, shared.pxat, milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",key,c->db->id);\n    }\n\n    if (!(flags & OBJ_SET_GET)) {\n        addReply(c, ok_reply ? ok_reply : shared.ok);\n    }\n\n    /* Propagate without the GET argument (Isn't needed if we had expire since in that case we completely re-written the command argv) */\n    if ((flags & OBJ_SET_GET) && !expire) {\n        int argc = 0;\n        int j;\n        robj **argv = zmalloc((c->argc-1)*sizeof(robj*));\n        for (j=0; j < c->argc; j++) {\n            char *a = c->argv[j]->ptr;\n            /* Skip GET which may be repeated multiple times. */\n            if (j >= 3 &&\n                (a[0] == 'g' || a[0] == 'G') &&\n                (a[1] == 'e' || a[1] == 'E') &&\n                (a[2] == 't' || a[2] == 'T') && a[3] == '\\0')\n                continue;\n            argv[argc++] = c->argv[j];\n            incrRefCount(c->argv[j]);\n        }\n        replaceClientCommandVector(c, argc, argv);\n    }\n}\n\n/*\n * Extract the `expire` argument of a given GET/SET command as an absolute timestamp in milliseconds.\n *\n * \"client\" is the client that sent the `expire` argument.\n * \"expire\" is the `expire` argument to be extracted.\n * \"flags\" represents the behavior of the command (e.g. PX or EX).\n * \"unit\" is the original unit of the given `expire` argument (e.g. UNIT_SECONDS).\n * \"milliseconds\" is output argument.\n *\n * If return C_OK, \"milliseconds\" output argument will be set to the resulting absolute timestamp.\n * If return C_ERR, an error reply has been added to the given client.\n */\nstatic int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {\n    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);\n    if (ret != C_OK) {\n        return ret;\n    }\n\n    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {\n        /* Negative value provided or multiplication is gonna overflow. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    if (unit == UNIT_SECONDS) *milliseconds *= 1000;\n\n    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {\n        *milliseconds += commandTimeSnapshot();\n    }\n\n    if (*milliseconds <= 0) {\n        /* Overflow detected. */\n        addReplyErrorExpireTime(c);\n        return C_ERR;\n    }\n\n    return C_OK;\n}\n\n#define COMMAND_GET 0\n#define COMMAND_SET 1\n/*\n * The parseExtendedStringArgumentsOrReply() function performs the common validation for extended\n * string arguments used in SET and GET command.\n *\n * Get specific commands - PERSIST/DEL\n * Set specific commands - XX/NX/GET\n * Common commands - EX/EXAT/PX/PXAT/KEEPTTL\n *\n * Function takes pointers to client, flags, unit, pointer to pointer of expire obj if needed\n * to be determined and command_type which can be COMMAND_GET or COMMAND_SET.\n *\n * If there are any syntax violations C_ERR is returned else C_OK is returned.\n *\n * Input flags are updated upon parsing the arguments. Unit and expire are updated if there are any\n * EX/EXAT/PX/PXAT arguments. Unit is updated to millisecond if PX/PXAT is set.\n */\nint parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {\n\n    int j = command_type == COMMAND_GET ? 2 : 3;\n    for (; j < c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];\n\n        if ((opt[0] == 'n' || opt[0] == 'N') &&\n            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_NX;\n        } else if ((opt[0] == 'x' || opt[0] == 'X') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_XX;\n        } else if ((opt[0] == 'g' || opt[0] == 'G') &&\n                   (opt[1] == 'e' || opt[1] == 'E') &&\n                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\\0' &&\n                   (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_SET_GET;\n        } else if (!strcasecmp(opt, \"KEEPTTL\") && !(*flags & OBJ_PERSIST) &&\n            !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n            !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) && (command_type == COMMAND_SET))\n        {\n            *flags |= OBJ_KEEPTTL;\n        } else if (!strcasecmp(opt,\"PERSIST\") && (command_type == COMMAND_GET) &&\n               !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n               !(*flags & OBJ_PX) && !(*flags & OBJ_PXAT) &&\n               !(*flags & OBJ_KEEPTTL))\n        {\n            *flags |= OBJ_PERSIST;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EXAT) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EX;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_PX;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'e' || opt[0] == 'E') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_PX) &&\n                   !(*flags & OBJ_PXAT) && next)\n        {\n            *flags |= OBJ_EXAT;\n            *expire = next;\n            j++;\n        } else if ((opt[0] == 'p' || opt[0] == 'P') &&\n                   (opt[1] == 'x' || opt[1] == 'X') &&\n                   (opt[2] == 'a' || opt[2] == 'A') &&\n                   (opt[3] == 't' || opt[3] == 'T') && opt[4] == '\\0' &&\n                   !(*flags & OBJ_KEEPTTL) && !(*flags & OBJ_PERSIST) &&\n                   !(*flags & OBJ_EX) && !(*flags & OBJ_EXAT) &&\n                   !(*flags & OBJ_PX) && next)\n        {\n            *flags |= OBJ_PXAT;\n            *unit = UNIT_MILLISECONDS;\n            *expire = next;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* SET key value [NX] [XX] [KEEPTTL] [GET] [EX <seconds>] [PX <milliseconds>]\n *     [EXAT <seconds-timestamp>][PXAT <milliseconds-timestamp>] */\nvoid setCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {\n        return;\n    }\n\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);\n}\n\nvoid setnxCommand(client *c) {\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);\n}\n\nvoid setexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_EX,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);\n}\n\nvoid psetexCommand(client *c) {\n    c->argv[3] = tryObjectEncoding(c->argv[3]);\n    setGenericCommand(c,OBJ_PX,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);\n}\n\nint getGenericCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return C_OK;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return C_ERR;\n    }\n\n    addReplyBulk(c,o);\n    return C_OK;\n}\n\nvoid getCommand(client *c) {\n    getGenericCommand(c);\n}\n\n/*\n * GETEX <key> [PERSIST][EX seconds][PX milliseconds][EXAT seconds-timestamp][PXAT milliseconds-timestamp]\n *\n * The getexCommand() function implements extended options and variants of the GET command. Unlike GET\n * command this command is not read-only.\n *\n * The default behavior when no options are specified is same as GET and does not alter any TTL.\n *\n * Only one of the below options can be used at a given time.\n *\n * 1. PERSIST removes any TTL associated with the key.\n * 2. EX Set expiry TTL in seconds.\n * 3. PX Set expiry TTL in milliseconds.\n * 4. EXAT Same like EX instead of specifying the number of seconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n * 5. PXAT Same like PX instead of specifying the number of milliseconds representing the TTL\n *      (time to live), it takes an absolute Unix timestamp\n *\n * Command would either return the bulk string, error or nil.\n */\nvoid getexCommand(client *c) {\n    robj *expire = NULL;\n    int unit = UNIT_SECONDS;\n    int flags = OBJ_NO_FLAGS;\n\n    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_GET) != C_OK) {\n        return;\n    }\n\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)\n        return;\n\n    if (checkType(c,o,OBJ_STRING)) {\n        return;\n    }\n\n    /* Validate the expiration time value first */\n    long long milliseconds = 0;\n    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {\n        return;\n    }\n\n    /* We need to do this before we expire the key or delete it */\n    addReplyBulk(c,o);\n\n    /* This command is never propagated as is. It is either propagated as PEXPIRE[AT],DEL,UNLINK or PERSIST.\n     * This why it doesn't need special handling in feedAppendOnlyFile to convert relative expire time to absolute one. */\n    if (((flags & OBJ_PXAT) || (flags & OBJ_EXAT)) && checkAlreadyExpired(milliseconds)) {\n        /* When PXAT/EXAT absolute timestamp is specified, there can be a chance that timestamp\n         * has already elapsed so delete the key in that case. */\n        int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c->db, c->argv[1]) :\n                      dbSyncDelete(c->db, c->argv[1]);\n        serverAssert(deleted);\n        robj *aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;\n        rewriteClientCommandVector(c,2,aux,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    } else if (expire) {\n        setExpire(c,c->db,c->argv[1],milliseconds);\n        /* Propagate as PXEXPIREAT millisecond-timestamp if there is\n         * EX/PX/EXAT/PXAT flag and the key has not expired. */\n        robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);\n        rewriteClientCommandVector(c,3,shared.pexpireat,c->argv[1],milliseconds_obj);\n        decrRefCount(milliseconds_obj);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"expire\",c->argv[1],c->db->id);\n        server.dirty++;\n    } else if (flags & OBJ_PERSIST) {\n        if (removeExpire(c->db, c->argv[1])) {\n            signalModifiedKey(c, c->db, c->argv[1]);\n            rewriteClientCommandVector(c, 2, shared.persist, c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"persist\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    }\n}\n\nvoid getdelCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    if (dbSyncDelete(c->db, c->argv[1])) {\n        /* Propagate as DEL command */\n        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\", c->argv[1], c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid getsetCommand(client *c) {\n    if (getGenericCommand(c) == C_ERR) return;\n    c->argv[2] = tryObjectEncoding(c->argv[2]);\n    setKey(c,c->db,c->argv[1],c->argv[2],0);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Propagate as SET command */\n    rewriteClientCommandArgument(c,0,shared.set);\n}\n\nvoid setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Return 0 when setting nothing on a non-existing string */\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* Return existing string length when setting nothing */\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n\n        /* Return when the resulting string exceeds allowed size */\n        if (checkStringLength(c,offset,sdslen(value)) != C_OK)\n            return;\n\n        /* Create a copy when the object is shared or encoded. */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}\n\nvoid getrangeCommand(client *c) {\n    robj *o;\n    long long start, end;\n    char *str, llbuf[32];\n    size_t strlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)\n        return;\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)\n        return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n\n    if (o->encoding == OBJ_ENCODING_INT) {\n        str = llbuf;\n        strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);\n    } else {\n        str = o->ptr;\n        strlen = sdslen(str);\n    }\n\n    /* Convert negative indexes */\n    if (start < 0 && end < 0 && start > end) {\n        addReply(c,shared.emptybulk);\n        return;\n    }\n    if (start < 0) start = strlen+start;\n    if (end < 0) end = strlen+end;\n    if (start < 0) start = 0;\n    if (end < 0) end = 0;\n    if ((unsigned long long)end >= strlen) end = strlen-1;\n\n    /* Precondition: end >= 0 && end < strlen, so the only condition where\n     * nothing can be returned is: start > end. */\n    if (start > end || strlen == 0) {\n        addReply(c,shared.emptybulk);\n    } else {\n        addReplyBulkCBuffer(c,(char*)str+start,end-start+1);\n    }\n}\n\nvoid mgetCommand(client *c) {\n    int j;\n\n    addReplyArrayLen(c,c->argc-1);\n    for (j = 1; j < c->argc; j++) {\n        robj *o = lookupKeyRead(c->db,c->argv[j]);\n        if (o == NULL) {\n            addReplyNull(c);\n        } else {\n            if (o->type != OBJ_STRING) {\n                addReplyNull(c);\n            } else {\n                addReplyBulk(c,o);\n            }\n        }\n    }\n}\n\nvoid msetGenericCommand(client *c, int nx) {\n    int j;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}\n\nvoid msetCommand(client *c) {\n    msetGenericCommand(c,0);\n}\n\nvoid msetnxCommand(client *c) {\n    msetGenericCommand(c,1);\n}\n\nvoid incrDecrCommand(client *c, long long incr) {\n    long long value, oldvalue;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n\n    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&\n        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&\n        value >= LONG_MIN && value <= LONG_MAX)\n    {\n        new = o;\n        o->ptr = (void*)((long)value);\n    } else {\n        new = createStringObjectFromLongLongForValue(value);\n        if (o) {\n            dbReplaceValue(c->db,c->argv[1],new);\n        } else {\n            dbAdd(c->db,c->argv[1],new);\n        }\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrby\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c, value);\n}\n\nvoid incrCommand(client *c) {\n    incrDecrCommand(c,1);\n}\n\nvoid decrCommand(client *c) {\n    incrDecrCommand(c,-1);\n}\n\nvoid incrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    incrDecrCommand(c,incr);\n}\n\nvoid decrbyCommand(client *c) {\n    long long incr;\n\n    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;\n    /* Overflow check: negating LLONG_MIN will cause an overflow */\n    if (incr == LLONG_MIN) {\n        addReplyError(c, \"decrement would overflow\");\n        return;\n    }\n    incrDecrCommand(c,-incr);\n}\n\nvoid incrbyfloatCommand(client *c) {\n    long double incr, value;\n    robj *o, *new;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (checkType(c,o,OBJ_STRING)) return;\n    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||\n        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)\n        return;\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    new = createStringObjectFromLongDouble(value,1);\n    if (o)\n        dbReplaceValue(c->db,c->argv[1],new);\n    else\n        dbAdd(c->db,c->argv[1],new);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"incrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyBulk(c,new);\n\n    /* Always replicate INCRBYFLOAT as a SET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    rewriteClientCommandArgument(c,0,shared.set);\n    rewriteClientCommandArgument(c,2,new);\n    rewriteClientCommandArgument(c,3,shared.keepttl);\n}\n\nvoid appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        /* Create the key */\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        /* Key exists, check type */\n        if (checkType(c,o,OBJ_STRING))\n            return;\n\n        /* \"append\" is an argument, so always an sds */\n        append = c->argv[2];\n        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)\n            return;\n\n        /* Append the value */\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}\n\nvoid strlenCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_STRING)) return;\n    addReplyLongLong(c,stringObjectLen(o));\n}\n\n/* LCS key1 key2 [LEN] [IDX] [MINMATCHLEN <len>] [WITHMATCHLEN] */\nvoid lcsCommand(client *c) {\n    uint32_t i, j;\n    long long minmatchlen = 0;\n    sds a = NULL, b = NULL;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja = NULL, *objb = NULL;\n\n    obja = lookupKeyRead(c->db,c->argv[1]);\n    objb = lookupKeyRead(c->db,c->argv[2]);\n    if ((obja && obja->type != OBJ_STRING) ||\n        (objb && objb->type != OBJ_STRING))\n    {\n        addReplyError(c,\n            \"The specified keys must contain string values\");\n        /* Don't cleanup the objects, we need to do that\n         * only after calling getDecodedObject(). */\n        obja = NULL;\n        objb = NULL;\n        goto cleanup;\n    }\n    obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n    objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n    a = obja->ptr;\n    b = objb->ptr;\n\n    for (j = 3; j < (uint32_t)c->argc; j++) {\n        char *opt = c->argv[j]->ptr;\n        int moreargs = (c->argc-1) - j;\n\n        if (!strcasecmp(opt,\"IDX\")) {\n            getidx = 1;\n        } else if (!strcasecmp(opt,\"LEN\")) {\n            getlen = 1;\n        } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n            withmatchlen = 1;\n        } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                != C_OK) goto cleanup;\n            if (minmatchlen < 0) minmatchlen = 0;\n            j++;\n        } else {\n            addReplyErrorObject(c,shared.syntaxerr);\n            goto cleanup;\n        }\n    }\n\n    /* Complain if the user passed ambiguous parameters. */\n    if (getlen && getidx) {\n        addReplyError(c,\n            \"If you want both the length and indexes, please just use IDX.\");\n        goto cleanup;\n    }\n\n    /* Detect string truncation or later overflows. */\n    if (sdslen(a) >= UINT32_MAX-1 || sdslen(b) >= UINT32_MAX-1) {\n        addReplyError(c, \"String too long for LCS\");\n        goto cleanup;\n    }\n\n    /* Compute the LCS using the vanilla dynamic programming technique of\n     * building a table of LCS(x,y) substrings. */\n    uint32_t alen = sdslen(a);\n    uint32_t blen = sdslen(b);\n\n    /* Setup an uint32_t array to store at LCS[i,j] the length of the\n     * LCS A0..i-1, B0..j-1. Note that we have a linear array here, so\n     * we index it as LCS[j+(blen+1)*i] */\n    #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n\n    /* Try to allocate the LCS table, and abort on overflow or insufficient memory. */\n    unsigned long long lcssize = (unsigned long long)(alen+1)*(blen+1); /* Can't overflow due to the size limits above. */\n    unsigned long long lcsalloc = lcssize * sizeof(uint32_t);\n    uint32_t *lcs = NULL;\n    if (lcsalloc < SIZE_MAX && lcsalloc / lcssize == sizeof(uint32_t)) {\n        if (lcsalloc > (size_t)server.proto_max_bulk_len) {\n            addReplyError(c, \"Insufficient memory, transient memory for LCS exceeds proto-max-bulk-len\");\n            goto cleanup;\n        }\n        lcs = ztrymalloc(lcsalloc);\n    }\n    if (!lcs) {\n        addReplyError(c, \"Insufficient memory, failed allocating transient memory for LCS\");\n        goto cleanup;\n    }\n\n    /* Start building the LCS table. */\n    for (uint32_t i = 0; i <= alen; i++) {\n        for (uint32_t j = 0; j <= blen; j++) {\n            if (i == 0 || j == 0) {\n                /* If one substring has length of zero, the\n                 * LCS length is zero. */\n                LCS(i,j) = 0;\n            } else if (a[i-1] == b[j-1]) {\n                /* The len LCS (and the LCS itself) of two\n                 * sequences with the same final character, is the\n                 * LCS of the two sequences without the last char\n                 * plus that last char. */\n                LCS(i,j) = LCS(i-1,j-1)+1;\n            } else {\n                /* If the last character is different, take the longest\n                 * between the LCS of the first string and the second\n                 * minus the last char, and the reverse. */\n                uint32_t lcs1 = LCS(i-1,j);\n                uint32_t lcs2 = LCS(i,j-1);\n                LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n            }\n        }\n    }\n\n    /* Store the actual LCS string in \"result\" if needed. We create\n     * it backward, but the length is already known, we store it into idx. */\n    uint32_t idx = LCS(alen,blen);\n    sds result = NULL;        /* Resulting LCS string. */\n    void *arraylenptr = NULL; /* Deferred length of the array for IDX. */\n    uint32_t arange_start = alen, /* alen signals that values are not set. */\n             arange_end = 0,\n             brange_start = 0,\n             brange_end = 0;\n\n    /* Do we need to compute the actual LCS string? Allocate it in that case. */\n    int computelcs = getidx || !getlen;\n    if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n\n    /* Start with a deferred array if we have to emit the ranges. */\n    uint32_t arraylen = 0;  /* Number of ranges emitted in the array. */\n    if (getidx) {\n        addReplyMapLen(c,2);\n        addReplyBulkCString(c,\"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n\n    i = alen, j = blen;\n    while (computelcs && i > 0 && j > 0) {\n        int emit_range = 0;\n        if (a[i-1] == b[j-1]) {\n            /* If there is a match, store the character and reduce\n             * the indexes to look for a new match. */\n            result[idx-1] = a[i-1];\n\n            /* Track the current range. */\n            if (arange_start == alen) {\n                arange_start = i-1;\n                arange_end = i-1;\n                brange_start = j-1;\n                brange_end = j-1;\n            } else {\n                /* Let's see if we can extend the range backward since\n                 * it is contiguous. */\n                if (arange_start == i && brange_start == j) {\n                    arange_start--;\n                    brange_start--;\n                } else {\n                    emit_range = 1;\n                }\n            }\n            /* Emit the range if we matched with the first byte of\n             * one of the two strings. We'll exit the loop ASAP. */\n            if (arange_start == 0 || brange_start == 0) emit_range = 1;\n            idx--; i--; j--;\n        } else {\n            /* Otherwise reduce i and j depending on the largest\n             * LCS between, to understand what direction we need to go. */\n            uint32_t lcs1 = LCS(i-1,j);\n            uint32_t lcs2 = LCS(i,j-1);\n            if (lcs1 > lcs2)\n                i--;\n            else\n                j--;\n            if (arange_start != alen) emit_range = 1;\n        }\n\n        /* Emit the current range if needed. */\n        uint32_t match_len = arange_end - arange_start + 1;\n        if (emit_range) {\n            if (minmatchlen == 0 || match_len >= minmatchlen) {\n                if (arraylenptr) {\n                    addReplyArrayLen(c,2+withmatchlen);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,arange_start);\n                    addReplyLongLong(c,arange_end);\n                    addReplyArrayLen(c,2);\n                    addReplyLongLong(c,brange_start);\n                    addReplyLongLong(c,brange_end);\n                    if (withmatchlen) addReplyLongLong(c,match_len);\n                    arraylen++;\n                }\n            }\n            arange_start = alen; /* Restart at the next match. */\n        }\n    }\n\n    /* Signal modified key, increment dirty, ... */\n\n    /* Reply depending on the given options. */\n    if (arraylenptr) {\n        addReplyBulkCString(c,\"len\");\n        addReplyLongLong(c,LCS(alen,blen));\n        setDeferredArrayLen(c,arraylenptr,arraylen);\n    } else if (getlen) {\n        addReplyLongLong(c,LCS(alen,blen));\n    } else {\n        addReplyBulkSds(c,result);\n        result = NULL;\n    }\n\n    /* Cleanup. */\n    sdsfree(result);\n    zfree(lcs);\n\ncleanup:\n    if (obja) decrRefCount(obja);\n    if (objb) decrRefCount(objb);\n    return;\n}\n\n", "start_server {tags {\"string\"}} {\n    test {SET and GET an item} {\n        r set x foobar\n        r get x\n    } {foobar}\n\n    test {SET and GET an empty item} {\n        r set x {}\n        r get x\n    } {}\n\n    test {Very big payload in GET/SET} {\n        set buf [string repeat \"abcd\" 1000000]\n        r set foo $buf\n        r get foo\n    } [string repeat \"abcd\" 1000000]\n\n    tags {\"slow\"} {\n        test {Very big payload random access} {\n            set err {}\n            array set payload {}\n            for {set j 0} {$j < 100} {incr j} {\n                set size [expr 1+[randomInt 100000]]\n                set buf [string repeat \"pl-$j\" $size]\n                set payload($j) $buf\n                r set bigpayload_$j $buf\n            }\n            for {set j 0} {$j < 1000} {incr j} {\n                set index [randomInt 100]\n                set buf [r get bigpayload_$index]\n                if {$buf != $payload($index)} {\n                    set err \"Values differ: I set '$payload($index)' but I read back '$buf'\"\n                    break\n                }\n            }\n            unset payload\n            set _ $err\n        } {}\n\n        test {SET 10000 numeric keys and access all them in reverse order} {\n            r flushdb\n            set err {}\n            for {set x 0} {$x < 10000} {incr x} {\n                r set $x $x\n            }\n            set sum 0\n            for {set x 9999} {$x >= 0} {incr x -1} {\n                set val [r get $x]\n                if {$val ne $x} {\n                    set err \"Element at position $x is $val instead of $x\"\n                    break\n                }\n            }\n            set _ $err\n        } {}\n\n        test {DBSIZE should be 10000 now} {\n            r dbsize\n        } {10000}\n    }\n\n    test \"SETNX target key missing\" {\n        r del novar\n        assert_equal 1 [r setnx novar foobared]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX target key exists\" {\n        r set novar foobared\n        assert_equal 0 [r setnx novar blabla]\n        assert_equal \"foobared\" [r get novar]\n    }\n\n    test \"SETNX against not-expired volatile key\" {\n        r set x 10\n        r expire x 10000\n        assert_equal 0 [r setnx x 20]\n        assert_equal 10 [r get x]\n    }\n\n    test \"SETNX against expired volatile key\" {\n        # Make it very unlikely for the key this test uses to be expired by the\n        # active expiry cycle. This is tightly coupled to the implementation of\n        # active expiry and dbAdd() but currently the only way to test that\n        # SETNX expires a key when it should have been.\n        for {set x 0} {$x < 9999} {incr x} {\n            r setex key-$x 3600 value\n        }\n\n        # This will be one of 10000 expiring keys. A cycle is executed every\n        # 100ms, sampling 10 keys for being expired or not.  This key will be\n        # expired for at most 1s when we wait 2s, resulting in a total sample\n        # of 100 keys. The probability of the success of this test being a\n        # false positive is therefore approx. 1%.\n        r set x 10\n        r expire x 1\n\n        # Wait for the key to expire\n        after 2000\n\n        assert_equal 1 [r setnx x 20]\n        assert_equal 20 [r get x]\n    }\n\n    test \"GETEX EX option\" {\n        r del foo\n        r set foo bar\n        r getex foo ex 10\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PX option\" {\n        r del foo\n        r set foo bar\n        r getex foo px 10000\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX EXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"GETEX PXAT option\" {\n        r del foo\n        r set foo bar\n        r getex foo pxat [expr [clock milliseconds] + 10000]\n        assert_range [r pttl foo] 5000 10000\n    }\n\n    test \"GETEX PERSIST option\" {\n        r del foo\n        r set foo bar ex 10\n        assert_range [r ttl foo] 5 10\n        r getex foo persist\n        assert_equal -1 [r ttl foo]\n    }\n\n    test \"GETEX no option\" {\n        r del foo\n        r set foo bar\n        r getex foo\n        assert_equal bar [r getex foo]\n    }\n\n    test \"GETEX syntax errors\" {\n        set ex {}\n        catch {r getex foo non-existent-option} ex\n        set ex\n    } {*syntax*}\n\n    test \"GETEX no arguments\" {\n         set ex {}\n         catch {r getex} ex\n         set ex\n     } {*wrong number of arguments for 'getex' command}\n\n    test \"GETDEL command\" {\n        r del foo\n        r set foo bar\n        assert_equal bar [r getdel foo ]\n        assert_equal {} [r getdel foo ]\n    }\n\n    test {GETDEL propagate as DEL command to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getdel foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {GETEX without argument does not propagate to replica} {\n        set repl [attach_to_replication_stream]\n        r set foo bar\n        r getex foo\n        r del foo\n        assert_replication_stream $repl {\n            {select *}\n            {set foo bar}\n            {del foo}\n        }\n        close_replication_stream $repl\n    } {} {needs:repl}\n\n    test {MGET} {\n        r flushdb\n        r set foo{t} BAR\n        r set bar{t} FOO\n        r mget foo{t} bar{t}\n    } {BAR FOO}\n\n    test {MGET against non existing key} {\n        r mget foo{t} baazz{t} bar{t}\n    } {BAR {} FOO}\n\n    test {MGET against non-string key} {\n        r sadd myset{t} ciao\n        r sadd myset{t} bau\n        r mget foo{t} baazz{t} bar{t} myset{t}\n    } {BAR {} FOO {}}\n\n    test {GETSET (set new value)} {\n        r del foo\n        list [r getset foo xyz] [r get foo]\n    } {{} xyz}\n\n    test {GETSET (replace old value)} {\n        r set foo bar\n        list [r getset foo xyz] [r get foo]\n    } {bar xyz}\n\n    test {MSET base case} {\n        r mset x{t} 10 y{t} \"foo bar\" z{t} \"x x x x x x x\\n\\n\\r\\n\"\n        r mget x{t} y{t} z{t}\n    } [list 10 {foo bar} \"x x x x x x x\\n\\n\\r\\n\"]\n\n    test {MSET/MSETNX wrong number of args} {\n        assert_error {*wrong number of arguments for 'mset' command} {r mset x{t} 10 y{t} \"foo bar\" z{t}}\n        assert_error {*wrong number of arguments for 'msetnx' command} {r msetnx x{t} 20 y{t} \"foo bar\" z{t}}\n    }\n\n    test {MSETNX with already existent key} {\n        list [r msetnx x1{t} xxx y2{t} yyy x{t} 20] [r exists x1{t}] [r exists y2{t}]\n    } {0 0 0}\n\n    test {MSETNX with not existing keys} {\n        list [r msetnx x1{t} xxx y2{t} yyy] [r get x1{t}] [r get y2{t}]\n    } {1 xxx yyy}\n\n    test {MSETNX with not existing keys - same key twice} {\n        r del x1{t}\n        list [r msetnx x1{t} xxx x1{t} yyy] [r get x1{t}]\n    } {1 yyy}\n\n    test {MSETNX with already existing keys - same key twice} {\n        list [r msetnx x1{t} xxx x1{t} zzz] [r get x1{t}]\n    } {0 yyy}\n\n    test \"STRLEN against non-existing key\" {\n        assert_equal 0 [r strlen notakey]\n    }\n\n    test \"STRLEN against integer-encoded value\" {\n        r set myinteger -555\n        assert_equal 4 [r strlen myinteger]\n    }\n\n    test \"STRLEN against plain string\" {\n        r set mystring \"foozzz0123456789 baz\"\n        assert_equal 20 [r strlen mystring]\n    }\n\n    test \"SETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r setbit mykey 1 1]\n        assert_equal [binary format B* 01000000] [r get mykey]\n    }\n\n    test \"SETBIT against string-encoded key\" {\n        # Ascii \"@\" is integer 64 = 01 00 00 00\n        r set mykey \"@\"\n\n        assert_equal 0 [r setbit mykey 2 1]\n        assert_equal [binary format B* 01100000] [r get mykey]\n        assert_equal 1 [r setbit mykey 1 0]\n        assert_equal [binary format B* 00100000] [r get mykey]\n    }\n\n    test \"SETBIT against integer-encoded key\" {\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        r set mykey 1\n        assert_encoding int mykey\n\n        assert_equal 0 [r setbit mykey 6 1]\n        assert_equal [binary format B* 00110011] [r get mykey]\n        assert_equal 1 [r setbit mykey 2 0]\n        assert_equal [binary format B* 00010011] [r get mykey]\n    }\n\n    test \"SETBIT against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setbit mykey 0 1}\n    }\n\n    test \"SETBIT with out of range bit offset\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey [expr 4*1024*1024*1024] 1}\n        assert_error \"*out of range*\" {r setbit mykey -1 1}\n    }\n\n    test \"SETBIT with non-bit argument\" {\n        r del mykey\n        assert_error \"*out of range*\" {r setbit mykey 0 -1}\n        assert_error \"*out of range*\" {r setbit mykey 0  2}\n        assert_error \"*out of range*\" {r setbit mykey 0 10}\n        assert_error \"*out of range*\" {r setbit mykey 0 20}\n    }\n\n    test \"SETBIT fuzzing\" {\n        set str \"\"\n        set len [expr 256*8]\n        r del mykey\n\n        for {set i 0} {$i < 2000} {incr i} {\n            set bitnum [randomInt $len]\n            set bitval [randomInt 2]\n            set fmt [format \"%%-%ds%%d%%-s\" $bitnum]\n            set head [string range $str 0 $bitnum-1]\n            set tail [string range $str $bitnum+1 end]\n            set str [string map {\" \" 0} [format $fmt $head $bitval $tail]]\n\n            r setbit mykey $bitnum $bitval\n            assert_equal [binary format B* $str] [r get mykey]\n        }\n    }\n\n    test \"GETBIT against non-existing key\" {\n        r del mykey\n        assert_equal 0 [r getbit mykey 0]\n    }\n\n    test \"GETBIT against string-encoded key\" {\n        # Single byte with 2nd and 3rd bit set\n        r set mykey \"`\"\n\n        # In-range\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 1 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 0 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"GETBIT against integer-encoded key\" {\n        r set mykey 1\n        assert_encoding int mykey\n\n        # Ascii \"1\" is integer 49 = 00 11 00 01\n        assert_equal 0 [r getbit mykey 0]\n        assert_equal 0 [r getbit mykey 1]\n        assert_equal 1 [r getbit mykey 2]\n        assert_equal 1 [r getbit mykey 3]\n\n        # Out-range\n        assert_equal 0 [r getbit mykey 8]\n        assert_equal 0 [r getbit mykey 100]\n        assert_equal 0 [r getbit mykey 10000]\n    }\n\n    test \"SETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal 3 [r setrange mykey 0 foo]\n        assert_equal \"foo\" [r get mykey]\n\n        r del mykey\n        assert_equal 0 [r setrange mykey 0 \"\"]\n        assert_equal 0 [r exists mykey]\n\n        r del mykey\n        assert_equal 4 [r setrange mykey 1 foo]\n        assert_equal \"\\000foo\" [r get mykey]\n    }\n\n    test \"SETRANGE against string-encoded key\" {\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 b]\n        assert_equal \"boo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 0 \"\"]\n        assert_equal \"foo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 3 [r setrange mykey 1 b]\n        assert_equal \"fbo\" [r get mykey]\n\n        r set mykey \"foo\"\n        assert_equal 7 [r setrange mykey 4 bar]\n        assert_equal \"foo\\000bar\" [r get mykey]\n    }\n\n    test \"SETRANGE against integer-encoded key\" {\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 2]\n        assert_encoding raw mykey\n        assert_equal 2234 [r get mykey]\n\n        # Shouldn't change encoding when nothing is set\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 0 \"\"]\n        assert_encoding int mykey\n        assert_equal 1234 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 4 [r setrange mykey 1 3]\n        assert_encoding raw mykey\n        assert_equal 1334 [r get mykey]\n\n        r set mykey 1234\n        assert_encoding int mykey\n        assert_equal 6 [r setrange mykey 5 2]\n        assert_encoding raw mykey\n        assert_equal \"1234\\0002\" [r get mykey]\n    }\n\n    test \"SETRANGE against key with wrong type\" {\n        r del mykey\n        r lpush mykey \"foo\"\n        assert_error \"WRONGTYPE*\" {r setrange mykey 0 bar}\n    }\n\n    test \"SETRANGE with out of range offset\" {\n        r del mykey\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n\n        r set mykey \"hello\"\n        assert_error \"*out of range*\" {r setrange mykey -1 world}\n        assert_error \"*maximum allowed size*\" {r setrange mykey [expr 512*1024*1024-4] world}\n    }\n\n    test \"GETRANGE against non-existing key\" {\n        r del mykey\n        assert_equal \"\" [r getrange mykey 0 -1]\n    }\n\n    test \"GETRANGE against string value\" {\n        r set mykey \"Hello World\"\n        assert_equal \"Hell\" [r getrange mykey 0 3]\n        assert_equal \"Hello World\" [r getrange mykey 0 -1]\n        assert_equal \"orld\" [r getrange mykey -4 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \" World\" [r getrange mykey 5 5000]\n        assert_equal \"Hello World\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE against integer-encoded value\" {\n        r set mykey 1234\n        assert_equal \"123\" [r getrange mykey 0 2]\n        assert_equal \"1234\" [r getrange mykey 0 -1]\n        assert_equal \"234\" [r getrange mykey -3 -1]\n        assert_equal \"\" [r getrange mykey 5 3]\n        assert_equal \"4\" [r getrange mykey 3 5000]\n        assert_equal \"1234\" [r getrange mykey -5000 10000]\n    }\n\n    test \"GETRANGE fuzzing\" {\n        for {set i 0} {$i < 1000} {incr i} {\n            r set bin [set bin [randstring 0 1024 binary]]\n            set _start [set start [randomInt 1500]]\n            set _end [set end [randomInt 1500]]\n            if {$_start < 0} {set _start \"end-[abs($_start)-1]\"}\n            if {$_end < 0} {set _end \"end-[abs($_end)-1]\"}\n            assert_equal [string range $bin $_start $_end] [r getrange bin $start $end]\n        }\n    }\n\n    test \"Coverage: SUBSTR\" {\n        r set key abcde\n        assert_equal \"a\" [r substr key 0 0]\n        assert_equal \"abcd\" [r substr key 0 3]\n        assert_equal \"bcde\" [r substr key -4 -1]\n    }\n    \nif {[string match {*jemalloc*} [s mem_allocator]]} {\n    test {trim on SET with big value} {\n        # set a big value to trigger increasing the query buf\n        r set key [string repeat A 100000] \n        # set a smaller value but > PROTO_MBULK_BIG_ARG (32*1024) Redis will try to save the query buf itself on the DB.\n        r set key [string repeat A 33000]\n        # asset the value was trimmed\n        assert {[r memory usage key] < 42000}; # 42K to count for Jemalloc's additional memory overhead. \n    }\n} ;# if jemalloc\n\n    test {Extended SET can detect syntax errors} {\n        set e {}\n        catch {r set foo bar non-existing-option} e\n        set e\n    } {*syntax*}\n\n    test {Extended SET NX option} {\n        r del foo\n        set v1 [r set foo 1 nx]\n        set v2 [r set foo 2 nx]\n        list $v1 $v2 [r get foo]\n    } {OK {} 1}\n\n    test {Extended SET XX option} {\n        r del foo\n        set v1 [r set foo 1 xx]\n        r set foo bar\n        set v2 [r set foo 2 xx]\n        list $v1 $v2 [r get foo]\n    } {{} OK 2}\n\n    test {Extended SET GET option} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo bar2 GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar2}\n\n    test {Extended SET GET option with no previous value} {\n        r del foo\n        set old_value [r set foo bar GET]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with XX} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar baz}\n\n    test {Extended SET GET option with XX and no previous value} {\n        r del foo\n        set old_value [r set foo bar GET XX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} {}}\n\n    test {Extended SET GET option with NX} {\n        r del foo\n        set old_value [r set foo bar GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {{} bar}\n\n    test {Extended SET GET option with NX and previous value} {\n        r del foo\n        r set foo bar\n        set old_value [r set foo baz GET NX]\n        set new_value [r get foo]\n        list $old_value $new_value\n    } {bar bar}\n\n    test {Extended SET GET with incorrect type should result in wrong type error} {\n      r del foo\n      r rpush foo waffle\n      catch {r set foo bar GET} err1\n      assert_equal \"waffle\" [r rpop foo]\n      set err1\n    } {*WRONGTYPE*}\n\n    test {Extended SET EX option} {\n        r del foo\n        r set foo bar ex 10\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {Extended SET PX option} {\n        r del foo\n        r set foo bar px 10000\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test \"Extended SET EXAT option\" {\n        r del foo\n        r set foo bar exat [expr [clock seconds] + 10]\n        assert_range [r ttl foo] 5 10\n    }\n\n    test \"Extended SET PXAT option\" {\n        r del foo\n        r set foo bar pxat [expr [clock milliseconds] + 10000]\n        assert_range [r ttl foo] 5 10\n    }\n    test {Extended SET using multiple options at once} {\n        r set foo val\n        assert {[r set foo bar xx px 10000] eq {OK}}\n        set ttl [r ttl foo]\n        assert {$ttl <= 10 && $ttl > 5}\n    }\n\n    test {GETRANGE with huge ranges, Github issue #1844} {\n        r set foo bar\n        r getrange foo 0 4294967297\n    } {bar}\n\n    set rna1 {CACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTTCGTCCGGGTGTG}\n    set rna2 {ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n    set rnalcs {ACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATCATCAGCACATCTAGGTTT}\n\n    test {LCS basic} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t}\n    } $rnalcs\n\n    test {LCS len} {\n        r set virus1{t} $rna1\n        r set virus2{t} $rna2\n        r LCS virus1{t} virus2{t} LEN\n    } [string length $rnalcs]\n\n    test {LCS indexes} {\n        dict get [r LCS virus1{t} virus2{t} IDX] matches\n    } {{{238 238} {239 239}} {{236 236} {238 238}} {{229 230} {236 237}} {{224 224} {235 235}} {{1 222} {13 234}}}\n\n    test {LCS indexes with match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN] matches\n    } {{{238 238} {239 239} 1} {{236 236} {238 238} 1} {{229 230} {236 237} 2} {{224 224} {235 235} 1} {{1 222} {13 234} 222}}\n\n    test {LCS indexes with match len and minimum match len} {\n        dict get [r LCS virus1{t} virus2{t} IDX WITHMATCHLEN MINMATCHLEN 5] matches\n    } {{{1 222} {13 234} 222}}\n\n    test {SETRANGE with huge offset} {\n        foreach value {9223372036854775807 2147483647} {\n            catch {[r setrange K $value A]} res\n            # expecting a different error on 32 and 64 bit systems\n            if {![string match \"*string exceeds maximum allowed size*\" $res] && ![string match \"*out of range*\" $res]} {\n                assert_equal $res \"expecting an error\"\n           }\n        }\n    }\n}\n"], "filenames": ["src/t_string.c", "tests/unit/type/string.tcl"], "buggy_code_start_loc": [562, 236], "buggy_code_end_loc": [584, 236], "fixing_code_start_loc": [561, 237], "fixing_code_end_loc": [582, 246], "type": "CWE-77", "message": "Redis is an in-memory database that persists on disk. Starting in version 7.0.8 and prior to version 7.0.10, authenticated users can use the MSETNX command to trigger a runtime assertion and termination of the Redis server process. The problem is fixed in Redis version 7.0.10.", "other": {"cve": {"id": "CVE-2023-28425", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-20T20:15:52.787", "lastModified": "2023-04-13T17:15:19.497", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Redis is an in-memory database that persists on disk. Starting in version 7.0.8 and prior to version 7.0.10, authenticated users can use the MSETNX command to trigger a runtime assertion and termination of the Redis server process. The problem is fixed in Redis version 7.0.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.8", "versionEndExcluding": "7.0.10", "matchCriteriaId": "A3A3D6B1-C1A2-420D-9AD7-F9F6F04E6CFD"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/48e0d4788434833b47892fe9f3d91be7687f25c9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/releases/tag/7.0.10", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-mvmm-4vq6-vw8c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230413-0005/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/redis/redis/commit/48e0d4788434833b47892fe9f3d91be7687f25c9"}}