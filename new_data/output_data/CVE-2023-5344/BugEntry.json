{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * message.c: functions for displaying messages on the command line\n */\n\n#define MESSAGE_FILE\t\t// don't include prototype for smsg()\n\n#include \"vim.h\"\n\nstatic void add_msg_hist(char_u *s, int len, int attr);\nstatic void hit_return_msg(void);\nstatic void msg_home_replace_attr(char_u *fname, int attr);\nstatic void msg_puts_attr_len(char *str, int maxlen, int attr);\nstatic void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);\nstatic void msg_scroll_up(void);\nstatic void inc_msg_scrolled(void);\nstatic void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish);\nstatic void t_puts(int *t_col, char_u *t_s, char_u *s, int attr);\nstatic void msg_puts_printf(char_u *str, int maxlen);\nstatic int do_more_prompt(int typed_char);\nstatic void msg_screen_putchar(int c, int attr);\nstatic void msg_moremsg(int full);\nstatic int  msg_check_screen(void);\nstatic void redir_write(char_u *s, int maxlen);\n#ifdef FEAT_CON_DIALOG\nstatic char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);\nstatic int\tconfirm_msg_used = FALSE;\t// displaying confirm_msg\nstatic char_u\t*confirm_msg = NULL;\t\t// \":confirm\" message\nstatic char_u\t*confirm_msg_tail;\t\t// tail of confirm_msg\nstatic void display_confirm_msg(void);\n#endif\n#ifdef FEAT_EVAL\nstatic int emsg_to_channel_log = FALSE;\n#endif\n\nstruct msg_hist\n{\n    struct msg_hist\t*next;\n    char_u\t\t*msg;\n    int\t\t\tattr;\n};\n\nstatic struct msg_hist *first_msg_hist = NULL;\nstatic struct msg_hist *last_msg_hist = NULL;\nstatic int msg_hist_len = 0;\n\nstatic FILE *verbose_fd = NULL;\nstatic int  verbose_did_open = FALSE;\n\n/*\n * When writing messages to the screen, there are many different situations.\n * A number of variables is used to remember the current state:\n * msg_didany\t    TRUE when messages were written since the last time the\n *\t\t    user reacted to a prompt.\n *\t\t    Reset: After hitting a key for the hit-return prompt,\n *\t\t    hitting <CR> for the command line or input().\n *\t\t    Set: When any message is written to the screen.\n * msg_didout\t    TRUE when something was written to the current line.\n *\t\t    Reset: When advancing to the next line, when the current\n *\t\t    text can be overwritten.\n *\t\t    Set: When any message is written to the screen.\n * msg_nowait\t    No extra delay for the last drawn message.\n *\t\t    Used in normal_cmd() before the mode message is drawn.\n * emsg_on_display  There was an error message recently.  Indicates that there\n *\t\t    should be a delay before redrawing.\n * msg_scroll\t    The next message should not overwrite the current one.\n * msg_scrolled\t    How many lines the screen has been scrolled (because of\n *\t\t    messages).  Used in update_screen() to scroll the screen\n *\t\t    back.  Incremented each time the screen scrolls a line.\n * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()\n *\t\t    writes something without scrolling should not make\n *\t\t    need_wait_return to be set.  This is a hack to make \":ts\"\n *\t\t    work without an extra prompt.\n * lines_left\t    Number of lines available for messages before the\n *\t\t    more-prompt is to be given.  -1 when not set.\n * need_wait_return TRUE when the hit-return prompt is needed.\n *\t\t    Reset: After giving the hit-return prompt, when the user\n *\t\t    has answered some other prompt.\n *\t\t    Set: When the ruler or typeahead display is overwritten,\n *\t\t    scrolling the screen for some message.\n * keep_msg\t    Message to be displayed after redrawing the screen, in\n *\t\t    main_loop().\n *\t\t    This is an allocated string or NULL when not used.\n */\n\n/*\n * msg(s) - displays the string 's' on the status line\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n * return TRUE if wait_return() not called\n */\n    int\nmsg(char *s)\n{\n    return msg_attr_keep(s, 0, FALSE);\n}\n\n/*\n * Like msg() but keep it silent when 'verbosefile' is set.\n */\n    int\nverb_msg(char *s)\n{\n    int\t\tn;\n\n    verbose_enter();\n    n = msg_attr_keep(s, 0, FALSE);\n    verbose_leave();\n\n    return n;\n}\n\n    int\nmsg_attr(char *s, int attr)\n{\n    return msg_attr_keep(s, attr, FALSE);\n}\n\n    int\nmsg_attr_keep(\n    char\t*s,\n    int\t\tattr,\n    int\t\tkeep)\t    // TRUE: set keep_msg if it doesn't scroll\n{\n    static int\tentered = 0;\n    int\t\tretval;\n    char_u\t*buf = NULL;\n\n    // Skip messages not matching \":filter pattern\".\n    // Don't filter when there is an error.\n    if (!emsg_on_display && message_filtered((char_u *)s))\n\treturn TRUE;\n\n#ifdef FEAT_EVAL\n    if (attr == 0)\n\tset_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);\n#endif\n\n    /*\n     * It is possible that displaying a messages causes a problem (e.g.,\n     * when redrawing the window), which causes another message, etc..\tTo\n     * break this loop, limit the recursiveness to 3 levels.\n     */\n    if (entered >= 3)\n\treturn TRUE;\n    ++entered;\n\n    // Add message to history (unless it's a repeated kept message or a\n    // truncated message)\n    if ((char_u *)s != keep_msg\n\t    || (*s != '<'\n\t\t&& last_msg_hist != NULL\n\t\t&& last_msg_hist->msg != NULL\n\t\t&& STRCMP(s, last_msg_hist->msg)))\n\tadd_msg_hist((char_u *)s, -1, attr);\n\n#ifdef FEAT_EVAL\n    if (emsg_to_channel_log)\n\t// Write message in the channel log.\n\tch_log(NULL, \"ERROR: %s\", s);\n#endif\n\n    // Truncate the message if needed.\n    msg_start();\n    buf = msg_strtrunc((char_u *)s, FALSE);\n    if (buf != NULL)\n\ts = (char *)buf;\n\n    msg_outtrans_attr((char_u *)s, attr);\n    msg_clr_eos();\n    retval = msg_end();\n\n    if (keep && retval && vim_strsize((char_u *)s)\n\t\t\t    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)\n\tset_keep_msg((char_u *)s, 0);\n\n    need_fileinfo = FALSE;\n\n    vim_free(buf);\n    --entered;\n    return retval;\n}\n\n/*\n * Truncate a string such that it can be printed without causing a scroll.\n * Returns an allocated string or NULL when no truncating is done.\n */\n    char_u *\nmsg_strtrunc(\n    char_u\t*s,\n    int\t\tforce)\t    // always truncate\n{\n    char_u\t*buf = NULL;\n    int\t\tlen;\n    int\t\troom;\n\n    // May truncate message to avoid a hit-return prompt\n    if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)\n\t\t\t       && !exmode_active && msg_silent == 0) || force)\n    {\n\tlen = vim_strsize(s);\n\tif (msg_scrolled != 0\n#ifdef HAS_MESSAGE_WINDOW\n\t\t|| in_echowindow\n#endif\n\t\t)\n\t    // Use all the columns.\n\t    room = (int)(Rows - msg_row) * Columns - 1;\n\telse\n\t    // Use up to 'showcmd' column.\n\t    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\tif (len > room && room > 0)\n\t{\n\t    if (enc_utf8)\n\t\t// may have up to 18 bytes per cell (6 per char, up to two\n\t\t// composing chars)\n\t\tlen = (room + 2) * 18;\n\t    else if (enc_dbcs == DBCS_JPNU)\n\t\t// may have up to 2 bytes per cell for euc-jp\n\t\tlen = (room + 2) * 2;\n\t    else\n\t\tlen = room + 2;\n\t    buf = alloc(len);\n\t    if (buf != NULL)\n\t\ttrunc_string(s, buf, room, len);\n\t}\n    }\n    return buf;\n}\n\n/*\n * Truncate a string \"s\" to \"buf\" with cell width \"room\".\n * \"s\" and \"buf\" may be equal.\n */\n    void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}\n\n/*\n * Automatic prototype generation does not understand this function.\n * Note: Caller of smsg() and smsg_attr() must check the resulting string is\n * shorter than IOSIZE!!!\n */\n#ifndef PROTO\n\nint vim_snprintf(char *str, size_t str_m, const char *fmt, ...);\n\n    int\nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n\n    va_list arglist;\n\n    va_start(arglist, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n    va_end(arglist);\n    return msg((char *)IObuff);\n}\n\n    int\nsmsg_attr(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr((char *)s, attr);\n    }\n\n    va_list arglist;\n\n    va_start(arglist, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n    va_end(arglist);\n    return msg_attr((char *)IObuff, attr);\n}\n\n    int\nsmsg_attr_keep(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr_keep((char *)s, attr, TRUE);\n    }\n\n    va_list arglist;\n\n    va_start(arglist, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n    va_end(arglist);\n    return msg_attr_keep((char *)IObuff, attr, TRUE);\n}\n\n#endif\n\n/*\n * Remember the last sourcing name/lnum used in an error message, so that it\n * isn't printed each time when it didn't change.\n */\nstatic int\tlast_sourcing_lnum = 0;\nstatic char_u   *last_sourcing_name = NULL;\n\n/*\n * Reset the last used sourcing name/lnum.  Makes sure it is displayed again\n * for the next error message;\n */\n    void\nreset_last_sourcing(void)\n{\n    VIM_CLEAR(last_sourcing_name);\n    last_sourcing_lnum = 0;\n}\n\n/*\n * Return TRUE if \"SOURCING_NAME\" differs from \"last_sourcing_name\".\n */\n    static int\nother_sourcing_name(void)\n{\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL)\n    {\n\tif (last_sourcing_name != NULL)\n\t    return STRCMP(SOURCING_NAME, last_sourcing_name) != 0;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Get the message about the source, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_source(void)\n{\n    char_u\t*Buf, *p;\n\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL && other_sourcing_name())\n    {\n\tchar_u\t    *sname = estack_sfile(ESTACK_NONE);\n\tchar_u\t    *tofree = sname;\n\n\tif (sname == NULL)\n\t    sname = SOURCING_NAME;\n\n#ifdef FEAT_EVAL\n\tif (estack_compiling)\n\t    p = (char_u *)_(\"Error detected while compiling %s:\");\n\telse\n#endif\n\t    p = (char_u *)_(\"Error detected while processing %s:\");\n\tBuf = alloc(STRLEN(sname) + STRLEN(p));\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, sname);\n\tvim_free(tofree);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Get the message about the source lnum, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_lnum(void)\n{\n    char_u\t*Buf, *p;\n\n    // lnum is 0 when executing a command from the command line\n    // argument, we don't want a line number then\n    if (SOURCING_NAME != NULL\n\t    && (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)\n\t    && SOURCING_LNUM != 0)\n    {\n\tp = (char_u *)_(\"line %4ld:\");\n\tBuf = alloc(STRLEN(p) + 20);\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, (long)SOURCING_LNUM);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Display name and line number for the source of an error.\n * Remember the file name and line number, so that for the next error the info\n * is only displayed if it changed.\n */\n    void\nmsg_source(int attr)\n{\n    char_u\t*p;\n    static int\trecursive = FALSE;\n\n    // Bail out if something called here causes an error.\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n\n    ++no_wait_return;\n    p = get_emsg_source();\n    if (p != NULL)\n    {\n\tmsg_scroll = TRUE;  // this will take more than one line\n\tmsg_attr((char *)p, attr);\n\tvim_free(p);\n    }\n    p = get_emsg_lnum();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, HL_ATTR(HLF_N));\n\tvim_free(p);\n\tlast_sourcing_lnum = SOURCING_LNUM;  // only once for each line\n    }\n\n    // remember the last sourcing name printed, also when it's empty\n    if (SOURCING_NAME == NULL || other_sourcing_name())\n    {\n\tVIM_CLEAR(last_sourcing_name);\n\tif (SOURCING_NAME != NULL)\n\t    last_sourcing_name = vim_strsave(SOURCING_NAME);\n    }\n    --no_wait_return;\n\n    recursive = FALSE;\n}\n\n/*\n * Return TRUE if not giving error messages right now:\n * If \"emsg_off\" is set: no error messages at the moment.\n * If \"msg\" is in 'debug': do error message but without side effects.\n * If \"emsg_skip\" is set: never do error messages.\n */\n    static int\nemsg_not_now(void)\n{\n    if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL\n\t\t\t\t\t  && vim_strchr(p_debug, 't') == NULL)\n#ifdef FEAT_EVAL\n\t    || emsg_skip > 0\n#endif\n\t    )\n\treturn TRUE;\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic garray_T ignore_error_list = GA_EMPTY;\n\n    void\nignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_copy_string(&ignore_error_list, error);\n}\n\n    static int\nignore_error(const char *msg)\n{\n    int i;\n\n    for (i = 0; i < ignore_error_list.ga_len; ++i)\n\tif (strstr(msg,\n\t\t  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n#if !defined(HAVE_STRERROR) || defined(PROTO)\n/*\n * Replacement for perror() that behaves more or less like emsg() was called.\n * v:errmsg will be set and called_emsg will be incremented.\n */\n    void\ndo_perror(char *msg)\n{\n    perror(msg);\n    ++emsg_silent;\n    emsg(msg);\n    --emsg_silent;\n}\n#endif\n\n/*\n * emsg_core() - display an error message\n *\n * Rings the bell, if appropriate, and calls message() to do the real work\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n *\n * Return TRUE if wait_return() not called.\n * Note: caller must check 'emsg_not_now()' before calling this.\n */\n    static int\nemsg_core(const char *s)\n{\n    int\t\tattr;\n    char_u\t*p;\n    int\t\tr;\n#ifdef FEAT_EVAL\n    int\t\tignore = FALSE;\n    int\t\tsevere;\n#endif\n\n#ifdef FEAT_EVAL\n    // When testing some errors are turned into a normal message.\n    if (ignore_error(s))\n\t// don't call msg() if it results in a dialog\n\treturn msg_use_printf() ? FALSE : msg((char *)s);\n#endif\n\n    ++called_emsg;\n\n#ifdef FEAT_EVAL\n    // If \"emsg_severe\" is TRUE: When an error exception is to be thrown,\n    // prefer this message over previous messages for the same command.\n    severe = emsg_severe;\n    emsg_severe = FALSE;\n#endif\n\n    if (!emsg_off || vim_strchr(p_debug, 't') != NULL)\n    {\n#ifdef FEAT_EVAL\n\t/*\n\t * Cause a throw of an error exception if appropriate.  Don't display\n\t * the error message in this case.  (If no matching catch clause will\n\t * be found, the message will be displayed later on.)  \"ignore\" is set\n\t * when the message should be ignored completely (used for the\n\t * interrupt message).\n\t */\n\tif (cause_errthrow((char_u *)s, severe, &ignore) == TRUE)\n\t{\n\t    if (!ignore)\n\t\t++did_emsg;\n\t    return TRUE;\n\t}\n\n\tif (in_assert_fails && emsg_assert_fails_msg == NULL)\n\t{\n\t    emsg_assert_fails_msg = vim_strsave((char_u *)s);\n\t    emsg_assert_fails_lnum = SOURCING_LNUM;\n\t    vim_free(emsg_assert_fails_context);\n\t    emsg_assert_fails_context = vim_strsave(\n\t\t\t SOURCING_NAME == NULL ? (char_u *)\"\" : SOURCING_NAME);\n\t}\n\n\t// set \"v:errmsg\", also when using \":silent! cmd\"\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n#endif\n\n\t/*\n\t * When using \":silent! cmd\" ignore error messages.\n\t * But do write it to the redirection file.\n\t */\n\tif (emsg_silent != 0)\n\t{\n#ifdef FEAT_EVAL\n\t    ++did_emsg_silent;\n#endif\n\t    if (emsg_noredir == 0)\n\t    {\n\t\tmsg_start();\n\t\tp = get_emsg_source();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tp = get_emsg_lnum();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tredir_write((char_u *)s, -1);\n\t    }\n#ifdef FEAT_EVAL\n\t    // Only increment did_emsg_def when :silent! wasn't used inside the\n\t    // :def function.\n\t    if (emsg_silent == emsg_silent_def)\n\t\t++did_emsg_def;\n#endif\n#ifdef FEAT_EVAL\n\t    ch_log(NULL, \"ERROR silent: %s\", s);\n#endif\n\t    return TRUE;\n\t}\n\n\tex_exitval = 1;\n\n\t// Reset msg_silent, an error causes messages to be switched back on.\n\tmsg_silent = 0;\n\tcmd_silent = FALSE;\n\n\tif (global_busy)\t\t// break :global command\n\t    ++global_busy;\n\n\tif (p_eb)\n\t    beep_flush();\t\t// also includes flush_buffers()\n\telse\n\t    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers\n\t++did_emsg;\t\t\t   // flag for DoOneCmd()\n#ifdef FEAT_EVAL\n\t++uncaught_emsg;\n#endif\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (!in_echowindow)\n#endif\n\temsg_on_display = TRUE;\t    // remember there is an error message\n\n    attr = HL_ATTR(HLF_E);\t    // set highlight mode for error messages\n    if (msg_scrolled != 0)\n\tneed_wait_return = TRUE;    // needed in case emsg() is called after\n\t\t\t\t    // wait_return() has reset need_wait_return\n\t\t\t\t    // and a redraw is expected because\n\t\t\t\t    // msg_scrolled is non-zero\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = TRUE;\n#endif\n    /*\n     * Display name and line number for the source of the error.\n     */\n    msg_scroll = TRUE;\n    msg_source(attr);\n\n    /*\n     * Display the error message itself.\n     */\n    msg_nowait = FALSE;\t\t\t// wait for this msg\n    r = msg_attr((char *)s, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = FALSE;\n#endif\n    return r;\n}\n\n/*\n * Print error message \"s\".  Should already be translated.\n * Return TRUE if wait_return() not called.\n */\n    int\nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (emsg_not_now())\n\treturn TRUE;\n\n    return emsg_core(s);\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Print error message \"s\" with format string and variable arguments.\n * \"s\" should already be translated.\n * Note: caller must not use \"IObuff\" for \"s\"!\n * Return TRUE if wait_return() not called.\n */\n    int\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (emsg_not_now())\n\treturn TRUE;\n\n    if (IObuff == NULL)\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn emsg_core(s);\n\n    va_list ap;\n\n    va_start(ap, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n    va_end(ap);\n    return emsg_core((char *)IObuff);\n}\n#endif\n\n/*\n * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n */\n    void\niemsg(char *s)\n{\n    if (emsg_not_now())\n\treturn;\n\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    emsg_core(s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n    set_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n    msg_putchar('\\n');  // avoid overwriting the error message\n    out_flush();\n    abort();\n#endif\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    void\nsiemsg(const char *s, ...)\n{\n    if (emsg_not_now())\n\treturn;\n\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\temsg_core(s);\n    }\n    else\n    {\n\tva_list ap;\n\n\tva_start(ap, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\tva_end(ap);\n\temsg_core((char *)IObuff);\n    }\n# ifdef ABORT_ON_INTERNAL_ERROR\n    msg_putchar('\\n');  // avoid overwriting the error message\n    out_flush();\n    abort();\n# endif\n}\n#endif\n\n/*\n * Give an \"Internal error\" message.\n */\n    void\ninternal_error(char *where)\n{\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    siemsg(_(e_internal_error_str), where);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Like internal_error() but do not call abort(), to avoid tests using\n * test_unknown() and test_void() causing Vim to exit.\n */\n    void\ninternal_error_no_abort(char *where)\n{\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    semsg(_(e_internal_error_str), where);\n}\n#endif\n\n// emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.\n\n    void\nemsg_invreg(int name)\n{\n    semsg(_(e_invalid_register_name_str), transchar_buf(NULL, name));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Give an error message which contains %s for \"name[len]\".\n */\n    void\nemsg_namelen(char *msg, char_u *name, int len)\n{\n    char_u *copy = vim_strnsave(name, len);\n\n    semsg(msg, copy == NULL ? \"NULL\" : (char *)copy);\n    vim_free(copy);\n}\n#endif\n\n/*\n * Like msg(), but truncate to a single line if p_shm contains 't', or when\n * \"force\" is TRUE.  This truncates in another way as for normal messages.\n * Careful: The string may be changed by msg_may_trunc()!\n * Returns a pointer to the printed message, if wait_return() not called.\n */\n    char *\nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n\n/*\n * Check if message \"s\" should be truncated at the start (for filenames).\n * Return a pointer to where the truncated message starts.\n * Note: May change the message by replacing a character with '<'.\n */\n    char_u *\nmsg_may_trunc(int force, char_u *s)\n{\n    int\t\tn;\n    int\t\troom;\n\n    // If 'cmdheight' is zero or something unexpected happened \"room\" may be\n    // negative.\n    room = (int)(Rows - cmdline_row - 1) * Columns + sc_col - 1;\n    if (room > 0 && (force || (shortmess(SHM_TRUNC) && !exmode_active))\n\t    && (n = (int)STRLEN(s) - room) > 0)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tsize = vim_strsize(s);\n\n\t    // There may be room anyway when there are multibyte chars.\n\t    if (size <= room)\n\t\treturn s;\n\n\t    for (n = 0; size >= room; )\n\t    {\n\t\tsize -= (*mb_ptr2cells)(s + n);\n\t\tn += (*mb_ptr2len)(s + n);\n\t    }\n\t    --n;\n\t}\n\ts += n;\n\t*s = '<';\n    }\n    return s;\n}\n\n    static void\nadd_msg_hist(\n    char_u\t*s,\n    int\t\tlen,\t\t// -1 for undetermined length\n    int\t\tattr)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_off || msg_silent != 0)\n\treturn;\n\n    // Don't let the message history get too big\n    while (msg_hist_len > MAX_MSG_HIST_LEN)\n\t(void)delete_first_msg();\n\n    // allocate an entry and add the message at the end of the history\n    p = ALLOC_ONE(struct msg_hist);\n    if (p == NULL)\n\treturn;\n\n    if (len < 0)\n\tlen = (int)STRLEN(s);\n    // remove leading and trailing newlines\n    while (len > 0 && *s == '\\n')\n    {\n\t++s;\n\t--len;\n    }\n    while (len > 0 && s[len - 1] == '\\n')\n\t--len;\n    p->msg = vim_strnsave(s, len);\n    p->next = NULL;\n    p->attr = attr;\n    if (last_msg_hist != NULL)\n\tlast_msg_hist->next = p;\n    last_msg_hist = p;\n    if (first_msg_hist == NULL)\n\tfirst_msg_hist = last_msg_hist;\n    ++msg_hist_len;\n}\n\n/*\n * Delete the first (oldest) message from the history.\n * Returns FAIL if there are no messages.\n */\n    int\ndelete_first_msg(void)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_len <= 0)\n\treturn FAIL;\n    p = first_msg_hist;\n    first_msg_hist = p->next;\n    if (first_msg_hist == NULL)\n\tlast_msg_hist = NULL;  // history is empty\n    vim_free(p->msg);\n    vim_free(p);\n    --msg_hist_len;\n    return OK;\n}\n\n/*\n * \":messages\" command.\n */\n    void\nex_messages(exarg_T *eap)\n{\n    struct msg_hist *p;\n    char_u\t    *s;\n    int\t\t    c = 0;\n\n    if (STRCMP(eap->arg, \"clear\") == 0)\n    {\n\tint keep = eap->addr_count == 0 ? 0 : eap->line2;\n\n\twhile (msg_hist_len > keep)\n\t    (void)delete_first_msg();\n\treturn;\n    }\n\n    if (*eap->arg != NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    msg_hist_off = TRUE;\n\n    p = first_msg_hist;\n    if (eap->addr_count != 0)\n    {\n\t// Count total messages\n\tfor (; p != NULL && !got_int; p = p->next)\n\t    c++;\n\n\tc -= eap->line2;\n\n\t// Skip without number of messages specified\n\tfor (p = first_msg_hist; p != NULL && !got_int && c > 0;\n\t\t\t\t\t\t    p = p->next, c--);\n    }\n\n    if (p == first_msg_hist)\n    {\n#ifdef FEAT_MULTI_LANG\n\ts = get_mess_lang();\n#else\n\ts = mch_getenv((char_u *)\"LANG\");\n#endif\n\tif (s != NULL && *s != NUL)\n\t    // The next comment is extracted by xgettext and put in po file for\n\t    // translators to read.\n\t    msg_attr(\n\t\t    // Translator: Please replace the name and email address\n\t\t    // with the appropriate text for your translation.\n\t\t    _(\"Messages maintainer: The Vim Project\"),\n\t\t    HL_ATTR(HLF_T));\n    }\n\n    // Display what was not skipped.\n    for (; p != NULL && !got_int; p = p->next)\n\tif (p->msg != NULL)\n\t    msg_attr((char *)p->msg, p->attr);\n\n    msg_hist_off = FALSE;\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(FIND_REPLACE_DIALOG) || defined(PROTO)\n/*\n * Call this after prompting the user.  This will avoid a hit-return message\n * and a delay.\n */\n    void\nmsg_end_prompt(void)\n{\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    cmdline_row = msg_row;\n    msg_col = 0;\n    msg_clr_eos();\n    lines_left = -1;\n}\n#endif\n\n/*\n * Wait for the user to hit a key (normally Enter).\n * If \"redraw\" is TRUE, clear and redraw the screen.\n * If \"redraw\" is FALSE, just redraw the screen.\n * If \"redraw\" is -1, don't redraw at all.\n */\n    void\nwait_return(int redraw)\n{\n    int\t\tc;\n    int\t\toldState;\n    int\t\ttmpState;\n    int\t\thad_got_int;\n    int\t\tsave_reg_recording;\n    FILE\t*save_scriptout;\n\n    if (redraw == TRUE)\n\tset_must_redraw(UPD_CLEAR);\n\n    // If using \":silent cmd\", don't wait for a return.  Also don't set\n    // need_wait_return to do it later.\n    if (msg_silent != 0)\n\treturn;\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n\n    /*\n     * When inside vgetc(), we can't wait for a typed character at all.\n     * With the global command (and some others) we only need one return at\n     * the end. Adjust cmdline_row to avoid the next message overwriting the\n     * last one.\n     */\n    if (vgetc_busy > 0)\n\treturn;\n    need_wait_return = TRUE;\n    if (no_wait_return)\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\treturn;\n    }\n\n    redir_off = TRUE;\t\t// don't redirect this message\n    oldState = State;\n    if (quit_more)\n    {\n\tc = CAR;\t\t// just pretend CR was hit\n\tquit_more = FALSE;\n\tgot_int = FALSE;\n    }\n    else if (exmode_active)\n    {\n\tmsg_puts(\" \");\t\t// make sure the cursor is on the right line\n\tc = CAR;\t\t// no need for a return in ex mode\n\tgot_int = FALSE;\n    }\n    else\n    {\n\t// Make sure the hit-return prompt is on screen when 'guioptions' was\n\t// just changed.\n\tscreenalloc(FALSE);\n\n\tState = MODE_HITRETURN;\n\tsetmouse();\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\tcmdline_row = msg_row;\n\n\t// Avoid the sequence that the user types \":\" at the hit-return prompt\n\t// to start an Ex command, but the file-changed dialog gets in the\n\t// way.\n\tif (need_check_timestamps)\n\t    check_timestamps(FALSE);\n\n\thit_return_msg();\n\n\tdo\n\t{\n\t    // Remember \"got_int\", if it is set vgetc() probably returns a\n\t    // CTRL-C, but we need to loop then.\n\t    had_got_int = got_int;\n\n\t    // Don't do mappings here, we put the character back in the\n\t    // typeahead buffer.\n\t    ++no_mapping;\n\t    ++allow_keys;\n\n\t    // Temporarily disable Recording. If Recording is active, the\n\t    // character will be recorded later, since it will be added to the\n\t    // typebuf after the loop\n\t    save_reg_recording = reg_recording;\n\t    save_scriptout = scriptout;\n\t    reg_recording = 0;\n\t    scriptout = NULL;\n\t    c = safe_vgetc();\n\t    if (had_got_int && !global_busy)\n\t\tgot_int = FALSE;\n\t    --no_mapping;\n\t    --allow_keys;\n\t    reg_recording = save_reg_recording;\n\t    scriptout = save_scriptout;\n\n#ifdef FEAT_CLIPBOARD\n\t    // Strange way to allow copying (yanking) a modeless selection at\n\t    // the hit-enter prompt.  Use CTRL-Y, because the same is used in\n\t    // Cmdline-mode and it's harmless when there is no selection.\n\t    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)\n\t    {\n\t\tclip_copy_modeless_selection(TRUE);\n\t\tc = K_IGNORE;\n\t    }\n#endif\n\n\t    /*\n\t     * Allow scrolling back in the messages.\n\t     * Also accept scroll-down commands when messages fill the screen,\n\t     * to avoid that typing one 'j' too many makes the messages\n\t     * disappear.\n\t     */\n\t    if (p_more && !p_cp)\n\t    {\n\t\tif (c == 'b' || c == 'k' || c == 'u' || c == 'g'\n\t\t\t\t\t\t|| c == K_UP || c == K_PAGEUP)\n\t\t{\n\t\t    if (msg_scrolled > Rows)\n\t\t\t// scroll back to show older messages\n\t\t\tdo_more_prompt(c);\n\t\t    else\n\t\t    {\n\t\t\tmsg_didout = FALSE;\n\t\t\tc = K_IGNORE;\n\t\t\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t\t\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t\t\t    0;\n\t\t    }\n\t\t    if (quit_more)\n\t\t    {\n\t\t\tc = CAR;\t\t// just pretend CR was hit\n\t\t\tquit_more = FALSE;\n\t\t\tgot_int = FALSE;\n\t\t    }\n\t\t    else if (c != K_IGNORE)\n\t\t    {\n\t\t\tc = K_IGNORE;\n\t\t\thit_return_msg();\n\t\t    }\n\t\t}\n\t\telse if (msg_scrolled > Rows - 2\n\t\t\t && (c == 'j' || c == 'd' || c == 'f'\n\t\t\t\t\t   || c == K_DOWN || c == K_PAGEDOWN))\n\t\t    c = K_IGNORE;\n\t    }\n\t} while ((had_got_int && c == Ctrl_C)\n\t\t\t\t|| c == K_IGNORE\n#ifdef FEAT_GUI\n\t\t\t\t|| c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n#endif\n\t\t\t\t|| c == K_LEFTDRAG   || c == K_LEFTRELEASE\n\t\t\t\t|| c == K_MIDDLEDRAG || c == K_MIDDLERELEASE\n\t\t\t\t|| c == K_RIGHTDRAG  || c == K_RIGHTRELEASE\n\t\t\t\t|| c == K_MOUSELEFT  || c == K_MOUSERIGHT\n\t\t\t\t|| c == K_MOUSEDOWN  || c == K_MOUSEUP\n\t\t\t\t|| c == K_MOUSEMOVE\n\t\t\t\t|| (!mouse_has(MOUSE_RETURN)\n\t\t\t\t    && mouse_row < msg_row\n\t\t\t\t    && (c == K_LEFTMOUSE\n\t\t\t\t\t|| c == K_MIDDLEMOUSE\n\t\t\t\t\t|| c == K_RIGHTMOUSE\n\t\t\t\t\t|| c == K_X1MOUSE\n\t\t\t\t\t|| c == K_X2MOUSE))\n\t\t\t\t);\n\tui_breakcheck();\n\n\t// Avoid that the mouse-up event causes Visual mode to start.\n\tif (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE\n\t\t\t\t\t  || c == K_X1MOUSE || c == K_X2MOUSE)\n\t    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);\n\telse if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C)\n\t{\n\t    // Put the character back in the typeahead buffer.  Don't use the\n\t    // stuff buffer, because lmaps wouldn't work.\n\t    ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\t    do_redraw = TRUE;\t    // need a redraw even though there is\n\t\t\t\t    // typeahead\n\t}\n    }\n    redir_off = FALSE;\n\n    /*\n     * If the user hits ':', '?' or '/' we get a command line from the next\n     * line.\n     */\n    if (c == ':' || c == '?' || c == '/')\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\tskip_redraw = TRUE;\t    // skip redraw once\n\tdo_redraw = FALSE;\n#ifdef FEAT_TERMINAL\n\tskip_term_loop = TRUE;\n#endif\n    }\n\n    /*\n     * If the window size changed set_shellsize() will redraw the screen.\n     * Otherwise the screen is only redrawn if 'redraw' is set and no ':'\n     * typed.\n     */\n    tmpState = State;\n    State = oldState;\t\t    // restore State before set_shellsize\n    setmouse();\n    msg_check();\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * When switching screens, we need to output an extra newline on exit.\n     */\n    if (swapping_screen() && !termcap_active)\n\tnewline_on_exit = TRUE;\n#endif\n\n    need_wait_return = FALSE;\n    did_wait_return = TRUE;\n    emsg_on_display = FALSE;\t// can delete error message now\n    lines_left = -1;\t\t// reset lines_left at next msg_start()\n    reset_last_sourcing();\n    if (keep_msg != NULL && vim_strsize(keep_msg) >=\n\t\t\t\t  (Rows - cmdline_row - 1) * Columns + sc_col)\n\tVIM_CLEAR(keep_msg);\t    // don't redisplay message, it's too long\n\n    if (tmpState == MODE_SETWSIZE)  // got resize event while in vgetc()\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tshell_resized();\n    }\n    else if (!skip_redraw\n\t    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tredraw_later(UPD_VALID);\n    }\n}\n\n/*\n * Write the hit-return prompt.\n */\n    static void\nhit_return_msg(void)\n{\n    int\t\tsave_p_more = p_more;\n\n    p_more = FALSE;\t// don't want to see this message when scrolling back\n    if (msg_didout)\t// start on a new line\n\tmsg_putchar('\\n');\n    if (got_int)\n\tmsg_puts(_(\"Interrupt: \"));\n\n    msg_puts_attr(_(\"Press ENTER or type command to continue\"), HL_ATTR(HLF_R));\n    if (!msg_use_printf())\n\tmsg_clr_eos();\n    p_more = save_p_more;\n}\n\n/*\n * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer.\n */\n    void\nset_keep_msg(char_u *s, int attr)\n{\n    vim_free(keep_msg);\n    if (s != NULL && msg_silent == 0)\n\tkeep_msg = vim_strsave(s);\n    else\n\tkeep_msg = NULL;\n    keep_msg_more = FALSE;\n    keep_msg_attr = attr;\n}\n\n/*\n * If there currently is a message being displayed, set \"keep_msg\" to it, so\n * that it will be displayed again after redraw.\n */\n    void\nset_keep_msg_from_hist(void)\n{\n    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0\n\t\t\t\t\t\t      && (State & MODE_NORMAL))\n\tset_keep_msg(last_msg_hist->msg, last_msg_hist->attr);\n}\n\n/*\n * Prepare for outputting characters in the command line.\n */\n    void\nmsg_start(void)\n{\n    int\t\tdid_return = FALSE;\n\n    if (!msg_silent)\n    {\n\tVIM_CLEAR(keep_msg);\n\tneed_fileinfo = FALSE;\n    }\n\n#ifdef FEAT_EVAL\n    if (need_clr_eos)\n    {\n\t// Halfway an \":echo\" command and getting an (error) message: clear\n\t// any text from the command.\n\tneed_clr_eos = FALSE;\n\tmsg_clr_eos();\n    }\n#endif\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n    {\n\tif (popup_message_win_visible()\n\t\t    && ((msg_col > 0 && (msg_scroll || !full_screen))\n\t\t\t|| in_echowindow))\n\t{\n\t    win_T *wp = popup_get_message_win();\n\n\t    // start a new line\n\t    curbuf = wp->w_buffer;\n\t    ml_append(wp->w_buffer->b_ml.ml_line_count,\n\t\t\t\t\t      (char_u *)\"\", (colnr_T)0, FALSE);\n\t    curbuf = curwin->w_buffer;\n\t}\n\tmsg_col = 0;\n    }\n    else\n#endif\n\tif (!msg_scroll && full_screen)\t// overwrite last message\n    {\n\tmsg_row = cmdline_row;\n\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t    0;\n    }\n    else if (msg_didout || in_echowindow)\n    {\n\t// start message on next line\n\tmsg_putchar('\\n');\n\tdid_return = TRUE;\n\tif (exmode_active != EXMODE_NORMAL)\n\t    cmdline_row = msg_row;\n    }\n    if (!msg_didany || lines_left < 0)\n\tmsg_starthere();\n    if (msg_silent == 0)\n    {\n\tmsg_didout = FALSE;\t\t    // no output on current line yet\n\tcursor_off();\n    }\n\n    // when redirecting, may need to start a new line.\n    if (!did_return)\n\tredir_write((char_u *)\"\\n\", -1);\n}\n\n/*\n * Note that the current msg position is where messages start.\n */\n    void\nmsg_starthere(void)\n{\n    lines_left = cmdline_row;\n    msg_didany = FALSE;\n}\n\n    void\nmsg_putchar(int c)\n{\n    msg_putchar_attr(c, 0);\n}\n\n    void\nmsg_putchar_attr(int c, int attr)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    msg_puts_attr((char *)buf, attr);\n}\n\n    void\nmsg_outnum(long n)\n{\n    char\tbuf[20];\n\n    sprintf(buf, \"%ld\", n);\n    msg_puts(buf);\n}\n\n    void\nmsg_home_replace(char_u *fname)\n{\n    msg_home_replace_attr(fname, 0);\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n    void\nmsg_home_replace_hl(char_u *fname)\n{\n    msg_home_replace_attr(fname, HL_ATTR(HLF_D));\n}\n#endif\n\n    static void\nmsg_home_replace_attr(char_u *fname, int attr)\n{\n    char_u\t*name;\n\n    name = home_replace_save(NULL, fname);\n    if (name != NULL)\n\tmsg_outtrans_attr(name, attr);\n    vim_free(name);\n}\n\n/*\n * Output 'len' characters in 'str' (including NULs) with translation\n * if 'len' is -1, output up to a NUL character.\n * Use attributes 'attr'.\n * Return the number of characters it takes on the screen.\n */\n    int\nmsg_outtrans(char_u *str)\n{\n    return msg_outtrans_attr(str, 0);\n}\n\n    int\nmsg_outtrans_attr(char_u *str, int attr)\n{\n    return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);\n}\n\n    int\nmsg_outtrans_len(char_u *str, int len)\n{\n    return msg_outtrans_len_attr(str, len, 0);\n}\n\n/*\n * Output one character at \"p\".  Return pointer to the next character.\n * Handles multi-byte characters.\n */\n    char_u *\nmsg_outtrans_one(char_u *p, int attr)\n{\n    int\t\tl;\n\n    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n    {\n\tmsg_outtrans_len_attr(p, l, attr);\n\treturn p + l;\n    }\n    msg_puts_attr((char *)transchar_byte_buf(NULL, *p), attr);\n    return p + 1;\n}\n\n    int\nmsg_outtrans_len_attr(char_u *msgstr, int len, int attr)\n{\n    int\t\tretval = 0;\n    char_u\t*str = msgstr;\n    char_u\t*plain_start = msgstr;\n    char_u\t*s;\n    int\t\tmb_l;\n    int\t\tc;\n    int\t\tsave_got_int = got_int;\n\n    // Only quit when got_int was set in here.\n    got_int = FALSE;\n\n    // if MSG_HIST flag set, add message to history\n    if (attr & MSG_HIST)\n    {\n\tadd_msg_hist(str, len, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When drawing over the command line no need to clear it later or remove\n    // the mode message.\n    if (msg_row >= cmdline_row && msg_col == 0)\n    {\n\tclear_cmdline = FALSE;\n\tmode_displayed = FALSE;\n    }\n\n    // If the string starts with a composing character first draw a space on\n    // which the composing char can be drawn.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))\n\tmsg_puts_attr(\" \", attr);\n\n    /*\n     * Go over the string.  Special characters are translated and printed.\n     * Normal characters are printed several at a time.\n     */\n    while (--len >= 0 && !got_int)\n    {\n\tif (enc_utf8)\n\t    // Don't include composing chars after the end.\n\t    mb_l = utfc_ptr2len_len(str, len + 1);\n\telse if (has_mbyte)\n\t    mb_l = (*mb_ptr2len)(str);\n\telse\n\t    mb_l = 1;\n\tif (has_mbyte && mb_l > 1)\n\t{\n\t    c = (*mb_ptr2char)(str);\n\t    if (vim_isprintc(c))\n\t\t// printable multi-byte char: count the cells.\n\t\tretval += (*mb_ptr2cells)(str);\n\t    else\n\t    {\n\t\t// unprintable multi-byte char: print the printable chars so\n\t\t// far and the translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + mb_l;\n\t\tmsg_puts_attr((char *)transchar_buf(NULL, c),\n\t\t\t\t\t    attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += char2cells(c);\n\t    }\n\t    len -= mb_l - 1;\n\t    str += mb_l;\n\t}\n\telse\n\t{\n\t    s = transchar_byte_buf(NULL, *str);\n\t    if (s[1] != NUL)\n\t    {\n\t\t// unprintable char: print the printable chars so far and the\n\t\t// translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + 1;\n\t\tmsg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += (int)STRLEN(s);\n\t    }\n\t    else\n\t\t++retval;\n\t    ++str;\n\t}\n    }\n\n    if (str > plain_start && !got_int)\n\t// print the printable chars at the end\n\tmsg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);\n\n    got_int |= save_got_int;\n\n    return retval;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    void\nmsg_make(char_u *arg)\n{\n    int\t    i;\n    static char_u *str = (char_u *)\"eeffoc\", *rs = (char_u *)\"Plon#dqg#vxjduB\";\n\n    arg = skipwhite(arg);\n    for (i = 5; *arg && i >= 0; --i)\n\tif (*arg++ != str[i])\n\t    break;\n    if (i < 0)\n    {\n\tmsg_putchar('\\n');\n\tfor (i = 0; rs[i]; ++i)\n\t    msg_putchar(rs[i] - 3);\n    }\n}\n#endif\n\n/*\n * Output the string 'str' up to a NUL character.\n * Return the number of characters it takes on the screen.\n *\n * If K_SPECIAL is encountered, then it is taken in conjunction with the\n * following character and shown as <F1>, <S-Up> etc.  Any other character\n * which is not printable shown in <> form.\n * If 'from' is TRUE (lhs of a mapping), a space is shown as <Space>.\n * If a character is displayed in one of these special ways, is also\n * highlighted (its highlight name is '8' in the p_hl variable).\n * Otherwise characters are not highlighted.\n * This function is used to show mappings, where we want to see how to type\n * the character/string -- webb\n */\n    int\nmsg_outtrans_special(\n    char_u\t*strstart,\n    int\t\tfrom,\t// TRUE for lhs of a mapping\n    int\t\tmaxlen) // screen columns, 0 for unlimited\n{\n    char_u\t*str = strstart;\n    int\t\tretval = 0;\n    char\t*text;\n    int\t\tattr;\n    int\t\tlen;\n\n    attr = HL_ATTR(HLF_8);\n    while (*str != NUL)\n    {\n\t// Leading and trailing spaces need to be displayed in <> form.\n\tif ((str == strstart || str[1] == NUL) && *str == ' ')\n\t{\n\t    text = \"<Space>\";\n\t    ++str;\n\t}\n\telse\n\t    text = (char *)str2special(&str, from, FALSE);\n\tif (text[0] != NUL && text[1] == NUL)\n\t    // single-byte character or illegal byte\n\t    text = (char *)transchar_byte_buf(NULL, (char_u)text[0]);\n\tlen = vim_strsize((char_u *)text);\n\tif (maxlen > 0 && retval + len >= maxlen)\n\t    break;\n\t// Highlight special keys\n\tmsg_puts_attr(text, len > 1\n\t\t&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);\n\tretval += len;\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return the lhs or rhs of a mapping, with the key codes turned into printable\n * strings, in an allocated string.\n */\n    char_u *\nstr2special_save(\n    char_u  *str,\n    int\t    replace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t    replace_lt)\t\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    garray_T\tga;\n    char_u\t*p = str;\n\n    ga_init2(&ga, 1, 40);\n    while (*p != NUL)\n\tga_concat(&ga, str2special(&p, replace_spaces, replace_lt));\n    ga_append(&ga, NUL);\n    return (char_u *)ga.ga_data;\n}\n#endif\n\n/*\n * Return the printable string for the key codes at \"*sp\".\n * On illegal byte return a string with only that byte.\n * Used for translating the lhs or rhs of a mapping to printable chars.\n * Advances \"sp\" to the next code.\n */\n    char_u *\nstr2special(\n    char_u\t**sp,\n    int\t\treplace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t\treplace_lt)\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if ((c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t|| c == CSI\n#endif\n\t) && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif ((c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t    || c == CSI\n#endif\n\t    ) && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\n\t*sp = str;\n\t// Try to un-escape a multi-byte character after modifiers.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    // Since 'special' is TRUE the multi-byte character 'c' will be\n\t    // processed by get_special_key_name()\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    // illegal byte\n\t    *sp = str + 1;\n    }\n    else\n\t// single-byte character, NUL or illegal byte\n\t*sp = str + (*str == NUL ? 0 : 1);\n\n    // Make special keys and C0 control characters in <> form, also <M-Space>.\n    if (special\n\t|| c < ' '\n\t|| (replace_spaces && c == ' ')\n\t|| (replace_lt && c == '<'))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n\n/*\n * Translate a key sequence into special key names.\n */\n    void\nstr2specialbuf(char_u *sp, char_u *buf, int len)\n{\n    char_u\t*s;\n\n    *buf = NUL;\n    while (*sp)\n    {\n\ts = str2special(&sp, FALSE, FALSE);\n\tif ((int)(STRLEN(s) + STRLEN(buf)) < len)\n\t    STRCAT(buf, s);\n    }\n}\n\n/*\n * print line for :print or :list command\n */\n    void\nmsg_prt_line(char_u *s, int list)\n{\n    int\t\tc;\n    int\t\tcol = 0;\n    int\t\tn_extra = 0;\n    int\t\tc_extra = 0;\n    int\t\tc_final = 0;\n    char_u\t*p_extra = NULL;\t    // init to make SASC shut up\n    int\t\tn;\n    int\t\tattr = 0;\n    char_u\t*trail = NULL;\n    char_u\t*lead = NULL;\n    int\t\tin_multispace = FALSE;\n    int\t\tmultispace_pos = 0;\n    int\t\tl;\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (curwin->w_p_list)\n\tlist = TRUE;\n\n    if (list)\n    {\n\t// find start of trailing whitespace\n\tif (curwin->w_lcs_chars.trail)\n\t{\n\t    trail = s + STRLEN(s);\n\t    while (trail > s && VIM_ISWHITE(trail[-1]))\n\t\t--trail;\n\t}\n\t// find end of leading whitespace\n\tif (curwin->w_lcs_chars.lead\n\t\t\t\t || curwin->w_lcs_chars.leadmultispace != NULL)\n\t{\n\t    lead = s;\n\t    while (VIM_ISWHITE(lead[0]))\n\t\tlead++;\n\t    // in a line full of spaces all of them are treated as trailing\n\t    if (*lead == NUL)\n\t\tlead = NULL;\n\t}\n    }\n\n    // output a space for an empty line, otherwise the line will be\n    // overwritten\n    if (*s == NUL && !(list && curwin->w_lcs_chars.eol != NUL))\n\tmsg_putchar(' ');\n\n    while (!got_int)\n    {\n\tif (n_extra > 0)\n\t{\n\t    --n_extra;\n\t    if (n_extra == 0 && c_final)\n\t\tc = c_final;\n\t    else if (c_extra)\n\t\tc = c_extra;\n\t    else\n\t\tc = *p_extra++;\n\t}\n\telse if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)\n\t{\n\t    col += (*mb_ptr2cells)(s);\n\t    if (l >= MB_MAXBYTES)\n\t    {\n\t\tSTRCPY(buf, \"?\");\n\t    }\n\t    else if (curwin->w_lcs_chars.nbsp != NUL && list\n\t\t    && (mb_ptr2char(s) == 160\n\t\t\t|| mb_ptr2char(s) == 0x202f))\n\t    {\n\t\tint len = mb_char2bytes(curwin->w_lcs_chars.nbsp, buf);\n\n\t\tbuf[len] = NUL;\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(buf, s, (size_t)l);\n\t\tbuf[l] = NUL;\n\t    }\n\t    msg_puts((char *)buf);\n\t    s += l;\n\t    continue;\n\t}\n\telse\n\t{\n\t    attr = 0;\n\t    c = *s++;\n\t    if (list)\n\t    {\n\t\tin_multispace = c == ' ' && (*s == ' '\n\t\t\t\t\t\t || (col > 0 && s[-2] == ' '));\n\t\tif (!in_multispace)\n\t\t    multispace_pos = 0;\n\t    }\n\t    if (c == TAB && (!list || curwin->w_lcs_chars.tab1))\n\t    {\n\t\t// tab amount depends on current column\n#ifdef FEAT_VARTABS\n\t\tn_extra = tabstop_padding(col, curbuf->b_p_ts,\n\t\t\t\t\t\t    curbuf->b_p_vts_array) - 1;\n#else\n\t\tn_extra = curbuf->b_p_ts - col % curbuf->b_p_ts - 1;\n#endif\n\t\tif (!list)\n\t\t{\n\t\t    c = ' ';\n\t\t    c_extra = ' ';\n\t\t    c_final = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = (n_extra == 0 && curwin->w_lcs_chars.tab3)\n\t\t\t\t\t\t? curwin->w_lcs_chars.tab3\n\t\t\t\t\t\t: curwin->w_lcs_chars.tab1;\n\t\t    c_extra = curwin->w_lcs_chars.tab2;\n\t\t    c_final = curwin->w_lcs_chars.tab3;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t    else if (c == 160 && list && curwin->w_lcs_chars.nbsp != NUL)\n\t    {\n\t\tc = curwin->w_lcs_chars.nbsp;\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == NUL && list && curwin->w_lcs_chars.eol != NUL)\n\t    {\n\t\tp_extra = (char_u *)\"\";\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tn_extra = 1;\n\t\tc = curwin->w_lcs_chars.eol;\n\t\tattr = HL_ATTR(HLF_AT);\n\t\t--s;\n\t    }\n\t    else if (c != NUL && (n = byte2cells(c)) > 1)\n\t    {\n\t\tn_extra = n - 1;\n\t\tp_extra = transchar_byte_buf(NULL, c);\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tc = *p_extra++;\n\t\t// Use special coloring to be able to distinguish <hex> from\n\t\t// the same in plain text.\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == ' ')\n\t    {\n\t\tif (lead != NULL && s <= lead && in_multispace\n\t\t\t&& curwin->w_lcs_chars.leadmultispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.leadmultispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.leadmultispace[multispace_pos]\n\t\t\t\t\t\t\t\t\t== NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (lead != NULL && s <= lead\n\t\t\t\t\t    && curwin->w_lcs_chars.lead != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.lead;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (trail != NULL && s > trail)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.trail;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (in_multispace\n\t\t\t&& curwin->w_lcs_chars.multispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.multispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.multispace[multispace_pos] == NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && curwin->w_lcs_chars.space != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.space;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t}\n\n\tif (c == NUL)\n\t    break;\n\n\tmsg_putchar_attr(c, attr);\n\tcol++;\n    }\n    msg_clr_eos();\n}\n\n/*\n * Use screen_puts() to output one multi-byte character.\n * Return the pointer \"s\" advanced to the next character.\n */\n    static char_u *\nscreen_puts_mbyte(char_u *s, int l, int attr)\n{\n    int\t\tcw;\n\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    cw = (*mb_ptr2cells)(s);\n    if (cw > 1 && (\n#ifdef FEAT_RIGHTLEFT\n\t\tcmdmsg_rl ? msg_col <= 1 :\n#endif\n\t\tmsg_col == Columns - 1))\n    {\n\t// Doesn't fit, print a highlighted '>' to fill it up.\n\tmsg_screen_putchar('>', HL_ATTR(HLF_AT));\n\treturn s;\n    }\n\n    screen_puts_len(s, l, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_col -= cw;\n\tif (msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tmsg_col += cw;\n\tif (msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n    return s + l;\n}\n\n/*\n * Output a string to the screen at position msg_row, msg_col.\n * Update msg_row and msg_col for the next message.\n */\n    void\nmsg_puts(char *s)\n{\n    msg_puts_attr(s, 0);\n}\n\n    void\nmsg_puts_title(char *s)\n{\n    msg_puts_attr(s, HL_ATTR(HLF_T));\n}\n\n/*\n * Show a message in such a way that it always fits in the line.  Cut out a\n * part in the middle and replace it with \"...\" when necessary.\n * Does not handle multi-byte characters!\n */\n    static void\nmsg_outtrans_long_len_attr(char_u *longstr, int len, int attr)\n{\n    int\t\tslen = len;\n    int\t\troom;\n\n    room = Columns - msg_col;\n    if (len > room && room >= 20)\n    {\n\tslen = (room - 3) / 2;\n\tmsg_outtrans_len_attr(longstr, slen, attr);\n\tmsg_puts_attr(\"...\", HL_ATTR(HLF_8));\n    }\n    msg_outtrans_len_attr(longstr + len - slen, slen, attr);\n}\n\n    void\nmsg_outtrans_long_attr(char_u *longstr, int attr)\n{\n    msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);\n}\n\n/*\n * Basic function for writing a message with highlight attributes.\n */\n    void\nmsg_puts_attr(char *s, int attr)\n{\n    msg_puts_attr_len(s, -1, attr);\n}\n\n/*\n * Like msg_puts_attr(), but with a maximum length \"maxlen\" (in bytes).\n * When \"maxlen\" is -1 there is no maximum length.\n * When \"maxlen\" is >= 0 the message is not put in the history.\n */\n    static void\nmsg_puts_attr_len(char *str, int maxlen, int attr)\n{\n    /*\n     * If redirection is on, also write to the redirection file.\n     */\n    redir_write((char_u *)str, maxlen);\n\n    /*\n     * Don't print anything when using \":silent cmd\".\n     */\n    if (msg_silent != 0)\n\treturn;\n\n    // if MSG_HIST flag set, add message to history\n    if ((attr & MSG_HIST) && maxlen < 0)\n    {\n\tadd_msg_hist((char_u *)str, -1, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When writing something to the screen after it has scrolled, requires a\n    // wait-return prompt later.  Needed when scrolling, resetting\n    // need_wait_return after some prompt, and then outputting something\n    // without scrolling\n    // Not needed when only using CR to move the cursor.\n    if (msg_scrolled != 0 && !msg_scrolled_ign && STRCMP(str, \"\\r\") != 0)\n\tneed_wait_return = TRUE;\n    msg_didany = TRUE;\t\t// remember that something was outputted\n\n    /*\n     * If there is no valid screen, use fprintf so we can see error messages.\n     * If termcap is not active, we may be writing in an alternate console\n     * window, cursor positioning may not work correctly (window size may be\n     * different, e.g. for Win32 console) or we just don't know where the\n     * cursor is.\n     */\n    if (msg_use_printf())\n\tmsg_puts_printf((char_u *)str, maxlen);\n    else\n\tmsg_puts_display((char_u *)str, maxlen, attr, FALSE);\n\n    need_fileinfo = FALSE;\n}\n\n// values for \"where\"\n#define PUT_APPEND 0\t\t// append to \"lnum\"\n#define PUT_TRUNC 1\t\t// replace \"lnum\"\n#define PUT_BELOW 2\t\t// add below \"lnum\"\n\t\t\t\t//\n#ifdef HAS_MESSAGE_WINDOW\n/*\n * Put text \"t_s\" until \"end\" in the message window.\n * \"where\" specifies where to put the text.\n */\n    static void\nput_msg_win(win_T *wp, int where, char_u *t_s, char_u *end, linenr_T lnum)\n{\n    char_u  *p;\n\n    if (where == PUT_BELOW)\n    {\n\tif (*end != NUL)\n\t{\n\t    p = vim_strnsave(t_s, end - t_s);\n\t    if (p == NULL)\n\t\treturn;\n\t}\n\telse\n\t    p = t_s;\n\tml_append_buf(wp->w_buffer, lnum, p, (colnr_T)0, FALSE);\n\tif (p != t_s)\n\t    vim_free(p);\n    }\n    else\n    {\n\tchar_u *newp;\n\n\tcurbuf = wp->w_buffer;\n\tif (where == PUT_APPEND)\n\t{\n\t    newp = concat_str(ml_get(lnum), t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t    if (*end != NUL)\n\t\tnewp[STRLEN(ml_get(lnum)) + (end - t_s)] = NUL;\n\t}\n\telse\n\t{\n\t    newp = vim_strnsave(t_s, end - t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t}\n\tml_replace(lnum, newp, FALSE);\n\tcurbuf = curwin->w_buffer;\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\n    // set msg_col so that a newline is written if needed\n    msg_col += (int)(end - t_s);\n}\n#endif\n\n/*\n * The display part of msg_puts_attr_len().\n * May be called recursively to display scroll-back text.\n */\n    static void\nmsg_puts_display(\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tattr,\n    int\t\trecurse)\n{\n    char_u\t*s = str;\n    char_u\t*t_s = str;\t// string from \"t_s\" to \"s\" is still todo\n    int\t\tt_col = 0;\t// screen cells todo, 0 when \"t_s\" not used\n    int\t\tl;\n    int\t\tcw;\n    char_u\t*sb_str = str;\n    int\t\tsb_col = msg_col;\n    int\t\twrap;\n    int\t\tdid_last_char;\n#ifdef HAS_MESSAGE_WINDOW\n    int\t\twhere = PUT_APPEND;\n    win_T\t*msg_win = NULL;\n    linenr_T    lnum = 1;\n\n    if (in_echowindow)\n    {\n\tmsg_win = popup_get_message_win();\n\n\tif (msg_win != NULL)\n\t{\n\t    if (!popup_message_win_visible())\n\t    {\n\t\tif (*str == NL)\n\t\t{\n\t\t    // When not showing the message window and the output\n\t\t    // starts with a NL show the message normally.\n\t\t    msg_win = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // currently hidden, make it empty\n\t\t    curbuf = msg_win->w_buffer;\n\t\t    while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t\tml_delete(1);\n\t\t    curbuf = curwin->w_buffer;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tlnum = msg_win->w_buffer->b_ml.ml_line_count;\n\t\tif (msg_col == 0)\n\t\t    where = PUT_TRUNC;\n\t    }\n\t}\n    }\n#endif\n\n    did_wait_return = FALSE;\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\t/*\n\t * We are at the end of the screen line when:\n\t * - When outputting a newline.\n\t * - When outputting a character in the last column.\n\t */\n\tif (!recurse && msg_row >= Rows - 1 && (*s == '\\n' || (\n#ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl\n\t\t    ? (\n\t\t\tmsg_col <= 1\n\t\t      || (*s == TAB && msg_col <= 7)\n\t\t      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))\n\t\t    :\n#endif\n\t\t      ((*s != '\\r' && msg_col + t_col >= Columns - 1)\n\t\t       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))\n\t\t       || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t && msg_col + t_col >= Columns - 2)))))\n\t{\n\t    /*\n\t     * The screen is scrolled up when at the last row (some terminals\n\t     * scroll automatically, some don't.  To avoid problems we scroll\n\t     * ourselves).\n\t     */\n\t    if (t_col > 0)\n\t    {\n\t\t// output postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t\tif (msg_win != NULL)\n\t\t{\n\t\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\t\t    t_col = 0;\n\t\t    where = PUT_BELOW;\n\t\t}\n\t\telse\n#endif\n\t\t    t_puts(&t_col, t_s, s, attr);\n\t    }\n\n\t    // When no more prompt and no more room, truncate here\n\t    if (msg_no_more && lines_left == 0)\n\t\tbreak;\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n#endif\n\t\t// Scroll the screen up one line.\n\t\tmsg_scroll_up();\n\n\t    msg_row = Rows - 2;\n\t    if (msg_col >= Columns)\t// can happen after screen resize\n\t\tmsg_col = Columns - 1;\n\n\t    // Display char in last column before showing more-prompt.\n\t    if (*s >= ' '\n#ifdef FEAT_RIGHTLEFT\n\t\t    && !cmdmsg_rl\n#endif\n\t       )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    if (enc_utf8 && maxlen >= 0)\n\t\t\t// avoid including composing chars after the end\n\t\t\tl = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\t    else\n\t\t\tl = (*mb_ptr2len)(s);\n\t\t    s = screen_puts_mbyte(s, l, attr);\n\t\t}\n\t\telse\n\t\t    msg_screen_putchar(*s++, attr);\n\t\tdid_last_char = TRUE;\n\t    }\n\t    else\n\t\tdid_last_char = FALSE;\n\n\t    if (p_more)\n\t\t// store text for scrolling back\n\t\tstore_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n\t    {\n#endif\n\t\tinc_msg_scrolled();\n\t\tneed_wait_return = TRUE; // may need wait_return() in main()\n\t\tredraw_cmdline = TRUE;\n\t\tif (cmdline_row > 0 && !exmode_active)\n\t\t    --cmdline_row;\n\n\t\t/*\n\t\t * If screen is completely filled and 'more' is set then wait\n\t\t * for a character.\n\t\t */\n\t\tif (lines_left > 0)\n\t\t    --lines_left;\n#ifdef HAS_MESSAGE_WINDOW\n\t    }\n#endif\n\t    if (p_more && lines_left == 0 && State != MODE_HITRETURN\n\t\t\t\t\t    && !msg_no_more && !exmode_active)\n\t    {\n#ifdef FEAT_CON_DIALOG\n\t\tif (do_more_prompt(NUL))\n\t\t    s = confirm_msg_tail;\n#else\n\t\t(void)do_more_prompt(NUL);\n#endif\n\t\tif (quit_more)\n\t\t    return;\n\t    }\n\n\t    // When we displayed a char in last column need to check if there\n\t    // is still more.\n\t    if (did_last_char)\n\t\tcontinue;\n\t}\n\n\twrap = *s == '\\n'\n\t\t    || msg_col + t_col >= Columns\n\t\t    || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t    && msg_col + t_col >= Columns - 1);\n\tif (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'\n\t\t\t\t\t\t || *s == '\\t' || *s == BELL))\n\t{\n\t    // output any postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\tput_msg_win(msg_win, where, t_s, s, lnum);\n\t\tt_col = 0;\n\t\twhere = PUT_BELOW;\n\t    }\n\t    else\n#endif\n\t\tt_puts(&t_col, t_s, s, attr);\n\t}\n\n\tif (wrap && p_more && !recurse)\n\t    // store text for scrolling back\n\t    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\tif (*s == '\\n')\t\t    // go to next line\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\t// Ignore a NL when the buffer is empty, it is used to scroll\n\t\t// up the text.\n\t\tif ((msg_win->w_buffer->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t{\n\t\t    put_msg_win(msg_win, PUT_BELOW, t_s, t_s, lnum);\n\t\t    ++lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tmsg_didout = FALSE;\t    // remember that line is empty\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns - 1;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    if (++msg_row >= Rows)  // safety check\n\t\tmsg_row = Rows - 1;\n\t}\n\telse if (*s == '\\r')\t    // go to column 0\n\t{\n\t    msg_col = 0;\n#ifdef HAS_MESSAGE_WINDOW\n\t    where = PUT_TRUNC;\n#endif\n\t}\n\telse if (*s == '\\b')\t    // go to previous char\n\t{\n\t    if (msg_col)\n\t\t--msg_col;\n\t}\n\telse if (*s == TAB)\t    // translate Tab into spaces\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t\tmsg_col = (msg_col + 7) % 8;\n\t    else\n#endif\n\t\tdo\n\t\t    msg_screen_putchar(' ', attr);\n\t\twhile (msg_col & 7);\n\t}\n\telse if (*s == BELL)\t\t// beep (from \":sh\")\n\t    vim_beep(BO_SH);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcw = (*mb_ptr2cells)(s);\n\t\tif (enc_utf8 && maxlen >= 0)\n\t\t    // avoid including composing chars after the end\n\t\t    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\telse\n\t\t    l = (*mb_ptr2len)(s);\n\t    }\n\t    else\n\t    {\n\t\tcw = 1;\n\t\tl = 1;\n\t    }\n\n\t    // When drawing from right to left or when a double-wide character\n\t    // doesn't fit, draw a single character here.  Otherwise collect\n\t    // characters and draw them all at once later.\n\t    if (\n# ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl ||\n# endif\n\t\t    (cw > 1 && msg_col + t_col >= Columns - 1))\n\t    {\n\t\tif (l > 1)\n\t\t    s = screen_puts_mbyte(s, l, attr) - 1;\n\t\telse\n\t\t    msg_screen_putchar(*s, attr);\n\t    }\n\t    else\n\t    {\n\t\t// postpone this character until later\n\t\tif (t_col == 0)\n\t\t    t_s = s;\n\t\tt_col += cw;\n\t\ts += l - 1;\n\t    }\n\t}\n\t++s;\n    }\n\n    // output any postponed text\n    if (t_col > 0)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (msg_win != NULL)\n\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\telse\n#endif\n\t    t_puts(&t_col, t_s, s, attr);\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (msg_win != NULL)\n\tpopup_show_message_win();\n#endif\n    // Store the text for scroll back, unless it's a newline by itself.\n    if (p_more && !recurse && !(s == sb_str + 1 && *sb_str == '\\n'))\n\tstore_sb_text(&sb_str, s, attr, &sb_col, FALSE);\n\n    msg_check();\n}\n\n/*\n * Return TRUE when \":filter pattern\" was used and \"msg\" does not match\n * \"pattern\".\n */\n    int\nmessage_filtered(char_u *msg)\n{\n    int match;\n\n    if (cmdmod.cmod_filter_regmatch.regprog == NULL)\n\treturn FALSE;\n    match = vim_regexec(&cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);\n    return cmdmod.cmod_filter_force ? match : !match;\n}\n\n/*\n * Scroll the screen up one line for displaying the next message line.\n */\n    static void\nmsg_scroll_up(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}\n\n/*\n * Increment \"msg_scrolled\".\n */\n    static void\ninc_msg_scrolled(void)\n{\n#ifdef FEAT_EVAL\n    if (*get_vim_var_str(VV_SCROLLSTART) == NUL)\n    {\n\tchar_u\t    *p = SOURCING_NAME;\n\tchar_u\t    *tofree = NULL;\n\tint\t    len;\n\n\t// v:scrollstart is empty, set it to the script/function name and line\n\t// number\n\tif (p == NULL)\n\t    p = (char_u *)_(\"Unknown\");\n\telse\n\t{\n\t    len = (int)STRLEN(p) + 40;\n\t    tofree = alloc(len);\n\t    if (tofree != NULL)\n\t    {\n\t\tvim_snprintf((char *)tofree, len, _(\"%s line %ld\"),\n\t\t\t\t\t\t      p, (long)SOURCING_LNUM);\n\t\tp = tofree;\n\t    }\n\t}\n\tset_vim_var_string(VV_SCROLLSTART, p, -1);\n\tvim_free(tofree);\n    }\n#endif\n    ++msg_scrolled;\n    set_must_redraw(UPD_VALID);\n}\n\n/*\n * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to\n * store the displayed text and remember where screen lines start.\n */\ntypedef struct msgchunk_S msgchunk_T;\nstruct msgchunk_S\n{\n    msgchunk_T\t*sb_next;\n    msgchunk_T\t*sb_prev;\n    char\tsb_eol;\t\t// TRUE when line ends after this text\n    int\t\tsb_msg_col;\t// column in which text starts\n    int\t\tsb_attr;\t// text attributes\n    char_u\tsb_text[1];\t// text to be displayed, actually longer\n};\n\nstatic msgchunk_T *last_msgchunk = NULL; // last displayed text\n\nstatic msgchunk_T *msg_sb_start(msgchunk_T *mps);\n\ntypedef enum {\n    SB_CLEAR_NONE = 0,\n    SB_CLEAR_ALL,\n    SB_CLEAR_CMDLINE_BUSY,\n    SB_CLEAR_CMDLINE_DONE\n} sb_clear_T;\n\n// When to clear text on next msg.\nstatic sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;\n\n/*\n * Store part of a printed message for displaying when scrolling back.\n */\n    static void\nstore_sb_text(\n    char_u\t**sb_str,\t// start of string\n    char_u\t*s,\t\t// just after string\n    int\t\tattr,\n    int\t\t*sb_col,\n    int\t\tfinish)\t\t// line ends\n{\n    msgchunk_T\t*mp;\n\n    if (do_clear_sb_text == SB_CLEAR_ALL\n\t    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)\n    {\n\tclear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);\n\tmsg_sb_eol();  // prevent messages from overlapping\n\tdo_clear_sb_text = SB_CLEAR_NONE;\n    }\n\n    if (s > *sb_str)\n    {\n\tmp = alloc(offsetof(msgchunk_T, sb_text) + (s - *sb_str) + 1);\n\tif (mp != NULL)\n\t{\n\t    mp->sb_eol = finish;\n\t    mp->sb_msg_col = *sb_col;\n\t    mp->sb_attr = attr;\n\t    vim_strncpy(mp->sb_text, *sb_str, s - *sb_str);\n\n\t    if (last_msgchunk == NULL)\n\t    {\n\t\tlast_msgchunk = mp;\n\t\tmp->sb_prev = NULL;\n\t    }\n\t    else\n\t    {\n\t\tmp->sb_prev = last_msgchunk;\n\t\tlast_msgchunk->sb_next = mp;\n\t\tlast_msgchunk = mp;\n\t    }\n\t    mp->sb_next = NULL;\n\t}\n    }\n    else if (finish && last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n\n    *sb_str = s;\n    *sb_col = 0;\n}\n\n/*\n * Finished showing messages, clear the scroll-back text on the next message.\n */\n    void\nmay_clear_sb_text(void)\n{\n    do_clear_sb_text = SB_CLEAR_ALL;\n}\n\n/*\n * Starting to edit the command line: do not clear messages now.\n */\n    void\nsb_text_start_cmdline(void)\n{\n    if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY)\n\t// Invoking command line recursively: the previous-level command line\n\t// doesn't need to be remembered as it will be redrawn when returning\n\t// to that level.\n\tsb_text_restart_cmdline();\n    else\n    {\n\tmsg_sb_eol();\n\tdo_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n    }\n}\n\n/*\n * Redrawing the command line: clear the last unfinished line.\n */\n    void\nsb_text_restart_cmdline(void)\n{\n    msgchunk_T *tofree;\n\n    // Needed when returning from nested command line.\n    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n\n    if (last_msgchunk == NULL || last_msgchunk->sb_eol)\n\t// No unfinished line: don't clear anything.\n\treturn;\n\n    tofree = msg_sb_start(last_msgchunk);\n    last_msgchunk = tofree->sb_prev;\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_next = NULL;\n    while (tofree != NULL)\n    {\n\tmsgchunk_T *tofree_next = tofree->sb_next;\n\n\tvim_free(tofree);\n\ttofree = tofree_next;\n    }\n}\n\n/*\n * Ending to edit the command line: clear old lines but the last one later.\n */\n    void\nsb_text_end_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;\n}\n\n/*\n * Clear any text remembered for scrolling back.\n * When \"all\" is FALSE keep the last line.\n * Called when redrawing the screen.\n */\n    void\nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &msg_sb_start(last_msgchunk)->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n/*\n * \"g<\" command.\n */\n    void\nshow_sb_text(void)\n{\n    msgchunk_T\t*mp;\n\n    // Only show something if there is more than one line, otherwise it looks\n    // weird, typing a command without output results in one line.\n    mp = msg_sb_start(last_msgchunk);\n    if (mp == NULL || mp->sb_prev == NULL)\n\tvim_beep(BO_MESS);\n    else\n    {\n\tdo_more_prompt('G');\n\twait_return(FALSE);\n    }\n}\n\n/*\n * Move to the start of screen line in already displayed text.\n */\n    static msgchunk_T *\nmsg_sb_start(msgchunk_T *mps)\n{\n    msgchunk_T *mp = mps;\n\n    while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)\n\tmp = mp->sb_prev;\n    return mp;\n}\n\n/*\n * Mark the last message chunk as finishing the line.\n */\n    void\nmsg_sb_eol(void)\n{\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n}\n\n/*\n * Display a screen line from previously displayed text at row \"row\".\n * When \"clear_to_eol\" is set clear the rest of the screen line.\n * Returns a pointer to the text for the next line (can be NULL).\n */\n    static msgchunk_T *\ndisp_sb_line(int row, msgchunk_T *smp, int clear_to_eol)\n{\n    msgchunk_T\t*mp = smp;\n    char_u\t*p;\n\n    for (;;)\n    {\n\tmsg_row = row;\n\tmsg_col = mp->sb_msg_col;\n\tp = mp->sb_text;\n\tif (*p == '\\n')\t    // don't display the line break\n\t    ++p;\n\tmsg_puts_display(p, -1, mp->sb_attr, TRUE);\n\n\t// If clearing the screen did not work (e.g. because of a background\n\t// color and t_ut isn't set) clear until the last column here.\n\tif (clear_to_eol)\n\t    screen_fill(row, row + 1, msg_col, (int)Columns, ' ', ' ', 0);\n\n\tif (mp->sb_eol || mp->sb_next == NULL)\n\t    break;\n\tmp = mp->sb_next;\n    }\n    return mp->sb_next;\n}\n\n/*\n * Output any postponed text for msg_puts_attr_len().\n */\n    static void\nt_puts(\n    int\t\t*t_col,\n    char_u\t*t_s,\n    char_u\t*s,\n    int\t\tattr)\n{\n    // output postponed text\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);\n    msg_col += *t_col;\n    *t_col = 0;\n    // If the string starts with a composing character don't increment the\n    // column position for it.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))\n\t--msg_col;\n    if (msg_col >= Columns)\n    {\n\tmsg_col = 0;\n\t++msg_row;\n    }\n}\n\n/*\n * Returns TRUE when messages should be printed with mch_errmsg().\n * This is used when there is no valid screen, so we can see error messages.\n * If termcap is not active, we may be writing in an alternate console\n * window, cursor positioning may not work correctly (window size may be\n * different, e.g. for Win32 console) or we just don't know where the\n * cursor is.\n */\n    int\nmsg_use_printf(void)\n{\n    return (!msg_check_screen()\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\t    || (!gui.in_use && !termcap_active)\n# else\n\t    || !termcap_active\n# endif\n#endif\n\t    || (swapping_screen() && !termcap_active)\n\t       );\n}\n\n/*\n * Print a message when there is no valid screen.\n */\n    static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)\n\t\t\t\t\t\t\t     >= (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}\n\n/*\n * Show the more-prompt and handle the user response.\n * This takes care of scrolling back and displaying previously displayed text.\n * When at hit-enter prompt \"typed_char\" is the already typed character,\n * otherwise it's NUL.\n * Returns TRUE when jumping ahead to \"confirm_msg_tail\".\n */\n    static int\ndo_more_prompt(int typed_char)\n{\n    static int\tentered = FALSE;\n    int\t\tused_typed_char = typed_char;\n    int\t\toldState = State;\n    int\t\tc;\n#ifdef FEAT_CON_DIALOG\n    int\t\tretval = FALSE;\n#endif\n    int\t\ttoscroll;\n    msgchunk_T\t*mp_last = NULL;\n    msgchunk_T\t*mp;\n    int\t\ti;\n\n    // We get called recursively when a timer callback outputs a message. In\n    // that case don't show another prompt. Also when at the hit-Enter prompt\n    // and nothing was typed.\n    if (entered || (State == MODE_HITRETURN && typed_char == 0))\n\treturn FALSE;\n    entered = TRUE;\n\n    if (typed_char == 'G')\n    {\n\t// \"g<\": Find first line on the last page.\n\tmp_last = msg_sb_start(last_msgchunk);\n\tfor (i = 0; i < Rows - 2 && mp_last != NULL\n\t\t\t\t\t     && mp_last->sb_prev != NULL; ++i)\n\t    mp_last = msg_sb_start(mp_last->sb_prev);\n    }\n\n    State = MODE_ASKMORE;\n    setmouse();\n    if (typed_char == NUL)\n\tmsg_moremsg(FALSE);\n    for (;;)\n    {\n\t/*\n\t * Get a typed character directly from the user.\n\t */\n\tif (used_typed_char != NUL)\n\t{\n\t    c = used_typed_char;\t// was typed at hit-enter prompt\n\t    used_typed_char = NUL;\n\t}\n\telse\n\t    c = get_keystroke();\n\n#if defined(FEAT_MENU) && defined(FEAT_GUI)\n\tif (c == K_MENU)\n\t{\n\t    int idx = get_menu_index(current_menu, MODE_ASKMORE);\n\n\t    // Used a menu.  If it starts with CTRL-Y, it must\n\t    // be a \"Copy\" for the clipboard.  Otherwise\n\t    // assume that we end\n\t    if (idx == MENU_INDEX_INVALID)\n\t\tcontinue;\n\t    c = *current_menu->strings[idx];\n\t    if (c != NUL && current_menu->strings[idx][1] != NUL)\n\t\tins_typebuf(current_menu->strings[idx] + 1,\n\t\t\t\tcurrent_menu->noremap[idx], 0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t}\n#endif\n\n\ttoscroll = 0;\n\tswitch (c)\n\t{\n\tcase BS:\t\t// scroll one line back\n\tcase K_BS:\n\tcase 'k':\n\tcase K_UP:\n\t    toscroll = -1;\n\t    break;\n\n\tcase CAR:\t\t// one extra line\n\tcase NL:\n\tcase 'j':\n\tcase K_DOWN:\n\t    toscroll = 1;\n\t    break;\n\n\tcase 'u':\t\t// Up half a page\n\t    toscroll = -(Rows / 2);\n\t    break;\n\n\tcase 'd':\t\t// Down half a page\n\t    toscroll = Rows / 2;\n\t    break;\n\n\tcase 'b':\t\t// one page back\n\tcase K_PAGEUP:\n\t    toscroll = -(Rows - 1);\n\t    break;\n\n\tcase ' ':\t\t// one extra page\n\tcase 'f':\n\tcase K_PAGEDOWN:\n\tcase K_LEFTMOUSE:\n\t    toscroll = Rows - 1;\n\t    break;\n\n\tcase 'g':\t\t// all the way back to the start\n\t    toscroll = -999999;\n\t    break;\n\n\tcase 'G':\t\t// all the way to the end\n\t    toscroll = 999999;\n\t    lines_left = 999999;\n\t    break;\n\n\tcase ':':\t\t// start new command line\n#ifdef FEAT_CON_DIALOG\n\t    if (!confirm_msg_used)\n#endif\n\t    {\n\t\t// Since got_int is set all typeahead will be flushed, but we\n\t\t// want to keep this ':', remember that in a special way.\n\t\ttypeahead_noflush(':');\n#ifdef FEAT_TERMINAL\n\t\tskip_term_loop = TRUE;\n#endif\n\t\tcmdline_row = Rows - 1;\t\t// put ':' on this line\n\t\tskip_redraw = TRUE;\t\t// skip redraw once\n\t\tneed_wait_return = FALSE;\t// don't wait in main()\n\t    }\n\t    // FALLTHROUGH\n\tcase 'q':\t\t// quit\n\tcase Ctrl_C:\n\tcase ESC:\n#ifdef FEAT_CON_DIALOG\n\t    if (confirm_msg_used)\n\t    {\n\t\t// Jump to the choices of the dialog.\n\t\tretval = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tgot_int = TRUE;\n\t\tquit_more = TRUE;\n\t    }\n\t    // When there is some more output (wrapping line) display that\n\t    // without another prompt.\n\t    lines_left = Rows - 1;\n\t    break;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t    // Strange way to allow copying (yanking) a modeless\n\t    // selection at the more prompt.  Use CTRL-Y,\n\t    // because the same is used in Cmdline-mode and at the\n\t    // hit-enter prompt.  However, scrolling one line up\n\t    // might be expected...\n\t    if (clip_star.state == SELECT_DONE)\n\t\tclip_copy_modeless_selection(TRUE);\n\t    continue;\n#endif\n\tdefault:\t\t// no valid response\n\t    msg_moremsg(TRUE);\n\t    continue;\n\t}\n\n\tif (toscroll != 0)\n\t{\n\t    if (toscroll < 0)\n\t    {\n\t\t// go to start of last line\n\t\tif (mp_last == NULL)\n\t\t    mp = msg_sb_start(last_msgchunk);\n\t\telse if (mp_last->sb_prev != NULL)\n\t\t    mp = msg_sb_start(mp_last->sb_prev);\n\t\telse\n\t\t    mp = NULL;\n\n\t\t// go to start of line at top of the screen\n\t\tfor (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;\n\t\t\t\t\t\t\t\t\t  ++i)\n\t\t    mp = msg_sb_start(mp->sb_prev);\n\n\t\tif (mp != NULL && mp->sb_prev != NULL)\n\t\t{\n\t\t    // Find line to be displayed at top.\n\t\t    for (i = 0; i > toscroll; --i)\n\t\t    {\n\t\t\tif (mp == NULL || mp->sb_prev == NULL)\n\t\t\t    break;\n\t\t\tmp = msg_sb_start(mp->sb_prev);\n\t\t\tif (mp_last == NULL)\n\t\t\t    mp_last = msg_sb_start(last_msgchunk);\n\t\t\telse\n\t\t\t    mp_last = msg_sb_start(mp_last->sb_prev);\n\t\t    }\n\n\t\t    if (toscroll == -1 && screen_ins_lines(0, 0, 1,\n\t\t\t\t\t\t     (int)Rows, 0, NULL) == OK)\n\t\t    {\n\t\t\t// display line at top\n\t\t\t(void)disp_sb_line(0, mp, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tint did_clear = screenclear();\n\n\t\t\t// redisplay all lines\n\t\t\tfor (i = 0; mp != NULL && i < Rows - 1; ++i)\n\t\t\t{\n\t\t\t    mp = disp_sb_line(i, mp, !did_clear);\n\t\t\t    ++msg_scrolled;\n\t\t\t}\n\t\t    }\n\t\t    toscroll = 0;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// First display any text that we scrolled back.\n\t\twhile (toscroll > 0 && mp_last != NULL)\n\t\t{\n\t\t    // scroll up, display line at bottom\n\t\t    msg_scroll_up();\n\t\t    inc_msg_scrolled();\n\t\t    screen_fill((int)Rows - 2, (int)Rows - 1, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\t    mp_last = disp_sb_line((int)Rows - 2, mp_last, FALSE);\n\t\t    --toscroll;\n\t\t}\n\t    }\n\n\t    if (toscroll <= 0)\n\t    {\n\t\t// displayed the requested text, more prompt again\n\t\tscreen_fill((int)Rows - 1, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\tmsg_moremsg(FALSE);\n\t\tcontinue;\n\t    }\n\n\t    // display more text, return to caller\n\t    lines_left = toscroll;\n\t}\n\n\tbreak;\n    }\n\n    // clear the --more-- message\n    screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n    State = oldState;\n    setmouse();\n    if (quit_more)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n#ifdef FEAT_RIGHTLEFT\n    else if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n#endif\n\n    entered = FALSE;\n#ifdef FEAT_CON_DIALOG\n    return retval;\n#else\n    return FALSE;\n#endif\n}\n\n#if defined(USE_MCH_ERRMSG) || defined(PROTO)\n\n#ifdef mch_errmsg\n# undef mch_errmsg\n#endif\n#ifdef mch_msg\n# undef mch_msg\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_errmsg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode = 0;\n    HANDLE  h = GetStdHandle(STD_ERROR_HANDLE);\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tfprintf(stderr, \"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give an error message.  To be used when the screen hasn't been initialized\n * yet.  When stderr can't be used, collect error messages until the GUI has\n * started and they can be displayed in a message box.\n */\n    void\nmch_errmsg(char *str)\n{\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    int\t\tlen;\n#endif\n\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stderr if it's a tty.\n    // When not going to start the GUI also use stderr.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tfprintf(stderr, \"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_errmsg_c(str);\n\treturn;\n    }\n#endif\n\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    // avoid a delay for a message that isn't there\n    emsg_on_display = FALSE;\n\n    len = (int)STRLEN(str) + 1;\n    if (error_ga.ga_growsize == 0)\n    {\n\terror_ga.ga_growsize = 80;\n\terror_ga.ga_itemsize = 1;\n    }\n    if (ga_grow(&error_ga, len) == OK)\n    {\n\tmch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,\n\t\t\t\t\t\t\t  (char_u *)str, len);\n# ifdef UNIX\n\t// remove CR characters, they are displayed\n\t{\n\t    char_u\t*p;\n\n\t    p = (char_u *)error_ga.ga_data + error_ga.ga_len;\n\t    for (;;)\n\t    {\n\t\tp = vim_strchr(p, '\\r');\n\t\tif (p == NULL)\n\t\t    break;\n\t\t*p = ' ';\n\t    }\n\t}\n# endif\n\t--len;\t\t// don't count the NUL at the end\n\terror_ga.ga_len += len;\n    }\n#endif\n}\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_msg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode;\n    HANDLE  h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tprintf(\"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give a message.  To be used when the screen hasn't been initialized yet.\n * When there is no tty, collect messages until the GUI has started and they\n * can be displayed in a message box.\n */\n    void\nmch_msg(char *str)\n{\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stdout if we have a tty.  This allows \"vim -h | more\" and\n    // uses mch_errmsg() when started from the desktop.\n    // When not going to start the GUI also use stdout.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tprintf(\"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_msg_c(str);\n\treturn;\n    }\n#endif\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    mch_errmsg(str);\n#endif\n}\n#endif // USE_MCH_ERRMSG\n\n/*\n * Put a character on the screen at the current message position and advance\n * to the next position.  Only for printable ASCII!\n */\n    static void\nmsg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}\n\n    static void\nmsg_moremsg(int full)\n{\n    int\t\tattr;\n    char_u\t*s = (char_u *)_(\"-- More --\");\n\n    attr = HL_ATTR(HLF_M);\n    screen_puts(s, (int)Rows - 1, 0, attr);\n    if (full)\n\tscreen_puts((char_u *)\n\t\t_(\" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit \"),\n\t\t(int)Rows - 1, vim_strsize(s), attr);\n}\n\n/*\n * Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,\n * MODE_CONFIRM or exmode_active.\n */\n    void\nrepeat_message(void)\n{\n    if (State == MODE_ASKMORE)\n    {\n\tmsg_moremsg(TRUE);\t// display --more-- message again\n\tmsg_row = Rows - 1;\n    }\n#ifdef FEAT_CON_DIALOG\n    else if (State == MODE_CONFIRM)\n    {\n\tdisplay_confirm_msg();\t// display \":confirm\" message again\n\tmsg_row = Rows - 1;\n    }\n#endif\n    else if (State == MODE_EXTERNCMD)\n    {\n\twindgoto(msg_row, msg_col); // put cursor back\n    }\n    else if (State == MODE_HITRETURN || State == MODE_SETWSIZE)\n    {\n\tif (msg_row == Rows - 1)\n\t{\n\t    // Avoid drawing the \"hit-enter\" prompt below the previous one,\n\t    // overwrite it.  Esp. useful when regaining focus and a\n\t    // FocusGained autocmd exists but didn't draw anything.\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    msg_clr_eos();\n\t}\n\thit_return_msg();\n\tmsg_row = Rows - 1;\n    }\n}\n\n/*\n * msg_check_screen - check if the screen is initialized.\n * Also check msg_row and msg_col, if they are too big it may cause a crash.\n * While starting the GUI the terminal codes will be set for the GUI, but the\n * output goes to the terminal.  Don't use the terminal codes then.\n */\n    static int\nmsg_check_screen(void)\n{\n    if (!full_screen || !screen_valid(FALSE))\n\treturn FALSE;\n\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n    if (msg_col >= Columns)\n\tmsg_col = Columns - 1;\n    return TRUE;\n}\n\n/*\n * Clear from current message position to end of screen.\n * Skip this when \":silent\" was used, no need to clear for redirection.\n */\n    void\nmsg_clr_eos(void)\n{\n    if (msg_silent == 0)\n\tmsg_clr_eos_force();\n}\n\n/*\n * Clear from current message position to end of screen.\n * Note: msg_col is not updated, so we remember the end of the message\n * for msg_check().\n */\n    void\nmsg_clr_eos_force(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;  // messages go into a popup\n#endif\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n/*\n * Clear the command line.\n */\n    void\nmsg_clr_cmdline(void)\n{\n    msg_row = cmdline_row;\n    msg_col = 0;\n    msg_clr_eos_force();\n}\n\n/*\n * end putting a message on the screen\n * call wait_return() if the message does not fit in the available space\n * return TRUE if wait_return() not called.\n */\n    int\nmsg_end(void)\n{\n    /*\n     * If the string is larger than the window,\n     * or the ruler option is set and we run into it,\n     * we have to redraw the window.\n     * Do not do this if we are abandoning the file or editing the command line.\n     */\n    if (!exiting && need_wait_return && !(State & MODE_CMDLINE))\n    {\n\twait_return(FALSE);\n\treturn FALSE;\n    }\n    out_flush();\n    return TRUE;\n}\n\n/*\n * If the written message runs into the shown command or ruler, we have to\n * wait for hit-return and redraw the window later.\n */\n    void\nmsg_check(void)\n{\n    if (msg_row == Rows - 1 && msg_col >= sc_col\n#ifdef HAS_MESSAGE_WINDOW\n\t\t&& !in_echowindow\n#endif\n\t    )\n    {\n\tneed_wait_return = TRUE;\n\tredraw_cmdline = TRUE;\n    }\n}\n\n/*\n * May write a string to the redirection file.\n * When \"maxlen\" is -1 write the whole string, otherwise up to \"maxlen\" bytes.\n */\n    static void\nredir_write(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    static int\tcur_col = 0;\n\n    // Don't do anything for displaying prompts and the like.\n    if (redir_off)\n\treturn;\n\n    // If 'verbosefile' is set prepare for writing in that file.\n    if (*p_vfile != NUL && verbose_fd == NULL)\n\tverbose_open();\n\n    if (redirecting())\n    {\n\t// If the string doesn't start with CR or NL, go to msg_col\n\tif (*s != '\\n' && *s != '\\r')\n\t{\n\t    while (cur_col < msg_col)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (redir_execute)\n\t\t    execute_redir_str((char_u *)\" \", -1);\n\t\telse if (redir_reg)\n\t\t    write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);\n\t\telse if (redir_vname)\n\t\t    var_redir_str((char_u *)\" \", -1);\n\t\telse\n#endif\n\t\t    if (redir_fd != NULL)\n\t\t    fputs(\" \", redir_fd);\n\t\tif (verbose_fd != NULL)\n\t\t    fputs(\" \", verbose_fd);\n\t\t++cur_col;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (redir_execute)\n\t    execute_redir_str(s, maxlen);\n\telse if (redir_reg)\n\t    write_reg_contents(redir_reg, s, maxlen, TRUE);\n\telse if (redir_vname)\n\t    var_redir_str(s, maxlen);\n#endif\n\n\t// Write and adjust the current column.\n\twhile (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))\n\t{\n#ifdef FEAT_EVAL\n\t    if (!redir_reg && !redir_vname && !redir_execute)\n#endif\n\t\tif (redir_fd != NULL)\n\t\t    putc(*s, redir_fd);\n\t    if (verbose_fd != NULL)\n\t\tputc(*s, verbose_fd);\n\t    if (*s == '\\r' || *s == '\\n')\n\t\tcur_col = 0;\n\t    else if (*s == '\\t')\n\t\tcur_col += (8 - cur_col % 8);\n\t    else\n\t\t++cur_col;\n\t    ++s;\n\t}\n\n\tif (msg_silent != 0)\t// should update msg_col\n\t    msg_col = cur_col;\n    }\n}\n\n    int\nredirecting(void)\n{\n    return redir_fd != NULL || *p_vfile != NUL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname || redir_execute\n#endif\n\t\t\t\t       ;\n}\n\n/*\n * Before giving verbose message.\n * Must always be called paired with verbose_leave()!\n */\n    void\nverbose_enter(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n}\n\n/*\n * After giving verbose message.\n * Must always be called paired with verbose_enter()!\n */\n    void\nverbose_leave(void)\n{\n    if (*p_vfile != NUL)\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n}\n\n/*\n * Like verbose_enter() and set msg_scroll when displaying the message.\n */\n    void\nverbose_enter_scroll(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n    else\n\t// always scroll up, don't overwrite\n\tmsg_scroll = TRUE;\n}\n\n/*\n * Like verbose_leave() and set cmdline_row when displaying the message.\n */\n    void\nverbose_leave_scroll(void)\n{\n    if (*p_vfile != NUL)\n    {\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n    }\n    else\n\tcmdline_row = msg_row;\n}\n\n/*\n * Called when 'verbosefile' is set: stop writing to the file.\n */\n    void\nverbose_stop(void)\n{\n    if (verbose_fd != NULL)\n    {\n\tfclose(verbose_fd);\n\tverbose_fd = NULL;\n    }\n    verbose_did_open = FALSE;\n}\n\n/*\n * Open the file 'verbosefile'.\n * Return FAIL or OK.\n */\n    int\nverbose_open(void)\n{\n    if (verbose_fd == NULL && !verbose_did_open)\n    {\n\t// Only give the error message once.\n\tverbose_did_open = TRUE;\n\n\tverbose_fd = mch_fopen((char *)p_vfile, \"a\");\n\tif (verbose_fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), p_vfile);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Give a warning message (for searching).\n * Use 'w' highlighting and may repeat the message after redrawing\n */\n    void\ngive_warning(char_u *message, int hl)\n{\n    give_warning_with_source(message, hl, FALSE);\n}\n\n    void\ngive_warning_with_source(char_u *message, int hl, int with_source)\n{\n    // Don't do this for \":silent\".\n    if (msg_silent != 0)\n\treturn;\n\n    // Don't want a hit-enter prompt here.\n    ++no_wait_return;\n\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_WARNINGMSG, message, -1);\n#endif\n    VIM_CLEAR(keep_msg);\n    if (hl)\n\tkeep_msg_attr = HL_ATTR(HLF_W);\n    else\n\tkeep_msg_attr = 0;\n\n    if (with_source)\n    {\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts(\" \");\n\tmsg_puts_attr((char *)message, HL_ATTR(HLF_W) | MSG_HIST);\n\tmsg_clr_eos();\n\t(void)msg_end();\n    }\n    else if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)\n\tset_keep_msg(message, keep_msg_attr);\n\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n\n    --no_wait_return;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\ngive_warning2(char_u *message, char_u *a1, int hl)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just give\n\t// the raw message so the user at least gets a hint.\n\tgive_warning(message, hl);\n    }\n    else\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);\n\tgive_warning(IObuff, hl);\n    }\n}\n#endif\n\n/*\n * Advance msg cursor to column \"col\".\n */\n    void\nmsg_advance(int col)\n{\n    if (msg_silent != 0)\t// nothing to advance to\n    {\n\tmsg_col = col;\t\t// for redirection, may fill it up later\n\treturn;\n    }\n    if (col >= Columns)\t\t// not enough room\n\tcol = Columns - 1;\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\twhile (msg_col > Columns - col)\n\t    msg_putchar(' ');\n    else\n#endif\n\twhile (msg_col < col)\n\t    msg_putchar(' ');\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Used for \"confirm()\" function, and the :confirm command prefix.\n * Versions which haven't got flexible dialogs yet, and console\n * versions, get this generic handler which uses the command line.\n *\n * type  = one of:\n *\t   VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC\n * title = title string (can be NULL for default)\n * (neither used in console dialogs at the moment)\n *\n * Format of the \"buttons\" string:\n * \"Button1Name\\nButton2Name\\nButton3Name\"\n * The first button should normally be the default/accept\n * The second button should be the 'Cancel' button\n * Other buttons- use your imagination!\n * A '&' in a button name becomes a shortcut, so each '&' should be before a\n * different letter.\n *\n * Returns 0 if cancelled, otherwise the nth button (1-indexed).\n */\n    int\ndo_dialog(\n    int\t\ttype UNUSED,\n    char_u\t*title UNUSED,\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton,\n    char_u\t*textfield UNUSED,\t// IObuff for inputdialog(), NULL\n\t\t\t\t\t// otherwise\n    int\t\tex_cmd)\t    // when TRUE pressing : accepts default and starts\n\t\t\t    // Ex command\n{\n    int\t\toldState;\n    int\t\tretval = 0;\n    char_u\t*hotkeys;\n    int\t\tc;\n    int\t\ti;\n    tmode_T\tsave_tmode;\n\n#ifndef NO_CONSOLE\n    // Don't output anything in silent mode (\"ex -s\")\n    if (silent_mode)\n\treturn dfltbutton;   // return default option\n#endif\n\n#ifdef FEAT_GUI_DIALOG\n    // When GUI is running and 'c' not in 'guioptions', use the GUI dialog\n    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)\n    {\n\t// --gui-dialog-file: write text to a file\n\tif (gui_dialog_log(title, message))\n\t    c = dfltbutton;\n\telse\n\t    c = gui_mch_dialog(type, title, message, buttons, dfltbutton,\n\t\t\t\t\t\t\t   textfield, ex_cmd);\n\t// avoid a hit-enter prompt without clearing the cmdline\n\tneed_wait_return = FALSE;\n\temsg_on_display = FALSE;\n\tcmdline_row = msg_row;\n\n\t// Flush output to avoid that further messages and redrawing is done\n\t// in the wrong order.\n\tout_flush();\n\tgui_mch_update();\n\n\treturn c;\n    }\n#endif\n\n    oldState = State;\n    State = MODE_CONFIRM;\n    setmouse();\n\n    // Ensure raw mode here.\n    save_tmode = cur_tmode;\n    settmode(TMODE_RAW);\n\n    /*\n     * Since we wait for a keypress, don't make the\n     * user press RETURN as well afterwards.\n     */\n    ++no_wait_return;\n    hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);\n\n    if (hotkeys != NULL)\n    {\n\tfor (;;)\n\t{\n\t    // Get a typed character directly from the user.\n\t    c = get_keystroke();\n\t    switch (c)\n\t    {\n\t    case CAR:\t\t// User accepts default option\n\t    case NL:\n\t\tretval = dfltbutton;\n\t\tbreak;\n\t    case Ctrl_C:\t// User aborts/cancels\n\t    case ESC:\n\t\tretval = 0;\n\t\tbreak;\n\t    default:\t\t// Could be a hotkey?\n\t\tif (c < 0)\t// special keys are ignored here\n\t\t    continue;\n\t\tif (c == ':' && ex_cmd)\n\t\t{\n\t\t    retval = dfltbutton;\n\t\t    ins_char_typebuf(':', 0);\n\t\t    break;\n\t\t}\n\n\t\t// Make the character lowercase, as chars in \"hotkeys\" are.\n\t\tc = MB_TOLOWER(c);\n\t\tretval = 1;\n\t\tfor (i = 0; hotkeys[i]; ++i)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif ((*mb_ptr2char)(hotkeys + i) == c)\n\t\t\t    break;\n\t\t\ti += (*mb_ptr2len)(hotkeys + i) - 1;\n\t\t    }\n\t\t    else\n\t\t\tif (hotkeys[i] == c)\n\t\t\t    break;\n\t\t    ++retval;\n\t\t}\n\t\tif (hotkeys[i])\n\t\t    break;\n\t\t// No hotkey match, so keep waiting\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\n\tvim_free(hotkeys);\n    }\n\n    settmode(save_tmode);\n    State = oldState;\n    setmouse();\n    --no_wait_return;\n    msg_end_prompt();\n\n    return retval;\n}\n\n/*\n * Copy one character from \"*from\" to \"*to\", taking care of multi-byte\n * characters.  Return the length of the character in bytes.\n */\n    static int\ncopy_char(\n    char_u\t*from,\n    char_u\t*to,\n    int\t\tlowercase)\t// make character lower case\n{\n    int\t\tlen;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tif (lowercase)\n\t{\n\t    c = MB_TOLOWER((*mb_ptr2char)(from));\n\t    return (*mb_char2bytes)(c, to);\n\t}\n\telse\n\t{\n\t    len = (*mb_ptr2len)(from);\n\t    mch_memmove(to, from, (size_t)len);\n\t    return len;\n\t}\n    }\n    else\n    {\n\tif (lowercase)\n\t    *to = (char_u)TOLOWER_LOC(*from);\n\telse\n\t    *to = *from;\n\treturn 1;\n    }\n}\n\n/*\n * Format the dialog string, and display it at the bottom of\n * the screen. Return a string of hotkey chars (if defined) for\n * each 'button'. If a button has no hotkey defined, the first character of\n * the button is used.\n * The hotkeys can be multi-byte characters, but without combining chars.\n *\n * Returns an allocated string with hotkeys, or NULL for error.\n */\n    static char_u *\nmsg_show_console_dialog(\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton)\n{\n    int\t\tlen = 0;\n#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)\n    int\t\tlenhotkey = HOTK_LEN;\t// count first button\n    char_u\t*hotk = NULL;\n    char_u\t*msgp = NULL;\n    char_u\t*hotkp = NULL;\n    char_u\t*r;\n    int\t\tcopy;\n#define HAS_HOTKEY_LEN 30\n    char_u\thas_hotkey[HAS_HOTKEY_LEN];\n    int\t\tfirst_hotkey = FALSE;\t// first char of button is hotkey\n    int\t\tidx;\n\n    has_hotkey[0] = FALSE;\n\n    /*\n     * First loop: compute the size of memory to allocate.\n     * Second loop: copy to the allocated memory.\n     */\n    for (copy = 0; copy <= 1; ++copy)\n    {\n\tr = buttons;\n\tidx = 0;\n\twhile (*r)\n\t{\n\t    if (*r == DLG_BUTTON_SEP)\n\t    {\n\t\tif (copy)\n\t\t{\n\t\t    *msgp++ = ',';\n\t\t    *msgp++ = ' ';\t    // '\\n' -> ', '\n\n\t\t    // advance to next hotkey and set default hotkey\n\t\t    if (has_mbyte)\n\t\t\thotkp += STRLEN(hotkp);\n\t\t    else\n\t\t\t++hotkp;\n\t\t    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;\n\t\t    if (dfltbutton)\n\t\t\t--dfltbutton;\n\n\t\t    // If no hotkey is specified first char is used.\n\t\t    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])\n\t\t\tfirst_hotkey = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    len += 3;\t\t    // '\\n' -> ', '; 'x' -> '(x)'\n\t\t    lenhotkey += HOTK_LEN;  // each button needs a hotkey\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[++idx] = FALSE;\n\t\t}\n\t    }\n\t    else if (*r == DLG_HOTKEY_CHAR || first_hotkey)\n\t    {\n\t\tif (*r == DLG_HOTKEY_CHAR)\n\t\t    ++r;\n\t\tfirst_hotkey = FALSE;\n\t\tif (copy)\n\t\t{\n\t\t    if (*r == DLG_HOTKEY_CHAR)\t\t// '&&a' -> '&a'\n\t\t\t*msgp++ = *r;\n\t\t    else\n\t\t    {\n\t\t\t// '&a' -> '[a]'\n\t\t\t*msgp++ = (dfltbutton == 1) ? '[' : '(';\n\t\t\tmsgp += copy_char(r, msgp, FALSE);\n\t\t\t*msgp++ = (dfltbutton == 1) ? ']' : ')';\n\n\t\t\t// redefine hotkey\n\t\t\thotkp[copy_char(r, hotkp, TRUE)] = NUL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++len;\t    // '&a' -> '[a]'\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[idx] = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// everything else copy literally\n\t\tif (copy)\n\t\t    msgp += copy_char(r, msgp, FALSE);\n\t    }\n\n\t    // advance to the next character\n\t    MB_PTR_ADV(r);\n\t}\n\n\tif (copy)\n\t{\n\t    *msgp++ = ':';\n\t    *msgp++ = ' ';\n\t    *msgp = NUL;\n\t}\n\telse\n\t{\n\t    len += (int)(STRLEN(message)\n\t\t\t+ 2\t\t\t// for the NL's\n\t\t\t+ STRLEN(buttons)\n\t\t\t+ 3);\t\t\t// for the \": \" and NUL\n\t    lenhotkey++;\t\t\t// for the NUL\n\n\t    // If no hotkey is specified first char is used.\n\t    if (!has_hotkey[0])\n\t    {\n\t\tfirst_hotkey = TRUE;\n\t\tlen += 2;\t\t// \"x\" -> \"[x]\"\n\t    }\n\n\t    /*\n\t     * Now allocate and load the strings\n\t     */\n\t    vim_free(confirm_msg);\n\t    confirm_msg = alloc(len);\n\t    if (confirm_msg == NULL)\n\t\treturn NULL;\n\t    *confirm_msg = NUL;\n\t    hotk = alloc(lenhotkey);\n\t    if (hotk == NULL)\n\t\treturn NULL;\n\n\t    *confirm_msg = '\\n';\n\t    STRCPY(confirm_msg + 1, message);\n\n\t    msgp = confirm_msg + 1 + STRLEN(message);\n\t    hotkp = hotk;\n\n\t    // Define first default hotkey.  Keep the hotkey string NUL\n\t    // terminated to avoid reading past the end.\n\t    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;\n\n\t    // Remember where the choices start, displaying starts here when\n\t    // \"hotkp\" typed at the more prompt.\n\t    confirm_msg_tail = msgp;\n\t    *msgp++ = '\\n';\n\t}\n    }\n\n    display_confirm_msg();\n    return hotk;\n}\n\n/*\n * Display the \":confirm\" message.  Also called when screen resized.\n */\n    static void\ndisplay_confirm_msg(void)\n{\n    // avoid that 'q' at the more prompt truncates the message here\n    ++confirm_msg_used;\n    if (confirm_msg != NULL)\n\tmsg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));\n    --confirm_msg_used;\n}\n\n#endif // FEAT_CON_DIALOG\n\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\n    int\nvim_dialog_yesno(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    if (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)\n\treturn VIM_YES;\n    return VIM_NO;\n}\n\n    int\nvim_dialog_yesnocancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n    }\n    return VIM_CANCEL;\n}\n\n    int\nvim_dialog_yesnoallcancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)\"Question\" : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),\n\t\t\t\t\t\t\t   dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n\tcase 3: return VIM_ALL;\n\tcase 4: return VIM_DISCARDALL;\n    }\n    return VIM_CANCEL;\n}\n\n#endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG\n", "\" Some tests, that used to crash Vim\nsource check.vim\nsource screendump.vim\n\nCheckScreendump\n\nfunc Test_crash1()\n  CheckNotBSD\n  CheckExecutable dash\n  \" Test 7 fails on Mac ...\n  CheckNotMac\n\n  \" The following used to crash Vim\n  let opts = #{cmd: 'sh'}\n  let vim  = GetVimProg()\n\n  let buf = RunVimInTerminal('sh', opts)\n\n  let file = 'crash/poc_huaf1'\n  let cmn_args = \"%s -u NONE -i NONE -n -e -s -S %s -c ':qa!'\"\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 1: [OK]\" > X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 50)\n\n  let file = 'crash/poc_huaf2'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 2: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 50)\n\n  let file = 'crash/poc_huaf3'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 3: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 100)\n\n  let file = 'crash/bt_quickfix_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 4: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  \" clean up\n  call delete('Xerr')\n  \" This test takes a bit longer\n  call TermWait(buf, 1000)\n\n  let file = 'crash/poc_tagfunc.vim'\n  let args = printf(cmn_args, vim, file)\n  \" using || because this poc causes vim to exit with exitstatus != 0\n  call term_sendkeys(buf, args ..\n    \\ '  || echo \"crash 5: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n\n  call TermWait(buf, 100)\n\n  let file = 'crash/bt_quickfix1_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 6: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  \" clean up\n  call delete('X')\n  call TermWait(buf, 3000)\n\n  let file = 'crash/vim_regsub_both_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 7: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 3000)\n\n  \" clean up\n  exe buf .. \"bw!\"\n\n  sp X_crash1_result.txt\n\n  let expected = [\n      \\ 'crash 1: [OK]',\n      \\ 'crash 2: [OK]',\n      \\ 'crash 3: [OK]',\n      \\ 'crash 4: [OK]',\n      \\ 'crash 5: [OK]',\n      \\ 'crash 6: [OK]',\n      \\ 'crash 7: [OK]',\n      \\ ]\n\n  call assert_equal(expected, getline(1, '$'))\n  bw!\n\n  call delete('X_crash1_result.txt')\nendfunc\n\nfunc Test_crash2()\n  \" The following used to crash Vim\n  let opts = #{wait_for_ruler: 0, rows: 20}\n  let args = ' -u NONE -i NONE -n -e -s -S '\n  let buf = RunVimInTerminal(args .. ' crash/vim_regsub_both', opts)\n  call VerifyScreenDump(buf, 'Test_crash_01', {})\n  exe buf .. \"bw!\"\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * message.c: functions for displaying messages on the command line\n */\n\n#define MESSAGE_FILE\t\t// don't include prototype for smsg()\n\n#include \"vim.h\"\n\nstatic void add_msg_hist(char_u *s, int len, int attr);\nstatic void hit_return_msg(void);\nstatic void msg_home_replace_attr(char_u *fname, int attr);\nstatic void msg_puts_attr_len(char *str, int maxlen, int attr);\nstatic void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);\nstatic void msg_scroll_up(void);\nstatic void inc_msg_scrolled(void);\nstatic void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish);\nstatic void t_puts(int *t_col, char_u *t_s, char_u *s, int attr);\nstatic void msg_puts_printf(char_u *str, int maxlen);\nstatic int do_more_prompt(int typed_char);\nstatic void msg_screen_putchar(int c, int attr);\nstatic void msg_moremsg(int full);\nstatic int  msg_check_screen(void);\nstatic void redir_write(char_u *s, int maxlen);\n#ifdef FEAT_CON_DIALOG\nstatic char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);\nstatic int\tconfirm_msg_used = FALSE;\t// displaying confirm_msg\nstatic char_u\t*confirm_msg = NULL;\t\t// \":confirm\" message\nstatic char_u\t*confirm_msg_tail;\t\t// tail of confirm_msg\nstatic void display_confirm_msg(void);\n#endif\n#ifdef FEAT_EVAL\nstatic int emsg_to_channel_log = FALSE;\n#endif\n\nstruct msg_hist\n{\n    struct msg_hist\t*next;\n    char_u\t\t*msg;\n    int\t\t\tattr;\n};\n\nstatic struct msg_hist *first_msg_hist = NULL;\nstatic struct msg_hist *last_msg_hist = NULL;\nstatic int msg_hist_len = 0;\n\nstatic FILE *verbose_fd = NULL;\nstatic int  verbose_did_open = FALSE;\n\n/*\n * When writing messages to the screen, there are many different situations.\n * A number of variables is used to remember the current state:\n * msg_didany\t    TRUE when messages were written since the last time the\n *\t\t    user reacted to a prompt.\n *\t\t    Reset: After hitting a key for the hit-return prompt,\n *\t\t    hitting <CR> for the command line or input().\n *\t\t    Set: When any message is written to the screen.\n * msg_didout\t    TRUE when something was written to the current line.\n *\t\t    Reset: When advancing to the next line, when the current\n *\t\t    text can be overwritten.\n *\t\t    Set: When any message is written to the screen.\n * msg_nowait\t    No extra delay for the last drawn message.\n *\t\t    Used in normal_cmd() before the mode message is drawn.\n * emsg_on_display  There was an error message recently.  Indicates that there\n *\t\t    should be a delay before redrawing.\n * msg_scroll\t    The next message should not overwrite the current one.\n * msg_scrolled\t    How many lines the screen has been scrolled (because of\n *\t\t    messages).  Used in update_screen() to scroll the screen\n *\t\t    back.  Incremented each time the screen scrolls a line.\n * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()\n *\t\t    writes something without scrolling should not make\n *\t\t    need_wait_return to be set.  This is a hack to make \":ts\"\n *\t\t    work without an extra prompt.\n * lines_left\t    Number of lines available for messages before the\n *\t\t    more-prompt is to be given.  -1 when not set.\n * need_wait_return TRUE when the hit-return prompt is needed.\n *\t\t    Reset: After giving the hit-return prompt, when the user\n *\t\t    has answered some other prompt.\n *\t\t    Set: When the ruler or typeahead display is overwritten,\n *\t\t    scrolling the screen for some message.\n * keep_msg\t    Message to be displayed after redrawing the screen, in\n *\t\t    main_loop().\n *\t\t    This is an allocated string or NULL when not used.\n */\n\n/*\n * msg(s) - displays the string 's' on the status line\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n * return TRUE if wait_return() not called\n */\n    int\nmsg(char *s)\n{\n    return msg_attr_keep(s, 0, FALSE);\n}\n\n/*\n * Like msg() but keep it silent when 'verbosefile' is set.\n */\n    int\nverb_msg(char *s)\n{\n    int\t\tn;\n\n    verbose_enter();\n    n = msg_attr_keep(s, 0, FALSE);\n    verbose_leave();\n\n    return n;\n}\n\n    int\nmsg_attr(char *s, int attr)\n{\n    return msg_attr_keep(s, attr, FALSE);\n}\n\n    int\nmsg_attr_keep(\n    char\t*s,\n    int\t\tattr,\n    int\t\tkeep)\t    // TRUE: set keep_msg if it doesn't scroll\n{\n    static int\tentered = 0;\n    int\t\tretval;\n    char_u\t*buf = NULL;\n\n    // Skip messages not matching \":filter pattern\".\n    // Don't filter when there is an error.\n    if (!emsg_on_display && message_filtered((char_u *)s))\n\treturn TRUE;\n\n#ifdef FEAT_EVAL\n    if (attr == 0)\n\tset_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);\n#endif\n\n    /*\n     * It is possible that displaying a messages causes a problem (e.g.,\n     * when redrawing the window), which causes another message, etc..\tTo\n     * break this loop, limit the recursiveness to 3 levels.\n     */\n    if (entered >= 3)\n\treturn TRUE;\n    ++entered;\n\n    // Add message to history (unless it's a repeated kept message or a\n    // truncated message)\n    if ((char_u *)s != keep_msg\n\t    || (*s != '<'\n\t\t&& last_msg_hist != NULL\n\t\t&& last_msg_hist->msg != NULL\n\t\t&& STRCMP(s, last_msg_hist->msg)))\n\tadd_msg_hist((char_u *)s, -1, attr);\n\n#ifdef FEAT_EVAL\n    if (emsg_to_channel_log)\n\t// Write message in the channel log.\n\tch_log(NULL, \"ERROR: %s\", s);\n#endif\n\n    // Truncate the message if needed.\n    msg_start();\n    buf = msg_strtrunc((char_u *)s, FALSE);\n    if (buf != NULL)\n\ts = (char *)buf;\n\n    msg_outtrans_attr((char_u *)s, attr);\n    msg_clr_eos();\n    retval = msg_end();\n\n    if (keep && retval && vim_strsize((char_u *)s)\n\t\t\t    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)\n\tset_keep_msg((char_u *)s, 0);\n\n    need_fileinfo = FALSE;\n\n    vim_free(buf);\n    --entered;\n    return retval;\n}\n\n/*\n * Truncate a string such that it can be printed without causing a scroll.\n * Returns an allocated string or NULL when no truncating is done.\n */\n    char_u *\nmsg_strtrunc(\n    char_u\t*s,\n    int\t\tforce)\t    // always truncate\n{\n    char_u\t*buf = NULL;\n    int\t\tlen;\n    int\t\troom;\n\n    // May truncate message to avoid a hit-return prompt\n    if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)\n\t\t\t       && !exmode_active && msg_silent == 0) || force)\n    {\n\tlen = vim_strsize(s);\n\tif (msg_scrolled != 0\n#ifdef HAS_MESSAGE_WINDOW\n\t\t|| in_echowindow\n#endif\n\t\t)\n\t    // Use all the columns.\n\t    room = (int)(Rows - msg_row) * Columns - 1;\n\telse\n\t    // Use up to 'showcmd' column.\n\t    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\tif (len > room && room > 0)\n\t{\n\t    if (enc_utf8)\n\t\t// may have up to 18 bytes per cell (6 per char, up to two\n\t\t// composing chars)\n\t\tlen = (room + 2) * 18;\n\t    else if (enc_dbcs == DBCS_JPNU)\n\t\t// may have up to 2 bytes per cell for euc-jp\n\t\tlen = (room + 2) * 2;\n\t    else\n\t\tlen = room + 2;\n\t    buf = alloc(len);\n\t    if (buf != NULL)\n\t\ttrunc_string(s, buf, room, len);\n\t}\n    }\n    return buf;\n}\n\n/*\n * Truncate a string \"s\" to \"buf\" with cell width \"room\".\n * \"s\" and \"buf\" may be equal.\n */\n    void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[buflen - 1] = NUL;\n    }\n}\n\n/*\n * Automatic prototype generation does not understand this function.\n * Note: Caller of smsg() and smsg_attr() must check the resulting string is\n * shorter than IOSIZE!!!\n */\n#ifndef PROTO\n\nint vim_snprintf(char *str, size_t str_m, const char *fmt, ...);\n\n    int\nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n\n    va_list arglist;\n\n    va_start(arglist, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n    va_end(arglist);\n    return msg((char *)IObuff);\n}\n\n    int\nsmsg_attr(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr((char *)s, attr);\n    }\n\n    va_list arglist;\n\n    va_start(arglist, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n    va_end(arglist);\n    return msg_attr((char *)IObuff, attr);\n}\n\n    int\nsmsg_attr_keep(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr_keep((char *)s, attr, TRUE);\n    }\n\n    va_list arglist;\n\n    va_start(arglist, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n    va_end(arglist);\n    return msg_attr_keep((char *)IObuff, attr, TRUE);\n}\n\n#endif\n\n/*\n * Remember the last sourcing name/lnum used in an error message, so that it\n * isn't printed each time when it didn't change.\n */\nstatic int\tlast_sourcing_lnum = 0;\nstatic char_u   *last_sourcing_name = NULL;\n\n/*\n * Reset the last used sourcing name/lnum.  Makes sure it is displayed again\n * for the next error message;\n */\n    void\nreset_last_sourcing(void)\n{\n    VIM_CLEAR(last_sourcing_name);\n    last_sourcing_lnum = 0;\n}\n\n/*\n * Return TRUE if \"SOURCING_NAME\" differs from \"last_sourcing_name\".\n */\n    static int\nother_sourcing_name(void)\n{\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL)\n    {\n\tif (last_sourcing_name != NULL)\n\t    return STRCMP(SOURCING_NAME, last_sourcing_name) != 0;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Get the message about the source, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_source(void)\n{\n    char_u\t*Buf, *p;\n\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL && other_sourcing_name())\n    {\n\tchar_u\t    *sname = estack_sfile(ESTACK_NONE);\n\tchar_u\t    *tofree = sname;\n\n\tif (sname == NULL)\n\t    sname = SOURCING_NAME;\n\n#ifdef FEAT_EVAL\n\tif (estack_compiling)\n\t    p = (char_u *)_(\"Error detected while compiling %s:\");\n\telse\n#endif\n\t    p = (char_u *)_(\"Error detected while processing %s:\");\n\tBuf = alloc(STRLEN(sname) + STRLEN(p));\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, sname);\n\tvim_free(tofree);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Get the message about the source lnum, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_lnum(void)\n{\n    char_u\t*Buf, *p;\n\n    // lnum is 0 when executing a command from the command line\n    // argument, we don't want a line number then\n    if (SOURCING_NAME != NULL\n\t    && (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)\n\t    && SOURCING_LNUM != 0)\n    {\n\tp = (char_u *)_(\"line %4ld:\");\n\tBuf = alloc(STRLEN(p) + 20);\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, (long)SOURCING_LNUM);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Display name and line number for the source of an error.\n * Remember the file name and line number, so that for the next error the info\n * is only displayed if it changed.\n */\n    void\nmsg_source(int attr)\n{\n    char_u\t*p;\n    static int\trecursive = FALSE;\n\n    // Bail out if something called here causes an error.\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n\n    ++no_wait_return;\n    p = get_emsg_source();\n    if (p != NULL)\n    {\n\tmsg_scroll = TRUE;  // this will take more than one line\n\tmsg_attr((char *)p, attr);\n\tvim_free(p);\n    }\n    p = get_emsg_lnum();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, HL_ATTR(HLF_N));\n\tvim_free(p);\n\tlast_sourcing_lnum = SOURCING_LNUM;  // only once for each line\n    }\n\n    // remember the last sourcing name printed, also when it's empty\n    if (SOURCING_NAME == NULL || other_sourcing_name())\n    {\n\tVIM_CLEAR(last_sourcing_name);\n\tif (SOURCING_NAME != NULL)\n\t    last_sourcing_name = vim_strsave(SOURCING_NAME);\n    }\n    --no_wait_return;\n\n    recursive = FALSE;\n}\n\n/*\n * Return TRUE if not giving error messages right now:\n * If \"emsg_off\" is set: no error messages at the moment.\n * If \"msg\" is in 'debug': do error message but without side effects.\n * If \"emsg_skip\" is set: never do error messages.\n */\n    static int\nemsg_not_now(void)\n{\n    if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL\n\t\t\t\t\t  && vim_strchr(p_debug, 't') == NULL)\n#ifdef FEAT_EVAL\n\t    || emsg_skip > 0\n#endif\n\t    )\n\treturn TRUE;\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic garray_T ignore_error_list = GA_EMPTY;\n\n    void\nignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_copy_string(&ignore_error_list, error);\n}\n\n    static int\nignore_error(const char *msg)\n{\n    int i;\n\n    for (i = 0; i < ignore_error_list.ga_len; ++i)\n\tif (strstr(msg,\n\t\t  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n#if !defined(HAVE_STRERROR) || defined(PROTO)\n/*\n * Replacement for perror() that behaves more or less like emsg() was called.\n * v:errmsg will be set and called_emsg will be incremented.\n */\n    void\ndo_perror(char *msg)\n{\n    perror(msg);\n    ++emsg_silent;\n    emsg(msg);\n    --emsg_silent;\n}\n#endif\n\n/*\n * emsg_core() - display an error message\n *\n * Rings the bell, if appropriate, and calls message() to do the real work\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n *\n * Return TRUE if wait_return() not called.\n * Note: caller must check 'emsg_not_now()' before calling this.\n */\n    static int\nemsg_core(const char *s)\n{\n    int\t\tattr;\n    char_u\t*p;\n    int\t\tr;\n#ifdef FEAT_EVAL\n    int\t\tignore = FALSE;\n    int\t\tsevere;\n#endif\n\n#ifdef FEAT_EVAL\n    // When testing some errors are turned into a normal message.\n    if (ignore_error(s))\n\t// don't call msg() if it results in a dialog\n\treturn msg_use_printf() ? FALSE : msg((char *)s);\n#endif\n\n    ++called_emsg;\n\n#ifdef FEAT_EVAL\n    // If \"emsg_severe\" is TRUE: When an error exception is to be thrown,\n    // prefer this message over previous messages for the same command.\n    severe = emsg_severe;\n    emsg_severe = FALSE;\n#endif\n\n    if (!emsg_off || vim_strchr(p_debug, 't') != NULL)\n    {\n#ifdef FEAT_EVAL\n\t/*\n\t * Cause a throw of an error exception if appropriate.  Don't display\n\t * the error message in this case.  (If no matching catch clause will\n\t * be found, the message will be displayed later on.)  \"ignore\" is set\n\t * when the message should be ignored completely (used for the\n\t * interrupt message).\n\t */\n\tif (cause_errthrow((char_u *)s, severe, &ignore) == TRUE)\n\t{\n\t    if (!ignore)\n\t\t++did_emsg;\n\t    return TRUE;\n\t}\n\n\tif (in_assert_fails && emsg_assert_fails_msg == NULL)\n\t{\n\t    emsg_assert_fails_msg = vim_strsave((char_u *)s);\n\t    emsg_assert_fails_lnum = SOURCING_LNUM;\n\t    vim_free(emsg_assert_fails_context);\n\t    emsg_assert_fails_context = vim_strsave(\n\t\t\t SOURCING_NAME == NULL ? (char_u *)\"\" : SOURCING_NAME);\n\t}\n\n\t// set \"v:errmsg\", also when using \":silent! cmd\"\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n#endif\n\n\t/*\n\t * When using \":silent! cmd\" ignore error messages.\n\t * But do write it to the redirection file.\n\t */\n\tif (emsg_silent != 0)\n\t{\n#ifdef FEAT_EVAL\n\t    ++did_emsg_silent;\n#endif\n\t    if (emsg_noredir == 0)\n\t    {\n\t\tmsg_start();\n\t\tp = get_emsg_source();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tp = get_emsg_lnum();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tredir_write((char_u *)s, -1);\n\t    }\n#ifdef FEAT_EVAL\n\t    // Only increment did_emsg_def when :silent! wasn't used inside the\n\t    // :def function.\n\t    if (emsg_silent == emsg_silent_def)\n\t\t++did_emsg_def;\n#endif\n#ifdef FEAT_EVAL\n\t    ch_log(NULL, \"ERROR silent: %s\", s);\n#endif\n\t    return TRUE;\n\t}\n\n\tex_exitval = 1;\n\n\t// Reset msg_silent, an error causes messages to be switched back on.\n\tmsg_silent = 0;\n\tcmd_silent = FALSE;\n\n\tif (global_busy)\t\t// break :global command\n\t    ++global_busy;\n\n\tif (p_eb)\n\t    beep_flush();\t\t// also includes flush_buffers()\n\telse\n\t    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers\n\t++did_emsg;\t\t\t   // flag for DoOneCmd()\n#ifdef FEAT_EVAL\n\t++uncaught_emsg;\n#endif\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (!in_echowindow)\n#endif\n\temsg_on_display = TRUE;\t    // remember there is an error message\n\n    attr = HL_ATTR(HLF_E);\t    // set highlight mode for error messages\n    if (msg_scrolled != 0)\n\tneed_wait_return = TRUE;    // needed in case emsg() is called after\n\t\t\t\t    // wait_return() has reset need_wait_return\n\t\t\t\t    // and a redraw is expected because\n\t\t\t\t    // msg_scrolled is non-zero\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = TRUE;\n#endif\n    /*\n     * Display name and line number for the source of the error.\n     */\n    msg_scroll = TRUE;\n    msg_source(attr);\n\n    /*\n     * Display the error message itself.\n     */\n    msg_nowait = FALSE;\t\t\t// wait for this msg\n    r = msg_attr((char *)s, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = FALSE;\n#endif\n    return r;\n}\n\n/*\n * Print error message \"s\".  Should already be translated.\n * Return TRUE if wait_return() not called.\n */\n    int\nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (emsg_not_now())\n\treturn TRUE;\n\n    return emsg_core(s);\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Print error message \"s\" with format string and variable arguments.\n * \"s\" should already be translated.\n * Note: caller must not use \"IObuff\" for \"s\"!\n * Return TRUE if wait_return() not called.\n */\n    int\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (emsg_not_now())\n\treturn TRUE;\n\n    if (IObuff == NULL)\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn emsg_core(s);\n\n    va_list ap;\n\n    va_start(ap, s);\n    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n    va_end(ap);\n    return emsg_core((char *)IObuff);\n}\n#endif\n\n/*\n * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n */\n    void\niemsg(char *s)\n{\n    if (emsg_not_now())\n\treturn;\n\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    emsg_core(s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n    set_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n    msg_putchar('\\n');  // avoid overwriting the error message\n    out_flush();\n    abort();\n#endif\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    void\nsiemsg(const char *s, ...)\n{\n    if (emsg_not_now())\n\treturn;\n\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\temsg_core(s);\n    }\n    else\n    {\n\tva_list ap;\n\n\tva_start(ap, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\tva_end(ap);\n\temsg_core((char *)IObuff);\n    }\n# ifdef ABORT_ON_INTERNAL_ERROR\n    msg_putchar('\\n');  // avoid overwriting the error message\n    out_flush();\n    abort();\n# endif\n}\n#endif\n\n/*\n * Give an \"Internal error\" message.\n */\n    void\ninternal_error(char *where)\n{\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    siemsg(_(e_internal_error_str), where);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Like internal_error() but do not call abort(), to avoid tests using\n * test_unknown() and test_void() causing Vim to exit.\n */\n    void\ninternal_error_no_abort(char *where)\n{\n    // Give a generic error which is translated.  The error itself may not be\n    // translated, it almost never shows.\n    emsg_core(_(e_internal_error_please_report_a_bug));\n\n    semsg(_(e_internal_error_str), where);\n}\n#endif\n\n// emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.\n\n    void\nemsg_invreg(int name)\n{\n    semsg(_(e_invalid_register_name_str), transchar_buf(NULL, name));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Give an error message which contains %s for \"name[len]\".\n */\n    void\nemsg_namelen(char *msg, char_u *name, int len)\n{\n    char_u *copy = vim_strnsave(name, len);\n\n    semsg(msg, copy == NULL ? \"NULL\" : (char *)copy);\n    vim_free(copy);\n}\n#endif\n\n/*\n * Like msg(), but truncate to a single line if p_shm contains 't', or when\n * \"force\" is TRUE.  This truncates in another way as for normal messages.\n * Careful: The string may be changed by msg_may_trunc()!\n * Returns a pointer to the printed message, if wait_return() not called.\n */\n    char *\nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n\n/*\n * Check if message \"s\" should be truncated at the start (for filenames).\n * Return a pointer to where the truncated message starts.\n * Note: May change the message by replacing a character with '<'.\n */\n    char_u *\nmsg_may_trunc(int force, char_u *s)\n{\n    int\t\tn;\n    int\t\troom;\n\n    // If 'cmdheight' is zero or something unexpected happened \"room\" may be\n    // negative.\n    room = (int)(Rows - cmdline_row - 1) * Columns + sc_col - 1;\n    if (room > 0 && (force || (shortmess(SHM_TRUNC) && !exmode_active))\n\t    && (n = (int)STRLEN(s) - room) > 0)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tsize = vim_strsize(s);\n\n\t    // There may be room anyway when there are multibyte chars.\n\t    if (size <= room)\n\t\treturn s;\n\n\t    for (n = 0; size >= room; )\n\t    {\n\t\tsize -= (*mb_ptr2cells)(s + n);\n\t\tn += (*mb_ptr2len)(s + n);\n\t    }\n\t    --n;\n\t}\n\ts += n;\n\t*s = '<';\n    }\n    return s;\n}\n\n    static void\nadd_msg_hist(\n    char_u\t*s,\n    int\t\tlen,\t\t// -1 for undetermined length\n    int\t\tattr)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_off || msg_silent != 0)\n\treturn;\n\n    // Don't let the message history get too big\n    while (msg_hist_len > MAX_MSG_HIST_LEN)\n\t(void)delete_first_msg();\n\n    // allocate an entry and add the message at the end of the history\n    p = ALLOC_ONE(struct msg_hist);\n    if (p == NULL)\n\treturn;\n\n    if (len < 0)\n\tlen = (int)STRLEN(s);\n    // remove leading and trailing newlines\n    while (len > 0 && *s == '\\n')\n    {\n\t++s;\n\t--len;\n    }\n    while (len > 0 && s[len - 1] == '\\n')\n\t--len;\n    p->msg = vim_strnsave(s, len);\n    p->next = NULL;\n    p->attr = attr;\n    if (last_msg_hist != NULL)\n\tlast_msg_hist->next = p;\n    last_msg_hist = p;\n    if (first_msg_hist == NULL)\n\tfirst_msg_hist = last_msg_hist;\n    ++msg_hist_len;\n}\n\n/*\n * Delete the first (oldest) message from the history.\n * Returns FAIL if there are no messages.\n */\n    int\ndelete_first_msg(void)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_len <= 0)\n\treturn FAIL;\n    p = first_msg_hist;\n    first_msg_hist = p->next;\n    if (first_msg_hist == NULL)\n\tlast_msg_hist = NULL;  // history is empty\n    vim_free(p->msg);\n    vim_free(p);\n    --msg_hist_len;\n    return OK;\n}\n\n/*\n * \":messages\" command.\n */\n    void\nex_messages(exarg_T *eap)\n{\n    struct msg_hist *p;\n    char_u\t    *s;\n    int\t\t    c = 0;\n\n    if (STRCMP(eap->arg, \"clear\") == 0)\n    {\n\tint keep = eap->addr_count == 0 ? 0 : eap->line2;\n\n\twhile (msg_hist_len > keep)\n\t    (void)delete_first_msg();\n\treturn;\n    }\n\n    if (*eap->arg != NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    msg_hist_off = TRUE;\n\n    p = first_msg_hist;\n    if (eap->addr_count != 0)\n    {\n\t// Count total messages\n\tfor (; p != NULL && !got_int; p = p->next)\n\t    c++;\n\n\tc -= eap->line2;\n\n\t// Skip without number of messages specified\n\tfor (p = first_msg_hist; p != NULL && !got_int && c > 0;\n\t\t\t\t\t\t    p = p->next, c--);\n    }\n\n    if (p == first_msg_hist)\n    {\n#ifdef FEAT_MULTI_LANG\n\ts = get_mess_lang();\n#else\n\ts = mch_getenv((char_u *)\"LANG\");\n#endif\n\tif (s != NULL && *s != NUL)\n\t    // The next comment is extracted by xgettext and put in po file for\n\t    // translators to read.\n\t    msg_attr(\n\t\t    // Translator: Please replace the name and email address\n\t\t    // with the appropriate text for your translation.\n\t\t    _(\"Messages maintainer: The Vim Project\"),\n\t\t    HL_ATTR(HLF_T));\n    }\n\n    // Display what was not skipped.\n    for (; p != NULL && !got_int; p = p->next)\n\tif (p->msg != NULL)\n\t    msg_attr((char *)p->msg, p->attr);\n\n    msg_hist_off = FALSE;\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(FIND_REPLACE_DIALOG) || defined(PROTO)\n/*\n * Call this after prompting the user.  This will avoid a hit-return message\n * and a delay.\n */\n    void\nmsg_end_prompt(void)\n{\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    cmdline_row = msg_row;\n    msg_col = 0;\n    msg_clr_eos();\n    lines_left = -1;\n}\n#endif\n\n/*\n * Wait for the user to hit a key (normally Enter).\n * If \"redraw\" is TRUE, clear and redraw the screen.\n * If \"redraw\" is FALSE, just redraw the screen.\n * If \"redraw\" is -1, don't redraw at all.\n */\n    void\nwait_return(int redraw)\n{\n    int\t\tc;\n    int\t\toldState;\n    int\t\ttmpState;\n    int\t\thad_got_int;\n    int\t\tsave_reg_recording;\n    FILE\t*save_scriptout;\n\n    if (redraw == TRUE)\n\tset_must_redraw(UPD_CLEAR);\n\n    // If using \":silent cmd\", don't wait for a return.  Also don't set\n    // need_wait_return to do it later.\n    if (msg_silent != 0)\n\treturn;\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n\n    /*\n     * When inside vgetc(), we can't wait for a typed character at all.\n     * With the global command (and some others) we only need one return at\n     * the end. Adjust cmdline_row to avoid the next message overwriting the\n     * last one.\n     */\n    if (vgetc_busy > 0)\n\treturn;\n    need_wait_return = TRUE;\n    if (no_wait_return)\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\treturn;\n    }\n\n    redir_off = TRUE;\t\t// don't redirect this message\n    oldState = State;\n    if (quit_more)\n    {\n\tc = CAR;\t\t// just pretend CR was hit\n\tquit_more = FALSE;\n\tgot_int = FALSE;\n    }\n    else if (exmode_active)\n    {\n\tmsg_puts(\" \");\t\t// make sure the cursor is on the right line\n\tc = CAR;\t\t// no need for a return in ex mode\n\tgot_int = FALSE;\n    }\n    else\n    {\n\t// Make sure the hit-return prompt is on screen when 'guioptions' was\n\t// just changed.\n\tscreenalloc(FALSE);\n\n\tState = MODE_HITRETURN;\n\tsetmouse();\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\tcmdline_row = msg_row;\n\n\t// Avoid the sequence that the user types \":\" at the hit-return prompt\n\t// to start an Ex command, but the file-changed dialog gets in the\n\t// way.\n\tif (need_check_timestamps)\n\t    check_timestamps(FALSE);\n\n\thit_return_msg();\n\n\tdo\n\t{\n\t    // Remember \"got_int\", if it is set vgetc() probably returns a\n\t    // CTRL-C, but we need to loop then.\n\t    had_got_int = got_int;\n\n\t    // Don't do mappings here, we put the character back in the\n\t    // typeahead buffer.\n\t    ++no_mapping;\n\t    ++allow_keys;\n\n\t    // Temporarily disable Recording. If Recording is active, the\n\t    // character will be recorded later, since it will be added to the\n\t    // typebuf after the loop\n\t    save_reg_recording = reg_recording;\n\t    save_scriptout = scriptout;\n\t    reg_recording = 0;\n\t    scriptout = NULL;\n\t    c = safe_vgetc();\n\t    if (had_got_int && !global_busy)\n\t\tgot_int = FALSE;\n\t    --no_mapping;\n\t    --allow_keys;\n\t    reg_recording = save_reg_recording;\n\t    scriptout = save_scriptout;\n\n#ifdef FEAT_CLIPBOARD\n\t    // Strange way to allow copying (yanking) a modeless selection at\n\t    // the hit-enter prompt.  Use CTRL-Y, because the same is used in\n\t    // Cmdline-mode and it's harmless when there is no selection.\n\t    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)\n\t    {\n\t\tclip_copy_modeless_selection(TRUE);\n\t\tc = K_IGNORE;\n\t    }\n#endif\n\n\t    /*\n\t     * Allow scrolling back in the messages.\n\t     * Also accept scroll-down commands when messages fill the screen,\n\t     * to avoid that typing one 'j' too many makes the messages\n\t     * disappear.\n\t     */\n\t    if (p_more && !p_cp)\n\t    {\n\t\tif (c == 'b' || c == 'k' || c == 'u' || c == 'g'\n\t\t\t\t\t\t|| c == K_UP || c == K_PAGEUP)\n\t\t{\n\t\t    if (msg_scrolled > Rows)\n\t\t\t// scroll back to show older messages\n\t\t\tdo_more_prompt(c);\n\t\t    else\n\t\t    {\n\t\t\tmsg_didout = FALSE;\n\t\t\tc = K_IGNORE;\n\t\t\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t\t\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t\t\t    0;\n\t\t    }\n\t\t    if (quit_more)\n\t\t    {\n\t\t\tc = CAR;\t\t// just pretend CR was hit\n\t\t\tquit_more = FALSE;\n\t\t\tgot_int = FALSE;\n\t\t    }\n\t\t    else if (c != K_IGNORE)\n\t\t    {\n\t\t\tc = K_IGNORE;\n\t\t\thit_return_msg();\n\t\t    }\n\t\t}\n\t\telse if (msg_scrolled > Rows - 2\n\t\t\t && (c == 'j' || c == 'd' || c == 'f'\n\t\t\t\t\t   || c == K_DOWN || c == K_PAGEDOWN))\n\t\t    c = K_IGNORE;\n\t    }\n\t} while ((had_got_int && c == Ctrl_C)\n\t\t\t\t|| c == K_IGNORE\n#ifdef FEAT_GUI\n\t\t\t\t|| c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n#endif\n\t\t\t\t|| c == K_LEFTDRAG   || c == K_LEFTRELEASE\n\t\t\t\t|| c == K_MIDDLEDRAG || c == K_MIDDLERELEASE\n\t\t\t\t|| c == K_RIGHTDRAG  || c == K_RIGHTRELEASE\n\t\t\t\t|| c == K_MOUSELEFT  || c == K_MOUSERIGHT\n\t\t\t\t|| c == K_MOUSEDOWN  || c == K_MOUSEUP\n\t\t\t\t|| c == K_MOUSEMOVE\n\t\t\t\t|| (!mouse_has(MOUSE_RETURN)\n\t\t\t\t    && mouse_row < msg_row\n\t\t\t\t    && (c == K_LEFTMOUSE\n\t\t\t\t\t|| c == K_MIDDLEMOUSE\n\t\t\t\t\t|| c == K_RIGHTMOUSE\n\t\t\t\t\t|| c == K_X1MOUSE\n\t\t\t\t\t|| c == K_X2MOUSE))\n\t\t\t\t);\n\tui_breakcheck();\n\n\t// Avoid that the mouse-up event causes Visual mode to start.\n\tif (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE\n\t\t\t\t\t  || c == K_X1MOUSE || c == K_X2MOUSE)\n\t    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);\n\telse if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C)\n\t{\n\t    // Put the character back in the typeahead buffer.  Don't use the\n\t    // stuff buffer, because lmaps wouldn't work.\n\t    ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\t    do_redraw = TRUE;\t    // need a redraw even though there is\n\t\t\t\t    // typeahead\n\t}\n    }\n    redir_off = FALSE;\n\n    /*\n     * If the user hits ':', '?' or '/' we get a command line from the next\n     * line.\n     */\n    if (c == ':' || c == '?' || c == '/')\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\tskip_redraw = TRUE;\t    // skip redraw once\n\tdo_redraw = FALSE;\n#ifdef FEAT_TERMINAL\n\tskip_term_loop = TRUE;\n#endif\n    }\n\n    /*\n     * If the window size changed set_shellsize() will redraw the screen.\n     * Otherwise the screen is only redrawn if 'redraw' is set and no ':'\n     * typed.\n     */\n    tmpState = State;\n    State = oldState;\t\t    // restore State before set_shellsize\n    setmouse();\n    msg_check();\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * When switching screens, we need to output an extra newline on exit.\n     */\n    if (swapping_screen() && !termcap_active)\n\tnewline_on_exit = TRUE;\n#endif\n\n    need_wait_return = FALSE;\n    did_wait_return = TRUE;\n    emsg_on_display = FALSE;\t// can delete error message now\n    lines_left = -1;\t\t// reset lines_left at next msg_start()\n    reset_last_sourcing();\n    if (keep_msg != NULL && vim_strsize(keep_msg) >=\n\t\t\t\t  (Rows - cmdline_row - 1) * Columns + sc_col)\n\tVIM_CLEAR(keep_msg);\t    // don't redisplay message, it's too long\n\n    if (tmpState == MODE_SETWSIZE)  // got resize event while in vgetc()\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tshell_resized();\n    }\n    else if (!skip_redraw\n\t    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tredraw_later(UPD_VALID);\n    }\n}\n\n/*\n * Write the hit-return prompt.\n */\n    static void\nhit_return_msg(void)\n{\n    int\t\tsave_p_more = p_more;\n\n    p_more = FALSE;\t// don't want to see this message when scrolling back\n    if (msg_didout)\t// start on a new line\n\tmsg_putchar('\\n');\n    if (got_int)\n\tmsg_puts(_(\"Interrupt: \"));\n\n    msg_puts_attr(_(\"Press ENTER or type command to continue\"), HL_ATTR(HLF_R));\n    if (!msg_use_printf())\n\tmsg_clr_eos();\n    p_more = save_p_more;\n}\n\n/*\n * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer.\n */\n    void\nset_keep_msg(char_u *s, int attr)\n{\n    vim_free(keep_msg);\n    if (s != NULL && msg_silent == 0)\n\tkeep_msg = vim_strsave(s);\n    else\n\tkeep_msg = NULL;\n    keep_msg_more = FALSE;\n    keep_msg_attr = attr;\n}\n\n/*\n * If there currently is a message being displayed, set \"keep_msg\" to it, so\n * that it will be displayed again after redraw.\n */\n    void\nset_keep_msg_from_hist(void)\n{\n    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0\n\t\t\t\t\t\t      && (State & MODE_NORMAL))\n\tset_keep_msg(last_msg_hist->msg, last_msg_hist->attr);\n}\n\n/*\n * Prepare for outputting characters in the command line.\n */\n    void\nmsg_start(void)\n{\n    int\t\tdid_return = FALSE;\n\n    if (!msg_silent)\n    {\n\tVIM_CLEAR(keep_msg);\n\tneed_fileinfo = FALSE;\n    }\n\n#ifdef FEAT_EVAL\n    if (need_clr_eos)\n    {\n\t// Halfway an \":echo\" command and getting an (error) message: clear\n\t// any text from the command.\n\tneed_clr_eos = FALSE;\n\tmsg_clr_eos();\n    }\n#endif\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n    {\n\tif (popup_message_win_visible()\n\t\t    && ((msg_col > 0 && (msg_scroll || !full_screen))\n\t\t\t|| in_echowindow))\n\t{\n\t    win_T *wp = popup_get_message_win();\n\n\t    // start a new line\n\t    curbuf = wp->w_buffer;\n\t    ml_append(wp->w_buffer->b_ml.ml_line_count,\n\t\t\t\t\t      (char_u *)\"\", (colnr_T)0, FALSE);\n\t    curbuf = curwin->w_buffer;\n\t}\n\tmsg_col = 0;\n    }\n    else\n#endif\n\tif (!msg_scroll && full_screen)\t// overwrite last message\n    {\n\tmsg_row = cmdline_row;\n\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t    0;\n    }\n    else if (msg_didout || in_echowindow)\n    {\n\t// start message on next line\n\tmsg_putchar('\\n');\n\tdid_return = TRUE;\n\tif (exmode_active != EXMODE_NORMAL)\n\t    cmdline_row = msg_row;\n    }\n    if (!msg_didany || lines_left < 0)\n\tmsg_starthere();\n    if (msg_silent == 0)\n    {\n\tmsg_didout = FALSE;\t\t    // no output on current line yet\n\tcursor_off();\n    }\n\n    // when redirecting, may need to start a new line.\n    if (!did_return)\n\tredir_write((char_u *)\"\\n\", -1);\n}\n\n/*\n * Note that the current msg position is where messages start.\n */\n    void\nmsg_starthere(void)\n{\n    lines_left = cmdline_row;\n    msg_didany = FALSE;\n}\n\n    void\nmsg_putchar(int c)\n{\n    msg_putchar_attr(c, 0);\n}\n\n    void\nmsg_putchar_attr(int c, int attr)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    msg_puts_attr((char *)buf, attr);\n}\n\n    void\nmsg_outnum(long n)\n{\n    char\tbuf[20];\n\n    sprintf(buf, \"%ld\", n);\n    msg_puts(buf);\n}\n\n    void\nmsg_home_replace(char_u *fname)\n{\n    msg_home_replace_attr(fname, 0);\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n    void\nmsg_home_replace_hl(char_u *fname)\n{\n    msg_home_replace_attr(fname, HL_ATTR(HLF_D));\n}\n#endif\n\n    static void\nmsg_home_replace_attr(char_u *fname, int attr)\n{\n    char_u\t*name;\n\n    name = home_replace_save(NULL, fname);\n    if (name != NULL)\n\tmsg_outtrans_attr(name, attr);\n    vim_free(name);\n}\n\n/*\n * Output 'len' characters in 'str' (including NULs) with translation\n * if 'len' is -1, output up to a NUL character.\n * Use attributes 'attr'.\n * Return the number of characters it takes on the screen.\n */\n    int\nmsg_outtrans(char_u *str)\n{\n    return msg_outtrans_attr(str, 0);\n}\n\n    int\nmsg_outtrans_attr(char_u *str, int attr)\n{\n    return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);\n}\n\n    int\nmsg_outtrans_len(char_u *str, int len)\n{\n    return msg_outtrans_len_attr(str, len, 0);\n}\n\n/*\n * Output one character at \"p\".  Return pointer to the next character.\n * Handles multi-byte characters.\n */\n    char_u *\nmsg_outtrans_one(char_u *p, int attr)\n{\n    int\t\tl;\n\n    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n    {\n\tmsg_outtrans_len_attr(p, l, attr);\n\treturn p + l;\n    }\n    msg_puts_attr((char *)transchar_byte_buf(NULL, *p), attr);\n    return p + 1;\n}\n\n    int\nmsg_outtrans_len_attr(char_u *msgstr, int len, int attr)\n{\n    int\t\tretval = 0;\n    char_u\t*str = msgstr;\n    char_u\t*plain_start = msgstr;\n    char_u\t*s;\n    int\t\tmb_l;\n    int\t\tc;\n    int\t\tsave_got_int = got_int;\n\n    // Only quit when got_int was set in here.\n    got_int = FALSE;\n\n    // if MSG_HIST flag set, add message to history\n    if (attr & MSG_HIST)\n    {\n\tadd_msg_hist(str, len, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When drawing over the command line no need to clear it later or remove\n    // the mode message.\n    if (msg_row >= cmdline_row && msg_col == 0)\n    {\n\tclear_cmdline = FALSE;\n\tmode_displayed = FALSE;\n    }\n\n    // If the string starts with a composing character first draw a space on\n    // which the composing char can be drawn.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))\n\tmsg_puts_attr(\" \", attr);\n\n    /*\n     * Go over the string.  Special characters are translated and printed.\n     * Normal characters are printed several at a time.\n     */\n    while (--len >= 0 && !got_int)\n    {\n\tif (enc_utf8)\n\t    // Don't include composing chars after the end.\n\t    mb_l = utfc_ptr2len_len(str, len + 1);\n\telse if (has_mbyte)\n\t    mb_l = (*mb_ptr2len)(str);\n\telse\n\t    mb_l = 1;\n\tif (has_mbyte && mb_l > 1)\n\t{\n\t    c = (*mb_ptr2char)(str);\n\t    if (vim_isprintc(c))\n\t\t// printable multi-byte char: count the cells.\n\t\tretval += (*mb_ptr2cells)(str);\n\t    else\n\t    {\n\t\t// unprintable multi-byte char: print the printable chars so\n\t\t// far and the translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + mb_l;\n\t\tmsg_puts_attr((char *)transchar_buf(NULL, c),\n\t\t\t\t\t    attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += char2cells(c);\n\t    }\n\t    len -= mb_l - 1;\n\t    str += mb_l;\n\t}\n\telse\n\t{\n\t    s = transchar_byte_buf(NULL, *str);\n\t    if (s[1] != NUL)\n\t    {\n\t\t// unprintable char: print the printable chars so far and the\n\t\t// translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + 1;\n\t\tmsg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += (int)STRLEN(s);\n\t    }\n\t    else\n\t\t++retval;\n\t    ++str;\n\t}\n    }\n\n    if (str > plain_start && !got_int)\n\t// print the printable chars at the end\n\tmsg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);\n\n    got_int |= save_got_int;\n\n    return retval;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    void\nmsg_make(char_u *arg)\n{\n    int\t    i;\n    static char_u *str = (char_u *)\"eeffoc\", *rs = (char_u *)\"Plon#dqg#vxjduB\";\n\n    arg = skipwhite(arg);\n    for (i = 5; *arg && i >= 0; --i)\n\tif (*arg++ != str[i])\n\t    break;\n    if (i < 0)\n    {\n\tmsg_putchar('\\n');\n\tfor (i = 0; rs[i]; ++i)\n\t    msg_putchar(rs[i] - 3);\n    }\n}\n#endif\n\n/*\n * Output the string 'str' up to a NUL character.\n * Return the number of characters it takes on the screen.\n *\n * If K_SPECIAL is encountered, then it is taken in conjunction with the\n * following character and shown as <F1>, <S-Up> etc.  Any other character\n * which is not printable shown in <> form.\n * If 'from' is TRUE (lhs of a mapping), a space is shown as <Space>.\n * If a character is displayed in one of these special ways, is also\n * highlighted (its highlight name is '8' in the p_hl variable).\n * Otherwise characters are not highlighted.\n * This function is used to show mappings, where we want to see how to type\n * the character/string -- webb\n */\n    int\nmsg_outtrans_special(\n    char_u\t*strstart,\n    int\t\tfrom,\t// TRUE for lhs of a mapping\n    int\t\tmaxlen) // screen columns, 0 for unlimited\n{\n    char_u\t*str = strstart;\n    int\t\tretval = 0;\n    char\t*text;\n    int\t\tattr;\n    int\t\tlen;\n\n    attr = HL_ATTR(HLF_8);\n    while (*str != NUL)\n    {\n\t// Leading and trailing spaces need to be displayed in <> form.\n\tif ((str == strstart || str[1] == NUL) && *str == ' ')\n\t{\n\t    text = \"<Space>\";\n\t    ++str;\n\t}\n\telse\n\t    text = (char *)str2special(&str, from, FALSE);\n\tif (text[0] != NUL && text[1] == NUL)\n\t    // single-byte character or illegal byte\n\t    text = (char *)transchar_byte_buf(NULL, (char_u)text[0]);\n\tlen = vim_strsize((char_u *)text);\n\tif (maxlen > 0 && retval + len >= maxlen)\n\t    break;\n\t// Highlight special keys\n\tmsg_puts_attr(text, len > 1\n\t\t&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);\n\tretval += len;\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return the lhs or rhs of a mapping, with the key codes turned into printable\n * strings, in an allocated string.\n */\n    char_u *\nstr2special_save(\n    char_u  *str,\n    int\t    replace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t    replace_lt)\t\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    garray_T\tga;\n    char_u\t*p = str;\n\n    ga_init2(&ga, 1, 40);\n    while (*p != NUL)\n\tga_concat(&ga, str2special(&p, replace_spaces, replace_lt));\n    ga_append(&ga, NUL);\n    return (char_u *)ga.ga_data;\n}\n#endif\n\n/*\n * Return the printable string for the key codes at \"*sp\".\n * On illegal byte return a string with only that byte.\n * Used for translating the lhs or rhs of a mapping to printable chars.\n * Advances \"sp\" to the next code.\n */\n    char_u *\nstr2special(\n    char_u\t**sp,\n    int\t\treplace_spaces,\t// TRUE to replace \" \" with \"<Space>\".\n\t\t\t\t// used for the lhs of mapping and keytrans().\n    int\t\treplace_lt)\t// TRUE to replace \"<\" with \"<lt>\".\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if ((c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t|| c == CSI\n#endif\n\t) && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif ((c == K_SPECIAL\n#ifdef FEAT_GUI\n\t\t    || c == CSI\n#endif\n\t    ) && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\n\t*sp = str;\n\t// Try to un-escape a multi-byte character after modifiers.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    // Since 'special' is TRUE the multi-byte character 'c' will be\n\t    // processed by get_special_key_name()\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    // illegal byte\n\t    *sp = str + 1;\n    }\n    else\n\t// single-byte character, NUL or illegal byte\n\t*sp = str + (*str == NUL ? 0 : 1);\n\n    // Make special keys and C0 control characters in <> form, also <M-Space>.\n    if (special\n\t|| c < ' '\n\t|| (replace_spaces && c == ' ')\n\t|| (replace_lt && c == '<'))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n\n/*\n * Translate a key sequence into special key names.\n */\n    void\nstr2specialbuf(char_u *sp, char_u *buf, int len)\n{\n    char_u\t*s;\n\n    *buf = NUL;\n    while (*sp)\n    {\n\ts = str2special(&sp, FALSE, FALSE);\n\tif ((int)(STRLEN(s) + STRLEN(buf)) < len)\n\t    STRCAT(buf, s);\n    }\n}\n\n/*\n * print line for :print or :list command\n */\n    void\nmsg_prt_line(char_u *s, int list)\n{\n    int\t\tc;\n    int\t\tcol = 0;\n    int\t\tn_extra = 0;\n    int\t\tc_extra = 0;\n    int\t\tc_final = 0;\n    char_u\t*p_extra = NULL;\t    // init to make SASC shut up\n    int\t\tn;\n    int\t\tattr = 0;\n    char_u\t*trail = NULL;\n    char_u\t*lead = NULL;\n    int\t\tin_multispace = FALSE;\n    int\t\tmultispace_pos = 0;\n    int\t\tl;\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (curwin->w_p_list)\n\tlist = TRUE;\n\n    if (list)\n    {\n\t// find start of trailing whitespace\n\tif (curwin->w_lcs_chars.trail)\n\t{\n\t    trail = s + STRLEN(s);\n\t    while (trail > s && VIM_ISWHITE(trail[-1]))\n\t\t--trail;\n\t}\n\t// find end of leading whitespace\n\tif (curwin->w_lcs_chars.lead\n\t\t\t\t || curwin->w_lcs_chars.leadmultispace != NULL)\n\t{\n\t    lead = s;\n\t    while (VIM_ISWHITE(lead[0]))\n\t\tlead++;\n\t    // in a line full of spaces all of them are treated as trailing\n\t    if (*lead == NUL)\n\t\tlead = NULL;\n\t}\n    }\n\n    // output a space for an empty line, otherwise the line will be\n    // overwritten\n    if (*s == NUL && !(list && curwin->w_lcs_chars.eol != NUL))\n\tmsg_putchar(' ');\n\n    while (!got_int)\n    {\n\tif (n_extra > 0)\n\t{\n\t    --n_extra;\n\t    if (n_extra == 0 && c_final)\n\t\tc = c_final;\n\t    else if (c_extra)\n\t\tc = c_extra;\n\t    else\n\t\tc = *p_extra++;\n\t}\n\telse if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)\n\t{\n\t    col += (*mb_ptr2cells)(s);\n\t    if (l >= MB_MAXBYTES)\n\t    {\n\t\tSTRCPY(buf, \"?\");\n\t    }\n\t    else if (curwin->w_lcs_chars.nbsp != NUL && list\n\t\t    && (mb_ptr2char(s) == 160\n\t\t\t|| mb_ptr2char(s) == 0x202f))\n\t    {\n\t\tint len = mb_char2bytes(curwin->w_lcs_chars.nbsp, buf);\n\n\t\tbuf[len] = NUL;\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(buf, s, (size_t)l);\n\t\tbuf[l] = NUL;\n\t    }\n\t    msg_puts((char *)buf);\n\t    s += l;\n\t    continue;\n\t}\n\telse\n\t{\n\t    attr = 0;\n\t    c = *s++;\n\t    if (list)\n\t    {\n\t\tin_multispace = c == ' ' && (*s == ' '\n\t\t\t\t\t\t || (col > 0 && s[-2] == ' '));\n\t\tif (!in_multispace)\n\t\t    multispace_pos = 0;\n\t    }\n\t    if (c == TAB && (!list || curwin->w_lcs_chars.tab1))\n\t    {\n\t\t// tab amount depends on current column\n#ifdef FEAT_VARTABS\n\t\tn_extra = tabstop_padding(col, curbuf->b_p_ts,\n\t\t\t\t\t\t    curbuf->b_p_vts_array) - 1;\n#else\n\t\tn_extra = curbuf->b_p_ts - col % curbuf->b_p_ts - 1;\n#endif\n\t\tif (!list)\n\t\t{\n\t\t    c = ' ';\n\t\t    c_extra = ' ';\n\t\t    c_final = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = (n_extra == 0 && curwin->w_lcs_chars.tab3)\n\t\t\t\t\t\t? curwin->w_lcs_chars.tab3\n\t\t\t\t\t\t: curwin->w_lcs_chars.tab1;\n\t\t    c_extra = curwin->w_lcs_chars.tab2;\n\t\t    c_final = curwin->w_lcs_chars.tab3;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t    else if (c == 160 && list && curwin->w_lcs_chars.nbsp != NUL)\n\t    {\n\t\tc = curwin->w_lcs_chars.nbsp;\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == NUL && list && curwin->w_lcs_chars.eol != NUL)\n\t    {\n\t\tp_extra = (char_u *)\"\";\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tn_extra = 1;\n\t\tc = curwin->w_lcs_chars.eol;\n\t\tattr = HL_ATTR(HLF_AT);\n\t\t--s;\n\t    }\n\t    else if (c != NUL && (n = byte2cells(c)) > 1)\n\t    {\n\t\tn_extra = n - 1;\n\t\tp_extra = transchar_byte_buf(NULL, c);\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tc = *p_extra++;\n\t\t// Use special coloring to be able to distinguish <hex> from\n\t\t// the same in plain text.\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == ' ')\n\t    {\n\t\tif (lead != NULL && s <= lead && in_multispace\n\t\t\t&& curwin->w_lcs_chars.leadmultispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.leadmultispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.leadmultispace[multispace_pos]\n\t\t\t\t\t\t\t\t\t== NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (lead != NULL && s <= lead\n\t\t\t\t\t    && curwin->w_lcs_chars.lead != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.lead;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (trail != NULL && s > trail)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.trail;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (in_multispace\n\t\t\t&& curwin->w_lcs_chars.multispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.multispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.multispace[multispace_pos] == NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && curwin->w_lcs_chars.space != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.space;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t}\n\n\tif (c == NUL)\n\t    break;\n\n\tmsg_putchar_attr(c, attr);\n\tcol++;\n    }\n    msg_clr_eos();\n}\n\n/*\n * Use screen_puts() to output one multi-byte character.\n * Return the pointer \"s\" advanced to the next character.\n */\n    static char_u *\nscreen_puts_mbyte(char_u *s, int l, int attr)\n{\n    int\t\tcw;\n\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    cw = (*mb_ptr2cells)(s);\n    if (cw > 1 && (\n#ifdef FEAT_RIGHTLEFT\n\t\tcmdmsg_rl ? msg_col <= 1 :\n#endif\n\t\tmsg_col == Columns - 1))\n    {\n\t// Doesn't fit, print a highlighted '>' to fill it up.\n\tmsg_screen_putchar('>', HL_ATTR(HLF_AT));\n\treturn s;\n    }\n\n    screen_puts_len(s, l, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_col -= cw;\n\tif (msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tmsg_col += cw;\n\tif (msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n    return s + l;\n}\n\n/*\n * Output a string to the screen at position msg_row, msg_col.\n * Update msg_row and msg_col for the next message.\n */\n    void\nmsg_puts(char *s)\n{\n    msg_puts_attr(s, 0);\n}\n\n    void\nmsg_puts_title(char *s)\n{\n    msg_puts_attr(s, HL_ATTR(HLF_T));\n}\n\n/*\n * Show a message in such a way that it always fits in the line.  Cut out a\n * part in the middle and replace it with \"...\" when necessary.\n * Does not handle multi-byte characters!\n */\n    static void\nmsg_outtrans_long_len_attr(char_u *longstr, int len, int attr)\n{\n    int\t\tslen = len;\n    int\t\troom;\n\n    room = Columns - msg_col;\n    if (len > room && room >= 20)\n    {\n\tslen = (room - 3) / 2;\n\tmsg_outtrans_len_attr(longstr, slen, attr);\n\tmsg_puts_attr(\"...\", HL_ATTR(HLF_8));\n    }\n    msg_outtrans_len_attr(longstr + len - slen, slen, attr);\n}\n\n    void\nmsg_outtrans_long_attr(char_u *longstr, int attr)\n{\n    msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);\n}\n\n/*\n * Basic function for writing a message with highlight attributes.\n */\n    void\nmsg_puts_attr(char *s, int attr)\n{\n    msg_puts_attr_len(s, -1, attr);\n}\n\n/*\n * Like msg_puts_attr(), but with a maximum length \"maxlen\" (in bytes).\n * When \"maxlen\" is -1 there is no maximum length.\n * When \"maxlen\" is >= 0 the message is not put in the history.\n */\n    static void\nmsg_puts_attr_len(char *str, int maxlen, int attr)\n{\n    /*\n     * If redirection is on, also write to the redirection file.\n     */\n    redir_write((char_u *)str, maxlen);\n\n    /*\n     * Don't print anything when using \":silent cmd\".\n     */\n    if (msg_silent != 0)\n\treturn;\n\n    // if MSG_HIST flag set, add message to history\n    if ((attr & MSG_HIST) && maxlen < 0)\n    {\n\tadd_msg_hist((char_u *)str, -1, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When writing something to the screen after it has scrolled, requires a\n    // wait-return prompt later.  Needed when scrolling, resetting\n    // need_wait_return after some prompt, and then outputting something\n    // without scrolling\n    // Not needed when only using CR to move the cursor.\n    if (msg_scrolled != 0 && !msg_scrolled_ign && STRCMP(str, \"\\r\") != 0)\n\tneed_wait_return = TRUE;\n    msg_didany = TRUE;\t\t// remember that something was outputted\n\n    /*\n     * If there is no valid screen, use fprintf so we can see error messages.\n     * If termcap is not active, we may be writing in an alternate console\n     * window, cursor positioning may not work correctly (window size may be\n     * different, e.g. for Win32 console) or we just don't know where the\n     * cursor is.\n     */\n    if (msg_use_printf())\n\tmsg_puts_printf((char_u *)str, maxlen);\n    else\n\tmsg_puts_display((char_u *)str, maxlen, attr, FALSE);\n\n    need_fileinfo = FALSE;\n}\n\n// values for \"where\"\n#define PUT_APPEND 0\t\t// append to \"lnum\"\n#define PUT_TRUNC 1\t\t// replace \"lnum\"\n#define PUT_BELOW 2\t\t// add below \"lnum\"\n\t\t\t\t//\n#ifdef HAS_MESSAGE_WINDOW\n/*\n * Put text \"t_s\" until \"end\" in the message window.\n * \"where\" specifies where to put the text.\n */\n    static void\nput_msg_win(win_T *wp, int where, char_u *t_s, char_u *end, linenr_T lnum)\n{\n    char_u  *p;\n\n    if (where == PUT_BELOW)\n    {\n\tif (*end != NUL)\n\t{\n\t    p = vim_strnsave(t_s, end - t_s);\n\t    if (p == NULL)\n\t\treturn;\n\t}\n\telse\n\t    p = t_s;\n\tml_append_buf(wp->w_buffer, lnum, p, (colnr_T)0, FALSE);\n\tif (p != t_s)\n\t    vim_free(p);\n    }\n    else\n    {\n\tchar_u *newp;\n\n\tcurbuf = wp->w_buffer;\n\tif (where == PUT_APPEND)\n\t{\n\t    newp = concat_str(ml_get(lnum), t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t    if (*end != NUL)\n\t\tnewp[STRLEN(ml_get(lnum)) + (end - t_s)] = NUL;\n\t}\n\telse\n\t{\n\t    newp = vim_strnsave(t_s, end - t_s);\n\t    if (newp == NULL)\n\t\treturn;\n\t}\n\tml_replace(lnum, newp, FALSE);\n\tcurbuf = curwin->w_buffer;\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\n    // set msg_col so that a newline is written if needed\n    msg_col += (int)(end - t_s);\n}\n#endif\n\n/*\n * The display part of msg_puts_attr_len().\n * May be called recursively to display scroll-back text.\n */\n    static void\nmsg_puts_display(\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tattr,\n    int\t\trecurse)\n{\n    char_u\t*s = str;\n    char_u\t*t_s = str;\t// string from \"t_s\" to \"s\" is still todo\n    int\t\tt_col = 0;\t// screen cells todo, 0 when \"t_s\" not used\n    int\t\tl;\n    int\t\tcw;\n    char_u\t*sb_str = str;\n    int\t\tsb_col = msg_col;\n    int\t\twrap;\n    int\t\tdid_last_char;\n#ifdef HAS_MESSAGE_WINDOW\n    int\t\twhere = PUT_APPEND;\n    win_T\t*msg_win = NULL;\n    linenr_T    lnum = 1;\n\n    if (in_echowindow)\n    {\n\tmsg_win = popup_get_message_win();\n\n\tif (msg_win != NULL)\n\t{\n\t    if (!popup_message_win_visible())\n\t    {\n\t\tif (*str == NL)\n\t\t{\n\t\t    // When not showing the message window and the output\n\t\t    // starts with a NL show the message normally.\n\t\t    msg_win = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // currently hidden, make it empty\n\t\t    curbuf = msg_win->w_buffer;\n\t\t    while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t\tml_delete(1);\n\t\t    curbuf = curwin->w_buffer;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tlnum = msg_win->w_buffer->b_ml.ml_line_count;\n\t\tif (msg_col == 0)\n\t\t    where = PUT_TRUNC;\n\t    }\n\t}\n    }\n#endif\n\n    did_wait_return = FALSE;\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\t/*\n\t * We are at the end of the screen line when:\n\t * - When outputting a newline.\n\t * - When outputting a character in the last column.\n\t */\n\tif (!recurse && msg_row >= Rows - 1 && (*s == '\\n' || (\n#ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl\n\t\t    ? (\n\t\t\tmsg_col <= 1\n\t\t      || (*s == TAB && msg_col <= 7)\n\t\t      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))\n\t\t    :\n#endif\n\t\t      ((*s != '\\r' && msg_col + t_col >= Columns - 1)\n\t\t       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))\n\t\t       || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t && msg_col + t_col >= Columns - 2)))))\n\t{\n\t    /*\n\t     * The screen is scrolled up when at the last row (some terminals\n\t     * scroll automatically, some don't.  To avoid problems we scroll\n\t     * ourselves).\n\t     */\n\t    if (t_col > 0)\n\t    {\n\t\t// output postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t\tif (msg_win != NULL)\n\t\t{\n\t\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\t\t    t_col = 0;\n\t\t    where = PUT_BELOW;\n\t\t}\n\t\telse\n#endif\n\t\t    t_puts(&t_col, t_s, s, attr);\n\t    }\n\n\t    // When no more prompt and no more room, truncate here\n\t    if (msg_no_more && lines_left == 0)\n\t\tbreak;\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n#endif\n\t\t// Scroll the screen up one line.\n\t\tmsg_scroll_up();\n\n\t    msg_row = Rows - 2;\n\t    if (msg_col >= Columns)\t// can happen after screen resize\n\t\tmsg_col = Columns - 1;\n\n\t    // Display char in last column before showing more-prompt.\n\t    if (*s >= ' '\n#ifdef FEAT_RIGHTLEFT\n\t\t    && !cmdmsg_rl\n#endif\n\t       )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    if (enc_utf8 && maxlen >= 0)\n\t\t\t// avoid including composing chars after the end\n\t\t\tl = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\t    else\n\t\t\tl = (*mb_ptr2len)(s);\n\t\t    s = screen_puts_mbyte(s, l, attr);\n\t\t}\n\t\telse\n\t\t    msg_screen_putchar(*s++, attr);\n\t\tdid_last_char = TRUE;\n\t    }\n\t    else\n\t\tdid_last_char = FALSE;\n\n\t    if (p_more)\n\t\t// store text for scrolling back\n\t\tstore_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win == NULL)\n\t    {\n#endif\n\t\tinc_msg_scrolled();\n\t\tneed_wait_return = TRUE; // may need wait_return() in main()\n\t\tredraw_cmdline = TRUE;\n\t\tif (cmdline_row > 0 && !exmode_active)\n\t\t    --cmdline_row;\n\n\t\t/*\n\t\t * If screen is completely filled and 'more' is set then wait\n\t\t * for a character.\n\t\t */\n\t\tif (lines_left > 0)\n\t\t    --lines_left;\n#ifdef HAS_MESSAGE_WINDOW\n\t    }\n#endif\n\t    if (p_more && lines_left == 0 && State != MODE_HITRETURN\n\t\t\t\t\t    && !msg_no_more && !exmode_active)\n\t    {\n#ifdef FEAT_CON_DIALOG\n\t\tif (do_more_prompt(NUL))\n\t\t    s = confirm_msg_tail;\n#else\n\t\t(void)do_more_prompt(NUL);\n#endif\n\t\tif (quit_more)\n\t\t    return;\n\t    }\n\n\t    // When we displayed a char in last column need to check if there\n\t    // is still more.\n\t    if (did_last_char)\n\t\tcontinue;\n\t}\n\n\twrap = *s == '\\n'\n\t\t    || msg_col + t_col >= Columns\n\t\t    || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t    && msg_col + t_col >= Columns - 1);\n\tif (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'\n\t\t\t\t\t\t || *s == '\\t' || *s == BELL))\n\t{\n\t    // output any postponed text\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\tput_msg_win(msg_win, where, t_s, s, lnum);\n\t\tt_col = 0;\n\t\twhere = PUT_BELOW;\n\t    }\n\t    else\n#endif\n\t\tt_puts(&t_col, t_s, s, attr);\n\t}\n\n\tif (wrap && p_more && !recurse)\n\t    // store text for scrolling back\n\t    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\tif (*s == '\\n')\t\t    // go to next line\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t    {\n\t\t// Ignore a NL when the buffer is empty, it is used to scroll\n\t\t// up the text.\n\t\tif ((msg_win->w_buffer->b_ml.ml_flags & ML_EMPTY) == 0)\n\t\t{\n\t\t    put_msg_win(msg_win, PUT_BELOW, t_s, t_s, lnum);\n\t\t    ++lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tmsg_didout = FALSE;\t    // remember that line is empty\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns - 1;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    if (++msg_row >= Rows)  // safety check\n\t\tmsg_row = Rows - 1;\n\t}\n\telse if (*s == '\\r')\t    // go to column 0\n\t{\n\t    msg_col = 0;\n#ifdef HAS_MESSAGE_WINDOW\n\t    where = PUT_TRUNC;\n#endif\n\t}\n\telse if (*s == '\\b')\t    // go to previous char\n\t{\n\t    if (msg_col)\n\t\t--msg_col;\n\t}\n\telse if (*s == TAB)\t    // translate Tab into spaces\n\t{\n#ifdef HAS_MESSAGE_WINDOW\n\t    if (msg_win != NULL)\n\t\tmsg_col = (msg_col + 7) % 8;\n\t    else\n#endif\n\t\tdo\n\t\t    msg_screen_putchar(' ', attr);\n\t\twhile (msg_col & 7);\n\t}\n\telse if (*s == BELL)\t\t// beep (from \":sh\")\n\t    vim_beep(BO_SH);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcw = (*mb_ptr2cells)(s);\n\t\tif (enc_utf8 && maxlen >= 0)\n\t\t    // avoid including composing chars after the end\n\t\t    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\telse\n\t\t    l = (*mb_ptr2len)(s);\n\t    }\n\t    else\n\t    {\n\t\tcw = 1;\n\t\tl = 1;\n\t    }\n\n\t    // When drawing from right to left or when a double-wide character\n\t    // doesn't fit, draw a single character here.  Otherwise collect\n\t    // characters and draw them all at once later.\n\t    if (\n# ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl ||\n# endif\n\t\t    (cw > 1 && msg_col + t_col >= Columns - 1))\n\t    {\n\t\tif (l > 1)\n\t\t    s = screen_puts_mbyte(s, l, attr) - 1;\n\t\telse\n\t\t    msg_screen_putchar(*s, attr);\n\t    }\n\t    else\n\t    {\n\t\t// postpone this character until later\n\t\tif (t_col == 0)\n\t\t    t_s = s;\n\t\tt_col += cw;\n\t\ts += l - 1;\n\t    }\n\t}\n\t++s;\n    }\n\n    // output any postponed text\n    if (t_col > 0)\n    {\n#ifdef HAS_MESSAGE_WINDOW\n\tif (msg_win != NULL)\n\t    put_msg_win(msg_win, where, t_s, s, lnum);\n\telse\n#endif\n\t    t_puts(&t_col, t_s, s, attr);\n    }\n\n#ifdef HAS_MESSAGE_WINDOW\n    if (msg_win != NULL)\n\tpopup_show_message_win();\n#endif\n    // Store the text for scroll back, unless it's a newline by itself.\n    if (p_more && !recurse && !(s == sb_str + 1 && *sb_str == '\\n'))\n\tstore_sb_text(&sb_str, s, attr, &sb_col, FALSE);\n\n    msg_check();\n}\n\n/*\n * Return TRUE when \":filter pattern\" was used and \"msg\" does not match\n * \"pattern\".\n */\n    int\nmessage_filtered(char_u *msg)\n{\n    int match;\n\n    if (cmdmod.cmod_filter_regmatch.regprog == NULL)\n\treturn FALSE;\n    match = vim_regexec(&cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);\n    return cmdmod.cmod_filter_force ? match : !match;\n}\n\n/*\n * Scroll the screen up one line for displaying the next message line.\n */\n    static void\nmsg_scroll_up(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;\n#endif\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}\n\n/*\n * Increment \"msg_scrolled\".\n */\n    static void\ninc_msg_scrolled(void)\n{\n#ifdef FEAT_EVAL\n    if (*get_vim_var_str(VV_SCROLLSTART) == NUL)\n    {\n\tchar_u\t    *p = SOURCING_NAME;\n\tchar_u\t    *tofree = NULL;\n\tint\t    len;\n\n\t// v:scrollstart is empty, set it to the script/function name and line\n\t// number\n\tif (p == NULL)\n\t    p = (char_u *)_(\"Unknown\");\n\telse\n\t{\n\t    len = (int)STRLEN(p) + 40;\n\t    tofree = alloc(len);\n\t    if (tofree != NULL)\n\t    {\n\t\tvim_snprintf((char *)tofree, len, _(\"%s line %ld\"),\n\t\t\t\t\t\t      p, (long)SOURCING_LNUM);\n\t\tp = tofree;\n\t    }\n\t}\n\tset_vim_var_string(VV_SCROLLSTART, p, -1);\n\tvim_free(tofree);\n    }\n#endif\n    ++msg_scrolled;\n    set_must_redraw(UPD_VALID);\n}\n\n/*\n * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to\n * store the displayed text and remember where screen lines start.\n */\ntypedef struct msgchunk_S msgchunk_T;\nstruct msgchunk_S\n{\n    msgchunk_T\t*sb_next;\n    msgchunk_T\t*sb_prev;\n    char\tsb_eol;\t\t// TRUE when line ends after this text\n    int\t\tsb_msg_col;\t// column in which text starts\n    int\t\tsb_attr;\t// text attributes\n    char_u\tsb_text[1];\t// text to be displayed, actually longer\n};\n\nstatic msgchunk_T *last_msgchunk = NULL; // last displayed text\n\nstatic msgchunk_T *msg_sb_start(msgchunk_T *mps);\n\ntypedef enum {\n    SB_CLEAR_NONE = 0,\n    SB_CLEAR_ALL,\n    SB_CLEAR_CMDLINE_BUSY,\n    SB_CLEAR_CMDLINE_DONE\n} sb_clear_T;\n\n// When to clear text on next msg.\nstatic sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;\n\n/*\n * Store part of a printed message for displaying when scrolling back.\n */\n    static void\nstore_sb_text(\n    char_u\t**sb_str,\t// start of string\n    char_u\t*s,\t\t// just after string\n    int\t\tattr,\n    int\t\t*sb_col,\n    int\t\tfinish)\t\t// line ends\n{\n    msgchunk_T\t*mp;\n\n    if (do_clear_sb_text == SB_CLEAR_ALL\n\t    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)\n    {\n\tclear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);\n\tmsg_sb_eol();  // prevent messages from overlapping\n\tdo_clear_sb_text = SB_CLEAR_NONE;\n    }\n\n    if (s > *sb_str)\n    {\n\tmp = alloc(offsetof(msgchunk_T, sb_text) + (s - *sb_str) + 1);\n\tif (mp != NULL)\n\t{\n\t    mp->sb_eol = finish;\n\t    mp->sb_msg_col = *sb_col;\n\t    mp->sb_attr = attr;\n\t    vim_strncpy(mp->sb_text, *sb_str, s - *sb_str);\n\n\t    if (last_msgchunk == NULL)\n\t    {\n\t\tlast_msgchunk = mp;\n\t\tmp->sb_prev = NULL;\n\t    }\n\t    else\n\t    {\n\t\tmp->sb_prev = last_msgchunk;\n\t\tlast_msgchunk->sb_next = mp;\n\t\tlast_msgchunk = mp;\n\t    }\n\t    mp->sb_next = NULL;\n\t}\n    }\n    else if (finish && last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n\n    *sb_str = s;\n    *sb_col = 0;\n}\n\n/*\n * Finished showing messages, clear the scroll-back text on the next message.\n */\n    void\nmay_clear_sb_text(void)\n{\n    do_clear_sb_text = SB_CLEAR_ALL;\n}\n\n/*\n * Starting to edit the command line: do not clear messages now.\n */\n    void\nsb_text_start_cmdline(void)\n{\n    if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY)\n\t// Invoking command line recursively: the previous-level command line\n\t// doesn't need to be remembered as it will be redrawn when returning\n\t// to that level.\n\tsb_text_restart_cmdline();\n    else\n    {\n\tmsg_sb_eol();\n\tdo_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n    }\n}\n\n/*\n * Redrawing the command line: clear the last unfinished line.\n */\n    void\nsb_text_restart_cmdline(void)\n{\n    msgchunk_T *tofree;\n\n    // Needed when returning from nested command line.\n    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n\n    if (last_msgchunk == NULL || last_msgchunk->sb_eol)\n\t// No unfinished line: don't clear anything.\n\treturn;\n\n    tofree = msg_sb_start(last_msgchunk);\n    last_msgchunk = tofree->sb_prev;\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_next = NULL;\n    while (tofree != NULL)\n    {\n\tmsgchunk_T *tofree_next = tofree->sb_next;\n\n\tvim_free(tofree);\n\ttofree = tofree_next;\n    }\n}\n\n/*\n * Ending to edit the command line: clear old lines but the last one later.\n */\n    void\nsb_text_end_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;\n}\n\n/*\n * Clear any text remembered for scrolling back.\n * When \"all\" is FALSE keep the last line.\n * Called when redrawing the screen.\n */\n    void\nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &msg_sb_start(last_msgchunk)->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n/*\n * \"g<\" command.\n */\n    void\nshow_sb_text(void)\n{\n    msgchunk_T\t*mp;\n\n    // Only show something if there is more than one line, otherwise it looks\n    // weird, typing a command without output results in one line.\n    mp = msg_sb_start(last_msgchunk);\n    if (mp == NULL || mp->sb_prev == NULL)\n\tvim_beep(BO_MESS);\n    else\n    {\n\tdo_more_prompt('G');\n\twait_return(FALSE);\n    }\n}\n\n/*\n * Move to the start of screen line in already displayed text.\n */\n    static msgchunk_T *\nmsg_sb_start(msgchunk_T *mps)\n{\n    msgchunk_T *mp = mps;\n\n    while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)\n\tmp = mp->sb_prev;\n    return mp;\n}\n\n/*\n * Mark the last message chunk as finishing the line.\n */\n    void\nmsg_sb_eol(void)\n{\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n}\n\n/*\n * Display a screen line from previously displayed text at row \"row\".\n * When \"clear_to_eol\" is set clear the rest of the screen line.\n * Returns a pointer to the text for the next line (can be NULL).\n */\n    static msgchunk_T *\ndisp_sb_line(int row, msgchunk_T *smp, int clear_to_eol)\n{\n    msgchunk_T\t*mp = smp;\n    char_u\t*p;\n\n    for (;;)\n    {\n\tmsg_row = row;\n\tmsg_col = mp->sb_msg_col;\n\tp = mp->sb_text;\n\tif (*p == '\\n')\t    // don't display the line break\n\t    ++p;\n\tmsg_puts_display(p, -1, mp->sb_attr, TRUE);\n\n\t// If clearing the screen did not work (e.g. because of a background\n\t// color and t_ut isn't set) clear until the last column here.\n\tif (clear_to_eol)\n\t    screen_fill(row, row + 1, msg_col, (int)Columns, ' ', ' ', 0);\n\n\tif (mp->sb_eol || mp->sb_next == NULL)\n\t    break;\n\tmp = mp->sb_next;\n    }\n    return mp->sb_next;\n}\n\n/*\n * Output any postponed text for msg_puts_attr_len().\n */\n    static void\nt_puts(\n    int\t\t*t_col,\n    char_u\t*t_s,\n    char_u\t*s,\n    int\t\tattr)\n{\n    // output postponed text\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);\n    msg_col += *t_col;\n    *t_col = 0;\n    // If the string starts with a composing character don't increment the\n    // column position for it.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))\n\t--msg_col;\n    if (msg_col >= Columns)\n    {\n\tmsg_col = 0;\n\t++msg_row;\n    }\n}\n\n/*\n * Returns TRUE when messages should be printed with mch_errmsg().\n * This is used when there is no valid screen, so we can see error messages.\n * If termcap is not active, we may be writing in an alternate console\n * window, cursor positioning may not work correctly (window size may be\n * different, e.g. for Win32 console) or we just don't know where the\n * cursor is.\n */\n    int\nmsg_use_printf(void)\n{\n    return (!msg_check_screen()\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\t    || (!gui.in_use && !termcap_active)\n# else\n\t    || !termcap_active\n# endif\n#endif\n\t    || (swapping_screen() && !termcap_active)\n\t       );\n}\n\n/*\n * Print a message when there is no valid screen.\n */\n    static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)\n\t\t\t\t\t\t\t     >= (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}\n\n/*\n * Show the more-prompt and handle the user response.\n * This takes care of scrolling back and displaying previously displayed text.\n * When at hit-enter prompt \"typed_char\" is the already typed character,\n * otherwise it's NUL.\n * Returns TRUE when jumping ahead to \"confirm_msg_tail\".\n */\n    static int\ndo_more_prompt(int typed_char)\n{\n    static int\tentered = FALSE;\n    int\t\tused_typed_char = typed_char;\n    int\t\toldState = State;\n    int\t\tc;\n#ifdef FEAT_CON_DIALOG\n    int\t\tretval = FALSE;\n#endif\n    int\t\ttoscroll;\n    msgchunk_T\t*mp_last = NULL;\n    msgchunk_T\t*mp;\n    int\t\ti;\n\n    // We get called recursively when a timer callback outputs a message. In\n    // that case don't show another prompt. Also when at the hit-Enter prompt\n    // and nothing was typed.\n    if (entered || (State == MODE_HITRETURN && typed_char == 0))\n\treturn FALSE;\n    entered = TRUE;\n\n    if (typed_char == 'G')\n    {\n\t// \"g<\": Find first line on the last page.\n\tmp_last = msg_sb_start(last_msgchunk);\n\tfor (i = 0; i < Rows - 2 && mp_last != NULL\n\t\t\t\t\t     && mp_last->sb_prev != NULL; ++i)\n\t    mp_last = msg_sb_start(mp_last->sb_prev);\n    }\n\n    State = MODE_ASKMORE;\n    setmouse();\n    if (typed_char == NUL)\n\tmsg_moremsg(FALSE);\n    for (;;)\n    {\n\t/*\n\t * Get a typed character directly from the user.\n\t */\n\tif (used_typed_char != NUL)\n\t{\n\t    c = used_typed_char;\t// was typed at hit-enter prompt\n\t    used_typed_char = NUL;\n\t}\n\telse\n\t    c = get_keystroke();\n\n#if defined(FEAT_MENU) && defined(FEAT_GUI)\n\tif (c == K_MENU)\n\t{\n\t    int idx = get_menu_index(current_menu, MODE_ASKMORE);\n\n\t    // Used a menu.  If it starts with CTRL-Y, it must\n\t    // be a \"Copy\" for the clipboard.  Otherwise\n\t    // assume that we end\n\t    if (idx == MENU_INDEX_INVALID)\n\t\tcontinue;\n\t    c = *current_menu->strings[idx];\n\t    if (c != NUL && current_menu->strings[idx][1] != NUL)\n\t\tins_typebuf(current_menu->strings[idx] + 1,\n\t\t\t\tcurrent_menu->noremap[idx], 0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t}\n#endif\n\n\ttoscroll = 0;\n\tswitch (c)\n\t{\n\tcase BS:\t\t// scroll one line back\n\tcase K_BS:\n\tcase 'k':\n\tcase K_UP:\n\t    toscroll = -1;\n\t    break;\n\n\tcase CAR:\t\t// one extra line\n\tcase NL:\n\tcase 'j':\n\tcase K_DOWN:\n\t    toscroll = 1;\n\t    break;\n\n\tcase 'u':\t\t// Up half a page\n\t    toscroll = -(Rows / 2);\n\t    break;\n\n\tcase 'd':\t\t// Down half a page\n\t    toscroll = Rows / 2;\n\t    break;\n\n\tcase 'b':\t\t// one page back\n\tcase K_PAGEUP:\n\t    toscroll = -(Rows - 1);\n\t    break;\n\n\tcase ' ':\t\t// one extra page\n\tcase 'f':\n\tcase K_PAGEDOWN:\n\tcase K_LEFTMOUSE:\n\t    toscroll = Rows - 1;\n\t    break;\n\n\tcase 'g':\t\t// all the way back to the start\n\t    toscroll = -999999;\n\t    break;\n\n\tcase 'G':\t\t// all the way to the end\n\t    toscroll = 999999;\n\t    lines_left = 999999;\n\t    break;\n\n\tcase ':':\t\t// start new command line\n#ifdef FEAT_CON_DIALOG\n\t    if (!confirm_msg_used)\n#endif\n\t    {\n\t\t// Since got_int is set all typeahead will be flushed, but we\n\t\t// want to keep this ':', remember that in a special way.\n\t\ttypeahead_noflush(':');\n#ifdef FEAT_TERMINAL\n\t\tskip_term_loop = TRUE;\n#endif\n\t\tcmdline_row = Rows - 1;\t\t// put ':' on this line\n\t\tskip_redraw = TRUE;\t\t// skip redraw once\n\t\tneed_wait_return = FALSE;\t// don't wait in main()\n\t    }\n\t    // FALLTHROUGH\n\tcase 'q':\t\t// quit\n\tcase Ctrl_C:\n\tcase ESC:\n#ifdef FEAT_CON_DIALOG\n\t    if (confirm_msg_used)\n\t    {\n\t\t// Jump to the choices of the dialog.\n\t\tretval = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tgot_int = TRUE;\n\t\tquit_more = TRUE;\n\t    }\n\t    // When there is some more output (wrapping line) display that\n\t    // without another prompt.\n\t    lines_left = Rows - 1;\n\t    break;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t    // Strange way to allow copying (yanking) a modeless\n\t    // selection at the more prompt.  Use CTRL-Y,\n\t    // because the same is used in Cmdline-mode and at the\n\t    // hit-enter prompt.  However, scrolling one line up\n\t    // might be expected...\n\t    if (clip_star.state == SELECT_DONE)\n\t\tclip_copy_modeless_selection(TRUE);\n\t    continue;\n#endif\n\tdefault:\t\t// no valid response\n\t    msg_moremsg(TRUE);\n\t    continue;\n\t}\n\n\tif (toscroll != 0)\n\t{\n\t    if (toscroll < 0)\n\t    {\n\t\t// go to start of last line\n\t\tif (mp_last == NULL)\n\t\t    mp = msg_sb_start(last_msgchunk);\n\t\telse if (mp_last->sb_prev != NULL)\n\t\t    mp = msg_sb_start(mp_last->sb_prev);\n\t\telse\n\t\t    mp = NULL;\n\n\t\t// go to start of line at top of the screen\n\t\tfor (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;\n\t\t\t\t\t\t\t\t\t  ++i)\n\t\t    mp = msg_sb_start(mp->sb_prev);\n\n\t\tif (mp != NULL && mp->sb_prev != NULL)\n\t\t{\n\t\t    // Find line to be displayed at top.\n\t\t    for (i = 0; i > toscroll; --i)\n\t\t    {\n\t\t\tif (mp == NULL || mp->sb_prev == NULL)\n\t\t\t    break;\n\t\t\tmp = msg_sb_start(mp->sb_prev);\n\t\t\tif (mp_last == NULL)\n\t\t\t    mp_last = msg_sb_start(last_msgchunk);\n\t\t\telse\n\t\t\t    mp_last = msg_sb_start(mp_last->sb_prev);\n\t\t    }\n\n\t\t    if (toscroll == -1 && screen_ins_lines(0, 0, 1,\n\t\t\t\t\t\t     (int)Rows, 0, NULL) == OK)\n\t\t    {\n\t\t\t// display line at top\n\t\t\t(void)disp_sb_line(0, mp, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tint did_clear = screenclear();\n\n\t\t\t// redisplay all lines\n\t\t\tfor (i = 0; mp != NULL && i < Rows - 1; ++i)\n\t\t\t{\n\t\t\t    mp = disp_sb_line(i, mp, !did_clear);\n\t\t\t    ++msg_scrolled;\n\t\t\t}\n\t\t    }\n\t\t    toscroll = 0;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// First display any text that we scrolled back.\n\t\twhile (toscroll > 0 && mp_last != NULL)\n\t\t{\n\t\t    // scroll up, display line at bottom\n\t\t    msg_scroll_up();\n\t\t    inc_msg_scrolled();\n\t\t    screen_fill((int)Rows - 2, (int)Rows - 1, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\t    mp_last = disp_sb_line((int)Rows - 2, mp_last, FALSE);\n\t\t    --toscroll;\n\t\t}\n\t    }\n\n\t    if (toscroll <= 0)\n\t    {\n\t\t// displayed the requested text, more prompt again\n\t\tscreen_fill((int)Rows - 1, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\tmsg_moremsg(FALSE);\n\t\tcontinue;\n\t    }\n\n\t    // display more text, return to caller\n\t    lines_left = toscroll;\n\t}\n\n\tbreak;\n    }\n\n    // clear the --more-- message\n    screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n    State = oldState;\n    setmouse();\n    if (quit_more)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n#ifdef FEAT_RIGHTLEFT\n    else if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n#endif\n\n    entered = FALSE;\n#ifdef FEAT_CON_DIALOG\n    return retval;\n#else\n    return FALSE;\n#endif\n}\n\n#if defined(USE_MCH_ERRMSG) || defined(PROTO)\n\n#ifdef mch_errmsg\n# undef mch_errmsg\n#endif\n#ifdef mch_msg\n# undef mch_msg\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_errmsg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode = 0;\n    HANDLE  h = GetStdHandle(STD_ERROR_HANDLE);\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tfprintf(stderr, \"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give an error message.  To be used when the screen hasn't been initialized\n * yet.  When stderr can't be used, collect error messages until the GUI has\n * started and they can be displayed in a message box.\n */\n    void\nmch_errmsg(char *str)\n{\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    int\t\tlen;\n#endif\n\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stderr if it's a tty.\n    // When not going to start the GUI also use stderr.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tfprintf(stderr, \"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_errmsg_c(str);\n\treturn;\n    }\n#endif\n\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    // avoid a delay for a message that isn't there\n    emsg_on_display = FALSE;\n\n    len = (int)STRLEN(str) + 1;\n    if (error_ga.ga_growsize == 0)\n    {\n\terror_ga.ga_growsize = 80;\n\terror_ga.ga_itemsize = 1;\n    }\n    if (ga_grow(&error_ga, len) == OK)\n    {\n\tmch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,\n\t\t\t\t\t\t\t  (char_u *)str, len);\n# ifdef UNIX\n\t// remove CR characters, they are displayed\n\t{\n\t    char_u\t*p;\n\n\t    p = (char_u *)error_ga.ga_data + error_ga.ga_len;\n\t    for (;;)\n\t    {\n\t\tp = vim_strchr(p, '\\r');\n\t\tif (p == NULL)\n\t\t    break;\n\t\t*p = ' ';\n\t    }\n\t}\n# endif\n\t--len;\t\t// don't count the NUL at the end\n\terror_ga.ga_len += len;\n    }\n#endif\n}\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_msg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode;\n    HANDLE  h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tprintf(\"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give a message.  To be used when the screen hasn't been initialized yet.\n * When there is no tty, collect messages until the GUI has started and they\n * can be displayed in a message box.\n */\n    void\nmch_msg(char *str)\n{\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stdout if we have a tty.  This allows \"vim -h | more\" and\n    // uses mch_errmsg() when started from the desktop.\n    // When not going to start the GUI also use stdout.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tprintf(\"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_msg_c(str);\n\treturn;\n    }\n#endif\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    mch_errmsg(str);\n#endif\n}\n#endif // USE_MCH_ERRMSG\n\n/*\n * Put a character on the screen at the current message position and advance\n * to the next position.  Only for printable ASCII!\n */\n    static void\nmsg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}\n\n    static void\nmsg_moremsg(int full)\n{\n    int\t\tattr;\n    char_u\t*s = (char_u *)_(\"-- More --\");\n\n    attr = HL_ATTR(HLF_M);\n    screen_puts(s, (int)Rows - 1, 0, attr);\n    if (full)\n\tscreen_puts((char_u *)\n\t\t_(\" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit \"),\n\t\t(int)Rows - 1, vim_strsize(s), attr);\n}\n\n/*\n * Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,\n * MODE_CONFIRM or exmode_active.\n */\n    void\nrepeat_message(void)\n{\n    if (State == MODE_ASKMORE)\n    {\n\tmsg_moremsg(TRUE);\t// display --more-- message again\n\tmsg_row = Rows - 1;\n    }\n#ifdef FEAT_CON_DIALOG\n    else if (State == MODE_CONFIRM)\n    {\n\tdisplay_confirm_msg();\t// display \":confirm\" message again\n\tmsg_row = Rows - 1;\n    }\n#endif\n    else if (State == MODE_EXTERNCMD)\n    {\n\twindgoto(msg_row, msg_col); // put cursor back\n    }\n    else if (State == MODE_HITRETURN || State == MODE_SETWSIZE)\n    {\n\tif (msg_row == Rows - 1)\n\t{\n\t    // Avoid drawing the \"hit-enter\" prompt below the previous one,\n\t    // overwrite it.  Esp. useful when regaining focus and a\n\t    // FocusGained autocmd exists but didn't draw anything.\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    msg_clr_eos();\n\t}\n\thit_return_msg();\n\tmsg_row = Rows - 1;\n    }\n}\n\n/*\n * msg_check_screen - check if the screen is initialized.\n * Also check msg_row and msg_col, if they are too big it may cause a crash.\n * While starting the GUI the terminal codes will be set for the GUI, but the\n * output goes to the terminal.  Don't use the terminal codes then.\n */\n    static int\nmsg_check_screen(void)\n{\n    if (!full_screen || !screen_valid(FALSE))\n\treturn FALSE;\n\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n    if (msg_col >= Columns)\n\tmsg_col = Columns - 1;\n    return TRUE;\n}\n\n/*\n * Clear from current message position to end of screen.\n * Skip this when \":silent\" was used, no need to clear for redirection.\n */\n    void\nmsg_clr_eos(void)\n{\n    if (msg_silent == 0)\n\tmsg_clr_eos_force();\n}\n\n/*\n * Clear from current message position to end of screen.\n * Note: msg_col is not updated, so we remember the end of the message\n * for msg_check().\n */\n    void\nmsg_clr_eos_force(void)\n{\n#ifdef HAS_MESSAGE_WINDOW\n    if (in_echowindow)\n\treturn;  // messages go into a popup\n#endif\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n/*\n * Clear the command line.\n */\n    void\nmsg_clr_cmdline(void)\n{\n    msg_row = cmdline_row;\n    msg_col = 0;\n    msg_clr_eos_force();\n}\n\n/*\n * end putting a message on the screen\n * call wait_return() if the message does not fit in the available space\n * return TRUE if wait_return() not called.\n */\n    int\nmsg_end(void)\n{\n    /*\n     * If the string is larger than the window,\n     * or the ruler option is set and we run into it,\n     * we have to redraw the window.\n     * Do not do this if we are abandoning the file or editing the command line.\n     */\n    if (!exiting && need_wait_return && !(State & MODE_CMDLINE))\n    {\n\twait_return(FALSE);\n\treturn FALSE;\n    }\n    out_flush();\n    return TRUE;\n}\n\n/*\n * If the written message runs into the shown command or ruler, we have to\n * wait for hit-return and redraw the window later.\n */\n    void\nmsg_check(void)\n{\n    if (msg_row == Rows - 1 && msg_col >= sc_col\n#ifdef HAS_MESSAGE_WINDOW\n\t\t&& !in_echowindow\n#endif\n\t    )\n    {\n\tneed_wait_return = TRUE;\n\tredraw_cmdline = TRUE;\n    }\n}\n\n/*\n * May write a string to the redirection file.\n * When \"maxlen\" is -1 write the whole string, otherwise up to \"maxlen\" bytes.\n */\n    static void\nredir_write(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    static int\tcur_col = 0;\n\n    // Don't do anything for displaying prompts and the like.\n    if (redir_off)\n\treturn;\n\n    // If 'verbosefile' is set prepare for writing in that file.\n    if (*p_vfile != NUL && verbose_fd == NULL)\n\tverbose_open();\n\n    if (redirecting())\n    {\n\t// If the string doesn't start with CR or NL, go to msg_col\n\tif (*s != '\\n' && *s != '\\r')\n\t{\n\t    while (cur_col < msg_col)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (redir_execute)\n\t\t    execute_redir_str((char_u *)\" \", -1);\n\t\telse if (redir_reg)\n\t\t    write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);\n\t\telse if (redir_vname)\n\t\t    var_redir_str((char_u *)\" \", -1);\n\t\telse\n#endif\n\t\t    if (redir_fd != NULL)\n\t\t    fputs(\" \", redir_fd);\n\t\tif (verbose_fd != NULL)\n\t\t    fputs(\" \", verbose_fd);\n\t\t++cur_col;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (redir_execute)\n\t    execute_redir_str(s, maxlen);\n\telse if (redir_reg)\n\t    write_reg_contents(redir_reg, s, maxlen, TRUE);\n\telse if (redir_vname)\n\t    var_redir_str(s, maxlen);\n#endif\n\n\t// Write and adjust the current column.\n\twhile (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))\n\t{\n#ifdef FEAT_EVAL\n\t    if (!redir_reg && !redir_vname && !redir_execute)\n#endif\n\t\tif (redir_fd != NULL)\n\t\t    putc(*s, redir_fd);\n\t    if (verbose_fd != NULL)\n\t\tputc(*s, verbose_fd);\n\t    if (*s == '\\r' || *s == '\\n')\n\t\tcur_col = 0;\n\t    else if (*s == '\\t')\n\t\tcur_col += (8 - cur_col % 8);\n\t    else\n\t\t++cur_col;\n\t    ++s;\n\t}\n\n\tif (msg_silent != 0)\t// should update msg_col\n\t    msg_col = cur_col;\n    }\n}\n\n    int\nredirecting(void)\n{\n    return redir_fd != NULL || *p_vfile != NUL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname || redir_execute\n#endif\n\t\t\t\t       ;\n}\n\n/*\n * Before giving verbose message.\n * Must always be called paired with verbose_leave()!\n */\n    void\nverbose_enter(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n}\n\n/*\n * After giving verbose message.\n * Must always be called paired with verbose_enter()!\n */\n    void\nverbose_leave(void)\n{\n    if (*p_vfile != NUL)\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n}\n\n/*\n * Like verbose_enter() and set msg_scroll when displaying the message.\n */\n    void\nverbose_enter_scroll(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n    else\n\t// always scroll up, don't overwrite\n\tmsg_scroll = TRUE;\n}\n\n/*\n * Like verbose_leave() and set cmdline_row when displaying the message.\n */\n    void\nverbose_leave_scroll(void)\n{\n    if (*p_vfile != NUL)\n    {\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n    }\n    else\n\tcmdline_row = msg_row;\n}\n\n/*\n * Called when 'verbosefile' is set: stop writing to the file.\n */\n    void\nverbose_stop(void)\n{\n    if (verbose_fd != NULL)\n    {\n\tfclose(verbose_fd);\n\tverbose_fd = NULL;\n    }\n    verbose_did_open = FALSE;\n}\n\n/*\n * Open the file 'verbosefile'.\n * Return FAIL or OK.\n */\n    int\nverbose_open(void)\n{\n    if (verbose_fd == NULL && !verbose_did_open)\n    {\n\t// Only give the error message once.\n\tverbose_did_open = TRUE;\n\n\tverbose_fd = mch_fopen((char *)p_vfile, \"a\");\n\tif (verbose_fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), p_vfile);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Give a warning message (for searching).\n * Use 'w' highlighting and may repeat the message after redrawing\n */\n    void\ngive_warning(char_u *message, int hl)\n{\n    give_warning_with_source(message, hl, FALSE);\n}\n\n    void\ngive_warning_with_source(char_u *message, int hl, int with_source)\n{\n    // Don't do this for \":silent\".\n    if (msg_silent != 0)\n\treturn;\n\n    // Don't want a hit-enter prompt here.\n    ++no_wait_return;\n\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_WARNINGMSG, message, -1);\n#endif\n    VIM_CLEAR(keep_msg);\n    if (hl)\n\tkeep_msg_attr = HL_ATTR(HLF_W);\n    else\n\tkeep_msg_attr = 0;\n\n    if (with_source)\n    {\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts(\" \");\n\tmsg_puts_attr((char *)message, HL_ATTR(HLF_W) | MSG_HIST);\n\tmsg_clr_eos();\n\t(void)msg_end();\n    }\n    else if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)\n\tset_keep_msg(message, keep_msg_attr);\n\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n\n    --no_wait_return;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\ngive_warning2(char_u *message, char_u *a1, int hl)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just give\n\t// the raw message so the user at least gets a hint.\n\tgive_warning(message, hl);\n    }\n    else\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);\n\tgive_warning(IObuff, hl);\n    }\n}\n#endif\n\n/*\n * Advance msg cursor to column \"col\".\n */\n    void\nmsg_advance(int col)\n{\n    if (msg_silent != 0)\t// nothing to advance to\n    {\n\tmsg_col = col;\t\t// for redirection, may fill it up later\n\treturn;\n    }\n    if (col >= Columns)\t\t// not enough room\n\tcol = Columns - 1;\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\twhile (msg_col > Columns - col)\n\t    msg_putchar(' ');\n    else\n#endif\n\twhile (msg_col < col)\n\t    msg_putchar(' ');\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Used for \"confirm()\" function, and the :confirm command prefix.\n * Versions which haven't got flexible dialogs yet, and console\n * versions, get this generic handler which uses the command line.\n *\n * type  = one of:\n *\t   VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC\n * title = title string (can be NULL for default)\n * (neither used in console dialogs at the moment)\n *\n * Format of the \"buttons\" string:\n * \"Button1Name\\nButton2Name\\nButton3Name\"\n * The first button should normally be the default/accept\n * The second button should be the 'Cancel' button\n * Other buttons- use your imagination!\n * A '&' in a button name becomes a shortcut, so each '&' should be before a\n * different letter.\n *\n * Returns 0 if cancelled, otherwise the nth button (1-indexed).\n */\n    int\ndo_dialog(\n    int\t\ttype UNUSED,\n    char_u\t*title UNUSED,\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton,\n    char_u\t*textfield UNUSED,\t// IObuff for inputdialog(), NULL\n\t\t\t\t\t// otherwise\n    int\t\tex_cmd)\t    // when TRUE pressing : accepts default and starts\n\t\t\t    // Ex command\n{\n    int\t\toldState;\n    int\t\tretval = 0;\n    char_u\t*hotkeys;\n    int\t\tc;\n    int\t\ti;\n    tmode_T\tsave_tmode;\n\n#ifndef NO_CONSOLE\n    // Don't output anything in silent mode (\"ex -s\")\n    if (silent_mode)\n\treturn dfltbutton;   // return default option\n#endif\n\n#ifdef FEAT_GUI_DIALOG\n    // When GUI is running and 'c' not in 'guioptions', use the GUI dialog\n    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)\n    {\n\t// --gui-dialog-file: write text to a file\n\tif (gui_dialog_log(title, message))\n\t    c = dfltbutton;\n\telse\n\t    c = gui_mch_dialog(type, title, message, buttons, dfltbutton,\n\t\t\t\t\t\t\t   textfield, ex_cmd);\n\t// avoid a hit-enter prompt without clearing the cmdline\n\tneed_wait_return = FALSE;\n\temsg_on_display = FALSE;\n\tcmdline_row = msg_row;\n\n\t// Flush output to avoid that further messages and redrawing is done\n\t// in the wrong order.\n\tout_flush();\n\tgui_mch_update();\n\n\treturn c;\n    }\n#endif\n\n    oldState = State;\n    State = MODE_CONFIRM;\n    setmouse();\n\n    // Ensure raw mode here.\n    save_tmode = cur_tmode;\n    settmode(TMODE_RAW);\n\n    /*\n     * Since we wait for a keypress, don't make the\n     * user press RETURN as well afterwards.\n     */\n    ++no_wait_return;\n    hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);\n\n    if (hotkeys != NULL)\n    {\n\tfor (;;)\n\t{\n\t    // Get a typed character directly from the user.\n\t    c = get_keystroke();\n\t    switch (c)\n\t    {\n\t    case CAR:\t\t// User accepts default option\n\t    case NL:\n\t\tretval = dfltbutton;\n\t\tbreak;\n\t    case Ctrl_C:\t// User aborts/cancels\n\t    case ESC:\n\t\tretval = 0;\n\t\tbreak;\n\t    default:\t\t// Could be a hotkey?\n\t\tif (c < 0)\t// special keys are ignored here\n\t\t    continue;\n\t\tif (c == ':' && ex_cmd)\n\t\t{\n\t\t    retval = dfltbutton;\n\t\t    ins_char_typebuf(':', 0);\n\t\t    break;\n\t\t}\n\n\t\t// Make the character lowercase, as chars in \"hotkeys\" are.\n\t\tc = MB_TOLOWER(c);\n\t\tretval = 1;\n\t\tfor (i = 0; hotkeys[i]; ++i)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif ((*mb_ptr2char)(hotkeys + i) == c)\n\t\t\t    break;\n\t\t\ti += (*mb_ptr2len)(hotkeys + i) - 1;\n\t\t    }\n\t\t    else\n\t\t\tif (hotkeys[i] == c)\n\t\t\t    break;\n\t\t    ++retval;\n\t\t}\n\t\tif (hotkeys[i])\n\t\t    break;\n\t\t// No hotkey match, so keep waiting\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\n\tvim_free(hotkeys);\n    }\n\n    settmode(save_tmode);\n    State = oldState;\n    setmouse();\n    --no_wait_return;\n    msg_end_prompt();\n\n    return retval;\n}\n\n/*\n * Copy one character from \"*from\" to \"*to\", taking care of multi-byte\n * characters.  Return the length of the character in bytes.\n */\n    static int\ncopy_char(\n    char_u\t*from,\n    char_u\t*to,\n    int\t\tlowercase)\t// make character lower case\n{\n    int\t\tlen;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tif (lowercase)\n\t{\n\t    c = MB_TOLOWER((*mb_ptr2char)(from));\n\t    return (*mb_char2bytes)(c, to);\n\t}\n\telse\n\t{\n\t    len = (*mb_ptr2len)(from);\n\t    mch_memmove(to, from, (size_t)len);\n\t    return len;\n\t}\n    }\n    else\n    {\n\tif (lowercase)\n\t    *to = (char_u)TOLOWER_LOC(*from);\n\telse\n\t    *to = *from;\n\treturn 1;\n    }\n}\n\n/*\n * Format the dialog string, and display it at the bottom of\n * the screen. Return a string of hotkey chars (if defined) for\n * each 'button'. If a button has no hotkey defined, the first character of\n * the button is used.\n * The hotkeys can be multi-byte characters, but without combining chars.\n *\n * Returns an allocated string with hotkeys, or NULL for error.\n */\n    static char_u *\nmsg_show_console_dialog(\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton)\n{\n    int\t\tlen = 0;\n#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)\n    int\t\tlenhotkey = HOTK_LEN;\t// count first button\n    char_u\t*hotk = NULL;\n    char_u\t*msgp = NULL;\n    char_u\t*hotkp = NULL;\n    char_u\t*r;\n    int\t\tcopy;\n#define HAS_HOTKEY_LEN 30\n    char_u\thas_hotkey[HAS_HOTKEY_LEN];\n    int\t\tfirst_hotkey = FALSE;\t// first char of button is hotkey\n    int\t\tidx;\n\n    has_hotkey[0] = FALSE;\n\n    /*\n     * First loop: compute the size of memory to allocate.\n     * Second loop: copy to the allocated memory.\n     */\n    for (copy = 0; copy <= 1; ++copy)\n    {\n\tr = buttons;\n\tidx = 0;\n\twhile (*r)\n\t{\n\t    if (*r == DLG_BUTTON_SEP)\n\t    {\n\t\tif (copy)\n\t\t{\n\t\t    *msgp++ = ',';\n\t\t    *msgp++ = ' ';\t    // '\\n' -> ', '\n\n\t\t    // advance to next hotkey and set default hotkey\n\t\t    if (has_mbyte)\n\t\t\thotkp += STRLEN(hotkp);\n\t\t    else\n\t\t\t++hotkp;\n\t\t    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;\n\t\t    if (dfltbutton)\n\t\t\t--dfltbutton;\n\n\t\t    // If no hotkey is specified first char is used.\n\t\t    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])\n\t\t\tfirst_hotkey = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    len += 3;\t\t    // '\\n' -> ', '; 'x' -> '(x)'\n\t\t    lenhotkey += HOTK_LEN;  // each button needs a hotkey\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[++idx] = FALSE;\n\t\t}\n\t    }\n\t    else if (*r == DLG_HOTKEY_CHAR || first_hotkey)\n\t    {\n\t\tif (*r == DLG_HOTKEY_CHAR)\n\t\t    ++r;\n\t\tfirst_hotkey = FALSE;\n\t\tif (copy)\n\t\t{\n\t\t    if (*r == DLG_HOTKEY_CHAR)\t\t// '&&a' -> '&a'\n\t\t\t*msgp++ = *r;\n\t\t    else\n\t\t    {\n\t\t\t// '&a' -> '[a]'\n\t\t\t*msgp++ = (dfltbutton == 1) ? '[' : '(';\n\t\t\tmsgp += copy_char(r, msgp, FALSE);\n\t\t\t*msgp++ = (dfltbutton == 1) ? ']' : ')';\n\n\t\t\t// redefine hotkey\n\t\t\thotkp[copy_char(r, hotkp, TRUE)] = NUL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++len;\t    // '&a' -> '[a]'\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[idx] = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// everything else copy literally\n\t\tif (copy)\n\t\t    msgp += copy_char(r, msgp, FALSE);\n\t    }\n\n\t    // advance to the next character\n\t    MB_PTR_ADV(r);\n\t}\n\n\tif (copy)\n\t{\n\t    *msgp++ = ':';\n\t    *msgp++ = ' ';\n\t    *msgp = NUL;\n\t}\n\telse\n\t{\n\t    len += (int)(STRLEN(message)\n\t\t\t+ 2\t\t\t// for the NL's\n\t\t\t+ STRLEN(buttons)\n\t\t\t+ 3);\t\t\t// for the \": \" and NUL\n\t    lenhotkey++;\t\t\t// for the NUL\n\n\t    // If no hotkey is specified first char is used.\n\t    if (!has_hotkey[0])\n\t    {\n\t\tfirst_hotkey = TRUE;\n\t\tlen += 2;\t\t// \"x\" -> \"[x]\"\n\t    }\n\n\t    /*\n\t     * Now allocate and load the strings\n\t     */\n\t    vim_free(confirm_msg);\n\t    confirm_msg = alloc(len);\n\t    if (confirm_msg == NULL)\n\t\treturn NULL;\n\t    *confirm_msg = NUL;\n\t    hotk = alloc(lenhotkey);\n\t    if (hotk == NULL)\n\t\treturn NULL;\n\n\t    *confirm_msg = '\\n';\n\t    STRCPY(confirm_msg + 1, message);\n\n\t    msgp = confirm_msg + 1 + STRLEN(message);\n\t    hotkp = hotk;\n\n\t    // Define first default hotkey.  Keep the hotkey string NUL\n\t    // terminated to avoid reading past the end.\n\t    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;\n\n\t    // Remember where the choices start, displaying starts here when\n\t    // \"hotkp\" typed at the more prompt.\n\t    confirm_msg_tail = msgp;\n\t    *msgp++ = '\\n';\n\t}\n    }\n\n    display_confirm_msg();\n    return hotk;\n}\n\n/*\n * Display the \":confirm\" message.  Also called when screen resized.\n */\n    static void\ndisplay_confirm_msg(void)\n{\n    // avoid that 'q' at the more prompt truncates the message here\n    ++confirm_msg_used;\n    if (confirm_msg != NULL)\n\tmsg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));\n    --confirm_msg_used;\n}\n\n#endif // FEAT_CON_DIALOG\n\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\n    int\nvim_dialog_yesno(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    if (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)\n\treturn VIM_YES;\n    return VIM_NO;\n}\n\n    int\nvim_dialog_yesnocancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n    }\n    return VIM_CANCEL;\n}\n\n    int\nvim_dialog_yesnoallcancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)\"Question\" : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),\n\t\t\t\t\t\t\t   dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n\tcase 3: return VIM_ALL;\n\tcase 4: return VIM_DISCARDALL;\n    }\n    return VIM_CANCEL;\n}\n\n#endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG\n", "\" Some tests, that used to crash Vim\nsource check.vim\nsource screendump.vim\n\nCheckScreendump\n\nfunc Test_crash1()\n  CheckNotBSD\n  CheckExecutable dash\n  \" Test 7 fails on Mac ...\n  CheckNotMac\n\n  \" The following used to crash Vim\n  let opts = #{cmd: 'sh'}\n  let vim  = GetVimProg()\n\n  let buf = RunVimInTerminal('sh', opts)\n\n  let file = 'crash/poc_huaf1'\n  let cmn_args = \"%s -u NONE -i NONE -n -e -s -S %s -c ':qa!'\"\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 1: [OK]\" > X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 50)\n\n  let file = 'crash/poc_huaf2'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 2: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 50)\n\n  let file = 'crash/poc_huaf3'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 3: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 100)\n\n  let file = 'crash/bt_quickfix_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 4: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  \" clean up\n  call delete('Xerr')\n  \" This test takes a bit longer\n  call TermWait(buf, 1000)\n\n  let file = 'crash/poc_tagfunc.vim'\n  let args = printf(cmn_args, vim, file)\n  \" using || because this poc causes vim to exit with exitstatus != 0\n  call term_sendkeys(buf, args ..\n    \\ '  || echo \"crash 5: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n\n  call TermWait(buf, 100)\n\n  let file = 'crash/bt_quickfix1_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 6: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  \" clean up\n  call delete('X')\n  call TermWait(buf, 3000)\n\n  let file = 'crash/vim_regsub_both_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  && echo \"crash 7: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 3000)\n\n  let file = 'crash/vim_msg_trunc_poc'\n  let args = printf(cmn_args, vim, file)\n  call term_sendkeys(buf, args ..\n    \\ '  || echo \"crash 8: [OK]\" >> X_crash1_result.txt' .. \"\\<cr>\")\n  call TermWait(buf, 3000)\n\n  \" clean up\n  exe buf .. \"bw!\"\n\n  sp X_crash1_result.txt\n\n  let expected = [\n      \\ 'crash 1: [OK]',\n      \\ 'crash 2: [OK]',\n      \\ 'crash 3: [OK]',\n      \\ 'crash 4: [OK]',\n      \\ 'crash 5: [OK]',\n      \\ 'crash 6: [OK]',\n      \\ 'crash 7: [OK]',\n      \\ 'crash 8: [OK]',\n      \\ ]\n\n  call assert_equal(expected, getline(1, '$'))\n  bw!\n\n  call delete('X_crash1_result.txt')\nendfunc\n\nfunc Test_crash2()\n  \" The following used to crash Vim\n  let opts = #{wait_for_ruler: 0, rows: 20}\n  let args = ' -u NONE -i NONE -n -e -s -S '\n  let buf = RunVimInTerminal(args .. ' crash/vim_regsub_both', opts)\n  call VerifyScreenDump(buf, 'Test_crash_01', {})\n  exe buf .. \"bw!\"\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/message.c", "src/testdir/test_crash.vim", "src/version.c"], "buggy_code_start_loc": [356, 68, 706], "buggy_code_end_loc": [357, 81, 706], "fixing_code_start_loc": [356, 69, 707], "fixing_code_end_loc": [357, 89, 709], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1969.", "other": {"cve": {"id": "CVE-2023-5344", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-02T20:15:10.327", "lastModified": "2023-12-13T01:15:11.123", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1969."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en mont\u00f3n en el repositorio de GitHub vim/vim anterior a 9.0.1969."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1969", "matchCriteriaId": "553DABFB-28FC-415B-93DC-911110BF8DFB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Dec/10", "source": "security@huntr.dev"}, {"url": "http://seclists.org/fulldisclosure/2023/Dec/11", "source": "security@huntr.dev"}, {"url": "http://seclists.org/fulldisclosure/2023/Dec/9", "source": "security@huntr.dev"}, {"url": "https://github.com/vim/vim/commit/3bd7fa12e146c6051490d048a4acbfba974eeb04", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/530cb762-899e-48d7-b50e-dad09eb775bf", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4W665GQBN6S6ZDMYWVF4X7KMFI7AQKJL/", "source": "security@huntr.dev", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XPT7NMYJRLBPIALGSE24UWTY6F774GZW/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOXBUJLJ5VSPN3YXWN7XZA4JDYKNE7GZ/", "source": "security@huntr.dev", "tags": ["Mailing List"]}, {"url": "https://support.apple.com/kb/HT214036", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT214037", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT214038", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/3bd7fa12e146c6051490d048a4acbfba974eeb04"}}