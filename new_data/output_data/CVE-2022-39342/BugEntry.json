{"buggy_code": ["package typesystem\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-errors/errors\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nconst (\n\tSchemaVersion1_0 = \"1.0\"\n\tSchemaVersion1_1 = \"1.1\"\n)\n\nvar (\n\tErrDuplicateTypes       = errors.New(\"an authorization model cannot contain duplicate types\")\n\tErrInvalidSchemaVersion = errors.New(\"invalid schema version\")\n)\n\nfunc RelationReference(objectType, relation string) *openfgapb.RelationReference {\n\treturn &openfgapb.RelationReference{\n\t\tType:     objectType,\n\t\tRelation: relation,\n\t}\n}\n\nfunc This() *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_This{},\n\t}\n}\n\nfunc ComputedUserset(relation string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\tRelation: relation,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc TupleToUserset(tuplesetRelation, targetRelation string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: tuplesetRelation,\n\t\t\t\t},\n\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: targetRelation,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Union(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Union{\n\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Intersection(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Difference(base *openfgapb.Userset, sub *openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: sub,\n\t\t\t},\n\t\t},\n\t}\n}\n\ntype TypeSystem struct {\n\tschemaVersion   string\n\ttypeDefinitions map[string]*openfgapb.TypeDefinition\n}\n\n// New creates a *TypeSystem from an *openfgapb.AuthorizationModel. New assumes that the model\n// has already been validated.\nfunc New(model *openfgapb.AuthorizationModel) *TypeSystem {\n\ttds := map[string]*openfgapb.TypeDefinition{}\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\ttds[td.GetType()] = td\n\t}\n\n\treturn &TypeSystem{\n\t\tschemaVersion:   model.GetSchemaVersion(),\n\t\ttypeDefinitions: tds,\n\t}\n}\n\nfunc (t *TypeSystem) GetSchemaVersion() string {\n\treturn t.schemaVersion\n}\n\nfunc (t *TypeSystem) GetTypeDefinitions() map[string]*openfgapb.TypeDefinition {\n\treturn t.typeDefinitions\n}\n\nfunc (t *TypeSystem) GetTypeDefinition(objectType string) (*openfgapb.TypeDefinition, bool) {\n\tif typeDefinition, ok := t.typeDefinitions[objectType]; ok {\n\t\treturn typeDefinition, true\n\t}\n\treturn nil, false\n}\n\nfunc (t *TypeSystem) GetRelations(objectType string) (map[string]*openfgapb.Relation, bool) {\n\ttd, ok := t.typeDefinitions[objectType]\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\trelations := map[string]*openfgapb.Relation{}\n\n\tfor relation, rewrite := range td.GetRelations() {\n\t\tr := &openfgapb.Relation{\n\t\t\tName:     relation,\n\t\t\tRewrite:  rewrite,\n\t\t\tTypeInfo: &openfgapb.RelationTypeInfo{},\n\t\t}\n\n\t\tif metadata, ok := td.GetMetadata().GetRelations()[relation]; ok {\n\t\t\tr.TypeInfo.DirectlyRelatedUserTypes = metadata.GetDirectlyRelatedUserTypes()\n\t\t}\n\n\t\trelations[relation] = r\n\t}\n\n\treturn relations, true\n}\n\nfunc (t *TypeSystem) GetRelation(objectType, relation string) (*openfgapb.Relation, bool) {\n\trelations, ok := t.GetRelations(objectType)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\tr, ok := relations[relation]\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\treturn r, true\n}\n\nfunc (t *TypeSystem) GetDirectlyRelatedUserTypes(objectType, relation string) []*openfgapb.RelationReference {\n\tif r, ok := t.GetRelation(objectType, relation); ok {\n\t\treturn r.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t}\n\n\treturn nil\n}\n\n// IsDirectlyRelated determines whether the type of the target RelationReference contains the source RelationReference.\nfunc (t *TypeSystem) IsDirectlyRelated(target *openfgapb.RelationReference, source *openfgapb.RelationReference) bool {\n\tif relation, ok := t.GetRelation(target.GetType(), target.GetRelation()); ok {\n\t\tfor _, relationReference := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tif source.GetType() == relationReference.GetType() && source.GetRelation() == relationReference.GetRelation() {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Validate validates an *openfgapb.AuthorizationModel according to the following rules:\n//  1. Checks that the model have a valid schema version.\n//  2. For every rewrite the relations in the rewrite must:\n//     a. Be valid relations on the same type in the authorization model (in cases of computedUserset)\n//     b. Be valid relations on another existing type (in cases of tupleToUserset)\n//  3. Do not allow duplicate types or duplicate relations (only need to check types as relations are\n//     in a map so cannot contain duplicates)\n//\n// If the authorization model has a v1.1 schema version  (with types on relations), then additionally\n// validate the type system according to the following rules:\n//  3. Every type restriction on a relation must be a valid type:\n//     a. For a type (e.g. user) this means checking that this type is in the TypeSystem\n//     b. For a type#relation this means checking that this type with this relation is in the TypeSystem\n//  4. Check that a relation is assignable if and only if it has a non-zero list of types\nfunc Validate(model *openfgapb.AuthorizationModel) error {\n\tschemaVersion := model.GetSchemaVersion()\n\n\tif schemaVersion != SchemaVersion1_0 && schemaVersion != SchemaVersion1_1 {\n\t\treturn ErrInvalidSchemaVersion\n\t}\n\n\tif containsDuplicateType(model) {\n\t\treturn ErrDuplicateTypes\n\t}\n\n\tif err := validateRelationRewrites(model); err != nil {\n\t\treturn err\n\t}\n\n\tif schemaVersion == SchemaVersion1_1 {\n\t\tif err := validateRelationTypeRestrictions(model); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc containsDuplicateType(model *openfgapb.AuthorizationModel) bool {\n\tseen := map[string]struct{}{}\n\tfor _, td := range model.TypeDefinitions {\n\t\tobjectType := td.GetType()\n\t\tif _, ok := seen[objectType]; ok {\n\t\t\treturn true\n\t\t}\n\t\tseen[objectType] = struct{}{}\n\t}\n\treturn false\n}\n\nfunc validateRelationRewrites(model *openfgapb.AuthorizationModel) error {\n\ttypeDefinitions := model.GetTypeDefinitions()\n\n\tallRelations := map[string]struct{}{}\n\ttypeToRelations := map[string]map[string]struct{}{}\n\tfor _, td := range typeDefinitions {\n\t\tobjectType := td.GetType()\n\t\ttypeToRelations[objectType] = map[string]struct{}{}\n\t\tfor relation := range td.GetRelations() {\n\t\t\ttypeToRelations[objectType][relation] = struct{}{}\n\t\t\tallRelations[relation] = struct{}{}\n\t\t}\n\t}\n\n\tfor _, td := range typeDefinitions {\n\t\tobjectType := td.GetType()\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\terr := isUsersetRewriteValid(allRelations, typeToRelations[objectType], objectType, relation, rewrite)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// isUsersetRewriteValid checks if a particular userset rewrite is valid. The first argument is all the relations in\n// the typeSystem, the second argument is the subset of relations on the type where the rewrite occurs.\nfunc isUsersetRewriteValid(allRelations map[string]struct{}, relationsOnType map[string]struct{}, objectType, relation string, rewrite *openfgapb.Userset) error {\n\tif rewrite.GetUserset() == nil {\n\t\treturn InvalidRelationError(objectType, relation)\n\t}\n\n\tswitch t := rewrite.GetUserset().(type) {\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\tcomputedUserset := t.ComputedUserset.GetRelation()\n\t\tif computedUserset == relation {\n\t\t\treturn InvalidRelationError(objectType, relation)\n\t\t}\n\t\tif _, ok := relationsOnType[computedUserset]; !ok {\n\t\t\treturn RelationDoesNotExistError(objectType, computedUserset)\n\t\t}\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\ttupleset := t.TupleToUserset.GetTupleset().GetRelation()\n\t\tif _, ok := relationsOnType[tupleset]; !ok {\n\t\t\treturn RelationDoesNotExistError(objectType, tupleset)\n\t\t}\n\n\t\tcomputedUserset := t.TupleToUserset.GetComputedUserset().GetRelation()\n\t\tif _, ok := allRelations[computedUserset]; !ok {\n\t\t\treturn RelationDoesNotExistError(\"\", computedUserset)\n\t\t}\n\tcase *openfgapb.Userset_Union:\n\t\tfor _, child := range t.Union.GetChild() {\n\t\t\terr := isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Intersection:\n\t\tfor _, child := range t.Intersection.GetChild() {\n\t\t\terr := isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Difference:\n\t\terr := isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, t.Difference.Base)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, t.Difference.Subtract)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc validateRelationTypeRestrictions(model *openfgapb.AuthorizationModel) error {\n\tt := New(model)\n\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, ok := t.GetRelations(objectType)\n\t\tif !ok {\n\t\t\treturn InvalidRelationError(objectType, \"\")\n\t\t}\n\n\t\tfor name, relation := range relations {\n\t\t\trelatedTypes := relation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\n\t\t\tassignable := t.IsDirectlyAssignable(relation)\n\t\t\tif assignable && len(relatedTypes) == 0 {\n\t\t\t\treturn AssignableRelationError(objectType, name)\n\t\t\t}\n\n\t\t\tif !assignable && len(relatedTypes) != 0 {\n\t\t\t\treturn NonAssignableRelationError(objectType, name)\n\t\t\t}\n\n\t\t\tfor _, related := range relatedTypes {\n\t\t\t\trelatedObjectType := related.GetType()\n\t\t\t\trelatedRelation := related.GetRelation()\n\n\t\t\t\tif _, ok := t.GetRelations(relatedObjectType); !ok {\n\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t}\n\n\t\t\t\tif relatedRelation != \"\" {\n\t\t\t\t\tif _, ok := t.GetRelation(relatedObjectType, relatedRelation); !ok {\n\t\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) IsDirectlyAssignable(relation *openfgapb.Relation) bool {\n\trewrite := relation.GetRewrite()\n\n\treturn ContainsSelf(rewrite)\n}\n\nfunc ContainsSelf(rewrite *openfgapb.Userset) bool {\n\tswitch rw := rewrite.GetUserset().(type) {\n\tcase *openfgapb.Userset_This:\n\t\treturn true\n\tcase *openfgapb.Userset_Union:\n\t\tfor _, child := range rw.Union.GetChild() {\n\t\t\tif ContainsSelf(child) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Intersection:\n\t\tfor _, child := range rw.Intersection.GetChild() {\n\t\t\tif ContainsSelf(child) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Difference:\n\t\tdifference := rw.Difference\n\t\tif ContainsSelf(difference.GetBase()) || ContainsSelf(difference.GetSubtract()) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc InvalidRelationError(objectType, relation string) error {\n\treturn errors.Errorf(\"the definition of relation '%s' in object type '%s' is invalid\", relation, objectType)\n}\n\nfunc ObjectTypeDoesNotExistError(objectType string) error {\n\treturn errors.Errorf(\"object type '%s' does not exist\", objectType)\n}\n\n// RelationDoesNotExistError may have an empty objectType, but must have a relation\n// (otherwise the error won't make much sense).\nfunc RelationDoesNotExistError(objectType, relation string) error {\n\tmsg := fmt.Sprintf(\"relation '%s'\", relation)\n\tif objectType != \"\" {\n\t\tmsg = fmt.Sprintf(\"%s in object type '%s'\", msg, objectType)\n\t}\n\treturn errors.Errorf(\"%s does not exist\", msg)\n}\n\nfunc AssignableRelationError(objectType, relation string) error {\n\treturn errors.Errorf(\"the assignable relation '%s' in object type '%s' must contain at least one relation type\", relation, objectType)\n}\n\nfunc NonAssignableRelationError(objectType, relation string) error {\n\treturn errors.Errorf(\"the non-assignable relation '%s' in object type '%s' should not contain a relation type\", objectType, relation)\n}\n\nfunc InvalidRelationTypeError(objectType, relation, relatedObjectType, relatedRelation string) error {\n\trelationType := relatedObjectType\n\tif relatedRelation != \"\" {\n\t\trelationType = fmt.Sprintf(\"%s#%s\", relatedObjectType, relatedRelation)\n\t}\n\n\treturn errors.Errorf(\"the relation type '%s' on '%s' in object type '%s' is not valid\", relationType, relation, objectType)\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/openfga/openfga/server/commands\"\n\t\"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc WriteAuthorizationModelTest(t *testing.T, datastore storage.OpenFGADatastore) {\n\tstoreID, err := id.NewString()\n\trequire.NoError(t, err)\n\n\titems := make([]*openfgapb.TypeDefinition, datastore.MaxTypesInTypeDefinition()+1)\n\tfor i := 0; i < datastore.MaxTypesInTypeDefinition(); i++ {\n\t\titems[i] = &openfgapb.TypeDefinition{\n\t\t\tType: fmt.Sprintf(\"type%v\", i),\n\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t},\n\t\t}\n\t}\n\n\tvar tests = []struct {\n\t\tname    string\n\t\trequest *openfgapb.WriteAuthorizationModelRequest\n\t\terr     error\n\t}{\n\t\t{\n\t\t\tname: \"succeeds\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"succeeds part II\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: \"somestoreid\",\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset:        &openfgapb.ObjectRelation{Relation: \"owner\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"member\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"fails if too many types\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:         storeID,\n\t\t\t\tTypeDefinitions: items,\n\t\t\t},\n\t\t\terr: errors.ExceededEntityLimit(\"type definitions in an authorization model\", datastore.MaxTypesInTypeDefinition()),\n\t\t},\n\t\t{\n\t\t\tname: \"empty relations is valid\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero length relations is valid\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfSameTypeTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.ErrDuplicateTypes),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfEmptyRewrites\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInComputedUserset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tObject:   \"\",\n\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInTupleToUserset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInUnion\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInDifferenceBaseArgument\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInDifferenceSubtractArgument\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInTupleToUsersetTupleset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"from\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInTupleToUsersetComputedUserset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfTupleToUsersetReferencesUnknownRelation\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"foo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"bar\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"bar\", \"writer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInIntersection\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfDifferenceIncludesSameRelationTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"viewer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnionIncludesSameRelationTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"viewer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfIntersectionIncludesSameRelationTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: errors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"viewer\")),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewWriteAuthorizationModelCommand(datastore, logger)\n\t\t\tresp, err := cmd.Execute(ctx, test.request)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\n\t\t\tif err == nil {\n\t\t\t\trequire.True(t, id.IsValid(resp.AuthorizationModelId))\n\t\t\t}\n\t\t})\n\t}\n}\n"], "fixing_code": ["package typesystem\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/go-errors/errors\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nconst (\n\tSchemaVersion1_0 = \"1.0\"\n\tSchemaVersion1_1 = \"1.1\"\n)\n\nvar (\n\tErrDuplicateTypes       = errors.New(\"an authorization model cannot contain duplicate types\")\n\tErrInvalidSchemaVersion = errors.New(\"invalid schema version\")\n)\n\nfunc RelationReference(objectType, relation string) *openfgapb.RelationReference {\n\treturn &openfgapb.RelationReference{\n\t\tType:     objectType,\n\t\tRelation: relation,\n\t}\n}\n\nfunc This() *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_This{},\n\t}\n}\n\nfunc ComputedUserset(relation string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\tRelation: relation,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc TupleToUserset(tuplesetRelation, targetRelation string) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: tuplesetRelation,\n\t\t\t\t},\n\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\tRelation: targetRelation,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Union(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Union{\n\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Intersection(children ...*openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\tChild: children,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Difference(base *openfgapb.Userset, sub *openfgapb.Userset) *openfgapb.Userset {\n\treturn &openfgapb.Userset{\n\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\tBase:     base,\n\t\t\t\tSubtract: sub,\n\t\t\t},\n\t\t},\n\t}\n}\n\ntype TypeSystem struct {\n\tschemaVersion   string\n\ttypeDefinitions map[string]*openfgapb.TypeDefinition\n}\n\n// New creates a *TypeSystem from an *openfgapb.AuthorizationModel. New assumes that the model\n// has already been validated.\nfunc New(model *openfgapb.AuthorizationModel) *TypeSystem {\n\ttds := map[string]*openfgapb.TypeDefinition{}\n\tfor _, td := range model.GetTypeDefinitions() {\n\t\ttds[td.GetType()] = td\n\t}\n\n\treturn &TypeSystem{\n\t\tschemaVersion:   model.GetSchemaVersion(),\n\t\ttypeDefinitions: tds,\n\t}\n}\n\nfunc (t *TypeSystem) GetSchemaVersion() string {\n\treturn t.schemaVersion\n}\n\nfunc (t *TypeSystem) GetTypeDefinitions() map[string]*openfgapb.TypeDefinition {\n\treturn t.typeDefinitions\n}\n\nfunc (t *TypeSystem) GetTypeDefinition(objectType string) (*openfgapb.TypeDefinition, bool) {\n\tif typeDefinition, ok := t.typeDefinitions[objectType]; ok {\n\t\treturn typeDefinition, true\n\t}\n\treturn nil, false\n}\n\nfunc (t *TypeSystem) GetRelations(objectType string) (map[string]*openfgapb.Relation, bool) {\n\ttd, ok := t.typeDefinitions[objectType]\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\trelations := map[string]*openfgapb.Relation{}\n\n\tfor relation, rewrite := range td.GetRelations() {\n\t\tr := &openfgapb.Relation{\n\t\t\tName:     relation,\n\t\t\tRewrite:  rewrite,\n\t\t\tTypeInfo: &openfgapb.RelationTypeInfo{},\n\t\t}\n\n\t\tif metadata, ok := td.GetMetadata().GetRelations()[relation]; ok {\n\t\t\tr.TypeInfo.DirectlyRelatedUserTypes = metadata.GetDirectlyRelatedUserTypes()\n\t\t}\n\n\t\trelations[relation] = r\n\t}\n\n\treturn relations, true\n}\n\nfunc (t *TypeSystem) GetRelation(objectType, relation string) (*openfgapb.Relation, bool) {\n\trelations, ok := t.GetRelations(objectType)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\tr, ok := relations[relation]\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\treturn r, true\n}\n\nfunc (t *TypeSystem) GetDirectlyRelatedUserTypes(objectType, relation string) []*openfgapb.RelationReference {\n\tif r, ok := t.GetRelation(objectType, relation); ok {\n\t\treturn r.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\t}\n\n\treturn nil\n}\n\n// IsDirectlyRelated determines whether the type of the target RelationReference contains the source RelationReference.\nfunc (t *TypeSystem) IsDirectlyRelated(target *openfgapb.RelationReference, source *openfgapb.RelationReference) bool {\n\tif relation, ok := t.GetRelation(target.GetType(), target.GetRelation()); ok {\n\t\tfor _, relationReference := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {\n\t\t\tif source.GetType() == relationReference.GetType() && source.GetRelation() == relationReference.GetRelation() {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Validate validates an *openfgapb.AuthorizationModel according to the following rules:\n//  1. Checks that the model have a valid schema version.\n//  2. For every rewrite the relations in the rewrite must:\n//     a. Be valid relations on the same type in the authorization model (in cases of computedUserset)\n//     b. Be valid relations on another existing type (in cases of tupleToUserset)\n//  3. Do not allow duplicate types or duplicate relations (only need to check types as relations are\n//     in a map so cannot contain duplicates)\n//\n// If the authorization model has a v1.1 schema version  (with types on relations), then additionally\n// validate the type system according to the following rules:\n//  3. Every type restriction on a relation must be a valid type:\n//     a. For a type (e.g. user) this means checking that this type is in the TypeSystem\n//     b. For a type#relation this means checking that this type with this relation is in the TypeSystem\n//  4. Check that a relation is assignable if and only if it has a non-zero list of types\nfunc Validate(model *openfgapb.AuthorizationModel) error {\n\tschemaVersion := model.GetSchemaVersion()\n\n\tif schemaVersion != SchemaVersion1_0 && schemaVersion != SchemaVersion1_1 {\n\t\treturn ErrInvalidSchemaVersion\n\t}\n\n\tif containsDuplicateType(model) {\n\t\treturn ErrDuplicateTypes\n\t}\n\n\tif err := validateRelationRewrites(model); err != nil {\n\t\treturn err\n\t}\n\n\tif schemaVersion == SchemaVersion1_1 {\n\t\tif err := validateRelationTypeRestrictions(model); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc containsDuplicateType(model *openfgapb.AuthorizationModel) bool {\n\tseen := map[string]struct{}{}\n\tfor _, td := range model.TypeDefinitions {\n\t\tobjectType := td.GetType()\n\t\tif _, ok := seen[objectType]; ok {\n\t\t\treturn true\n\t\t}\n\t\tseen[objectType] = struct{}{}\n\t}\n\treturn false\n}\n\nfunc validateRelationRewrites(model *openfgapb.AuthorizationModel) error {\n\ttypeDefinitions := model.GetTypeDefinitions()\n\n\trelations := map[string]*openfgapb.Relation{}\n\ttyperels := map[string]map[string]*openfgapb.Relation{}\n\n\tfor _, td := range typeDefinitions {\n\t\tobjectType := td.GetType()\n\n\t\ttyperels[objectType] = map[string]*openfgapb.Relation{}\n\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\trelationMetadata := td.GetMetadata().GetRelations()\n\t\t\tmd, ok := relationMetadata[relation]\n\n\t\t\tvar typeinfo *openfgapb.RelationTypeInfo\n\t\t\tif ok {\n\t\t\t\ttypeinfo = &openfgapb.RelationTypeInfo{\n\t\t\t\t\tDirectlyRelatedUserTypes: md.GetDirectlyRelatedUserTypes(),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tr := &openfgapb.Relation{\n\t\t\t\tName:     relation,\n\t\t\t\tRewrite:  rewrite,\n\t\t\t\tTypeInfo: typeinfo,\n\t\t\t}\n\n\t\t\ttyperels[objectType][relation] = r\n\t\t\trelations[relation] = r\n\t\t}\n\t}\n\n\tfor _, td := range typeDefinitions {\n\t\tobjectType := td.GetType()\n\n\t\tfor relation, rewrite := range td.GetRelations() {\n\t\t\terr := isUsersetRewriteValid(relations, typerels[objectType], objectType, relation, rewrite)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// isUsersetRewriteValid checks if a particular userset rewrite is valid. The first argument is all the relations in\n// the typeSystem, the second argument is the subset of relations on the type where the rewrite occurs.\nfunc isUsersetRewriteValid(\n\tallRelations map[string]*openfgapb.Relation,\n\trelationsOnType map[string]*openfgapb.Relation,\n\tobjectType, relation string,\n\trewrite *openfgapb.Userset,\n) error {\n\tif rewrite.GetUserset() == nil {\n\t\treturn InvalidRelationError(objectType, relation)\n\t}\n\n\tswitch t := rewrite.GetUserset().(type) {\n\tcase *openfgapb.Userset_ComputedUserset:\n\t\tcomputedUserset := t.ComputedUserset.GetRelation()\n\t\tif computedUserset == relation {\n\t\t\treturn InvalidRelationError(objectType, relation)\n\t\t}\n\t\tif _, ok := relationsOnType[computedUserset]; !ok {\n\t\t\treturn RelationDoesNotExistError(objectType, computedUserset)\n\t\t}\n\tcase *openfgapb.Userset_TupleToUserset:\n\t\ttupleset := t.TupleToUserset.GetTupleset().GetRelation()\n\n\t\ttuplesetRelation, ok := relationsOnType[tupleset]\n\t\tif !ok {\n\t\t\treturn RelationDoesNotExistError(objectType, tupleset)\n\t\t}\n\n\t\t// tupleset relations must only be direct relationships, no rewrites\n\t\t// are allowed on them\n\t\ttuplesetRewrite := tuplesetRelation.GetRewrite()\n\t\tif reflect.TypeOf(tuplesetRewrite.GetUserset()) != reflect.TypeOf(&openfgapb.Userset_This{}) {\n\t\t\treturn errors.Errorf(\"the '%s#%s' relation is referenced in at least one tupleset and thus must be a direct relation\", objectType, tupleset)\n\t\t}\n\n\t\tcomputedUserset := t.TupleToUserset.GetComputedUserset().GetRelation()\n\t\tif _, ok := allRelations[computedUserset]; !ok {\n\t\t\treturn RelationDoesNotExistError(\"\", computedUserset)\n\t\t}\n\tcase *openfgapb.Userset_Union:\n\t\tfor _, child := range t.Union.GetChild() {\n\t\t\terr := isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Intersection:\n\t\tfor _, child := range t.Intersection.GetChild() {\n\t\t\terr := isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, child)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Difference:\n\t\terr := isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, t.Difference.Base)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = isUsersetRewriteValid(allRelations, relationsOnType, objectType, relation, t.Difference.Subtract)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc validateRelationTypeRestrictions(model *openfgapb.AuthorizationModel) error {\n\tt := New(model)\n\n\tfor objectType := range t.typeDefinitions {\n\t\trelations, ok := t.GetRelations(objectType)\n\t\tif !ok {\n\t\t\treturn InvalidRelationError(objectType, \"\")\n\t\t}\n\n\t\tfor name, relation := range relations {\n\t\t\trelatedTypes := relation.GetTypeInfo().GetDirectlyRelatedUserTypes()\n\n\t\t\tassignable := t.IsDirectlyAssignable(relation)\n\t\t\tif assignable && len(relatedTypes) == 0 {\n\t\t\t\treturn AssignableRelationError(objectType, name)\n\t\t\t}\n\n\t\t\tif !assignable && len(relatedTypes) != 0 {\n\t\t\t\treturn NonAssignableRelationError(objectType, name)\n\t\t\t}\n\n\t\t\tfor _, related := range relatedTypes {\n\t\t\t\trelatedObjectType := related.GetType()\n\t\t\t\trelatedRelation := related.GetRelation()\n\n\t\t\t\tif _, ok := t.GetRelations(relatedObjectType); !ok {\n\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t}\n\n\t\t\t\tif relatedRelation != \"\" {\n\t\t\t\t\tif _, ok := t.GetRelation(relatedObjectType, relatedRelation); !ok {\n\t\t\t\t\t\treturn InvalidRelationTypeError(objectType, name, relatedObjectType, relatedRelation)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *TypeSystem) IsDirectlyAssignable(relation *openfgapb.Relation) bool {\n\trewrite := relation.GetRewrite()\n\n\treturn ContainsSelf(rewrite)\n}\n\nfunc ContainsSelf(rewrite *openfgapb.Userset) bool {\n\tswitch rw := rewrite.GetUserset().(type) {\n\tcase *openfgapb.Userset_This:\n\t\treturn true\n\tcase *openfgapb.Userset_Union:\n\t\tfor _, child := range rw.Union.GetChild() {\n\t\t\tif ContainsSelf(child) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Intersection:\n\t\tfor _, child := range rw.Intersection.GetChild() {\n\t\t\tif ContainsSelf(child) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\tcase *openfgapb.Userset_Difference:\n\t\tdifference := rw.Difference\n\t\tif ContainsSelf(difference.GetBase()) || ContainsSelf(difference.GetSubtract()) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc InvalidRelationError(objectType, relation string) error {\n\treturn errors.Errorf(\"the definition of relation '%s' in object type '%s' is invalid\", relation, objectType)\n}\n\nfunc ObjectTypeDoesNotExistError(objectType string) error {\n\treturn errors.Errorf(\"object type '%s' does not exist\", objectType)\n}\n\n// RelationDoesNotExistError may have an empty objectType, but must have a relation\n// (otherwise the error won't make much sense).\nfunc RelationDoesNotExistError(objectType, relation string) error {\n\tmsg := fmt.Sprintf(\"relation '%s'\", relation)\n\tif objectType != \"\" {\n\t\tmsg = fmt.Sprintf(\"%s in object type '%s'\", msg, objectType)\n\t}\n\treturn errors.Errorf(\"%s does not exist\", msg)\n}\n\nfunc AssignableRelationError(objectType, relation string) error {\n\treturn errors.Errorf(\"the assignable relation '%s' in object type '%s' must contain at least one relation type\", relation, objectType)\n}\n\nfunc NonAssignableRelationError(objectType, relation string) error {\n\treturn errors.Errorf(\"the non-assignable relation '%s' in object type '%s' should not contain a relation type\", objectType, relation)\n}\n\nfunc InvalidRelationTypeError(objectType, relation, relatedObjectType, relatedRelation string) error {\n\trelationType := relatedObjectType\n\tif relatedRelation != \"\" {\n\t\trelationType = fmt.Sprintf(\"%s#%s\", relatedObjectType, relatedRelation)\n\t}\n\n\treturn errors.Errorf(\"the relation type '%s' on '%s' in object type '%s' is not valid\", relationType, relation, objectType)\n}\n", "package test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/go-errors/errors\"\n\t\"github.com/openfga/openfga/pkg/id\"\n\t\"github.com/openfga/openfga/pkg/logger\"\n\t\"github.com/openfga/openfga/pkg/typesystem\"\n\t\"github.com/openfga/openfga/server/commands\"\n\tserverErrors \"github.com/openfga/openfga/server/errors\"\n\t\"github.com/openfga/openfga/storage\"\n\t\"github.com/stretchr/testify/require\"\n\topenfgapb \"go.buf.build/openfga/go/openfga/api/openfga/v1\"\n)\n\nfunc WriteAuthorizationModelTest(t *testing.T, datastore storage.OpenFGADatastore) {\n\tstoreID, err := id.NewString()\n\trequire.NoError(t, err)\n\n\titems := make([]*openfgapb.TypeDefinition, datastore.MaxTypesInTypeDefinition()+1)\n\tfor i := 0; i < datastore.MaxTypesInTypeDefinition(); i++ {\n\t\titems[i] = &openfgapb.TypeDefinition{\n\t\t\tType: fmt.Sprintf(\"type%v\", i),\n\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t},\n\t\t}\n\t}\n\n\tvar tests = []struct {\n\t\tname    string\n\t\trequest *openfgapb.WriteAuthorizationModelRequest\n\t\terr     error\n\t}{\n\t\t{\n\t\t\tname: \"succeeds\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"succeeds part II\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: \"somestoreid\",\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"group\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"member\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"writer\"},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tTupleset:        &openfgapb.ObjectRelation{Relation: \"owner\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{Relation: \"member\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"fails if too many types\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId:         storeID,\n\t\t\t\tTypeDefinitions: items,\n\t\t\t},\n\t\t\terr: serverErrors.ExceededEntityLimit(\"type definitions in an authorization model\", datastore.MaxTypesInTypeDefinition()),\n\t\t},\n\t\t{\n\t\t\tname: \"empty relations is valid\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"zero length relations is valid\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType:      \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfSameTypeTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"admin\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.ErrDuplicateTypes),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfEmptyRewrites\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInComputedUserset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tObject:   \"\",\n\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInTupleToUserset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInUnion\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInDifferenceBaseArgument\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInDifferenceSubtractArgument\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInTupleToUsersetTupleset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"from\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInTupleToUsersetComputedUserset\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_TupleToUserset{\n\t\t\t\t\t\t\t\t\tTupleToUserset: &openfgapb.TupleToUserset{\n\t\t\t\t\t\t\t\t\t\tTupleset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfTupleToUsersetReferencesUnknownRelation\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"foo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"reader\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"reader\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"bar\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"owner\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\tRelation: \"writer\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"bar\", \"writer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnknownRelationInIntersection\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"writer\": {Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"owner\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.RelationDoesNotExistError(\"repo\", \"owner\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfDifferenceIncludesSameRelationTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Difference{\n\t\t\t\t\t\t\t\t\tDifference: &openfgapb.Difference{\n\t\t\t\t\t\t\t\t\t\tBase: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_This{},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tSubtract: &openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"viewer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfUnionIncludesSameRelationTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Union{\n\t\t\t\t\t\t\t\t\tUnion: &openfgapb.Usersets{\n\t\t\t\t\t\t\t\t\t\tChild: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"viewer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"ExecuteWriteFailsIfIntersectionIncludesSameRelationTwice\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"repo\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"viewer\": {\n\t\t\t\t\t\t\t\tUserset: &openfgapb.Userset_Intersection{\n\t\t\t\t\t\t\t\t\tIntersection: &openfgapb.Usersets{Child: []*openfgapb.Userset{\n\t\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_ComputedUserset{\n\t\t\t\t\t\t\t\t\t\t\tComputedUserset: &openfgapb.ObjectRelation{\n\t\t\t\t\t\t\t\t\t\t\t\tRelation: \"viewer\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t\t\t{Userset: &openfgapb.Userset_This{}},\n\t\t\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(typesystem.InvalidRelationError(\"repo\", \"viewer\")),\n\t\t},\n\t\t{\n\t\t\tname: \"Union Rewrite Contains Repeated Definitions\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"editor\": typesystem.Union(typesystem.This(), typesystem.This()),\n\t\t\t\t\t\t\t\"manage\": typesystem.Union(\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"manage\"),\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"manage\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Intersection Rewrite Contains Repeated Definitions\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.Intersection(\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"editor\": typesystem.Intersection(typesystem.This(), typesystem.This()),\n\t\t\t\t\t\t\t\"manage\": typesystem.Intersection(\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"manage\"),\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"manage\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Exclusion Rewrite Contains Repeated Definitions\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"parent\": typesystem.This(),\n\t\t\t\t\t\t\t\"viewer\": typesystem.Difference(\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t\ttypesystem.ComputedUserset(\"editor\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"editor\": typesystem.Difference(typesystem.This(), typesystem.This()),\n\t\t\t\t\t\t\t\"manage\": typesystem.Difference(\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"manage\"),\n\t\t\t\t\t\t\t\ttypesystem.TupleToUserset(\"parent\", \"manage\"),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Tupleset relation involves ComputedUserset rewrite\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"ancestor\": typesystem.This(),\n\t\t\t\t\t\t\t\"parent\":   typesystem.ComputedUserset(\"ancestor\"),\n\t\t\t\t\t\t\t\"viewer\":   typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the 'document#parent' relation is referenced in at least one tupleset and thus must be a direct relation\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Tupleset relation involves Union rewrite\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"ancestor\": typesystem.This(),\n\t\t\t\t\t\t\t\"parent\":   typesystem.Union(typesystem.This(), typesystem.ComputedUserset(\"ancestor\")),\n\t\t\t\t\t\t\t\"viewer\":   typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the 'document#parent' relation is referenced in at least one tupleset and thus must be a direct relation\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Tupleset relation involves Intersection rewrite\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"ancestor\": typesystem.This(),\n\t\t\t\t\t\t\t\"parent\":   typesystem.Intersection(typesystem.This(), typesystem.ComputedUserset(\"ancestor\")),\n\t\t\t\t\t\t\t\"viewer\":   typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the 'document#parent' relation is referenced in at least one tupleset and thus must be a direct relation\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Tupleset relation involves Exclusion rewrite\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"restricted\": typesystem.This(),\n\t\t\t\t\t\t\t\"parent\":     typesystem.Difference(typesystem.This(), typesystem.ComputedUserset(\"restricted\")),\n\t\t\t\t\t\t\t\"viewer\":     typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the 'document#parent' relation is referenced in at least one tupleset and thus must be a direct relation\"),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tname: \"Tupleset relation involves TupleToUserset rewrite\",\n\t\t\trequest: &openfgapb.WriteAuthorizationModelRequest{\n\t\t\t\tStoreId: storeID,\n\t\t\t\tTypeDefinitions: []*openfgapb.TypeDefinition{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: \"document\",\n\t\t\t\t\t\tRelations: map[string]*openfgapb.Userset{\n\t\t\t\t\t\t\t\"ancestor\": typesystem.This(),\n\t\t\t\t\t\t\t\"parent\":   typesystem.TupleToUserset(\"ancestor\", \"viewer\"),\n\t\t\t\t\t\t\t\"viewer\":   typesystem.TupleToUserset(\"parent\", \"viewer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: serverErrors.InvalidAuthorizationModelInput(\n\t\t\t\terrors.New(\"the 'document#parent' relation is referenced in at least one tupleset and thus must be a direct relation\"),\n\t\t\t),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\tlogger := logger.NewNoopLogger()\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := commands.NewWriteAuthorizationModelCommand(datastore, logger)\n\t\t\tresp, err := cmd.Execute(ctx, test.request)\n\t\t\trequire.ErrorIs(t, err, test.err)\n\n\t\t\tif err == nil {\n\t\t\t\trequire.True(t, id.IsValid(resp.AuthorizationModelId))\n\t\t\t}\n\t\t})\n\t}\n}\n"], "filenames": ["pkg/typesystem/typesystem.go", "server/test/write_authzmodel.go"], "buggy_code_start_loc": [4, 7], "buggy_code_end_loc": [279, 534], "fixing_code_start_loc": [5, 8], "fixing_code_end_loc": [315, 699], "type": "CWE-863", "message": "OpenFGA is an authorization/permission engine. Versions prior to version 0.2.4 are vulnerable to authorization bypass under certain conditions. Users whose model has a relation defined as a tupleset (the right hand side of a \u00e2\u20ac\u02dcfrom\u00e2\u20ac\u2122 statement) that involves anything other than a direct relationship (e.g. \u00e2\u20ac\u02dcas self\u00e2\u20ac\u2122) are vulnerable. Version 0.2.4 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-39342", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-25T17:15:56.333", "lastModified": "2022-10-26T00:52:04.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenFGA is an authorization/permission engine. Versions prior to version 0.2.4 are vulnerable to authorization bypass under certain conditions. Users whose model has a relation defined as a tupleset (the right hand side of a \u00e2\u20ac\u02dcfrom\u00e2\u20ac\u2122 statement) that involves anything other than a direct relationship (e.g. \u00e2\u20ac\u02dcas self\u00e2\u20ac\u2122) are vulnerable. Version 0.2.4 contains a patch for this issue."}, {"lang": "es", "value": "OpenFGA es un motor de autorizaci\u00f3n/permiso. Las versiones anteriores a 0.2.4 son vulnerables a la omisi\u00f3n de la autorizaci\u00f3n bajo determinadas condiciones. Los usuarios cuyo modelo presenta una relaci\u00f3n definida como un conjunto de tuplas (el lado derecho de una declaraci\u00f3n \"from\") que implica cualquier cosa que no sea una relaci\u00f3n directa (por ejemplo, \"as self\") son vulnerables. La versi\u00f3n 0.2.4 contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openfga:openfga:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.4", "matchCriteriaId": "6C8497C4-6109-40A8-AA89-E20BF94EB4C2"}]}]}], "references": [{"url": "https://github.com/openfga/openfga/commit/c8db1ee3d2a366f18e585dd33236340e76e784c4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openfga/openfga/releases/tag/v0.2.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/openfga/openfga/security/advisories/GHSA-f4mm-2r69-mg5f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openfga/openfga/commit/c8db1ee3d2a366f18e585dd33236340e76e784c4"}}