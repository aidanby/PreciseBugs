{"buggy_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed crash bugs for books (Issue #412, Issue #414)\n- Fixed a number-up crash bug (Issue #413)\n- Fixed JPEG error handling (Issue #415)\n- Fixed crash bugs with bogus table attributes (Issue #416, Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed some issues reported by Coverity.\n- Removed the bundled libjpeg, libpng, and zlib.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * HTML parsing routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright 2011-2020 by Michael R Sweet.\n * Copyright 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include \"http.h\"\n#include <ctype.h>\n\n\n/*\n * Markup strings...\n */\n\nconst char\t*_htmlMarkups[] =\n\t\t{\n\t\t  \"\",\t\t/* MARKUP_NONE */\n\t\t  \"!--\",\t/* MARKUP_COMMENT */\n\t\t  \"!DOCTYPE\",\n\t\t  \"a\",\n\t\t  \"acronym\",\n\t\t  \"address\",\n\t\t  \"applet\",\n\t\t  \"area\",\n\t\t  \"b\",\n\t\t  \"base\",\n\t\t  \"basefont\",\n\t\t  \"big\",\n\t\t  \"blink\",\n\t\t  \"blockquote\",\n\t\t  \"body\",\n\t\t  \"br\",\n\t\t  \"caption\",\n\t\t  \"center\",\n\t\t  \"cite\",\n\t\t  \"code\",\n\t\t  \"col\",\n\t\t  \"colgroup\",\n\t\t  \"dd\",\n\t\t  \"del\",\n\t\t  \"dfn\",\n\t\t  \"dir\",\n\t\t  \"div\",\n\t\t  \"dl\",\n\t\t  \"dt\",\n\t\t  \"em\",\n\t\t  \"embed\",\n\t\t  \"font\",\n\t\t  \"form\",\n\t\t  \"frame\",\n\t\t  \"frameset\",\n\t\t  \"h1\",\n\t\t  \"h2\",\n\t\t  \"h3\",\n\t\t  \"h4\",\n\t\t  \"h5\",\n\t\t  \"h6\",\n\t\t  \"h7\",\n\t\t  \"h8\",\n\t\t  \"h9\",\n\t\t  \"h10\",\n\t\t  \"h11\",\n\t\t  \"h12\",\n\t\t  \"h13\",\n\t\t  \"h14\",\n\t\t  \"h15\",\n\t\t  \"head\",\n\t\t  \"hr\",\n\t\t  \"html\",\n\t\t  \"i\",\n\t\t  \"img\",\n\t\t  \"input\",\n\t\t  \"ins\",\n\t\t  \"isindex\",\n\t\t  \"kbd\",\n\t\t  \"li\",\n\t\t  \"link\",\n\t\t  \"map\",\n\t\t  \"menu\",\n\t\t  \"meta\",\n\t\t  \"multicol\",\n\t\t  \"nobr\",\n\t\t  \"noframes\",\n\t\t  \"ol\",\n\t\t  \"option\",\n\t\t  \"p\",\n\t\t  \"pre\",\n\t\t  \"s\",\n\t\t  \"samp\",\n\t\t  \"script\",\n\t\t  \"select\",\n\t\t  \"small\",\n\t\t  \"spacer\",\n\t\t  \"span\",\n\t\t  \"strike\",\n\t\t  \"strong\",\n\t\t  \"style\",\n\t\t  \"sub\",\n\t\t  \"sup\",\n\t\t  \"table\",\n\t\t  \"tbody\",\n\t\t  \"td\",\n\t\t  \"textarea\",\n\t\t  \"tfoot\",\n\t\t  \"th\",\n\t\t  \"thead\",\n\t\t  \"title\",\n\t\t  \"tr\",\n\t\t  \"tt\",\n\t\t  \"u\",\n\t\t  \"ul\",\n\t\t  \"var\",\n\t\t  \"wbr\"\n\t\t};\n\nconst char\t*_htmlCurrentFile = \"UNKNOWN\";\n\t\t\t\t\t/* Current file */\nconst char\t*_htmlData = HTML_DATA;\t/* Data directory */\nfloat\t\t_htmlPPI = 80.0f;\t/* Image resolution */\nint\t\t_htmlGrayscale = 0;\t/* Grayscale output? */\nuchar\t\t_htmlTextColor[255] =\t/* Default text color */\n\t\t{ 0 };\nfloat\t\t_htmlBrowserWidth = 680.0f;\n\t\t\t\t\t/* Browser width for pixel scaling */\nfloat\t\t_htmlSizes[8] =\t\t/* Point size for each HTML size */\n\t\t{ 6.0f, 8.0f, 9.0f, 11.0f, 14.0f, 17.0f, 20.0f, 24.0f };\nfloat\t\t_htmlSpacings[8] =\t/* Line height for each HTML size */\n\t\t{ 7.2f, 9.6f, 10.8f, 13.2f, 16.8f, 20.4f, 24.0f, 28.8f };\ntypeface_t\t_htmlBodyFont = TYPE_TIMES,\n\t\t_htmlHeadingFont = TYPE_HELVETICA;\n\nint\t\t_htmlInitialized = 0;\t/* Initialized glyphs yet? */\nchar\t\t_htmlCharSet[256] = \"iso-8859-1\";\n\t\t\t\t\t/* Character set name */\nint\t\t_htmlWidthsLoaded[TYPE_MAX][STYLE_MAX] =\n\t\t{\t\t\t/* Have the widths been loaded? */\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 }\n\t\t};\nshort\t\t_htmlWidths[TYPE_MAX][STYLE_MAX][256];\n\t\t\t\t\t/* Character widths of fonts */\nshort\t\t_htmlWidthsAll[TYPE_MAX][STYLE_MAX][65536];\n                                        /* Unicode widths of fonts */\nint\t\t_htmlUnicode[256];\t/* Character to Unicode mapping */\nuchar           _htmlCharacters[65536]; /* Unicode to character mapping */\nint             _htmlUTF8 = 0;          /* Doing UTF-8? */\nconst char\t*_htmlGlyphsAll[65536];\t/* Character glyphs for Unicode */\nconst char\t*_htmlGlyphs[256];\t/* Character glyphs for charset */\nint\t\t_htmlNumSorted = 0;\t/* Number of sorted glyphs */\nconst char\t*_htmlSorted[256];\t/* Sorted character glyphs for charset */\nuchar\t\t_htmlSortedChars[256];\t/* Sorted character indices */\nconst char\t*_htmlFonts[TYPE_MAX][STYLE_MAX] =\n\t\t{\n\t\t  {\n\t\t    \"Courier\",\n\t\t    \"Courier-Bold\",\n\t\t    \"Courier-Oblique\",\n\t\t    \"Courier-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Times-Roman\",\n\t\t    \"Times-Bold\",\n\t\t    \"Times-Italic\",\n\t\t    \"Times-BoldItalic\"\n\t\t  },\n\t\t  {\n\t\t    \"Helvetica\",\n\t\t    \"Helvetica-Bold\",\n\t\t    \"Helvetica-Oblique\",\n\t\t    \"Helvetica-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Monospace\",\n\t\t    \"Monospace-Bold\",\n\t\t    \"Monospace-Oblique\",\n\t\t    \"Monospace-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Serif-Roman\",\n\t\t    \"Serif-Bold\",\n\t\t    \"Serif-Oblique\",\n\t\t    \"Serif-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Sans\",\n\t\t    \"Sans-Bold\",\n\t\t    \"Sans-Oblique\",\n\t\t    \"Sans-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Symbol\",\n\t\t    \"Symbol\",\n\t\t    \"Symbol\",\n\t\t    \"Symbol\"\n\t\t  },\n\t\t  {\n\t\t    \"Dingbats\",\n\t\t    \"Dingbats\",\n\t\t    \"Dingbats\",\n\t\t    \"Dingbats\"\n\t\t  }\n\t\t};\nint\t\t_htmlStandardFonts[TYPE_MAX] =\n\t\t{\n\t\t  1,\t// Courier\n\t\t  1,\t// Times\n\t\t  1,\t// Helvetica\n\t\t  0,\t// Monospace\n\t\t  0,\t// Sans\n\t\t  0,\t// Serif\n\t\t  1,\t// Symbol\n\t\t  1\t// Dingbats\n\t\t};\n\n\n/*\n * Local functions.\n */\n\nextern \"C\" {\ntypedef int\t(*compare_func_t)(const void *, const void *);\n}\n\nstatic int\twrite_file(tree_t *t, FILE *fp, int col);\nstatic int\tcompare_variables(var_t *v0, var_t *v1);\nstatic int\tcompare_markups(uchar **m0, uchar **m1);\nstatic void\tdelete_node(tree_t *t);\nstatic void\tinsert_space(tree_t *parent, tree_t *t);\nstatic int\tparse_markup(tree_t *t, FILE *fp, int *linenum);\nstatic int\tparse_variable(tree_t *t, FILE *fp, int *linenum);\nstatic int\tcompute_size(tree_t *t);\nstatic int\tcompute_color(tree_t *t, uchar *color);\nstatic int\tget_alignment(tree_t *t);\nstatic const char *fix_filename(char *path, char *base);\nstatic int      utf8_getc(int ch, FILE *fp);\n\n#define issuper(x)\t((x) == MARKUP_CENTER || (x) == MARKUP_DIV ||\\\n\t\t\t (x) == MARKUP_BLOCKQUOTE)\n#define isblock(x)\t((x) == MARKUP_ADDRESS || \\\n\t\t\t (x) == MARKUP_P || (x) == MARKUP_PRE ||\\\n\t\t\t ((x) >= MARKUP_H1 && (x) <= MARKUP_H6) ||\\\n\t\t\t (x) == MARKUP_HR || (x) == MARKUP_TABLE)\n#define islist(x)\t((x) == MARKUP_DL || (x) == MARKUP_OL ||\\\n\t\t\t (x) == MARKUP_UL || (x) == MARKUP_DIR ||\\\n\t\t\t (x) == MARKUP_MENU)\n#define islentry(x)\t((x) == MARKUP_LI || (x) == MARKUP_DD ||\\\n\t\t\t (x) == MARKUP_DT)\n#define istable(x)\t((x) == MARKUP_TBODY || (x) == MARKUP_THEAD ||\\\n\t\t\t (x) == MARKUP_TFOOT || (x) == MARKUP_TR)\n#define istentry(x)\t((x) == MARKUP_TD || (x) == MARKUP_TH)\n\n#ifdef DEBUG\nstatic uchar\tindent[255] = \"\";\n#endif /* DEBUG */\n\n\n/*\n * 'htmlReadFile()' - Read a file for HTML markup codes.\n */\n\ntree_t *\t\t\t\t// O - Pointer to top of file tree\nhtmlReadFile(tree_t     *parent,\t// I - Parent tree entry\n             FILE       *fp,\t\t// I - File pointer\n\t     const char *base)\t\t// I - Base directory for file\n{\n  int\t\tch;\t\t\t// Character from file\n  uchar\t\t*ptr,\t\t\t// Pointer in string\n\t\tentity[16],\t\t// Character entity name (&#nnn; or &name;)\n\t\t*eptr;\t\t\t// Pointer in entity string\n  tree_t\t*tree,\t\t\t// \"top\" of this tree\n\t\t*t,\t\t\t// New tree entry\n\t\t*prev,\t\t\t// Previous tree entry\n\t\t*temp;\t\t\t// Temporary looping var\n  int\t\tdescend;\t\t// Descend into node?\n  FILE\t\t*embed;\t\t\t// File pointer for EMBED\n  char\t\tnewbase[1024];\t\t// New base directory for EMBED\n  uchar\t\t*filename,\t\t// Filename for EMBED tag\n\t\t*face,\t\t\t// Typeface for FONT tag\n\t\t*color,\t\t\t// Color for FONT tag\n\t\t*size,\t\t\t// Size for FONT tag\n\t\t*type,\t\t\t// Type for EMBED tag\n\t\t*span;\t\t\t// Value for SPAN tag\n  int\t\tsizeval;\t\t// Size value from FONT tag\n  int\t\tlinenum;\t\t// Line number in file\n  static uchar\ts[10240];\t\t// String from file\n  static int\thave_whitespace = 0;\t// Non-zero if there was leading whitespace\n\n\n  DEBUG_printf((\"htmlReadFile(parent=%p, fp=%p, base=\\\"%s\\\")\\n\",\n                (void *)parent, (void *)fp, base ? base : \"(null)\"));\n\n#ifdef DEBUG\n  indent[0] = '\\0';\n#endif // DEBUG\n\n /*\n  * Start off with no previous tree entry...\n  */\n\n  prev = NULL;\n  tree = NULL;\n\n /*\n  * Parse data until we hit end-of-file...\n  */\n\n  linenum = 1;\n\n  while ((ch = getc(fp)) != EOF)\n  {\n   /*\n    * Ignore leading whitespace...\n    */\n\n    if (parent == NULL || !parent->preformatted)\n    {\n      while (isspace(ch))\n      {\n\tif (ch == '\\n')\n\t  linenum ++;\n\n        have_whitespace = 1;\n        ch              = getc(fp);\n      }\n\n      if (ch == EOF)\n        break;\n    }\n\n   /*\n    * Allocate a new tree entry - use calloc() to get zeroed data...\n    */\n\n    t = (tree_t *)calloc(sizeof(tree_t), 1);\n    if (t == NULL)\n    {\n#ifndef DEBUG\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for HTML tree node!\");\n#endif /* !DEBUG */\n      break;\n    }\n\n   /*\n    * Set/copy font characteristics...\n    */\n\n    if (parent == NULL)\n    {\n      t->halignment   = ALIGN_LEFT;\n      t->valignment   = ALIGN_BOTTOM;\n      t->typeface     = _htmlBodyFont;\n      t->size         = SIZE_P;\n\n      compute_color(t, _htmlTextColor);\n    }\n    else\n    {\n      t->link          = parent->link;\n      t->halignment    = parent->halignment;\n      t->valignment    = parent->valignment;\n      t->typeface      = parent->typeface;\n      t->size          = parent->size;\n      t->style         = parent->style;\n      t->superscript   = parent->superscript;\n      t->subscript     = parent->subscript;\n      t->preformatted  = parent->preformatted;\n      t->indent        = parent->indent;\n      t->red           = parent->red;\n      t->green         = parent->green;\n      t->blue          = parent->blue;\n      t->underline     = parent->underline;\n      t->strikethrough = parent->strikethrough;\n    }\n\n   /*\n    * See what the character was...\n    */\n\n    if (ch == '<')\n    {\n     /*\n      * Markup char; grab the next char to see if this is a /...\n      */\n\n      ch = getc(fp);\n\n      if (isspace(ch) || ch == '=' || ch == '<')\n      {\n       /*\n        * Sigh...  \"<\" followed by anything but an element name is\n\t* invalid HTML, but so many people have asked for this to\n\t* be supported that we have added this hack...\n\t*/\n\n\tprogress_error(HD_ERROR_HTML_ERROR, \"Unquoted < on line %d of %s.\",\n\t               linenum, _htmlCurrentFile);\n\n\tif (ch == '\\n')\n\t  linenum ++;\n\n\tptr = s;\n\tif (have_whitespace)\n\t{\n          *ptr++ = ' ';\n\t  have_whitespace = 0;\n\t}\n\n        *ptr++ = '<';\n\tif (ch == '=')\n\t  *ptr++ = '=';\n\telse if (ch == '<')\n\t  ungetc(ch, fp);\n\telse\n\t  have_whitespace = 1;\n\n\t*ptr++ = '\\0';\n\n\tt->markup = MARKUP_NONE;\n\tt->data   = (uchar *)strdup((char *)s);\n      }\n      else\n      {\n       /*\n        * Start of a markup...\n\t*/\n\n\tif (ch != '/')\n          ungetc(ch, fp);\n\n\tif (parse_markup(t, fp, &linenum) == MARKUP_ERROR)\n\t{\n#ifndef DEBUG\n          progress_error(HD_ERROR_READ_ERROR,\n                         \"Unable to parse HTML element on line %d of %s!\",\n\t\t\t linenum, _htmlCurrentFile);\n#endif /* !DEBUG */\n\n          delete_node(t);\n          break;\n\t}\n\n       /*\n\t* Eliminate extra whitespace...\n\t*/\n\n\tif (issuper(t->markup) || isblock(t->markup) ||\n            islist(t->markup) || islentry(t->markup) ||\n            istable(t->markup) || istentry(t->markup) ||\n\t    t->markup == MARKUP_TITLE)\n          have_whitespace = 0;\n\n       /*\n\t* If this is the matching close mark, or if we are starting the same\n\t* markup, or if we've completed a list, we're done!\n\t*/\n\n\tif (ch == '/')\n\t{\n\t /*\n          * Close markup; find matching markup...\n          */\n\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (temp->markup == t->markup)\n              break;\n\t    else if (temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (t->markup == MARKUP_BODY || t->markup == MARKUP_HEAD)\n\t{\n\t /*\n          * Make sure we aren't inside an existing HEAD or BODY...\n\t  */\n\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (temp->markup == MARKUP_BODY || temp->markup == MARKUP_HEAD)\n              break;\n\t    else if (temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (t->markup == MARKUP_EMBED)\n\t{\n\t /*\n          * Close any text blocks...\n\t  */\n\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (isblock(temp->markup) || islentry(temp->markup))\n              break;\n\t    else if (istentry(temp->markup) || islist(temp->markup) ||\n\t             issuper(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (issuper(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n\t    if (istentry(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (islist(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (isblock(temp->markup))\n\t      break;\n\t    else if (islentry(temp->markup) || istentry(temp->markup) ||\n\t             issuper(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (islentry(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (islentry(temp->markup))\n              break;\n\t    else if (islist(temp->markup) || issuper(temp->markup) ||\n\t             istentry(temp->markup) || temp->markup == MARKUP_EMBED)\n            {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (isblock(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (isblock(temp->markup))\n              break;\n\t    else if (istentry(temp->markup) || islist(temp->markup) ||\n\t             islentry(temp->markup) ||\n\t             issuper(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (t->markup == MARKUP_THEAD || t->markup == MARKUP_TBODY || t->markup == MARKUP_TFOOT)\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n\t    if (temp->markup == MARKUP_TABLE || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (istentry(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (istentry(temp->markup))\n              break;\n\t    else if (temp->markup == MARKUP_TABLE || istable(temp->markup) ||\n\t             temp->markup == MARKUP_EMBED)\n\t    {\n\t      if (temp->markup != MARKUP_TR)\n\t      {\n\t        // Strictly speaking, this is an error - TD/TH can only\n\t\t// be found under TR, but web browsers automatically\n\t\t// inject a TR...\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"No TR element before %s element on line %d of %s.\",\n\t\t\t       _htmlMarkups[t->markup], linenum,\n\t\t\t       _htmlCurrentFile);\n\n                parent = htmlAddTree(temp, MARKUP_TR, NULL);\n\t\tprev   = NULL;\n\t\tDEBUG_printf((\"%str (inserted) under %s, line %d\\n\", indent,\n\t\t              _htmlMarkups[temp->markup], linenum));\n\t      }\n\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse\n          temp = NULL;\n\n\tif (temp != NULL)\n\t{\n          DEBUG_printf((\"%s>>>> Auto-ascend <<<\\n\", indent));\n\n          if (ch != '/' &&\n\t      temp->markup != MARKUP_BODY &&\n\t      temp->markup != MARKUP_DD &&\n\t      temp->markup != MARKUP_DT &&\n\t      temp->markup != MARKUP_HEAD &&\n\t      temp->markup != MARKUP_HTML &&\n\t      temp->markup != MARKUP_LI &&\n\t      temp->markup != MARKUP_OPTION &&\n\t      temp->markup != MARKUP_P &&\n\t      temp->markup != MARKUP_TBODY &&\n\t      temp->markup != MARKUP_TD &&\n\t      temp->markup != MARKUP_TFOOT &&\n\t      temp->markup != MARKUP_TH &&\n\t      temp->markup != MARKUP_THEAD &&\n\t      temp->markup != MARKUP_TR)\n\t  {\n\t    // Log this condition as an error...\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"No /%s element before %s element on line %d of %s.\",\n\t                   _htmlMarkups[temp->markup],\n\t\t\t   _htmlMarkups[t->markup], linenum, _htmlCurrentFile);\n\t    DEBUG_printf((\"%sNo /%s element before %s element on line %d.\\n\",\n\t                  indent, _htmlMarkups[temp->markup],\n\t\t\t  _htmlMarkups[t->markup], linenum));\n\t  }\n\n#ifdef DEBUG\n          for (tree_t *p = parent;\n\t       p && p != temp && indent[0];\n\t       p = p->parent)\n\t    indent[strlen((char *)indent) - 4] = '\\0';\n\n          if (indent[0])\n            indent[strlen((char *)indent) - 4] = '\\0';\n#endif // DEBUG\n\n          // Safety check; should never happen, since MARKUP_FILE is\n\t  // the root node created by the caller...\n          if (temp->parent)\n\t  {\n\t    parent = temp->parent;\n            prev   = parent->last_child;\n\t  }\n\t  else\n\t  {\n\t    for (prev = temp; prev->next; prev = prev->next);\n\t    parent = NULL;\n\t  }\n\n          if (ch == '/')\n\t  {\n\t    // Closing element, so delete this node...\n            delete_node(t);\n\t    continue;\n\t  }\n\t  else\n\t  {\n\t    // Reparent the node...\n\t    if (parent == NULL)\n\t    {\n\t      t->halignment   = ALIGN_LEFT;\n\t      t->valignment   = ALIGN_BOTTOM;\n\t      t->typeface     = _htmlBodyFont;\n\t      t->size         = SIZE_P;\n\n\t      compute_color(t, _htmlTextColor);\n\t    }\n\t    else\n\t    {\n\t      t->link          = parent->link;\n\t      t->halignment    = parent->halignment;\n\t      t->valignment    = parent->valignment;\n\t      t->typeface      = parent->typeface;\n\t      t->size          = parent->size;\n\t      t->style         = parent->style;\n\t      t->superscript   = parent->superscript;\n\t      t->subscript     = parent->subscript;\n\t      t->preformatted  = parent->preformatted;\n\t      t->indent        = parent->indent;\n\t      t->red           = parent->red;\n\t      t->green         = parent->green;\n\t      t->blue          = parent->blue;\n\t      t->underline     = parent->underline;\n\t      t->strikethrough = parent->strikethrough;\n\t    }\n\n          }\n\t}\n\telse if (ch == '/')\n\t{\n\t  // Log this condition as an error...\n\t  if (t->markup != MARKUP_UNKNOWN &&\n\t      t->markup != MARKUP_COMMENT)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Dangling /%s element on line %d of %s.\",\n\t\t\t   _htmlMarkups[t->markup], linenum, _htmlCurrentFile);\n\t    DEBUG_printf((\"%sDangling /%s element on line %d.\\n\",\n\t\t\t  indent, _htmlMarkups[t->markup], linenum));\n          }\n\n\t  delete_node(t);\n\t  continue;\n\t}\n      }\n    }\n    else if (t->preformatted)\n    {\n     /*\n      * Read a pre-formatted string into the current tree entry...\n      */\n\n      ptr = s;\n      while (ch != '<' && ch != EOF && ptr < (s + sizeof(s) - 1))\n      {\n        if (ch == '&')\n        {\n\t  // Possibly a character entity...\n\t  eptr = entity;\n\t  while (eptr < (entity + sizeof(entity) - 1) &&\n\t         (ch = getc(fp)) != EOF)\n\t    if (!isalnum(ch) && ch != '#')\n\t      break;\n\t    else\n\t      *eptr++ = (uchar)ch;\n\n          if (ch != ';')\n\t  {\n\t    ungetc(ch, fp);\n\t    ch = 0;\n\t  }\n\n          *eptr = '\\0';\n          if (!ch)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                   linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n\t  }\n\t  else if ((ch = iso8859(entity)) == 0)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                   entity, linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = ';';\n\t  }\n\t  else\n\t    *ptr++ = (uchar)ch;\n        }\n        else if ((ch & 0x80) && _htmlUTF8)\n        {\n          // Collect UTF-8 value...\n          ch = utf8_getc(ch, fp);\n\n          if (ch)\n            *ptr++ = (uchar)ch;\n        }\n\telse if (ch != 0 && ch != '\\r')\n\t{\n          *ptr++ = (uchar)ch;\n\n          if (ch == '\\n')\n\t  {\n\t    linenum ++;\n            break;\n\t  }\n\t}\n\n        ch = getc(fp);\n      }\n\n      *ptr = '\\0';\n\n      if (ch == '<')\n        ungetc(ch, fp);\n\n      t->markup = MARKUP_NONE;\n      t->data   = (uchar *)strdup((char *)s);\n\n      DEBUG_printf((\"%sfragment \\\"%s\\\", line %d\\n\", indent, s, linenum));\n    }\n    else\n    {\n     /*\n      * Read the next string fragment...\n      */\n\n      ptr = s;\n      if (have_whitespace)\n      {\n        *ptr++ = ' ';\n\thave_whitespace = 0;\n      }\n\n      while (!isspace(ch) && ch != '<' && ch != EOF && ptr < (s + sizeof(s) - 1))\n      {\n        if (ch == '&')\n        {\n\t  // Possibly a character entity...\n\t  eptr = entity;\n\t  while (eptr < (entity + sizeof(entity) - 1) &&\n\t         (ch = getc(fp)) != EOF)\n\t    if (!isalnum(ch) && ch != '#')\n\t      break;\n\t    else\n\t      *eptr++ = (uchar)ch;\n\n          *eptr = '\\0';\n\n          if (ch != ';')\n\t  {\n\t    ungetc(ch, fp);\n\t    ch = 0;\n\t  }\n\n          if (!ch)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                   linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n\t  }\n\t  else if ((ch = iso8859(entity)) == 0)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                   entity, linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = ';';\n\t  }\n\t  else\n\t    *ptr++ = (uchar)ch;\n        }\n        else\n        {\n          if ((ch & 0x80) && _htmlUTF8)\n          {\n            // Collect UTF-8 value...\n            ch = utf8_getc(ch, fp);\n          }\n\n          if (ch)\n            *ptr++ = (uchar)ch;\n        }\n\n\tif ((_htmlUTF8 && ch == _htmlCharacters[173]) || (!_htmlUTF8 && ch == 173))\n\t  break;\n\n        ch = getc(fp);\n      }\n\n      if (ch == '\\n')\n\tlinenum ++;\n\n      if (isspace(ch))\n        have_whitespace = 1;\n\n      *ptr = '\\0';\n\n      if (ch == '<')\n        ungetc(ch, fp);\n\n      t->markup = MARKUP_NONE;\n      t->data   = (uchar *)strdup((char *)s);\n\n      DEBUG_printf((\"%sfragment \\\"%s\\\" (len=%d), line %d\\n\", indent, s,\n                    (int)(ptr - s), linenum));\n    }\n\n   /*\n    * If the parent tree pointer is not null and this is the first\n    * entry we've read, set the child pointer...\n    */\n\n    DEBUG_printf((\"%sADDING %s node to %s parent!\\n\", indent,\n                  _htmlMarkups[t->markup],\n\t\t  parent ? _htmlMarkups[parent->markup] : \"ROOT\"));\n    if (parent != NULL && prev == NULL)\n      parent->child = t;\n\n    if (parent != NULL)\n      parent->last_child = t;\n\n   /*\n    * Do the prev/next links...\n    */\n\n    t->parent = parent;\n    t->prev   = prev;\n    if (prev != NULL)\n      prev->next = t;\n\n    if (tree == NULL)\n      tree = t;\n\n    prev = t;\n\n   /*\n    * Do markup-specific stuff...\n    */\n\n    descend = 0;\n\n    switch (t->markup)\n    {\n      case MARKUP_BODY :\n         /*\n\t  * Update the text color as necessary...\n\t  */\n\n          if ((color = htmlGetVariable(t, (uchar *)\"TEXT\")) != NULL)\n            compute_color(t, color);\n\t  else\n            compute_color(t, _htmlTextColor);\n\n          if ((color = htmlGetVariable(t, (uchar *)\"BGCOLOR\")) != NULL &&\n\t      !BodyColor[0])\n\t    strlcpy(BodyColor, (char *)color, sizeof(BodyColor));\n\n          // Update the background image as necessary...\n          if ((filename = htmlGetVariable(t, (uchar *)\"BACKGROUND\")) != NULL)\n\t    htmlSetVariable(t, (uchar *)\"BACKGROUND\",\n\t                    (uchar *)fix_filename((char *)filename,\n\t\t\t                          (char *)base));\n\n          descend = 1;\n          break;\n\n      case MARKUP_IMG :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this image...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          // Get the image alignment...\n          t->valignment = ALIGN_BOTTOM;\n          get_alignment(t);\n\n          // Update the image source as necessary...\n          if ((filename = htmlGetVariable(t, (uchar *)\"SRC\")) != NULL)\n\t    htmlSetVariable(t, (uchar *)\"REALSRC\",\n\t                    (uchar *)fix_filename((char *)filename,\n\t\t\t                          (char *)base));\n\n      case MARKUP_BR :\n      case MARKUP_NONE :\n      case MARKUP_SPACER :\n\t /*\n\t  * Figure out the width & height of this markup...\n\t  */\n\n          compute_size(t);\n\t  break;\n\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n          get_alignment(t);\n\n          t->typeface      = _htmlHeadingFont;\n          t->subscript     = 0;\n          t->superscript   = 0;\n          t->strikethrough = 0;\n          t->preformatted  = 0;\n\n\t  if (t->markup > MARKUP_H6)\n          {\n\t    t->size  = SIZE_H7;\n            t->style = STYLE_ITALIC;\n\t  }\n\t  else\n\t  {\n            t->size  = (unsigned)(SIZE_H1 - t->markup + MARKUP_H1);\n            t->style = STYLE_BOLD;\n\t  }\n\n          descend = 1;\n          break;\n\n      case MARKUP_P :\n          get_alignment(t);\n\n          t->typeface      = _htmlBodyFont;\n          t->size          = SIZE_P;\n          t->style         = STYLE_NORMAL;\n          t->subscript     = 0;\n          t->superscript   = 0;\n          t->strikethrough = 0;\n          t->preformatted  = 0;\n\n          descend = 1;\n          break;\n\n      case MARKUP_PRE :\n          t->typeface      = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_MONOSPACE\n\t                                                     : TYPE_COURIER;\n          t->size          = SIZE_PRE;\n          t->style         = STYLE_NORMAL;\n          t->subscript     = 0;\n          t->superscript   = 0;\n          t->strikethrough = 0;\n          t->preformatted  = 1;\n\n          descend = 1;\n          break;\n\n      case MARKUP_BLOCKQUOTE :\n      case MARKUP_DIR :\n      case MARKUP_MENU :\n      case MARKUP_UL :\n      case MARKUP_OL :\n      case MARKUP_DL :\n          t->indent ++;\n\n          descend = 1;\n          break;\n\n      case MARKUP_DIV :\n          get_alignment(t);\n\n          descend = 1;\n          break;\n\n      case MARKUP_HR :\n          t->halignment = ALIGN_CENTER;\n          get_alignment(t);\n          break;\n\n      case MARKUP_DOCTYPE :\n      case MARKUP_AREA :\n      case MARKUP_COMMENT :\n      case MARKUP_INPUT :\n      case MARKUP_ISINDEX :\n      case MARKUP_LINK :\n      case MARKUP_META :\n      case MARKUP_WBR :\n      case MARKUP_COL :\n          break;\n\n      case MARKUP_EMBED :\n          if ((type = htmlGetVariable(t, (uchar *)\"TYPE\")) != NULL &&\n\t      strncasecmp((const char *)type, \"text/html\", 9) != 0)\n\t    break;\n\n          if ((filename = htmlGetVariable(t, (uchar *)\"SRC\")) != NULL)\n\t  {\n\t    const char *save_name = _htmlCurrentFile;\n\n\t    filename = (uchar *)fix_filename((char *)filename,\n\t                                     (char *)base);\n\n            if ((embed = fopen((char *)filename, \"r\")) != NULL)\n            {\n\t      strlcpy(newbase, file_directory((char *)filename), sizeof(newbase));\n\n              _htmlCurrentFile = (char *)filename;\n              htmlReadFile(t, embed, newbase);\n              fclose(embed);\n\t      _htmlCurrentFile = save_name;\n            }\n#ifndef DEBUG\n\t    else\n\t      progress_error(HD_ERROR_FILE_NOT_FOUND,\n                             \"Unable to embed \\\"%s\\\" - %s\", filename,\n\t                     strerror(errno));\n#endif /* !DEBUG */\n\t  }\n          break;\n\n      case MARKUP_TH :\n          if (htmlGetVariable(t->parent, (uchar *)\"ALIGN\") != NULL)\n\t    t->halignment = t->parent->halignment;\n\t  else\n            t->halignment = ALIGN_CENTER;\n\n          if (htmlGetVariable(t->parent, (uchar *)\"VALIGN\") != NULL)\n\t    t->valignment = t->parent->valignment;\n\t  else\n            t->valignment = ALIGN_MIDDLE;\n\n          get_alignment(t);\n\n          t->style = STYLE_BOLD;\n\n          descend = 1;\n          break;\n\n      case MARKUP_TD :\n          if (htmlGetVariable(t->parent, (uchar *)\"ALIGN\") != NULL)\n\t    t->halignment = t->parent->halignment;\n\t  else\n            t->halignment = ALIGN_LEFT;\n\n          if (htmlGetVariable(t->parent, (uchar *)\"VALIGN\") != NULL)\n\t    t->valignment = t->parent->valignment;\n\t  else\n            t->valignment = ALIGN_MIDDLE;\n\n\t  get_alignment(t);\n\n          t->style = STYLE_NORMAL;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SPAN :\n          // Pull style data, if present...\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this element...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          get_alignment(t);\n\n          if ((color = htmlGetStyle(t, (uchar *)\"color:\")) != NULL)\n            compute_color(t, color);\n\n          if ((face = htmlGetStyle(t, (uchar *)\"font-family:\")) != NULL)\n          {\n\t    char\tfont[255],\t// Font name\n\t\t\t*fontptr;\t// Pointer into font name\n\n            for (ptr = face; *ptr;)\n\t    {\n\t      while (isspace(*ptr) || *ptr == ',')\n\t        ptr ++;\n\n              if (!*ptr)\n\t        break;\n\n\t      for (fontptr = font; *ptr && *ptr != ',' && !isspace(*ptr); ptr ++)\n\t        if (fontptr < (font + sizeof(font) - 1))\n\t\t  *fontptr++ = (char)*ptr;\n\n              *fontptr = '\\0';\n\n              if (!strcasecmp(font, \"serif\"))\n\t      {\n        \tt->typeface = TYPE_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"sans-serif\") ||\n\t               !strcasecmp(font, \"sans\"))\n\t      {\n        \tt->typeface = TYPE_SANS_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"monospace\"))\n\t      {\n        \tt->typeface = TYPE_MONOSPACE;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"arial\") ||\n\t               !strcasecmp(font, \"helvetica\"))\n              {\n        \tt->typeface = TYPE_HELVETICA;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"times\"))\n\t      {\n        \tt->typeface = TYPE_TIMES;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"courier\"))\n\t      {\n        \tt->typeface = TYPE_COURIER;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"symbol\"))\n\t      {\n        \tt->typeface = TYPE_SYMBOL;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"dingbat\"))\n\t      {\n        \tt->typeface = TYPE_DINGBATS;\n\t\tbreak;\n\t      }\n\t    }\n          }\n\n          if ((size = htmlGetStyle(t, (uchar *)\"font-size:\")) != NULL)\n          {\n            // Find the closest size to the fixed sizes...\n            unsigned i;\n            double fontsize = atof((char *)size);\n\n            for (i = 0; i < 7; i ++)\n              if (fontsize <= _htmlSizes[i])\n                break;\n\n\t    t->size = i;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"font-style:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"normal\"))\n              t->style &= ~STYLE_ITALIC;\n            else if (!strcmp((char *)span, \"italic\") || !strcmp((char *)span, \"oblique\"))\n              t->style |= STYLE_ITALIC;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"font-weight:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"bold\") || !strcmp((char *)span, \"bolder\") || !strcmp((char *)span, \"700\") || !strcmp((char *)span, \"800\") || !strcmp((char *)span, \"900\"))\n              t->style |= STYLE_BOLD;\n            else if (strcmp((char *)span, \"inherit\"))\n              t->style &= ~STYLE_BOLD;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"text-decoration:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"underline\"))\n              t->underline = 1;\n            else if (!strcmp((char *)span, \"line-through\"))\n              t->strikethrough = 1;\n            else if (strcmp((char *)span, \"inherit\"))\n              t->underline = t->strikethrough = 0;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"vertical-align:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"sub\"))\n              t->subscript = 1;\n            else if (!strcmp((char *)span, \"super\"))\n              t->superscript = 1;\n            else if (strcmp((char *)span, \"inherit\"))\n              t->subscript = t->superscript = 0;\n          }\n\n          descend = 1;\n          break;\n\n      case MARKUP_FONT :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this element...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          if ((face = htmlGetVariable(t, (uchar *)\"FACE\")) != NULL)\n          {\n\t    char\tfont[255],\t// Font name\n\t\t\t*fontptr;\t// Pointer into font name\n\n\n            for (ptr = face; *ptr;)\n\t    {\n\t      while (isspace(*ptr) || *ptr == ',')\n\t        ptr ++;\n\n              if (!*ptr)\n\t        break;\n\n\t      for (fontptr = font; *ptr && *ptr != ',' && !isspace(*ptr); ptr ++)\n\t        if (fontptr < (font + sizeof(font) - 1))\n\t\t  *fontptr++ = (char)*ptr;\n\n              *fontptr = '\\0';\n\n              if (!strcasecmp(font, \"serif\"))\n\t      {\n        \tt->typeface = TYPE_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"sans-serif\") ||\n\t               !strcasecmp(font, \"sans\"))\n\t      {\n        \tt->typeface = TYPE_SANS_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"mono\") || !strcasecmp(font, \"monospace\"))\n\t      {\n        \tt->typeface = TYPE_MONOSPACE;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"arial\") ||\n\t               !strcasecmp(font, \"helvetica\"))\n              {\n        \tt->typeface = TYPE_HELVETICA;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"times\"))\n\t      {\n        \tt->typeface = TYPE_TIMES;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"courier\"))\n\t      {\n        \tt->typeface = TYPE_COURIER;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"symbol\"))\n\t      {\n        \tt->typeface = TYPE_SYMBOL;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"dingbat\"))\n\t      {\n        \tt->typeface = TYPE_DINGBATS;\n\t\tbreak;\n\t      }\n\t    }\n          }\n\n          if ((color = htmlGetVariable(t, (uchar *)\"COLOR\")) != NULL)\n            compute_color(t, color);\n\n          if ((size = htmlGetVariable(t, (uchar *)\"SIZE\")) != NULL)\n          {\n            if (have_whitespace)\n\t    {\n\t      // Insert a space before sized text...\n\t      insert_space(parent, t);\n\n\t      have_whitespace = 0;\n\t    }\n\n\t    if (isdigit(size[0]))\n\t      sizeval = atoi((char *)size);\n\t    else\n              sizeval = t->size + atoi((char *)size);\n\n            if (sizeval < 0)\n              t->size = 0;\n            else if (sizeval > 7)\n              t->size = 7;\n            else\n              t->size = (unsigned)sizeval;\n          }\n\n          descend = 1;\n          break;\n\n      case MARKUP_BIG :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before big text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          if (t->size < 6)\n            t->size += 2;\n          else\n            t->size = 7;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SMALL :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before small text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          if (t->size > 2)\n            t->size -= 2;\n          else\n            t->size = 0;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SUP :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before superscript text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->superscript = 1;\n\n          if ((sizeval = t->size + SIZE_SUP) < 0)\n\t    t->size = 0;\n\t  else\n\t    t->size = (unsigned)sizeval;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SUB :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before subscript text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->subscript = 1;\n\n          if ((sizeval = t->size + SIZE_SUB) < 0)\n\t    t->size = 0;\n\t  else\n\t    t->size = (unsigned)sizeval;\n\n          descend = 1;\n          break;\n\n      case MARKUP_KBD :\n          t->style    = STYLE_BOLD;\n\n      case MARKUP_TT :\n      case MARKUP_CODE :\n      case MARKUP_SAMP :\n          if (isspace(ch = getc(fp)))\n\t    have_whitespace = 1;\n\t  else\n\t    ungetc(ch, fp);\n\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before monospaced text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->typeface = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_MONOSPACE\n\t                                                : TYPE_COURIER;\n\n          descend = 1;\n          break;\n\n      case MARKUP_STRONG :\n      case MARKUP_B :\n          t->style = (style_t)(t->style | STYLE_BOLD);\n\n          descend = 1;\n          break;\n\n      case MARKUP_DD :\n          t->indent ++;\n\n          descend = 1;\n          break;\n\n      case MARKUP_VAR :\n          t->style = (style_t)(t->style | STYLE_ITALIC);\n      case MARKUP_DFN :\n          t->typeface = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_SANS_SERIF\n\t                                                : TYPE_HELVETICA;\n\n          descend = 1;\n          break;\n\n      case MARKUP_CITE :\n      case MARKUP_EM :\n      case MARKUP_I :\n          t->style = (style_t)(t->style | STYLE_ITALIC);\n\n          descend = 1;\n          break;\n\n      case MARKUP_U :\n      case MARKUP_INS :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before underlined text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->underline = 1;\n\n          descend = 1;\n          break;\n\n      case MARKUP_STRIKE :\n      case MARKUP_S :\n      case MARKUP_DEL :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before struck-through text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->strikethrough = 1;\n\n          descend = 1;\n          break;\n\n      case MARKUP_CENTER :\n          t->halignment = ALIGN_CENTER;\n\n          descend = 1;\n          break;\n\n      case MARKUP_A :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this link...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          descend = 1;\n\t  break;\n\n      default :\n         /*\n          * All other markup types should be using <MARK>...</MARK>\n          */\n\n          get_alignment(t);\n\n          descend = 1;\n          break;\n    }\n\n    if (descend)\n    {\n#ifdef DEBUG\n      strlcat((char *)indent, \"    \", sizeof(indent));\n#endif // DEBUG\n\n      parent = t;\n      prev   = NULL;\n    }\n  }\n\n  return (tree);\n}\n\n\n/*\n * 'write_file()' - Write a tree entry to a file...\n */\n\nstatic int\t\t\t/* I - New column */\nwrite_file(tree_t *t,\t\t/* I - Tree entry */\n           FILE   *fp,\t\t/* I - File to write to */\n           int    col)\t\t/* I - Current column */\n{\n  int\ti;\t\t\t/* Looping var */\n  uchar\t*ptr;\t\t\t/* Character pointer */\n\n\n  while (t != NULL)\n  {\n    if (t->markup == MARKUP_NONE)\n    {\n      if (t->preformatted)\n      {\n        for (ptr = t->data; *ptr != '\\0'; ptr ++)\n          fputs((char *)iso8859(*ptr), fp);\n\n\tif (t->data[strlen((char *)t->data) - 1] == '\\n')\n          col = 0;\n\telse\n          col += strlen((char *)t->data);\n      }\n      else\n      {\n\tif ((col + (int)strlen((char *)t->data)) > 72 && col > 0)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n\n        for (ptr = t->data; *ptr != '\\0'; ptr ++)\n          fputs((char *)iso8859(*ptr), fp);\n\n\tcol += strlen((char *)t->data);\n\n\tif (col > 72)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n      }\n    }\n    else if (t->markup == MARKUP_COMMENT)\n      fprintf(fp, \"\\n<!--%s-->\\n\", t->data);\n    else if (t->markup > 0)\n    {\n      switch (t->markup)\n      {\n        case MARKUP_AREA :\n        case MARKUP_BR :\n        case MARKUP_CENTER :\n        case MARKUP_COMMENT :\n        case MARKUP_DD :\n        case MARKUP_DL :\n        case MARKUP_DT :\n        case MARKUP_H1 :\n        case MARKUP_H2 :\n        case MARKUP_H3 :\n        case MARKUP_H4 :\n        case MARKUP_H5 :\n        case MARKUP_H6 :\n        case MARKUP_HEAD :\n        case MARKUP_HR :\n        case MARKUP_LI :\n        case MARKUP_MAP :\n        case MARKUP_OL :\n        case MARKUP_P :\n        case MARKUP_PRE :\n        case MARKUP_TABLE :\n        case MARKUP_TITLE :\n        case MARKUP_TR :\n        case MARKUP_UL :\n\tcase MARKUP_DIR :\n\tcase MARKUP_MENU :\n            if (col > 0)\n            {\n              putc('\\n', fp);\n              col = 0;\n            }\n        default :\n            break;\n      }\n\n      col += fprintf(fp, \"<%s\", _htmlMarkups[t->markup]);\n      for (i = 0; i < t->nvars; i ++)\n      {\n\tif (col > 72 && !t->preformatted)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n\n        if (col > 0)\n        {\n          putc(' ', fp);\n          col ++;\n        }\n\n\tif (t->vars[i].value == NULL)\n          col += fprintf(fp, \"%s\", t->vars[i].name);\n\telse if (strchr((char *)t->vars[i].value, '\\\"') != NULL)\n          col += fprintf(fp, \"%s=\\'%s\\'\", t->vars[i].name, t->vars[i].value);\n\telse\n          col += fprintf(fp, \"%s=\\\"%s\\\"\", t->vars[i].name, t->vars[i].value);\n      }\n\n      putc('>', fp);\n      col ++;\n\n      if (col > 72 && !t->preformatted)\n      {\n\tputc('\\n', fp);\n\tcol = 0;\n      }\n\n      if (t->child != NULL)\n      {\n\tcol = write_file(t->child, fp, col);\n\n\tif (col > 72 && !t->preformatted)\n\t{\n\t  putc('\\n', fp);\n\t  col = 0;\n\t}\n\n        col += fprintf(fp, \"</%s>\", _htmlMarkups[t->markup]);\n        switch (t->markup)\n        {\n          case MARKUP_AREA :\n          case MARKUP_BR :\n          case MARKUP_CENTER :\n          case MARKUP_COMMENT :\n          case MARKUP_DD :\n          case MARKUP_DL :\n          case MARKUP_DT :\n          case MARKUP_H1 :\n          case MARKUP_H2 :\n          case MARKUP_H3 :\n          case MARKUP_H4 :\n          case MARKUP_H5 :\n          case MARKUP_H6 :\n          case MARKUP_HEAD :\n          case MARKUP_HR :\n          case MARKUP_LI :\n          case MARKUP_MAP :\n          case MARKUP_OL :\n          case MARKUP_P :\n          case MARKUP_PRE :\n          case MARKUP_TABLE :\n          case MARKUP_TITLE :\n          case MARKUP_TR :\n          case MARKUP_UL :\n          case MARKUP_DIR :\n          case MARKUP_MENU :\n              putc('\\n', fp);\n              col = 0;\n          default :\n\t      break;\n        }\n      }\n    }\n\n    t = t->next;\n  }\n\n  return (col);\n}\n\n\n/*\n * 'htmlWriteFile()' - Write an HTML markup tree to a file.\n */\n\nint\t\t\t\t/* O - Write status: 0 = success, -1 = fail */\nhtmlWriteFile(tree_t *parent,\t/* I - Parent tree entry */\n              FILE   *fp)\t/* I - File to write to */\n{\n  if (write_file(parent, fp, 0) < 0)\n    return (-1);\n  else\n    return (0);\n}\n\n\n/*\n * 'htmlAddTree()' - Add a tree node to the parent.\n */\n\ntree_t *\t\t\t/* O - New entry */\nhtmlAddTree(tree_t   *parent,\t/* I - Parent entry */\n            markup_t markup,\t/* I - Markup code */\n            uchar    *data)\t/* I - Data/text */\n{\n  tree_t\t*t;\t\t/* New tree entry */\n\n\n  if ((t = htmlNewTree(parent, markup, data)) == NULL)\n    return (NULL);\n\n /*\n  * Add the tree entry to the end of the chain of children...\n  */\n\n  if (parent != NULL)\n  {\n    if (parent->last_child != NULL)\n    {\n      parent->last_child->next = t;\n      t->prev                  = parent->last_child;\n    }\n    else\n      parent->child = t;\n\n    parent->last_child = t;\n  }\n\n  return (t);\n}\n\n\n/*\n * 'htmlDeleteTree()' - Free all memory associated with a tree...\n */\n\nint\t\t\t\t/* O - 0 for success, -1 for failure */\nhtmlDeleteTree(tree_t *parent)\t/* I - Parent to delete */\n{\n  tree_t\t*next;\t\t/* Next tree entry */\n\n\n  if (parent == NULL)\n    return (-1);\n\n  while (parent != NULL)\n  {\n    next = parent->next;\n\n    if (parent->child != NULL)\n      if (htmlDeleteTree(parent->child))\n        return (-1);\n\n    delete_node(parent);\n\n    parent = next;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'htmlInsertTree()' - Insert a tree node under the parent.\n */\n\ntree_t *\t\t\t/* O - New entry */\nhtmlInsertTree(tree_t   *parent,/* I - Parent entry */\n               markup_t markup,\t/* I - Markup code */\n               uchar    *data)\t/* I - Data/text */\n{\n  tree_t\t*t;\t\t/* New tree entry */\n\n\n  if ((t = htmlNewTree(parent, markup, data)) == NULL)\n    return (NULL);\n\n /*\n  * Insert the tree entry at the beginning of the chain of children...\n  */\n\n  if (parent != NULL)\n  {\n    if (parent->child != NULL)\n    {\n      parent->child->prev = t;\n      t->next             = parent->child;\n    }\n    else\n      parent->last_child = t;\n\n    parent->child = t;\n  }\n\n  return (t);\n}\n\n\n/*\n * 'htmlMapUnicode()' - Map a Unicode character to the custom character set.\n */\n\nuchar\t\t\t\t/* O - Charset character */\nhtmlMapUnicode(int ch)\t\t/* I - Unicode character */\n{\n  uchar\tnewch;\t\t\t/* New charset character */\n\n\n  // If we already have a mapping for this character, return it...\n  if (_htmlCharacters[ch])\n    return (_htmlCharacters[ch]);\n\n  if (_htmlUTF8 >= 0x100)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Too many Unicode code points.\");\n    return (0);\n  }\n\n  newch = _htmlUTF8++;\n\n  _htmlCharacters[ch] = (uchar)newch;\n  _htmlUnicode[newch] = ch;\n  _htmlGlyphs[newch]  = _htmlGlyphsAll[ch];\n\n  for (int i = 0; i < TYPE_MAX; i ++)\n    for (int j = 0; j < STYLE_MAX; j ++)\n      _htmlWidths[i][j][newch] = _htmlWidthsAll[i][j][ch];\n\n  return (newch);\n}\n\n\n/*\n * 'htmlNewTree()' - Create a new tree node for the parent.\n */\n\ntree_t *\t\t\t/* O - New entry */\nhtmlNewTree(tree_t   *parent,\t/* I - Parent entry */\n            markup_t markup,\t/* I - Markup code */\n            uchar    *data)\t/* I - Data/text */\n{\n  tree_t\t*t;\t\t/* New tree entry */\n\n\n /*\n  * Allocate a new tree entry - use calloc() to get zeroed data...\n  */\n\n  t = (tree_t *)calloc(sizeof(tree_t), 1);\n  if (t == NULL)\n    return (NULL);\n\n /*\n  * Set the markup code and copy the data if necessary...\n  */\n\n  t->markup = markup;\n  if (data != NULL)\n    t->data = (uchar *)strdup((char *)data);\n\n /*\n  * Set/copy font characteristics...\n  */\n\n  if (parent == NULL)\n  {\n    t->halignment = ALIGN_LEFT;\n    t->valignment = ALIGN_BOTTOM;\n    t->typeface   = _htmlBodyFont;\n    t->size       = SIZE_P;\n\n    compute_color(t, _htmlTextColor);\n  }\n  else\n  {\n    t->link          = parent->link;\n    t->halignment    = parent->halignment;\n    t->valignment    = parent->valignment;\n    t->typeface      = parent->typeface;\n    t->size          = parent->size;\n    t->style         = parent->style;\n    t->preformatted  = parent->preformatted;\n    t->indent        = parent->indent;\n    t->red           = parent->red;\n    t->green         = parent->green;\n    t->blue          = parent->blue;\n    t->underline     = parent->underline;\n    t->strikethrough = parent->strikethrough;\n  }\n\n  switch (t->markup)\n  {\n    case MARKUP_NONE :\n    case MARKUP_IMG :\n       /*\n\t* Figure out the width & height of this fragment...\n\t*/\n\n        compute_size(t);\n\tbreak;\n\n    case MARKUP_H1 :\n    case MARKUP_H2 :\n    case MARKUP_H3 :\n    case MARKUP_H4 :\n    case MARKUP_H5 :\n    case MARKUP_H6 :\n        get_alignment(t);\n\n        t->typeface      = _htmlHeadingFont;\n        t->size          = (unsigned)(SIZE_H1 - t->markup + MARKUP_H1);\n        t->subscript     = 0;\n        t->superscript   = 0;\n        t->strikethrough = 0;\n        t->preformatted  = 0;\n        t->style         = STYLE_BOLD;\n        break;\n\n    case MARKUP_P :\n        get_alignment(t);\n\n        t->typeface      = _htmlBodyFont;\n        t->size          = SIZE_P;\n        t->style         = STYLE_NORMAL;\n        t->subscript     = 0;\n        t->superscript   = 0;\n        t->strikethrough = 0;\n        t->preformatted  = 0;\n        break;\n\n    case MARKUP_PRE :\n        t->typeface      = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_MONOSPACE\n\t                                                   : TYPE_COURIER;\n        t->size          = SIZE_PRE;\n        t->style         = STYLE_NORMAL;\n        t->subscript     = 0;\n        t->superscript   = 0;\n        t->strikethrough = 0;\n        t->preformatted  = 1;\n        break;\n\n    case MARKUP_DIV :\n        get_alignment(t);\n        break;\n\n    case MARKUP_BLOCKQUOTE :\n        t->style = STYLE_ITALIC;\n\n    case MARKUP_UL :\n    case MARKUP_DIR :\n    case MARKUP_MENU :\n    case MARKUP_OL :\n    case MARKUP_DL :\n        t->indent ++;\n        break;\n\n    case MARKUP_AREA :\n    case MARKUP_BR :\n    case MARKUP_COMMENT :\n    case MARKUP_HR :\n    case MARKUP_INPUT :\n    case MARKUP_ISINDEX :\n    case MARKUP_META :\n    case MARKUP_WBR :\n        break;\n\n    case MARKUP_TH :\n        t->style = STYLE_BOLD;\n    case MARKUP_TD :\n        get_alignment(t);\n        break;\n\n    case MARKUP_SUP :\n        t->superscript = 1;\n        t->size        = SIZE_P + SIZE_SUP;\n        break;\n\n    case MARKUP_SUB :\n        t->subscript = 1;\n        t->size      = SIZE_P + SIZE_SUB;\n        break;\n\n    case MARKUP_B :\n        t->style = (style_t)(t->style | STYLE_BOLD);\n        break;\n\n    case MARKUP_DD :\n        t->indent ++;\n        break;\n\n    case MARKUP_DT :\n    case MARKUP_I :\n        t->style = (style_t)(t->style | STYLE_ITALIC);\n        break;\n\n    case MARKUP_U :\n    case MARKUP_INS :\n        t->underline = 1;\n        break;\n\n    case MARKUP_STRIKE :\n    case MARKUP_DEL :\n        t->strikethrough = 1;\n        break;\n\n    default :\n        break;\n  }\n\n  t->parent = parent;\n\n  return (t);\n}\n\n\n/*\n * 'htmlGetText()' - Get all text from the given tree.\n */\n\nuchar *\t\t\t\t/* O - String containing text nodes */\nhtmlGetText(tree_t *t)\t\t/* I - Tree to pick */\n{\n  uchar\t\t*s,\t\t// String\n\t\t*s2,\t\t// New string\n\t\t*tdata = NULL,\t// Temporary string data\n\t\t*talloc = NULL;\t// Allocated string data\n  size_t\tslen,\t\t// Length of string\n\t\ttlen;\t\t// Length of node string\n\n\n  // Loop through all of the nodes in the tree and collect text...\n  slen = 0;\n  s    = NULL;\n\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n\n    if (tdata != NULL)\n    {\n      // Add the text to this string...\n      tlen = strlen((char *)tdata);\n\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n\n      if (!s2)\n        break;\n\n      s = s2;\n\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n\n      slen += tlen;\n\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n\n    t = t->next;\n  }\n\n  if (slen)\n    s[slen] = '\\0';\n\n  if (talloc)\n    free(talloc);\n\n  return (s);\n}\n\n\n/*\n * 'htmlGetMeta()' - Get document \"meta\" data...\n */\n\nuchar *\t\t\t\t/* O - Content string */\nhtmlGetMeta(tree_t *tree,\t/* I - Document tree */\n            uchar  *name)\t/* I - Metadata name */\n{\n  uchar\t*tname,\t\t\t/* Name value from tree entry */\n\t*tcontent;\t\t/* Content value from tree entry */\n\n\n  while (tree != NULL)\n  {\n   /*\n    * Check this tree entry...\n    */\n\n    if (tree->markup == MARKUP_META &&\n        (tname = htmlGetVariable(tree, (uchar *)\"NAME\")) != NULL &&\n        (tcontent = htmlGetVariable(tree, (uchar *)\"CONTENT\")) != NULL)\n    {\n      if (strcasecmp((char *)name, (char *)tname) == 0)\n        return (tcontent);\n    }\n    else if (tree->markup == MARKUP_HTML && !strcasecmp((char *)name, \"LANG\") && (tcontent = htmlGetVariable(tree, (uchar *)\"LANG\")) != NULL)\n    {\n      return (tcontent);\n    }\n\n   /*\n    * Check child entries...\n    */\n\n    if (tree->child != NULL)\n      if ((tcontent = htmlGetMeta(tree->child, name)) != NULL)\n        return (tcontent);\n\n   /*\n    * Next tree entry...\n    */\n\n    tree = tree->next;\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'htmlGetStyle()' - Get a style value from a node's STYLE attribute.\n */\n\nuchar *\t\t\t\t// O - Value or NULL\nhtmlGetStyle(tree_t *t,\t\t// I - Node\n             uchar  *name)\t// I - Name (including \":\")\n{\n  uchar\t\t*ptr,\t\t// Pointer in STYLE attribute\n\t\t*bufptr;\t// Pointer in buffer\n  size_t\tptrlen,\t\t// Length of STYLE attribute\n\t\tnamelen;\t// Length of name\n  static uchar\tbuffer[1024];\t// Buffer for value\n\n\n  // See if we have a STYLE attribute...\n  if ((ptr = htmlGetVariable(t, (uchar *)\"STYLE\")) == NULL)\n    return (NULL);\n\n  // Loop through the STYLE attribute looking for the name...\n  for (namelen = strlen((char *)name), ptrlen = strlen((char *)ptr);\n       ptrlen > namelen;\n       ptr ++, ptrlen --)\n    if (strncasecmp((char *)name, (char *)ptr, namelen) == 0)\n    {\n      for (ptr += namelen; isspace(*ptr); ptr ++);\n\n      for (bufptr = buffer;\n           *ptr && *ptr != ';' && bufptr < (buffer + sizeof(buffer) - 1);\n\t   *bufptr++ = *ptr++);\n\n      *bufptr = '\\0';\n\n      return (buffer);\n    }\n\n  return (NULL);\n}\n\n\n/*\n * 'htmlGetVariable()' - Get a variable value from a markup entry.\n */\n\nuchar *\t\t\t\t/* O - Value or NULL if variable does not exist */\nhtmlGetVariable(tree_t *t,\t/* I - Tree entry */\n                uchar  *name)\t/* I - Variable name */\n{\n  var_t\t*v,\t\t\t/* Matching variable */\n\tkey;\t\t\t/* Search key */\n\n\n  if (t == NULL || name == NULL || t->nvars == 0)\n    return (NULL);\n\n  key.name = name;\n\n  v = (var_t *)bsearch(&key, t->vars, (size_t)t->nvars, sizeof(var_t), (compare_func_t)compare_variables);\n  if (v == NULL)\n    return (NULL);\n  else if (v->value == NULL)\n    return ((uchar *)\"\");\n  else\n    return (v->value);\n}\n\n\n/*\n * 'htmlLoadFontWidths()' - Load all of the font width files.\n */\n\nvoid\nhtmlLoadFontWidths(int typeface, int style)\n{\n  char\t\tfilename[1024];\t\t/* Filenames */\n  FILE\t\t*fp;\t\t\t/* Files */\n  int\t\tch;\t\t\t/* Character */\n  float\t\twidth;\t\t\t/* Width value */\n  char\t\tglyph[64];\t\t/* Glyph name */\n  char\t\tline[1024];\t\t/* Line from AFM file */\n\n\n /*\n  * Now read all of the font widths...\n  */\n\n  for (ch = 0; ch < 256; ch ++)\n    _htmlWidths[typeface][style][ch] = 600;\n\n  if (_htmlUTF8)\n  {\n    for (ch = 0; ch < 65536; ch ++)\n      _htmlWidthsAll[typeface][style][ch] = 600;\n  }\n\n  snprintf(filename, sizeof(filename), \"%s/fonts/%s.afm\", _htmlData, _htmlFonts[typeface][style]);\n  if ((fp = fopen(filename, \"r\")) == NULL)\n  {\n#ifndef DEBUG\n    progress_error(HD_ERROR_FILE_NOT_FOUND, \"Unable to open font width file %s!\", filename);\n#endif /* !DEBUG */\n    return;\n  }\n\n  while (fgets(line, sizeof(line), fp) != NULL)\n  {\n    if (strncmp(line, \"C \", 2) != 0)\n      continue;\n\n    if (typeface < TYPE_SYMBOL)\n    {\n     /*\n      * Handle encoding of regular fonts using assigned charset...\n      */\n\n      if (sscanf(line, \"%*s%*s%*s%*s%f%*s%*s%63s\", &width, glyph) != 2)\n\tcontinue;\n\n      for (ch = 0; ch < 256; ch ++)\n      {\n\tif (_htmlGlyphs[ch] && !strcmp(_htmlGlyphs[ch], glyph))\n\t{\n\t  _htmlWidths[typeface][style][ch] = (short)width;\n\t  break;\n\t}\n      }\n\n      if (_htmlUTF8)\n      {\n\tfor (ch = 0; ch < 65536; ch ++)\n\t{\n\t  if (_htmlGlyphsAll[ch] && !strcmp(_htmlGlyphsAll[ch], glyph))\n\t  {\n\t    _htmlWidthsAll[typeface][style][ch] = (short)width;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else\n    {\n     /*\n      * Symbol and Dingbats fonts uses their own encoding...\n      */\n\n      if (sscanf(line, \"%*s%d%*s%*s%f\", &ch, &width) != 2)\n\tcontinue;\n\n      if (ch < 256 && ch >= 0)\n      {\n\t_htmlWidths[typeface][style][ch]    = (short)width;\n\t_htmlWidthsAll[typeface][style][ch] = (short)width;\n      }\n    }\n  }\n\n  fclose(fp);\n\n  // Make sure that non-breaking space has the same width as a breaking space...\n  _htmlWidths[typeface][style][160]    = _htmlWidths[typeface][style][32];\n  _htmlWidthsAll[typeface][style][160] = _htmlWidthsAll[typeface][style][32];\n\n  _htmlWidthsLoaded[typeface][style] = 1;\n}\n\n\n/*\n * 'htmlSetVariable()' - Set a variable for a markup entry.\n */\n\nint\t\t\t\t/* O - Set status: 0 = success, -1 = fail */\nhtmlSetVariable(tree_t *t,\t/* I - Tree entry */\n                uchar  *name,\t/* I - Variable name */\n                uchar  *value)\t/* I - Variable value */\n{\n  var_t\t*v,\t\t\t/* Matching variable */\n\tkey;\t\t\t/* Search key */\n\n\n  DEBUG_printf((\"%shtmlSetVariable(%p, \\\"%s\\\", \\\"%s\\\")\\n\", indent, (void *)t, name,\n                value ? (const char *)value : \"(null)\"));\n\n  if (t->nvars == 0)\n    v = NULL;\n  else\n  {\n    key.name = name;\n\n    v = (var_t *)bsearch(&key, t->vars, (size_t)t->nvars, sizeof(var_t), (compare_func_t)compare_variables);\n  }\n\n  if (v == NULL)\n  {\n    if (t->nvars == 0)\n      v = (var_t *)malloc(sizeof(var_t));\n    else\n      v = (var_t *)realloc(t->vars, sizeof(var_t) * (size_t)(t->nvars + 1));\n\n    if (v == NULL)\n    {\n      DEBUG_printf((\"%s==== MALLOC/REALLOC FAILED! ====\\n\", indent));\n\n      return (-1);\n    }\n\n    t->vars  = v;\n    v        += t->nvars;\n    t->nvars ++;\n    v->name  = (uchar *)strdup((char *)name);\n    if (value != NULL)\n      v->value = (uchar *)strdup((char *)value);\n    else\n      v->value = NULL;\n\n    if (strcasecmp((char *)name, \"HREF\") == 0)\n    {\n      DEBUG_printf((\"%s---- Set link to %s ----\\n\", indent, value));\n      t->link = t;\n    }\n\n    if (t->nvars > 1)\n      qsort(t->vars, (size_t)t->nvars, sizeof(var_t), (compare_func_t)compare_variables);\n  }\n  else if (v->value != value)\n  {\n    if (v->value != NULL)\n      free(v->value);\n    if (value != NULL)\n      v->value = (uchar *)strdup((char *)value);\n    else\n      v->value = NULL;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'htmlSetBaseSize()' - Set the font sizes and spacings...\n */\n\nvoid\nhtmlSetBaseSize(double p,\t/* I - Point size of paragraph font */\n                double s)\t/* I - Spacing */\n{\n  int\ti;\t\t\t/* Looping var */\n\n\n  p /= 1.2 * 1.2 * 1.2;\n  for (i = 0; i < 8; i ++, p *= 1.2)\n  {\n    _htmlSizes[i]    = p;\n    _htmlSpacings[i] = p * s;\n  }\n}\n\n\n/*\n * 'htmlSetCharSet()' - Set the character set for output.\n */\n\nvoid\nhtmlSetCharSet(const char *cs)\t\t/* I - Character set file to load */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\tfilename[1024];\t\t/* Filenames */\n  FILE\t\t*fp;\t\t\t/* Files */\n  int\t\tch, unicode;\t\t/* Character values */\n  char\t\tglyph[64];\t\t/* Glyph name */\n  char\t\tline[1024];\t\t/* Line from charset file */\n  int\t\tchars[256];\t\t/* Character encoding array */\n\n\n  strlcpy(_htmlCharSet, cs, sizeof(_htmlCharSet));\n\n  if (!_htmlInitialized)\n  {\n   /*\n    * Load the PostScript glyph names for all of Unicode...\n    */\n\n    memset(_htmlGlyphsAll, 0, sizeof(_htmlGlyphsAll));\n\n    snprintf(line, sizeof(line), \"%s/data/psglyphs\", _htmlData);\n    if ((fp = fopen(line, \"r\")) != NULL)\n    {\n      while (fscanf(fp, \"%x%63s\", &unicode, glyph) == 2)\n        _htmlGlyphsAll[unicode] = strdup(glyph);\n\n      fclose(fp);\n\n      _htmlInitialized = 1;\n    }\n#ifndef DEBUG\n    else\n      progress_error(HD_ERROR_FILE_NOT_FOUND,\n                     \"Unable to open psglyphs data file!\");\n#endif /* !DEBUG */\n  }\n\n  memset(_htmlGlyphs, 0, sizeof(_htmlGlyphs));\n\n  if (!strcmp(cs, \"utf-8\"))\n  {\n    // Generate a dynamic mapping of Unicode to an 8-bit charset with the\n    // bottom 128 characters matching US ASCII...\n    _htmlUTF8 = 0x80;\n\n    for (i = 0; i < 128; i ++)\n    {\n     /*\n      * Add the glyph to the charset array...\n      */\n\n      _htmlGlyphs[i]  = _htmlGlyphsAll[i];\n      _htmlUnicode[i] = i;\n    }\n\n    memset(_htmlWidthsLoaded, 0, sizeof(_htmlWidthsLoaded));\n    return;\n  }\n\n  if (strncmp(cs, \"8859-\", 5) == 0)\n    snprintf(filename, sizeof(filename), \"%s/data/iso-%s\", _htmlData, cs);\n  else\n    snprintf(filename, sizeof(filename), \"%s/data/%s\", _htmlData, cs);\n\n  if ((fp = fopen(filename, \"r\")) == NULL)\n  {\n   /*\n    * Can't open charset file; use ISO-8859-1...\n    */\n\n#ifndef DEBUG\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open character set file %s!\", cs);\n#endif /* !DEBUG */\n\n    for (i = 0; i < 256; i ++)\n      chars[i] = i;\n  }\n  else\n  {\n   /*\n    * Read the <char> <unicode> lines from the file...\n    */\n\n    memset(chars, 0, sizeof(chars));\n\n    while (fscanf(fp, \"%x%x\", &ch, &unicode) == 2)\n      chars[ch] = unicode;\n\n    fclose(fp);\n  }\n\n /*\n  * Build the glyph array...\n  */\n\n  for (i = 0; i < 256; i ++)\n  {\n   /*\n    * Add the glyph to the charset array...\n    */\n\n    if (chars[i] == 0)\n    {\n      _htmlGlyphs[i] = NULL;\n      continue;\n    }\n    else\n      _htmlGlyphs[i] = _htmlGlyphsAll[chars[i]];\n\n    if (_htmlGlyphs[i])\n      _htmlUnicode[i] = chars[i];\n  }\n\n  memset(_htmlWidthsLoaded, 0, sizeof(_htmlWidthsLoaded));\n}\n\n\n/*\n * 'htmlSetTextColor()' - Set the default text color.\n */\n\nvoid\nhtmlSetTextColor(uchar *color)\t/* I - Text color */\n{\n  strlcpy((char *)_htmlTextColor, (char *)color, sizeof(_htmlTextColor));\n}\n\n\n/*\n * 'compare_variables()' - Compare two markup variables.\n */\n\nstatic int\t\t\t/* O - -1 if v0 < v1, 0 if v0 == v1, 1 if v0 > v1 */\ncompare_variables(var_t *v0,\t/* I - First variable */\n                  var_t *v1)\t/* I - Second variable */\n{\n  return (strcasecmp((char *)v0->name, (char *)v1->name));\n}\n\n\n/*\n * 'compare_markups()' - Compare two markup strings...\n */\n\nstatic int\t\t\t/* O - -1 if m0 < m1, 0 if m0 == m1, 1 if m0 > m1 */\ncompare_markups(uchar **m0,\t/* I - First markup */\n                uchar **m1)\t/* I - Second markup */\n{\n  if (tolower((*m0)[0]) == 'h' && isdigit((*m0)[1]) &&\n      tolower((*m1)[0]) == 'h' && isdigit((*m1)[1]))\n    return (atoi((char *)*m0 + 1) - atoi((char *)*m1 + 1));\n  else\n    return (strcasecmp((char *)*m0, (char *)*m1));\n}\n\n\n/*\n * 'delete_node()' - Free all memory associated with a node...\n */\n\nstatic void\ndelete_node(tree_t *t)\t\t/* I - Node to delete */\n{\n  int\t\ti;\t\t/* Looping var */\n  var_t\t\t*var;\t\t/* Current variable */\n\n\n  if (t == NULL)\n    return;\n\n  if (t->data != NULL)\n    free(t->data);\n\n  for (i = t->nvars, var = t->vars; i > 0; i --, var ++)\n  {\n    free(var->name);\n    if (var->value != NULL)\n      free(var->value);\n  }\n\n  if (t->vars != NULL)\n    free(t->vars);\n\n  free(t);\n}\n\n\n//\n// 'insert_space()' - Insert a whitespace character before the\n//                    specified node.\n//\n\nstatic void\ninsert_space(tree_t *parent,\t// I - Parent node\n             tree_t *t)\t\t// I - Node to insert before\n{\n  tree_t\t*space;\t\t// Space node\n\n\n  // Allocate memory for the whitespace...\n  space = (tree_t *)calloc(sizeof(tree_t), 1);\n  if (space == NULL)\n  {\n#ifndef DEBUG\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for HTML tree node!\");\n#endif /* !DEBUG */\n    return;\n  }\n\n  // Set/copy font characteristics...\n  if (parent)\n  {\n    space->typeface = parent->typeface;\n    space->size     = parent->size;\n    space->style    = parent->style;\n  }\n  else\n  {\n    space->typeface = _htmlBodyFont;\n    space->size     = SIZE_P;\n  }\n\n  // Initialize element data...\n  space->markup = MARKUP_NONE;\n  space->data   = (uchar *)strdup(\" \");\n\n  // Set tree pointers...\n  space->parent = parent;\n  space->prev   = t->prev;\n  space->next   = t;\n\n  if (space->prev)\n    space->prev->next = space;\n  else if (parent)\n    parent->child = space;\n\n  t->prev = space;\n\n  compute_size(space);\n}\n\n\n/*\n * 'parse_markup()' - Parse a markup string.\n */\n\nstatic int\t\t\t/* O - -1 on error, MARKUP_nnnn otherwise */\nparse_markup(tree_t *t,\t\t/* I - Current tree entry */\n             FILE   *fp,\t/* I - Input file */\n\t     int    *linenum)\t/* O - Current line number */\n{\n  int\tch, ch2;\t\t/* Characters from file */\n  uchar\tmarkup[255],\t\t/* Markup string... */\n\t*mptr,\t\t\t/* Current character... */\n\tcomment[10240],\t\t/* Comment string */\n\t*cptr,\t\t\t/* Current char... */\n\t**temp;\t\t\t/* Markup variable entry */\n\n\n  mptr = markup;\n\n  while ((ch = getc(fp)) != EOF && mptr < (markup + sizeof(markup) - 1))\n    if (ch == '>' || isspace(ch))\n      break;\n    else if (ch == '/' && mptr > markup)\n    {\n      // Look for \"/>\"...\n      ch = getc(fp);\n\n      if (ch != '>')\n        return (MARKUP_ERROR);\n\n      break;\n    }\n    else\n    {\n      if ((ch & 0x80) && _htmlUTF8)\n      {\n        // Collect UTF-8 value...\n        ch = utf8_getc(ch, fp);\n      }\n\n      if (ch)\n        *mptr++ = (uchar)ch;\n\n      // Handle comments without whitespace...\n      if ((mptr - markup) == 3 && strncmp((const char *)markup, \"!--\", 3) == 0)\n      {\n        ch = getc(fp);\n        break;\n      }\n    }\n\n  *mptr = '\\0';\n\n  if (ch == EOF)\n    return (MARKUP_ERROR);\n\n  mptr = markup;\n  temp = (uchar **)bsearch(&mptr, _htmlMarkups,\n                           sizeof(_htmlMarkups) / sizeof(_htmlMarkups[0]),\n                           sizeof(_htmlMarkups[0]),\n                           (compare_func_t)compare_markups);\n\n  if (temp == NULL)\n  {\n   /*\n    * Unrecognized markup stuff...\n    */\n\n    t->markup = MARKUP_UNKNOWN;\n    strlcpy((char *)comment, (char *)markup, sizeof(comment));\n    cptr = comment + strlen((char *)comment);\n\n    DEBUG_printf((\"%s%s (unrecognized!)\\n\", indent, markup));\n  }\n  else\n  {\n    t->markup = (markup_t)((const char **)temp - _htmlMarkups);\n    cptr      = comment;\n\n    DEBUG_printf((\"%s%s, line %d\\n\", indent, markup, *linenum));\n  }\n\n  if (t->markup == MARKUP_COMMENT || t->markup == MARKUP_UNKNOWN)\n  {\n    int lastch = ch;\t\t\t// Last character seen\n\n    while (ch != EOF && cptr < (comment + sizeof(comment) - 2))\n    {\n      if (ch == '>' && temp == NULL)\n        break;\n\n      if (ch == '\\n')\n        (*linenum) ++;\n\n      if (ch == '-' && lastch == '-')\n      {\n        *cptr++ = (uchar)ch;\n\n        if ((ch2 = getc(fp)) == '>')\n\t{\n\t  // Erase trailing -->\n\t  cptr -= 2;\n\n          if (cptr < comment)\n            cptr = comment; // Issue #316: buffer underflow\n\t  break;\n        }\n\telse\n\t  ch = ch2;\n      }\n      else\n      {\n        if (ch == '&')\n\t{\n          // Handle character entities...\n\t  uchar\tentity[16],\t\t// Character entity name\n\t\t*eptr;\t\t\t// Pointer into name\n\n\n\t  eptr = entity;\n\t  while (eptr < (entity + sizeof(entity) - 1) &&\n\t\t (ch = getc(fp)) != EOF)\n\t    if (!isalnum(ch) && ch != '#')\n\t      break;\n\t    else\n\t      *eptr++ = (uchar)ch;\n\n\t  if (ch != ';')\n\t  {\n\t    ungetc(ch, fp);\n\t    ch = 0;\n\t  }\n\n\t  *eptr = '\\0';\n\t  if (!ch)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                   *linenum, _htmlCurrentFile);\n\n            if (cptr < (comment + sizeof(comment) - 1))\n\t      *cptr++ = '&';\n            strlcpy((char *)cptr, (char *)entity, sizeof(comment) - (size_t)(cptr - comment));\n\t    cptr += strlen((char *)cptr);\n\t  }\n\t  else if ((ch = iso8859(entity)) == 0)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                   entity, *linenum, _htmlCurrentFile);\n\n            if (cptr < (comment + sizeof(comment) - 1))\n\t      *cptr++ = '&';\n            strlcpy((char *)cptr, (char *)entity, sizeof(comment) - (size_t)(cptr - comment));\n\t    cptr += strlen((char *)cptr);\n            if (cptr < (comment + sizeof(comment) - 1))\n\t      *cptr++ = ';';\n\t  }\n\t  else\n\t    *cptr++ = (uchar)ch;\n\t}\n\telse\n        {\n          if ((ch & 0x80) && _htmlUTF8)\n          {\n            // Collect UTF-8 value...\n            ch = utf8_getc(ch, fp);\n          }\n\n          if (ch)\n            *cptr++ = (uchar)ch;\n        }\n\n        lastch = ch;\n        ch     = getc(fp);\n      }\n    }\n\n    *cptr = '\\0';\n    t->data = (uchar *)strdup((char *)comment);\n  }\n  else\n  {\n    while (ch != EOF && ch != '>')\n    {\n      if (ch == '\\n')\n        (*linenum) ++;\n\n      if (!isspace(ch))\n      {\n        ungetc(ch, fp);\n        parse_variable(t, fp, linenum);\n      }\n\n      ch = getc(fp);\n\n      if (ch == '/')\n      {\n\t// Look for \"/>\"...\n\tch = getc(fp);\n\n\tif (ch != '>')\n          return (MARKUP_ERROR);\n\n\tbreak;\n      }\n    }\n  }\n\n  return (t->markup);\n}\n\n\n/*\n * 'parse_variable()' - Parse a markup variable string.\n */\n\nstatic int\t\t\t\t// O - -1 on error, 0 on success\nparse_variable(tree_t *t,\t\t// I - Current tree entry\n               FILE   *fp,\t\t// I - Input file\n\t       int    *linenum)\t\t// I - Current line number\n{\n  uchar\tname[1024],\t\t\t// Name of variable\n\tvalue[10240],\t\t\t// Value of variable\n\t*ptr,\t\t\t\t// Temporary pointer\n\tentity[16],\t\t\t// Character entity name\n\t*eptr;\t\t\t\t// Pointer into name\n  int\tch;\t\t\t\t// Character from file\n\n\n  ptr = name;\n  while ((ch = getc(fp)) != EOF)\n    if (isspace(ch) || ch == '=' || ch == '>' || ch == '\\r')\n      break;\n    else if (ch == '/' && ptr == name)\n      break;\n    else if (ptr < (name + sizeof(name) - 1))\n    {\n      if ((ch & 0x80) && _htmlUTF8)\n      {\n        // Collect UTF-8 value...\n        ch = utf8_getc(ch, fp);\n      }\n\n      if (ch)\n        *ptr++ = (uchar)ch;\n    }\n\n  *ptr = '\\0';\n\n  if (ch == '\\n')\n    (*linenum) ++;\n\n  while (isspace(ch) || ch == '\\r')\n  {\n    ch = getc(fp);\n\n    if (ch == '\\n')\n      (*linenum) ++;\n  }\n\n  switch (ch)\n  {\n    default :\n        ungetc(ch, fp);\n        return (htmlSetVariable(t, name, NULL));\n    case EOF :\n        return (-1);\n    case '=' :\n        ptr = value;\n        ch  = getc(fp);\n\n        while (isspace(ch) || ch == '\\r')\n          ch = getc(fp);\n\n        if (ch == EOF)\n          return (-1);\n\n        if (ch == '\\'')\n        {\n          while ((ch = getc(fp)) != EOF)\n\t  {\n            if (ch == '\\'')\n              break;\n\t    else if (ch == '&')\n\t    {\n\t      // Possibly a character entity...\n\t      eptr = entity;\n\t      while (eptr < (entity + sizeof(entity) - 1) &&\n\t             (ch = getc(fp)) != EOF)\n\t        if (!isalnum(ch) && ch != '#')\n\t\t  break;\n\t\telse\n\t\t  *eptr++ = (uchar)ch;\n\n              if (ch != ';')\n\t      {\n\t        ungetc(ch, fp);\n\t\tch = 0;\n\t      }\n\n              *eptr = '\\0';\n              if (!ch)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unquoted & on line %d of %s.\",\n\t                       *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n\t      }\n\t      else if ((ch = iso8859(entity)) == 0)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                       entity, *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = ';';\n\t      }\n\t      else if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = (uchar)ch;\n\t    }\n            else if (ptr < (value + sizeof(value) - 1) &&\n\t             ch != '\\n' && ch != '\\r')\n            {\n              if ((ch & 0x80) && _htmlUTF8)\n              {\n                // Collect UTF-8 value...\n                ch = utf8_getc(ch, fp);\n              }\n\n              if (ch)\n                *ptr++ = (uchar)ch;\n            }\n\t    else if (ch == '\\n')\n\t    {\n\t      if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = ' ';\n\n\t      (*linenum) ++;\n\t    }\n\t  }\n\n          *ptr = '\\0';\n        }\n        else if (ch == '\\\"')\n        {\n          while ((ch = getc(fp)) != EOF)\n\t  {\n            if (ch == '\\\"')\n              break;\n\t    else if (ch == '&')\n\t    {\n\t      // Possibly a character entity...\n\t      eptr = entity;\n\t      while (eptr < (entity + sizeof(entity) - 1) &&\n\t             (ch = getc(fp)) != EOF)\n\t        if (!isalnum(ch) && ch != '#')\n\t\t  break;\n\t\telse\n\t\t  *eptr++ = (uchar)ch;\n\n              if (ch != ';')\n\t      {\n\t        ungetc(ch, fp);\n\t\tch = 0;\n\t      }\n\n              *eptr = '\\0';\n              if (!ch)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                       *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n\t      }\n\t      else if ((ch = iso8859(entity)) == 0)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                       entity, *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = ';';\n\t      }\n\t      else if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = (uchar)ch;\n\t    }\n            else if (ptr < (value + sizeof(value) - 1) &&\n\t             ch != '\\n' && ch != '\\r')\n            {\n              if ((ch & 0x80) && _htmlUTF8)\n              {\n                // Collect UTF-8 value...\n                ch = utf8_getc(ch, fp);\n              }\n\n              if (ch)\n                *ptr++ = (uchar)ch;\n            }\n\t    else if (ch == '\\n')\n\t    {\n\t      if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = ' ';\n\n\t      (*linenum) ++;\n\t    }\n\t  }\n\n          *ptr = '\\0';\n        }\n        else\n        {\n          *ptr++ = (uchar)ch;\n          while ((ch = getc(fp)) != EOF)\n\t  {\n            if (isspace(ch) || ch == '>' || ch == '\\r')\n              break;\n\t    else if (ch == '&')\n\t    {\n\t      // Possibly a character entity...\n\t      eptr = entity;\n\t      while (eptr < (entity + sizeof(entity) - 1) &&\n\t             (ch = getc(fp)) != EOF)\n\t        if (!isalnum(ch) && ch != '#')\n\t\t  break;\n\t\telse\n\t\t  *eptr++ = (uchar)ch;\n\n              if (ch != ';')\n\t      {\n\t        ungetc(ch, fp);\n\t\tch = 0;\n\t      }\n\n              *eptr = '\\0';\n              if (!ch)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                       *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n\t      }\n\t      else if ((ch = iso8859(entity)) == 0)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                       entity, *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = ';';\n\t      }\n\t      else if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = (uchar)ch;\n\t    }\n            else if (ptr < (value + sizeof(value) - 1))\n            {\n              if ((ch & 0x80) && _htmlUTF8)\n              {\n                // Collect UTF-8 value...\n                ch = utf8_getc(ch, fp);\n              }\n\n              if (ch)\n                *ptr++ = (uchar)ch;\n            }\n\t  }\n\n\t  if (ch == '\\n')\n\t    (*linenum) ++;\n\n          *ptr = '\\0';\n          if (ch == '>')\n            ungetc(ch, fp);\n        }\n\n        return (htmlSetVariable(t, name, value));\n  }\n}\n\n\n/*\n * 'compute_size()' - Compute the width and height of a tree entry.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = failure */\ncompute_size(tree_t *t)\t\t/* I - Tree entry */\n{\n  uchar\t\t*ptr;\t\t/* Current character */\n  float\t\twidth;\t\t/* Current width */\n  int\t\tint_width;\t/* Integer width */\n  uchar\t\t*width_ptr,\t/* Pointer to width string */\n\t\t*height_ptr,\t/* Pointer to height string */\n\t\t*size_ptr,\t/* Pointer to size string */\n\t\t*type_ptr;\t/* Pointer to spacer type string */\n  image_t\t*img;\t\t/* Image */\n  char\t\tnumber[255];\t/* Width or height value */\n\n\n  if (!_htmlInitialized)\n    htmlSetCharSet(\"iso-8859-1\");\n\n  if (t->markup == MARKUP_IMG)\n  {\n    width_ptr  = htmlGetVariable(t, (uchar *)\"WIDTH\");\n    height_ptr = htmlGetVariable(t, (uchar *)\"HEIGHT\");\n\n    img = image_load((char *)htmlGetVariable(t, (uchar *)\"REALSRC\"),\n                     _htmlGrayscale);\n\n    if (width_ptr != NULL && height_ptr != NULL)\n    {\n      t->width  = (float)(atoi((char *)width_ptr) / _htmlPPI * 72.0f);\n      t->height = (float)(atoi((char *)height_ptr) / _htmlPPI * 72.0f);\n\n      return (0);\n    }\n\n    if (img == NULL)\n      return (-1);\n\n    if (width_ptr != NULL)\n    {\n      t->width  = (float)(atoi((char *)width_ptr) / _htmlPPI * 72.0f);\n      t->height = (float)(t->width * img->height / img->width);\n\n      snprintf(number, sizeof(number), \"%d\", atoi((char *)width_ptr) * img->height / img->width);\n      if (strchr((char *)width_ptr, '%') != NULL)\n        strlcat(number, \"%\", sizeof(number));\n      htmlSetVariable(t, (uchar *)\"HEIGHT\", (uchar *)number);\n    }\n    else if (height_ptr != NULL)\n    {\n      t->height = (float)(atoi((char *)height_ptr) / _htmlPPI * 72.0f);\n      t->width  = (float)(t->height * img->width / img->height);\n\n      snprintf(number, sizeof(number), \"%d\", atoi((char *)height_ptr) * img->width / img->height);\n      if (strchr((char *)height_ptr, '%') != NULL)\n        strlcat(number, \"%\", sizeof(number));\n      htmlSetVariable(t, (uchar *)\"WIDTH\", (uchar *)number);\n    }\n    else\n    {\n      t->width  = (float)(img->width / _htmlPPI * 72.0f);\n      t->height = (float)(img->height / _htmlPPI * 72.0f);\n\n      snprintf(number, sizeof(number), \"%d\", img->width);\n      htmlSetVariable(t, (uchar *)\"WIDTH\", (uchar *)number);\n\n      snprintf(number, sizeof(number), \"%d\", img->height);\n      htmlSetVariable(t, (uchar *)\"HEIGHT\", (uchar *)number);\n    }\n\n    return (0);\n  }\n  else if (t->markup == MARKUP_SPACER)\n  {\n    width_ptr  = htmlGetVariable(t, (uchar *)\"WIDTH\");\n    height_ptr = htmlGetVariable(t, (uchar *)\"HEIGHT\");\n    size_ptr   = htmlGetVariable(t, (uchar *)\"SIZE\");\n    type_ptr   = htmlGetVariable(t, (uchar *)\"TYPE\");\n\n    if (width_ptr != NULL)\n      t->width = (float)(atoi((char *)width_ptr) / _htmlPPI * 72.0f);\n    else if (size_ptr != NULL)\n      t->width = (float)(atoi((char *)size_ptr) / _htmlPPI * 72.0f);\n    else\n      t->width = 1.0f;\n\n    if (height_ptr != NULL)\n      t->height = (float)(atoi((char *)height_ptr) / _htmlPPI * 72.0f);\n    else if (size_ptr != NULL)\n      t->height = (float)(atoi((char *)size_ptr) / _htmlPPI * 72.0f);\n    else\n      t->height = 1.0f;\n\n    if (type_ptr == NULL)\n      return (0);\n\n    if (strcasecmp((char *)type_ptr, \"horizontal\") == 0)\n      t->height = 0.0;\n    else if (strcasecmp((char *)type_ptr, \"vertical\") == 0)\n      t->width = 0.0;\n\n    return (0);\n  }\n  else if (t->markup == MARKUP_BR)\n  {\n    t->width  = 0.0;\n    t->height = (float)_htmlSizes[t->size];\n\n    return (0);\n  }\n  else if (t->preformatted && t->data)\n  {\n    int\t\tmax_width = 0;\t\t/* Maximum width */\n\n    for (int_width = 0, ptr = t->data; *ptr != '\\0'; ptr ++)\n    {\n      if (*ptr == '\\n')\n      {\n        if (int_width > max_width)\n          max_width = int_width;\n\n\tint_width = 0;\n      }\n      else if (*ptr == '\\t')\n        int_width = (int_width + 7) & ~7;\n      else\n        int_width ++;\n    }\n\n    if (int_width > max_width)\n      max_width = int_width;\n\n    if (!_htmlWidthsLoaded[t->typeface][t->style])\n      htmlLoadFontWidths(t->typeface, t->style);\n\n    width = _htmlWidths[t->typeface][t->style][0x20] * max_width * 0.001f;\n  }\n  else if (t->data)\n  {\n    if (!_htmlWidthsLoaded[t->typeface][t->style])\n      htmlLoadFontWidths(t->typeface, t->style);\n\n    for (int_width = 0, ptr = t->data; *ptr != '\\0'; ptr ++)\n      int_width += _htmlWidths[t->typeface][t->style][(int)*ptr & 255];\n\n    width = 0.001f * int_width;\n  }\n  else\n    width = 0.0f;\n\n  t->width  = (float)(width * _htmlSizes[t->size]);\n  t->height = (float)_htmlSizes[t->size];\n\n  DEBUG_printf((\"%swidth = %.1f, height = %.1f\\n\", indent, t->width, t->height));\n\n  return (0);\n}\n\n\n/*\n * 'compute_color()' - Compute the red, green, blue color from the given\n *                     string.\n */\n\nstatic int\ncompute_color(tree_t *t,\t/* I - Tree entry */\n              uchar  *color)\t/* I - Color string */\n{\n  float\trgb[3];\t\t\t/* RGB color */\n\n\n  get_color(color, rgb);\n\n  t->red   = (uchar)(rgb[0] * 255.0f + 0.5f);\n  t->green = (uchar)(rgb[1] * 255.0f + 0.5f);\n  t->blue  = (uchar)(rgb[2] * 255.0f + 0.5f);\n\n  return (0);\n}\n\n\n/*\n * 'get_alignment()' - Get horizontal & vertical alignment values.\n */\n\nstatic int\t\t\t/* O - 0 for success, -1 for failure */\nget_alignment(tree_t *t)\t/* I - Tree entry */\n{\n  uchar\t*align;\t\t\t/* Alignment string */\n\n\n  if ((align = htmlGetVariable(t, (uchar *)\"ALIGN\")) == NULL)\n    align = htmlGetStyle(t, (uchar *)\"text-align\");\n\n  if (align != NULL)\n  {\n    if (!strcasecmp((char *)align, \"left\"))\n      t->halignment = ALIGN_LEFT;\n    else if (!strcasecmp((char *)align, \"center\"))\n      t->halignment = ALIGN_CENTER;\n    else if (!strcasecmp((char *)align, \"right\"))\n      t->halignment = ALIGN_RIGHT;\n    else if (!strcasecmp((char *)align, \"justify\"))\n      t->halignment = ALIGN_JUSTIFY;\n    else if (!strcasecmp((char *)align, \"top\"))\n      t->valignment = ALIGN_TOP;\n    else if (!strcasecmp((char *)align, \"middle\") ||\n             !strcasecmp((char *)align, \"absmiddle\"))\n      t->valignment = ALIGN_MIDDLE;\n    else if (!strcasecmp((char *)align, \"bottom\"))\n      t->valignment = ALIGN_BOTTOM;\n  }\n\n  if ((align = htmlGetVariable(t, (uchar *)\"VALIGN\")) == NULL)\n    align = htmlGetStyle(t, (uchar *)\"vertical-align\");\n\n  if (align != NULL)\n  {\n    if (!strcasecmp((char *)align, \"top\"))\n      t->valignment = ALIGN_TOP;\n    else if (!strcasecmp((char *)align, \"middle\"))\n      t->valignment = ALIGN_MIDDLE;\n    else if (!strcasecmp((char *)align, \"center\"))\n      t->valignment = ALIGN_MIDDLE;\n    else if (!strcasecmp((char *)align, \"bottom\"))\n      t->valignment = ALIGN_BOTTOM;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'fix_filename()' - Fix a filename to be relative to the base directory.\n */\n\nstatic const char *\t\t\t/* O - Fixed filename */\nfix_filename(char *filename,\t\t/* I - Original filename */\n             char *base)\t\t/* I - Base directory */\n{\n  char\t\t*slash;\t\t\t/* Location of slash */\n  char\t\t*tempptr;\t\t/* Pointer into filename */\n  static char\ttemp[1024];\t\t/* Temporary filename */\n  static char\tnewfilename[1024];\t/* New filename */\n\n\n//  printf(\"fix_filename(filename=\\\"%s\\\", base=\\\"%s\\\")\\n\", filename, base);\n\n  if (filename == NULL)\n    return (NULL);\n\n#ifdef DEBUG // to silence Clang static analyzer, totally unnecessary\n  memset(temp, 0, sizeof(temp));\n#endif // DEBUG\n\n  // Unescape filenames as needed...\n  if (strchr(filename, '%') && !strstr(filename, \"//\"))\n  {\n    for (tempptr = temp; *filename && tempptr < (temp + sizeof(temp) - 1);)\n    {\n      if (*filename == '%')\n      {\n        // Decode hex-escaped filename character...\n\tfilename ++;\n\tif (isxdigit(filename[0] & 255) && isxdigit(filename[1] & 255))\n\t{\n\t  if (isdigit(filename[0] & 255))\n\t    *tempptr = (char)((filename[0] - '0') << 4);\n\t  else\n\t    *tempptr = (char)((tolower(filename[0]) - 'a' + 10) << 4);\n\n\t  if (isdigit(filename[1] & 255))\n\t    *tempptr |= filename[1] - '0';\n\t  else\n\t    *tempptr |= tolower(filename[0]) - 'a' + 10;\n\n          tempptr ++;\n\t  filename += 2;\n\t}\n\telse\n\t  *tempptr++ = '%';\n      }\n      else\n        *tempptr++ = *filename++;\n    }\n\n    *tempptr = '\\0';\n    filename = temp;\n  }\n\n  if (strcmp(base, \".\") == 0 || strstr(filename, \"//\") != NULL)\n    return (file_find(Path, filename));\n\n  if (strncmp(filename, \"./\", 2) == 0 ||\n      strncmp(filename, \".\\\\\", 2) == 0)\n    filename += 2;\n\n  if (strncmp(base, \"http://\", 7) == 0 || strncmp(base, \"https://\", 8) == 0)\n  {\n    // Base is a URL...\n    char\tscheme[32],\t\t// URI scheme\n\t\tuserpass[256],\t\t// Username:password\n\t\thost[256],\t\t// Hostname or IP address\n\t\tresource[256];\t\t// Resource path\n    int\t\tport;\t\t\t// Port number\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, base, scheme, sizeof(scheme), userpass, sizeof(userpass), host, sizeof(host), &port, resource, sizeof(resource));\n\n    if (filename[0] == '/')\n    {\n      // Absolute path, so just use the server...\n      httpAssembleURI(HTTP_URI_CODING_ALL, newfilename, sizeof(newfilename), scheme, userpass, host, port, filename);\n    }\n    else\n    {\n      // Relative path, strip the last component from the resource...\n      if ((slash = strrchr(resource, '/')) != NULL)\n\t*slash = '\\0';\n\n      // Handle \"../\" in filename...\n      while (!strncmp(filename, \"../\", 3))\n      {\n\t// Strip one level of directory in the resource\n\tfilename += 3;\n\n\tif ((slash = strrchr(resource, '/')) != NULL)\n\t  *slash = '\\0';\n      }\n\n      // Combine the resource and remaining relative filename to make a URL...\n      httpAssembleURIf(HTTP_URI_CODING_ALL, newfilename, sizeof(newfilename), scheme, userpass, host, port, \"%s/%s\", resource, filename);\n    }\n  }\n  else\n  {\n    // Base is a filename...\n    if (filename[0] == '/' || filename[0] == '\\\\' || base == NULL ||\n\tbase[0] == '\\0' || (isalpha(filename[0]) && filename[1] == ':'))\n    {\n      // No change needed for absolute path...\n      return (file_find(Path, filename));\n    }\n\n    strlcpy(newfilename, base, sizeof(newfilename));\n    base = newfilename;\n\n#if defined(WIN32) || defined(__EMX__)\n    while (!strncmp(filename, \"../\", 3) || !strncmp(filename, \"..\\\\\", 3))\n#else\n    while (!strncmp(filename, \"../\", 3))\n#endif // WIN32 || __EMX__\n    {\n      filename += 3;\n#if defined(WIN32) || defined(__EMX__)\n      if ((slash = strrchr(base, '/')) != NULL)\n        *slash = '\\0';\n      else if ((slash = strrchr(base, '\\\\')) != NULL)\n        *slash = '\\0';\n#else\n      if ((slash = strrchr(base, '/')) != NULL)\n        *slash = '\\0';\n#endif // WIN32 || __EMX__\n      else\n      {\n\tfilename -= 3;\n\tbreak;\n      }\n    }\n\n    if (filename[0] != '/' && *base && base[strlen(base) - 1] != '/')\n      strlcat(newfilename, \"/\", sizeof(newfilename));\n\n    strlcat(newfilename, filename, sizeof(newfilename));\n  }\n\n//  printf(\"    newfilename=\\\"%s\\\"\\n\", newfilename);\n\n  return (file_find(Path, newfilename));\n}\n\n\n//\n// 'html_memory_used()' - Figure out the amount of memory that was used.\n//\n\nstatic int\t\t\t\t// O - Bytes used\nhtml_memory_used(tree_t *t)\t\t// I - Tree node\n{\n  int\ti;\t\t\t\t// Looping var\n  int\tbytes;\t\t\t\t// Bytes used\n\n\n  if (t == NULL)\n    return (0);\n\n  bytes = 0;\n\n  while (t != NULL)\n  {\n    bytes += sizeof(tree_t);\n    bytes += (size_t)t->nvars * sizeof(var_t);\n\n    for (i = 0; i < t->nvars; i ++)\n    {\n      bytes += (strlen((char *)t->vars[i].name) + 8) & (size_t)~7;\n\n      if (t->vars[i].value != NULL)\n        bytes += (strlen((char *)t->vars[i].value) + 8) & (size_t)~7;\n    }\n\n    if (t->data != NULL)\n      bytes += (strlen((char *)t->data) + 8) & (size_t)~7;\n\n    bytes += html_memory_used(t->child);\n\n    t = t->next;\n  }\n\n  return (bytes);\n}\n\n\n//\n// 'htmlDebugStats()' - Display debug statistics for HTML tree memory use.\n//\n\nvoid\nhtmlDebugStats(const char *title,\t// I - Title\n               tree_t     *t)\t\t// I - Document root node\n{\n  const char\t*debug;\t\t\t/* HTMLDOC_DEBUG env var */\n\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) == NULL ||\n      (strstr(debug, \"all\") == NULL && strstr(debug, \"memory\") == NULL))\n    return;\n\n  progress_error(HD_ERROR_NONE, \"DEBUG: %s = %d kbytes\", title,\n                 (html_memory_used(t) + 1023) / 1024);\n}\n\n\n//\n// 'htmlFindFile()' - Find a file in the document.\n//\n\ntree_t *\t\t\t\t// O - Node for file\nhtmlFindFile(tree_t *doc,\t\t// I - Document pointer\n             uchar  *filename)\t\t// I - Filename\n{\n  tree_t\t*tree;\t\t\t// Current node\n  uchar\t\t*treename;\t\t// Filename from node\n\n\n  if (!filename || !doc)\n    return (NULL);\n\n  for (tree = doc; tree; tree = tree->next)\n    if ((treename = htmlGetVariable(tree, (uchar *)\"_HD_FILENAME\")) != NULL &&\n        !strcmp((char *)treename, (char *)filename))\n      return (tree);\n\n  return (NULL);\n}\n\n\n//\n// 'htmlFixLinks()' - Fix the external links in the document.\n//\n\nvoid\nhtmlFixLinks(tree_t *doc,\t\t// I - Top node\n             tree_t *tree,\t\t// I - Current node\n\t     uchar  *base)\t\t// I - Base directory/path\n{\n  uchar\t\t*href;\t\t\t// HREF attribute\n  char\t\tfull_href[1024];\t// Full HREF value\n  const char\t*debug;\t\t\t// HTMLDOC_DEBUG environment variable\n  static int\tshow_debug = -1;\t// Show debug messages?\n\n\n  if (show_debug < 0)\n  {\n    if ((debug = getenv(\"HTMLDOC_DEBUG\")) == NULL ||\n\t(strstr(debug, \"all\") == NULL && strstr(debug, \"links\") == NULL))\n      show_debug = 0;\n    else\n      show_debug = 1;\n\n    if (show_debug)\n      progress_error(HD_ERROR_NONE, \"DEBUG: Updating links in document.\");\n  }\n\n  while (tree)\n  {\n    if (tree->markup == MARKUP_A && base && base[0] &&\n        (href = htmlGetVariable(tree, (uchar *)\"HREF\")) != NULL)\n    {\n      // Check if the link needs to be localized...\n      if (href[0] != '#' && file_method((char *)href) == NULL &&\n          file_method((char *)base) != NULL &&\n\t  htmlFindFile(doc, (uchar *)file_basename((char *)href)) == NULL)\n      {\n        // Yes, localize it...\n\tif (href[0] == '/')\n\t{\n\t  // Absolute URL, just copy scheme, server, etc.\n\t  char *ptr;\t\t\t// Pointer into URL...\n\n\t  strlcpy(full_href, (char *)base, sizeof(full_href));\n\n          if (href[1] == '/')\n\t  {\n\t    // Just use scheme...\n\t    if ((ptr = strstr(full_href, \"//\")) != NULL)\n\t      *ptr ='\\0';\n\t  }\n\t  else if ((ptr = strstr(full_href, \"//\")) != NULL  &&\n\t           (ptr = strchr(ptr + 2, '/')) != NULL)\n\t    *ptr ='\\0';\n\n\t  strlcat(full_href, (char *)href, sizeof(full_href));\n\t}\n\telse if (!strncmp((char *)href, \"./\", 2))\n\t{\n\t  // Relative URL of the form \"./foo/bar\", append href sans\n\t  // \"./\" to base to form full href...\n\t  snprintf(full_href, sizeof(full_href), \"%s/%s\", base, href + 2);\n\t}\n\telse\n\t{\n\t  // Relative URL, append href to base to form full href...\n\t  snprintf(full_href, sizeof(full_href), \"%s/%s\", base, href);\n\t}\n\n        if (show_debug)\n          progress_error(HD_ERROR_NONE, \"DEBUG: Mapping \\\"%s\\\" to \\\"%s\\\"...\", href, full_href);\n\n\thtmlSetVariable(tree, (uchar *)\"_HD_FULL_HREF\", (uchar *)full_href);\n      }\n      else\n      {\n        // No, just mirror the link in the _HD_FULL_HREF attribute...\n\thtmlSetVariable(tree, (uchar *)\"_HD_FULL_HREF\", href);\n      }\n    }\n    else if (tree->markup == MARKUP_FILE)\n      base = htmlGetVariable(tree, (uchar *)\"_HD_BASE\");\n\n    if (tree->child)\n      htmlFixLinks(doc, tree->child, base);\n\n    tree = tree->next;\n  }\n}\n\n\n//\n// 'utf8_getc()' - Get a UTF-8 encoded character.\n//\n\nstatic int                              // O - Unicode equivalent\nutf8_getc(int  ch,                      // I - Initial character\n          FILE *fp)                     // I - File to read from\n{\n  int  ch2 = -1, ch3 = -1;              // Temporary characters\n\n\n  if ((ch & 0xe0) == 0xc0)\n  {\n   /*\n    * Two-byte sequence for 0x80 to 0x7ff...\n    */\n\n    ch  = (ch & 0x1f) << 6;\n    ch2 = getc(fp);\n\n    if ((ch2 & 0xc0) == 0x80)\n      ch |= ch2 & 0x3f;\n    else\n      goto bad_sequence;\n  }\n  else if ((ch & 0xf0) == 0xe0)\n  {\n   /*\n    * Three-byte sequence from 0x800 to 0xffff...\n    */\n\n    ch  = (ch & 0x0f) << 12;\n    ch2 = getc(fp);\n\n    if ((ch2 & 0xc0) == 0x80)\n      ch |= (ch2 & 0x3f) << 6;\n    else\n      goto bad_sequence;\n\n    ch3 = getc(fp);\n\n    if ((ch3 & 0xc0) == 0x80)\n      ch |= ch3 & 0x3f;\n    else\n      goto bad_sequence;\n  }\n  else if (ch & 0x80)\n    goto bad_sequence;\n\n  if (ch == 0xfeff)\n  {\n    // BOMs are invalid in UTF-8 text, but Microsoft insists on still using\n    // them...  Try reading another character...\n    //\n    // TODO: Emit a warning about this...\n    return (utf8_getc(getc(fp), fp));\n  }\n\n  return (htmlMapUnicode(ch));\n\n  bad_sequence:\n\n  if (ch3 >= 0)\n    progress_error(HD_ERROR_READ_ERROR, \"Bad UTF-8 character sequence %02X %02X %02X.\", ch, ch2, ch3);\n  else if (ch2 >= 0)\n    progress_error(HD_ERROR_READ_ERROR, \"Bad UTF-8 character sequence %02X %02X.\", ch, ch2);\n  else\n    progress_error(HD_ERROR_READ_ERROR, \"Bad UTF-8 character sequence %02X.\", ch);\n\n  return (0);\n}\n\n", "/*\n * Test program for HTML parsing routines for HTMLDOC, an HTML document\n * processing program.\n *\n * Copyright 2011-2017 by Michael R Sweet.\n * Copyright 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#define _HTMLDOC_CXX_\n#include \"htmldoc.h\"\n\n\nvoid\tprefs_load(void) { }\nvoid\tprefs_save(void) { }\n\nstatic void     show_tree(tree_t *t, int indent);\n\n\n/*\n * 'main()' - Main entry for test program.\n */\n\nint\t\t\t\t/* O - Exit status */\nmain(int  argc,\t\t\t/* I - Number of command-line arguments */\n     char *argv[])\t\t/* I - Command-line arguments */\n{\n  int\t\ti;\t\t/* Looping var */\n  FILE\t\t*fp;\t\t/* Input file */\n  tree_t\t*t,\t\t/* HTML markup tree */\n\t\t*doc,\t\t/* HTML document */\n\t\t*toc;\t\t/* Table of contents */\n  char\t\tbase[1024];\t/* Base directory */\n  int           tree = 0;       /* Show parsing tree */\n\n\n#ifdef DEBUG\n  printf(\"MARKUP_NONE=%d\\n\", MARKUP_NONE);\n  printf(\"MARKUP_COMMENT=%d\\n\", MARKUP_COMMENT);\n  printf(\"MARKUP_A=%d\\n\", MARKUP_A);\n  printf(\"MARKUP_ADDRESS=%d\\n\", MARKUP_ADDRESS);\n  printf(\"MARKUP_APPLET=%d\\n\", MARKUP_APPLET);\n  printf(\"MARKUP_AREA=%d\\n\", MARKUP_AREA);\n  printf(\"MARKUP_B=%d\\n\", MARKUP_B);\n  printf(\"MARKUP_BASE=%d\\n\", MARKUP_BASE);\n  printf(\"MARKUP_BASEFONT=%d\\n\", MARKUP_BASEFONT);\n  printf(\"MARKUP_BIG=%d\\n\", MARKUP_BIG);\n  printf(\"MARKUP_BLINK=%d\\n\", MARKUP_BLINK);\n  printf(\"MARKUP_BLOCKQUOTE=%d\\n\", MARKUP_BLOCKQUOTE);\n  printf(\"MARKUP_BODY=%d\\n\", MARKUP_BODY);\n  printf(\"MARKUP_BR=%d\\n\", MARKUP_BR);\n  printf(\"MARKUP_CAPTION=%d\\n\", MARKUP_CAPTION);\n  printf(\"MARKUP_CENTER=%d\\n\", MARKUP_CENTER);\n  printf(\"MARKUP_CITE=%d\\n\", MARKUP_CITE);\n  printf(\"MARKUP_CODE=%d\\n\", MARKUP_CODE);\n  printf(\"MARKUP_DD=%d\\n\", MARKUP_DD);\n  printf(\"MARKUP_DFN=%d\\n\", MARKUP_DFN);\n  printf(\"MARKUP_DIR=%d\\n\", MARKUP_DIR);\n  printf(\"MARKUP_DIV=%d\\n\", MARKUP_DIV);\n  printf(\"MARKUP_DL=%d\\n\", MARKUP_DL);\n  printf(\"MARKUP_DT=%d\\n\", MARKUP_DT);\n  printf(\"MARKUP_EM=%d\\n\", MARKUP_EM);\n  printf(\"MARKUP_EMBED=%d\\n\", MARKUP_EMBED);\n  printf(\"MARKUP_FONT=%d\\n\", MARKUP_FONT);\n  printf(\"MARKUP_FORM=%d\\n\", MARKUP_FORM);\n  printf(\"MARKUP_FRAME=%d\\n\", MARKUP_FRAME);\n  printf(\"MARKUP_FRAMESET=%d\\n\", MARKUP_FRAMESET);\n  printf(\"MARKUP_H1=%d\\n\", MARKUP_H1);\n  printf(\"MARKUP_H2=%d\\n\", MARKUP_H2);\n  printf(\"MARKUP_H3=%d\\n\", MARKUP_H3);\n  printf(\"MARKUP_H4=%d\\n\", MARKUP_H4);\n  printf(\"MARKUP_H5=%d\\n\", MARKUP_H5);\n  printf(\"MARKUP_H6=%d\\n\", MARKUP_H6);\n  printf(\"MARKUP_H7=%d\\n\", MARKUP_H7);\n  printf(\"MARKUP_HEAD=%d\\n\", MARKUP_HEAD);\n  printf(\"MARKUP_HR=%d\\n\", MARKUP_HR);\n  printf(\"MARKUP_HTML=%d\\n\", MARKUP_HTML);\n  printf(\"MARKUP_I=%d\\n\", MARKUP_I);\n  printf(\"MARKUP_IMG=%d\\n\", MARKUP_IMG);\n  printf(\"MARKUP_INPUT=%d\\n\", MARKUP_INPUT);\n  printf(\"MARKUP_ISINDEX=%d\\n\", MARKUP_ISINDEX);\n  printf(\"MARKUP_KBD=%d\\n\", MARKUP_KBD);\n  printf(\"MARKUP_LI=%d\\n\", MARKUP_LI);\n  printf(\"MARKUP_LINK=%d\\n\", MARKUP_LINK);\n  printf(\"MARKUP_MAP=%d\\n\", MARKUP_MAP);\n  printf(\"MARKUP_MENU=%d\\n\", MARKUP_MENU);\n  printf(\"MARKUP_META=%d\\n\", MARKUP_META);\n  printf(\"MARKUP_MULTICOL=%d\\n\", MARKUP_MULTICOL);\n  printf(\"MARKUP_NOBR=%d\\n\", MARKUP_NOBR);\n  printf(\"MARKUP_NOFRAMES=%d\\n\", MARKUP_NOFRAMES);\n  printf(\"MARKUP_OL=%d\\n\", MARKUP_OL);\n  printf(\"MARKUP_OPTION=%d\\n\", MARKUP_OPTION);\n  printf(\"MARKUP_P=%d\\n\", MARKUP_P);\n  printf(\"MARKUP_PRE=%d\\n\", MARKUP_PRE);\n  printf(\"MARKUP_S=%d\\n\", MARKUP_S);\n  printf(\"MARKUP_SAMP=%d\\n\", MARKUP_SAMP);\n  printf(\"MARKUP_SCRIPT=%d\\n\", MARKUP_SCRIPT);\n  printf(\"MARKUP_SELECT=%d\\n\", MARKUP_SELECT);\n  printf(\"MARKUP_SMALL=%d\\n\", MARKUP_SMALL);\n  printf(\"MARKUP_SPACER=%d\\n\", MARKUP_SPACER);\n  printf(\"MARKUP_STRIKE=%d\\n\", MARKUP_STRIKE);\n  printf(\"MARKUP_STRONG=%d\\n\", MARKUP_STRONG);\n  printf(\"MARKUP_STYLE=%d\\n\", MARKUP_STYLE);\n  printf(\"MARKUP_SUB=%d\\n\", MARKUP_SUB);\n  printf(\"MARKUP_SUP=%d\\n\", MARKUP_SUP);\n  printf(\"MARKUP_TABLE=%d\\n\", MARKUP_TABLE);\n  printf(\"MARKUP_TD=%d\\n\", MARKUP_TD);\n  printf(\"MARKUP_TEXTAREA=%d\\n\", MARKUP_TEXTAREA);\n  printf(\"MARKUP_TH=%d\\n\", MARKUP_TH);\n  printf(\"MARKUP_TITLE=%d\\n\", MARKUP_TITLE);\n  printf(\"MARKUP_TR=%d\\n\", MARKUP_TR);\n  printf(\"MARKUP_TT=%d\\n\", MARKUP_TT);\n  printf(\"MARKUP_U=%d\\n\", MARKUP_U);\n  printf(\"MARKUP_UL=%d\\n\", MARKUP_UL);\n  printf(\"MARKUP_VAR=%d\\n\", MARKUP_VAR);\n  printf(\"MARKUP_WBR=%d\\n\", MARKUP_WBR);\n#endif /* DEBUG */\n\n  _htmlData = \"..\";\n\n  if (argc < 2)\n  {\n    fputs(\"Usage: testhtml [--tree] filename.html\\n\", stderr);\n    return (1);\n  };\n\n  for (i = 1, doc = NULL; i < argc; i ++)\n  {\n    if (!strcmp(argv[i], \"--tree\"))\n      tree = 1;\n    else if (argv[i][0] == '-')\n    {\n      fprintf(stderr, \"Unknown option '%s'.\\n\", argv[i]);\n      fputs(\"Usage: testhtml [--tree] filename.html\\n\", stderr);\n      return (1);\n    }\n    else if ((fp = fopen(file_find(\"\", argv[i]), \"r\")) != NULL)\n    {\n      strlcpy(base, argv[i], sizeof(base));\n      if (strrchr(base, '/') != NULL)\n        *strrchr(base, '/') = '\\0';\n      else\n        base[0] = '\\0';\n\n      t = htmlReadFile(NULL, fp, base);\n      fclose(fp);\n\n      if (t != NULL)\n      {\n        if (doc == NULL)\n        {\n          doc = t;\n        }\n        else\n        {\n          doc->next = t;\n          t->prev   = doc;\n        }\n      }\n    }\n    else\n    {\n      fprintf(stderr, \"testhtml: Unable to open input file \\'%s\\'!\\n\", argv[i]);\n    }\n  }\n\n  if (doc != NULL)\n  {\n    toc = toc_build(doc);\n\n    if (tree)\n    {\n      show_tree(doc, 0);\n      puts(\"---- TABLE OF CONTENTS ----\");\n      show_tree(toc, 0);\n    }\n    else\n    {\n      htmlWriteFile(doc, stdout);\n      puts(\"---- TABLE OF CONTENTS ----\");\n      htmlWriteFile(toc, stdout);\n    }\n  }\n\n  return (doc == NULL);\n}\n\n\n/*\n * 'show_tree()' - Show the parsing tree...\n */\n\nstatic void\nshow_tree(tree_t *t,                    /* I - Parent node */\n          int    indent)                /* I - Indentation */\n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}\n\n\n#ifdef HAVE_LIBFLTK\nvoid\nGUI::progress(int        percent,\t// I - Percent complete\n              const char *text)\t\t// I - Text prompt\n{\n  (void)percent;\n  (void)text;\n}\n#endif /* HAVE_LIBFLTK */\n"], "fixing_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed crash bugs for books (Issue #412, Issue #414)\n- Fixed a number-up crash bug (Issue #413)\n- Fixed JPEG error handling (Issue #415)\n- Fixed crash bugs with bogus table attributes (Issue #416, Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed a crash bug with empty titles (Issue #425)\n- Fixed some issues reported by Coverity.\n- Removed the bundled libjpeg, libpng, and zlib.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * HTML parsing routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright 2011-2021 by Michael R Sweet.\n * Copyright 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include \"http.h\"\n#include <ctype.h>\n\n\n/*\n * Markup strings...\n */\n\nconst char\t*_htmlMarkups[] =\n\t\t{\n\t\t  \"\",\t\t/* MARKUP_NONE */\n\t\t  \"!--\",\t/* MARKUP_COMMENT */\n\t\t  \"!DOCTYPE\",\n\t\t  \"a\",\n\t\t  \"acronym\",\n\t\t  \"address\",\n\t\t  \"applet\",\n\t\t  \"area\",\n\t\t  \"b\",\n\t\t  \"base\",\n\t\t  \"basefont\",\n\t\t  \"big\",\n\t\t  \"blink\",\n\t\t  \"blockquote\",\n\t\t  \"body\",\n\t\t  \"br\",\n\t\t  \"caption\",\n\t\t  \"center\",\n\t\t  \"cite\",\n\t\t  \"code\",\n\t\t  \"col\",\n\t\t  \"colgroup\",\n\t\t  \"dd\",\n\t\t  \"del\",\n\t\t  \"dfn\",\n\t\t  \"dir\",\n\t\t  \"div\",\n\t\t  \"dl\",\n\t\t  \"dt\",\n\t\t  \"em\",\n\t\t  \"embed\",\n\t\t  \"font\",\n\t\t  \"form\",\n\t\t  \"frame\",\n\t\t  \"frameset\",\n\t\t  \"h1\",\n\t\t  \"h2\",\n\t\t  \"h3\",\n\t\t  \"h4\",\n\t\t  \"h5\",\n\t\t  \"h6\",\n\t\t  \"h7\",\n\t\t  \"h8\",\n\t\t  \"h9\",\n\t\t  \"h10\",\n\t\t  \"h11\",\n\t\t  \"h12\",\n\t\t  \"h13\",\n\t\t  \"h14\",\n\t\t  \"h15\",\n\t\t  \"head\",\n\t\t  \"hr\",\n\t\t  \"html\",\n\t\t  \"i\",\n\t\t  \"img\",\n\t\t  \"input\",\n\t\t  \"ins\",\n\t\t  \"isindex\",\n\t\t  \"kbd\",\n\t\t  \"li\",\n\t\t  \"link\",\n\t\t  \"map\",\n\t\t  \"menu\",\n\t\t  \"meta\",\n\t\t  \"multicol\",\n\t\t  \"nobr\",\n\t\t  \"noframes\",\n\t\t  \"ol\",\n\t\t  \"option\",\n\t\t  \"p\",\n\t\t  \"pre\",\n\t\t  \"s\",\n\t\t  \"samp\",\n\t\t  \"script\",\n\t\t  \"select\",\n\t\t  \"small\",\n\t\t  \"spacer\",\n\t\t  \"span\",\n\t\t  \"strike\",\n\t\t  \"strong\",\n\t\t  \"style\",\n\t\t  \"sub\",\n\t\t  \"sup\",\n\t\t  \"table\",\n\t\t  \"tbody\",\n\t\t  \"td\",\n\t\t  \"textarea\",\n\t\t  \"tfoot\",\n\t\t  \"th\",\n\t\t  \"thead\",\n\t\t  \"title\",\n\t\t  \"tr\",\n\t\t  \"tt\",\n\t\t  \"u\",\n\t\t  \"ul\",\n\t\t  \"var\",\n\t\t  \"wbr\"\n\t\t};\n\nconst char\t*_htmlCurrentFile = \"UNKNOWN\";\n\t\t\t\t\t/* Current file */\nconst char\t*_htmlData = HTML_DATA;\t/* Data directory */\nfloat\t\t_htmlPPI = 80.0f;\t/* Image resolution */\nint\t\t_htmlGrayscale = 0;\t/* Grayscale output? */\nuchar\t\t_htmlTextColor[255] =\t/* Default text color */\n\t\t{ 0 };\nfloat\t\t_htmlBrowserWidth = 680.0f;\n\t\t\t\t\t/* Browser width for pixel scaling */\nfloat\t\t_htmlSizes[8] =\t\t/* Point size for each HTML size */\n\t\t{ 6.0f, 8.0f, 9.0f, 11.0f, 14.0f, 17.0f, 20.0f, 24.0f };\nfloat\t\t_htmlSpacings[8] =\t/* Line height for each HTML size */\n\t\t{ 7.2f, 9.6f, 10.8f, 13.2f, 16.8f, 20.4f, 24.0f, 28.8f };\ntypeface_t\t_htmlBodyFont = TYPE_TIMES,\n\t\t_htmlHeadingFont = TYPE_HELVETICA;\n\nint\t\t_htmlInitialized = 0;\t/* Initialized glyphs yet? */\nchar\t\t_htmlCharSet[256] = \"iso-8859-1\";\n\t\t\t\t\t/* Character set name */\nint\t\t_htmlWidthsLoaded[TYPE_MAX][STYLE_MAX] =\n\t\t{\t\t\t/* Have the widths been loaded? */\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 },\n\t\t  { 0, 0, 0, 0 }\n\t\t};\nshort\t\t_htmlWidths[TYPE_MAX][STYLE_MAX][256];\n\t\t\t\t\t/* Character widths of fonts */\nshort\t\t_htmlWidthsAll[TYPE_MAX][STYLE_MAX][65536];\n                                        /* Unicode widths of fonts */\nint\t\t_htmlUnicode[256];\t/* Character to Unicode mapping */\nuchar           _htmlCharacters[65536]; /* Unicode to character mapping */\nint             _htmlUTF8 = 0;          /* Doing UTF-8? */\nconst char\t*_htmlGlyphsAll[65536];\t/* Character glyphs for Unicode */\nconst char\t*_htmlGlyphs[256];\t/* Character glyphs for charset */\nint\t\t_htmlNumSorted = 0;\t/* Number of sorted glyphs */\nconst char\t*_htmlSorted[256];\t/* Sorted character glyphs for charset */\nuchar\t\t_htmlSortedChars[256];\t/* Sorted character indices */\nconst char\t*_htmlFonts[TYPE_MAX][STYLE_MAX] =\n\t\t{\n\t\t  {\n\t\t    \"Courier\",\n\t\t    \"Courier-Bold\",\n\t\t    \"Courier-Oblique\",\n\t\t    \"Courier-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Times-Roman\",\n\t\t    \"Times-Bold\",\n\t\t    \"Times-Italic\",\n\t\t    \"Times-BoldItalic\"\n\t\t  },\n\t\t  {\n\t\t    \"Helvetica\",\n\t\t    \"Helvetica-Bold\",\n\t\t    \"Helvetica-Oblique\",\n\t\t    \"Helvetica-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Monospace\",\n\t\t    \"Monospace-Bold\",\n\t\t    \"Monospace-Oblique\",\n\t\t    \"Monospace-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Serif-Roman\",\n\t\t    \"Serif-Bold\",\n\t\t    \"Serif-Oblique\",\n\t\t    \"Serif-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Sans\",\n\t\t    \"Sans-Bold\",\n\t\t    \"Sans-Oblique\",\n\t\t    \"Sans-BoldOblique\"\n\t\t  },\n\t\t  {\n\t\t    \"Symbol\",\n\t\t    \"Symbol\",\n\t\t    \"Symbol\",\n\t\t    \"Symbol\"\n\t\t  },\n\t\t  {\n\t\t    \"Dingbats\",\n\t\t    \"Dingbats\",\n\t\t    \"Dingbats\",\n\t\t    \"Dingbats\"\n\t\t  }\n\t\t};\nint\t\t_htmlStandardFonts[TYPE_MAX] =\n\t\t{\n\t\t  1,\t// Courier\n\t\t  1,\t// Times\n\t\t  1,\t// Helvetica\n\t\t  0,\t// Monospace\n\t\t  0,\t// Sans\n\t\t  0,\t// Serif\n\t\t  1,\t// Symbol\n\t\t  1\t// Dingbats\n\t\t};\n\n\n/*\n * Local functions.\n */\n\nextern \"C\" {\ntypedef int\t(*compare_func_t)(const void *, const void *);\n}\n\nstatic int\twrite_file(tree_t *t, FILE *fp, int col);\nstatic int\tcompare_variables(var_t *v0, var_t *v1);\nstatic int\tcompare_markups(uchar **m0, uchar **m1);\nstatic void\tdelete_node(tree_t *t);\nstatic void\tinsert_space(tree_t *parent, tree_t *t);\nstatic int\tparse_markup(tree_t *t, FILE *fp, int *linenum);\nstatic int\tparse_variable(tree_t *t, FILE *fp, int *linenum);\nstatic int\tcompute_size(tree_t *t);\nstatic int\tcompute_color(tree_t *t, uchar *color);\nstatic int\tget_alignment(tree_t *t);\nstatic const char *fix_filename(char *path, char *base);\nstatic int      utf8_getc(int ch, FILE *fp);\n\n#define issuper(x)\t((x) == MARKUP_CENTER || (x) == MARKUP_DIV ||\\\n\t\t\t (x) == MARKUP_BLOCKQUOTE)\n#define isblock(x)\t((x) == MARKUP_ADDRESS || \\\n\t\t\t (x) == MARKUP_P || (x) == MARKUP_PRE ||\\\n\t\t\t ((x) >= MARKUP_H1 && (x) <= MARKUP_H6) ||\\\n\t\t\t (x) == MARKUP_HR || (x) == MARKUP_TABLE)\n#define islist(x)\t((x) == MARKUP_DL || (x) == MARKUP_OL ||\\\n\t\t\t (x) == MARKUP_UL || (x) == MARKUP_DIR ||\\\n\t\t\t (x) == MARKUP_MENU)\n#define islentry(x)\t((x) == MARKUP_LI || (x) == MARKUP_DD ||\\\n\t\t\t (x) == MARKUP_DT)\n#define istable(x)\t((x) == MARKUP_TBODY || (x) == MARKUP_THEAD ||\\\n\t\t\t (x) == MARKUP_TFOOT || (x) == MARKUP_TR)\n#define istentry(x)\t((x) == MARKUP_TD || (x) == MARKUP_TH)\n\n#ifdef DEBUG\nstatic uchar\tindent[255] = \"\";\n#endif /* DEBUG */\n\n\n/*\n * 'htmlReadFile()' - Read a file for HTML markup codes.\n */\n\ntree_t *\t\t\t\t// O - Pointer to top of file tree\nhtmlReadFile(tree_t     *parent,\t// I - Parent tree entry\n             FILE       *fp,\t\t// I - File pointer\n\t     const char *base)\t\t// I - Base directory for file\n{\n  int\t\tch;\t\t\t// Character from file\n  uchar\t\t*ptr,\t\t\t// Pointer in string\n\t\tentity[16],\t\t// Character entity name (&#nnn; or &name;)\n\t\t*eptr;\t\t\t// Pointer in entity string\n  tree_t\t*tree,\t\t\t// \"top\" of this tree\n\t\t*t,\t\t\t// New tree entry\n\t\t*prev,\t\t\t// Previous tree entry\n\t\t*temp;\t\t\t// Temporary looping var\n  int\t\tdescend;\t\t// Descend into node?\n  FILE\t\t*embed;\t\t\t// File pointer for EMBED\n  char\t\tnewbase[1024];\t\t// New base directory for EMBED\n  uchar\t\t*filename,\t\t// Filename for EMBED tag\n\t\t*face,\t\t\t// Typeface for FONT tag\n\t\t*color,\t\t\t// Color for FONT tag\n\t\t*size,\t\t\t// Size for FONT tag\n\t\t*type,\t\t\t// Type for EMBED tag\n\t\t*span;\t\t\t// Value for SPAN tag\n  int\t\tsizeval;\t\t// Size value from FONT tag\n  int\t\tlinenum;\t\t// Line number in file\n  static uchar\ts[10240];\t\t// String from file\n  static int\thave_whitespace = 0;\t// Non-zero if there was leading whitespace\n\n\n  DEBUG_printf((\"htmlReadFile(parent=%p, fp=%p, base=\\\"%s\\\")\\n\",\n                (void *)parent, (void *)fp, base ? base : \"(null)\"));\n\n#ifdef DEBUG\n  indent[0] = '\\0';\n#endif // DEBUG\n\n /*\n  * Start off with no previous tree entry...\n  */\n\n  prev = NULL;\n  tree = NULL;\n\n /*\n  * Parse data until we hit end-of-file...\n  */\n\n  linenum = 1;\n\n  while ((ch = getc(fp)) != EOF)\n  {\n   /*\n    * Ignore leading whitespace...\n    */\n\n    if (parent == NULL || !parent->preformatted)\n    {\n      while (isspace(ch))\n      {\n\tif (ch == '\\n')\n\t  linenum ++;\n\n        have_whitespace = 1;\n        ch              = getc(fp);\n      }\n\n      if (ch == EOF)\n        break;\n    }\n\n   /*\n    * Allocate a new tree entry - use calloc() to get zeroed data...\n    */\n\n    t = (tree_t *)calloc(sizeof(tree_t), 1);\n    if (t == NULL)\n    {\n#ifndef DEBUG\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for HTML tree node!\");\n#endif /* !DEBUG */\n      break;\n    }\n\n   /*\n    * Set/copy font characteristics...\n    */\n\n    if (parent == NULL)\n    {\n      t->halignment   = ALIGN_LEFT;\n      t->valignment   = ALIGN_BOTTOM;\n      t->typeface     = _htmlBodyFont;\n      t->size         = SIZE_P;\n\n      compute_color(t, _htmlTextColor);\n    }\n    else\n    {\n      t->link          = parent->link;\n      t->halignment    = parent->halignment;\n      t->valignment    = parent->valignment;\n      t->typeface      = parent->typeface;\n      t->size          = parent->size;\n      t->style         = parent->style;\n      t->superscript   = parent->superscript;\n      t->subscript     = parent->subscript;\n      t->preformatted  = parent->preformatted;\n      t->indent        = parent->indent;\n      t->red           = parent->red;\n      t->green         = parent->green;\n      t->blue          = parent->blue;\n      t->underline     = parent->underline;\n      t->strikethrough = parent->strikethrough;\n    }\n\n   /*\n    * See what the character was...\n    */\n\n    if (ch == '<')\n    {\n     /*\n      * Markup char; grab the next char to see if this is a /...\n      */\n\n      ch = getc(fp);\n\n      if (isspace(ch) || ch == '=' || ch == '<')\n      {\n       /*\n        * Sigh...  \"<\" followed by anything but an element name is\n\t* invalid HTML, but so many people have asked for this to\n\t* be supported that we have added this hack...\n\t*/\n\n\tprogress_error(HD_ERROR_HTML_ERROR, \"Unquoted < on line %d of %s.\",\n\t               linenum, _htmlCurrentFile);\n\n\tif (ch == '\\n')\n\t  linenum ++;\n\n\tptr = s;\n\tif (have_whitespace)\n\t{\n          *ptr++ = ' ';\n\t  have_whitespace = 0;\n\t}\n\n        *ptr++ = '<';\n\tif (ch == '=')\n\t  *ptr++ = '=';\n\telse if (ch == '<')\n\t  ungetc(ch, fp);\n\telse\n\t  have_whitespace = 1;\n\n\t*ptr++ = '\\0';\n\n\tt->markup = MARKUP_NONE;\n\tt->data   = (uchar *)strdup((char *)s);\n      }\n      else\n      {\n       /*\n        * Start of a markup...\n\t*/\n\n\tif (ch != '/')\n          ungetc(ch, fp);\n\n\tif (parse_markup(t, fp, &linenum) == MARKUP_ERROR)\n\t{\n#ifndef DEBUG\n          progress_error(HD_ERROR_READ_ERROR,\n                         \"Unable to parse HTML element on line %d of %s!\",\n\t\t\t linenum, _htmlCurrentFile);\n#endif /* !DEBUG */\n\n          delete_node(t);\n          break;\n\t}\n\n       /*\n\t* Eliminate extra whitespace...\n\t*/\n\n\tif (issuper(t->markup) || isblock(t->markup) ||\n            islist(t->markup) || islentry(t->markup) ||\n            istable(t->markup) || istentry(t->markup) ||\n\t    t->markup == MARKUP_TITLE)\n          have_whitespace = 0;\n\n       /*\n\t* If this is the matching close mark, or if we are starting the same\n\t* markup, or if we've completed a list, we're done!\n\t*/\n\n\tif (ch == '/')\n\t{\n\t /*\n          * Close markup; find matching markup...\n          */\n\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (temp->markup == t->markup)\n              break;\n\t    else if (temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (t->markup == MARKUP_BODY || t->markup == MARKUP_HEAD)\n\t{\n\t /*\n          * Make sure we aren't inside an existing HEAD or BODY...\n\t  */\n\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (temp->markup == MARKUP_BODY || temp->markup == MARKUP_HEAD)\n              break;\n\t    else if (temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (t->markup == MARKUP_EMBED)\n\t{\n\t /*\n          * Close any text blocks...\n\t  */\n\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (isblock(temp->markup) || islentry(temp->markup))\n              break;\n\t    else if (istentry(temp->markup) || islist(temp->markup) ||\n\t             issuper(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (issuper(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n\t    if (istentry(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (islist(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (isblock(temp->markup))\n\t      break;\n\t    else if (islentry(temp->markup) || istentry(temp->markup) ||\n\t             issuper(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (islentry(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (islentry(temp->markup))\n              break;\n\t    else if (islist(temp->markup) || issuper(temp->markup) ||\n\t             istentry(temp->markup) || temp->markup == MARKUP_EMBED)\n            {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (isblock(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (isblock(temp->markup))\n              break;\n\t    else if (istentry(temp->markup) || islist(temp->markup) ||\n\t             islentry(temp->markup) ||\n\t             issuper(temp->markup) || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n\t      break;\n\t    }\n\t}\n\telse if (t->markup == MARKUP_THEAD || t->markup == MARKUP_TBODY || t->markup == MARKUP_TFOOT)\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n\t    if (temp->markup == MARKUP_TABLE || temp->markup == MARKUP_EMBED)\n\t    {\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse if (istentry(t->markup))\n\t{\n          for (temp = parent; temp != NULL; temp = temp->parent)\n            if (istentry(temp->markup))\n              break;\n\t    else if (temp->markup == MARKUP_TABLE || istable(temp->markup) ||\n\t             temp->markup == MARKUP_EMBED)\n\t    {\n\t      if (temp->markup != MARKUP_TR)\n\t      {\n\t        // Strictly speaking, this is an error - TD/TH can only\n\t\t// be found under TR, but web browsers automatically\n\t\t// inject a TR...\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"No TR element before %s element on line %d of %s.\",\n\t\t\t       _htmlMarkups[t->markup], linenum,\n\t\t\t       _htmlCurrentFile);\n\n                parent = htmlAddTree(temp, MARKUP_TR, NULL);\n\t\tprev   = NULL;\n\t\tDEBUG_printf((\"%str (inserted) under %s, line %d\\n\", indent,\n\t\t              _htmlMarkups[temp->markup], linenum));\n\t      }\n\n\t      temp = NULL;\n              break;\n\t    }\n\t}\n\telse\n          temp = NULL;\n\n\tif (temp != NULL)\n\t{\n          DEBUG_printf((\"%s>>>> Auto-ascend <<<\\n\", indent));\n\n          if (ch != '/' &&\n\t      temp->markup != MARKUP_BODY &&\n\t      temp->markup != MARKUP_DD &&\n\t      temp->markup != MARKUP_DT &&\n\t      temp->markup != MARKUP_HEAD &&\n\t      temp->markup != MARKUP_HTML &&\n\t      temp->markup != MARKUP_LI &&\n\t      temp->markup != MARKUP_OPTION &&\n\t      temp->markup != MARKUP_P &&\n\t      temp->markup != MARKUP_TBODY &&\n\t      temp->markup != MARKUP_TD &&\n\t      temp->markup != MARKUP_TFOOT &&\n\t      temp->markup != MARKUP_TH &&\n\t      temp->markup != MARKUP_THEAD &&\n\t      temp->markup != MARKUP_TR)\n\t  {\n\t    // Log this condition as an error...\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"No /%s element before %s element on line %d of %s.\",\n\t                   _htmlMarkups[temp->markup],\n\t\t\t   _htmlMarkups[t->markup], linenum, _htmlCurrentFile);\n\t    DEBUG_printf((\"%sNo /%s element before %s element on line %d.\\n\",\n\t                  indent, _htmlMarkups[temp->markup],\n\t\t\t  _htmlMarkups[t->markup], linenum));\n\t  }\n\n#ifdef DEBUG\n          for (tree_t *p = parent;\n\t       p && p != temp && indent[0];\n\t       p = p->parent)\n\t    indent[strlen((char *)indent) - 4] = '\\0';\n\n          if (indent[0])\n            indent[strlen((char *)indent) - 4] = '\\0';\n#endif // DEBUG\n\n          // Safety check; should never happen, since MARKUP_FILE is\n\t  // the root node created by the caller...\n          if (temp->parent)\n\t  {\n\t    parent = temp->parent;\n            prev   = parent->last_child;\n\t  }\n\t  else\n\t  {\n\t    for (prev = temp; prev->next; prev = prev->next);\n\t    parent = NULL;\n\t  }\n\n          if (ch == '/')\n\t  {\n\t    // Closing element, so delete this node...\n            delete_node(t);\n\t    continue;\n\t  }\n\t  else\n\t  {\n\t    // Reparent the node...\n\t    if (parent == NULL)\n\t    {\n\t      t->halignment   = ALIGN_LEFT;\n\t      t->valignment   = ALIGN_BOTTOM;\n\t      t->typeface     = _htmlBodyFont;\n\t      t->size         = SIZE_P;\n\n\t      compute_color(t, _htmlTextColor);\n\t    }\n\t    else\n\t    {\n\t      t->link          = parent->link;\n\t      t->halignment    = parent->halignment;\n\t      t->valignment    = parent->valignment;\n\t      t->typeface      = parent->typeface;\n\t      t->size          = parent->size;\n\t      t->style         = parent->style;\n\t      t->superscript   = parent->superscript;\n\t      t->subscript     = parent->subscript;\n\t      t->preformatted  = parent->preformatted;\n\t      t->indent        = parent->indent;\n\t      t->red           = parent->red;\n\t      t->green         = parent->green;\n\t      t->blue          = parent->blue;\n\t      t->underline     = parent->underline;\n\t      t->strikethrough = parent->strikethrough;\n\t    }\n\n          }\n\t}\n\telse if (ch == '/')\n\t{\n\t  // Log this condition as an error...\n\t  if (t->markup != MARKUP_UNKNOWN &&\n\t      t->markup != MARKUP_COMMENT)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Dangling /%s element on line %d of %s.\",\n\t\t\t   _htmlMarkups[t->markup], linenum, _htmlCurrentFile);\n\t    DEBUG_printf((\"%sDangling /%s element on line %d.\\n\",\n\t\t\t  indent, _htmlMarkups[t->markup], linenum));\n          }\n\n\t  delete_node(t);\n\t  continue;\n\t}\n      }\n    }\n    else if (t->preformatted)\n    {\n     /*\n      * Read a pre-formatted string into the current tree entry...\n      */\n\n      ptr = s;\n      while (ch != '<' && ch != EOF && ptr < (s + sizeof(s) - 1))\n      {\n        if (ch == '&')\n        {\n\t  // Possibly a character entity...\n\t  eptr = entity;\n\t  while (eptr < (entity + sizeof(entity) - 1) &&\n\t         (ch = getc(fp)) != EOF)\n\t    if (!isalnum(ch) && ch != '#')\n\t      break;\n\t    else\n\t      *eptr++ = (uchar)ch;\n\n          if (ch != ';')\n\t  {\n\t    ungetc(ch, fp);\n\t    ch = 0;\n\t  }\n\n          *eptr = '\\0';\n          if (!ch)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                   linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n\t  }\n\t  else if ((ch = iso8859(entity)) == 0)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                   entity, linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = ';';\n\t  }\n\t  else\n\t    *ptr++ = (uchar)ch;\n        }\n        else if ((ch & 0x80) && _htmlUTF8)\n        {\n          // Collect UTF-8 value...\n          ch = utf8_getc(ch, fp);\n\n          if (ch)\n            *ptr++ = (uchar)ch;\n        }\n\telse if (ch != 0 && ch != '\\r')\n\t{\n          *ptr++ = (uchar)ch;\n\n          if (ch == '\\n')\n\t  {\n\t    linenum ++;\n            break;\n\t  }\n\t}\n\n        ch = getc(fp);\n      }\n\n      *ptr = '\\0';\n\n      if (ch == '<')\n        ungetc(ch, fp);\n\n      t->markup = MARKUP_NONE;\n      t->data   = (uchar *)strdup((char *)s);\n\n      DEBUG_printf((\"%sfragment \\\"%s\\\", line %d\\n\", indent, s, linenum));\n    }\n    else\n    {\n     /*\n      * Read the next string fragment...\n      */\n\n      ptr = s;\n      if (have_whitespace)\n      {\n        *ptr++ = ' ';\n\thave_whitespace = 0;\n      }\n\n      while (!isspace(ch) && ch != '<' && ch != EOF && ptr < (s + sizeof(s) - 1))\n      {\n        if (ch == '&')\n        {\n\t  // Possibly a character entity...\n\t  eptr = entity;\n\t  while (eptr < (entity + sizeof(entity) - 1) &&\n\t         (ch = getc(fp)) != EOF)\n\t    if (!isalnum(ch) && ch != '#')\n\t      break;\n\t    else\n\t      *eptr++ = (uchar)ch;\n\n          *eptr = '\\0';\n\n          if (ch != ';')\n\t  {\n\t    ungetc(ch, fp);\n\t    ch = 0;\n\t  }\n\n          if (!ch)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                   linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n\t  }\n\t  else if ((ch = iso8859(entity)) == 0)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                   entity, linenum, _htmlCurrentFile);\n\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = '&';\n            strlcpy((char *)ptr, (char *)entity, sizeof(s) - (size_t)(ptr - s));\n\t    ptr += strlen((char *)ptr);\n            if (ptr < (s + sizeof(s) - 1))\n\t      *ptr++ = ';';\n\t  }\n\t  else\n\t    *ptr++ = (uchar)ch;\n        }\n        else\n        {\n          if ((ch & 0x80) && _htmlUTF8)\n          {\n            // Collect UTF-8 value...\n            ch = utf8_getc(ch, fp);\n          }\n\n          if (ch)\n            *ptr++ = (uchar)ch;\n        }\n\n\tif ((_htmlUTF8 && ch == _htmlCharacters[173]) || (!_htmlUTF8 && ch == 173))\n\t  break;\n\n        ch = getc(fp);\n      }\n\n      if (ch == '\\n')\n\tlinenum ++;\n\n      if (isspace(ch))\n        have_whitespace = 1;\n\n      *ptr = '\\0';\n\n      if (ch == '<')\n        ungetc(ch, fp);\n\n      t->markup = MARKUP_NONE;\n      t->data   = (uchar *)strdup((char *)s);\n\n      DEBUG_printf((\"%sfragment \\\"%s\\\" (len=%d), line %d\\n\", indent, s,\n                    (int)(ptr - s), linenum));\n    }\n\n   /*\n    * If the parent tree pointer is not null and this is the first\n    * entry we've read, set the child pointer...\n    */\n\n    DEBUG_printf((\"%sADDING %s node to %s parent!\\n\", indent,\n                  _htmlMarkups[t->markup],\n\t\t  parent ? _htmlMarkups[parent->markup] : \"ROOT\"));\n    if (parent != NULL && prev == NULL)\n      parent->child = t;\n\n    if (parent != NULL)\n      parent->last_child = t;\n\n   /*\n    * Do the prev/next links...\n    */\n\n    t->parent = parent;\n    t->prev   = prev;\n    if (prev != NULL)\n      prev->next = t;\n\n    if (tree == NULL)\n      tree = t;\n\n    prev = t;\n\n   /*\n    * Do markup-specific stuff...\n    */\n\n    descend = 0;\n\n    switch (t->markup)\n    {\n      case MARKUP_BODY :\n         /*\n\t  * Update the text color as necessary...\n\t  */\n\n          if ((color = htmlGetVariable(t, (uchar *)\"TEXT\")) != NULL)\n            compute_color(t, color);\n\t  else\n            compute_color(t, _htmlTextColor);\n\n          if ((color = htmlGetVariable(t, (uchar *)\"BGCOLOR\")) != NULL &&\n\t      !BodyColor[0])\n\t    strlcpy(BodyColor, (char *)color, sizeof(BodyColor));\n\n          // Update the background image as necessary...\n          if ((filename = htmlGetVariable(t, (uchar *)\"BACKGROUND\")) != NULL)\n\t    htmlSetVariable(t, (uchar *)\"BACKGROUND\",\n\t                    (uchar *)fix_filename((char *)filename,\n\t\t\t                          (char *)base));\n\n          descend = 1;\n          break;\n\n      case MARKUP_IMG :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this image...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          // Get the image alignment...\n          t->valignment = ALIGN_BOTTOM;\n          get_alignment(t);\n\n          // Update the image source as necessary...\n          if ((filename = htmlGetVariable(t, (uchar *)\"SRC\")) != NULL)\n\t    htmlSetVariable(t, (uchar *)\"REALSRC\",\n\t                    (uchar *)fix_filename((char *)filename,\n\t\t\t                          (char *)base));\n\n      case MARKUP_BR :\n      case MARKUP_NONE :\n      case MARKUP_SPACER :\n\t /*\n\t  * Figure out the width & height of this markup...\n\t  */\n\n          compute_size(t);\n\t  break;\n\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n          get_alignment(t);\n\n          t->typeface      = _htmlHeadingFont;\n          t->subscript     = 0;\n          t->superscript   = 0;\n          t->strikethrough = 0;\n          t->preformatted  = 0;\n\n\t  if (t->markup > MARKUP_H6)\n          {\n\t    t->size  = SIZE_H7;\n            t->style = STYLE_ITALIC;\n\t  }\n\t  else\n\t  {\n            t->size  = (unsigned)(SIZE_H1 - t->markup + MARKUP_H1);\n            t->style = STYLE_BOLD;\n\t  }\n\n          descend = 1;\n          break;\n\n      case MARKUP_P :\n          get_alignment(t);\n\n          t->typeface      = _htmlBodyFont;\n          t->size          = SIZE_P;\n          t->style         = STYLE_NORMAL;\n          t->subscript     = 0;\n          t->superscript   = 0;\n          t->strikethrough = 0;\n          t->preformatted  = 0;\n\n          descend = 1;\n          break;\n\n      case MARKUP_PRE :\n          t->typeface      = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_MONOSPACE\n\t                                                     : TYPE_COURIER;\n          t->size          = SIZE_PRE;\n          t->style         = STYLE_NORMAL;\n          t->subscript     = 0;\n          t->superscript   = 0;\n          t->strikethrough = 0;\n          t->preformatted  = 1;\n\n          descend = 1;\n          break;\n\n      case MARKUP_BLOCKQUOTE :\n      case MARKUP_DIR :\n      case MARKUP_MENU :\n      case MARKUP_UL :\n      case MARKUP_OL :\n      case MARKUP_DL :\n          t->indent ++;\n\n          descend = 1;\n          break;\n\n      case MARKUP_DIV :\n          get_alignment(t);\n\n          descend = 1;\n          break;\n\n      case MARKUP_HR :\n          t->halignment = ALIGN_CENTER;\n          get_alignment(t);\n          break;\n\n      case MARKUP_DOCTYPE :\n      case MARKUP_AREA :\n      case MARKUP_COMMENT :\n      case MARKUP_INPUT :\n      case MARKUP_ISINDEX :\n      case MARKUP_LINK :\n      case MARKUP_META :\n      case MARKUP_WBR :\n      case MARKUP_COL :\n          break;\n\n      case MARKUP_EMBED :\n          if ((type = htmlGetVariable(t, (uchar *)\"TYPE\")) != NULL &&\n\t      strncasecmp((const char *)type, \"text/html\", 9) != 0)\n\t    break;\n\n          if ((filename = htmlGetVariable(t, (uchar *)\"SRC\")) != NULL)\n\t  {\n\t    const char *save_name = _htmlCurrentFile;\n\n\t    filename = (uchar *)fix_filename((char *)filename,\n\t                                     (char *)base);\n\n            if ((embed = fopen((char *)filename, \"r\")) != NULL)\n            {\n\t      strlcpy(newbase, file_directory((char *)filename), sizeof(newbase));\n\n              _htmlCurrentFile = (char *)filename;\n              htmlReadFile(t, embed, newbase);\n              fclose(embed);\n\t      _htmlCurrentFile = save_name;\n            }\n#ifndef DEBUG\n\t    else\n\t      progress_error(HD_ERROR_FILE_NOT_FOUND,\n                             \"Unable to embed \\\"%s\\\" - %s\", filename,\n\t                     strerror(errno));\n#endif /* !DEBUG */\n\t  }\n          break;\n\n      case MARKUP_TH :\n          if (htmlGetVariable(t->parent, (uchar *)\"ALIGN\") != NULL)\n\t    t->halignment = t->parent->halignment;\n\t  else\n            t->halignment = ALIGN_CENTER;\n\n          if (htmlGetVariable(t->parent, (uchar *)\"VALIGN\") != NULL)\n\t    t->valignment = t->parent->valignment;\n\t  else\n            t->valignment = ALIGN_MIDDLE;\n\n          get_alignment(t);\n\n          t->style = STYLE_BOLD;\n\n          descend = 1;\n          break;\n\n      case MARKUP_TD :\n          if (htmlGetVariable(t->parent, (uchar *)\"ALIGN\") != NULL)\n\t    t->halignment = t->parent->halignment;\n\t  else\n            t->halignment = ALIGN_LEFT;\n\n          if (htmlGetVariable(t->parent, (uchar *)\"VALIGN\") != NULL)\n\t    t->valignment = t->parent->valignment;\n\t  else\n            t->valignment = ALIGN_MIDDLE;\n\n\t  get_alignment(t);\n\n          t->style = STYLE_NORMAL;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SPAN :\n          // Pull style data, if present...\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this element...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          get_alignment(t);\n\n          if ((color = htmlGetStyle(t, (uchar *)\"color:\")) != NULL)\n            compute_color(t, color);\n\n          if ((face = htmlGetStyle(t, (uchar *)\"font-family:\")) != NULL)\n          {\n\t    char\tfont[255],\t// Font name\n\t\t\t*fontptr;\t// Pointer into font name\n\n            for (ptr = face; *ptr;)\n\t    {\n\t      while (isspace(*ptr) || *ptr == ',')\n\t        ptr ++;\n\n              if (!*ptr)\n\t        break;\n\n\t      for (fontptr = font; *ptr && *ptr != ',' && !isspace(*ptr); ptr ++)\n\t        if (fontptr < (font + sizeof(font) - 1))\n\t\t  *fontptr++ = (char)*ptr;\n\n              *fontptr = '\\0';\n\n              if (!strcasecmp(font, \"serif\"))\n\t      {\n        \tt->typeface = TYPE_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"sans-serif\") ||\n\t               !strcasecmp(font, \"sans\"))\n\t      {\n        \tt->typeface = TYPE_SANS_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"monospace\"))\n\t      {\n        \tt->typeface = TYPE_MONOSPACE;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"arial\") ||\n\t               !strcasecmp(font, \"helvetica\"))\n              {\n        \tt->typeface = TYPE_HELVETICA;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"times\"))\n\t      {\n        \tt->typeface = TYPE_TIMES;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"courier\"))\n\t      {\n        \tt->typeface = TYPE_COURIER;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"symbol\"))\n\t      {\n        \tt->typeface = TYPE_SYMBOL;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"dingbat\"))\n\t      {\n        \tt->typeface = TYPE_DINGBATS;\n\t\tbreak;\n\t      }\n\t    }\n          }\n\n          if ((size = htmlGetStyle(t, (uchar *)\"font-size:\")) != NULL)\n          {\n            // Find the closest size to the fixed sizes...\n            unsigned i;\n            double fontsize = atof((char *)size);\n\n            for (i = 0; i < 7; i ++)\n              if (fontsize <= _htmlSizes[i])\n                break;\n\n\t    t->size = i;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"font-style:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"normal\"))\n              t->style &= ~STYLE_ITALIC;\n            else if (!strcmp((char *)span, \"italic\") || !strcmp((char *)span, \"oblique\"))\n              t->style |= STYLE_ITALIC;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"font-weight:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"bold\") || !strcmp((char *)span, \"bolder\") || !strcmp((char *)span, \"700\") || !strcmp((char *)span, \"800\") || !strcmp((char *)span, \"900\"))\n              t->style |= STYLE_BOLD;\n            else if (strcmp((char *)span, \"inherit\"))\n              t->style &= ~STYLE_BOLD;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"text-decoration:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"underline\"))\n              t->underline = 1;\n            else if (!strcmp((char *)span, \"line-through\"))\n              t->strikethrough = 1;\n            else if (strcmp((char *)span, \"inherit\"))\n              t->underline = t->strikethrough = 0;\n          }\n\n          if ((span = htmlGetStyle(t, (uchar *)\"vertical-align:\")) != NULL)\n          {\n            if (!strcmp((char *)span, \"sub\"))\n              t->subscript = 1;\n            else if (!strcmp((char *)span, \"super\"))\n              t->superscript = 1;\n            else if (strcmp((char *)span, \"inherit\"))\n              t->subscript = t->superscript = 0;\n          }\n\n          descend = 1;\n          break;\n\n      case MARKUP_FONT :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this element...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          if ((face = htmlGetVariable(t, (uchar *)\"FACE\")) != NULL)\n          {\n\t    char\tfont[255],\t// Font name\n\t\t\t*fontptr;\t// Pointer into font name\n\n\n            for (ptr = face; *ptr;)\n\t    {\n\t      while (isspace(*ptr) || *ptr == ',')\n\t        ptr ++;\n\n              if (!*ptr)\n\t        break;\n\n\t      for (fontptr = font; *ptr && *ptr != ',' && !isspace(*ptr); ptr ++)\n\t        if (fontptr < (font + sizeof(font) - 1))\n\t\t  *fontptr++ = (char)*ptr;\n\n              *fontptr = '\\0';\n\n              if (!strcasecmp(font, \"serif\"))\n\t      {\n        \tt->typeface = TYPE_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"sans-serif\") ||\n\t               !strcasecmp(font, \"sans\"))\n\t      {\n        \tt->typeface = TYPE_SANS_SERIF;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"mono\") || !strcasecmp(font, \"monospace\"))\n\t      {\n        \tt->typeface = TYPE_MONOSPACE;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"arial\") ||\n\t               !strcasecmp(font, \"helvetica\"))\n              {\n        \tt->typeface = TYPE_HELVETICA;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"times\"))\n\t      {\n        \tt->typeface = TYPE_TIMES;\n\t\tbreak;\n\t      }\n              else if (!strcasecmp(font, \"courier\"))\n\t      {\n        \tt->typeface = TYPE_COURIER;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"symbol\"))\n\t      {\n        \tt->typeface = TYPE_SYMBOL;\n\t\tbreak;\n\t      }\n\t      else if (!strcasecmp(font, \"dingbat\"))\n\t      {\n        \tt->typeface = TYPE_DINGBATS;\n\t\tbreak;\n\t      }\n\t    }\n          }\n\n          if ((color = htmlGetVariable(t, (uchar *)\"COLOR\")) != NULL)\n            compute_color(t, color);\n\n          if ((size = htmlGetVariable(t, (uchar *)\"SIZE\")) != NULL)\n          {\n            if (have_whitespace)\n\t    {\n\t      // Insert a space before sized text...\n\t      insert_space(parent, t);\n\n\t      have_whitespace = 0;\n\t    }\n\n\t    if (isdigit(size[0]))\n\t      sizeval = atoi((char *)size);\n\t    else\n              sizeval = t->size + atoi((char *)size);\n\n            if (sizeval < 0)\n              t->size = 0;\n            else if (sizeval > 7)\n              t->size = 7;\n            else\n              t->size = (unsigned)sizeval;\n          }\n\n          descend = 1;\n          break;\n\n      case MARKUP_BIG :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before big text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          if (t->size < 6)\n            t->size += 2;\n          else\n            t->size = 7;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SMALL :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before small text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          if (t->size > 2)\n            t->size -= 2;\n          else\n            t->size = 0;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SUP :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before superscript text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->superscript = 1;\n\n          if ((sizeval = t->size + SIZE_SUP) < 0)\n\t    t->size = 0;\n\t  else\n\t    t->size = (unsigned)sizeval;\n\n          descend = 1;\n          break;\n\n      case MARKUP_SUB :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before subscript text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->subscript = 1;\n\n          if ((sizeval = t->size + SIZE_SUB) < 0)\n\t    t->size = 0;\n\t  else\n\t    t->size = (unsigned)sizeval;\n\n          descend = 1;\n          break;\n\n      case MARKUP_KBD :\n          t->style    = STYLE_BOLD;\n\n      case MARKUP_TT :\n      case MARKUP_CODE :\n      case MARKUP_SAMP :\n          if (isspace(ch = getc(fp)))\n\t    have_whitespace = 1;\n\t  else\n\t    ungetc(ch, fp);\n\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before monospaced text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->typeface = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_MONOSPACE\n\t                                                : TYPE_COURIER;\n\n          descend = 1;\n          break;\n\n      case MARKUP_STRONG :\n      case MARKUP_B :\n          t->style = (style_t)(t->style | STYLE_BOLD);\n\n          descend = 1;\n          break;\n\n      case MARKUP_DD :\n          t->indent ++;\n\n          descend = 1;\n          break;\n\n      case MARKUP_VAR :\n          t->style = (style_t)(t->style | STYLE_ITALIC);\n      case MARKUP_DFN :\n          t->typeface = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_SANS_SERIF\n\t                                                : TYPE_HELVETICA;\n\n          descend = 1;\n          break;\n\n      case MARKUP_CITE :\n      case MARKUP_EM :\n      case MARKUP_I :\n          t->style = (style_t)(t->style | STYLE_ITALIC);\n\n          descend = 1;\n          break;\n\n      case MARKUP_U :\n      case MARKUP_INS :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before underlined text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->underline = 1;\n\n          descend = 1;\n          break;\n\n      case MARKUP_STRIKE :\n      case MARKUP_S :\n      case MARKUP_DEL :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before struck-through text...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          t->strikethrough = 1;\n\n          descend = 1;\n          break;\n\n      case MARKUP_CENTER :\n          t->halignment = ALIGN_CENTER;\n\n          descend = 1;\n          break;\n\n      case MARKUP_A :\n          if (have_whitespace)\n\t  {\n\t    // Insert a space before this link...\n\t    insert_space(parent, t);\n\n\t    have_whitespace = 0;\n\t  }\n\n          descend = 1;\n\t  break;\n\n      default :\n         /*\n          * All other markup types should be using <MARK>...</MARK>\n          */\n\n          get_alignment(t);\n\n          descend = 1;\n          break;\n    }\n\n    if (descend)\n    {\n#ifdef DEBUG\n      strlcat((char *)indent, \"    \", sizeof(indent));\n#endif // DEBUG\n\n      parent = t;\n      prev   = NULL;\n    }\n  }\n\n  return (tree);\n}\n\n\n/*\n * 'write_file()' - Write a tree entry to a file...\n */\n\nstatic int\t\t\t/* I - New column */\nwrite_file(tree_t *t,\t\t/* I - Tree entry */\n           FILE   *fp,\t\t/* I - File to write to */\n           int    col)\t\t/* I - Current column */\n{\n  int\ti;\t\t\t/* Looping var */\n  uchar\t*ptr;\t\t\t/* Character pointer */\n\n\n  while (t != NULL)\n  {\n    if (t->markup == MARKUP_NONE)\n    {\n      if (t->preformatted)\n      {\n        for (ptr = t->data; *ptr != '\\0'; ptr ++)\n          fputs((char *)iso8859(*ptr), fp);\n\n\tif (t->data[strlen((char *)t->data) - 1] == '\\n')\n          col = 0;\n\telse\n          col += strlen((char *)t->data);\n      }\n      else\n      {\n\tif ((col + (int)strlen((char *)t->data)) > 72 && col > 0)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n\n        for (ptr = t->data; *ptr != '\\0'; ptr ++)\n          fputs((char *)iso8859(*ptr), fp);\n\n\tcol += strlen((char *)t->data);\n\n\tif (col > 72)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n      }\n    }\n    else if (t->markup == MARKUP_COMMENT)\n      fprintf(fp, \"\\n<!--%s-->\\n\", t->data);\n    else if (t->markup > 0)\n    {\n      switch (t->markup)\n      {\n        case MARKUP_AREA :\n        case MARKUP_BR :\n        case MARKUP_CENTER :\n        case MARKUP_COMMENT :\n        case MARKUP_DD :\n        case MARKUP_DL :\n        case MARKUP_DT :\n        case MARKUP_H1 :\n        case MARKUP_H2 :\n        case MARKUP_H3 :\n        case MARKUP_H4 :\n        case MARKUP_H5 :\n        case MARKUP_H6 :\n        case MARKUP_HEAD :\n        case MARKUP_HR :\n        case MARKUP_LI :\n        case MARKUP_MAP :\n        case MARKUP_OL :\n        case MARKUP_P :\n        case MARKUP_PRE :\n        case MARKUP_TABLE :\n        case MARKUP_TITLE :\n        case MARKUP_TR :\n        case MARKUP_UL :\n\tcase MARKUP_DIR :\n\tcase MARKUP_MENU :\n            if (col > 0)\n            {\n              putc('\\n', fp);\n              col = 0;\n            }\n        default :\n            break;\n      }\n\n      col += fprintf(fp, \"<%s\", _htmlMarkups[t->markup]);\n      for (i = 0; i < t->nvars; i ++)\n      {\n\tif (col > 72 && !t->preformatted)\n\t{\n          putc('\\n', fp);\n          col = 0;\n\t}\n\n        if (col > 0)\n        {\n          putc(' ', fp);\n          col ++;\n        }\n\n\tif (t->vars[i].value == NULL)\n          col += fprintf(fp, \"%s\", t->vars[i].name);\n\telse if (strchr((char *)t->vars[i].value, '\\\"') != NULL)\n          col += fprintf(fp, \"%s=\\'%s\\'\", t->vars[i].name, t->vars[i].value);\n\telse\n          col += fprintf(fp, \"%s=\\\"%s\\\"\", t->vars[i].name, t->vars[i].value);\n      }\n\n      putc('>', fp);\n      col ++;\n\n      if (col > 72 && !t->preformatted)\n      {\n\tputc('\\n', fp);\n\tcol = 0;\n      }\n\n      if (t->child != NULL)\n      {\n\tcol = write_file(t->child, fp, col);\n\n\tif (col > 72 && !t->preformatted)\n\t{\n\t  putc('\\n', fp);\n\t  col = 0;\n\t}\n\n        col += fprintf(fp, \"</%s>\", _htmlMarkups[t->markup]);\n        switch (t->markup)\n        {\n          case MARKUP_AREA :\n          case MARKUP_BR :\n          case MARKUP_CENTER :\n          case MARKUP_COMMENT :\n          case MARKUP_DD :\n          case MARKUP_DL :\n          case MARKUP_DT :\n          case MARKUP_H1 :\n          case MARKUP_H2 :\n          case MARKUP_H3 :\n          case MARKUP_H4 :\n          case MARKUP_H5 :\n          case MARKUP_H6 :\n          case MARKUP_HEAD :\n          case MARKUP_HR :\n          case MARKUP_LI :\n          case MARKUP_MAP :\n          case MARKUP_OL :\n          case MARKUP_P :\n          case MARKUP_PRE :\n          case MARKUP_TABLE :\n          case MARKUP_TITLE :\n          case MARKUP_TR :\n          case MARKUP_UL :\n          case MARKUP_DIR :\n          case MARKUP_MENU :\n              putc('\\n', fp);\n              col = 0;\n          default :\n\t      break;\n        }\n      }\n    }\n\n    t = t->next;\n  }\n\n  return (col);\n}\n\n\n/*\n * 'htmlWriteFile()' - Write an HTML markup tree to a file.\n */\n\nint\t\t\t\t/* O - Write status: 0 = success, -1 = fail */\nhtmlWriteFile(tree_t *parent,\t/* I - Parent tree entry */\n              FILE   *fp)\t/* I - File to write to */\n{\n  if (write_file(parent, fp, 0) < 0)\n    return (-1);\n  else\n    return (0);\n}\n\n\n/*\n * 'htmlAddTree()' - Add a tree node to the parent.\n */\n\ntree_t *\t\t\t/* O - New entry */\nhtmlAddTree(tree_t   *parent,\t/* I - Parent entry */\n            markup_t markup,\t/* I - Markup code */\n            uchar    *data)\t/* I - Data/text */\n{\n  tree_t\t*t;\t\t/* New tree entry */\n\n\n  if ((t = htmlNewTree(parent, markup, data)) == NULL)\n    return (NULL);\n\n /*\n  * Add the tree entry to the end of the chain of children...\n  */\n\n  if (parent != NULL)\n  {\n    if (parent->last_child != NULL)\n    {\n      parent->last_child->next = t;\n      t->prev                  = parent->last_child;\n    }\n    else\n      parent->child = t;\n\n    parent->last_child = t;\n  }\n\n  return (t);\n}\n\n\n/*\n * 'htmlDeleteTree()' - Free all memory associated with a tree...\n */\n\nint\t\t\t\t/* O - 0 for success, -1 for failure */\nhtmlDeleteTree(tree_t *parent)\t/* I - Parent to delete */\n{\n  tree_t\t*next;\t\t/* Next tree entry */\n\n\n  if (parent == NULL)\n    return (-1);\n\n  while (parent != NULL)\n  {\n    next = parent->next;\n\n    if (parent->child != NULL)\n      if (htmlDeleteTree(parent->child))\n        return (-1);\n\n    delete_node(parent);\n\n    parent = next;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'htmlInsertTree()' - Insert a tree node under the parent.\n */\n\ntree_t *\t\t\t/* O - New entry */\nhtmlInsertTree(tree_t   *parent,/* I - Parent entry */\n               markup_t markup,\t/* I - Markup code */\n               uchar    *data)\t/* I - Data/text */\n{\n  tree_t\t*t;\t\t/* New tree entry */\n\n\n  if ((t = htmlNewTree(parent, markup, data)) == NULL)\n    return (NULL);\n\n /*\n  * Insert the tree entry at the beginning of the chain of children...\n  */\n\n  if (parent != NULL)\n  {\n    if (parent->child != NULL)\n    {\n      parent->child->prev = t;\n      t->next             = parent->child;\n    }\n    else\n      parent->last_child = t;\n\n    parent->child = t;\n  }\n\n  return (t);\n}\n\n\n/*\n * 'htmlMapUnicode()' - Map a Unicode character to the custom character set.\n */\n\nuchar\t\t\t\t/* O - Charset character */\nhtmlMapUnicode(int ch)\t\t/* I - Unicode character */\n{\n  uchar\tnewch;\t\t\t/* New charset character */\n\n\n  // If we already have a mapping for this character, return it...\n  if (_htmlCharacters[ch])\n    return (_htmlCharacters[ch]);\n\n  if (_htmlUTF8 >= 0x100)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Too many Unicode code points.\");\n    return (0);\n  }\n\n  newch = _htmlUTF8++;\n\n  _htmlCharacters[ch] = (uchar)newch;\n  _htmlUnicode[newch] = ch;\n  _htmlGlyphs[newch]  = _htmlGlyphsAll[ch];\n\n  for (int i = 0; i < TYPE_MAX; i ++)\n    for (int j = 0; j < STYLE_MAX; j ++)\n      _htmlWidths[i][j][newch] = _htmlWidthsAll[i][j][ch];\n\n  return (newch);\n}\n\n\n/*\n * 'htmlNewTree()' - Create a new tree node for the parent.\n */\n\ntree_t *\t\t\t/* O - New entry */\nhtmlNewTree(tree_t   *parent,\t/* I - Parent entry */\n            markup_t markup,\t/* I - Markup code */\n            uchar    *data)\t/* I - Data/text */\n{\n  tree_t\t*t;\t\t/* New tree entry */\n\n\n /*\n  * Allocate a new tree entry - use calloc() to get zeroed data...\n  */\n\n  t = (tree_t *)calloc(sizeof(tree_t), 1);\n  if (t == NULL)\n    return (NULL);\n\n /*\n  * Set the markup code and copy the data if necessary...\n  */\n\n  t->markup = markup;\n  if (data != NULL)\n    t->data = (uchar *)strdup((char *)data);\n\n /*\n  * Set/copy font characteristics...\n  */\n\n  if (parent == NULL)\n  {\n    t->halignment = ALIGN_LEFT;\n    t->valignment = ALIGN_BOTTOM;\n    t->typeface   = _htmlBodyFont;\n    t->size       = SIZE_P;\n\n    compute_color(t, _htmlTextColor);\n  }\n  else\n  {\n    t->link          = parent->link;\n    t->halignment    = parent->halignment;\n    t->valignment    = parent->valignment;\n    t->typeface      = parent->typeface;\n    t->size          = parent->size;\n    t->style         = parent->style;\n    t->preformatted  = parent->preformatted;\n    t->indent        = parent->indent;\n    t->red           = parent->red;\n    t->green         = parent->green;\n    t->blue          = parent->blue;\n    t->underline     = parent->underline;\n    t->strikethrough = parent->strikethrough;\n  }\n\n  switch (t->markup)\n  {\n    case MARKUP_NONE :\n    case MARKUP_IMG :\n       /*\n\t* Figure out the width & height of this fragment...\n\t*/\n\n        compute_size(t);\n\tbreak;\n\n    case MARKUP_H1 :\n    case MARKUP_H2 :\n    case MARKUP_H3 :\n    case MARKUP_H4 :\n    case MARKUP_H5 :\n    case MARKUP_H6 :\n        get_alignment(t);\n\n        t->typeface      = _htmlHeadingFont;\n        t->size          = (unsigned)(SIZE_H1 - t->markup + MARKUP_H1);\n        t->subscript     = 0;\n        t->superscript   = 0;\n        t->strikethrough = 0;\n        t->preformatted  = 0;\n        t->style         = STYLE_BOLD;\n        break;\n\n    case MARKUP_P :\n        get_alignment(t);\n\n        t->typeface      = _htmlBodyFont;\n        t->size          = SIZE_P;\n        t->style         = STYLE_NORMAL;\n        t->subscript     = 0;\n        t->superscript   = 0;\n        t->strikethrough = 0;\n        t->preformatted  = 0;\n        break;\n\n    case MARKUP_PRE :\n        t->typeface      = _htmlBodyFont >= TYPE_MONOSPACE ? TYPE_MONOSPACE\n\t                                                   : TYPE_COURIER;\n        t->size          = SIZE_PRE;\n        t->style         = STYLE_NORMAL;\n        t->subscript     = 0;\n        t->superscript   = 0;\n        t->strikethrough = 0;\n        t->preformatted  = 1;\n        break;\n\n    case MARKUP_DIV :\n        get_alignment(t);\n        break;\n\n    case MARKUP_BLOCKQUOTE :\n        t->style = STYLE_ITALIC;\n\n    case MARKUP_UL :\n    case MARKUP_DIR :\n    case MARKUP_MENU :\n    case MARKUP_OL :\n    case MARKUP_DL :\n        t->indent ++;\n        break;\n\n    case MARKUP_AREA :\n    case MARKUP_BR :\n    case MARKUP_COMMENT :\n    case MARKUP_HR :\n    case MARKUP_INPUT :\n    case MARKUP_ISINDEX :\n    case MARKUP_META :\n    case MARKUP_WBR :\n        break;\n\n    case MARKUP_TH :\n        t->style = STYLE_BOLD;\n    case MARKUP_TD :\n        get_alignment(t);\n        break;\n\n    case MARKUP_SUP :\n        t->superscript = 1;\n        t->size        = SIZE_P + SIZE_SUP;\n        break;\n\n    case MARKUP_SUB :\n        t->subscript = 1;\n        t->size      = SIZE_P + SIZE_SUB;\n        break;\n\n    case MARKUP_B :\n        t->style = (style_t)(t->style | STYLE_BOLD);\n        break;\n\n    case MARKUP_DD :\n        t->indent ++;\n        break;\n\n    case MARKUP_DT :\n    case MARKUP_I :\n        t->style = (style_t)(t->style | STYLE_ITALIC);\n        break;\n\n    case MARKUP_U :\n    case MARKUP_INS :\n        t->underline = 1;\n        break;\n\n    case MARKUP_STRIKE :\n    case MARKUP_DEL :\n        t->strikethrough = 1;\n        break;\n\n    default :\n        break;\n  }\n\n  t->parent = parent;\n\n  return (t);\n}\n\n\n/*\n * 'htmlGetText()' - Get all text from the given tree.\n */\n\nuchar *\t\t\t\t/* O - String containing text nodes */\nhtmlGetText(tree_t *t)\t\t/* I - Tree to pick */\n{\n  uchar\t\t*s,\t\t// String\n\t\t*s2,\t\t// New string\n\t\t*tdata = NULL,\t// Temporary string data\n\t\t*talloc = NULL;\t// Allocated string data\n  size_t\tslen,\t\t// Length of string\n\t\ttlen;\t\t// Length of node string\n\n\n  // Loop through all of the nodes in the tree and collect text...\n  slen = 0;\n  s    = NULL;\n\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n\n    tlen = tdata ? strlen((char *)tdata) : 0;\n\n    if (tdata != NULL && tlen > 0)\n    {\n      // Add the text to this string...\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n\n      if (!s2)\n        break;\n\n      s = s2;\n\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n\n      slen += tlen;\n    }\n\n    if (talloc)\n    {\n      free(talloc);\n      talloc = NULL;\n    }\n\n    t = t->next;\n  }\n\n  if (slen)\n    s[slen] = '\\0';\n\n  if (talloc)\n    free(talloc);\n\n  return (s);\n}\n\n\n/*\n * 'htmlGetMeta()' - Get document \"meta\" data...\n */\n\nuchar *\t\t\t\t/* O - Content string */\nhtmlGetMeta(tree_t *tree,\t/* I - Document tree */\n            uchar  *name)\t/* I - Metadata name */\n{\n  uchar\t*tname,\t\t\t/* Name value from tree entry */\n\t*tcontent;\t\t/* Content value from tree entry */\n\n\n  while (tree != NULL)\n  {\n   /*\n    * Check this tree entry...\n    */\n\n    if (tree->markup == MARKUP_META &&\n        (tname = htmlGetVariable(tree, (uchar *)\"NAME\")) != NULL &&\n        (tcontent = htmlGetVariable(tree, (uchar *)\"CONTENT\")) != NULL)\n    {\n      if (strcasecmp((char *)name, (char *)tname) == 0)\n        return (tcontent);\n    }\n    else if (tree->markup == MARKUP_HTML && !strcasecmp((char *)name, \"LANG\") && (tcontent = htmlGetVariable(tree, (uchar *)\"LANG\")) != NULL)\n    {\n      return (tcontent);\n    }\n\n   /*\n    * Check child entries...\n    */\n\n    if (tree->child != NULL)\n      if ((tcontent = htmlGetMeta(tree->child, name)) != NULL)\n        return (tcontent);\n\n   /*\n    * Next tree entry...\n    */\n\n    tree = tree->next;\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'htmlGetStyle()' - Get a style value from a node's STYLE attribute.\n */\n\nuchar *\t\t\t\t// O - Value or NULL\nhtmlGetStyle(tree_t *t,\t\t// I - Node\n             uchar  *name)\t// I - Name (including \":\")\n{\n  uchar\t\t*ptr,\t\t// Pointer in STYLE attribute\n\t\t*bufptr;\t// Pointer in buffer\n  size_t\tptrlen,\t\t// Length of STYLE attribute\n\t\tnamelen;\t// Length of name\n  static uchar\tbuffer[1024];\t// Buffer for value\n\n\n  // See if we have a STYLE attribute...\n  if ((ptr = htmlGetVariable(t, (uchar *)\"STYLE\")) == NULL)\n    return (NULL);\n\n  // Loop through the STYLE attribute looking for the name...\n  for (namelen = strlen((char *)name), ptrlen = strlen((char *)ptr);\n       ptrlen > namelen;\n       ptr ++, ptrlen --)\n    if (strncasecmp((char *)name, (char *)ptr, namelen) == 0)\n    {\n      for (ptr += namelen; isspace(*ptr); ptr ++);\n\n      for (bufptr = buffer;\n           *ptr && *ptr != ';' && bufptr < (buffer + sizeof(buffer) - 1);\n\t   *bufptr++ = *ptr++);\n\n      *bufptr = '\\0';\n\n      return (buffer);\n    }\n\n  return (NULL);\n}\n\n\n/*\n * 'htmlGetVariable()' - Get a variable value from a markup entry.\n */\n\nuchar *\t\t\t\t/* O - Value or NULL if variable does not exist */\nhtmlGetVariable(tree_t *t,\t/* I - Tree entry */\n                uchar  *name)\t/* I - Variable name */\n{\n  var_t\t*v,\t\t\t/* Matching variable */\n\tkey;\t\t\t/* Search key */\n\n\n  if (t == NULL || name == NULL || t->nvars == 0)\n    return (NULL);\n\n  key.name = name;\n\n  v = (var_t *)bsearch(&key, t->vars, (size_t)t->nvars, sizeof(var_t), (compare_func_t)compare_variables);\n  if (v == NULL)\n    return (NULL);\n  else if (v->value == NULL)\n    return ((uchar *)\"\");\n  else\n    return (v->value);\n}\n\n\n/*\n * 'htmlLoadFontWidths()' - Load all of the font width files.\n */\n\nvoid\nhtmlLoadFontWidths(int typeface, int style)\n{\n  char\t\tfilename[1024];\t\t/* Filenames */\n  FILE\t\t*fp;\t\t\t/* Files */\n  int\t\tch;\t\t\t/* Character */\n  float\t\twidth;\t\t\t/* Width value */\n  char\t\tglyph[64];\t\t/* Glyph name */\n  char\t\tline[1024];\t\t/* Line from AFM file */\n\n\n /*\n  * Now read all of the font widths...\n  */\n\n  for (ch = 0; ch < 256; ch ++)\n    _htmlWidths[typeface][style][ch] = 600;\n\n  if (_htmlUTF8)\n  {\n    for (ch = 0; ch < 65536; ch ++)\n      _htmlWidthsAll[typeface][style][ch] = 600;\n  }\n\n  snprintf(filename, sizeof(filename), \"%s/fonts/%s.afm\", _htmlData, _htmlFonts[typeface][style]);\n  if ((fp = fopen(filename, \"r\")) == NULL)\n  {\n#ifndef DEBUG\n    progress_error(HD_ERROR_FILE_NOT_FOUND, \"Unable to open font width file %s!\", filename);\n#endif /* !DEBUG */\n    return;\n  }\n\n  while (fgets(line, sizeof(line), fp) != NULL)\n  {\n    if (strncmp(line, \"C \", 2) != 0)\n      continue;\n\n    if (typeface < TYPE_SYMBOL)\n    {\n     /*\n      * Handle encoding of regular fonts using assigned charset...\n      */\n\n      if (sscanf(line, \"%*s%*s%*s%*s%f%*s%*s%63s\", &width, glyph) != 2)\n\tcontinue;\n\n      for (ch = 0; ch < 256; ch ++)\n      {\n\tif (_htmlGlyphs[ch] && !strcmp(_htmlGlyphs[ch], glyph))\n\t{\n\t  _htmlWidths[typeface][style][ch] = (short)width;\n\t  break;\n\t}\n      }\n\n      if (_htmlUTF8)\n      {\n\tfor (ch = 0; ch < 65536; ch ++)\n\t{\n\t  if (_htmlGlyphsAll[ch] && !strcmp(_htmlGlyphsAll[ch], glyph))\n\t  {\n\t    _htmlWidthsAll[typeface][style][ch] = (short)width;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    else\n    {\n     /*\n      * Symbol and Dingbats fonts uses their own encoding...\n      */\n\n      if (sscanf(line, \"%*s%d%*s%*s%f\", &ch, &width) != 2)\n\tcontinue;\n\n      if (ch < 256 && ch >= 0)\n      {\n\t_htmlWidths[typeface][style][ch]    = (short)width;\n\t_htmlWidthsAll[typeface][style][ch] = (short)width;\n      }\n    }\n  }\n\n  fclose(fp);\n\n  // Make sure that non-breaking space has the same width as a breaking space...\n  _htmlWidths[typeface][style][160]    = _htmlWidths[typeface][style][32];\n  _htmlWidthsAll[typeface][style][160] = _htmlWidthsAll[typeface][style][32];\n\n  _htmlWidthsLoaded[typeface][style] = 1;\n}\n\n\n/*\n * 'htmlSetVariable()' - Set a variable for a markup entry.\n */\n\nint\t\t\t\t/* O - Set status: 0 = success, -1 = fail */\nhtmlSetVariable(tree_t *t,\t/* I - Tree entry */\n                uchar  *name,\t/* I - Variable name */\n                uchar  *value)\t/* I - Variable value */\n{\n  var_t\t*v,\t\t\t/* Matching variable */\n\tkey;\t\t\t/* Search key */\n\n\n  DEBUG_printf((\"%shtmlSetVariable(%p, \\\"%s\\\", \\\"%s\\\")\\n\", indent, (void *)t, name,\n                value ? (const char *)value : \"(null)\"));\n\n  if (t->nvars == 0)\n    v = NULL;\n  else\n  {\n    key.name = name;\n\n    v = (var_t *)bsearch(&key, t->vars, (size_t)t->nvars, sizeof(var_t), (compare_func_t)compare_variables);\n  }\n\n  if (v == NULL)\n  {\n    if (t->nvars == 0)\n      v = (var_t *)malloc(sizeof(var_t));\n    else\n      v = (var_t *)realloc(t->vars, sizeof(var_t) * (size_t)(t->nvars + 1));\n\n    if (v == NULL)\n    {\n      DEBUG_printf((\"%s==== MALLOC/REALLOC FAILED! ====\\n\", indent));\n\n      return (-1);\n    }\n\n    t->vars  = v;\n    v        += t->nvars;\n    t->nvars ++;\n    v->name  = (uchar *)strdup((char *)name);\n    if (value != NULL)\n      v->value = (uchar *)strdup((char *)value);\n    else\n      v->value = NULL;\n\n    if (strcasecmp((char *)name, \"HREF\") == 0)\n    {\n      DEBUG_printf((\"%s---- Set link to %s ----\\n\", indent, value));\n      t->link = t;\n    }\n\n    if (t->nvars > 1)\n      qsort(t->vars, (size_t)t->nvars, sizeof(var_t), (compare_func_t)compare_variables);\n  }\n  else if (v->value != value)\n  {\n    if (v->value != NULL)\n      free(v->value);\n    if (value != NULL)\n      v->value = (uchar *)strdup((char *)value);\n    else\n      v->value = NULL;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'htmlSetBaseSize()' - Set the font sizes and spacings...\n */\n\nvoid\nhtmlSetBaseSize(double p,\t/* I - Point size of paragraph font */\n                double s)\t/* I - Spacing */\n{\n  int\ti;\t\t\t/* Looping var */\n\n\n  p /= 1.2 * 1.2 * 1.2;\n  for (i = 0; i < 8; i ++, p *= 1.2)\n  {\n    _htmlSizes[i]    = p;\n    _htmlSpacings[i] = p * s;\n  }\n}\n\n\n/*\n * 'htmlSetCharSet()' - Set the character set for output.\n */\n\nvoid\nhtmlSetCharSet(const char *cs)\t\t/* I - Character set file to load */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\tfilename[1024];\t\t/* Filenames */\n  FILE\t\t*fp;\t\t\t/* Files */\n  int\t\tch, unicode;\t\t/* Character values */\n  char\t\tglyph[64];\t\t/* Glyph name */\n  char\t\tline[1024];\t\t/* Line from charset file */\n  int\t\tchars[256];\t\t/* Character encoding array */\n\n\n  strlcpy(_htmlCharSet, cs, sizeof(_htmlCharSet));\n\n  if (!_htmlInitialized)\n  {\n   /*\n    * Load the PostScript glyph names for all of Unicode...\n    */\n\n    memset(_htmlGlyphsAll, 0, sizeof(_htmlGlyphsAll));\n\n    snprintf(line, sizeof(line), \"%s/data/psglyphs\", _htmlData);\n    if ((fp = fopen(line, \"r\")) != NULL)\n    {\n      while (fscanf(fp, \"%x%63s\", &unicode, glyph) == 2)\n        _htmlGlyphsAll[unicode] = strdup(glyph);\n\n      fclose(fp);\n\n      _htmlInitialized = 1;\n    }\n#ifndef DEBUG\n    else\n      progress_error(HD_ERROR_FILE_NOT_FOUND,\n                     \"Unable to open psglyphs data file!\");\n#endif /* !DEBUG */\n  }\n\n  memset(_htmlGlyphs, 0, sizeof(_htmlGlyphs));\n\n  if (!strcmp(cs, \"utf-8\"))\n  {\n    // Generate a dynamic mapping of Unicode to an 8-bit charset with the\n    // bottom 128 characters matching US ASCII...\n    _htmlUTF8 = 0x80;\n\n    for (i = 0; i < 128; i ++)\n    {\n     /*\n      * Add the glyph to the charset array...\n      */\n\n      _htmlGlyphs[i]  = _htmlGlyphsAll[i];\n      _htmlUnicode[i] = i;\n    }\n\n    memset(_htmlWidthsLoaded, 0, sizeof(_htmlWidthsLoaded));\n    return;\n  }\n\n  if (strncmp(cs, \"8859-\", 5) == 0)\n    snprintf(filename, sizeof(filename), \"%s/data/iso-%s\", _htmlData, cs);\n  else\n    snprintf(filename, sizeof(filename), \"%s/data/%s\", _htmlData, cs);\n\n  if ((fp = fopen(filename, \"r\")) == NULL)\n  {\n   /*\n    * Can't open charset file; use ISO-8859-1...\n    */\n\n#ifndef DEBUG\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open character set file %s!\", cs);\n#endif /* !DEBUG */\n\n    for (i = 0; i < 256; i ++)\n      chars[i] = i;\n  }\n  else\n  {\n   /*\n    * Read the <char> <unicode> lines from the file...\n    */\n\n    memset(chars, 0, sizeof(chars));\n\n    while (fscanf(fp, \"%x%x\", &ch, &unicode) == 2)\n      chars[ch] = unicode;\n\n    fclose(fp);\n  }\n\n /*\n  * Build the glyph array...\n  */\n\n  for (i = 0; i < 256; i ++)\n  {\n   /*\n    * Add the glyph to the charset array...\n    */\n\n    if (chars[i] == 0)\n    {\n      _htmlGlyphs[i] = NULL;\n      continue;\n    }\n    else\n      _htmlGlyphs[i] = _htmlGlyphsAll[chars[i]];\n\n    if (_htmlGlyphs[i])\n      _htmlUnicode[i] = chars[i];\n  }\n\n  memset(_htmlWidthsLoaded, 0, sizeof(_htmlWidthsLoaded));\n}\n\n\n/*\n * 'htmlSetTextColor()' - Set the default text color.\n */\n\nvoid\nhtmlSetTextColor(uchar *color)\t/* I - Text color */\n{\n  strlcpy((char *)_htmlTextColor, (char *)color, sizeof(_htmlTextColor));\n}\n\n\n/*\n * 'compare_variables()' - Compare two markup variables.\n */\n\nstatic int\t\t\t/* O - -1 if v0 < v1, 0 if v0 == v1, 1 if v0 > v1 */\ncompare_variables(var_t *v0,\t/* I - First variable */\n                  var_t *v1)\t/* I - Second variable */\n{\n  return (strcasecmp((char *)v0->name, (char *)v1->name));\n}\n\n\n/*\n * 'compare_markups()' - Compare two markup strings...\n */\n\nstatic int\t\t\t/* O - -1 if m0 < m1, 0 if m0 == m1, 1 if m0 > m1 */\ncompare_markups(uchar **m0,\t/* I - First markup */\n                uchar **m1)\t/* I - Second markup */\n{\n  if (tolower((*m0)[0]) == 'h' && isdigit((*m0)[1]) &&\n      tolower((*m1)[0]) == 'h' && isdigit((*m1)[1]))\n    return (atoi((char *)*m0 + 1) - atoi((char *)*m1 + 1));\n  else\n    return (strcasecmp((char *)*m0, (char *)*m1));\n}\n\n\n/*\n * 'delete_node()' - Free all memory associated with a node...\n */\n\nstatic void\ndelete_node(tree_t *t)\t\t/* I - Node to delete */\n{\n  int\t\ti;\t\t/* Looping var */\n  var_t\t\t*var;\t\t/* Current variable */\n\n\n  if (t == NULL)\n    return;\n\n  if (t->data != NULL)\n    free(t->data);\n\n  for (i = t->nvars, var = t->vars; i > 0; i --, var ++)\n  {\n    free(var->name);\n    if (var->value != NULL)\n      free(var->value);\n  }\n\n  if (t->vars != NULL)\n    free(t->vars);\n\n  free(t);\n}\n\n\n//\n// 'insert_space()' - Insert a whitespace character before the\n//                    specified node.\n//\n\nstatic void\ninsert_space(tree_t *parent,\t// I - Parent node\n             tree_t *t)\t\t// I - Node to insert before\n{\n  tree_t\t*space;\t\t// Space node\n\n\n  // Allocate memory for the whitespace...\n  space = (tree_t *)calloc(sizeof(tree_t), 1);\n  if (space == NULL)\n  {\n#ifndef DEBUG\n    progress_error(HD_ERROR_OUT_OF_MEMORY,\n                   \"Unable to allocate memory for HTML tree node!\");\n#endif /* !DEBUG */\n    return;\n  }\n\n  // Set/copy font characteristics...\n  if (parent)\n  {\n    space->typeface = parent->typeface;\n    space->size     = parent->size;\n    space->style    = parent->style;\n  }\n  else\n  {\n    space->typeface = _htmlBodyFont;\n    space->size     = SIZE_P;\n  }\n\n  // Initialize element data...\n  space->markup = MARKUP_NONE;\n  space->data   = (uchar *)strdup(\" \");\n\n  // Set tree pointers...\n  space->parent = parent;\n  space->prev   = t->prev;\n  space->next   = t;\n\n  if (space->prev)\n    space->prev->next = space;\n  else if (parent)\n    parent->child = space;\n\n  t->prev = space;\n\n  compute_size(space);\n}\n\n\n/*\n * 'parse_markup()' - Parse a markup string.\n */\n\nstatic int\t\t\t/* O - -1 on error, MARKUP_nnnn otherwise */\nparse_markup(tree_t *t,\t\t/* I - Current tree entry */\n             FILE   *fp,\t/* I - Input file */\n\t     int    *linenum)\t/* O - Current line number */\n{\n  int\tch, ch2;\t\t/* Characters from file */\n  uchar\tmarkup[255],\t\t/* Markup string... */\n\t*mptr,\t\t\t/* Current character... */\n\tcomment[10240],\t\t/* Comment string */\n\t*cptr,\t\t\t/* Current char... */\n\t**temp;\t\t\t/* Markup variable entry */\n\n\n  mptr = markup;\n\n  while ((ch = getc(fp)) != EOF && mptr < (markup + sizeof(markup) - 1))\n    if (ch == '>' || isspace(ch))\n      break;\n    else if (ch == '/' && mptr > markup)\n    {\n      // Look for \"/>\"...\n      ch = getc(fp);\n\n      if (ch != '>')\n        return (MARKUP_ERROR);\n\n      break;\n    }\n    else\n    {\n      if ((ch & 0x80) && _htmlUTF8)\n      {\n        // Collect UTF-8 value...\n        ch = utf8_getc(ch, fp);\n      }\n\n      if (ch)\n        *mptr++ = (uchar)ch;\n\n      // Handle comments without whitespace...\n      if ((mptr - markup) == 3 && strncmp((const char *)markup, \"!--\", 3) == 0)\n      {\n        ch = getc(fp);\n        break;\n      }\n    }\n\n  *mptr = '\\0';\n\n  if (ch == EOF)\n    return (MARKUP_ERROR);\n\n  mptr = markup;\n  temp = (uchar **)bsearch(&mptr, _htmlMarkups,\n                           sizeof(_htmlMarkups) / sizeof(_htmlMarkups[0]),\n                           sizeof(_htmlMarkups[0]),\n                           (compare_func_t)compare_markups);\n\n  if (temp == NULL)\n  {\n   /*\n    * Unrecognized markup stuff...\n    */\n\n    t->markup = MARKUP_UNKNOWN;\n    strlcpy((char *)comment, (char *)markup, sizeof(comment));\n    cptr = comment + strlen((char *)comment);\n\n    DEBUG_printf((\"%s%s (unrecognized!)\\n\", indent, markup));\n  }\n  else\n  {\n    t->markup = (markup_t)((const char **)temp - _htmlMarkups);\n    cptr      = comment;\n\n    DEBUG_printf((\"%s%s, line %d\\n\", indent, markup, *linenum));\n  }\n\n  if (t->markup == MARKUP_COMMENT || t->markup == MARKUP_UNKNOWN)\n  {\n    int lastch = ch;\t\t\t// Last character seen\n\n    while (ch != EOF && cptr < (comment + sizeof(comment) - 2))\n    {\n      if (ch == '>' && temp == NULL)\n        break;\n\n      if (ch == '\\n')\n        (*linenum) ++;\n\n      if (ch == '-' && lastch == '-')\n      {\n        *cptr++ = (uchar)ch;\n\n        if ((ch2 = getc(fp)) == '>')\n\t{\n\t  // Erase trailing -->\n\t  cptr -= 2;\n\n          if (cptr < comment)\n            cptr = comment; // Issue #316: buffer underflow\n\t  break;\n        }\n\telse\n\t  ch = ch2;\n      }\n      else\n      {\n        if (ch == '&')\n\t{\n          // Handle character entities...\n\t  uchar\tentity[16],\t\t// Character entity name\n\t\t*eptr;\t\t\t// Pointer into name\n\n\n\t  eptr = entity;\n\t  while (eptr < (entity + sizeof(entity) - 1) &&\n\t\t (ch = getc(fp)) != EOF)\n\t    if (!isalnum(ch) && ch != '#')\n\t      break;\n\t    else\n\t      *eptr++ = (uchar)ch;\n\n\t  if (ch != ';')\n\t  {\n\t    ungetc(ch, fp);\n\t    ch = 0;\n\t  }\n\n\t  *eptr = '\\0';\n\t  if (!ch)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                   *linenum, _htmlCurrentFile);\n\n            if (cptr < (comment + sizeof(comment) - 1))\n\t      *cptr++ = '&';\n            strlcpy((char *)cptr, (char *)entity, sizeof(comment) - (size_t)(cptr - comment));\n\t    cptr += strlen((char *)cptr);\n\t  }\n\t  else if ((ch = iso8859(entity)) == 0)\n\t  {\n\t    progress_error(HD_ERROR_HTML_ERROR,\n\t                   \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                   entity, *linenum, _htmlCurrentFile);\n\n            if (cptr < (comment + sizeof(comment) - 1))\n\t      *cptr++ = '&';\n            strlcpy((char *)cptr, (char *)entity, sizeof(comment) - (size_t)(cptr - comment));\n\t    cptr += strlen((char *)cptr);\n            if (cptr < (comment + sizeof(comment) - 1))\n\t      *cptr++ = ';';\n\t  }\n\t  else\n\t    *cptr++ = (uchar)ch;\n\t}\n\telse\n        {\n          if ((ch & 0x80) && _htmlUTF8)\n          {\n            // Collect UTF-8 value...\n            ch = utf8_getc(ch, fp);\n          }\n\n          if (ch)\n            *cptr++ = (uchar)ch;\n        }\n\n        lastch = ch;\n        ch     = getc(fp);\n      }\n    }\n\n    *cptr = '\\0';\n    t->data = (uchar *)strdup((char *)comment);\n  }\n  else\n  {\n    while (ch != EOF && ch != '>')\n    {\n      if (ch == '\\n')\n        (*linenum) ++;\n\n      if (!isspace(ch))\n      {\n        ungetc(ch, fp);\n        parse_variable(t, fp, linenum);\n      }\n\n      ch = getc(fp);\n\n      if (ch == '/')\n      {\n\t// Look for \"/>\"...\n\tch = getc(fp);\n\n\tif (ch != '>')\n          return (MARKUP_ERROR);\n\n\tbreak;\n      }\n    }\n  }\n\n  return (t->markup);\n}\n\n\n/*\n * 'parse_variable()' - Parse a markup variable string.\n */\n\nstatic int\t\t\t\t// O - -1 on error, 0 on success\nparse_variable(tree_t *t,\t\t// I - Current tree entry\n               FILE   *fp,\t\t// I - Input file\n\t       int    *linenum)\t\t// I - Current line number\n{\n  uchar\tname[1024],\t\t\t// Name of variable\n\tvalue[10240],\t\t\t// Value of variable\n\t*ptr,\t\t\t\t// Temporary pointer\n\tentity[16],\t\t\t// Character entity name\n\t*eptr;\t\t\t\t// Pointer into name\n  int\tch;\t\t\t\t// Character from file\n\n\n  ptr = name;\n  while ((ch = getc(fp)) != EOF)\n    if (isspace(ch) || ch == '=' || ch == '>' || ch == '\\r')\n      break;\n    else if (ch == '/' && ptr == name)\n      break;\n    else if (ptr < (name + sizeof(name) - 1))\n    {\n      if ((ch & 0x80) && _htmlUTF8)\n      {\n        // Collect UTF-8 value...\n        ch = utf8_getc(ch, fp);\n      }\n\n      if (ch)\n        *ptr++ = (uchar)ch;\n    }\n\n  *ptr = '\\0';\n\n  if (ch == '\\n')\n    (*linenum) ++;\n\n  while (isspace(ch) || ch == '\\r')\n  {\n    ch = getc(fp);\n\n    if (ch == '\\n')\n      (*linenum) ++;\n  }\n\n  switch (ch)\n  {\n    default :\n        ungetc(ch, fp);\n        return (htmlSetVariable(t, name, NULL));\n    case EOF :\n        return (-1);\n    case '=' :\n        ptr = value;\n        ch  = getc(fp);\n\n        while (isspace(ch) || ch == '\\r')\n          ch = getc(fp);\n\n        if (ch == EOF)\n          return (-1);\n\n        if (ch == '\\'')\n        {\n          while ((ch = getc(fp)) != EOF)\n\t  {\n            if (ch == '\\'')\n              break;\n\t    else if (ch == '&')\n\t    {\n\t      // Possibly a character entity...\n\t      eptr = entity;\n\t      while (eptr < (entity + sizeof(entity) - 1) &&\n\t             (ch = getc(fp)) != EOF)\n\t        if (!isalnum(ch) && ch != '#')\n\t\t  break;\n\t\telse\n\t\t  *eptr++ = (uchar)ch;\n\n              if (ch != ';')\n\t      {\n\t        ungetc(ch, fp);\n\t\tch = 0;\n\t      }\n\n              *eptr = '\\0';\n              if (!ch)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unquoted & on line %d of %s.\",\n\t                       *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n\t      }\n\t      else if ((ch = iso8859(entity)) == 0)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                       entity, *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = ';';\n\t      }\n\t      else if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = (uchar)ch;\n\t    }\n            else if (ptr < (value + sizeof(value) - 1) &&\n\t             ch != '\\n' && ch != '\\r')\n            {\n              if ((ch & 0x80) && _htmlUTF8)\n              {\n                // Collect UTF-8 value...\n                ch = utf8_getc(ch, fp);\n              }\n\n              if (ch)\n                *ptr++ = (uchar)ch;\n            }\n\t    else if (ch == '\\n')\n\t    {\n\t      if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = ' ';\n\n\t      (*linenum) ++;\n\t    }\n\t  }\n\n          *ptr = '\\0';\n        }\n        else if (ch == '\\\"')\n        {\n          while ((ch = getc(fp)) != EOF)\n\t  {\n            if (ch == '\\\"')\n              break;\n\t    else if (ch == '&')\n\t    {\n\t      // Possibly a character entity...\n\t      eptr = entity;\n\t      while (eptr < (entity + sizeof(entity) - 1) &&\n\t             (ch = getc(fp)) != EOF)\n\t        if (!isalnum(ch) && ch != '#')\n\t\t  break;\n\t\telse\n\t\t  *eptr++ = (uchar)ch;\n\n              if (ch != ';')\n\t      {\n\t        ungetc(ch, fp);\n\t\tch = 0;\n\t      }\n\n              *eptr = '\\0';\n              if (!ch)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                       *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n\t      }\n\t      else if ((ch = iso8859(entity)) == 0)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                       entity, *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = ';';\n\t      }\n\t      else if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = (uchar)ch;\n\t    }\n            else if (ptr < (value + sizeof(value) - 1) &&\n\t             ch != '\\n' && ch != '\\r')\n            {\n              if ((ch & 0x80) && _htmlUTF8)\n              {\n                // Collect UTF-8 value...\n                ch = utf8_getc(ch, fp);\n              }\n\n              if (ch)\n                *ptr++ = (uchar)ch;\n            }\n\t    else if (ch == '\\n')\n\t    {\n\t      if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = ' ';\n\n\t      (*linenum) ++;\n\t    }\n\t  }\n\n          *ptr = '\\0';\n        }\n        else\n        {\n          *ptr++ = (uchar)ch;\n          while ((ch = getc(fp)) != EOF)\n\t  {\n            if (isspace(ch) || ch == '>' || ch == '\\r')\n              break;\n\t    else if (ch == '&')\n\t    {\n\t      // Possibly a character entity...\n\t      eptr = entity;\n\t      while (eptr < (entity + sizeof(entity) - 1) &&\n\t             (ch = getc(fp)) != EOF)\n\t        if (!isalnum(ch) && ch != '#')\n\t\t  break;\n\t\telse\n\t\t  *eptr++ = (uchar)ch;\n\n              if (ch != ';')\n\t      {\n\t        ungetc(ch, fp);\n\t\tch = 0;\n\t      }\n\n              *eptr = '\\0';\n              if (!ch)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR, \"Unquoted & on line %d of %s.\",\n\t                       *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n\t      }\n\t      else if ((ch = iso8859(entity)) == 0)\n\t      {\n\t\tprogress_error(HD_ERROR_HTML_ERROR,\n\t\t               \"Unknown character entity \\\"&%s;\\\" on line %d of %s.\",\n\t                       entity, *linenum, _htmlCurrentFile);\n\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = '&';\n                strlcpy((char *)ptr, (char *)entity, sizeof(value) - (size_t)(ptr - value));\n\t\tptr += strlen((char *)ptr);\n        \tif (ptr < (value + sizeof(value) - 1))\n\t\t  *ptr++ = ';';\n\t      }\n\t      else if (ptr < (value + sizeof(value) - 1))\n\t        *ptr++ = (uchar)ch;\n\t    }\n            else if (ptr < (value + sizeof(value) - 1))\n            {\n              if ((ch & 0x80) && _htmlUTF8)\n              {\n                // Collect UTF-8 value...\n                ch = utf8_getc(ch, fp);\n              }\n\n              if (ch)\n                *ptr++ = (uchar)ch;\n            }\n\t  }\n\n\t  if (ch == '\\n')\n\t    (*linenum) ++;\n\n          *ptr = '\\0';\n          if (ch == '>')\n            ungetc(ch, fp);\n        }\n\n        return (htmlSetVariable(t, name, value));\n  }\n}\n\n\n/*\n * 'compute_size()' - Compute the width and height of a tree entry.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = failure */\ncompute_size(tree_t *t)\t\t/* I - Tree entry */\n{\n  uchar\t\t*ptr;\t\t/* Current character */\n  float\t\twidth;\t\t/* Current width */\n  int\t\tint_width;\t/* Integer width */\n  uchar\t\t*width_ptr,\t/* Pointer to width string */\n\t\t*height_ptr,\t/* Pointer to height string */\n\t\t*size_ptr,\t/* Pointer to size string */\n\t\t*type_ptr;\t/* Pointer to spacer type string */\n  image_t\t*img;\t\t/* Image */\n  char\t\tnumber[255];\t/* Width or height value */\n\n\n  if (!_htmlInitialized)\n    htmlSetCharSet(\"iso-8859-1\");\n\n  if (t->markup == MARKUP_IMG)\n  {\n    width_ptr  = htmlGetVariable(t, (uchar *)\"WIDTH\");\n    height_ptr = htmlGetVariable(t, (uchar *)\"HEIGHT\");\n\n    img = image_load((char *)htmlGetVariable(t, (uchar *)\"REALSRC\"),\n                     _htmlGrayscale);\n\n    if (width_ptr != NULL && height_ptr != NULL)\n    {\n      t->width  = (float)(atoi((char *)width_ptr) / _htmlPPI * 72.0f);\n      t->height = (float)(atoi((char *)height_ptr) / _htmlPPI * 72.0f);\n\n      return (0);\n    }\n\n    if (img == NULL)\n      return (-1);\n\n    if (width_ptr != NULL)\n    {\n      t->width  = (float)(atoi((char *)width_ptr) / _htmlPPI * 72.0f);\n      t->height = (float)(t->width * img->height / img->width);\n\n      snprintf(number, sizeof(number), \"%d\", atoi((char *)width_ptr) * img->height / img->width);\n      if (strchr((char *)width_ptr, '%') != NULL)\n        strlcat(number, \"%\", sizeof(number));\n      htmlSetVariable(t, (uchar *)\"HEIGHT\", (uchar *)number);\n    }\n    else if (height_ptr != NULL)\n    {\n      t->height = (float)(atoi((char *)height_ptr) / _htmlPPI * 72.0f);\n      t->width  = (float)(t->height * img->width / img->height);\n\n      snprintf(number, sizeof(number), \"%d\", atoi((char *)height_ptr) * img->width / img->height);\n      if (strchr((char *)height_ptr, '%') != NULL)\n        strlcat(number, \"%\", sizeof(number));\n      htmlSetVariable(t, (uchar *)\"WIDTH\", (uchar *)number);\n    }\n    else\n    {\n      t->width  = (float)(img->width / _htmlPPI * 72.0f);\n      t->height = (float)(img->height / _htmlPPI * 72.0f);\n\n      snprintf(number, sizeof(number), \"%d\", img->width);\n      htmlSetVariable(t, (uchar *)\"WIDTH\", (uchar *)number);\n\n      snprintf(number, sizeof(number), \"%d\", img->height);\n      htmlSetVariable(t, (uchar *)\"HEIGHT\", (uchar *)number);\n    }\n\n    return (0);\n  }\n  else if (t->markup == MARKUP_SPACER)\n  {\n    width_ptr  = htmlGetVariable(t, (uchar *)\"WIDTH\");\n    height_ptr = htmlGetVariable(t, (uchar *)\"HEIGHT\");\n    size_ptr   = htmlGetVariable(t, (uchar *)\"SIZE\");\n    type_ptr   = htmlGetVariable(t, (uchar *)\"TYPE\");\n\n    if (width_ptr != NULL)\n      t->width = (float)(atoi((char *)width_ptr) / _htmlPPI * 72.0f);\n    else if (size_ptr != NULL)\n      t->width = (float)(atoi((char *)size_ptr) / _htmlPPI * 72.0f);\n    else\n      t->width = 1.0f;\n\n    if (height_ptr != NULL)\n      t->height = (float)(atoi((char *)height_ptr) / _htmlPPI * 72.0f);\n    else if (size_ptr != NULL)\n      t->height = (float)(atoi((char *)size_ptr) / _htmlPPI * 72.0f);\n    else\n      t->height = 1.0f;\n\n    if (type_ptr == NULL)\n      return (0);\n\n    if (strcasecmp((char *)type_ptr, \"horizontal\") == 0)\n      t->height = 0.0;\n    else if (strcasecmp((char *)type_ptr, \"vertical\") == 0)\n      t->width = 0.0;\n\n    return (0);\n  }\n  else if (t->markup == MARKUP_BR)\n  {\n    t->width  = 0.0;\n    t->height = (float)_htmlSizes[t->size];\n\n    return (0);\n  }\n  else if (t->preformatted && t->data)\n  {\n    int\t\tmax_width = 0;\t\t/* Maximum width */\n\n    for (int_width = 0, ptr = t->data; *ptr != '\\0'; ptr ++)\n    {\n      if (*ptr == '\\n')\n      {\n        if (int_width > max_width)\n          max_width = int_width;\n\n\tint_width = 0;\n      }\n      else if (*ptr == '\\t')\n        int_width = (int_width + 7) & ~7;\n      else\n        int_width ++;\n    }\n\n    if (int_width > max_width)\n      max_width = int_width;\n\n    if (!_htmlWidthsLoaded[t->typeface][t->style])\n      htmlLoadFontWidths(t->typeface, t->style);\n\n    width = _htmlWidths[t->typeface][t->style][0x20] * max_width * 0.001f;\n  }\n  else if (t->data)\n  {\n    if (!_htmlWidthsLoaded[t->typeface][t->style])\n      htmlLoadFontWidths(t->typeface, t->style);\n\n    for (int_width = 0, ptr = t->data; *ptr != '\\0'; ptr ++)\n      int_width += _htmlWidths[t->typeface][t->style][(int)*ptr & 255];\n\n    width = 0.001f * int_width;\n  }\n  else\n    width = 0.0f;\n\n  t->width  = (float)(width * _htmlSizes[t->size]);\n  t->height = (float)_htmlSizes[t->size];\n\n  DEBUG_printf((\"%swidth = %.1f, height = %.1f\\n\", indent, t->width, t->height));\n\n  return (0);\n}\n\n\n/*\n * 'compute_color()' - Compute the red, green, blue color from the given\n *                     string.\n */\n\nstatic int\ncompute_color(tree_t *t,\t/* I - Tree entry */\n              uchar  *color)\t/* I - Color string */\n{\n  float\trgb[3];\t\t\t/* RGB color */\n\n\n  get_color(color, rgb);\n\n  t->red   = (uchar)(rgb[0] * 255.0f + 0.5f);\n  t->green = (uchar)(rgb[1] * 255.0f + 0.5f);\n  t->blue  = (uchar)(rgb[2] * 255.0f + 0.5f);\n\n  return (0);\n}\n\n\n/*\n * 'get_alignment()' - Get horizontal & vertical alignment values.\n */\n\nstatic int\t\t\t/* O - 0 for success, -1 for failure */\nget_alignment(tree_t *t)\t/* I - Tree entry */\n{\n  uchar\t*align;\t\t\t/* Alignment string */\n\n\n  if ((align = htmlGetVariable(t, (uchar *)\"ALIGN\")) == NULL)\n    align = htmlGetStyle(t, (uchar *)\"text-align\");\n\n  if (align != NULL)\n  {\n    if (!strcasecmp((char *)align, \"left\"))\n      t->halignment = ALIGN_LEFT;\n    else if (!strcasecmp((char *)align, \"center\"))\n      t->halignment = ALIGN_CENTER;\n    else if (!strcasecmp((char *)align, \"right\"))\n      t->halignment = ALIGN_RIGHT;\n    else if (!strcasecmp((char *)align, \"justify\"))\n      t->halignment = ALIGN_JUSTIFY;\n    else if (!strcasecmp((char *)align, \"top\"))\n      t->valignment = ALIGN_TOP;\n    else if (!strcasecmp((char *)align, \"middle\") ||\n             !strcasecmp((char *)align, \"absmiddle\"))\n      t->valignment = ALIGN_MIDDLE;\n    else if (!strcasecmp((char *)align, \"bottom\"))\n      t->valignment = ALIGN_BOTTOM;\n  }\n\n  if ((align = htmlGetVariable(t, (uchar *)\"VALIGN\")) == NULL)\n    align = htmlGetStyle(t, (uchar *)\"vertical-align\");\n\n  if (align != NULL)\n  {\n    if (!strcasecmp((char *)align, \"top\"))\n      t->valignment = ALIGN_TOP;\n    else if (!strcasecmp((char *)align, \"middle\"))\n      t->valignment = ALIGN_MIDDLE;\n    else if (!strcasecmp((char *)align, \"center\"))\n      t->valignment = ALIGN_MIDDLE;\n    else if (!strcasecmp((char *)align, \"bottom\"))\n      t->valignment = ALIGN_BOTTOM;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'fix_filename()' - Fix a filename to be relative to the base directory.\n */\n\nstatic const char *\t\t\t/* O - Fixed filename */\nfix_filename(char *filename,\t\t/* I - Original filename */\n             char *base)\t\t/* I - Base directory */\n{\n  char\t\t*slash;\t\t\t/* Location of slash */\n  char\t\t*tempptr;\t\t/* Pointer into filename */\n  static char\ttemp[1024];\t\t/* Temporary filename */\n  static char\tnewfilename[1024];\t/* New filename */\n\n\n//  printf(\"fix_filename(filename=\\\"%s\\\", base=\\\"%s\\\")\\n\", filename, base);\n\n  if (filename == NULL)\n    return (NULL);\n\n#ifdef DEBUG // to silence Clang static analyzer, totally unnecessary\n  memset(temp, 0, sizeof(temp));\n#endif // DEBUG\n\n  // Unescape filenames as needed...\n  if (strchr(filename, '%') && !strstr(filename, \"//\"))\n  {\n    for (tempptr = temp; *filename && tempptr < (temp + sizeof(temp) - 1);)\n    {\n      if (*filename == '%')\n      {\n        // Decode hex-escaped filename character...\n\tfilename ++;\n\tif (isxdigit(filename[0] & 255) && isxdigit(filename[1] & 255))\n\t{\n\t  if (isdigit(filename[0] & 255))\n\t    *tempptr = (char)((filename[0] - '0') << 4);\n\t  else\n\t    *tempptr = (char)((tolower(filename[0]) - 'a' + 10) << 4);\n\n\t  if (isdigit(filename[1] & 255))\n\t    *tempptr |= filename[1] - '0';\n\t  else\n\t    *tempptr |= tolower(filename[0]) - 'a' + 10;\n\n          tempptr ++;\n\t  filename += 2;\n\t}\n\telse\n\t  *tempptr++ = '%';\n      }\n      else\n        *tempptr++ = *filename++;\n    }\n\n    *tempptr = '\\0';\n    filename = temp;\n  }\n\n  if (strcmp(base, \".\") == 0 || strstr(filename, \"//\") != NULL)\n    return (file_find(Path, filename));\n\n  if (strncmp(filename, \"./\", 2) == 0 ||\n      strncmp(filename, \".\\\\\", 2) == 0)\n    filename += 2;\n\n  if (strncmp(base, \"http://\", 7) == 0 || strncmp(base, \"https://\", 8) == 0)\n  {\n    // Base is a URL...\n    char\tscheme[32],\t\t// URI scheme\n\t\tuserpass[256],\t\t// Username:password\n\t\thost[256],\t\t// Hostname or IP address\n\t\tresource[256];\t\t// Resource path\n    int\t\tport;\t\t\t// Port number\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, base, scheme, sizeof(scheme), userpass, sizeof(userpass), host, sizeof(host), &port, resource, sizeof(resource));\n\n    if (filename[0] == '/')\n    {\n      // Absolute path, so just use the server...\n      httpAssembleURI(HTTP_URI_CODING_ALL, newfilename, sizeof(newfilename), scheme, userpass, host, port, filename);\n    }\n    else\n    {\n      // Relative path, strip the last component from the resource...\n      if ((slash = strrchr(resource, '/')) != NULL)\n\t*slash = '\\0';\n\n      // Handle \"../\" in filename...\n      while (!strncmp(filename, \"../\", 3))\n      {\n\t// Strip one level of directory in the resource\n\tfilename += 3;\n\n\tif ((slash = strrchr(resource, '/')) != NULL)\n\t  *slash = '\\0';\n      }\n\n      // Combine the resource and remaining relative filename to make a URL...\n      httpAssembleURIf(HTTP_URI_CODING_ALL, newfilename, sizeof(newfilename), scheme, userpass, host, port, \"%s/%s\", resource, filename);\n    }\n  }\n  else\n  {\n    // Base is a filename...\n    if (filename[0] == '/' || filename[0] == '\\\\' || base == NULL ||\n\tbase[0] == '\\0' || (isalpha(filename[0]) && filename[1] == ':'))\n    {\n      // No change needed for absolute path...\n      return (file_find(Path, filename));\n    }\n\n    strlcpy(newfilename, base, sizeof(newfilename));\n    base = newfilename;\n\n#if defined(WIN32) || defined(__EMX__)\n    while (!strncmp(filename, \"../\", 3) || !strncmp(filename, \"..\\\\\", 3))\n#else\n    while (!strncmp(filename, \"../\", 3))\n#endif // WIN32 || __EMX__\n    {\n      filename += 3;\n#if defined(WIN32) || defined(__EMX__)\n      if ((slash = strrchr(base, '/')) != NULL)\n        *slash = '\\0';\n      else if ((slash = strrchr(base, '\\\\')) != NULL)\n        *slash = '\\0';\n#else\n      if ((slash = strrchr(base, '/')) != NULL)\n        *slash = '\\0';\n#endif // WIN32 || __EMX__\n      else\n      {\n\tfilename -= 3;\n\tbreak;\n      }\n    }\n\n    if (filename[0] != '/' && *base && base[strlen(base) - 1] != '/')\n      strlcat(newfilename, \"/\", sizeof(newfilename));\n\n    strlcat(newfilename, filename, sizeof(newfilename));\n  }\n\n//  printf(\"    newfilename=\\\"%s\\\"\\n\", newfilename);\n\n  return (file_find(Path, newfilename));\n}\n\n\n//\n// 'html_memory_used()' - Figure out the amount of memory that was used.\n//\n\nstatic int\t\t\t\t// O - Bytes used\nhtml_memory_used(tree_t *t)\t\t// I - Tree node\n{\n  int\ti;\t\t\t\t// Looping var\n  int\tbytes;\t\t\t\t// Bytes used\n\n\n  if (t == NULL)\n    return (0);\n\n  bytes = 0;\n\n  while (t != NULL)\n  {\n    bytes += sizeof(tree_t);\n    bytes += (size_t)t->nvars * sizeof(var_t);\n\n    for (i = 0; i < t->nvars; i ++)\n    {\n      bytes += (strlen((char *)t->vars[i].name) + 8) & (size_t)~7;\n\n      if (t->vars[i].value != NULL)\n        bytes += (strlen((char *)t->vars[i].value) + 8) & (size_t)~7;\n    }\n\n    if (t->data != NULL)\n      bytes += (strlen((char *)t->data) + 8) & (size_t)~7;\n\n    bytes += html_memory_used(t->child);\n\n    t = t->next;\n  }\n\n  return (bytes);\n}\n\n\n//\n// 'htmlDebugStats()' - Display debug statistics for HTML tree memory use.\n//\n\nvoid\nhtmlDebugStats(const char *title,\t// I - Title\n               tree_t     *t)\t\t// I - Document root node\n{\n  const char\t*debug;\t\t\t/* HTMLDOC_DEBUG env var */\n\n\n  if ((debug = getenv(\"HTMLDOC_DEBUG\")) == NULL ||\n      (strstr(debug, \"all\") == NULL && strstr(debug, \"memory\") == NULL))\n    return;\n\n  progress_error(HD_ERROR_NONE, \"DEBUG: %s = %d kbytes\", title,\n                 (html_memory_used(t) + 1023) / 1024);\n}\n\n\n//\n// 'htmlFindFile()' - Find a file in the document.\n//\n\ntree_t *\t\t\t\t// O - Node for file\nhtmlFindFile(tree_t *doc,\t\t// I - Document pointer\n             uchar  *filename)\t\t// I - Filename\n{\n  tree_t\t*tree;\t\t\t// Current node\n  uchar\t\t*treename;\t\t// Filename from node\n\n\n  if (!filename || !doc)\n    return (NULL);\n\n  for (tree = doc; tree; tree = tree->next)\n    if ((treename = htmlGetVariable(tree, (uchar *)\"_HD_FILENAME\")) != NULL &&\n        !strcmp((char *)treename, (char *)filename))\n      return (tree);\n\n  return (NULL);\n}\n\n\n//\n// 'htmlFixLinks()' - Fix the external links in the document.\n//\n\nvoid\nhtmlFixLinks(tree_t *doc,\t\t// I - Top node\n             tree_t *tree,\t\t// I - Current node\n\t     uchar  *base)\t\t// I - Base directory/path\n{\n  uchar\t\t*href;\t\t\t// HREF attribute\n  char\t\tfull_href[1024];\t// Full HREF value\n  const char\t*debug;\t\t\t// HTMLDOC_DEBUG environment variable\n  static int\tshow_debug = -1;\t// Show debug messages?\n\n\n  if (show_debug < 0)\n  {\n    if ((debug = getenv(\"HTMLDOC_DEBUG\")) == NULL ||\n\t(strstr(debug, \"all\") == NULL && strstr(debug, \"links\") == NULL))\n      show_debug = 0;\n    else\n      show_debug = 1;\n\n    if (show_debug)\n      progress_error(HD_ERROR_NONE, \"DEBUG: Updating links in document.\");\n  }\n\n  while (tree)\n  {\n    if (tree->markup == MARKUP_A && base && base[0] &&\n        (href = htmlGetVariable(tree, (uchar *)\"HREF\")) != NULL)\n    {\n      // Check if the link needs to be localized...\n      if (href[0] != '#' && file_method((char *)href) == NULL &&\n          file_method((char *)base) != NULL &&\n\t  htmlFindFile(doc, (uchar *)file_basename((char *)href)) == NULL)\n      {\n        // Yes, localize it...\n\tif (href[0] == '/')\n\t{\n\t  // Absolute URL, just copy scheme, server, etc.\n\t  char *ptr;\t\t\t// Pointer into URL...\n\n\t  strlcpy(full_href, (char *)base, sizeof(full_href));\n\n          if (href[1] == '/')\n\t  {\n\t    // Just use scheme...\n\t    if ((ptr = strstr(full_href, \"//\")) != NULL)\n\t      *ptr ='\\0';\n\t  }\n\t  else if ((ptr = strstr(full_href, \"//\")) != NULL  &&\n\t           (ptr = strchr(ptr + 2, '/')) != NULL)\n\t    *ptr ='\\0';\n\n\t  strlcat(full_href, (char *)href, sizeof(full_href));\n\t}\n\telse if (!strncmp((char *)href, \"./\", 2))\n\t{\n\t  // Relative URL of the form \"./foo/bar\", append href sans\n\t  // \"./\" to base to form full href...\n\t  snprintf(full_href, sizeof(full_href), \"%s/%s\", base, href + 2);\n\t}\n\telse\n\t{\n\t  // Relative URL, append href to base to form full href...\n\t  snprintf(full_href, sizeof(full_href), \"%s/%s\", base, href);\n\t}\n\n        if (show_debug)\n          progress_error(HD_ERROR_NONE, \"DEBUG: Mapping \\\"%s\\\" to \\\"%s\\\"...\", href, full_href);\n\n\thtmlSetVariable(tree, (uchar *)\"_HD_FULL_HREF\", (uchar *)full_href);\n      }\n      else\n      {\n        // No, just mirror the link in the _HD_FULL_HREF attribute...\n\thtmlSetVariable(tree, (uchar *)\"_HD_FULL_HREF\", href);\n      }\n    }\n    else if (tree->markup == MARKUP_FILE)\n      base = htmlGetVariable(tree, (uchar *)\"_HD_BASE\");\n\n    if (tree->child)\n      htmlFixLinks(doc, tree->child, base);\n\n    tree = tree->next;\n  }\n}\n\n\n//\n// 'utf8_getc()' - Get a UTF-8 encoded character.\n//\n\nstatic int                              // O - Unicode equivalent\nutf8_getc(int  ch,                      // I - Initial character\n          FILE *fp)                     // I - File to read from\n{\n  int  ch2 = -1, ch3 = -1;              // Temporary characters\n\n\n  if ((ch & 0xe0) == 0xc0)\n  {\n   /*\n    * Two-byte sequence for 0x80 to 0x7ff...\n    */\n\n    ch  = (ch & 0x1f) << 6;\n    ch2 = getc(fp);\n\n    if ((ch2 & 0xc0) == 0x80)\n      ch |= ch2 & 0x3f;\n    else\n      goto bad_sequence;\n  }\n  else if ((ch & 0xf0) == 0xe0)\n  {\n   /*\n    * Three-byte sequence from 0x800 to 0xffff...\n    */\n\n    ch  = (ch & 0x0f) << 12;\n    ch2 = getc(fp);\n\n    if ((ch2 & 0xc0) == 0x80)\n      ch |= (ch2 & 0x3f) << 6;\n    else\n      goto bad_sequence;\n\n    ch3 = getc(fp);\n\n    if ((ch3 & 0xc0) == 0x80)\n      ch |= ch3 & 0x3f;\n    else\n      goto bad_sequence;\n  }\n  else if (ch & 0x80)\n    goto bad_sequence;\n\n  if (ch == 0xfeff)\n  {\n    // BOMs are invalid in UTF-8 text, but Microsoft insists on still using\n    // them...  Try reading another character...\n    //\n    // TODO: Emit a warning about this...\n    return (utf8_getc(getc(fp), fp));\n  }\n\n  return (htmlMapUnicode(ch));\n\n  bad_sequence:\n\n  if (ch3 >= 0)\n    progress_error(HD_ERROR_READ_ERROR, \"Bad UTF-8 character sequence %02X %02X %02X.\", ch, ch2, ch3);\n  else if (ch2 >= 0)\n    progress_error(HD_ERROR_READ_ERROR, \"Bad UTF-8 character sequence %02X %02X.\", ch, ch2);\n  else\n    progress_error(HD_ERROR_READ_ERROR, \"Bad UTF-8 character sequence %02X.\", ch);\n\n  return (0);\n}\n\n", "/*\n * Test program for HTML parsing routines for HTMLDOC, an HTML document\n * processing program.\n *\n * Copyright 2011-2017 by Michael R Sweet.\n * Copyright 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#define _HTMLDOC_CXX_\n#include \"htmldoc.h\"\n\n\nvoid\tprefs_load(void) { }\nvoid\tprefs_save(void) { }\n\nstatic void     show_tree(tree_t *t, int indent);\n\n\n/*\n * 'main()' - Main entry for test program.\n */\n\nint\t\t\t\t/* O - Exit status */\nmain(int  argc,\t\t\t/* I - Number of command-line arguments */\n     char *argv[])\t\t/* I - Command-line arguments */\n{\n  int\t\ti;\t\t/* Looping var */\n  FILE\t\t*fp;\t\t/* Input file */\n  tree_t\t*t,\t\t/* HTML markup tree */\n\t\t*doc,\t\t/* HTML document */\n\t\t*toc;\t\t/* Table of contents */\n  char\t\tbase[1024];\t/* Base directory */\n  int           tree = 0;       /* Show parsing tree */\n\n\n#ifdef DEBUG\n  printf(\"MARKUP_NONE=%d\\n\", MARKUP_NONE);\n  printf(\"MARKUP_COMMENT=%d\\n\", MARKUP_COMMENT);\n  printf(\"MARKUP_A=%d\\n\", MARKUP_A);\n  printf(\"MARKUP_ADDRESS=%d\\n\", MARKUP_ADDRESS);\n  printf(\"MARKUP_APPLET=%d\\n\", MARKUP_APPLET);\n  printf(\"MARKUP_AREA=%d\\n\", MARKUP_AREA);\n  printf(\"MARKUP_B=%d\\n\", MARKUP_B);\n  printf(\"MARKUP_BASE=%d\\n\", MARKUP_BASE);\n  printf(\"MARKUP_BASEFONT=%d\\n\", MARKUP_BASEFONT);\n  printf(\"MARKUP_BIG=%d\\n\", MARKUP_BIG);\n  printf(\"MARKUP_BLINK=%d\\n\", MARKUP_BLINK);\n  printf(\"MARKUP_BLOCKQUOTE=%d\\n\", MARKUP_BLOCKQUOTE);\n  printf(\"MARKUP_BODY=%d\\n\", MARKUP_BODY);\n  printf(\"MARKUP_BR=%d\\n\", MARKUP_BR);\n  printf(\"MARKUP_CAPTION=%d\\n\", MARKUP_CAPTION);\n  printf(\"MARKUP_CENTER=%d\\n\", MARKUP_CENTER);\n  printf(\"MARKUP_CITE=%d\\n\", MARKUP_CITE);\n  printf(\"MARKUP_CODE=%d\\n\", MARKUP_CODE);\n  printf(\"MARKUP_DD=%d\\n\", MARKUP_DD);\n  printf(\"MARKUP_DFN=%d\\n\", MARKUP_DFN);\n  printf(\"MARKUP_DIR=%d\\n\", MARKUP_DIR);\n  printf(\"MARKUP_DIV=%d\\n\", MARKUP_DIV);\n  printf(\"MARKUP_DL=%d\\n\", MARKUP_DL);\n  printf(\"MARKUP_DT=%d\\n\", MARKUP_DT);\n  printf(\"MARKUP_EM=%d\\n\", MARKUP_EM);\n  printf(\"MARKUP_EMBED=%d\\n\", MARKUP_EMBED);\n  printf(\"MARKUP_FONT=%d\\n\", MARKUP_FONT);\n  printf(\"MARKUP_FORM=%d\\n\", MARKUP_FORM);\n  printf(\"MARKUP_FRAME=%d\\n\", MARKUP_FRAME);\n  printf(\"MARKUP_FRAMESET=%d\\n\", MARKUP_FRAMESET);\n  printf(\"MARKUP_H1=%d\\n\", MARKUP_H1);\n  printf(\"MARKUP_H2=%d\\n\", MARKUP_H2);\n  printf(\"MARKUP_H3=%d\\n\", MARKUP_H3);\n  printf(\"MARKUP_H4=%d\\n\", MARKUP_H4);\n  printf(\"MARKUP_H5=%d\\n\", MARKUP_H5);\n  printf(\"MARKUP_H6=%d\\n\", MARKUP_H6);\n  printf(\"MARKUP_H7=%d\\n\", MARKUP_H7);\n  printf(\"MARKUP_HEAD=%d\\n\", MARKUP_HEAD);\n  printf(\"MARKUP_HR=%d\\n\", MARKUP_HR);\n  printf(\"MARKUP_HTML=%d\\n\", MARKUP_HTML);\n  printf(\"MARKUP_I=%d\\n\", MARKUP_I);\n  printf(\"MARKUP_IMG=%d\\n\", MARKUP_IMG);\n  printf(\"MARKUP_INPUT=%d\\n\", MARKUP_INPUT);\n  printf(\"MARKUP_ISINDEX=%d\\n\", MARKUP_ISINDEX);\n  printf(\"MARKUP_KBD=%d\\n\", MARKUP_KBD);\n  printf(\"MARKUP_LI=%d\\n\", MARKUP_LI);\n  printf(\"MARKUP_LINK=%d\\n\", MARKUP_LINK);\n  printf(\"MARKUP_MAP=%d\\n\", MARKUP_MAP);\n  printf(\"MARKUP_MENU=%d\\n\", MARKUP_MENU);\n  printf(\"MARKUP_META=%d\\n\", MARKUP_META);\n  printf(\"MARKUP_MULTICOL=%d\\n\", MARKUP_MULTICOL);\n  printf(\"MARKUP_NOBR=%d\\n\", MARKUP_NOBR);\n  printf(\"MARKUP_NOFRAMES=%d\\n\", MARKUP_NOFRAMES);\n  printf(\"MARKUP_OL=%d\\n\", MARKUP_OL);\n  printf(\"MARKUP_OPTION=%d\\n\", MARKUP_OPTION);\n  printf(\"MARKUP_P=%d\\n\", MARKUP_P);\n  printf(\"MARKUP_PRE=%d\\n\", MARKUP_PRE);\n  printf(\"MARKUP_S=%d\\n\", MARKUP_S);\n  printf(\"MARKUP_SAMP=%d\\n\", MARKUP_SAMP);\n  printf(\"MARKUP_SCRIPT=%d\\n\", MARKUP_SCRIPT);\n  printf(\"MARKUP_SELECT=%d\\n\", MARKUP_SELECT);\n  printf(\"MARKUP_SMALL=%d\\n\", MARKUP_SMALL);\n  printf(\"MARKUP_SPACER=%d\\n\", MARKUP_SPACER);\n  printf(\"MARKUP_STRIKE=%d\\n\", MARKUP_STRIKE);\n  printf(\"MARKUP_STRONG=%d\\n\", MARKUP_STRONG);\n  printf(\"MARKUP_STYLE=%d\\n\", MARKUP_STYLE);\n  printf(\"MARKUP_SUB=%d\\n\", MARKUP_SUB);\n  printf(\"MARKUP_SUP=%d\\n\", MARKUP_SUP);\n  printf(\"MARKUP_TABLE=%d\\n\", MARKUP_TABLE);\n  printf(\"MARKUP_TD=%d\\n\", MARKUP_TD);\n  printf(\"MARKUP_TEXTAREA=%d\\n\", MARKUP_TEXTAREA);\n  printf(\"MARKUP_TH=%d\\n\", MARKUP_TH);\n  printf(\"MARKUP_TITLE=%d\\n\", MARKUP_TITLE);\n  printf(\"MARKUP_TR=%d\\n\", MARKUP_TR);\n  printf(\"MARKUP_TT=%d\\n\", MARKUP_TT);\n  printf(\"MARKUP_U=%d\\n\", MARKUP_U);\n  printf(\"MARKUP_UL=%d\\n\", MARKUP_UL);\n  printf(\"MARKUP_VAR=%d\\n\", MARKUP_VAR);\n  printf(\"MARKUP_WBR=%d\\n\", MARKUP_WBR);\n#endif /* DEBUG */\n\n  _htmlData = \"..\";\n\n  if (argc < 2)\n  {\n    fputs(\"Usage: testhtml [--tree] filename.html\\n\", stderr);\n    return (1);\n  };\n\n  for (i = 1, doc = NULL; i < argc; i ++)\n  {\n    if (!strcmp(argv[i], \"--tree\"))\n      tree = 1;\n    else if (argv[i][0] == '-')\n    {\n      fprintf(stderr, \"Unknown option '%s'.\\n\", argv[i]);\n      fputs(\"Usage: testhtml [--tree] filename.html\\n\", stderr);\n      return (1);\n    }\n    else if ((fp = fopen(file_find(\"\", argv[i]), \"r\")) != NULL)\n    {\n      strlcpy(base, argv[i], sizeof(base));\n      if (strrchr(base, '/') != NULL)\n        *strrchr(base, '/') = '\\0';\n      else\n        base[0] = '\\0';\n\n      t = htmlReadFile(NULL, fp, base);\n      fclose(fp);\n\n      if (t != NULL)\n      {\n        if (doc == NULL)\n        {\n          doc = t;\n        }\n        else\n        {\n          doc->next = t;\n          t->prev   = doc;\n        }\n      }\n    }\n    else\n    {\n      fprintf(stderr, \"testhtml: Unable to open input file \\'%s\\'!\\n\", argv[i]);\n    }\n  }\n\n  if (doc != NULL)\n  {\n    toc = toc_build(doc);\n\n    if (tree)\n    {\n      show_tree(doc, 0);\n      puts(\"---- TABLE OF CONTENTS ----\");\n      show_tree(toc, 0);\n    }\n    else\n    {\n      htmlWriteFile(doc, stdout);\n      puts(\"---- TABLE OF CONTENTS ----\");\n      htmlWriteFile(toc, stdout);\n    }\n  }\n\n  return (doc == NULL);\n}\n\n\n/*\n * 'show_tree()' - Show the parsing tree...\n */\n\nstatic void\nshow_tree(tree_t *t,                    /* I - Parent node */\n          int    indent)                /* I - Indentation */\n{\n  static const char * const markups[] =\n  {\n    \"FILE\",\n    \"UNKNOWN\",\n    \"ERROR\"\n  };\n\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else if (t->markup > MARKUP_NONE)\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", markups[t->markup - MARKUP_FILE]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}\n\n\n#ifdef HAVE_LIBFLTK\nvoid\nGUI::progress(int        percent,\t// I - Percent complete\n              const char *text)\t\t// I - Text prompt\n{\n  (void)percent;\n  (void)text;\n}\n#endif /* HAVE_LIBFLTK */\n"], "filenames": ["CHANGES.md", "htmldoc/htmllib.cxx", "htmldoc/testhtml.cxx"], "buggy_code_start_loc": [9, 4, 202], "buggy_code_end_loc": [9, 2141, 209], "fixing_code_start_loc": [10, 4, 203], "fixing_code_end_loc": [11, 2141, 218], "type": "CWE-787", "message": "HTMLDoc v1.9.15 was discovered to contain a heap overflow via (write_header) /htmldoc/htmldoc/html.cxx:273.", "other": {"cve": {"id": "CVE-2022-34033", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-18T21:15:08.083", "lastModified": "2022-07-27T17:43:19.433", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HTMLDoc v1.9.15 was discovered to contain a heap overflow via (write_header) /htmldoc/htmldoc/html.cxx:273."}, {"lang": "es", "value": "Se ha detectado que HTMLDoc versi\u00f3n v1.9.15, contiene un desbordamiento de pila por medio de (write_header) /htmldoc/htmldoc/html.cxx:273"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htmldoc_project:htmldoc:1.9.15:*:*:*:*:*:*:*", "matchCriteriaId": "7FA48CA3-3C4E-46CA-8B5E-FDBF99FDD55F"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/htmldoc/commit/a0014be47d614220db111b360fb6170ef6f3937e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/commit/ee778252faebb721afba5a081dd6ad7eaf20eef3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/issues/425", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/htmldoc/commit/a0014be47d614220db111b360fb6170ef6f3937e"}}