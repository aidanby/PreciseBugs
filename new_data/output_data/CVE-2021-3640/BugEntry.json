{"buggy_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth SCO sockets. */\n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/sco.h>\n\nstatic bool disable_esco;\n\nstatic const struct proto_ops sco_sock_ops;\n\nstatic struct bt_sock_list sco_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(sco_sk_list.lock)\n};\n\n/* ---- SCO connections ---- */\nstruct sco_conn {\n\tstruct hci_conn\t*hcon;\n\n\tspinlock_t\tlock;\n\tstruct sock\t*sk;\n\n\tstruct delayed_work\ttimeout_work;\n\n\tunsigned int    mtu;\n};\n\n#define sco_conn_lock(c)\tspin_lock(&c->lock)\n#define sco_conn_unlock(c)\tspin_unlock(&c->lock)\n\nstatic void sco_sock_close(struct sock *sk);\nstatic void sco_sock_kill(struct sock *sk);\n\n/* ----- SCO socket info ----- */\n#define sco_pi(sk) ((struct sco_pinfo *) sk)\n\nstruct sco_pinfo {\n\tstruct bt_sock\tbt;\n\tbdaddr_t\tsrc;\n\tbdaddr_t\tdst;\n\t__u32\t\tflags;\n\t__u16\t\tsetting;\n\t__u8\t\tcmsg_mask;\n\tstruct sco_conn\t*conn;\n};\n\n/* ---- SCO timers ---- */\n#define SCO_CONN_TIMEOUT\t(HZ * 40)\n#define SCO_DISCONN_TIMEOUT\t(HZ * 2)\n\nstatic void sco_sock_timeout(struct work_struct *work)\n{\n\tstruct sco_conn *conn = container_of(work, struct sco_conn,\n\t\t\t\t\t     timeout_work.work);\n\tstruct sock *sk;\n\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tsco_conn_unlock(conn);\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tlock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void sco_sock_set_timer(struct sock *sk, long timeout)\n{\n\tif (!sco_pi(sk)->conn)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tcancel_delayed_work(&sco_pi(sk)->conn->timeout_work);\n\tschedule_delayed_work(&sco_pi(sk)->conn->timeout_work, timeout);\n}\n\nstatic void sco_sock_clear_timer(struct sock *sk)\n{\n\tif (!sco_pi(sk)->conn)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tcancel_delayed_work(&sco_pi(sk)->conn->timeout_work);\n}\n\n/* ---- SCO connections ---- */\nstatic struct sco_conn *sco_conn_add(struct hci_conn *hcon)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (conn)\n\t\treturn conn;\n\n\tconn = kzalloc(sizeof(struct sco_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\n\tspin_lock_init(&conn->lock);\n\n\thcon->sco_data = conn;\n\tconn->hcon = hcon;\n\n\tif (hdev->sco_mtu > 0)\n\t\tconn->mtu = hdev->sco_mtu;\n\telse\n\t\tconn->mtu = 60;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\treturn conn;\n}\n\n/* Delete channel.\n * Must be called on the locked socket. */\nstatic void sco_chan_del(struct sock *sk, int err)\n{\n\tstruct sco_conn *conn;\n\n\tconn = sco_pi(sk)->conn;\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\tsco_conn_lock(conn);\n\t\tconn->sk = NULL;\n\t\tsco_pi(sk)->conn = NULL;\n\t\tsco_conn_unlock(conn);\n\n\t\tif (conn->hcon)\n\t\t\thci_conn_drop(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsk->sk_err   = err;\n\tsk->sk_state_change(sk);\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n}\n\nstatic void sco_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t/* Kill socket */\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsco_chan_del(sk, err);\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\n\t\t/* Ensure no more work items will run before freeing conn. */\n\t\tcancel_delayed_work_sync(&conn->timeout_work);\n\t}\n\n\thcon->sco_data = NULL;\n\tkfree(conn);\n}\n\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\t   struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n}\n\nstatic int sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\tstruct sock *parent)\n{\n\tint err = 0;\n\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\n\tsco_conn_unlock(conn);\n\treturn err;\n}\n\nstatic int sco_connect(struct hci_dev *hdev, struct sock *sk)\n{\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tint err, type;\n\n\tBT_DBG(\"%pMR -> %pMR\", &sco_pi(sk)->src, &sco_pi(sk)->dst);\n\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\n\tif (sco_pi(sk)->setting == BT_VOICE_TRANSPARENT &&\n\t    (!lmp_transp_capable(hdev) || !lmp_esco_capable(hdev)))\n\t\treturn -EOPNOTSUPP;\n\n\thcon = hci_connect_sco(hdev, type, &sco_pi(sk)->dst,\n\t\t\t       sco_pi(sk)->setting);\n\tif (IS_ERR(hcon))\n\t\treturn PTR_ERR(hcon);\n\n\tconn = sco_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(&sco_pi(sk)->src, &hcon->src);\n\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\n\n\treturn err;\n}\n\nstatic int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* Check outgoing MTU */\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\thci_send_sco(conn->hcon, skb);\n\n\treturn len;\n}\n\nstatic void sco_recv_frame(struct sco_conn *conn, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p len %u\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\treturn;\n\ndrop:\n\tkfree_skb(skb);\n}\n\n/* -------- Socket interface ---------- */\nstatic struct sock *__sco_get_sock_listen_by_addr(bdaddr_t *ba)\n{\n\tstruct sock *sk;\n\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&sco_pi(sk)->src, ba))\n\t\t\treturn sk;\n\t}\n\n\treturn NULL;\n}\n\n/* Find socket listening on source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *sco_get_sock_listen(bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\n\tread_lock(&sco_sk_list.lock);\n\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\t/* Exact match. */\n\t\tif (!bacmp(&sco_pi(sk)->src, src))\n\t\t\tbreak;\n\n\t\t/* Closest match */\n\t\tif (!bacmp(&sco_pi(sk)->src, BDADDR_ANY))\n\t\t\tsk1 = sk;\n\t}\n\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn sk ? sk : sk1;\n}\n\nstatic void sco_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void sco_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&sco_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __sco_sock_close(struct sock *sk)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tsco_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (sco_pi(sk)->conn->hcon) {\n\t\t\tsk->sk_state = BT_DISCONN;\n\t\t\tsco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);\n\t\t\tsco_conn_lock(sco_pi(sk)->conn);\n\t\t\thci_conn_drop(sco_pi(sk)->conn->hcon);\n\t\t\tsco_pi(sk)->conn->hcon = NULL;\n\t\t\tsco_conn_unlock(sco_pi(sk)->conn);\n\t\t} else\n\t\t\tsco_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tsco_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Must be called on unlocked socket. */\nstatic void sco_sock_close(struct sock *sk)\n{\n\tlock_sock(sk);\n\tsco_sock_clear_timer(sk);\n\t__sco_sock_close(sk);\n\trelease_sock(sk);\n}\n\nstatic void sco_skb_put_cmsg(struct sk_buff *skb, struct msghdr *msg,\n\t\t\t     struct sock *sk)\n{\n\tif (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS)\n\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t sizeof(bt_cb(skb)->sco.pkt_status),\n\t\t\t &bt_cb(skb)->sco.pkt_status);\n}\n\nstatic void sco_sock_init(struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tbt_sk(sk)->skb_put_cmsg = sco_skb_put_cmsg;\n\t}\n}\n\nstatic struct proto sco_proto = {\n\t.name\t\t= \"SCO\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct sco_pinfo)\n};\n\nstatic struct sock *sco_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t   int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = sco_sock_destruct;\n\tsk->sk_sndtimeo = SCO_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\tsco_pi(sk)->setting = BT_VOICE_CVSD_16BIT;\n\n\tbt_sock_link(&sco_sk_list, sk);\n\treturn sk;\n}\n\nstatic int sco_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &sco_sock_ops;\n\n\tsk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsco_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tif (!addr || addr_len < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev  *hdev;\n\tint err;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\thdev = hci_get_route(&sa->sco_bdaddr, &sco_pi(sk)->src, BDADDR_BREDR);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock(hdev);\n\n\tlock_sock(sk);\n\n\t/* Set destination address and psm */\n\tbacpy(&sco_pi(sk)->dst, &sa->sco_bdaddr);\n\n\terr = sco_connect(hdev, sk);\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\tif (err)\n\t\tgoto done;\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tbdaddr_t *src = &sco_pi(sk)->src;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&sco_sk_list.lock);\n\n\tif (__sco_get_sock_listen_by_addr(src)) {\n\t\terr = -EADDRINUSE;\n\t\tgoto unlock;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tsk->sk_state = BT_LISTEN;\n\nunlock:\n\twrite_unlock(&sco_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t   int flags, bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *ch;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tch = bt_accept_dequeue(sk, newsock);\n\t\tif (ch)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tlock_sock(sk);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", ch);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int peer)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\n\tif (peer)\n\t\tbacpy(&sa->sco_bdaddr, &sco_pi(sk)->dst);\n\telse\n\t\tbacpy(&sa->sco_bdaddr, &sco_pi(sk)->src);\n\n\treturn sizeof(struct sockaddr_sco);\n}\n\nstatic int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void sco_conn_defer_accept(struct hci_conn *conn, u16 setting)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tconn->state = BT_CONFIG;\n\n\tif (!lmp_esco_capable(hdev)) {\n\t\tstruct hci_cp_accept_conn_req cp;\n\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.role = 0x00; /* Ignored */\n\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp), &cp);\n\t} else {\n\t\tstruct hci_cp_accept_sync_conn_req cp;\n\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.pkt_type = cpu_to_le16(conn->pkt_type);\n\n\t\tcp.tx_bandwidth   = cpu_to_le32(0x00001f40);\n\t\tcp.rx_bandwidth   = cpu_to_le32(0x00001f40);\n\t\tcp.content_format = cpu_to_le16(setting);\n\n\t\tswitch (setting & SCO_AIRMODE_MASK) {\n\t\tcase SCO_AIRMODE_TRANSP:\n\t\t\tif (conn->pkt_type & ESCO_2EV3)\n\t\t\t\tcp.max_latency = cpu_to_le16(0x0008);\n\t\t\telse\n\t\t\t\tcp.max_latency = cpu_to_le16(0x000D);\n\t\t\tcp.retrans_effort = 0x02;\n\t\t\tbreak;\n\t\tcase SCO_AIRMODE_CVSD:\n\t\t\tcp.max_latency = cpu_to_le16(0xffff);\n\t\t\tcp.retrans_effort = 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* use CVSD settings as fallback */\n\t\t\tcp.max_latency = cpu_to_le16(0xffff);\n\t\t\tcp.retrans_effort = 0xff;\n\t\t\tbreak;\n\t\t}\n\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,\n\t\t\t     sizeof(cp), &cp);\n\t}\n}\n\nstatic int sco_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(sock, msg, len, flags);\n}\n\nstatic int sco_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\tbreak;\n\n\tcase BT_VOICE:\n\t\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND &&\n\t\t    sk->sk_state != BT_CONNECT2) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvoice.setting = sco_pi(sk)->setting;\n\n\t\tlen = min_t(unsigned int, sizeof(voice), optlen);\n\t\tif (copy_from_sockptr(&voice, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Explicitly check for these values */\n\t\tif (voice.setting != BT_VOICE_TRANSPARENT &&\n\t\t    voice.setting != BT_VOICE_CVSD_16BIT) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsco_pi(sk)->setting = voice.setting;\n\t\tbreak;\n\n\tcase BT_PKT_STATUS:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tsco_pi(sk)->cmsg_mask |= SCO_CMSG_PKT_STATUS;\n\t\telse\n\t\t\tsco_pi(sk)->cmsg_mask &= SCO_CMSG_PKT_STATUS;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt_old(struct socket *sock, int optname,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %u\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tsco_sock_clear_timer(sk);\n\t\t__sco_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t sk->sk_lingertime);\n\t}\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int sco_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsco_sock_close(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING)) {\n\t\tlock_sock(sk);\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t\trelease_sock(sk);\n\t}\n\n\tsock_orphan(sk);\n\tsco_sock_kill(sk);\n\treturn err;\n}\n\nstatic void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\trelease_sock(sk);\n\t} else {\n\t\tsco_conn_lock(conn);\n\n\t\tif (!conn->hcon) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\n\t\tparent = sco_get_sock_listen(&conn->hcon->src);\n\t\tif (!parent) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\n\t\tlock_sock(parent);\n\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\t    BTPROTO_SCO, GFP_ATOMIC, 0);\n\t\tif (!sk) {\n\t\t\trelease_sock(parent);\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\n\t\tsco_sock_init(sk, parent);\n\n\t\tbacpy(&sco_pi(sk)->src, &conn->hcon->src);\n\t\tbacpy(&sco_pi(sk)->dst, &conn->hcon->dst);\n\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\n\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\telse\n\t\t\tsk->sk_state = BT_CONNECTED;\n\n\t\t/* Wake up parent */\n\t\tparent->sk_data_ready(parent);\n\n\t\trelease_sock(parent);\n\n\t\tsco_conn_unlock(conn);\n\t}\n}\n\n/* ----- SCO interface with lower layer (HCI) ----- */\nint sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags)\n{\n\tstruct sock *sk;\n\tint lm = 0;\n\n\tBT_DBG(\"hdev %s, bdaddr %pMR\", hdev->name, bdaddr);\n\n\t/* Find listening sockets */\n\tread_lock(&sco_sk_list.lock);\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&sco_pi(sk)->src, &hdev->bdaddr) ||\n\t\t    !bacmp(&sco_pi(sk)->src, BDADDR_ANY)) {\n\t\t\tlm |= HCI_LM_ACCEPT;\n\n\t\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))\n\t\t\t\t*flags |= HCI_PROTO_DEFER;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn lm;\n}\n\nstatic void sco_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p bdaddr %pMR status %u\", hcon, &hcon->dst, status);\n\n\tif (!status) {\n\t\tstruct sco_conn *conn;\n\n\t\tconn = sco_conn_add(hcon);\n\t\tif (conn)\n\t\t\tsco_conn_ready(conn);\n\t} else\n\t\tsco_conn_del(hcon, bt_to_errno(status));\n}\n\nstatic void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)\n{\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tsco_conn_del(hcon, bt_to_errno(reason));\n}\n\nvoid sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %u\", conn, skb->len);\n\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic struct hci_cb sco_cb = {\n\t.name\t\t= \"SCO\",\n\t.connect_cfm\t= sco_connect_cfm,\n\t.disconn_cfm\t= sco_disconn_cfm,\n};\n\nstatic int sco_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\n\tread_lock(&sco_sk_list.lock);\n\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tseq_printf(f, \"%pMR %pMR %d\\n\", &sco_pi(sk)->src,\n\t\t\t   &sco_pi(sk)->dst, sk->sk_state);\n\t}\n\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sco_debugfs);\n\nstatic struct dentry *sco_debugfs;\n\nstatic const struct proto_ops sco_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= sco_sock_release,\n\t.bind\t\t= sco_sock_bind,\n\t.connect\t= sco_sock_connect,\n\t.listen\t\t= sco_sock_listen,\n\t.accept\t\t= sco_sock_accept,\n\t.getname\t= sco_sock_getname,\n\t.sendmsg\t= sco_sock_sendmsg,\n\t.recvmsg\t= sco_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= sco_sock_shutdown,\n\t.setsockopt\t= sco_sock_setsockopt,\n\t.getsockopt\t= sco_sock_getsockopt\n};\n\nstatic const struct net_proto_family sco_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= sco_sock_create,\n};\n\nint __init sco_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_sco) > sizeof(struct sockaddr));\n\n\terr = proto_register(&sco_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_SCO, &sco_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"SCO socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"sco\", &sco_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create SCO proc file\");\n\t\tbt_sock_unregister(BTPROTO_SCO);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"SCO socket layer initialized\");\n\n\thci_register_cb(&sco_cb);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\tsco_debugfs = debugfs_create_file(\"sco\", 0444, bt_debugfs,\n\t\t\t\t\t  NULL, &sco_debugfs_fops);\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&sco_proto);\n\treturn err;\n}\n\nvoid sco_exit(void)\n{\n\tbt_procfs_cleanup(&init_net, \"sco\");\n\n\tdebugfs_remove(sco_debugfs);\n\n\thci_unregister_cb(&sco_cb);\n\n\tbt_sock_unregister(BTPROTO_SCO);\n\n\tproto_unregister(&sco_proto);\n}\n\nmodule_param(disable_esco, bool, 0644);\nMODULE_PARM_DESC(disable_esco, \"Disable eSCO connection creation\");\n"], "fixing_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth SCO sockets. */\n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/sco.h>\n\nstatic bool disable_esco;\n\nstatic const struct proto_ops sco_sock_ops;\n\nstatic struct bt_sock_list sco_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(sco_sk_list.lock)\n};\n\n/* ---- SCO connections ---- */\nstruct sco_conn {\n\tstruct hci_conn\t*hcon;\n\n\tspinlock_t\tlock;\n\tstruct sock\t*sk;\n\n\tstruct delayed_work\ttimeout_work;\n\n\tunsigned int    mtu;\n};\n\n#define sco_conn_lock(c)\tspin_lock(&c->lock)\n#define sco_conn_unlock(c)\tspin_unlock(&c->lock)\n\nstatic void sco_sock_close(struct sock *sk);\nstatic void sco_sock_kill(struct sock *sk);\n\n/* ----- SCO socket info ----- */\n#define sco_pi(sk) ((struct sco_pinfo *) sk)\n\nstruct sco_pinfo {\n\tstruct bt_sock\tbt;\n\tbdaddr_t\tsrc;\n\tbdaddr_t\tdst;\n\t__u32\t\tflags;\n\t__u16\t\tsetting;\n\t__u8\t\tcmsg_mask;\n\tstruct sco_conn\t*conn;\n};\n\n/* ---- SCO timers ---- */\n#define SCO_CONN_TIMEOUT\t(HZ * 40)\n#define SCO_DISCONN_TIMEOUT\t(HZ * 2)\n\nstatic void sco_sock_timeout(struct work_struct *work)\n{\n\tstruct sco_conn *conn = container_of(work, struct sco_conn,\n\t\t\t\t\t     timeout_work.work);\n\tstruct sock *sk;\n\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tsco_conn_unlock(conn);\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\n\tlock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void sco_sock_set_timer(struct sock *sk, long timeout)\n{\n\tif (!sco_pi(sk)->conn)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d timeout %ld\", sk, sk->sk_state, timeout);\n\tcancel_delayed_work(&sco_pi(sk)->conn->timeout_work);\n\tschedule_delayed_work(&sco_pi(sk)->conn->timeout_work, timeout);\n}\n\nstatic void sco_sock_clear_timer(struct sock *sk)\n{\n\tif (!sco_pi(sk)->conn)\n\t\treturn;\n\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tcancel_delayed_work(&sco_pi(sk)->conn->timeout_work);\n}\n\n/* ---- SCO connections ---- */\nstatic struct sco_conn *sco_conn_add(struct hci_conn *hcon)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (conn)\n\t\treturn conn;\n\n\tconn = kzalloc(sizeof(struct sco_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\n\tspin_lock_init(&conn->lock);\n\n\thcon->sco_data = conn;\n\tconn->hcon = hcon;\n\n\tif (hdev->sco_mtu > 0)\n\t\tconn->mtu = hdev->sco_mtu;\n\telse\n\t\tconn->mtu = 60;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\treturn conn;\n}\n\n/* Delete channel.\n * Must be called on the locked socket. */\nstatic void sco_chan_del(struct sock *sk, int err)\n{\n\tstruct sco_conn *conn;\n\n\tconn = sco_pi(sk)->conn;\n\n\tBT_DBG(\"sk %p, conn %p, err %d\", sk, conn, err);\n\n\tif (conn) {\n\t\tsco_conn_lock(conn);\n\t\tconn->sk = NULL;\n\t\tsco_pi(sk)->conn = NULL;\n\t\tsco_conn_unlock(conn);\n\n\t\tif (conn->hcon)\n\t\t\thci_conn_drop(conn->hcon);\n\t}\n\n\tsk->sk_state = BT_CLOSED;\n\tsk->sk_err   = err;\n\tsk->sk_state_change(sk);\n\n\tsock_set_flag(sk, SOCK_ZAPPED);\n}\n\nstatic void sco_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t/* Kill socket */\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsco_chan_del(sk, err);\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\n\t\t/* Ensure no more work items will run before freeing conn. */\n\t\tcancel_delayed_work_sync(&conn->timeout_work);\n\t}\n\n\thcon->sco_data = NULL;\n\tkfree(conn);\n}\n\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\t   struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n}\n\nstatic int sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\tstruct sock *parent)\n{\n\tint err = 0;\n\n\tsco_conn_lock(conn);\n\tif (conn->sk)\n\t\terr = -EBUSY;\n\telse\n\t\t__sco_chan_add(conn, sk, parent);\n\n\tsco_conn_unlock(conn);\n\treturn err;\n}\n\nstatic int sco_connect(struct hci_dev *hdev, struct sock *sk)\n{\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tint err, type;\n\n\tBT_DBG(\"%pMR -> %pMR\", &sco_pi(sk)->src, &sco_pi(sk)->dst);\n\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\n\tif (sco_pi(sk)->setting == BT_VOICE_TRANSPARENT &&\n\t    (!lmp_transp_capable(hdev) || !lmp_esco_capable(hdev)))\n\t\treturn -EOPNOTSUPP;\n\n\thcon = hci_connect_sco(hdev, type, &sco_pi(sk)->dst,\n\t\t\t       sco_pi(sk)->setting);\n\tif (IS_ERR(hcon))\n\t\treturn PTR_ERR(hcon);\n\n\tconn = sco_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(&sco_pi(sk)->src, &hcon->src);\n\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\n\n\treturn err;\n}\n\nstatic int sco_send_frame(struct sock *sk, void *buf, int len,\n\t\t\t  unsigned int msg_flags)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* Check outgoing MTU */\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\tskb = bt_skb_send_alloc(sk, len, msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tmemcpy(skb_put(skb, len), buf, len);\n\thci_send_sco(conn->hcon, skb);\n\n\treturn len;\n}\n\nstatic void sco_recv_frame(struct sco_conn *conn, struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\n\tif (!sk)\n\t\tgoto drop;\n\n\tBT_DBG(\"sk %p len %u\", sk, skb->len);\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (!sock_queue_rcv_skb(sk, skb))\n\t\treturn;\n\ndrop:\n\tkfree_skb(skb);\n}\n\n/* -------- Socket interface ---------- */\nstatic struct sock *__sco_get_sock_listen_by_addr(bdaddr_t *ba)\n{\n\tstruct sock *sk;\n\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&sco_pi(sk)->src, ba))\n\t\t\treturn sk;\n\t}\n\n\treturn NULL;\n}\n\n/* Find socket listening on source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *sco_get_sock_listen(bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\n\tread_lock(&sco_sk_list.lock);\n\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\t/* Exact match. */\n\t\tif (!bacmp(&sco_pi(sk)->src, src))\n\t\t\tbreak;\n\n\t\t/* Closest match */\n\t\tif (!bacmp(&sco_pi(sk)->src, BDADDR_ANY))\n\t\t\tsk1 = sk;\n\t}\n\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn sk ? sk : sk1;\n}\n\nstatic void sco_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void sco_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d\", sk, sk->sk_state);\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&sco_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __sco_sock_close(struct sock *sk)\n{\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\tsco_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (sco_pi(sk)->conn->hcon) {\n\t\t\tsk->sk_state = BT_DISCONN;\n\t\t\tsco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);\n\t\t\tsco_conn_lock(sco_pi(sk)->conn);\n\t\t\thci_conn_drop(sco_pi(sk)->conn->hcon);\n\t\t\tsco_pi(sk)->conn->hcon = NULL;\n\t\t\tsco_conn_unlock(sco_pi(sk)->conn);\n\t\t} else\n\t\t\tsco_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tsco_chan_del(sk, ECONNRESET);\n\t\tbreak;\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Must be called on unlocked socket. */\nstatic void sco_sock_close(struct sock *sk)\n{\n\tlock_sock(sk);\n\tsco_sock_clear_timer(sk);\n\t__sco_sock_close(sk);\n\trelease_sock(sk);\n}\n\nstatic void sco_skb_put_cmsg(struct sk_buff *skb, struct msghdr *msg,\n\t\t\t     struct sock *sk)\n{\n\tif (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS)\n\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t sizeof(bt_cb(skb)->sco.pkt_status),\n\t\t\t &bt_cb(skb)->sco.pkt_status);\n}\n\nstatic void sco_sock_init(struct sock *sk, struct sock *parent)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tbt_sk(sk)->skb_put_cmsg = sco_skb_put_cmsg;\n\t}\n}\n\nstatic struct proto sco_proto = {\n\t.name\t\t= \"SCO\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct sco_pinfo)\n};\n\nstatic struct sock *sco_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t   int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = sco_sock_destruct;\n\tsk->sk_sndtimeo = SCO_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\tsco_pi(sk)->setting = BT_VOICE_CVSD_16BIT;\n\n\tbt_sock_link(&sco_sk_list, sk);\n\treturn sk;\n}\n\nstatic int sco_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t   int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &sco_sock_ops;\n\n\tsk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsco_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tif (!addr || addr_len < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev  *hdev;\n\tint err;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\thdev = hci_get_route(&sa->sco_bdaddr, &sco_pi(sk)->src, BDADDR_BREDR);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock(hdev);\n\n\tlock_sock(sk);\n\n\t/* Set destination address and psm */\n\tbacpy(&sco_pi(sk)->dst, &sa->sco_bdaddr);\n\n\terr = sco_connect(hdev, sk);\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\tif (err)\n\t\tgoto done;\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tbdaddr_t *src = &sco_pi(sk)->src;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&sco_sk_list.lock);\n\n\tif (__sco_get_sock_listen_by_addr(src)) {\n\t\terr = -EADDRINUSE;\n\t\tgoto unlock;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tsk->sk_state = BT_LISTEN;\n\nunlock:\n\twrite_unlock(&sco_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t   int flags, bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *ch;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tch = bt_accept_dequeue(sk, newsock);\n\t\tif (ch)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tlock_sock(sk);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", ch);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int peer)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\n\tif (peer)\n\t\tbacpy(&sa->sco_bdaddr, &sco_pi(sk)->dst);\n\telse\n\t\tbacpy(&sa->sco_bdaddr, &sco_pi(sk)->src);\n\n\treturn sizeof(struct sockaddr_sco);\n}\n\nstatic int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}\n\nstatic void sco_conn_defer_accept(struct hci_conn *conn, u16 setting)\n{\n\tstruct hci_dev *hdev = conn->hdev;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tconn->state = BT_CONFIG;\n\n\tif (!lmp_esco_capable(hdev)) {\n\t\tstruct hci_cp_accept_conn_req cp;\n\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.role = 0x00; /* Ignored */\n\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp), &cp);\n\t} else {\n\t\tstruct hci_cp_accept_sync_conn_req cp;\n\n\t\tbacpy(&cp.bdaddr, &conn->dst);\n\t\tcp.pkt_type = cpu_to_le16(conn->pkt_type);\n\n\t\tcp.tx_bandwidth   = cpu_to_le32(0x00001f40);\n\t\tcp.rx_bandwidth   = cpu_to_le32(0x00001f40);\n\t\tcp.content_format = cpu_to_le16(setting);\n\n\t\tswitch (setting & SCO_AIRMODE_MASK) {\n\t\tcase SCO_AIRMODE_TRANSP:\n\t\t\tif (conn->pkt_type & ESCO_2EV3)\n\t\t\t\tcp.max_latency = cpu_to_le16(0x0008);\n\t\t\telse\n\t\t\t\tcp.max_latency = cpu_to_le16(0x000D);\n\t\t\tcp.retrans_effort = 0x02;\n\t\t\tbreak;\n\t\tcase SCO_AIRMODE_CVSD:\n\t\t\tcp.max_latency = cpu_to_le16(0xffff);\n\t\t\tcp.retrans_effort = 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* use CVSD settings as fallback */\n\t\t\tcp.max_latency = cpu_to_le16(0xffff);\n\t\t\tcp.retrans_effort = 0xff;\n\t\t\tbreak;\n\t\t}\n\n\t\thci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,\n\t\t\t     sizeof(cp), &cp);\n\t}\n}\n\nstatic int sco_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(sock, msg, len, flags);\n}\n\nstatic int sco_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\tbreak;\n\n\tcase BT_VOICE:\n\t\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND &&\n\t\t    sk->sk_state != BT_CONNECT2) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvoice.setting = sco_pi(sk)->setting;\n\n\t\tlen = min_t(unsigned int, sizeof(voice), optlen);\n\t\tif (copy_from_sockptr(&voice, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Explicitly check for these values */\n\t\tif (voice.setting != BT_VOICE_TRANSPARENT &&\n\t\t    voice.setting != BT_VOICE_CVSD_16BIT) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsco_pi(sk)->setting = voice.setting;\n\t\tbreak;\n\n\tcase BT_PKT_STATUS:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tsco_pi(sk)->cmsg_mask |= SCO_CMSG_PKT_STATUS;\n\t\telse\n\t\t\tsco_pi(sk)->cmsg_mask &= SCO_CMSG_PKT_STATUS;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt_old(struct socket *sock, int optname,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %u\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sco_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tsco_sock_clear_timer(sk);\n\t\t__sco_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t\t sk->sk_lingertime);\n\t}\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int sco_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsco_sock_close(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING)) {\n\t\tlock_sock(sk);\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t\trelease_sock(sk);\n\t}\n\n\tsock_orphan(sk);\n\tsco_sock_kill(sk);\n\treturn err;\n}\n\nstatic void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\trelease_sock(sk);\n\t} else {\n\t\tsco_conn_lock(conn);\n\n\t\tif (!conn->hcon) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\n\t\tparent = sco_get_sock_listen(&conn->hcon->src);\n\t\tif (!parent) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\n\t\tlock_sock(parent);\n\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\t    BTPROTO_SCO, GFP_ATOMIC, 0);\n\t\tif (!sk) {\n\t\t\trelease_sock(parent);\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\n\t\tsco_sock_init(sk, parent);\n\n\t\tbacpy(&sco_pi(sk)->src, &conn->hcon->src);\n\t\tbacpy(&sco_pi(sk)->dst, &conn->hcon->dst);\n\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\n\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\telse\n\t\t\tsk->sk_state = BT_CONNECTED;\n\n\t\t/* Wake up parent */\n\t\tparent->sk_data_ready(parent);\n\n\t\trelease_sock(parent);\n\n\t\tsco_conn_unlock(conn);\n\t}\n}\n\n/* ----- SCO interface with lower layer (HCI) ----- */\nint sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags)\n{\n\tstruct sock *sk;\n\tint lm = 0;\n\n\tBT_DBG(\"hdev %s, bdaddr %pMR\", hdev->name, bdaddr);\n\n\t/* Find listening sockets */\n\tread_lock(&sco_sk_list.lock);\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&sco_pi(sk)->src, &hdev->bdaddr) ||\n\t\t    !bacmp(&sco_pi(sk)->src, BDADDR_ANY)) {\n\t\t\tlm |= HCI_LM_ACCEPT;\n\n\t\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))\n\t\t\t\t*flags |= HCI_PROTO_DEFER;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn lm;\n}\n\nstatic void sco_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p bdaddr %pMR status %u\", hcon, &hcon->dst, status);\n\n\tif (!status) {\n\t\tstruct sco_conn *conn;\n\n\t\tconn = sco_conn_add(hcon);\n\t\tif (conn)\n\t\t\tsco_conn_ready(conn);\n\t} else\n\t\tsco_conn_del(hcon, bt_to_errno(status));\n}\n\nstatic void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)\n{\n\tif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tsco_conn_del(hcon, bt_to_errno(reason));\n}\n\nvoid sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %u\", conn, skb->len);\n\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic struct hci_cb sco_cb = {\n\t.name\t\t= \"SCO\",\n\t.connect_cfm\t= sco_connect_cfm,\n\t.disconn_cfm\t= sco_disconn_cfm,\n};\n\nstatic int sco_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\n\tread_lock(&sco_sk_list.lock);\n\n\tsk_for_each(sk, &sco_sk_list.head) {\n\t\tseq_printf(f, \"%pMR %pMR %d\\n\", &sco_pi(sk)->src,\n\t\t\t   &sco_pi(sk)->dst, sk->sk_state);\n\t}\n\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sco_debugfs);\n\nstatic struct dentry *sco_debugfs;\n\nstatic const struct proto_ops sco_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= sco_sock_release,\n\t.bind\t\t= sco_sock_bind,\n\t.connect\t= sco_sock_connect,\n\t.listen\t\t= sco_sock_listen,\n\t.accept\t\t= sco_sock_accept,\n\t.getname\t= sco_sock_getname,\n\t.sendmsg\t= sco_sock_sendmsg,\n\t.recvmsg\t= sco_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= sco_sock_shutdown,\n\t.setsockopt\t= sco_sock_setsockopt,\n\t.getsockopt\t= sco_sock_getsockopt\n};\n\nstatic const struct net_proto_family sco_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= sco_sock_create,\n};\n\nint __init sco_init(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_sco) > sizeof(struct sockaddr));\n\n\terr = proto_register(&sco_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_SCO, &sco_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"SCO socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"sco\", &sco_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create SCO proc file\");\n\t\tbt_sock_unregister(BTPROTO_SCO);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"SCO socket layer initialized\");\n\n\thci_register_cb(&sco_cb);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\tsco_debugfs = debugfs_create_file(\"sco\", 0444, bt_debugfs,\n\t\t\t\t\t  NULL, &sco_debugfs_fops);\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&sco_proto);\n\treturn err;\n}\n\nvoid sco_exit(void)\n{\n\tbt_procfs_cleanup(&init_net, \"sco\");\n\n\tdebugfs_remove(sco_debugfs);\n\n\thci_unregister_cb(&sco_cb);\n\n\tbt_sock_unregister(BTPROTO_SCO);\n\n\tproto_unregister(&sco_proto);\n}\n\nmodule_param(disable_esco, bool, 0644);\nMODULE_PARM_DESC(disable_esco, \"Disable eSCO connection creation\");\n"], "filenames": ["net/bluetooth/sco.c"], "buggy_code_start_loc": [283], "buggy_code_end_loc": [746], "fixing_code_start_loc": [283], "fixing_code_end_loc": [755], "type": "CWE-362", "message": "A flaw use-after-free in function sco_sock_sendmsg() of the Linux kernel HCI subsystem was found in the way user calls ioct UFFDIO_REGISTER or other way triggers race condition of the call sco_conn_del() together with the call sco_sock_sendmsg() with the expected controllable faulting memory page. A privileged local user could use this flaw to crash the system or escalate their privileges on the system.", "other": {"cve": {"id": "CVE-2021-3640", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-03T23:15:08.197", "lastModified": "2023-02-12T23:41:41.777", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw use-after-free in function sco_sock_sendmsg() of the Linux kernel HCI subsystem was found in the way user calls ioct UFFDIO_REGISTER or other way triggers race condition of the call sco_conn_del() together with the call sco_sock_sendmsg() with the expected controllable faulting memory page. A privileged local user could use this flaw to crash the system or escalate their privileges on the system."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo de uso de memoria previamente liberada en la funci\u00f3n sco_sock_sendmsg() del subsistema HCI del kernel de Linux en la forma en que el usuario llama a ioct UFFDIO_REGISTER o de otra manera desencadena una condici\u00f3n de carrera de la llamada sco_conn_del() junto con la llamada sco_sock_sendmsg() con la p\u00e1gina de memoria de fallo controlable esperada. Un usuario local privilegiado podr\u00eda usar este fallo para bloquear el sistema o escalar sus privilegios en el sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.15.3", "matchCriteriaId": "CEAFF076-B22B-4EC1-BBFE-58641EF7705F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:21.10:*:*:*:*:*:*:*", "matchCriteriaId": "AAE4D2D0-CEEB-416F-8BC5-A7987DF56190"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1980646", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/bluetooth/sco.c?h=v5.16&id=99c23da0eed4fd20cae8243f2b51e10e66aa0951", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/99c23da0eed4fd20cae8243f2b51e10e66aa0951", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220419-0003/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://ubuntu.com/security/CVE-2021-3640", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5096", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/07/22/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/99c23da0eed4fd20cae8243f2b51e10e66aa0951"}}