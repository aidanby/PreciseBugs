{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"sha1.h\"\n#include \"rand.h\"\n#include \"cluster.h\"\n\n#include <lua.h>\n#include <lauxlib.h>\n#include <lualib.h>\n#include <ctype.h>\n#include <math.h>\n\nchar *redisProtocolToLuaType_Int(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Status(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Error(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype);\nchar *redisProtocolToLuaType_Null(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Bool(lua_State *lua, char *reply, int tf);\nchar *redisProtocolToLuaType_Double(lua_State *lua, char *reply);\nint redis_math_random (lua_State *L);\nint redis_math_randomseed (lua_State *L);\nvoid ldbInit(void);\nvoid ldbDisable(client *c);\nvoid ldbEnable(client *c);\nvoid evalGenericCommandWithDebugging(client *c, int evalsha);\nvoid luaLdbLineHook(lua_State *lua, lua_Debug *ar);\nvoid ldbLog(sds entry);\nvoid ldbLogRedisReply(char *reply);\nsds ldbCatStackValue(sds s, lua_State *lua, int idx);\n\n/* Debugger shared state is stored inside this global structure. */\n#define LDB_BREAKPOINTS_MAX 64  /* Max number of breakpoints. */\n#define LDB_MAX_LEN_DEFAULT 256 /* Default len limit for replies / var dumps. */\nstruct ldbState {\n    connection *conn; /* Connection of the debugging client. */\n    int active; /* Are we debugging EVAL right now? */\n    int forked; /* Is this a fork()ed debugging session? */\n    list *logs; /* List of messages to send to the client. */\n    list *traces; /* Messages about Redis commands executed since last stop.*/\n    list *children; /* All forked debugging sessions pids. */\n    int bp[LDB_BREAKPOINTS_MAX]; /* An array of breakpoints line numbers. */\n    int bpcount; /* Number of valid entries inside bp. */\n    int step;   /* Stop at next line regardless of breakpoints. */\n    int luabp;  /* Stop at next line because redis.breakpoint() was called. */\n    sds *src;   /* Lua script source code split by line. */\n    int lines;  /* Number of lines in 'src'. */\n    int currentline;    /* Current line number. */\n    sds cbuf;   /* Debugger client command buffer. */\n    size_t maxlen;  /* Max var dump / reply length. */\n    int maxlen_hint_sent; /* Did we already hint about \"set maxlen\"? */\n} ldb;\n\n/* ---------------------------------------------------------------------------\n * Utility functions.\n * ------------------------------------------------------------------------- */\n\n/* Perform the SHA1 of the input string. We use this both for hashing script\n * bodies in order to obtain the Lua function name, and in the implementation\n * of redis.sha1().\n *\n * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an\n * hexadecimal number, plus 1 byte for null term. */\nvoid sha1hex(char *digest, char *script, size_t len) {\n    SHA1_CTX ctx;\n    unsigned char hash[20];\n    char *cset = \"0123456789abcdef\";\n    int j;\n\n    SHA1Init(&ctx);\n    SHA1Update(&ctx,(unsigned char*)script,len);\n    SHA1Final(hash,&ctx);\n\n    for (j = 0; j < 20; j++) {\n        digest[j*2] = cset[((hash[j]&0xF0)>>4)];\n        digest[j*2+1] = cset[(hash[j]&0xF)];\n    }\n    digest[40] = '\\0';\n}\n\n/* ---------------------------------------------------------------------------\n * Redis reply to Lua type conversion functions.\n * ------------------------------------------------------------------------- */\n\n/* Take a Redis reply in the Redis protocol format and convert it into a\n * Lua type. Thanks to this function, and the introduction of not connected\n * clients, it is trivial to implement the redis() lua function.\n *\n * Basically we take the arguments, execute the Redis command in the context\n * of a non connected client, then take the generated reply and convert it\n * into a suitable Lua type. With this trick the scripting feature does not\n * need the introduction of a full Redis internals API. The script\n * is like a normal client that bypasses all the slow I/O paths.\n *\n * Note: in this function we do not do any sanity check as the reply is\n * generated by Redis directly. This allows us to go faster.\n *\n * Errors are returned as a table with a single 'err' field set to the\n * error string.\n */\n\nchar *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    char *p = reply;\n\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}\n\nchar *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long value;\n\n    string2ll(reply+1,p-reply-1,&value);\n    lua_pushnumber(lua,(lua_Number)value);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long bulklen;\n\n    string2ll(reply+1,p-reply-1,&bulklen);\n    if (bulklen == -1) {\n        lua_pushboolean(lua,0);\n        return p+2;\n    } else {\n        lua_pushlstring(lua,p+2,bulklen);\n        return p+2+bulklen+2;\n    }\n}\n\nchar *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"ok\");\n    lua_pushlstring(lua,reply+1,p-reply-1);\n    lua_settable(lua,-3);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"err\");\n    lua_pushlstring(lua,reply+1,p-reply-1);\n    lua_settable(lua,-3);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        /* Here we handle only Set and Map replies in RESP3 mode, since arrays\n         * follow the above RESP2 code path. Note that those are represented\n         * as a table with the \"map\" or \"set\" field populated with the actual\n         * table representing the set or the map type. */\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}\n\nchar *redisProtocolToLuaType_Null(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    lua_pushnil(lua);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Bool(lua_State *lua, char *reply, int tf) {\n    char *p = strchr(reply+1,'\\r');\n    lua_pushboolean(lua,tf == 't');\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Double(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    char buf[MAX_LONG_DOUBLE_CHARS+1];\n    size_t len = p-reply-1;\n    double d;\n\n    if (len <= MAX_LONG_DOUBLE_CHARS) {\n        memcpy(buf,reply+1,len);\n        buf[len] = '\\0';\n        d = strtod(buf,NULL); /* We expect a valid representation. */\n    } else {\n        d = 0;\n    }\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"double\");\n    lua_pushnumber(lua,d);\n    lua_settable(lua,-3);\n    return p+2;\n}\n\n/* This function is used in order to push an error on the Lua stack in the\n * format used by redis.pcall to return errors, which is a lua table\n * with a single \"err\" field set to the error string. Note that this\n * table is never a valid reply by proper commands, since the returned\n * tables are otherwise always indexed by integers, never by strings. */\nvoid luaPushError(lua_State *lua, char *error) {\n    lua_Debug dbg;\n\n    /* If debugging is active and in step mode, log errors resulting from\n     * Redis commands. */\n    if (ldb.active && ldb.step) {\n        ldbLog(sdscatprintf(sdsempty(),\"<error> %s\",error));\n    }\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"err\");\n\n    /* Attempt to figure out where this function was called, if possible */\n    if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, \"nSl\", &dbg)) {\n        sds msg = sdscatprintf(sdsempty(), \"%s: %d: %s\",\n            dbg.source, dbg.currentline, error);\n        lua_pushstring(lua, msg);\n        sdsfree(msg);\n    } else {\n        lua_pushstring(lua, error);\n    }\n    lua_settable(lua,-3);\n}\n\n/* In case the error set into the Lua stack by luaPushError() was generated\n * by the non-error-trapping version of redis.pcall(), which is redis.call(),\n * this function will raise the Lua error so that the execution of the\n * script will be halted. */\nint luaRaiseError(lua_State *lua) {\n    lua_pushstring(lua,\"err\");\n    lua_gettable(lua,-2);\n    return lua_error(lua);\n}\n\n/* Sort the array currently in the stack. We do this to make the output\n * of commands like KEYS or SMEMBERS something deterministic when called\n * from Lua (to play well with AOf/replication).\n *\n * The array is sorted using table.sort itself, and assuming all the\n * list elements are strings. */\nvoid luaSortArray(lua_State *lua) {\n    /* Initial Stack: array */\n    lua_getglobal(lua,\"table\");\n    lua_pushstring(lua,\"sort\");\n    lua_gettable(lua,-2);       /* Stack: array, table, table.sort */\n    lua_pushvalue(lua,-3);      /* Stack: array, table, table.sort, array */\n    if (lua_pcall(lua,1,0,0)) {\n        /* Stack: array, table, error */\n\n        /* We are not interested in the error, we assume that the problem is\n         * that there are 'false' elements inside the array, so we try\n         * again with a slower function but able to handle this case, that\n         * is: table.sort(table, __redis__compare_helper) */\n        lua_pop(lua,1);             /* Stack: array, table */\n        lua_pushstring(lua,\"sort\"); /* Stack: array, table, sort */\n        lua_gettable(lua,-2);       /* Stack: array, table, table.sort */\n        lua_pushvalue(lua,-3);      /* Stack: array, table, table.sort, array */\n        lua_getglobal(lua,\"__redis__compare_helper\");\n        /* Stack: array, table, table.sort, array, __redis__compare_helper */\n        lua_call(lua,2,0);\n    }\n    /* Stack: array (sorted), table */\n    lua_pop(lua,1);             /* Stack: array (sorted) */\n}\n\n/* ---------------------------------------------------------------------------\n * Lua reply to Redis reply conversion functions.\n * ------------------------------------------------------------------------- */\n\n/* Reply to client 'c' converting the top element in the Lua stack to a\n * Redis reply. As a side effect the element is consumed from the stack.  */\nvoid luaReplyToRedisReply(client *c, lua_State *lua) {\n    int t = lua_type(lua,-1);\n\n    switch(t) {\n    case LUA_TSTRING:\n        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n        break;\n    case LUA_TBOOLEAN:\n        if (server.lua_client->resp == 2)\n            addReply(c,lua_toboolean(lua,-1) ? shared.cone :\n                                               shared.null[c->resp]);\n        else\n            addReplyBool(c,lua_toboolean(lua,-1));\n        break;\n    case LUA_TNUMBER:\n        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));\n        break;\n    case LUA_TTABLE:\n        /* We need to check if it is an array, an error, or a status reply.\n         * Error are returned as a single element table with 'err' field.\n         * Status replies are returned as single element table with 'ok'\n         * field. */\n\n        /* Handle error reply. */\n        lua_pushstring(lua,\"err\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds err = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(err,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"-%s\\r\\n\",err));\n            sdsfree(err);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle status reply. */\n        lua_pushstring(lua,\"ok\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds ok = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(ok,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"+%s\\r\\n\",ok));\n            sdsfree(ok);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle double reply. */\n        lua_pushstring(lua,\"double\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TNUMBER) {\n            addReplyDouble(c,lua_tonumber(lua,-1));\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle map reply. */\n        lua_pushstring(lua,\"map\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int maplen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, value */\n                lua_pushvalue(lua,-2);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                luaReplyToRedisReply(c, lua); /* Return value. */\n                /* Stack now: table, key. */\n                maplen++;\n            }\n            setDeferredMapLen(c,replylen,maplen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle set reply. */\n        lua_pushstring(lua,\"set\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int setlen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, true */\n                lua_pop(lua,1);               /* Discard the boolean value. */\n                lua_pushvalue(lua,-1);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                /* Stack now: table, key. */\n                setlen++;\n            }\n            setDeferredSetLen(c,replylen,setlen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle the array reply. */\n        void *replylen = addReplyDeferredLen(c);\n        int j = 1, mbulklen = 0;\n        while(1) {\n            lua_pushnumber(lua,j++);\n            lua_gettable(lua,-2);\n            t = lua_type(lua,-1);\n            if (t == LUA_TNIL) {\n                lua_pop(lua,1);\n                break;\n            }\n            luaReplyToRedisReply(c, lua);\n            mbulklen++;\n        }\n        setDeferredArrayLen(c,replylen,mbulklen);\n        break;\n    default:\n        addReplyNull(c);\n    }\n    lua_pop(lua,1);\n}\n\n/* ---------------------------------------------------------------------------\n * Lua redis.* functions implementations.\n * ------------------------------------------------------------------------- */\n\n#define LUA_CMD_OBJCACHE_SIZE 32\n#define LUA_CMD_OBJCACHE_MAX_LEN 64\nint luaRedisGenericCommand(lua_State *lua, int raise_error) {\n    int j, argc = lua_gettop(lua);\n    struct redisCommand *cmd;\n    client *c = server.lua_client;\n    sds reply;\n\n    /* Cached across calls. */\n    static robj **argv = NULL;\n    static int argv_size = 0;\n    static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];\n    static size_t cached_objects_len[LUA_CMD_OBJCACHE_SIZE];\n    static int inuse = 0;   /* Recursive calls detection. */\n\n    /* By using Lua debug hooks it is possible to trigger a recursive call\n     * to luaRedisGenericCommand(), which normally should never happen.\n     * To make this function reentrant is futile and makes it slower, but\n     * we should at least detect such a misuse, and abort. */\n    if (inuse) {\n        char *recursion_warning =\n            \"luaRedisGenericCommand() recursive call detected. \"\n            \"Are you doing funny stuff with Lua debug hooks?\";\n        serverLog(LL_WARNING,\"%s\",recursion_warning);\n        luaPushError(lua,recursion_warning);\n        return 1;\n    }\n    inuse++;\n\n    /* Require at least one argument */\n    if (argc == 0) {\n        luaPushError(lua,\n            \"Please specify at least one argument for redis.call()\");\n        inuse--;\n        return raise_error ? luaRaiseError(lua) : 1;\n    }\n\n    /* Build the arguments vector */\n    if (argv_size < argc) {\n        argv = zrealloc(argv,sizeof(robj*)*argc);\n        argv_size = argc;\n    }\n\n    for (j = 0; j < argc; j++) {\n        char *obj_s;\n        size_t obj_len;\n        char dbuf[64];\n\n        if (lua_type(lua,j+1) == LUA_TNUMBER) {\n            /* We can't use lua_tolstring() for number -> string conversion\n             * since Lua uses a format specifier that loses precision. */\n            lua_Number num = lua_tonumber(lua,j+1);\n\n            obj_len = snprintf(dbuf,sizeof(dbuf),\"%.17g\",(double)num);\n            obj_s = dbuf;\n        } else {\n            obj_s = (char*)lua_tolstring(lua,j+1,&obj_len);\n            if (obj_s == NULL) break; /* Not a string. */\n        }\n\n        /* Try to use a cached object. */\n        if (j < LUA_CMD_OBJCACHE_SIZE && cached_objects[j] &&\n            cached_objects_len[j] >= obj_len)\n        {\n            sds s = cached_objects[j]->ptr;\n            argv[j] = cached_objects[j];\n            cached_objects[j] = NULL;\n            memcpy(s,obj_s,obj_len+1);\n            sdssetlen(s, obj_len);\n        } else {\n            argv[j] = createStringObject(obj_s, obj_len);\n        }\n    }\n\n    /* Check if one of the arguments passed by the Lua script\n     * is not a string or an integer (lua_isstring() return true for\n     * integers as well). */\n    if (j != argc) {\n        j--;\n        while (j >= 0) {\n            decrRefCount(argv[j]);\n            j--;\n        }\n        luaPushError(lua,\n            \"Lua redis() command arguments must be strings or integers\");\n        inuse--;\n        return raise_error ? luaRaiseError(lua) : 1;\n    }\n\n    /* Setup our fake client for command execution */\n    c->argv = argv;\n    c->argc = argc;\n    c->user = server.lua_caller->user;\n\n    /* Process module hooks */\n    moduleCallCommandFilters(c);\n    argv = c->argv;\n    argc = c->argc;\n\n    /* Log the command if debugging is active. */\n    if (ldb.active && ldb.step) {\n        sds cmdlog = sdsnew(\"<redis>\");\n        for (j = 0; j < c->argc; j++) {\n            if (j == 10) {\n                cmdlog = sdscatprintf(cmdlog,\" ... (%d more)\",\n                    c->argc-j-1);\n                break;\n            } else {\n                cmdlog = sdscatlen(cmdlog,\" \",1);\n                cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);\n            }\n        }\n        ldbLog(cmdlog);\n    }\n\n    /* Command lookup */\n    cmd = lookupCommand(argv[0]->ptr);\n    if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) ||\n                   (argc < -cmd->arity)))\n    {\n        if (cmd)\n            luaPushError(lua,\n                \"Wrong number of args calling Redis command From Lua script\");\n        else\n            luaPushError(lua,\"Unknown Redis command called from Lua script\");\n        goto cleanup;\n    }\n    c->cmd = c->lastcmd = cmd;\n\n    /* There are commands that are not allowed inside scripts. */\n    if (cmd->flags & CMD_NOSCRIPT) {\n        luaPushError(lua, \"This Redis command is not allowed from scripts\");\n        goto cleanup;\n    }\n\n    /* Check the ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            luaPushError(lua, \"The user executing the script can't run this \"\n                              \"command or subcommand\");\n        else\n            luaPushError(lua, \"The user executing the script can't access \"\n                              \"at least one of the keys mentioned in the \"\n                              \"command arguments\");\n        goto cleanup;\n    }\n\n    /* Write commands are forbidden against read-only slaves, or if a\n     * command marked as non-deterministic was already called in the context\n     * of this script. */\n    if (cmd->flags & CMD_WRITE) {\n        int deny_write_type = writeCommandsDeniedByDiskError();\n        if (server.lua_random_dirty && !server.lua_replicate_commands) {\n            luaPushError(lua,\n                \"Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.\");\n            goto cleanup;\n        } else if (server.masterhost && server.repl_slave_ro &&\n                   !server.loading &&\n                   !(server.lua_caller->flags & CLIENT_MASTER))\n        {\n            luaPushError(lua, shared.roslaveerr->ptr);\n            goto cleanup;\n        } else if (deny_write_type != DISK_ERROR_TYPE_NONE) {\n            if (deny_write_type == DISK_ERROR_TYPE_RDB) {\n                luaPushError(lua, shared.bgsaveerr->ptr);\n            } else {\n                sds aof_write_err = sdscatfmt(sdsempty(),\n                    \"-MISCONF Errors writing to the AOF file: %s\\r\\n\",\n                    strerror(server.aof_last_write_errno));\n                luaPushError(lua, aof_write_err);\n                sdsfree(aof_write_err);\n            }\n            goto cleanup;\n        }\n    }\n\n    /* If we reached the memory limit configured via maxmemory, commands that\n     * could enlarge the memory usage are not allowed, but only if this is the\n     * first write in the context of this script, otherwise we can't stop\n     * in the middle. */\n    if (server.maxmemory &&             /* Maxmemory is actually enabled. */\n        !server.loading &&              /* Don't care about mem if loading. */\n        !server.masterhost &&           /* Slave must execute the script. */\n        server.lua_write_dirty == 0 &&  /* Script had no side effects so far. */\n        server.lua_oom &&               /* Detected OOM when script start. */\n        (cmd->flags & CMD_DENYOOM))\n    {\n        luaPushError(lua, shared.oomerr->ptr);\n        goto cleanup;\n    }\n\n    if (cmd->flags & CMD_RANDOM) server.lua_random_dirty = 1;\n    if (cmd->flags & CMD_WRITE) server.lua_write_dirty = 1;\n\n    /* If this is a Redis Cluster node, we need to make sure Lua is not\n     * trying to access non-local keys, with the exception of commands\n     * received from our master or when loading the AOF back in memory. */\n    if (server.cluster_enabled && !server.loading &&\n        !(server.lua_caller->flags & CLIENT_MASTER))\n    {\n        int error_code;\n        /* Duplicate relevant flags in the lua client. */\n        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);\n        c->flags |= server.lua_caller->flags & (CLIENT_READONLY|CLIENT_ASKING);\n        if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,&error_code) !=\n                           server.cluster->myself)\n        {\n            if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) { \n                luaPushError(lua,\n                    \"Lua script attempted to execute a write command while the \"\n                    \"cluster is down and readonly\");\n            } else if (error_code == CLUSTER_REDIR_DOWN_STATE) { \n                luaPushError(lua,\n                    \"Lua script attempted to execute a command while the \"\n                    \"cluster is down\");\n            } else {\n                luaPushError(lua,\n                    \"Lua script attempted to access a non local key in a \"\n                    \"cluster node\");\n            }\n\n            goto cleanup;\n        }\n    }\n\n    /* If we are using single commands replication, we need to wrap what\n     * we propagate into a MULTI/EXEC block, so that it will be atomic like\n     * a Lua script in the context of AOF and slaves. */\n    if (server.lua_replicate_commands &&\n        !server.lua_multi_emitted &&\n        !(server.lua_caller->flags & CLIENT_MULTI) &&\n        server.lua_write_dirty &&\n        server.lua_repl != PROPAGATE_NONE)\n    {\n        execCommandPropagateMulti(server.lua_caller);\n        server.lua_multi_emitted = 1;\n        /* Now we are in the MULTI context, the lua_client should be\n         * flag as CLIENT_MULTI. */\n        c->flags |= CLIENT_MULTI;\n    }\n\n    /* Run the command */\n    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;\n    if (server.lua_replicate_commands) {\n        /* Set flags according to redis.set_repl() settings. */\n        if (server.lua_repl & PROPAGATE_AOF)\n            call_flags |= CMD_CALL_PROPAGATE_AOF;\n        if (server.lua_repl & PROPAGATE_REPL)\n            call_flags |= CMD_CALL_PROPAGATE_REPL;\n    }\n    call(c,call_flags);\n\n    /* Convert the result of the Redis command into a suitable Lua type.\n     * The first thing we need is to create a single string from the client\n     * output buffers. */\n    if (listLength(c->reply) == 0 && c->bufpos < PROTO_REPLY_CHUNK_BYTES) {\n        /* This is a fast path for the common case of a reply inside the\n         * client static buffer. Don't create an SDS string but just use\n         * the client buffer directly. */\n        c->buf[c->bufpos] = '\\0';\n        reply = c->buf;\n        c->bufpos = 0;\n    } else {\n        reply = sdsnewlen(c->buf,c->bufpos);\n        c->bufpos = 0;\n        while(listLength(c->reply)) {\n            clientReplyBlock *o = listNodeValue(listFirst(c->reply));\n\n            reply = sdscatlen(reply,o->buf,o->used);\n            listDelNode(c->reply,listFirst(c->reply));\n        }\n    }\n    if (raise_error && reply[0] != '-') raise_error = 0;\n    redisProtocolToLuaType(lua,reply);\n\n    /* If the debugger is active, log the reply from Redis. */\n    if (ldb.active && ldb.step)\n        ldbLogRedisReply(reply);\n\n    /* Sort the output array if needed, assuming it is a non-null multi bulk\n     * reply as expected. */\n    if ((cmd->flags & CMD_SORT_FOR_SCRIPT) &&\n        (server.lua_replicate_commands == 0) &&\n        (reply[0] == '*' && reply[1] != '-')) {\n            luaSortArray(lua);\n    }\n    if (reply != c->buf) sdsfree(reply);\n    c->reply_bytes = 0;\n\ncleanup:\n    /* Clean up. Command code may have changed argv/argc so we use the\n     * argv/argc of the client instead of the local variables. */\n    for (j = 0; j < c->argc; j++) {\n        robj *o = c->argv[j];\n\n        /* Try to cache the object in the cached_objects array.\n         * The object must be small, SDS-encoded, and with refcount = 1\n         * (we must be the only owner) for us to cache it. */\n        if (j < LUA_CMD_OBJCACHE_SIZE &&\n            o->refcount == 1 &&\n            (o->encoding == OBJ_ENCODING_RAW ||\n             o->encoding == OBJ_ENCODING_EMBSTR) &&\n            sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)\n        {\n            sds s = o->ptr;\n            if (cached_objects[j]) decrRefCount(cached_objects[j]);\n            cached_objects[j] = o;\n            cached_objects_len[j] = sdsalloc(s);\n        } else {\n            decrRefCount(o);\n        }\n    }\n\n    if (c->argv != argv) {\n        zfree(c->argv);\n        argv = NULL;\n        argv_size = 0;\n    }\n\n    c->user = NULL;\n\n    if (raise_error) {\n        /* If we are here we should have an error in the stack, in the\n         * form of a table with an \"err\" field. Extract the string to\n         * return the plain error. */\n        inuse--;\n        return luaRaiseError(lua);\n    }\n    inuse--;\n    return 1;\n}\n\n/* redis.call() */\nint luaRedisCallCommand(lua_State *lua) {\n    return luaRedisGenericCommand(lua,1);\n}\n\n/* redis.pcall() */\nint luaRedisPCallCommand(lua_State *lua) {\n    return luaRedisGenericCommand(lua,0);\n}\n\n/* This adds redis.sha1hex(string) to Lua scripts using the same hashing\n * function used for sha1ing lua scripts. */\nint luaRedisSha1hexCommand(lua_State *lua) {\n    int argc = lua_gettop(lua);\n    char digest[41];\n    size_t len;\n    char *s;\n\n    if (argc != 1) {\n        lua_pushstring(lua, \"wrong number of arguments\");\n        return lua_error(lua);\n    }\n\n    s = (char*)lua_tolstring(lua,1,&len);\n    sha1hex(digest,s,len);\n    lua_pushstring(lua,digest);\n    return 1;\n}\n\n/* Returns a table with a single field 'field' set to the string value\n * passed as argument. This helper function is handy when returning\n * a Redis Protocol error or status reply from Lua:\n *\n * return redis.error_reply(\"ERR Some Error\")\n * return redis.status_reply(\"ERR Some Error\")\n */\nint luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {\n    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {\n        luaPushError(lua, \"wrong number or type of arguments\");\n        return 1;\n    }\n\n    lua_newtable(lua);\n    lua_pushstring(lua, field);\n    lua_pushvalue(lua, -3);\n    lua_settable(lua, -3);\n    return 1;\n}\n\n/* redis.error_reply() */\nint luaRedisErrorReplyCommand(lua_State *lua) {\n    return luaRedisReturnSingleFieldTable(lua,\"err\");\n}\n\n/* redis.status_reply() */\nint luaRedisStatusReplyCommand(lua_State *lua) {\n    return luaRedisReturnSingleFieldTable(lua,\"ok\");\n}\n\n/* redis.replicate_commands()\n *\n * Turn on single commands replication if the script never called\n * a write command so far, and returns true. Otherwise if the script\n * already started to write, returns false and stick to whole scripts\n * replication, which is our default. */\nint luaRedisReplicateCommandsCommand(lua_State *lua) {\n    if (server.lua_write_dirty) {\n        lua_pushboolean(lua,0);\n    } else {\n        server.lua_replicate_commands = 1;\n        /* When we switch to single commands replication, we can provide\n         * different math.random() sequences at every call, which is what\n         * the user normally expects. */\n        redisSrand48(rand());\n        lua_pushboolean(lua,1);\n    }\n    return 1;\n}\n\n/* redis.breakpoint()\n *\n * Allows to stop execution during a debugging session from within\n * the Lua code implementation, like if a breakpoint was set in the code\n * immediately after the function. */\nint luaRedisBreakpointCommand(lua_State *lua) {\n    if (ldb.active) {\n        ldb.luabp = 1;\n        lua_pushboolean(lua,1);\n    } else {\n        lua_pushboolean(lua,0);\n    }\n    return 1;\n}\n\n/* redis.debug()\n *\n * Log a string message into the output console.\n * Can take multiple arguments that will be separated by commas.\n * Nothing is returned to the caller. */\nint luaRedisDebugCommand(lua_State *lua) {\n    if (!ldb.active) return 0;\n    int argc = lua_gettop(lua);\n    sds log = sdscatprintf(sdsempty(),\"<debug> line %d: \", ldb.currentline);\n    while(argc--) {\n        log = ldbCatStackValue(log,lua,-1 - argc);\n        if (argc != 0) log = sdscatlen(log,\", \",2);\n    }\n    ldbLog(log);\n    return 0;\n}\n\n/* redis.set_repl()\n *\n * Set the propagation of write commands executed in the context of the\n * script to on/off for AOF and slaves. */\nint luaRedisSetReplCommand(lua_State *lua) {\n    int argc = lua_gettop(lua);\n    int flags;\n\n    if (server.lua_replicate_commands == 0) {\n        lua_pushstring(lua, \"You can set the replication behavior only after turning on single commands replication with redis.replicate_commands().\");\n        return lua_error(lua);\n    } else if (argc != 1) {\n        lua_pushstring(lua, \"redis.set_repl() requires two arguments.\");\n        return lua_error(lua);\n    }\n\n    flags = lua_tonumber(lua,-1);\n    if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {\n        lua_pushstring(lua, \"Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE.\");\n        return lua_error(lua);\n    }\n    server.lua_repl = flags;\n    return 0;\n}\n\n/* redis.log() */\nint luaLogCommand(lua_State *lua) {\n    int j, argc = lua_gettop(lua);\n    int level;\n    sds log;\n\n    if (argc < 2) {\n        lua_pushstring(lua, \"redis.log() requires two arguments or more.\");\n        return lua_error(lua);\n    } else if (!lua_isnumber(lua,-argc)) {\n        lua_pushstring(lua, \"First argument must be a number (log level).\");\n        return lua_error(lua);\n    }\n    level = lua_tonumber(lua,-argc);\n    if (level < LL_DEBUG || level > LL_WARNING) {\n        lua_pushstring(lua, \"Invalid debug level.\");\n        return lua_error(lua);\n    }\n    if (level < server.verbosity) return 0;\n\n    /* Glue together all the arguments */\n    log = sdsempty();\n    for (j = 1; j < argc; j++) {\n        size_t len;\n        char *s;\n\n        s = (char*)lua_tolstring(lua,(-argc)+j,&len);\n        if (s) {\n            if (j != 1) log = sdscatlen(log,\" \",1);\n            log = sdscatlen(log,s,len);\n        }\n    }\n    serverLogRaw(level,log);\n    sdsfree(log);\n    return 0;\n}\n\n/* redis.setresp() */\nint luaSetResp(lua_State *lua) {\n    int argc = lua_gettop(lua);\n\n    if (argc != 1) {\n        lua_pushstring(lua, \"redis.setresp() requires one argument.\");\n        return lua_error(lua);\n    }\n\n    int resp = lua_tonumber(lua,-argc);\n    if (resp != 2 && resp != 3) {\n        lua_pushstring(lua, \"RESP version must be 2 or 3.\");\n        return lua_error(lua);\n    }\n\n    server.lua_client->resp = resp;\n    return 0;\n}\n\n/* ---------------------------------------------------------------------------\n * Lua engine initialization and reset.\n * ------------------------------------------------------------------------- */\n\nvoid luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {\n  lua_pushcfunction(lua, luafunc);\n  lua_pushstring(lua, libname);\n  lua_call(lua, 1, 0);\n}\n\nLUALIB_API int (luaopen_cjson) (lua_State *L);\nLUALIB_API int (luaopen_struct) (lua_State *L);\nLUALIB_API int (luaopen_cmsgpack) (lua_State *L);\nLUALIB_API int (luaopen_bit) (lua_State *L);\n\nvoid luaLoadLibraries(lua_State *lua) {\n    luaLoadLib(lua, \"\", luaopen_base);\n    luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);\n    luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);\n    luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);\n    luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);\n    luaLoadLib(lua, \"cjson\", luaopen_cjson);\n    luaLoadLib(lua, \"struct\", luaopen_struct);\n    luaLoadLib(lua, \"cmsgpack\", luaopen_cmsgpack);\n    luaLoadLib(lua, \"bit\", luaopen_bit);\n\n#if 0 /* Stuff that we don't load currently, for sandboxing concerns. */\n    luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);\n    luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);\n#endif\n}\n\n/* Remove a functions that we don't want to expose to the Redis scripting\n * environment. */\nvoid luaRemoveUnsupportedFunctions(lua_State *lua) {\n    lua_pushnil(lua);\n    lua_setglobal(lua,\"loadfile\");\n    lua_pushnil(lua);\n    lua_setglobal(lua,\"dofile\");\n}\n\n/* This function installs metamethods in the global table _G that prevent\n * the creation of globals accidentally.\n *\n * It should be the last to be called in the scripting engine initialization\n * sequence, because it may interact with creation of globals. */\nvoid scriptingEnableGlobalsProtection(lua_State *lua) {\n    char *s[32];\n    sds code = sdsempty();\n    int j = 0;\n\n    /* strict.lua from: http://metalua.luaforge.net/src/lib/strict.lua.html.\n     * Modified to be adapted to Redis. */\n    s[j++]=\"local dbg=debug\\n\";\n    s[j++]=\"local mt = {}\\n\";\n    s[j++]=\"setmetatable(_G, mt)\\n\";\n    s[j++]=\"mt.__newindex = function (t, n, v)\\n\";\n    s[j++]=\"  if dbg.getinfo(2) then\\n\";\n    s[j++]=\"    local w = dbg.getinfo(2, \\\"S\\\").what\\n\";\n    s[j++]=\"    if w ~= \\\"main\\\" and w ~= \\\"C\\\" then\\n\";\n    s[j++]=\"      error(\\\"Script attempted to create global variable '\\\"..tostring(n)..\\\"'\\\", 2)\\n\";\n    s[j++]=\"    end\\n\";\n    s[j++]=\"  end\\n\";\n    s[j++]=\"  rawset(t, n, v)\\n\";\n    s[j++]=\"end\\n\";\n    s[j++]=\"mt.__index = function (t, n)\\n\";\n    s[j++]=\"  if dbg.getinfo(2) and dbg.getinfo(2, \\\"S\\\").what ~= \\\"C\\\" then\\n\";\n    s[j++]=\"    error(\\\"Script attempted to access nonexistent global variable '\\\"..tostring(n)..\\\"'\\\", 2)\\n\";\n    s[j++]=\"  end\\n\";\n    s[j++]=\"  return rawget(t, n)\\n\";\n    s[j++]=\"end\\n\";\n    s[j++]=\"debug = nil\\n\";\n    s[j++]=NULL;\n\n    for (j = 0; s[j] != NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));\n    luaL_loadbuffer(lua,code,sdslen(code),\"@enable_strict_lua\");\n    lua_pcall(lua,0,0,0);\n    sdsfree(code);\n}\n\n/* Initialize the scripting environment.\n *\n * This function is called the first time at server startup with\n * the 'setup' argument set to 1.\n *\n * It can be called again multiple times during the lifetime of the Redis\n * process, with 'setup' set to 0, and following a scriptingRelease() call,\n * in order to reset the Lua scripting environment.\n *\n * However it is simpler to just call scriptingReset() that does just that. */\nvoid scriptingInit(int setup) {\n    lua_State *lua = lua_open();\n\n    if (setup) {\n        server.lua_client = NULL;\n        server.lua_caller = NULL;\n        server.lua_cur_script = NULL;\n        server.lua_timedout = 0;\n        ldbInit();\n    }\n\n    luaLoadLibraries(lua);\n    luaRemoveUnsupportedFunctions(lua);\n\n    /* Initialize a dictionary we use to map SHAs to scripts.\n     * This is useful for replication, as we need to replicate EVALSHA\n     * as EVAL, so we need to remember the associated script. */\n    server.lua_scripts = dictCreate(&shaScriptObjectDictType,NULL);\n    server.lua_scripts_mem = 0;\n\n    /* Register the redis commands table and fields */\n    lua_newtable(lua);\n\n    /* redis.call */\n    lua_pushstring(lua,\"call\");\n    lua_pushcfunction(lua,luaRedisCallCommand);\n    lua_settable(lua,-3);\n\n    /* redis.pcall */\n    lua_pushstring(lua,\"pcall\");\n    lua_pushcfunction(lua,luaRedisPCallCommand);\n    lua_settable(lua,-3);\n\n    /* redis.log and log levels. */\n    lua_pushstring(lua,\"log\");\n    lua_pushcfunction(lua,luaLogCommand);\n    lua_settable(lua,-3);\n\n    /* redis.setresp */\n    lua_pushstring(lua,\"setresp\");\n    lua_pushcfunction(lua,luaSetResp);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_DEBUG\");\n    lua_pushnumber(lua,LL_DEBUG);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_VERBOSE\");\n    lua_pushnumber(lua,LL_VERBOSE);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_NOTICE\");\n    lua_pushnumber(lua,LL_NOTICE);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_WARNING\");\n    lua_pushnumber(lua,LL_WARNING);\n    lua_settable(lua,-3);\n\n    /* redis.sha1hex */\n    lua_pushstring(lua, \"sha1hex\");\n    lua_pushcfunction(lua, luaRedisSha1hexCommand);\n    lua_settable(lua, -3);\n\n    /* redis.error_reply and redis.status_reply */\n    lua_pushstring(lua, \"error_reply\");\n    lua_pushcfunction(lua, luaRedisErrorReplyCommand);\n    lua_settable(lua, -3);\n    lua_pushstring(lua, \"status_reply\");\n    lua_pushcfunction(lua, luaRedisStatusReplyCommand);\n    lua_settable(lua, -3);\n\n    /* redis.replicate_commands */\n    lua_pushstring(lua, \"replicate_commands\");\n    lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);\n    lua_settable(lua, -3);\n\n    /* redis.set_repl and associated flags. */\n    lua_pushstring(lua,\"set_repl\");\n    lua_pushcfunction(lua,luaRedisSetReplCommand);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_NONE\");\n    lua_pushnumber(lua,PROPAGATE_NONE);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_AOF\");\n    lua_pushnumber(lua,PROPAGATE_AOF);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_SLAVE\");\n    lua_pushnumber(lua,PROPAGATE_REPL);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_REPLICA\");\n    lua_pushnumber(lua,PROPAGATE_REPL);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_ALL\");\n    lua_pushnumber(lua,PROPAGATE_AOF|PROPAGATE_REPL);\n    lua_settable(lua,-3);\n\n    /* redis.breakpoint */\n    lua_pushstring(lua,\"breakpoint\");\n    lua_pushcfunction(lua,luaRedisBreakpointCommand);\n    lua_settable(lua,-3);\n\n    /* redis.debug */\n    lua_pushstring(lua,\"debug\");\n    lua_pushcfunction(lua,luaRedisDebugCommand);\n    lua_settable(lua,-3);\n\n    /* Finally set the table as 'redis' global var. */\n    lua_setglobal(lua,\"redis\");\n\n    /* Replace math.random and math.randomseed with our implementations. */\n    lua_getglobal(lua,\"math\");\n\n    lua_pushstring(lua,\"random\");\n    lua_pushcfunction(lua,redis_math_random);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"randomseed\");\n    lua_pushcfunction(lua,redis_math_randomseed);\n    lua_settable(lua,-3);\n\n    lua_setglobal(lua,\"math\");\n\n    /* Add a helper function that we use to sort the multi bulk output of non\n     * deterministic commands, when containing 'false' elements. */\n    {\n        char *compare_func =    \"function __redis__compare_helper(a,b)\\n\"\n                                \"  if a == false then a = '' end\\n\"\n                                \"  if b == false then b = '' end\\n\"\n                                \"  return a<b\\n\"\n                                \"end\\n\";\n        luaL_loadbuffer(lua,compare_func,strlen(compare_func),\"@cmp_func_def\");\n        lua_pcall(lua,0,0,0);\n    }\n\n    /* Add a helper function we use for pcall error reporting.\n     * Note that when the error is in the C function we want to report the\n     * information about the caller, that's what makes sense from the point\n     * of view of the user debugging a script. */\n    {\n        char *errh_func =       \"local dbg = debug\\n\"\n                                \"function __redis__err__handler(err)\\n\"\n                                \"  local i = dbg.getinfo(2,'nSl')\\n\"\n                                \"  if i and i.what == 'C' then\\n\"\n                                \"    i = dbg.getinfo(3,'nSl')\\n\"\n                                \"  end\\n\"\n                                \"  if i then\\n\"\n                                \"    return i.source .. ':' .. i.currentline .. ': ' .. err\\n\"\n                                \"  else\\n\"\n                                \"    return err\\n\"\n                                \"  end\\n\"\n                                \"end\\n\";\n        luaL_loadbuffer(lua,errh_func,strlen(errh_func),\"@err_handler_def\");\n        lua_pcall(lua,0,0,0);\n    }\n\n    /* Create the (non connected) client that we use to execute Redis commands\n     * inside the Lua interpreter.\n     * Note: there is no need to create it again when this function is called\n     * by scriptingReset(). */\n    if (server.lua_client == NULL) {\n        server.lua_client = createClient(NULL);\n        server.lua_client->flags |= CLIENT_LUA;\n    }\n\n    /* Lua beginners often don't use \"local\", this is likely to introduce\n     * subtle bugs in their code. To prevent problems we protect accesses\n     * to global variables. */\n    scriptingEnableGlobalsProtection(lua);\n\n    server.lua = lua;\n}\n\n/* Release resources related to Lua scripting.\n * This function is used in order to reset the scripting environment. */\nvoid scriptingRelease(void) {\n    dictRelease(server.lua_scripts);\n    server.lua_scripts_mem = 0;\n    lua_close(server.lua);\n}\n\nvoid scriptingReset(void) {\n    scriptingRelease();\n    scriptingInit(0);\n}\n\n/* Set an array of Redis String Objects as a Lua array (table) stored into a\n * global variable. */\nvoid luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {\n    int j;\n\n    lua_newtable(lua);\n    for (j = 0; j < elec; j++) {\n        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));\n        lua_rawseti(lua,-2,j+1);\n    }\n    lua_setglobal(lua,var);\n}\n\n/* ---------------------------------------------------------------------------\n * Redis provided math.random\n * ------------------------------------------------------------------------- */\n\n/* We replace math.random() with our implementation that is not affected\n * by specific libc random() implementations and will output the same sequence\n * (for the same seed) in every arch. */\n\n/* The following implementation is the one shipped with Lua itself but with\n * rand() replaced by redisLrand48(). */\nint redis_math_random (lua_State *L) {\n  /* the `%' avoids the (rare) case of r==1, and is needed also because on\n     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */\n  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /\n                                (lua_Number)REDIS_LRAND48_MAX;\n  switch (lua_gettop(L)) {  /* check number of arguments */\n    case 0: {  /* no arguments */\n      lua_pushnumber(L, r);  /* Number between 0 and 1 */\n      break;\n    }\n    case 1: {  /* only upper limit */\n      int u = luaL_checkint(L, 1);\n      luaL_argcheck(L, 1<=u, 1, \"interval is empty\");\n      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */\n      break;\n    }\n    case 2: {  /* lower and upper limits */\n      int l = luaL_checkint(L, 1);\n      int u = luaL_checkint(L, 2);\n      luaL_argcheck(L, l<=u, 2, \"interval is empty\");\n      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */\n      break;\n    }\n    default: return luaL_error(L, \"wrong number of arguments\");\n  }\n  return 1;\n}\n\nint redis_math_randomseed (lua_State *L) {\n  redisSrand48(luaL_checkint(L, 1));\n  return 0;\n}\n\n/* ---------------------------------------------------------------------------\n * EVAL and SCRIPT commands implementation\n * ------------------------------------------------------------------------- */\n\n/* Define a Lua function with the specified body.\n * The function name will be generated in the following form:\n *\n *   f_<hex sha1 sum>\n *\n * The function increments the reference count of the 'body' object as a\n * side effect of a successful call.\n *\n * On success a pointer to an SDS string representing the function SHA1 of the\n * just added function is returned (and will be valid until the next call\n * to scriptingReset() function), otherwise NULL is returned.\n *\n * The function handles the fact of being called with a script that already\n * exists, and in such a case, it behaves like in the success case.\n *\n * If 'c' is not NULL, on error the client is informed with an appropriate\n * error describing the nature of the problem and the Lua interpreter error. */\nsds luaCreateFunction(client *c, lua_State *lua, robj *body) {\n    char funcname[43];\n    dictEntry *de;\n\n    funcname[0] = 'f';\n    funcname[1] = '_';\n    sha1hex(funcname+2,body->ptr,sdslen(body->ptr));\n\n    sds sha = sdsnewlen(funcname+2,40);\n    if ((de = dictFind(server.lua_scripts,sha)) != NULL) {\n        sdsfree(sha);\n        return dictGetKey(de);\n    }\n\n    sds funcdef = sdsempty();\n    funcdef = sdscat(funcdef,\"function \");\n    funcdef = sdscatlen(funcdef,funcname,42);\n    funcdef = sdscatlen(funcdef,\"() \",3);\n    funcdef = sdscatlen(funcdef,body->ptr,sdslen(body->ptr));\n    funcdef = sdscatlen(funcdef,\"\\nend\",4);\n\n    if (luaL_loadbuffer(lua,funcdef,sdslen(funcdef),\"@user_script\")) {\n        if (c != NULL) {\n            addReplyErrorFormat(c,\n                \"Error compiling script (new function): %s\\n\",\n                lua_tostring(lua,-1));\n        }\n        lua_pop(lua,1);\n        sdsfree(sha);\n        sdsfree(funcdef);\n        return NULL;\n    }\n    sdsfree(funcdef);\n\n    if (lua_pcall(lua,0,0,0)) {\n        if (c != NULL) {\n            addReplyErrorFormat(c,\"Error running script (new function): %s\\n\",\n                lua_tostring(lua,-1));\n        }\n        lua_pop(lua,1);\n        sdsfree(sha);\n        return NULL;\n    }\n\n    /* We also save a SHA1 -> Original script map in a dictionary\n     * so that we can replicate / write in the AOF all the\n     * EVALSHA commands as EVAL using the original script. */\n    int retval = dictAdd(server.lua_scripts,sha,body);\n    serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);\n    server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);\n    incrRefCount(body);\n    return sha;\n}\n\n/* This is the Lua script \"count\" hook that we use to detect scripts timeout. */\nvoid luaMaskCountHook(lua_State *lua, lua_Debug *ar) {\n    long long elapsed = mstime() - server.lua_time_start;\n    UNUSED(ar);\n    UNUSED(lua);\n\n    /* Set the timeout condition if not already set and the maximum\n     * execution time was reached. */\n    if (elapsed >= server.lua_time_limit && server.lua_timedout == 0) {\n        serverLog(LL_WARNING,\n            \"Lua slow script detected: still in execution after %lld milliseconds. \"\n            \"You can try killing the script using the SCRIPT KILL command. \"\n            \"Script SHA1 is: %s\",\n            elapsed, server.lua_cur_script);\n        server.lua_timedout = 1;\n        /* Once the script timeouts we reenter the event loop to permit others\n         * to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason\n         * we need to mask the client executing the script from the event loop.\n         * If we don't do that the client may disconnect and could no longer be\n         * here when the EVAL command will return. */\n        protectClient(server.lua_caller);\n    }\n    if (server.lua_timedout) processEventsWhileBlocked();\n    if (server.lua_kill) {\n        serverLog(LL_WARNING,\"Lua script killed by user with SCRIPT KILL.\");\n        lua_pushstring(lua,\"Script killed by user with SCRIPT KILL...\");\n        lua_error(lua);\n    }\n}\n\nvoid prepareLuaClient(void) {\n    /* Select the right DB in the context of the Lua client */\n    selectDb(server.lua_client,server.lua_caller->db->id);\n    server.lua_client->resp = 2; /* Default is RESP2, scripts can change it. */\n\n    /* If we are in MULTI context, flag Lua client as CLIENT_MULTI. */\n    if (server.lua_caller->flags & CLIENT_MULTI) {\n        server.lua_client->flags |= CLIENT_MULTI;\n    }\n}\n\nvoid resetLuaClient(void) {\n    /* After the script done, remove the MULTI state. */\n    server.lua_client->flags &= ~CLIENT_MULTI;\n}\n\nvoid evalGenericCommand(client *c, int evalsha) {\n    lua_State *lua = server.lua;\n    char funcname[43];\n    long long numkeys;\n    long long initial_server_dirty = server.dirty;\n    int delhook = 0, err;\n\n    /* When we replicate whole scripts, we want the same PRNG sequence at\n     * every call so that our PRNG is not affected by external state. */\n    redisSrand48(0);\n\n    /* We set this flag to zero to remember that so far no random command\n     * was called. This way we can allow the user to call commands like\n     * SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command\n     * is called (otherwise the replication and AOF would end with non\n     * deterministic sequences).\n     *\n     * Thanks to this flag we'll raise an error every time a write command\n     * is called after a random command was used. */\n    server.lua_random_dirty = 0;\n    server.lua_write_dirty = 0;\n    server.lua_replicate_commands = server.lua_always_replicate_commands;\n    server.lua_multi_emitted = 0;\n    server.lua_repl = PROPAGATE_AOF|PROPAGATE_REPL;\n\n    /* Get the number of arguments that are keys */\n    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)\n        return;\n    if (numkeys > (c->argc - 3)) {\n        addReplyError(c,\"Number of keys can't be greater than number of args\");\n        return;\n    } else if (numkeys < 0) {\n        addReplyError(c,\"Number of keys can't be negative\");\n        return;\n    }\n\n    /* We obtain the script SHA1, then check if this function is already\n     * defined into the Lua state */\n    funcname[0] = 'f';\n    funcname[1] = '_';\n    if (!evalsha) {\n        /* Hash the code if this is an EVAL call */\n        sha1hex(funcname+2,c->argv[1]->ptr,sdslen(c->argv[1]->ptr));\n    } else {\n        /* We already have the SHA if it is an EVALSHA */\n        int j;\n        char *sha = c->argv[1]->ptr;\n\n        /* Convert to lowercase. We don't use tolower since the function\n         * managed to always show up in the profiler output consuming\n         * a non trivial amount of time. */\n        for (j = 0; j < 40; j++)\n            funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?\n                sha[j]+('a'-'A') : sha[j];\n        funcname[42] = '\\0';\n    }\n\n    /* Push the pcall error handler function on the stack. */\n    lua_getglobal(lua, \"__redis__err__handler\");\n\n    /* Try to lookup the Lua function */\n    lua_getglobal(lua, funcname);\n    if (lua_isnil(lua,-1)) {\n        lua_pop(lua,1); /* remove the nil from the stack */\n        /* Function not defined... let's define it if we have the\n         * body of the function. If this is an EVALSHA call we can just\n         * return an error. */\n        if (evalsha) {\n            lua_pop(lua,1); /* remove the error handler from the stack. */\n            addReply(c, shared.noscripterr);\n            return;\n        }\n        if (luaCreateFunction(c,lua,c->argv[1]) == NULL) {\n            lua_pop(lua,1); /* remove the error handler from the stack. */\n            /* The error is sent to the client by luaCreateFunction()\n             * itself when it returns NULL. */\n            return;\n        }\n        /* Now the following is guaranteed to return non nil */\n        lua_getglobal(lua, funcname);\n        serverAssert(!lua_isnil(lua,-1));\n    }\n\n    /* Populate the argv and keys table accordingly to the arguments that\n     * EVAL received. */\n    luaSetGlobalArray(lua,\"KEYS\",c->argv+3,numkeys);\n    luaSetGlobalArray(lua,\"ARGV\",c->argv+3+numkeys,c->argc-3-numkeys);\n\n    /* Set a hook in order to be able to stop the script execution if it\n     * is running for too much time.\n     * We set the hook only if the time limit is enabled as the hook will\n     * make the Lua script execution slower.\n     *\n     * If we are debugging, we set instead a \"line\" hook so that the\n     * debugger is call-back at every line executed by the script. */\n    server.lua_caller = c;\n    server.lua_cur_script = funcname + 2;\n    server.lua_time_start = mstime();\n    server.lua_kill = 0;\n    if (server.lua_time_limit > 0 && ldb.active == 0) {\n        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);\n        delhook = 1;\n    } else if (ldb.active) {\n        lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);\n        delhook = 1;\n    }\n\n    prepareLuaClient();\n\n    /* At this point whether this script was never seen before or if it was\n     * already defined, we can call it. We have zero arguments and expect\n     * a single return value. */\n    err = lua_pcall(lua,0,1,-2);\n\n    resetLuaClient();\n\n    /* Perform some cleanup that we need to do both on error and success. */\n    if (delhook) lua_sethook(lua,NULL,0,0); /* Disable hook */\n    if (server.lua_timedout) {\n        server.lua_timedout = 0;\n        /* Restore the client that was protected when the script timeout\n         * was detected. */\n        unprotectClient(c);\n        if (server.masterhost && server.master)\n            queueClientForReprocessing(server.master);\n    }\n    server.lua_caller = NULL;\n    server.lua_cur_script = NULL;\n\n    /* Call the Lua garbage collector from time to time to avoid a\n     * full cycle performed by Lua, which adds too latency.\n     *\n     * The call is performed every LUA_GC_CYCLE_PERIOD executed commands\n     * (and for LUA_GC_CYCLE_PERIOD collection steps) because calling it\n     * for every command uses too much CPU. */\n    #define LUA_GC_CYCLE_PERIOD 50\n    {\n        static long gc_count = 0;\n\n        gc_count++;\n        if (gc_count == LUA_GC_CYCLE_PERIOD) {\n            lua_gc(lua,LUA_GCSTEP,LUA_GC_CYCLE_PERIOD);\n            gc_count = 0;\n        }\n    }\n\n    if (err) {\n        addReplyErrorFormat(c,\"Error running script (call to %s): %s\\n\",\n            funcname, lua_tostring(lua,-1));\n        lua_pop(lua,2); /* Consume the Lua reply and remove error handler. */\n    } else {\n        /* On success convert the Lua return value into Redis protocol, and\n         * send it to * the client. */\n        luaReplyToRedisReply(c,lua); /* Convert and consume the reply. */\n        lua_pop(lua,1); /* Remove the error handler. */\n    }\n\n    /* If we are using single commands replication, emit EXEC if there\n     * was at least a write. */\n    if (server.lua_replicate_commands) {\n        preventCommandPropagation(c);\n        if (server.lua_multi_emitted) {\n            execCommandPropagateExec(c);\n        }\n    }\n\n    /* EVALSHA should be propagated to Slave and AOF file as full EVAL, unless\n     * we are sure that the script was already in the context of all the\n     * attached slaves *and* the current AOF file if enabled.\n     *\n     * To do so we use a cache of SHA1s of scripts that we already propagated\n     * as full EVAL, that's called the Replication Script Cache.\n     *\n     * For replication, everytime a new slave attaches to the master, we need to\n     * flush our cache of scripts that can be replicated as EVALSHA, while\n     * for AOF we need to do so every time we rewrite the AOF file. */\n    if (evalsha && !server.lua_replicate_commands) {\n        if (!replicationScriptCacheExists(c->argv[1]->ptr)) {\n            /* This script is not in our script cache, replicate it as\n             * EVAL, then add it into the script cache, as from now on\n             * slaves and AOF know about it. */\n            robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);\n\n            replicationScriptCacheAdd(c->argv[1]->ptr);\n            serverAssertWithInfo(c,NULL,script != NULL);\n\n            /* If the script did not produce any changes in the dataset we want\n             * just to replicate it as SCRIPT LOAD, otherwise we risk running\n             * an aborted script on slaves (that may then produce results there)\n             * or just running a CPU costly read-only script on the slaves. */\n            if (server.dirty == initial_server_dirty) {\n                rewriteClientCommandVector(c,3,\n                    resetRefCount(createStringObject(\"SCRIPT\",6)),\n                    resetRefCount(createStringObject(\"LOAD\",4)),\n                    script);\n            } else {\n                rewriteClientCommandArgument(c,0,\n                    resetRefCount(createStringObject(\"EVAL\",4)));\n                rewriteClientCommandArgument(c,1,script);\n            }\n            forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);\n        }\n    }\n}\n\nvoid evalCommand(client *c) {\n    if (!(c->flags & CLIENT_LUA_DEBUG))\n        evalGenericCommand(c,0);\n    else\n        evalGenericCommandWithDebugging(c,0);\n}\n\nvoid evalShaCommand(client *c) {\n    if (sdslen(c->argv[1]->ptr) != 40) {\n        /* We know that a match is not possible if the provided SHA is\n         * not the right length. So we return an error ASAP, this way\n         * evalGenericCommand() can be implemented without string length\n         * sanity check */\n        addReply(c, shared.noscripterr);\n        return;\n    }\n    if (!(c->flags & CLIENT_LUA_DEBUG))\n        evalGenericCommand(c,1);\n    else {\n        addReplyError(c,\"Please use EVAL instead of EVALSHA for debugging\");\n        return;\n    }\n}\n\nvoid scriptCommand(client *c) {\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"DEBUG (yes|sync|no) -- Set the debug mode for subsequent scripts executed.\",\n\"EXISTS <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script cache.\",\n\"FLUSH -- Flush the Lua scripts cache. Very dangerous on replicas.\",\n\"KILL -- Kill the currently executing Lua script.\",\n\"LOAD <script> -- Load a script into the scripts cache, without executing it.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"flush\")) {\n        scriptingReset();\n        addReply(c,shared.ok);\n        replicationScriptCacheFlush();\n        server.dirty++; /* Propagating this command is a good idea. */\n    } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,\"exists\")) {\n        int j;\n\n        addReplyArrayLen(c, c->argc-2);\n        for (j = 2; j < c->argc; j++) {\n            if (dictFind(server.lua_scripts,c->argv[j]->ptr))\n                addReply(c,shared.cone);\n            else\n                addReply(c,shared.czero);\n        }\n    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,\"load\")) {\n        sds sha = luaCreateFunction(c,server.lua,c->argv[2]);\n        if (sha == NULL) return; /* The error was sent by luaCreateFunction(). */\n        addReplyBulkCBuffer(c,sha,40);\n        forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);\n    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"kill\")) {\n        if (server.lua_caller == NULL) {\n            addReplySds(c,sdsnew(\"-NOTBUSY No scripts in execution right now.\\r\\n\"));\n        } else if (server.lua_caller->flags & CLIENT_MASTER) {\n            addReplySds(c,sdsnew(\"-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed.\\r\\n\"));\n        } else if (server.lua_write_dirty) {\n            addReplySds(c,sdsnew(\"-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\\r\\n\"));\n        } else {\n            server.lua_kill = 1;\n            addReply(c,shared.ok);\n        }\n    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,\"debug\")) {\n        if (clientHasPendingReplies(c)) {\n            addReplyError(c,\"SCRIPT DEBUG must be called outside a pipeline\");\n            return;\n        }\n        if (!strcasecmp(c->argv[2]->ptr,\"no\")) {\n            ldbDisable(c);\n            addReply(c,shared.ok);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"yes\")) {\n            ldbEnable(c);\n            addReply(c,shared.ok);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"sync\")) {\n            ldbEnable(c);\n            addReply(c,shared.ok);\n            c->flags |= CLIENT_LUA_DEBUG_SYNC;\n        } else {\n            addReplyError(c,\"Use SCRIPT DEBUG yes/sync/no\");\n            return;\n        }\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* ---------------------------------------------------------------------------\n * LDB: Redis Lua debugging facilities\n * ------------------------------------------------------------------------- */\n\n/* Initialize Lua debugger data structures. */\nvoid ldbInit(void) {\n    ldb.conn = NULL;\n    ldb.active = 0;\n    ldb.logs = listCreate();\n    listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);\n    ldb.children = listCreate();\n    ldb.src = NULL;\n    ldb.lines = 0;\n    ldb.cbuf = sdsempty();\n}\n\n/* Remove all the pending messages in the specified list. */\nvoid ldbFlushLog(list *log) {\n    listNode *ln;\n\n    while((ln = listFirst(log)) != NULL)\n        listDelNode(log,ln);\n}\n\n/* Enable debug mode of Lua scripts for this client. */\nvoid ldbEnable(client *c) {\n    c->flags |= CLIENT_LUA_DEBUG;\n    ldbFlushLog(ldb.logs);\n    ldb.conn = c->conn;\n    ldb.step = 1;\n    ldb.bpcount = 0;\n    ldb.luabp = 0;\n    sdsfree(ldb.cbuf);\n    ldb.cbuf = sdsempty();\n    ldb.maxlen = LDB_MAX_LEN_DEFAULT;\n    ldb.maxlen_hint_sent = 0;\n}\n\n/* Exit debugging mode from the POV of client. This function is not enough\n * to properly shut down a client debugging session, see ldbEndSession()\n * for more information. */\nvoid ldbDisable(client *c) {\n    c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);\n}\n\n/* Append a log entry to the specified LDB log. */\nvoid ldbLog(sds entry) {\n    listAddNodeTail(ldb.logs,entry);\n}\n\n/* A version of ldbLog() which prevents producing logs greater than\n * ldb.maxlen. The first time the limit is reached a hint is generated\n * to inform the user that reply trimming can be disabled using the\n * debugger \"maxlen\" command. */\nvoid ldbLogWithMaxLen(sds entry) {\n    int trimmed = 0;\n    if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {\n        sdsrange(entry,0,ldb.maxlen-1);\n        entry = sdscatlen(entry,\" ...\",4);\n        trimmed = 1;\n    }\n    ldbLog(entry);\n    if (trimmed && ldb.maxlen_hint_sent == 0) {\n        ldb.maxlen_hint_sent = 1;\n        ldbLog(sdsnew(\n        \"<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming.\"));\n    }\n}\n\n/* Send ldb.logs to the debugging client as a multi-bulk reply\n * consisting of simple strings. Log entries which include newlines have them\n * replaced with spaces. The entries sent are also consumed. */\nvoid ldbSendLogs(void) {\n    sds proto = sdsempty();\n    proto = sdscatfmt(proto,\"*%i\\r\\n\", (int)listLength(ldb.logs));\n    while(listLength(ldb.logs)) {\n        listNode *ln = listFirst(ldb.logs);\n        proto = sdscatlen(proto,\"+\",1);\n        sdsmapchars(ln->value,\"\\r\\n\",\"  \",2);\n        proto = sdscatsds(proto,ln->value);\n        proto = sdscatlen(proto,\"\\r\\n\",2);\n        listDelNode(ldb.logs,ln);\n    }\n    if (connWrite(ldb.conn,proto,sdslen(proto)) == -1) {\n        /* Avoid warning. We don't check the return value of write()\n         * since the next read() will catch the I/O error and will\n         * close the debugging session. */\n    }\n    sdsfree(proto);\n}\n\n/* Start a debugging session before calling EVAL implementation.\n * The technique we use is to capture the client socket file descriptor,\n * in order to perform direct I/O with it from within Lua hooks. This\n * way we don't have to re-enter Redis in order to handle I/O.\n *\n * The function returns 1 if the caller should proceed to call EVAL,\n * and 0 if instead the caller should abort the operation (this happens\n * for the parent in a forked session, since it's up to the children\n * to continue, or when fork returned an error).\n *\n * The caller should call ldbEndSession() only if ldbStartSession()\n * returned 1. */\nint ldbStartSession(client *c) {\n    ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;\n    if (ldb.forked) {\n        pid_t cp = redisFork(CHILD_TYPE_LDB);\n        if (cp == -1) {\n            addReplyError(c,\"Fork() failed: can't run EVAL in debugging mode.\");\n            return 0;\n        } else if (cp == 0) {\n            /* Child. Let's ignore important signals handled by the parent. */\n            struct sigaction act;\n            sigemptyset(&act.sa_mask);\n            act.sa_flags = 0;\n            act.sa_handler = SIG_IGN;\n            sigaction(SIGTERM, &act, NULL);\n            sigaction(SIGINT, &act, NULL);\n\n            /* Log the creation of the child and close the listening\n             * socket to make sure if the parent crashes a reset is sent\n             * to the clients. */\n            serverLog(LL_WARNING,\"Redis forked for debugging eval\");\n        } else {\n            /* Parent */\n            listAddNodeTail(ldb.children,(void*)(unsigned long)cp);\n            freeClientAsync(c); /* Close the client in the parent side. */\n            return 0;\n        }\n    } else {\n        serverLog(LL_WARNING,\n            \"Redis synchronous debugging eval session started\");\n    }\n\n    /* Setup our debugging session. */\n    connBlock(ldb.conn);\n    connSendTimeout(ldb.conn,5000);\n    ldb.active = 1;\n\n    /* First argument of EVAL is the script itself. We split it into different\n     * lines since this is the way the debugger accesses the source code. */\n    sds srcstring = sdsdup(c->argv[1]->ptr);\n    size_t srclen = sdslen(srcstring);\n    while(srclen && (srcstring[srclen-1] == '\\n' ||\n                     srcstring[srclen-1] == '\\r'))\n    {\n        srcstring[--srclen] = '\\0';\n    }\n    sdssetlen(srcstring,srclen);\n    ldb.src = sdssplitlen(srcstring,sdslen(srcstring),\"\\n\",1,&ldb.lines);\n    sdsfree(srcstring);\n    return 1;\n}\n\n/* End a debugging session after the EVAL call with debugging enabled\n * returned. */\nvoid ldbEndSession(client *c) {\n    /* Emit the remaining logs and an <endsession> mark. */\n    ldbLog(sdsnew(\"<endsession>\"));\n    ldbSendLogs();\n\n    /* If it's a fork()ed session, we just exit. */\n    if (ldb.forked) {\n        writeToClient(c,0);\n        serverLog(LL_WARNING,\"Lua debugging session child exiting\");\n        exitFromChild(0);\n    } else {\n        serverLog(LL_WARNING,\n            \"Redis synchronous debugging eval session ended\");\n    }\n\n    /* Otherwise let's restore client's state. */\n    connNonBlock(ldb.conn);\n    connSendTimeout(ldb.conn,0);\n\n    /* Close the client connection after sending the final EVAL reply\n     * in order to signal the end of the debugging session. */\n    c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n\n    /* Cleanup. */\n    sdsfreesplitres(ldb.src,ldb.lines);\n    ldb.lines = 0;\n    ldb.active = 0;\n}\n\n/* If the specified pid is among the list of children spawned for\n * forked debugging sessions, it is removed from the children list.\n * If the pid was found non-zero is returned. */\nint ldbRemoveChild(pid_t pid) {\n    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);\n    if (ln) {\n        listDelNode(ldb.children,ln);\n        return 1;\n    }\n    return 0;\n}\n\n/* Return the number of children we still did not receive termination\n * acknowledge via wait() in the parent process. */\nint ldbPendingChildren(void) {\n    return listLength(ldb.children);\n}\n\n/* Kill all the forked sessions. */\nvoid ldbKillForkedSessions(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(ldb.children,&li);\n    while((ln = listNext(&li))) {\n        pid_t pid = (unsigned long) ln->value;\n        serverLog(LL_WARNING,\"Killing debugging session %ld\",(long)pid);\n        kill(pid,SIGKILL);\n    }\n    listRelease(ldb.children);\n    ldb.children = listCreate();\n}\n\n/* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure\n * that when EVAL returns, whatever happened, the session is ended. */\nvoid evalGenericCommandWithDebugging(client *c, int evalsha) {\n    if (ldbStartSession(c)) {\n        evalGenericCommand(c,evalsha);\n        ldbEndSession(c);\n    } else {\n        ldbDisable(c);\n    }\n}\n\n/* Return a pointer to ldb.src source code line, considering line to be\n * one-based, and returning a special string for out of range lines. */\nchar *ldbGetSourceLine(int line) {\n    int idx = line-1;\n    if (idx < 0 || idx >= ldb.lines) return \"<out of range source code line>\";\n    return ldb.src[idx];\n}\n\n/* Return true if there is a breakpoint in the specified line. */\nint ldbIsBreakpoint(int line) {\n    int j;\n\n    for (j = 0; j < ldb.bpcount; j++)\n        if (ldb.bp[j] == line) return 1;\n    return 0;\n}\n\n/* Add the specified breakpoint. Ignore it if we already reached the max.\n * Returns 1 if the breakpoint was added (or was already set). 0 if there is\n * no space for the breakpoint or if the line is invalid. */\nint ldbAddBreakpoint(int line) {\n    if (line <= 0 || line > ldb.lines) return 0;\n    if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {\n        ldb.bp[ldb.bpcount++] = line;\n        return 1;\n    }\n    return 0;\n}\n\n/* Remove the specified breakpoint, returning 1 if the operation was\n * performed or 0 if there was no such breakpoint. */\nint ldbDelBreakpoint(int line) {\n    int j;\n\n    for (j = 0; j < ldb.bpcount; j++) {\n        if (ldb.bp[j] == line) {\n            ldb.bpcount--;\n            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Expect a valid multi-bulk command in the debugging client query buffer.\n * On success the command is parsed and returned as an array of SDS strings,\n * otherwise NULL is returned and there is to read more buffer. */\nsds *ldbReplParseCommand(int *argcp) {\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n\n    /* Working on a copy is simpler in this case. We can modify it freely\n     * for the sake of simpler parsing. */\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n\n    /* This Redis protocol parser is a joke... just the simplest thing that\n     * works in this context. It is also very forgiving regarding broken\n     * protocol. */\n\n    /* Seek and parse *<count>\\r\\n. */\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; /* Multi bulk len pointer. */\n    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n\n    /* Parse each argument. */\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        if (*p != '$') goto protoerr;\n        plen = p+1; /* Bulk string len pointer. */\n        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); /* Length of this arg. */\n        if (slen <= 0 || slen > 1024) goto protoerr;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; /* Skip the already parsed argument. */\n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; /* Skip \\r\\n. */\n    }\n    sdsfree(copy);\n    return argv;\n\nprotoerr:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}\n\n/* Log the specified line in the Lua debugger output. */\nvoid ldbLogSourceLine(int lnum) {\n    char *line = ldbGetSourceLine(lnum);\n    char *prefix;\n    int bp = ldbIsBreakpoint(lnum);\n    int current = ldb.currentline == lnum;\n\n    if (current && bp)\n        prefix = \"->#\";\n    else if (current)\n        prefix = \"-> \";\n    else if (bp)\n        prefix = \"  #\";\n    else\n        prefix = \"   \";\n    sds thisline = sdscatprintf(sdsempty(),\"%s%-3d %s\", prefix, lnum, line);\n    ldbLog(thisline);\n}\n\n/* Implement the \"list\" command of the Lua debugger. If around is 0\n * the whole file is listed, otherwise only a small portion of the file\n * around the specified line is shown. When a line number is specified\n * the amount of context (lines before/after) is specified via the\n * 'context' argument. */\nvoid ldbList(int around, int context) {\n    int j;\n\n    for (j = 1; j <= ldb.lines; j++) {\n        if (around != 0 && abs(around-j) > context) continue;\n        ldbLogSourceLine(j);\n    }\n}\n\n/* Append a human readable representation of the Lua value at position 'idx'\n * on the stack of the 'lua' state, to the SDS string passed as argument.\n * The new SDS string with the represented value attached is returned.\n * Used in order to implement ldbLogStackValue().\n *\n * The element is not automatically removed from the stack, nor it is\n * converted to a different type. */\n#define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)\nsds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {\n    int t = lua_type(lua,idx);\n\n    if (level++ == LDB_MAX_VALUES_DEPTH)\n        return sdscat(s,\"<max recursion level reached! Nested table?>\");\n\n    switch(t) {\n    case LUA_TSTRING:\n        {\n        size_t strl;\n        char *strp = (char*)lua_tolstring(lua,idx,&strl);\n        s = sdscatrepr(s,strp,strl);\n        }\n        break;\n    case LUA_TBOOLEAN:\n        s = sdscat(s,lua_toboolean(lua,idx) ? \"true\" : \"false\");\n        break;\n    case LUA_TNUMBER:\n        s = sdscatprintf(s,\"%g\",(double)lua_tonumber(lua,idx));\n        break;\n    case LUA_TNIL:\n        s = sdscatlen(s,\"nil\",3);\n        break;\n    case LUA_TTABLE:\n        {\n        int expected_index = 1; /* First index we expect in an array. */\n        int is_array = 1; /* Will be set to null if check fails. */\n        /* Note: we create two representations at the same time, one\n         * assuming the table is an array, one assuming it is not. At the\n         * end we know what is true and select the right one. */\n        sds repr1 = sdsempty();\n        sds repr2 = sdsempty();\n        lua_pushnil(lua); /* The first key to start the iteration is nil. */\n        while (lua_next(lua,idx-1)) {\n            /* Test if so far the table looks like an array. */\n            if (is_array &&\n                (lua_type(lua,-2) != LUA_TNUMBER ||\n                 lua_tonumber(lua,-2) != expected_index)) is_array = 0;\n            /* Stack now: table, key, value */\n            /* Array repr. */\n            repr1 = ldbCatStackValueRec(repr1,lua,-1,level);\n            repr1 = sdscatlen(repr1,\"; \",2);\n            /* Full repr. */\n            repr2 = sdscatlen(repr2,\"[\",1);\n            repr2 = ldbCatStackValueRec(repr2,lua,-2,level);\n            repr2 = sdscatlen(repr2,\"]=\",2);\n            repr2 = ldbCatStackValueRec(repr2,lua,-1,level);\n            repr2 = sdscatlen(repr2,\"; \",2);\n            lua_pop(lua,1); /* Stack: table, key. Ready for next iteration. */\n            expected_index++;\n        }\n        /* Strip the last \" ;\" from both the representations. */\n        if (sdslen(repr1)) sdsrange(repr1,0,-3);\n        if (sdslen(repr2)) sdsrange(repr2,0,-3);\n        /* Select the right one and discard the other. */\n        s = sdscatlen(s,\"{\",1);\n        s = sdscatsds(s,is_array ? repr1 : repr2);\n        s = sdscatlen(s,\"}\",1);\n        sdsfree(repr1);\n        sdsfree(repr2);\n        }\n        break;\n    case LUA_TFUNCTION:\n    case LUA_TUSERDATA:\n    case LUA_TTHREAD:\n    case LUA_TLIGHTUSERDATA:\n        {\n        const void *p = lua_topointer(lua,idx);\n        char *typename = \"unknown\";\n        if (t == LUA_TFUNCTION) typename = \"function\";\n        else if (t == LUA_TUSERDATA) typename = \"userdata\";\n        else if (t == LUA_TTHREAD) typename = \"thread\";\n        else if (t == LUA_TLIGHTUSERDATA) typename = \"light-userdata\";\n        s = sdscatprintf(s,\"\\\"%s@%p\\\"\",typename,p);\n        }\n        break;\n    default:\n        s = sdscat(s,\"\\\"<unknown-lua-type>\\\"\");\n        break;\n    }\n    return s;\n}\n\n/* Higher level wrapper for ldbCatStackValueRec() that just uses an initial\n * recursion level of '0'. */\nsds ldbCatStackValue(sds s, lua_State *lua, int idx) {\n    return ldbCatStackValueRec(s,lua,idx,0);\n}\n\n/* Produce a debugger log entry representing the value of the Lua object\n * currently on the top of the stack. The element is ot popped nor modified.\n * Check ldbCatStackValue() for the actual implementation. */\nvoid ldbLogStackValue(lua_State *lua, char *prefix) {\n    sds s = sdsnew(prefix);\n    s = ldbCatStackValue(s,lua,-1);\n    ldbLogWithMaxLen(s);\n}\n\nchar *ldbRedisProtocolToHuman_Int(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Status(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Set(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Map(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Null(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Bool(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Double(sds *o, char *reply);\n\n/* Get Redis protocol from 'reply' and appends it in human readable form to\n * the passed SDS string 'o'.\n *\n * Note that the SDS string is passed by reference (pointer of pointer to\n * char*) so that we can return a modified pointer, as for SDS semantics. */\nchar *ldbRedisProtocolToHuman(sds *o, char *reply) {\n    char *p = reply;\n    switch(*p) {\n    case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;\n    case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;\n    case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;\n    case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;\n    case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;\n    case '~': p = ldbRedisProtocolToHuman_Set(o,reply); break;\n    case '%': p = ldbRedisProtocolToHuman_Map(o,reply); break;\n    case '_': p = ldbRedisProtocolToHuman_Null(o,reply); break;\n    case '#': p = ldbRedisProtocolToHuman_Bool(o,reply); break;\n    case ',': p = ldbRedisProtocolToHuman_Double(o,reply); break;\n    }\n    return p;\n}\n\n/* The following functions are helpers for ldbRedisProtocolToHuman(), each\n * take care of a given Redis return type. */\n\nchar *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    *o = sdscatlen(*o,reply+1,p-reply-1);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long bulklen;\n\n    string2ll(reply+1,p-reply-1,&bulklen);\n    if (bulklen == -1) {\n        *o = sdscatlen(*o,\"NULL\",4);\n        return p+2;\n    } else {\n        *o = sdscatrepr(*o,p+2,bulklen);\n        return p+2+bulklen+2;\n    }\n}\n\nchar *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n\n    *o = sdscatrepr(*o,reply,p-reply);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    p += 2;\n    if (mbulklen == -1) {\n        *o = sdscatlen(*o,\"NULL\",4);\n        return p;\n    }\n    *o = sdscatlen(*o,\"[\",1);\n    for (j = 0; j < mbulklen; j++) {\n        p = ldbRedisProtocolToHuman(o,p);\n        if (j != mbulklen-1) *o = sdscatlen(*o,\",\",1);\n    }\n    *o = sdscatlen(*o,\"]\",1);\n    return p;\n}\n\nchar *ldbRedisProtocolToHuman_Set(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    p += 2;\n    *o = sdscatlen(*o,\"~(\",2);\n    for (j = 0; j < mbulklen; j++) {\n        p = ldbRedisProtocolToHuman(o,p);\n        if (j != mbulklen-1) *o = sdscatlen(*o,\",\",1);\n    }\n    *o = sdscatlen(*o,\")\",1);\n    return p;\n}\n\nchar *ldbRedisProtocolToHuman_Map(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    p += 2;\n    *o = sdscatlen(*o,\"{\",1);\n    for (j = 0; j < mbulklen; j++) {\n        p = ldbRedisProtocolToHuman(o,p);\n        *o = sdscatlen(*o,\" => \",4);\n        p = ldbRedisProtocolToHuman(o,p);\n        if (j != mbulklen-1) *o = sdscatlen(*o,\",\",1);\n    }\n    *o = sdscatlen(*o,\"}\",1);\n    return p;\n}\n\nchar *ldbRedisProtocolToHuman_Null(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    *o = sdscatlen(*o,\"(null)\",6);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_Bool(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    if (reply[1] == 't')\n        *o = sdscatlen(*o,\"#true\",5);\n    else\n        *o = sdscatlen(*o,\"#false\",6);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_Double(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    *o = sdscatlen(*o,\"(double) \",9);\n    *o = sdscatlen(*o,reply+1,p-reply-1);\n    return p+2;\n}\n\n/* Log a Redis reply as debugger output, in a human readable format.\n * If the resulting string is longer than 'len' plus a few more chars\n * used as prefix, it gets truncated. */\nvoid ldbLogRedisReply(char *reply) {\n    sds log = sdsnew(\"<reply> \");\n    ldbRedisProtocolToHuman(&log,reply);\n    ldbLogWithMaxLen(log);\n}\n\n/* Implements the \"print <var>\" command of the Lua debugger. It scans for Lua\n * var \"varname\" starting from the current stack frame up to the top stack\n * frame. The first matching variable is printed. */\nvoid ldbPrint(lua_State *lua, char *varname) {\n    lua_Debug ar;\n\n    int l = 0; /* Stack level. */\n    while (lua_getstack(lua,l,&ar) != 0) {\n        l++;\n        const char *name;\n        int i = 1; /* Variable index. */\n        while((name = lua_getlocal(lua,&ar,i)) != NULL) {\n            i++;\n            if (strcmp(varname,name) == 0) {\n                ldbLogStackValue(lua,\"<value> \");\n                lua_pop(lua,1);\n                return;\n            } else {\n                lua_pop(lua,1); /* Discard the var name on the stack. */\n            }\n        }\n    }\n\n    /* Let's try with global vars in two selected cases */\n    if (!strcmp(varname,\"ARGV\") || !strcmp(varname,\"KEYS\")) {\n        lua_getglobal(lua, varname);\n        ldbLogStackValue(lua,\"<value> \");\n        lua_pop(lua,1);\n    } else {\n        ldbLog(sdsnew(\"No such variable.\"));\n    }\n}\n\n/* Implements the \"print\" command (without arguments) of the Lua debugger.\n * Prints all the variables in the current stack frame. */\nvoid ldbPrintAll(lua_State *lua) {\n    lua_Debug ar;\n    int vars = 0;\n\n    if (lua_getstack(lua,0,&ar) != 0) {\n        const char *name;\n        int i = 1; /* Variable index. */\n        while((name = lua_getlocal(lua,&ar,i)) != NULL) {\n            i++;\n            if (!strstr(name,\"(*temporary)\")) {\n                sds prefix = sdscatprintf(sdsempty(),\"<value> %s = \",name);\n                ldbLogStackValue(lua,prefix);\n                sdsfree(prefix);\n                vars++;\n            }\n            lua_pop(lua,1);\n        }\n    }\n\n    if (vars == 0) {\n        ldbLog(sdsnew(\"No local variables in the current context.\"));\n    }\n}\n\n/* Implements the break command to list, add and remove breakpoints. */\nvoid ldbBreak(sds *argv, int argc) {\n    if (argc == 1) {\n        if (ldb.bpcount == 0) {\n            ldbLog(sdsnew(\"No breakpoints set. Use 'b <line>' to add one.\"));\n            return;\n        } else {\n            ldbLog(sdscatfmt(sdsempty(),\"%i breakpoints set:\",ldb.bpcount));\n            int j;\n            for (j = 0; j < ldb.bpcount; j++)\n                ldbLogSourceLine(ldb.bp[j]);\n        }\n    } else {\n        int j;\n        for (j = 1; j < argc; j++) {\n            char *arg = argv[j];\n            long line;\n            if (!string2l(arg,sdslen(arg),&line)) {\n                ldbLog(sdscatfmt(sdsempty(),\"Invalid argument:'%s'\",arg));\n            } else {\n                if (line == 0) {\n                    ldb.bpcount = 0;\n                    ldbLog(sdsnew(\"All breakpoints removed.\"));\n                } else if (line > 0) {\n                    if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {\n                        ldbLog(sdsnew(\"Too many breakpoints set.\"));\n                    } else if (ldbAddBreakpoint(line)) {\n                        ldbList(line,1);\n                    } else {\n                        ldbLog(sdsnew(\"Wrong line number.\"));\n                    }\n                } else if (line < 0) {\n                    if (ldbDelBreakpoint(-line))\n                        ldbLog(sdsnew(\"Breakpoint removed.\"));\n                    else\n                        ldbLog(sdsnew(\"No breakpoint in the specified line.\"));\n                }\n            }\n        }\n    }\n}\n\n/* Implements the Lua debugger \"eval\" command. It just compiles the user\n * passed fragment of code and executes it, showing the result left on\n * the stack. */\nvoid ldbEval(lua_State *lua, sds *argv, int argc) {\n    /* Glue the script together if it is composed of multiple arguments. */\n    sds code = sdsjoinsds(argv+1,argc-1,\" \",1);\n    sds expr = sdscatsds(sdsnew(\"return \"),code);\n\n    /* Try to compile it as an expression, prepending \"return \". */\n    if (luaL_loadbuffer(lua,expr,sdslen(expr),\"@ldb_eval\")) {\n        lua_pop(lua,1);\n        /* Failed? Try as a statement. */\n        if (luaL_loadbuffer(lua,code,sdslen(code),\"@ldb_eval\")) {\n            ldbLog(sdscatfmt(sdsempty(),\"<error> %s\",lua_tostring(lua,-1)));\n            lua_pop(lua,1);\n            sdsfree(code);\n            sdsfree(expr);\n            return;\n        }\n    }\n\n    /* Call it. */\n    sdsfree(code);\n    sdsfree(expr);\n    if (lua_pcall(lua,0,1,0)) {\n        ldbLog(sdscatfmt(sdsempty(),\"<error> %s\",lua_tostring(lua,-1)));\n        lua_pop(lua,1);\n        return;\n    }\n    ldbLogStackValue(lua,\"<retval> \");\n    lua_pop(lua,1);\n}\n\n/* Implement the debugger \"redis\" command. We use a trick in order to make\n * the implementation very simple: we just call the Lua redis.call() command\n * implementation, with ldb.step enabled, so as a side effect the Redis command\n * and its reply are logged. */\nvoid ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       /* Stack: redis, redis.call */\n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               /* Force redis.call() to log. */\n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */\n    ldb.step = 0;               /* Disable logging. */\n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             /* Discard the result and clean the stack. */\n}\n\n/* Implements \"trace\" command of the Lua debugger. It just prints a backtrace\n * querying Lua starting from the current callframe back to the outer one. */\nvoid ldbTrace(lua_State *lua) {\n    lua_Debug ar;\n    int level = 0;\n\n    while(lua_getstack(lua,level,&ar)) {\n        lua_getinfo(lua,\"Snl\",&ar);\n        if(strstr(ar.short_src,\"user_script\") != NULL) {\n            ldbLog(sdscatprintf(sdsempty(),\"%s %s:\",\n                (level == 0) ? \"In\" : \"From\",\n                ar.name ? ar.name : \"top level\"));\n            ldbLogSourceLine(ar.currentline);\n        }\n        level++;\n    }\n    if (level == 0) {\n        ldbLog(sdsnew(\"<error> Can't retrieve Lua stack.\"));\n    }\n}\n\n/* Implements the debugger \"maxlen\" command. It just queries or sets the\n * ldb.maxlen variable. */\nvoid ldbMaxlen(sds *argv, int argc) {\n    if (argc == 2) {\n        int newval = atoi(argv[1]);\n        ldb.maxlen_hint_sent = 1; /* User knows about this command. */\n        if (newval != 0 && newval <= 60) newval = 60;\n        ldb.maxlen = newval;\n    }\n    if (ldb.maxlen) {\n        ldbLog(sdscatprintf(sdsempty(),\"<value> replies are truncated at %d bytes.\",(int)ldb.maxlen));\n    } else {\n        ldbLog(sdscatprintf(sdsempty(),\"<value> replies are unlimited.\"));\n    }\n}\n\n/* Read debugging commands from client.\n * Return C_OK if the debugging session is continuing, otherwise\n * C_ERR if the client closed the connection or is timing out. */\nint ldbRepl(lua_State *lua) {\n    sds *argv;\n    int argc;\n\n    /* We continue processing commands until a command that should return\n     * to the Lua interpreter is found. */\n    while(1) {\n        while((argv = ldbReplParseCommand(&argc)) == NULL) {\n            char buf[1024];\n            int nread = connRead(ldb.conn,buf,sizeof(buf));\n            if (nread <= 0) {\n                /* Make sure the script runs without user input since the\n                 * client is no longer connected. */\n                ldb.step = 0;\n                ldb.bpcount = 0;\n                return C_ERR;\n            }\n            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);\n        }\n\n        /* Flush the old buffer. */\n        sdsfree(ldb.cbuf);\n        ldb.cbuf = sdsempty();\n\n        /* Execute the command. */\n        if (!strcasecmp(argv[0],\"h\") || !strcasecmp(argv[0],\"help\")) {\nldbLog(sdsnew(\"Redis Lua debugger help:\"));\nldbLog(sdsnew(\"[h]elp               Show this help.\"));\nldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));\nldbLog(sdsnew(\"[n]ext               Alias for step.\"));\nldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));\nldbLog(sdsnew(\"[l]list              List source code around current line.\"));\nldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));\nldbLog(sdsnew(\"                     line = 0 means: current position.\"));\nldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));\nldbLog(sdsnew(\"                     to show before/after [line].\"));\nldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));\nldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));\nldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));\nldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));\nldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));\nldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));\nldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));\nldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));\nldbLog(sdsnew(\"[t]race              Show a backtrace.\"));\nldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));\nldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));\nldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));\nldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));\nldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));\nldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));\nldbLog(sdsnew(\"\"));\nldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));\nldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));\nldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));\nldbLog(sdsnew(\"                     next line of code.\"));\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"s\") || !strcasecmp(argv[0],\"step\") ||\n                   !strcasecmp(argv[0],\"n\") || !strcasecmp(argv[0],\"next\")) {\n            ldb.step = 1;\n            break;\n        } else if (!strcasecmp(argv[0],\"c\") || !strcasecmp(argv[0],\"continue\")){\n            break;\n        } else if (!strcasecmp(argv[0],\"t\") || !strcasecmp(argv[0],\"trace\")) {\n            ldbTrace(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"m\") || !strcasecmp(argv[0],\"maxlen\")) {\n            ldbMaxlen(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"b\") || !strcasecmp(argv[0],\"break\")) {\n            ldbBreak(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"e\") || !strcasecmp(argv[0],\"eval\")) {\n            ldbEval(lua,argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"a\") || !strcasecmp(argv[0],\"abort\")) {\n            lua_pushstring(lua, \"script aborted for user request\");\n            lua_error(lua);\n        } else if (argc > 1 &&\n                   (!strcasecmp(argv[0],\"r\") || !strcasecmp(argv[0],\"redis\"))) {\n            ldbRedis(lua,argv,argc);\n            ldbSendLogs();\n        } else if ((!strcasecmp(argv[0],\"p\") || !strcasecmp(argv[0],\"print\"))) {\n            if (argc == 2)\n                ldbPrint(lua,argv[1]);\n            else\n                ldbPrintAll(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"l\") || !strcasecmp(argv[0],\"list\")){\n            int around = ldb.currentline, ctx = 5;\n            if (argc > 1) {\n                int num = atoi(argv[1]);\n                if (num > 0) around = num;\n            }\n            if (argc > 2) ctx = atoi(argv[2]);\n            ldbList(around,ctx);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"w\") || !strcasecmp(argv[0],\"whole\")){\n            ldbList(1,1000000);\n            ldbSendLogs();\n        } else {\n            ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"\n                          \"wrong number of arguments.\"));\n            ldbSendLogs();\n        }\n\n        /* Free the command vector. */\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Free the current command argv if we break inside the while loop. */\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}\n\n/* This is the core of our Lua debugger, called each time Lua is about\n * to start executing a new line. */\nvoid luaLdbLineHook(lua_State *lua, lua_Debug *ar) {\n    lua_getstack(lua,0,ar);\n    lua_getinfo(lua,\"Sl\",ar);\n    ldb.currentline = ar->currentline;\n\n    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;\n    int timeout = 0;\n\n    /* Events outside our script are not interesting. */\n    if(strstr(ar->short_src,\"user_script\") == NULL) return;\n\n    /* Check if a timeout occurred. */\n    if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {\n        mstime_t elapsed = mstime() - server.lua_time_start;\n        mstime_t timelimit = server.lua_time_limit ?\n                             server.lua_time_limit : 5000;\n        if (elapsed >= timelimit) {\n            timeout = 1;\n            ldb.step = 1;\n        } else {\n            return; /* No timeout, ignore the COUNT event. */\n        }\n    }\n\n    if (ldb.step || bp) {\n        char *reason = \"step over\";\n        if (bp) reason = ldb.luabp ? \"redis.breakpoint() called\" :\n                                     \"break point\";\n        else if (timeout) reason = \"timeout reached, infinite loop?\";\n        ldb.step = 0;\n        ldb.luabp = 0;\n        ldbLog(sdscatprintf(sdsempty(),\n            \"* Stopped at %d, stop reason = %s\",\n            ldb.currentline, reason));\n        ldbLogSourceLine(ldb.currentline);\n        ldbSendLogs();\n        if (ldbRepl(lua) == C_ERR && timeout) {\n            /* If the client closed the connection and we have a timeout\n             * connection, let's kill the script otherwise the process\n             * will remain blocked indefinitely. */\n            lua_pushstring(lua, \"timeout during Lua debugging with client closing connection\");\n            lua_error(lua);\n        }\n        server.lua_time_start = mstime();\n    }\n}\n\n", "start_server {tags {\"scripting\"}} {\n    test {EVAL - Does Lua interpreter replies to our requests?} {\n        r eval {return 'hello'} 0\n    } {hello}\n\n    test {EVAL - Lua integer -> Redis protocol type conversion} {\n        r eval {return 100.5} 0\n    } {100}\n\n    test {EVAL - Lua string -> Redis protocol type conversion} {\n        r eval {return 'hello world'} 0\n    } {hello world}\n\n    test {EVAL - Lua true boolean -> Redis protocol type conversion} {\n        r eval {return true} 0\n    } {1}\n\n    test {EVAL - Lua false boolean -> Redis protocol type conversion} {\n        r eval {return false} 0\n    } {}\n\n    test {EVAL - Lua status code reply -> Redis protocol type conversion} {\n        r eval {return {ok='fine'}} 0\n    } {fine}\n\n    test {EVAL - Lua error reply -> Redis protocol type conversion} {\n        catch {\n            r eval {return {err='this is an error'}} 0\n        } e\n        set _ $e\n    } {this is an error}\n\n    test {EVAL - Lua table -> Redis protocol type conversion} {\n        r eval {return {1,2,3,'ciao',{1,2}}} 0\n    } {1 2 3 ciao {1 2}}\n\n    test {EVAL - Are the KEYS and ARGV arrays populated correctly?} {\n        r eval {return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}} 2 a b c d\n    } {a b c d}\n\n    test {EVAL - is Lua able to call Redis API?} {\n        r set mykey myval\n        r eval {return redis.call('get',KEYS[1])} 1 mykey\n    } {myval}\n\n    test {EVALSHA - Can we call a SHA1 if already defined?} {\n        r evalsha fd758d1589d044dd850a6f05d52f2eefd27f033f 1 mykey\n    } {myval}\n\n    test {EVALSHA - Can we call a SHA1 in uppercase?} {\n        r evalsha FD758D1589D044DD850A6F05D52F2EEFD27F033F 1 mykey\n    } {myval}\n\n    test {EVALSHA - Do we get an error on invalid SHA1?} {\n        catch {r evalsha NotValidShaSUM 0} e\n        set _ $e\n    } {NOSCRIPT*}\n\n    test {EVALSHA - Do we get an error on non defined SHA1?} {\n        catch {r evalsha ffd632c7d33e571e9f24556ebed26c3479a87130 0} e\n        set _ $e\n    } {NOSCRIPT*}\n\n    test {EVAL - Redis integer -> Lua type conversion} {\n        r set x 0\n        r eval {\n            local foo = redis.pcall('incr',KEYS[1])\n            return {type(foo),foo}\n        } 1 x\n    } {number 1}\n\n    test {EVAL - Redis bulk -> Lua type conversion} {\n        r set mykey myval\n        r eval {\n            local foo = redis.pcall('get',KEYS[1])\n            return {type(foo),foo}\n        } 1 mykey\n    } {string myval}\n\n    test {EVAL - Redis multi bulk -> Lua type conversion} {\n        r del mylist\n        r rpush mylist a\n        r rpush mylist b\n        r rpush mylist c\n        r eval {\n            local foo = redis.pcall('lrange',KEYS[1],0,-1)\n            return {type(foo),foo[1],foo[2],foo[3],# foo}\n        } 1 mylist\n    } {table a b c 3}\n\n    test {EVAL - Redis status reply -> Lua type conversion} {\n        r eval {\n            local foo = redis.pcall('set',KEYS[1],'myval')\n            return {type(foo),foo['ok']}\n        } 1 mykey\n    } {table OK}\n\n    test {EVAL - Redis error reply -> Lua type conversion} {\n        r set mykey myval\n        r eval {\n            local foo = redis.pcall('incr',KEYS[1])\n            return {type(foo),foo['err']}\n        } 1 mykey\n    } {table {ERR value is not an integer or out of range}}\n\n    test {EVAL - Redis nil bulk reply -> Lua type conversion} {\n        r del mykey\n        r eval {\n            local foo = redis.pcall('get',KEYS[1])\n            return {type(foo),foo == false}\n        } 1 mykey\n    } {boolean 1}\n\n    test {EVAL - Is the Lua client using the currently selected DB?} {\n        r set mykey \"this is DB 9\"\n        r select 10\n        r set mykey \"this is DB 10\"\n        r eval {return redis.pcall('get',KEYS[1])} 1 mykey\n    } {this is DB 10}\n\n    test {EVAL - SELECT inside Lua should not affect the caller} {\n        # here we DB 10 is selected\n        r set mykey \"original value\"\n        r eval {return redis.pcall('select','9')} 0\n        set res [r get mykey]\n        r select 9\n        set res\n    } {original value}\n\n    if 0 {\n        test {EVAL - Script can't run more than configured time limit} {\n            r config set lua-time-limit 1\n            catch {\n                r eval {\n                    local i = 0\n                    while true do i=i+1 end\n                } 0\n            } e\n            set _ $e\n        } {*execution time*}\n    }\n\n    test {EVAL - Scripts can't run certain commands} {\n        set e {}\n        catch {r eval {return redis.pcall('blpop','x',0)} 0} e\n        set e\n    } {*not allowed*}\n\n    test {EVAL - Scripts can't run XREAD and XREADGROUP with BLOCK option} {\n        r del s\n        r xgroup create s g $ MKSTREAM\n        set res [r eval {return redis.pcall('xread','STREAMS','s','$')} 1 s]\n        assert {$res eq {}}\n        assert_error \"*xread command is not allowed with BLOCK option from scripts\" {r eval {return redis.pcall('xread','BLOCK',0,'STREAMS','s','$')} 1 s}\n        set res [r eval {return redis.pcall('xreadgroup','group','g','c','STREAMS','s','>')} 1 s]\n        assert {$res eq {}}\n        assert_error \"*xreadgroup command is not allowed with BLOCK option from scripts\" {r eval {return redis.pcall('xreadgroup','group','g','c','BLOCK',0,'STREAMS','s','>')} 1 s}\n    }\n\n    test {EVAL - Scripts can't run certain commands} {\n        set e {}\n        r debug lua-always-replicate-commands 0\n        catch {\n            r eval \"redis.pcall('randomkey'); return redis.pcall('set','x','ciao')\" 0\n        } e\n        r debug lua-always-replicate-commands 1\n        set e\n    } {*not allowed after*}\n\n    test {EVAL - No arguments to redis.call/pcall is considered an error} {\n        set e {}\n        catch {r eval {return redis.call()} 0} e\n        set e\n    } {*one argument*}\n\n    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {\n        set e {}\n        catch {\n            r eval \"redis.call('nosuchcommand')\" 0\n        } e\n        set e\n    } {*Unknown Redis*}\n\n    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {\n        set e {}\n        catch {\n            r eval \"redis.call('get','a','b','c')\" 0\n        } e\n        set e\n    } {*number of args*}\n\n    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {\n        set e {}\n        r set foo bar\n        catch {\n            r eval {redis.call('lpush',KEYS[1],'val')} 1 foo\n        } e\n        set e\n    } {*against a key*}\n\n    test {EVAL - JSON numeric decoding} {\n        # We must return the table as a string because otherwise\n        # Redis converts floats to ints and we get 0 and 1023 instead\n        # of 0.0003 and 1023.2 as the parsed output.\n        r eval {return\n                 table.concat(\n                   cjson.decode(\n                    \"[0.0, -5e3, -1, 0.3e-3, 1023.2, 0e10]\"), \" \")\n        } 0\n    } {0 -5000 -1 0.0003 1023.2 0}\n\n    test {EVAL - JSON string decoding} {\n        r eval {local decoded = cjson.decode('{\"keya\": \"a\", \"keyb\": \"b\"}')\n                return {decoded.keya, decoded.keyb}\n        } 0\n    } {a b}\n\n    test {EVAL - cmsgpack can pack double?} {\n        r eval {local encoded = cmsgpack.pack(0.1)\n                local h = \"\"\n                for i = 1, #encoded do\n                    h = h .. string.format(\"%02x\",string.byte(encoded,i))\n                end\n                return h\n        } 0\n    } {cb3fb999999999999a}\n\n    test {EVAL - cmsgpack can pack negative int64?} {\n        r eval {local encoded = cmsgpack.pack(-1099511627776)\n                local h = \"\"\n                for i = 1, #encoded do\n                    h = h .. string.format(\"%02x\",string.byte(encoded,i))\n                end\n                return h\n        } 0\n    } {d3ffffff0000000000}\n\n    test {EVAL - cmsgpack can pack and unpack circular references?} {\n        r eval {local a = {x=nil,y=5}\n                local b = {x=a}\n                a['x'] = b\n                local encoded = cmsgpack.pack(a)\n                local h = \"\"\n                -- cmsgpack encodes to a depth of 16, but can't encode\n                -- references, so the encoded object has a deep copy recusive\n                -- depth of 16.\n                for i = 1, #encoded do\n                    h = h .. string.format(\"%02x\",string.byte(encoded,i))\n                end\n                -- when unpacked, re.x.x != re because the unpack creates\n                -- individual tables down to a depth of 16.\n                -- (that's why the encoded output is so large)\n                local re = cmsgpack.unpack(encoded)\n                assert(re)\n                assert(re.x)\n                assert(re.x.x.y == re.y)\n                assert(re.x.x.x.x.y == re.y)\n                assert(re.x.x.x.x.x.x.y == re.y)\n                assert(re.x.x.x.x.x.x.x.x.x.x.y == re.y)\n                -- maximum working depth:\n                assert(re.x.x.x.x.x.x.x.x.x.x.x.x.x.x.y == re.y)\n                -- now the last x would be b above and has no y\n                assert(re.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x)\n                -- so, the final x.x is at the depth limit and was assigned nil\n                assert(re.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x == nil)\n                return {h, re.x.x.x.x.x.x.x.x.y == re.y, re.y == 5}\n        } 0\n    } {82a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a178c0 1 1}\n\n    test {EVAL - Numerical sanity check from bitop} {\n        r eval {assert(0x7fffffff == 2147483647, \"broken hex literals\");\n                assert(0xffffffff == -1 or 0xffffffff == 2^32-1,\n                    \"broken hex literals\");\n                assert(tostring(-1) == \"-1\", \"broken tostring()\");\n                assert(tostring(0xffffffff) == \"-1\" or\n                    tostring(0xffffffff) == \"4294967295\",\n                    \"broken tostring()\")\n        } 0\n    } {}\n\n    test {EVAL - Verify minimal bitop functionality} {\n        r eval {assert(bit.tobit(1) == 1);\n                assert(bit.band(1) == 1);\n                assert(bit.bxor(1,2) == 3);\n                assert(bit.bor(1,2,4,8,16,32,64,128) == 255)\n        } 0\n    } {}\n\n    test {EVAL - Able to parse trailing comments} {\n        r eval {return 'hello' --trailing comment} 0\n    } {hello}\n\n    test {SCRIPTING FLUSH - is able to clear the scripts cache?} {\n        r set mykey myval\n        set v [r evalsha fd758d1589d044dd850a6f05d52f2eefd27f033f 1 mykey]\n        assert_equal $v myval\n        set e \"\"\n        r script flush\n        catch {r evalsha fd758d1589d044dd850a6f05d52f2eefd27f033f 1 mykey} e\n        set e\n    } {NOSCRIPT*}\n\n    test {SCRIPT EXISTS - can detect already defined scripts?} {\n        r eval \"return 1+1\" 0\n        r script exists a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9 a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bda\n    } {1 0}\n\n    test {SCRIPT LOAD - is able to register scripts in the scripting cache} {\n        list \\\n            [r script load \"return 'loaded'\"] \\\n            [r evalsha b534286061d4b9e4026607613b95c06c06015ae8 0]\n    } {b534286061d4b9e4026607613b95c06c06015ae8 loaded}\n\n    test \"In the context of Lua the output of random commands gets ordered\" {\n        r debug lua-always-replicate-commands 0\n        r del myset\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        set res [r eval {return redis.call('smembers',KEYS[1])} 1 myset]\n        r debug lua-always-replicate-commands 1\n        set res\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z}\n\n    test \"SORT is normally not alpha re-ordered for the scripting engine\" {\n        r del myset\n        r sadd myset 1 2 3 4 10\n        r eval {return redis.call('sort',KEYS[1],'desc')} 1 myset\n    } {10 4 3 2 1}\n\n    test \"SORT BY <constant> output gets ordered for scripting\" {\n        r del myset\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        r eval {return redis.call('sort',KEYS[1],'by','_')} 1 myset\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z}\n\n    test \"SORT BY <constant> with GET gets ordered for scripting\" {\n        r del myset\n        r sadd myset a b c\n        r eval {return redis.call('sort',KEYS[1],'by','_','get','#','get','_:*')} 1 myset\n    } {a {} b {} c {}}\n\n    test \"redis.sha1hex() implementation\" {\n        list [r eval {return redis.sha1hex('')} 0] \\\n             [r eval {return redis.sha1hex('Pizza & Mandolino')} 0]\n    } {da39a3ee5e6b4b0d3255bfef95601890afd80709 74822d82031af7493c20eefa13bd07ec4fada82f}\n\n    test {Globals protection reading an undeclared global variable} {\n        catch {r eval {return a} 0} e\n        set e\n    } {*ERR*attempted to access * global*}\n\n    test {Globals protection setting an undeclared global*} {\n        catch {r eval {a=10} 0} e\n        set e\n    } {*ERR*attempted to create global*}\n\n    test {Test an example script DECR_IF_GT} {\n        set decr_if_gt {\n            local current\n\n            current = redis.call('get',KEYS[1])\n            if not current then return nil end\n            if current > ARGV[1] then\n                return redis.call('decr',KEYS[1])\n            else\n                return redis.call('get',KEYS[1])\n            end\n        }\n        r set foo 5\n        set res {}\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        set res\n    } {4 3 2 2 2}\n\n    test {Scripting engine resets PRNG at every script execution} {\n        set rand1 [r eval {return tostring(math.random())} 0]\n        set rand2 [r eval {return tostring(math.random())} 0]\n        assert_equal $rand1 $rand2\n    }\n\n    test {Scripting engine PRNG can be seeded correctly} {\n        set rand1 [r eval {\n            math.randomseed(ARGV[1]); return tostring(math.random())\n        } 0 10]\n        set rand2 [r eval {\n            math.randomseed(ARGV[1]); return tostring(math.random())\n        } 0 10]\n        set rand3 [r eval {\n            math.randomseed(ARGV[1]); return tostring(math.random())\n        } 0 20]\n        assert_equal $rand1 $rand2\n        assert {$rand2 ne $rand3}\n    }\n\n    test {EVAL does not leak in the Lua stack} {\n        r set x 0\n        # Use a non blocking client to speedup the loop.\n        set rd [redis_deferring_client]\n        for {set j 0} {$j < 10000} {incr j} {\n            $rd eval {return redis.call(\"incr\",KEYS[1])} 1 x\n        }\n        for {set j 0} {$j < 10000} {incr j} {\n            $rd read\n        }\n        assert {[s used_memory_lua] < 1024*100}\n        $rd close\n        r get x\n    } {10000}\n\n    test {EVAL processes writes from AOF in read-only slaves} {\n        r flushall\n        r config set appendonly yes\n        r config set aof-use-rdb-preamble no\n        r eval {redis.call(\"set\",KEYS[1],\"100\")} 1 foo\n        r eval {redis.call(\"incr\",KEYS[1])} 1 foo\n        r eval {redis.call(\"incr\",KEYS[1])} 1 foo\n        wait_for_condition 50 100 {\n            [s aof_rewrite_in_progress] == 0\n        } else {\n            fail \"AOF rewrite can't complete after CONFIG SET appendonly yes.\"\n        }\n        r config set slave-read-only yes\n        r slaveof 127.0.0.1 0\n        r debug loadaof\n        set res [r get foo]\n        r slaveof no one\n        set res\n    } {102}\n\n    test {EVAL timeout from AOF} {\n        # generate a long running script that is propagated to the AOF as script\n        # make sure that the script times out during loading\n        r config set appendonly no\n        r config set aof-use-rdb-preamble no\n        r config set lua-replicate-commands no\n        r flushall\n        r config set appendonly yes\n        wait_for_condition 50 100 {\n            [s aof_rewrite_in_progress] == 0\n        } else {\n            fail \"AOF rewrite can't complete after CONFIG SET appendonly yes.\"\n        }\n        r config set lua-time-limit 1\n        set rd [redis_deferring_client]\n        set start [clock clicks -milliseconds]\n        $rd eval {redis.call('set',KEYS[1],'y'); for i=1,1500000 do redis.call('ping') end return 'ok'} 1 x\n        $rd flush\n        after 100\n        catch {r ping} err\n        assert_match {BUSY*} $err\n        $rd read\n        set elapsed [expr [clock clicks -milliseconds]-$start]\n        if {$::verbose} { puts \"script took $elapsed milliseconds\" }\n        set start [clock clicks -milliseconds]\n        $rd debug loadaof\n        $rd flush\n        after 100\n        catch {r ping} err\n        assert_match {LOADING*} $err\n        $rd read\n        set elapsed [expr [clock clicks -milliseconds]-$start]\n        if {$::verbose} { puts \"loading took $elapsed milliseconds\" }\n        $rd close\n        r get x\n    } {y}\n    r config set aof-use-rdb-preamble yes\n    r config set lua-replicate-commands yes\n\n    test {We can call scripts rewriting client->argv from Lua} {\n        r del myset\n        r sadd myset a b c\n        r mset a 1 b 2 c 3 d 4\n        assert {[r spop myset] ne {}}\n        assert {[r spop myset 1] ne {}}\n        assert {[r spop myset] ne {}}\n        assert {[r mget a b c d] eq {1 2 3 4}}\n        assert {[r spop myset] eq {}}\n    }\n\n    test {Call Redis command with many args from Lua (issue #1764)} {\n        r eval {\n            local i\n            local x={}\n            redis.call('del','mylist')\n            for i=1,100 do\n                table.insert(x,i)\n            end\n            redis.call('rpush','mylist',unpack(x))\n            return redis.call('lrange','mylist',0,-1)\n        } 0\n    } {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100}\n\n    test {Number conversion precision test (issue #1118)} {\n        r eval {\n              local value = 9007199254740991\n              redis.call(\"set\",\"foo\",value)\n              return redis.call(\"get\",\"foo\")\n        } 0\n    } {9007199254740991}\n\n    test {String containing number precision test (regression of issue #1118)} {\n        r eval {\n            redis.call(\"set\", \"key\", \"12039611435714932082\")\n            return redis.call(\"get\", \"key\")\n        } 0\n    } {12039611435714932082}\n\n    test {Verify negative arg count is error instead of crash (issue #1842)} {\n        catch { r eval { return \"hello\" } -12 } e\n        set e\n    } {ERR Number of keys can't be negative}\n\n    test {Correct handling of reused argv (issue #1939)} {\n        r eval {\n              for i = 0, 10 do\n                  redis.call('SET', 'a', '1')\n                  redis.call('MGET', 'a', 'b', 'c')\n                  redis.call('EXPIRE', 'a', 0)\n                  redis.call('GET', 'a')\n                  redis.call('MGET', 'a', 'b', 'c')\n              end\n        } 0\n    }\n\n    test {Functions in the Redis namespace are able to report errors} {\n        catch {\n            r eval {\n                  redis.sha1hex()\n            } 0\n        } e\n        set e\n    } {*wrong number*}\n\n    test {Script with RESP3 map} {\n        set expected_dict [dict create field value]\n        set expected_list [list field value]\n\n        # Sanity test for RESP3 without scripts\n        r HELLO 3\n        r hset hash field value\n        set res [r hgetall hash]\n        assert_equal $res $expected_dict\n\n        # Test RESP3 client with script in both RESP2 and RESP3 modes\n        set res [r eval {redis.setresp(3); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_dict\n        set res [r eval {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_list\n\n        # Test RESP2 client with script in both RESP2 and RESP3 modes\n        r HELLO 2\n        set res [r eval {redis.setresp(3); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_list\n        set res [r eval {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_list\n    }\n}\n\n# Start a new server since the last test in this stanza will kill the\n# instance at all.\nstart_server {tags {\"scripting\"}} {\n    test {Timedout read-only scripts can be killed by SCRIPT KILL} {\n        set rd [redis_deferring_client]\n        r config set lua-time-limit 10\n        $rd eval {while true do end} 0\n        after 200\n        catch {r ping} e\n        assert_match {BUSY*} $e\n        r script kill\n        after 200 ; # Give some time to Lua to call the hook again...\n        assert_equal [r ping] \"PONG\"\n    }\n\n    test {Timedout script link is still usable after Lua returns} {\n        r config set lua-time-limit 10\n        r eval {for i=1,100000 do redis.call('ping') end return 'ok'} 0\n        r ping\n    } {PONG}\n\n    test {Timedout scripts that modified data can't be killed by SCRIPT KILL} {\n        set rd [redis_deferring_client]\n        r config set lua-time-limit 10\n        $rd eval {redis.call('set',KEYS[1],'y'); while true do end} 1 x\n        after 200\n        catch {r ping} e\n        assert_match {BUSY*} $e\n        catch {r script kill} e\n        assert_match {UNKILLABLE*} $e\n        catch {r ping} e\n        assert_match {BUSY*} $e\n    }\n\n    # Note: keep this test at the end of this server stanza because it\n    # kills the server.\n    test {SHUTDOWN NOSAVE can kill a timedout script anyway} {\n        # The server should be still unresponding to normal commands.\n        catch {r ping} e\n        assert_match {BUSY*} $e\n        catch {r shutdown nosave}\n        # Make sure the server was killed\n        catch {set rd [redis_deferring_client]} e\n        assert_match {*connection refused*} $e\n    }\n}\n\nforeach cmdrepl {0 1} {\n    start_server {tags {\"scripting repl\"}} {\n        start_server {} {\n            if {$cmdrepl == 1} {\n                set rt \"(commands replication)\"\n            } else {\n                set rt \"(scripts replication)\"\n                r debug lua-always-replicate-commands 1\n            }\n\n            test \"Before the replica connects we issue two EVAL commands $rt\" {\n                # One with an error, but still executing a command.\n                # SHA is: 67164fc43fa971f76fd1aaeeaf60c1c178d25876\n                catch {\n                    r eval {redis.call('incr',KEYS[1]); redis.call('nonexisting')} 1 x\n                }\n                # One command is correct:\n                # SHA is: 6f5ade10a69975e903c6d07b10ea44c6382381a5\n                r eval {return redis.call('incr',KEYS[1])} 1 x\n            } {2}\n\n            test \"Connect a replica to the master instance $rt\" {\n                r -1 slaveof [srv 0 host] [srv 0 port]\n                wait_for_condition 50 100 {\n                    [s -1 role] eq {slave} &&\n                    [string match {*master_link_status:up*} [r -1 info replication]]\n                } else {\n                    fail \"Can't turn the instance into a replica\"\n                }\n            }\n\n            test \"Now use EVALSHA against the master, with both SHAs $rt\" {\n                # The server should replicate successful and unsuccessful\n                # commands as EVAL instead of EVALSHA.\n                catch {\n                    r evalsha 67164fc43fa971f76fd1aaeeaf60c1c178d25876 1 x\n                }\n                r evalsha 6f5ade10a69975e903c6d07b10ea44c6382381a5 1 x\n            } {4}\n\n            test \"If EVALSHA was replicated as EVAL, 'x' should be '4' $rt\" {\n                wait_for_condition 50 100 {\n                    [r -1 get x] eq {4}\n                } else {\n                    fail \"Expected 4 in x, but value is '[r -1 get x]'\"\n                }\n            }\n\n            test \"Replication of script multiple pushes to list with BLPOP $rt\" {\n                set rd [redis_deferring_client]\n                $rd brpop a 0\n                r eval {\n                    redis.call(\"lpush\",KEYS[1],\"1\");\n                    redis.call(\"lpush\",KEYS[1],\"2\");\n                } 1 a\n                set res [$rd read]\n                $rd close\n                wait_for_condition 50 100 {\n                    [r -1 lrange a 0 -1] eq [r lrange a 0 -1]\n                } else {\n                    fail \"Expected list 'a' in replica and master to be the same, but they are respectively '[r -1 lrange a 0 -1]' and '[r lrange a 0 -1]'\"\n                }\n                set res\n            } {a 1}\n\n            test \"EVALSHA replication when first call is readonly $rt\" {\n                r del x\n                r eval {if tonumber(ARGV[1]) > 0 then redis.call('incr', KEYS[1]) end} 1 x 0\n                r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 0\n                r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 1\n                wait_for_condition 50 100 {\n                    [r -1 get x] eq {1}\n                } else {\n                    fail \"Expected 1 in x, but value is '[r -1 get x]'\"\n                }\n            }\n\n            test \"Lua scripts using SELECT are replicated correctly $rt\" {\n                r eval {\n                    redis.call(\"set\",\"foo1\",\"bar1\")\n                    redis.call(\"select\",\"10\")\n                    redis.call(\"incr\",\"x\")\n                    redis.call(\"select\",\"11\")\n                    redis.call(\"incr\",\"z\")\n                } 0\n                r eval {\n                    redis.call(\"set\",\"foo1\",\"bar1\")\n                    redis.call(\"select\",\"10\")\n                    redis.call(\"incr\",\"x\")\n                    redis.call(\"select\",\"11\")\n                    redis.call(\"incr\",\"z\")\n                } 0\n                wait_for_condition 50 100 {\n                    [r -1 debug digest] eq [r debug digest]\n                } else {\n                    fail \"Master-Replica desync after Lua script using SELECT.\"\n                }\n            }\n        }\n    }\n}\n\nstart_server {tags {\"scripting repl\"}} {\n    start_server {overrides {appendonly yes aof-use-rdb-preamble no}} {\n        test \"Connect a replica to the master instance\" {\n            r -1 slaveof [srv 0 host] [srv 0 port]\n            wait_for_condition 50 100 {\n                [s -1 role] eq {slave} &&\n                [string match {*master_link_status:up*} [r -1 info replication]]\n            } else {\n                fail \"Can't turn the instance into a replica\"\n            }\n        }\n\n        test \"Redis.replicate_commands() must be issued before any write\" {\n            r eval {\n                redis.call('set','foo','bar');\n                return redis.replicate_commands();\n            } 0\n        } {}\n\n        test \"Redis.replicate_commands() must be issued before any write (2)\" {\n            r eval {\n                return redis.replicate_commands();\n            } 0\n        } {1}\n\n        test \"Redis.set_repl() must be issued after replicate_commands()\" {\n            r debug lua-always-replicate-commands 0\n            catch {\n                r eval {\n                    redis.set_repl(redis.REPL_ALL);\n                } 0\n            } e\n            r debug lua-always-replicate-commands 1\n            set e\n        } {*only after turning on*}\n\n        test \"Redis.set_repl() don't accept invalid values\" {\n            catch {\n                r eval {\n                    redis.replicate_commands();\n                    redis.set_repl(12345);\n                } 0\n            } e\n            set e\n        } {*Invalid*flags*}\n\n        test \"Test selective replication of certain Redis commands from Lua\" {\n            r del a b c d\n            r eval {\n                redis.replicate_commands();\n                redis.call('set','a','1');\n                redis.set_repl(redis.REPL_NONE);\n                redis.call('set','b','2');\n                redis.set_repl(redis.REPL_AOF);\n                redis.call('set','c','3');\n                redis.set_repl(redis.REPL_ALL);\n                redis.call('set','d','4');\n            } 0\n\n            wait_for_condition 50 100 {\n                [r -1 mget a b c d] eq {1 {} {} 4}\n            } else {\n                fail \"Only a and c should be replicated to replica\"\n            }\n\n            # Master should have everything right now\n            assert {[r mget a b c d] eq {1 2 3 4}}\n\n            # After an AOF reload only a, c and d should exist\n            r debug loadaof\n\n            assert {[r mget a b c d] eq {1 {} 3 4}}\n        }\n\n        test \"PRNG is seeded randomly for command replication\" {\n            set a [\n                r eval {\n                    redis.replicate_commands();\n                    return math.random()*100000;\n                } 0\n            ]\n            set b [\n                r eval {\n                    redis.replicate_commands();\n                    return math.random()*100000;\n                } 0\n            ]\n            assert {$a ne $b}\n        }\n\n        test \"Using side effects is not a problem with command replication\" {\n            r eval {\n                redis.replicate_commands();\n                redis.call('set','time',redis.call('time')[1])\n            } 0\n\n            assert {[r get time] ne {}}\n\n            wait_for_condition 50 100 {\n                [r get time] eq [r -1 get time]\n            } else {\n                fail \"Time key does not match between master and replica\"\n            }\n        }\n    }\n}\n\nstart_server {tags {\"scripting\"}} {\n    r script debug sync\n    r eval {return 'hello'} 0\n    r eval {return 'hello'} 0\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"sha1.h\"\n#include \"rand.h\"\n#include \"cluster.h\"\n\n#include <lua.h>\n#include <lauxlib.h>\n#include <lualib.h>\n#include <ctype.h>\n#include <math.h>\n\nchar *redisProtocolToLuaType_Int(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Status(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Error(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype);\nchar *redisProtocolToLuaType_Null(lua_State *lua, char *reply);\nchar *redisProtocolToLuaType_Bool(lua_State *lua, char *reply, int tf);\nchar *redisProtocolToLuaType_Double(lua_State *lua, char *reply);\nint redis_math_random (lua_State *L);\nint redis_math_randomseed (lua_State *L);\nvoid ldbInit(void);\nvoid ldbDisable(client *c);\nvoid ldbEnable(client *c);\nvoid evalGenericCommandWithDebugging(client *c, int evalsha);\nvoid luaLdbLineHook(lua_State *lua, lua_Debug *ar);\nvoid ldbLog(sds entry);\nvoid ldbLogRedisReply(char *reply);\nsds ldbCatStackValue(sds s, lua_State *lua, int idx);\n\n/* Debugger shared state is stored inside this global structure. */\n#define LDB_BREAKPOINTS_MAX 64  /* Max number of breakpoints. */\n#define LDB_MAX_LEN_DEFAULT 256 /* Default len limit for replies / var dumps. */\nstruct ldbState {\n    connection *conn; /* Connection of the debugging client. */\n    int active; /* Are we debugging EVAL right now? */\n    int forked; /* Is this a fork()ed debugging session? */\n    list *logs; /* List of messages to send to the client. */\n    list *traces; /* Messages about Redis commands executed since last stop.*/\n    list *children; /* All forked debugging sessions pids. */\n    int bp[LDB_BREAKPOINTS_MAX]; /* An array of breakpoints line numbers. */\n    int bpcount; /* Number of valid entries inside bp. */\n    int step;   /* Stop at next line regardless of breakpoints. */\n    int luabp;  /* Stop at next line because redis.breakpoint() was called. */\n    sds *src;   /* Lua script source code split by line. */\n    int lines;  /* Number of lines in 'src'. */\n    int currentline;    /* Current line number. */\n    sds cbuf;   /* Debugger client command buffer. */\n    size_t maxlen;  /* Max var dump / reply length. */\n    int maxlen_hint_sent; /* Did we already hint about \"set maxlen\"? */\n} ldb;\n\n/* ---------------------------------------------------------------------------\n * Utility functions.\n * ------------------------------------------------------------------------- */\n\n/* Perform the SHA1 of the input string. We use this both for hashing script\n * bodies in order to obtain the Lua function name, and in the implementation\n * of redis.sha1().\n *\n * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an\n * hexadecimal number, plus 1 byte for null term. */\nvoid sha1hex(char *digest, char *script, size_t len) {\n    SHA1_CTX ctx;\n    unsigned char hash[20];\n    char *cset = \"0123456789abcdef\";\n    int j;\n\n    SHA1Init(&ctx);\n    SHA1Update(&ctx,(unsigned char*)script,len);\n    SHA1Final(hash,&ctx);\n\n    for (j = 0; j < 20; j++) {\n        digest[j*2] = cset[((hash[j]&0xF0)>>4)];\n        digest[j*2+1] = cset[(hash[j]&0xF)];\n    }\n    digest[40] = '\\0';\n}\n\n/* ---------------------------------------------------------------------------\n * Redis reply to Lua type conversion functions.\n * ------------------------------------------------------------------------- */\n\n/* Take a Redis reply in the Redis protocol format and convert it into a\n * Lua type. Thanks to this function, and the introduction of not connected\n * clients, it is trivial to implement the redis() lua function.\n *\n * Basically we take the arguments, execute the Redis command in the context\n * of a non connected client, then take the generated reply and convert it\n * into a suitable Lua type. With this trick the scripting feature does not\n * need the introduction of a full Redis internals API. The script\n * is like a normal client that bypasses all the slow I/O paths.\n *\n * Note: in this function we do not do any sanity check as the reply is\n * generated by Redis directly. This allows us to go faster.\n *\n * Errors are returned as a table with a single 'err' field set to the\n * error string.\n */\n\nchar *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    char *p = reply;\n\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}\n\nchar *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long value;\n\n    string2ll(reply+1,p-reply-1,&value);\n    lua_pushnumber(lua,(lua_Number)value);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long bulklen;\n\n    string2ll(reply+1,p-reply-1,&bulklen);\n    if (bulklen == -1) {\n        lua_pushboolean(lua,0);\n        return p+2;\n    } else {\n        lua_pushlstring(lua,p+2,bulklen);\n        return p+2+bulklen+2;\n    }\n}\n\nchar *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"ok\");\n    lua_pushlstring(lua,reply+1,p-reply-1);\n    lua_settable(lua,-3);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"err\");\n    lua_pushlstring(lua,reply+1,p-reply-1);\n    lua_settable(lua,-3);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        /* Here we handle only Set and Map replies in RESP3 mode, since arrays\n         * follow the above RESP2 code path. Note that those are represented\n         * as a table with the \"map\" or \"set\" field populated with the actual\n         * table representing the set or the map type. */\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}\n\nchar *redisProtocolToLuaType_Null(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    lua_pushnil(lua);\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Bool(lua_State *lua, char *reply, int tf) {\n    char *p = strchr(reply+1,'\\r');\n    lua_pushboolean(lua,tf == 't');\n    return p+2;\n}\n\nchar *redisProtocolToLuaType_Double(lua_State *lua, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    char buf[MAX_LONG_DOUBLE_CHARS+1];\n    size_t len = p-reply-1;\n    double d;\n\n    if (len <= MAX_LONG_DOUBLE_CHARS) {\n        memcpy(buf,reply+1,len);\n        buf[len] = '\\0';\n        d = strtod(buf,NULL); /* We expect a valid representation. */\n    } else {\n        d = 0;\n    }\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"double\");\n    lua_pushnumber(lua,d);\n    lua_settable(lua,-3);\n    return p+2;\n}\n\n/* This function is used in order to push an error on the Lua stack in the\n * format used by redis.pcall to return errors, which is a lua table\n * with a single \"err\" field set to the error string. Note that this\n * table is never a valid reply by proper commands, since the returned\n * tables are otherwise always indexed by integers, never by strings. */\nvoid luaPushError(lua_State *lua, char *error) {\n    lua_Debug dbg;\n\n    /* If debugging is active and in step mode, log errors resulting from\n     * Redis commands. */\n    if (ldb.active && ldb.step) {\n        ldbLog(sdscatprintf(sdsempty(),\"<error> %s\",error));\n    }\n\n    lua_newtable(lua);\n    lua_pushstring(lua,\"err\");\n\n    /* Attempt to figure out where this function was called, if possible */\n    if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, \"nSl\", &dbg)) {\n        sds msg = sdscatprintf(sdsempty(), \"%s: %d: %s\",\n            dbg.source, dbg.currentline, error);\n        lua_pushstring(lua, msg);\n        sdsfree(msg);\n    } else {\n        lua_pushstring(lua, error);\n    }\n    lua_settable(lua,-3);\n}\n\n/* In case the error set into the Lua stack by luaPushError() was generated\n * by the non-error-trapping version of redis.pcall(), which is redis.call(),\n * this function will raise the Lua error so that the execution of the\n * script will be halted. */\nint luaRaiseError(lua_State *lua) {\n    lua_pushstring(lua,\"err\");\n    lua_gettable(lua,-2);\n    return lua_error(lua);\n}\n\n/* Sort the array currently in the stack. We do this to make the output\n * of commands like KEYS or SMEMBERS something deterministic when called\n * from Lua (to play well with AOf/replication).\n *\n * The array is sorted using table.sort itself, and assuming all the\n * list elements are strings. */\nvoid luaSortArray(lua_State *lua) {\n    /* Initial Stack: array */\n    lua_getglobal(lua,\"table\");\n    lua_pushstring(lua,\"sort\");\n    lua_gettable(lua,-2);       /* Stack: array, table, table.sort */\n    lua_pushvalue(lua,-3);      /* Stack: array, table, table.sort, array */\n    if (lua_pcall(lua,1,0,0)) {\n        /* Stack: array, table, error */\n\n        /* We are not interested in the error, we assume that the problem is\n         * that there are 'false' elements inside the array, so we try\n         * again with a slower function but able to handle this case, that\n         * is: table.sort(table, __redis__compare_helper) */\n        lua_pop(lua,1);             /* Stack: array, table */\n        lua_pushstring(lua,\"sort\"); /* Stack: array, table, sort */\n        lua_gettable(lua,-2);       /* Stack: array, table, table.sort */\n        lua_pushvalue(lua,-3);      /* Stack: array, table, table.sort, array */\n        lua_getglobal(lua,\"__redis__compare_helper\");\n        /* Stack: array, table, table.sort, array, __redis__compare_helper */\n        lua_call(lua,2,0);\n    }\n    /* Stack: array (sorted), table */\n    lua_pop(lua,1);             /* Stack: array (sorted) */\n}\n\n/* ---------------------------------------------------------------------------\n * Lua reply to Redis reply conversion functions.\n * ------------------------------------------------------------------------- */\n\n/* Reply to client 'c' converting the top element in the Lua stack to a\n * Redis reply. As a side effect the element is consumed from the stack.  */\nvoid luaReplyToRedisReply(client *c, lua_State *lua) {\n    int t = lua_type(lua,-1);\n\n    switch(t) {\n    case LUA_TSTRING:\n        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n        break;\n    case LUA_TBOOLEAN:\n        if (server.lua_client->resp == 2)\n            addReply(c,lua_toboolean(lua,-1) ? shared.cone :\n                                               shared.null[c->resp]);\n        else\n            addReplyBool(c,lua_toboolean(lua,-1));\n        break;\n    case LUA_TNUMBER:\n        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));\n        break;\n    case LUA_TTABLE:\n        /* We need to check if it is an array, an error, or a status reply.\n         * Error are returned as a single element table with 'err' field.\n         * Status replies are returned as single element table with 'ok'\n         * field. */\n\n        /* Handle error reply. */\n        lua_pushstring(lua,\"err\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds err = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(err,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"-%s\\r\\n\",err));\n            sdsfree(err);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle status reply. */\n        lua_pushstring(lua,\"ok\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds ok = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(ok,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"+%s\\r\\n\",ok));\n            sdsfree(ok);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle double reply. */\n        lua_pushstring(lua,\"double\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TNUMBER) {\n            addReplyDouble(c,lua_tonumber(lua,-1));\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle map reply. */\n        lua_pushstring(lua,\"map\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int maplen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, value */\n                lua_pushvalue(lua,-2);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                luaReplyToRedisReply(c, lua); /* Return value. */\n                /* Stack now: table, key. */\n                maplen++;\n            }\n            setDeferredMapLen(c,replylen,maplen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle set reply. */\n        lua_pushstring(lua,\"set\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int setlen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, true */\n                lua_pop(lua,1);               /* Discard the boolean value. */\n                lua_pushvalue(lua,-1);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                /* Stack now: table, key. */\n                setlen++;\n            }\n            setDeferredSetLen(c,replylen,setlen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle the array reply. */\n        void *replylen = addReplyDeferredLen(c);\n        int j = 1, mbulklen = 0;\n        while(1) {\n            lua_pushnumber(lua,j++);\n            lua_gettable(lua,-2);\n            t = lua_type(lua,-1);\n            if (t == LUA_TNIL) {\n                lua_pop(lua,1);\n                break;\n            }\n            luaReplyToRedisReply(c, lua);\n            mbulklen++;\n        }\n        setDeferredArrayLen(c,replylen,mbulklen);\n        break;\n    default:\n        addReplyNull(c);\n    }\n    lua_pop(lua,1);\n}\n\n/* ---------------------------------------------------------------------------\n * Lua redis.* functions implementations.\n * ------------------------------------------------------------------------- */\n\n#define LUA_CMD_OBJCACHE_SIZE 32\n#define LUA_CMD_OBJCACHE_MAX_LEN 64\nint luaRedisGenericCommand(lua_State *lua, int raise_error) {\n    int j, argc = lua_gettop(lua);\n    struct redisCommand *cmd;\n    client *c = server.lua_client;\n    sds reply;\n\n    /* Cached across calls. */\n    static robj **argv = NULL;\n    static int argv_size = 0;\n    static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];\n    static size_t cached_objects_len[LUA_CMD_OBJCACHE_SIZE];\n    static int inuse = 0;   /* Recursive calls detection. */\n\n    /* By using Lua debug hooks it is possible to trigger a recursive call\n     * to luaRedisGenericCommand(), which normally should never happen.\n     * To make this function reentrant is futile and makes it slower, but\n     * we should at least detect such a misuse, and abort. */\n    if (inuse) {\n        char *recursion_warning =\n            \"luaRedisGenericCommand() recursive call detected. \"\n            \"Are you doing funny stuff with Lua debug hooks?\";\n        serverLog(LL_WARNING,\"%s\",recursion_warning);\n        luaPushError(lua,recursion_warning);\n        return 1;\n    }\n    inuse++;\n\n    /* Require at least one argument */\n    if (argc == 0) {\n        luaPushError(lua,\n            \"Please specify at least one argument for redis.call()\");\n        inuse--;\n        return raise_error ? luaRaiseError(lua) : 1;\n    }\n\n    /* Build the arguments vector */\n    if (argv_size < argc) {\n        argv = zrealloc(argv,sizeof(robj*)*argc);\n        argv_size = argc;\n    }\n\n    for (j = 0; j < argc; j++) {\n        char *obj_s;\n        size_t obj_len;\n        char dbuf[64];\n\n        if (lua_type(lua,j+1) == LUA_TNUMBER) {\n            /* We can't use lua_tolstring() for number -> string conversion\n             * since Lua uses a format specifier that loses precision. */\n            lua_Number num = lua_tonumber(lua,j+1);\n\n            obj_len = snprintf(dbuf,sizeof(dbuf),\"%.17g\",(double)num);\n            obj_s = dbuf;\n        } else {\n            obj_s = (char*)lua_tolstring(lua,j+1,&obj_len);\n            if (obj_s == NULL) break; /* Not a string. */\n        }\n\n        /* Try to use a cached object. */\n        if (j < LUA_CMD_OBJCACHE_SIZE && cached_objects[j] &&\n            cached_objects_len[j] >= obj_len)\n        {\n            sds s = cached_objects[j]->ptr;\n            argv[j] = cached_objects[j];\n            cached_objects[j] = NULL;\n            memcpy(s,obj_s,obj_len+1);\n            sdssetlen(s, obj_len);\n        } else {\n            argv[j] = createStringObject(obj_s, obj_len);\n        }\n    }\n\n    /* Check if one of the arguments passed by the Lua script\n     * is not a string or an integer (lua_isstring() return true for\n     * integers as well). */\n    if (j != argc) {\n        j--;\n        while (j >= 0) {\n            decrRefCount(argv[j]);\n            j--;\n        }\n        luaPushError(lua,\n            \"Lua redis() command arguments must be strings or integers\");\n        inuse--;\n        return raise_error ? luaRaiseError(lua) : 1;\n    }\n\n    /* Setup our fake client for command execution */\n    c->argv = argv;\n    c->argc = argc;\n    c->user = server.lua_caller->user;\n\n    /* Process module hooks */\n    moduleCallCommandFilters(c);\n    argv = c->argv;\n    argc = c->argc;\n\n    /* Log the command if debugging is active. */\n    if (ldb.active && ldb.step) {\n        sds cmdlog = sdsnew(\"<redis>\");\n        for (j = 0; j < c->argc; j++) {\n            if (j == 10) {\n                cmdlog = sdscatprintf(cmdlog,\" ... (%d more)\",\n                    c->argc-j-1);\n                break;\n            } else {\n                cmdlog = sdscatlen(cmdlog,\" \",1);\n                cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);\n            }\n        }\n        ldbLog(cmdlog);\n    }\n\n    /* Command lookup */\n    cmd = lookupCommand(argv[0]->ptr);\n    if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) ||\n                   (argc < -cmd->arity)))\n    {\n        if (cmd)\n            luaPushError(lua,\n                \"Wrong number of args calling Redis command From Lua script\");\n        else\n            luaPushError(lua,\"Unknown Redis command called from Lua script\");\n        goto cleanup;\n    }\n    c->cmd = c->lastcmd = cmd;\n\n    /* There are commands that are not allowed inside scripts. */\n    if (cmd->flags & CMD_NOSCRIPT) {\n        luaPushError(lua, \"This Redis command is not allowed from scripts\");\n        goto cleanup;\n    }\n\n    /* Check the ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            luaPushError(lua, \"The user executing the script can't run this \"\n                              \"command or subcommand\");\n        else\n            luaPushError(lua, \"The user executing the script can't access \"\n                              \"at least one of the keys mentioned in the \"\n                              \"command arguments\");\n        goto cleanup;\n    }\n\n    /* Write commands are forbidden against read-only slaves, or if a\n     * command marked as non-deterministic was already called in the context\n     * of this script. */\n    if (cmd->flags & CMD_WRITE) {\n        int deny_write_type = writeCommandsDeniedByDiskError();\n        if (server.lua_random_dirty && !server.lua_replicate_commands) {\n            luaPushError(lua,\n                \"Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.\");\n            goto cleanup;\n        } else if (server.masterhost && server.repl_slave_ro &&\n                   !server.loading &&\n                   !(server.lua_caller->flags & CLIENT_MASTER))\n        {\n            luaPushError(lua, shared.roslaveerr->ptr);\n            goto cleanup;\n        } else if (deny_write_type != DISK_ERROR_TYPE_NONE) {\n            if (deny_write_type == DISK_ERROR_TYPE_RDB) {\n                luaPushError(lua, shared.bgsaveerr->ptr);\n            } else {\n                sds aof_write_err = sdscatfmt(sdsempty(),\n                    \"-MISCONF Errors writing to the AOF file: %s\\r\\n\",\n                    strerror(server.aof_last_write_errno));\n                luaPushError(lua, aof_write_err);\n                sdsfree(aof_write_err);\n            }\n            goto cleanup;\n        }\n    }\n\n    /* If we reached the memory limit configured via maxmemory, commands that\n     * could enlarge the memory usage are not allowed, but only if this is the\n     * first write in the context of this script, otherwise we can't stop\n     * in the middle. */\n    if (server.maxmemory &&             /* Maxmemory is actually enabled. */\n        !server.loading &&              /* Don't care about mem if loading. */\n        !server.masterhost &&           /* Slave must execute the script. */\n        server.lua_write_dirty == 0 &&  /* Script had no side effects so far. */\n        server.lua_oom &&               /* Detected OOM when script start. */\n        (cmd->flags & CMD_DENYOOM))\n    {\n        luaPushError(lua, shared.oomerr->ptr);\n        goto cleanup;\n    }\n\n    if (cmd->flags & CMD_RANDOM) server.lua_random_dirty = 1;\n    if (cmd->flags & CMD_WRITE) server.lua_write_dirty = 1;\n\n    /* If this is a Redis Cluster node, we need to make sure Lua is not\n     * trying to access non-local keys, with the exception of commands\n     * received from our master or when loading the AOF back in memory. */\n    if (server.cluster_enabled && !server.loading &&\n        !(server.lua_caller->flags & CLIENT_MASTER))\n    {\n        int error_code;\n        /* Duplicate relevant flags in the lua client. */\n        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);\n        c->flags |= server.lua_caller->flags & (CLIENT_READONLY|CLIENT_ASKING);\n        if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,&error_code) !=\n                           server.cluster->myself)\n        {\n            if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) { \n                luaPushError(lua,\n                    \"Lua script attempted to execute a write command while the \"\n                    \"cluster is down and readonly\");\n            } else if (error_code == CLUSTER_REDIR_DOWN_STATE) { \n                luaPushError(lua,\n                    \"Lua script attempted to execute a command while the \"\n                    \"cluster is down\");\n            } else {\n                luaPushError(lua,\n                    \"Lua script attempted to access a non local key in a \"\n                    \"cluster node\");\n            }\n\n            goto cleanup;\n        }\n    }\n\n    /* If we are using single commands replication, we need to wrap what\n     * we propagate into a MULTI/EXEC block, so that it will be atomic like\n     * a Lua script in the context of AOF and slaves. */\n    if (server.lua_replicate_commands &&\n        !server.lua_multi_emitted &&\n        !(server.lua_caller->flags & CLIENT_MULTI) &&\n        server.lua_write_dirty &&\n        server.lua_repl != PROPAGATE_NONE)\n    {\n        execCommandPropagateMulti(server.lua_caller);\n        server.lua_multi_emitted = 1;\n        /* Now we are in the MULTI context, the lua_client should be\n         * flag as CLIENT_MULTI. */\n        c->flags |= CLIENT_MULTI;\n    }\n\n    /* Run the command */\n    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;\n    if (server.lua_replicate_commands) {\n        /* Set flags according to redis.set_repl() settings. */\n        if (server.lua_repl & PROPAGATE_AOF)\n            call_flags |= CMD_CALL_PROPAGATE_AOF;\n        if (server.lua_repl & PROPAGATE_REPL)\n            call_flags |= CMD_CALL_PROPAGATE_REPL;\n    }\n    call(c,call_flags);\n\n    /* Convert the result of the Redis command into a suitable Lua type.\n     * The first thing we need is to create a single string from the client\n     * output buffers. */\n    if (listLength(c->reply) == 0 && c->bufpos < PROTO_REPLY_CHUNK_BYTES) {\n        /* This is a fast path for the common case of a reply inside the\n         * client static buffer. Don't create an SDS string but just use\n         * the client buffer directly. */\n        c->buf[c->bufpos] = '\\0';\n        reply = c->buf;\n        c->bufpos = 0;\n    } else {\n        reply = sdsnewlen(c->buf,c->bufpos);\n        c->bufpos = 0;\n        while(listLength(c->reply)) {\n            clientReplyBlock *o = listNodeValue(listFirst(c->reply));\n\n            reply = sdscatlen(reply,o->buf,o->used);\n            listDelNode(c->reply,listFirst(c->reply));\n        }\n    }\n    if (raise_error && reply[0] != '-') raise_error = 0;\n    redisProtocolToLuaType(lua,reply);\n\n    /* If the debugger is active, log the reply from Redis. */\n    if (ldb.active && ldb.step)\n        ldbLogRedisReply(reply);\n\n    /* Sort the output array if needed, assuming it is a non-null multi bulk\n     * reply as expected. */\n    if ((cmd->flags & CMD_SORT_FOR_SCRIPT) &&\n        (server.lua_replicate_commands == 0) &&\n        (reply[0] == '*' && reply[1] != '-')) {\n            luaSortArray(lua);\n    }\n    if (reply != c->buf) sdsfree(reply);\n    c->reply_bytes = 0;\n\ncleanup:\n    /* Clean up. Command code may have changed argv/argc so we use the\n     * argv/argc of the client instead of the local variables. */\n    for (j = 0; j < c->argc; j++) {\n        robj *o = c->argv[j];\n\n        /* Try to cache the object in the cached_objects array.\n         * The object must be small, SDS-encoded, and with refcount = 1\n         * (we must be the only owner) for us to cache it. */\n        if (j < LUA_CMD_OBJCACHE_SIZE &&\n            o->refcount == 1 &&\n            (o->encoding == OBJ_ENCODING_RAW ||\n             o->encoding == OBJ_ENCODING_EMBSTR) &&\n            sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)\n        {\n            sds s = o->ptr;\n            if (cached_objects[j]) decrRefCount(cached_objects[j]);\n            cached_objects[j] = o;\n            cached_objects_len[j] = sdsalloc(s);\n        } else {\n            decrRefCount(o);\n        }\n    }\n\n    if (c->argv != argv) {\n        zfree(c->argv);\n        argv = NULL;\n        argv_size = 0;\n    }\n\n    c->user = NULL;\n\n    if (raise_error) {\n        /* If we are here we should have an error in the stack, in the\n         * form of a table with an \"err\" field. Extract the string to\n         * return the plain error. */\n        inuse--;\n        return luaRaiseError(lua);\n    }\n    inuse--;\n    return 1;\n}\n\n/* redis.call() */\nint luaRedisCallCommand(lua_State *lua) {\n    return luaRedisGenericCommand(lua,1);\n}\n\n/* redis.pcall() */\nint luaRedisPCallCommand(lua_State *lua) {\n    return luaRedisGenericCommand(lua,0);\n}\n\n/* This adds redis.sha1hex(string) to Lua scripts using the same hashing\n * function used for sha1ing lua scripts. */\nint luaRedisSha1hexCommand(lua_State *lua) {\n    int argc = lua_gettop(lua);\n    char digest[41];\n    size_t len;\n    char *s;\n\n    if (argc != 1) {\n        lua_pushstring(lua, \"wrong number of arguments\");\n        return lua_error(lua);\n    }\n\n    s = (char*)lua_tolstring(lua,1,&len);\n    sha1hex(digest,s,len);\n    lua_pushstring(lua,digest);\n    return 1;\n}\n\n/* Returns a table with a single field 'field' set to the string value\n * passed as argument. This helper function is handy when returning\n * a Redis Protocol error or status reply from Lua:\n *\n * return redis.error_reply(\"ERR Some Error\")\n * return redis.status_reply(\"ERR Some Error\")\n */\nint luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {\n    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {\n        luaPushError(lua, \"wrong number or type of arguments\");\n        return 1;\n    }\n\n    lua_newtable(lua);\n    lua_pushstring(lua, field);\n    lua_pushvalue(lua, -3);\n    lua_settable(lua, -3);\n    return 1;\n}\n\n/* redis.error_reply() */\nint luaRedisErrorReplyCommand(lua_State *lua) {\n    return luaRedisReturnSingleFieldTable(lua,\"err\");\n}\n\n/* redis.status_reply() */\nint luaRedisStatusReplyCommand(lua_State *lua) {\n    return luaRedisReturnSingleFieldTable(lua,\"ok\");\n}\n\n/* redis.replicate_commands()\n *\n * Turn on single commands replication if the script never called\n * a write command so far, and returns true. Otherwise if the script\n * already started to write, returns false and stick to whole scripts\n * replication, which is our default. */\nint luaRedisReplicateCommandsCommand(lua_State *lua) {\n    if (server.lua_write_dirty) {\n        lua_pushboolean(lua,0);\n    } else {\n        server.lua_replicate_commands = 1;\n        /* When we switch to single commands replication, we can provide\n         * different math.random() sequences at every call, which is what\n         * the user normally expects. */\n        redisSrand48(rand());\n        lua_pushboolean(lua,1);\n    }\n    return 1;\n}\n\n/* redis.breakpoint()\n *\n * Allows to stop execution during a debugging session from within\n * the Lua code implementation, like if a breakpoint was set in the code\n * immediately after the function. */\nint luaRedisBreakpointCommand(lua_State *lua) {\n    if (ldb.active) {\n        ldb.luabp = 1;\n        lua_pushboolean(lua,1);\n    } else {\n        lua_pushboolean(lua,0);\n    }\n    return 1;\n}\n\n/* redis.debug()\n *\n * Log a string message into the output console.\n * Can take multiple arguments that will be separated by commas.\n * Nothing is returned to the caller. */\nint luaRedisDebugCommand(lua_State *lua) {\n    if (!ldb.active) return 0;\n    int argc = lua_gettop(lua);\n    sds log = sdscatprintf(sdsempty(),\"<debug> line %d: \", ldb.currentline);\n    while(argc--) {\n        log = ldbCatStackValue(log,lua,-1 - argc);\n        if (argc != 0) log = sdscatlen(log,\", \",2);\n    }\n    ldbLog(log);\n    return 0;\n}\n\n/* redis.set_repl()\n *\n * Set the propagation of write commands executed in the context of the\n * script to on/off for AOF and slaves. */\nint luaRedisSetReplCommand(lua_State *lua) {\n    int argc = lua_gettop(lua);\n    int flags;\n\n    if (server.lua_replicate_commands == 0) {\n        lua_pushstring(lua, \"You can set the replication behavior only after turning on single commands replication with redis.replicate_commands().\");\n        return lua_error(lua);\n    } else if (argc != 1) {\n        lua_pushstring(lua, \"redis.set_repl() requires two arguments.\");\n        return lua_error(lua);\n    }\n\n    flags = lua_tonumber(lua,-1);\n    if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {\n        lua_pushstring(lua, \"Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE.\");\n        return lua_error(lua);\n    }\n    server.lua_repl = flags;\n    return 0;\n}\n\n/* redis.log() */\nint luaLogCommand(lua_State *lua) {\n    int j, argc = lua_gettop(lua);\n    int level;\n    sds log;\n\n    if (argc < 2) {\n        lua_pushstring(lua, \"redis.log() requires two arguments or more.\");\n        return lua_error(lua);\n    } else if (!lua_isnumber(lua,-argc)) {\n        lua_pushstring(lua, \"First argument must be a number (log level).\");\n        return lua_error(lua);\n    }\n    level = lua_tonumber(lua,-argc);\n    if (level < LL_DEBUG || level > LL_WARNING) {\n        lua_pushstring(lua, \"Invalid debug level.\");\n        return lua_error(lua);\n    }\n    if (level < server.verbosity) return 0;\n\n    /* Glue together all the arguments */\n    log = sdsempty();\n    for (j = 1; j < argc; j++) {\n        size_t len;\n        char *s;\n\n        s = (char*)lua_tolstring(lua,(-argc)+j,&len);\n        if (s) {\n            if (j != 1) log = sdscatlen(log,\" \",1);\n            log = sdscatlen(log,s,len);\n        }\n    }\n    serverLogRaw(level,log);\n    sdsfree(log);\n    return 0;\n}\n\n/* redis.setresp() */\nint luaSetResp(lua_State *lua) {\n    int argc = lua_gettop(lua);\n\n    if (argc != 1) {\n        lua_pushstring(lua, \"redis.setresp() requires one argument.\");\n        return lua_error(lua);\n    }\n\n    int resp = lua_tonumber(lua,-argc);\n    if (resp != 2 && resp != 3) {\n        lua_pushstring(lua, \"RESP version must be 2 or 3.\");\n        return lua_error(lua);\n    }\n\n    server.lua_client->resp = resp;\n    return 0;\n}\n\n/* ---------------------------------------------------------------------------\n * Lua engine initialization and reset.\n * ------------------------------------------------------------------------- */\n\nvoid luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {\n  lua_pushcfunction(lua, luafunc);\n  lua_pushstring(lua, libname);\n  lua_call(lua, 1, 0);\n}\n\nLUALIB_API int (luaopen_cjson) (lua_State *L);\nLUALIB_API int (luaopen_struct) (lua_State *L);\nLUALIB_API int (luaopen_cmsgpack) (lua_State *L);\nLUALIB_API int (luaopen_bit) (lua_State *L);\n\nvoid luaLoadLibraries(lua_State *lua) {\n    luaLoadLib(lua, \"\", luaopen_base);\n    luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);\n    luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);\n    luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);\n    luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);\n    luaLoadLib(lua, \"cjson\", luaopen_cjson);\n    luaLoadLib(lua, \"struct\", luaopen_struct);\n    luaLoadLib(lua, \"cmsgpack\", luaopen_cmsgpack);\n    luaLoadLib(lua, \"bit\", luaopen_bit);\n\n#if 0 /* Stuff that we don't load currently, for sandboxing concerns. */\n    luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);\n    luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);\n#endif\n}\n\n/* Remove a functions that we don't want to expose to the Redis scripting\n * environment. */\nvoid luaRemoveUnsupportedFunctions(lua_State *lua) {\n    lua_pushnil(lua);\n    lua_setglobal(lua,\"loadfile\");\n    lua_pushnil(lua);\n    lua_setglobal(lua,\"dofile\");\n}\n\n/* This function installs metamethods in the global table _G that prevent\n * the creation of globals accidentally.\n *\n * It should be the last to be called in the scripting engine initialization\n * sequence, because it may interact with creation of globals. */\nvoid scriptingEnableGlobalsProtection(lua_State *lua) {\n    char *s[32];\n    sds code = sdsempty();\n    int j = 0;\n\n    /* strict.lua from: http://metalua.luaforge.net/src/lib/strict.lua.html.\n     * Modified to be adapted to Redis. */\n    s[j++]=\"local dbg=debug\\n\";\n    s[j++]=\"local mt = {}\\n\";\n    s[j++]=\"setmetatable(_G, mt)\\n\";\n    s[j++]=\"mt.__newindex = function (t, n, v)\\n\";\n    s[j++]=\"  if dbg.getinfo(2) then\\n\";\n    s[j++]=\"    local w = dbg.getinfo(2, \\\"S\\\").what\\n\";\n    s[j++]=\"    if w ~= \\\"main\\\" and w ~= \\\"C\\\" then\\n\";\n    s[j++]=\"      error(\\\"Script attempted to create global variable '\\\"..tostring(n)..\\\"'\\\", 2)\\n\";\n    s[j++]=\"    end\\n\";\n    s[j++]=\"  end\\n\";\n    s[j++]=\"  rawset(t, n, v)\\n\";\n    s[j++]=\"end\\n\";\n    s[j++]=\"mt.__index = function (t, n)\\n\";\n    s[j++]=\"  if dbg.getinfo(2) and dbg.getinfo(2, \\\"S\\\").what ~= \\\"C\\\" then\\n\";\n    s[j++]=\"    error(\\\"Script attempted to access nonexistent global variable '\\\"..tostring(n)..\\\"'\\\", 2)\\n\";\n    s[j++]=\"  end\\n\";\n    s[j++]=\"  return rawget(t, n)\\n\";\n    s[j++]=\"end\\n\";\n    s[j++]=\"debug = nil\\n\";\n    s[j++]=NULL;\n\n    for (j = 0; s[j] != NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));\n    luaL_loadbuffer(lua,code,sdslen(code),\"@enable_strict_lua\");\n    lua_pcall(lua,0,0,0);\n    sdsfree(code);\n}\n\n/* Initialize the scripting environment.\n *\n * This function is called the first time at server startup with\n * the 'setup' argument set to 1.\n *\n * It can be called again multiple times during the lifetime of the Redis\n * process, with 'setup' set to 0, and following a scriptingRelease() call,\n * in order to reset the Lua scripting environment.\n *\n * However it is simpler to just call scriptingReset() that does just that. */\nvoid scriptingInit(int setup) {\n    lua_State *lua = lua_open();\n\n    if (setup) {\n        server.lua_client = NULL;\n        server.lua_caller = NULL;\n        server.lua_cur_script = NULL;\n        server.lua_timedout = 0;\n        ldbInit();\n    }\n\n    luaLoadLibraries(lua);\n    luaRemoveUnsupportedFunctions(lua);\n\n    /* Initialize a dictionary we use to map SHAs to scripts.\n     * This is useful for replication, as we need to replicate EVALSHA\n     * as EVAL, so we need to remember the associated script. */\n    server.lua_scripts = dictCreate(&shaScriptObjectDictType,NULL);\n    server.lua_scripts_mem = 0;\n\n    /* Register the redis commands table and fields */\n    lua_newtable(lua);\n\n    /* redis.call */\n    lua_pushstring(lua,\"call\");\n    lua_pushcfunction(lua,luaRedisCallCommand);\n    lua_settable(lua,-3);\n\n    /* redis.pcall */\n    lua_pushstring(lua,\"pcall\");\n    lua_pushcfunction(lua,luaRedisPCallCommand);\n    lua_settable(lua,-3);\n\n    /* redis.log and log levels. */\n    lua_pushstring(lua,\"log\");\n    lua_pushcfunction(lua,luaLogCommand);\n    lua_settable(lua,-3);\n\n    /* redis.setresp */\n    lua_pushstring(lua,\"setresp\");\n    lua_pushcfunction(lua,luaSetResp);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_DEBUG\");\n    lua_pushnumber(lua,LL_DEBUG);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_VERBOSE\");\n    lua_pushnumber(lua,LL_VERBOSE);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_NOTICE\");\n    lua_pushnumber(lua,LL_NOTICE);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"LOG_WARNING\");\n    lua_pushnumber(lua,LL_WARNING);\n    lua_settable(lua,-3);\n\n    /* redis.sha1hex */\n    lua_pushstring(lua, \"sha1hex\");\n    lua_pushcfunction(lua, luaRedisSha1hexCommand);\n    lua_settable(lua, -3);\n\n    /* redis.error_reply and redis.status_reply */\n    lua_pushstring(lua, \"error_reply\");\n    lua_pushcfunction(lua, luaRedisErrorReplyCommand);\n    lua_settable(lua, -3);\n    lua_pushstring(lua, \"status_reply\");\n    lua_pushcfunction(lua, luaRedisStatusReplyCommand);\n    lua_settable(lua, -3);\n\n    /* redis.replicate_commands */\n    lua_pushstring(lua, \"replicate_commands\");\n    lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);\n    lua_settable(lua, -3);\n\n    /* redis.set_repl and associated flags. */\n    lua_pushstring(lua,\"set_repl\");\n    lua_pushcfunction(lua,luaRedisSetReplCommand);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_NONE\");\n    lua_pushnumber(lua,PROPAGATE_NONE);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_AOF\");\n    lua_pushnumber(lua,PROPAGATE_AOF);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_SLAVE\");\n    lua_pushnumber(lua,PROPAGATE_REPL);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_REPLICA\");\n    lua_pushnumber(lua,PROPAGATE_REPL);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"REPL_ALL\");\n    lua_pushnumber(lua,PROPAGATE_AOF|PROPAGATE_REPL);\n    lua_settable(lua,-3);\n\n    /* redis.breakpoint */\n    lua_pushstring(lua,\"breakpoint\");\n    lua_pushcfunction(lua,luaRedisBreakpointCommand);\n    lua_settable(lua,-3);\n\n    /* redis.debug */\n    lua_pushstring(lua,\"debug\");\n    lua_pushcfunction(lua,luaRedisDebugCommand);\n    lua_settable(lua,-3);\n\n    /* Finally set the table as 'redis' global var. */\n    lua_setglobal(lua,\"redis\");\n\n    /* Replace math.random and math.randomseed with our implementations. */\n    lua_getglobal(lua,\"math\");\n\n    lua_pushstring(lua,\"random\");\n    lua_pushcfunction(lua,redis_math_random);\n    lua_settable(lua,-3);\n\n    lua_pushstring(lua,\"randomseed\");\n    lua_pushcfunction(lua,redis_math_randomseed);\n    lua_settable(lua,-3);\n\n    lua_setglobal(lua,\"math\");\n\n    /* Add a helper function that we use to sort the multi bulk output of non\n     * deterministic commands, when containing 'false' elements. */\n    {\n        char *compare_func =    \"function __redis__compare_helper(a,b)\\n\"\n                                \"  if a == false then a = '' end\\n\"\n                                \"  if b == false then b = '' end\\n\"\n                                \"  return a<b\\n\"\n                                \"end\\n\";\n        luaL_loadbuffer(lua,compare_func,strlen(compare_func),\"@cmp_func_def\");\n        lua_pcall(lua,0,0,0);\n    }\n\n    /* Add a helper function we use for pcall error reporting.\n     * Note that when the error is in the C function we want to report the\n     * information about the caller, that's what makes sense from the point\n     * of view of the user debugging a script. */\n    {\n        char *errh_func =       \"local dbg = debug\\n\"\n                                \"function __redis__err__handler(err)\\n\"\n                                \"  local i = dbg.getinfo(2,'nSl')\\n\"\n                                \"  if i and i.what == 'C' then\\n\"\n                                \"    i = dbg.getinfo(3,'nSl')\\n\"\n                                \"  end\\n\"\n                                \"  if i then\\n\"\n                                \"    return i.source .. ':' .. i.currentline .. ': ' .. err\\n\"\n                                \"  else\\n\"\n                                \"    return err\\n\"\n                                \"  end\\n\"\n                                \"end\\n\";\n        luaL_loadbuffer(lua,errh_func,strlen(errh_func),\"@err_handler_def\");\n        lua_pcall(lua,0,0,0);\n    }\n\n    /* Create the (non connected) client that we use to execute Redis commands\n     * inside the Lua interpreter.\n     * Note: there is no need to create it again when this function is called\n     * by scriptingReset(). */\n    if (server.lua_client == NULL) {\n        server.lua_client = createClient(NULL);\n        server.lua_client->flags |= CLIENT_LUA;\n    }\n\n    /* Lua beginners often don't use \"local\", this is likely to introduce\n     * subtle bugs in their code. To prevent problems we protect accesses\n     * to global variables. */\n    scriptingEnableGlobalsProtection(lua);\n\n    server.lua = lua;\n}\n\n/* Release resources related to Lua scripting.\n * This function is used in order to reset the scripting environment. */\nvoid scriptingRelease(void) {\n    dictRelease(server.lua_scripts);\n    server.lua_scripts_mem = 0;\n    lua_close(server.lua);\n}\n\nvoid scriptingReset(void) {\n    scriptingRelease();\n    scriptingInit(0);\n}\n\n/* Set an array of Redis String Objects as a Lua array (table) stored into a\n * global variable. */\nvoid luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {\n    int j;\n\n    lua_newtable(lua);\n    for (j = 0; j < elec; j++) {\n        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));\n        lua_rawseti(lua,-2,j+1);\n    }\n    lua_setglobal(lua,var);\n}\n\n/* ---------------------------------------------------------------------------\n * Redis provided math.random\n * ------------------------------------------------------------------------- */\n\n/* We replace math.random() with our implementation that is not affected\n * by specific libc random() implementations and will output the same sequence\n * (for the same seed) in every arch. */\n\n/* The following implementation is the one shipped with Lua itself but with\n * rand() replaced by redisLrand48(). */\nint redis_math_random (lua_State *L) {\n  /* the `%' avoids the (rare) case of r==1, and is needed also because on\n     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */\n  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /\n                                (lua_Number)REDIS_LRAND48_MAX;\n  switch (lua_gettop(L)) {  /* check number of arguments */\n    case 0: {  /* no arguments */\n      lua_pushnumber(L, r);  /* Number between 0 and 1 */\n      break;\n    }\n    case 1: {  /* only upper limit */\n      int u = luaL_checkint(L, 1);\n      luaL_argcheck(L, 1<=u, 1, \"interval is empty\");\n      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */\n      break;\n    }\n    case 2: {  /* lower and upper limits */\n      int l = luaL_checkint(L, 1);\n      int u = luaL_checkint(L, 2);\n      luaL_argcheck(L, l<=u, 2, \"interval is empty\");\n      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */\n      break;\n    }\n    default: return luaL_error(L, \"wrong number of arguments\");\n  }\n  return 1;\n}\n\nint redis_math_randomseed (lua_State *L) {\n  redisSrand48(luaL_checkint(L, 1));\n  return 0;\n}\n\n/* ---------------------------------------------------------------------------\n * EVAL and SCRIPT commands implementation\n * ------------------------------------------------------------------------- */\n\n/* Define a Lua function with the specified body.\n * The function name will be generated in the following form:\n *\n *   f_<hex sha1 sum>\n *\n * The function increments the reference count of the 'body' object as a\n * side effect of a successful call.\n *\n * On success a pointer to an SDS string representing the function SHA1 of the\n * just added function is returned (and will be valid until the next call\n * to scriptingReset() function), otherwise NULL is returned.\n *\n * The function handles the fact of being called with a script that already\n * exists, and in such a case, it behaves like in the success case.\n *\n * If 'c' is not NULL, on error the client is informed with an appropriate\n * error describing the nature of the problem and the Lua interpreter error. */\nsds luaCreateFunction(client *c, lua_State *lua, robj *body) {\n    char funcname[43];\n    dictEntry *de;\n\n    funcname[0] = 'f';\n    funcname[1] = '_';\n    sha1hex(funcname+2,body->ptr,sdslen(body->ptr));\n\n    sds sha = sdsnewlen(funcname+2,40);\n    if ((de = dictFind(server.lua_scripts,sha)) != NULL) {\n        sdsfree(sha);\n        return dictGetKey(de);\n    }\n\n    sds funcdef = sdsempty();\n    funcdef = sdscat(funcdef,\"function \");\n    funcdef = sdscatlen(funcdef,funcname,42);\n    funcdef = sdscatlen(funcdef,\"() \",3);\n    funcdef = sdscatlen(funcdef,body->ptr,sdslen(body->ptr));\n    funcdef = sdscatlen(funcdef,\"\\nend\",4);\n\n    if (luaL_loadbuffer(lua,funcdef,sdslen(funcdef),\"@user_script\")) {\n        if (c != NULL) {\n            addReplyErrorFormat(c,\n                \"Error compiling script (new function): %s\\n\",\n                lua_tostring(lua,-1));\n        }\n        lua_pop(lua,1);\n        sdsfree(sha);\n        sdsfree(funcdef);\n        return NULL;\n    }\n    sdsfree(funcdef);\n\n    if (lua_pcall(lua,0,0,0)) {\n        if (c != NULL) {\n            addReplyErrorFormat(c,\"Error running script (new function): %s\\n\",\n                lua_tostring(lua,-1));\n        }\n        lua_pop(lua,1);\n        sdsfree(sha);\n        return NULL;\n    }\n\n    /* We also save a SHA1 -> Original script map in a dictionary\n     * so that we can replicate / write in the AOF all the\n     * EVALSHA commands as EVAL using the original script. */\n    int retval = dictAdd(server.lua_scripts,sha,body);\n    serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);\n    server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);\n    incrRefCount(body);\n    return sha;\n}\n\n/* This is the Lua script \"count\" hook that we use to detect scripts timeout. */\nvoid luaMaskCountHook(lua_State *lua, lua_Debug *ar) {\n    long long elapsed = mstime() - server.lua_time_start;\n    UNUSED(ar);\n    UNUSED(lua);\n\n    /* Set the timeout condition if not already set and the maximum\n     * execution time was reached. */\n    if (elapsed >= server.lua_time_limit && server.lua_timedout == 0) {\n        serverLog(LL_WARNING,\n            \"Lua slow script detected: still in execution after %lld milliseconds. \"\n            \"You can try killing the script using the SCRIPT KILL command. \"\n            \"Script SHA1 is: %s\",\n            elapsed, server.lua_cur_script);\n        server.lua_timedout = 1;\n        /* Once the script timeouts we reenter the event loop to permit others\n         * to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason\n         * we need to mask the client executing the script from the event loop.\n         * If we don't do that the client may disconnect and could no longer be\n         * here when the EVAL command will return. */\n        protectClient(server.lua_caller);\n    }\n    if (server.lua_timedout) processEventsWhileBlocked();\n    if (server.lua_kill) {\n        serverLog(LL_WARNING,\"Lua script killed by user with SCRIPT KILL.\");\n        lua_pushstring(lua,\"Script killed by user with SCRIPT KILL...\");\n        lua_error(lua);\n    }\n}\n\nvoid prepareLuaClient(void) {\n    /* Select the right DB in the context of the Lua client */\n    selectDb(server.lua_client,server.lua_caller->db->id);\n    server.lua_client->resp = 2; /* Default is RESP2, scripts can change it. */\n\n    /* If we are in MULTI context, flag Lua client as CLIENT_MULTI. */\n    if (server.lua_caller->flags & CLIENT_MULTI) {\n        server.lua_client->flags |= CLIENT_MULTI;\n    }\n}\n\nvoid resetLuaClient(void) {\n    /* After the script done, remove the MULTI state. */\n    server.lua_client->flags &= ~CLIENT_MULTI;\n}\n\nvoid evalGenericCommand(client *c, int evalsha) {\n    lua_State *lua = server.lua;\n    char funcname[43];\n    long long numkeys;\n    long long initial_server_dirty = server.dirty;\n    int delhook = 0, err;\n\n    /* When we replicate whole scripts, we want the same PRNG sequence at\n     * every call so that our PRNG is not affected by external state. */\n    redisSrand48(0);\n\n    /* We set this flag to zero to remember that so far no random command\n     * was called. This way we can allow the user to call commands like\n     * SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command\n     * is called (otherwise the replication and AOF would end with non\n     * deterministic sequences).\n     *\n     * Thanks to this flag we'll raise an error every time a write command\n     * is called after a random command was used. */\n    server.lua_random_dirty = 0;\n    server.lua_write_dirty = 0;\n    server.lua_replicate_commands = server.lua_always_replicate_commands;\n    server.lua_multi_emitted = 0;\n    server.lua_repl = PROPAGATE_AOF|PROPAGATE_REPL;\n\n    /* Get the number of arguments that are keys */\n    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)\n        return;\n    if (numkeys > (c->argc - 3)) {\n        addReplyError(c,\"Number of keys can't be greater than number of args\");\n        return;\n    } else if (numkeys < 0) {\n        addReplyError(c,\"Number of keys can't be negative\");\n        return;\n    }\n\n    /* We obtain the script SHA1, then check if this function is already\n     * defined into the Lua state */\n    funcname[0] = 'f';\n    funcname[1] = '_';\n    if (!evalsha) {\n        /* Hash the code if this is an EVAL call */\n        sha1hex(funcname+2,c->argv[1]->ptr,sdslen(c->argv[1]->ptr));\n    } else {\n        /* We already have the SHA if it is an EVALSHA */\n        int j;\n        char *sha = c->argv[1]->ptr;\n\n        /* Convert to lowercase. We don't use tolower since the function\n         * managed to always show up in the profiler output consuming\n         * a non trivial amount of time. */\n        for (j = 0; j < 40; j++)\n            funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?\n                sha[j]+('a'-'A') : sha[j];\n        funcname[42] = '\\0';\n    }\n\n    /* Push the pcall error handler function on the stack. */\n    lua_getglobal(lua, \"__redis__err__handler\");\n\n    /* Try to lookup the Lua function */\n    lua_getglobal(lua, funcname);\n    if (lua_isnil(lua,-1)) {\n        lua_pop(lua,1); /* remove the nil from the stack */\n        /* Function not defined... let's define it if we have the\n         * body of the function. If this is an EVALSHA call we can just\n         * return an error. */\n        if (evalsha) {\n            lua_pop(lua,1); /* remove the error handler from the stack. */\n            addReply(c, shared.noscripterr);\n            return;\n        }\n        if (luaCreateFunction(c,lua,c->argv[1]) == NULL) {\n            lua_pop(lua,1); /* remove the error handler from the stack. */\n            /* The error is sent to the client by luaCreateFunction()\n             * itself when it returns NULL. */\n            return;\n        }\n        /* Now the following is guaranteed to return non nil */\n        lua_getglobal(lua, funcname);\n        serverAssert(!lua_isnil(lua,-1));\n    }\n\n    /* Populate the argv and keys table accordingly to the arguments that\n     * EVAL received. */\n    luaSetGlobalArray(lua,\"KEYS\",c->argv+3,numkeys);\n    luaSetGlobalArray(lua,\"ARGV\",c->argv+3+numkeys,c->argc-3-numkeys);\n\n    /* Set a hook in order to be able to stop the script execution if it\n     * is running for too much time.\n     * We set the hook only if the time limit is enabled as the hook will\n     * make the Lua script execution slower.\n     *\n     * If we are debugging, we set instead a \"line\" hook so that the\n     * debugger is call-back at every line executed by the script. */\n    server.lua_caller = c;\n    server.lua_cur_script = funcname + 2;\n    server.lua_time_start = mstime();\n    server.lua_kill = 0;\n    if (server.lua_time_limit > 0 && ldb.active == 0) {\n        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);\n        delhook = 1;\n    } else if (ldb.active) {\n        lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);\n        delhook = 1;\n    }\n\n    prepareLuaClient();\n\n    /* At this point whether this script was never seen before or if it was\n     * already defined, we can call it. We have zero arguments and expect\n     * a single return value. */\n    err = lua_pcall(lua,0,1,-2);\n\n    resetLuaClient();\n\n    /* Perform some cleanup that we need to do both on error and success. */\n    if (delhook) lua_sethook(lua,NULL,0,0); /* Disable hook */\n    if (server.lua_timedout) {\n        server.lua_timedout = 0;\n        /* Restore the client that was protected when the script timeout\n         * was detected. */\n        unprotectClient(c);\n        if (server.masterhost && server.master)\n            queueClientForReprocessing(server.master);\n    }\n    server.lua_caller = NULL;\n    server.lua_cur_script = NULL;\n\n    /* Call the Lua garbage collector from time to time to avoid a\n     * full cycle performed by Lua, which adds too latency.\n     *\n     * The call is performed every LUA_GC_CYCLE_PERIOD executed commands\n     * (and for LUA_GC_CYCLE_PERIOD collection steps) because calling it\n     * for every command uses too much CPU. */\n    #define LUA_GC_CYCLE_PERIOD 50\n    {\n        static long gc_count = 0;\n\n        gc_count++;\n        if (gc_count == LUA_GC_CYCLE_PERIOD) {\n            lua_gc(lua,LUA_GCSTEP,LUA_GC_CYCLE_PERIOD);\n            gc_count = 0;\n        }\n    }\n\n    if (err) {\n        addReplyErrorFormat(c,\"Error running script (call to %s): %s\\n\",\n            funcname, lua_tostring(lua,-1));\n        lua_pop(lua,2); /* Consume the Lua reply and remove error handler. */\n    } else {\n        /* On success convert the Lua return value into Redis protocol, and\n         * send it to * the client. */\n        luaReplyToRedisReply(c,lua); /* Convert and consume the reply. */\n        lua_pop(lua,1); /* Remove the error handler. */\n    }\n\n    /* If we are using single commands replication, emit EXEC if there\n     * was at least a write. */\n    if (server.lua_replicate_commands) {\n        preventCommandPropagation(c);\n        if (server.lua_multi_emitted) {\n            execCommandPropagateExec(c);\n        }\n    }\n\n    /* EVALSHA should be propagated to Slave and AOF file as full EVAL, unless\n     * we are sure that the script was already in the context of all the\n     * attached slaves *and* the current AOF file if enabled.\n     *\n     * To do so we use a cache of SHA1s of scripts that we already propagated\n     * as full EVAL, that's called the Replication Script Cache.\n     *\n     * For replication, everytime a new slave attaches to the master, we need to\n     * flush our cache of scripts that can be replicated as EVALSHA, while\n     * for AOF we need to do so every time we rewrite the AOF file. */\n    if (evalsha && !server.lua_replicate_commands) {\n        if (!replicationScriptCacheExists(c->argv[1]->ptr)) {\n            /* This script is not in our script cache, replicate it as\n             * EVAL, then add it into the script cache, as from now on\n             * slaves and AOF know about it. */\n            robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);\n\n            replicationScriptCacheAdd(c->argv[1]->ptr);\n            serverAssertWithInfo(c,NULL,script != NULL);\n\n            /* If the script did not produce any changes in the dataset we want\n             * just to replicate it as SCRIPT LOAD, otherwise we risk running\n             * an aborted script on slaves (that may then produce results there)\n             * or just running a CPU costly read-only script on the slaves. */\n            if (server.dirty == initial_server_dirty) {\n                rewriteClientCommandVector(c,3,\n                    resetRefCount(createStringObject(\"SCRIPT\",6)),\n                    resetRefCount(createStringObject(\"LOAD\",4)),\n                    script);\n            } else {\n                rewriteClientCommandArgument(c,0,\n                    resetRefCount(createStringObject(\"EVAL\",4)));\n                rewriteClientCommandArgument(c,1,script);\n            }\n            forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);\n        }\n    }\n}\n\nvoid evalCommand(client *c) {\n    if (!(c->flags & CLIENT_LUA_DEBUG))\n        evalGenericCommand(c,0);\n    else\n        evalGenericCommandWithDebugging(c,0);\n}\n\nvoid evalShaCommand(client *c) {\n    if (sdslen(c->argv[1]->ptr) != 40) {\n        /* We know that a match is not possible if the provided SHA is\n         * not the right length. So we return an error ASAP, this way\n         * evalGenericCommand() can be implemented without string length\n         * sanity check */\n        addReply(c, shared.noscripterr);\n        return;\n    }\n    if (!(c->flags & CLIENT_LUA_DEBUG))\n        evalGenericCommand(c,1);\n    else {\n        addReplyError(c,\"Please use EVAL instead of EVALSHA for debugging\");\n        return;\n    }\n}\n\nvoid scriptCommand(client *c) {\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"DEBUG (yes|sync|no) -- Set the debug mode for subsequent scripts executed.\",\n\"EXISTS <sha1> [<sha1> ...] -- Return information about the existence of the scripts in the script cache.\",\n\"FLUSH -- Flush the Lua scripts cache. Very dangerous on replicas.\",\n\"KILL -- Kill the currently executing Lua script.\",\n\"LOAD <script> -- Load a script into the scripts cache, without executing it.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"flush\")) {\n        scriptingReset();\n        addReply(c,shared.ok);\n        replicationScriptCacheFlush();\n        server.dirty++; /* Propagating this command is a good idea. */\n    } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,\"exists\")) {\n        int j;\n\n        addReplyArrayLen(c, c->argc-2);\n        for (j = 2; j < c->argc; j++) {\n            if (dictFind(server.lua_scripts,c->argv[j]->ptr))\n                addReply(c,shared.cone);\n            else\n                addReply(c,shared.czero);\n        }\n    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,\"load\")) {\n        sds sha = luaCreateFunction(c,server.lua,c->argv[2]);\n        if (sha == NULL) return; /* The error was sent by luaCreateFunction(). */\n        addReplyBulkCBuffer(c,sha,40);\n        forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);\n    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"kill\")) {\n        if (server.lua_caller == NULL) {\n            addReplySds(c,sdsnew(\"-NOTBUSY No scripts in execution right now.\\r\\n\"));\n        } else if (server.lua_caller->flags & CLIENT_MASTER) {\n            addReplySds(c,sdsnew(\"-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed.\\r\\n\"));\n        } else if (server.lua_write_dirty) {\n            addReplySds(c,sdsnew(\"-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\\r\\n\"));\n        } else {\n            server.lua_kill = 1;\n            addReply(c,shared.ok);\n        }\n    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,\"debug\")) {\n        if (clientHasPendingReplies(c)) {\n            addReplyError(c,\"SCRIPT DEBUG must be called outside a pipeline\");\n            return;\n        }\n        if (!strcasecmp(c->argv[2]->ptr,\"no\")) {\n            ldbDisable(c);\n            addReply(c,shared.ok);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"yes\")) {\n            ldbEnable(c);\n            addReply(c,shared.ok);\n        } else if (!strcasecmp(c->argv[2]->ptr,\"sync\")) {\n            ldbEnable(c);\n            addReply(c,shared.ok);\n            c->flags |= CLIENT_LUA_DEBUG_SYNC;\n        } else {\n            addReplyError(c,\"Use SCRIPT DEBUG yes/sync/no\");\n            return;\n        }\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* ---------------------------------------------------------------------------\n * LDB: Redis Lua debugging facilities\n * ------------------------------------------------------------------------- */\n\n/* Initialize Lua debugger data structures. */\nvoid ldbInit(void) {\n    ldb.conn = NULL;\n    ldb.active = 0;\n    ldb.logs = listCreate();\n    listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);\n    ldb.children = listCreate();\n    ldb.src = NULL;\n    ldb.lines = 0;\n    ldb.cbuf = sdsempty();\n}\n\n/* Remove all the pending messages in the specified list. */\nvoid ldbFlushLog(list *log) {\n    listNode *ln;\n\n    while((ln = listFirst(log)) != NULL)\n        listDelNode(log,ln);\n}\n\n/* Enable debug mode of Lua scripts for this client. */\nvoid ldbEnable(client *c) {\n    c->flags |= CLIENT_LUA_DEBUG;\n    ldbFlushLog(ldb.logs);\n    ldb.conn = c->conn;\n    ldb.step = 1;\n    ldb.bpcount = 0;\n    ldb.luabp = 0;\n    sdsfree(ldb.cbuf);\n    ldb.cbuf = sdsempty();\n    ldb.maxlen = LDB_MAX_LEN_DEFAULT;\n    ldb.maxlen_hint_sent = 0;\n}\n\n/* Exit debugging mode from the POV of client. This function is not enough\n * to properly shut down a client debugging session, see ldbEndSession()\n * for more information. */\nvoid ldbDisable(client *c) {\n    c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);\n}\n\n/* Append a log entry to the specified LDB log. */\nvoid ldbLog(sds entry) {\n    listAddNodeTail(ldb.logs,entry);\n}\n\n/* A version of ldbLog() which prevents producing logs greater than\n * ldb.maxlen. The first time the limit is reached a hint is generated\n * to inform the user that reply trimming can be disabled using the\n * debugger \"maxlen\" command. */\nvoid ldbLogWithMaxLen(sds entry) {\n    int trimmed = 0;\n    if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {\n        sdsrange(entry,0,ldb.maxlen-1);\n        entry = sdscatlen(entry,\" ...\",4);\n        trimmed = 1;\n    }\n    ldbLog(entry);\n    if (trimmed && ldb.maxlen_hint_sent == 0) {\n        ldb.maxlen_hint_sent = 1;\n        ldbLog(sdsnew(\n        \"<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming.\"));\n    }\n}\n\n/* Send ldb.logs to the debugging client as a multi-bulk reply\n * consisting of simple strings. Log entries which include newlines have them\n * replaced with spaces. The entries sent are also consumed. */\nvoid ldbSendLogs(void) {\n    sds proto = sdsempty();\n    proto = sdscatfmt(proto,\"*%i\\r\\n\", (int)listLength(ldb.logs));\n    while(listLength(ldb.logs)) {\n        listNode *ln = listFirst(ldb.logs);\n        proto = sdscatlen(proto,\"+\",1);\n        sdsmapchars(ln->value,\"\\r\\n\",\"  \",2);\n        proto = sdscatsds(proto,ln->value);\n        proto = sdscatlen(proto,\"\\r\\n\",2);\n        listDelNode(ldb.logs,ln);\n    }\n    if (connWrite(ldb.conn,proto,sdslen(proto)) == -1) {\n        /* Avoid warning. We don't check the return value of write()\n         * since the next read() will catch the I/O error and will\n         * close the debugging session. */\n    }\n    sdsfree(proto);\n}\n\n/* Start a debugging session before calling EVAL implementation.\n * The technique we use is to capture the client socket file descriptor,\n * in order to perform direct I/O with it from within Lua hooks. This\n * way we don't have to re-enter Redis in order to handle I/O.\n *\n * The function returns 1 if the caller should proceed to call EVAL,\n * and 0 if instead the caller should abort the operation (this happens\n * for the parent in a forked session, since it's up to the children\n * to continue, or when fork returned an error).\n *\n * The caller should call ldbEndSession() only if ldbStartSession()\n * returned 1. */\nint ldbStartSession(client *c) {\n    ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;\n    if (ldb.forked) {\n        pid_t cp = redisFork(CHILD_TYPE_LDB);\n        if (cp == -1) {\n            addReplyError(c,\"Fork() failed: can't run EVAL in debugging mode.\");\n            return 0;\n        } else if (cp == 0) {\n            /* Child. Let's ignore important signals handled by the parent. */\n            struct sigaction act;\n            sigemptyset(&act.sa_mask);\n            act.sa_flags = 0;\n            act.sa_handler = SIG_IGN;\n            sigaction(SIGTERM, &act, NULL);\n            sigaction(SIGINT, &act, NULL);\n\n            /* Log the creation of the child and close the listening\n             * socket to make sure if the parent crashes a reset is sent\n             * to the clients. */\n            serverLog(LL_WARNING,\"Redis forked for debugging eval\");\n        } else {\n            /* Parent */\n            listAddNodeTail(ldb.children,(void*)(unsigned long)cp);\n            freeClientAsync(c); /* Close the client in the parent side. */\n            return 0;\n        }\n    } else {\n        serverLog(LL_WARNING,\n            \"Redis synchronous debugging eval session started\");\n    }\n\n    /* Setup our debugging session. */\n    connBlock(ldb.conn);\n    connSendTimeout(ldb.conn,5000);\n    ldb.active = 1;\n\n    /* First argument of EVAL is the script itself. We split it into different\n     * lines since this is the way the debugger accesses the source code. */\n    sds srcstring = sdsdup(c->argv[1]->ptr);\n    size_t srclen = sdslen(srcstring);\n    while(srclen && (srcstring[srclen-1] == '\\n' ||\n                     srcstring[srclen-1] == '\\r'))\n    {\n        srcstring[--srclen] = '\\0';\n    }\n    sdssetlen(srcstring,srclen);\n    ldb.src = sdssplitlen(srcstring,sdslen(srcstring),\"\\n\",1,&ldb.lines);\n    sdsfree(srcstring);\n    return 1;\n}\n\n/* End a debugging session after the EVAL call with debugging enabled\n * returned. */\nvoid ldbEndSession(client *c) {\n    /* Emit the remaining logs and an <endsession> mark. */\n    ldbLog(sdsnew(\"<endsession>\"));\n    ldbSendLogs();\n\n    /* If it's a fork()ed session, we just exit. */\n    if (ldb.forked) {\n        writeToClient(c,0);\n        serverLog(LL_WARNING,\"Lua debugging session child exiting\");\n        exitFromChild(0);\n    } else {\n        serverLog(LL_WARNING,\n            \"Redis synchronous debugging eval session ended\");\n    }\n\n    /* Otherwise let's restore client's state. */\n    connNonBlock(ldb.conn);\n    connSendTimeout(ldb.conn,0);\n\n    /* Close the client connection after sending the final EVAL reply\n     * in order to signal the end of the debugging session. */\n    c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n\n    /* Cleanup. */\n    sdsfreesplitres(ldb.src,ldb.lines);\n    ldb.lines = 0;\n    ldb.active = 0;\n}\n\n/* If the specified pid is among the list of children spawned for\n * forked debugging sessions, it is removed from the children list.\n * If the pid was found non-zero is returned. */\nint ldbRemoveChild(pid_t pid) {\n    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);\n    if (ln) {\n        listDelNode(ldb.children,ln);\n        return 1;\n    }\n    return 0;\n}\n\n/* Return the number of children we still did not receive termination\n * acknowledge via wait() in the parent process. */\nint ldbPendingChildren(void) {\n    return listLength(ldb.children);\n}\n\n/* Kill all the forked sessions. */\nvoid ldbKillForkedSessions(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(ldb.children,&li);\n    while((ln = listNext(&li))) {\n        pid_t pid = (unsigned long) ln->value;\n        serverLog(LL_WARNING,\"Killing debugging session %ld\",(long)pid);\n        kill(pid,SIGKILL);\n    }\n    listRelease(ldb.children);\n    ldb.children = listCreate();\n}\n\n/* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure\n * that when EVAL returns, whatever happened, the session is ended. */\nvoid evalGenericCommandWithDebugging(client *c, int evalsha) {\n    if (ldbStartSession(c)) {\n        evalGenericCommand(c,evalsha);\n        ldbEndSession(c);\n    } else {\n        ldbDisable(c);\n    }\n}\n\n/* Return a pointer to ldb.src source code line, considering line to be\n * one-based, and returning a special string for out of range lines. */\nchar *ldbGetSourceLine(int line) {\n    int idx = line-1;\n    if (idx < 0 || idx >= ldb.lines) return \"<out of range source code line>\";\n    return ldb.src[idx];\n}\n\n/* Return true if there is a breakpoint in the specified line. */\nint ldbIsBreakpoint(int line) {\n    int j;\n\n    for (j = 0; j < ldb.bpcount; j++)\n        if (ldb.bp[j] == line) return 1;\n    return 0;\n}\n\n/* Add the specified breakpoint. Ignore it if we already reached the max.\n * Returns 1 if the breakpoint was added (or was already set). 0 if there is\n * no space for the breakpoint or if the line is invalid. */\nint ldbAddBreakpoint(int line) {\n    if (line <= 0 || line > ldb.lines) return 0;\n    if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {\n        ldb.bp[ldb.bpcount++] = line;\n        return 1;\n    }\n    return 0;\n}\n\n/* Remove the specified breakpoint, returning 1 if the operation was\n * performed or 0 if there was no such breakpoint. */\nint ldbDelBreakpoint(int line) {\n    int j;\n\n    for (j = 0; j < ldb.bpcount; j++) {\n        if (ldb.bp[j] == line) {\n            ldb.bpcount--;\n            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Expect a valid multi-bulk command in the debugging client query buffer.\n * On success the command is parsed and returned as an array of SDS strings,\n * otherwise NULL is returned and there is to read more buffer. */\nsds *ldbReplParseCommand(int *argcp, char** err) {\n    static char* protocol_error = \"protocol error\";\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n\n    /* Working on a copy is simpler in this case. We can modify it freely\n     * for the sake of simpler parsing. */\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n\n    /* This Redis protocol parser is a joke... just the simplest thing that\n     * works in this context. It is also very forgiving regarding broken\n     * protocol. */\n\n    /* Seek and parse *<count>\\r\\n. */\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; /* Multi bulk len pointer. */\n    p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n\n    /* Parse each argument. */\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        // reached the end but there should be more data to read\n        if (*p == '\\0') goto keep_reading;\n\n        if (*p != '$') goto protoerr;\n        plen = p+1; /* Bulk string len pointer. */\n        p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); /* Length of this arg. */\n        if (slen <= 0 || slen > 1024) goto protoerr;\n        if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; /* Skip the already parsed argument. */\n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; /* Skip \\r\\n. */\n    }\n    sdsfree(copy);\n    return argv;\n\nprotoerr:\n    *err = protocol_error;\nkeep_reading:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}\n\n/* Log the specified line in the Lua debugger output. */\nvoid ldbLogSourceLine(int lnum) {\n    char *line = ldbGetSourceLine(lnum);\n    char *prefix;\n    int bp = ldbIsBreakpoint(lnum);\n    int current = ldb.currentline == lnum;\n\n    if (current && bp)\n        prefix = \"->#\";\n    else if (current)\n        prefix = \"-> \";\n    else if (bp)\n        prefix = \"  #\";\n    else\n        prefix = \"   \";\n    sds thisline = sdscatprintf(sdsempty(),\"%s%-3d %s\", prefix, lnum, line);\n    ldbLog(thisline);\n}\n\n/* Implement the \"list\" command of the Lua debugger. If around is 0\n * the whole file is listed, otherwise only a small portion of the file\n * around the specified line is shown. When a line number is specified\n * the amount of context (lines before/after) is specified via the\n * 'context' argument. */\nvoid ldbList(int around, int context) {\n    int j;\n\n    for (j = 1; j <= ldb.lines; j++) {\n        if (around != 0 && abs(around-j) > context) continue;\n        ldbLogSourceLine(j);\n    }\n}\n\n/* Append a human readable representation of the Lua value at position 'idx'\n * on the stack of the 'lua' state, to the SDS string passed as argument.\n * The new SDS string with the represented value attached is returned.\n * Used in order to implement ldbLogStackValue().\n *\n * The element is not automatically removed from the stack, nor it is\n * converted to a different type. */\n#define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)\nsds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {\n    int t = lua_type(lua,idx);\n\n    if (level++ == LDB_MAX_VALUES_DEPTH)\n        return sdscat(s,\"<max recursion level reached! Nested table?>\");\n\n    switch(t) {\n    case LUA_TSTRING:\n        {\n        size_t strl;\n        char *strp = (char*)lua_tolstring(lua,idx,&strl);\n        s = sdscatrepr(s,strp,strl);\n        }\n        break;\n    case LUA_TBOOLEAN:\n        s = sdscat(s,lua_toboolean(lua,idx) ? \"true\" : \"false\");\n        break;\n    case LUA_TNUMBER:\n        s = sdscatprintf(s,\"%g\",(double)lua_tonumber(lua,idx));\n        break;\n    case LUA_TNIL:\n        s = sdscatlen(s,\"nil\",3);\n        break;\n    case LUA_TTABLE:\n        {\n        int expected_index = 1; /* First index we expect in an array. */\n        int is_array = 1; /* Will be set to null if check fails. */\n        /* Note: we create two representations at the same time, one\n         * assuming the table is an array, one assuming it is not. At the\n         * end we know what is true and select the right one. */\n        sds repr1 = sdsempty();\n        sds repr2 = sdsempty();\n        lua_pushnil(lua); /* The first key to start the iteration is nil. */\n        while (lua_next(lua,idx-1)) {\n            /* Test if so far the table looks like an array. */\n            if (is_array &&\n                (lua_type(lua,-2) != LUA_TNUMBER ||\n                 lua_tonumber(lua,-2) != expected_index)) is_array = 0;\n            /* Stack now: table, key, value */\n            /* Array repr. */\n            repr1 = ldbCatStackValueRec(repr1,lua,-1,level);\n            repr1 = sdscatlen(repr1,\"; \",2);\n            /* Full repr. */\n            repr2 = sdscatlen(repr2,\"[\",1);\n            repr2 = ldbCatStackValueRec(repr2,lua,-2,level);\n            repr2 = sdscatlen(repr2,\"]=\",2);\n            repr2 = ldbCatStackValueRec(repr2,lua,-1,level);\n            repr2 = sdscatlen(repr2,\"; \",2);\n            lua_pop(lua,1); /* Stack: table, key. Ready for next iteration. */\n            expected_index++;\n        }\n        /* Strip the last \" ;\" from both the representations. */\n        if (sdslen(repr1)) sdsrange(repr1,0,-3);\n        if (sdslen(repr2)) sdsrange(repr2,0,-3);\n        /* Select the right one and discard the other. */\n        s = sdscatlen(s,\"{\",1);\n        s = sdscatsds(s,is_array ? repr1 : repr2);\n        s = sdscatlen(s,\"}\",1);\n        sdsfree(repr1);\n        sdsfree(repr2);\n        }\n        break;\n    case LUA_TFUNCTION:\n    case LUA_TUSERDATA:\n    case LUA_TTHREAD:\n    case LUA_TLIGHTUSERDATA:\n        {\n        const void *p = lua_topointer(lua,idx);\n        char *typename = \"unknown\";\n        if (t == LUA_TFUNCTION) typename = \"function\";\n        else if (t == LUA_TUSERDATA) typename = \"userdata\";\n        else if (t == LUA_TTHREAD) typename = \"thread\";\n        else if (t == LUA_TLIGHTUSERDATA) typename = \"light-userdata\";\n        s = sdscatprintf(s,\"\\\"%s@%p\\\"\",typename,p);\n        }\n        break;\n    default:\n        s = sdscat(s,\"\\\"<unknown-lua-type>\\\"\");\n        break;\n    }\n    return s;\n}\n\n/* Higher level wrapper for ldbCatStackValueRec() that just uses an initial\n * recursion level of '0'. */\nsds ldbCatStackValue(sds s, lua_State *lua, int idx) {\n    return ldbCatStackValueRec(s,lua,idx,0);\n}\n\n/* Produce a debugger log entry representing the value of the Lua object\n * currently on the top of the stack. The element is ot popped nor modified.\n * Check ldbCatStackValue() for the actual implementation. */\nvoid ldbLogStackValue(lua_State *lua, char *prefix) {\n    sds s = sdsnew(prefix);\n    s = ldbCatStackValue(s,lua,-1);\n    ldbLogWithMaxLen(s);\n}\n\nchar *ldbRedisProtocolToHuman_Int(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Status(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Set(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Map(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Null(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Bool(sds *o, char *reply);\nchar *ldbRedisProtocolToHuman_Double(sds *o, char *reply);\n\n/* Get Redis protocol from 'reply' and appends it in human readable form to\n * the passed SDS string 'o'.\n *\n * Note that the SDS string is passed by reference (pointer of pointer to\n * char*) so that we can return a modified pointer, as for SDS semantics. */\nchar *ldbRedisProtocolToHuman(sds *o, char *reply) {\n    char *p = reply;\n    switch(*p) {\n    case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;\n    case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;\n    case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;\n    case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;\n    case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;\n    case '~': p = ldbRedisProtocolToHuman_Set(o,reply); break;\n    case '%': p = ldbRedisProtocolToHuman_Map(o,reply); break;\n    case '_': p = ldbRedisProtocolToHuman_Null(o,reply); break;\n    case '#': p = ldbRedisProtocolToHuman_Bool(o,reply); break;\n    case ',': p = ldbRedisProtocolToHuman_Double(o,reply); break;\n    }\n    return p;\n}\n\n/* The following functions are helpers for ldbRedisProtocolToHuman(), each\n * take care of a given Redis return type. */\n\nchar *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    *o = sdscatlen(*o,reply+1,p-reply-1);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long bulklen;\n\n    string2ll(reply+1,p-reply-1,&bulklen);\n    if (bulklen == -1) {\n        *o = sdscatlen(*o,\"NULL\",4);\n        return p+2;\n    } else {\n        *o = sdscatrepr(*o,p+2,bulklen);\n        return p+2+bulklen+2;\n    }\n}\n\nchar *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n\n    *o = sdscatrepr(*o,reply,p-reply);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    p += 2;\n    if (mbulklen == -1) {\n        *o = sdscatlen(*o,\"NULL\",4);\n        return p;\n    }\n    *o = sdscatlen(*o,\"[\",1);\n    for (j = 0; j < mbulklen; j++) {\n        p = ldbRedisProtocolToHuman(o,p);\n        if (j != mbulklen-1) *o = sdscatlen(*o,\",\",1);\n    }\n    *o = sdscatlen(*o,\"]\",1);\n    return p;\n}\n\nchar *ldbRedisProtocolToHuman_Set(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    p += 2;\n    *o = sdscatlen(*o,\"~(\",2);\n    for (j = 0; j < mbulklen; j++) {\n        p = ldbRedisProtocolToHuman(o,p);\n        if (j != mbulklen-1) *o = sdscatlen(*o,\",\",1);\n    }\n    *o = sdscatlen(*o,\")\",1);\n    return p;\n}\n\nchar *ldbRedisProtocolToHuman_Map(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    p += 2;\n    *o = sdscatlen(*o,\"{\",1);\n    for (j = 0; j < mbulklen; j++) {\n        p = ldbRedisProtocolToHuman(o,p);\n        *o = sdscatlen(*o,\" => \",4);\n        p = ldbRedisProtocolToHuman(o,p);\n        if (j != mbulklen-1) *o = sdscatlen(*o,\",\",1);\n    }\n    *o = sdscatlen(*o,\"}\",1);\n    return p;\n}\n\nchar *ldbRedisProtocolToHuman_Null(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    *o = sdscatlen(*o,\"(null)\",6);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_Bool(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    if (reply[1] == 't')\n        *o = sdscatlen(*o,\"#true\",5);\n    else\n        *o = sdscatlen(*o,\"#false\",6);\n    return p+2;\n}\n\nchar *ldbRedisProtocolToHuman_Double(sds *o, char *reply) {\n    char *p = strchr(reply+1,'\\r');\n    *o = sdscatlen(*o,\"(double) \",9);\n    *o = sdscatlen(*o,reply+1,p-reply-1);\n    return p+2;\n}\n\n/* Log a Redis reply as debugger output, in a human readable format.\n * If the resulting string is longer than 'len' plus a few more chars\n * used as prefix, it gets truncated. */\nvoid ldbLogRedisReply(char *reply) {\n    sds log = sdsnew(\"<reply> \");\n    ldbRedisProtocolToHuman(&log,reply);\n    ldbLogWithMaxLen(log);\n}\n\n/* Implements the \"print <var>\" command of the Lua debugger. It scans for Lua\n * var \"varname\" starting from the current stack frame up to the top stack\n * frame. The first matching variable is printed. */\nvoid ldbPrint(lua_State *lua, char *varname) {\n    lua_Debug ar;\n\n    int l = 0; /* Stack level. */\n    while (lua_getstack(lua,l,&ar) != 0) {\n        l++;\n        const char *name;\n        int i = 1; /* Variable index. */\n        while((name = lua_getlocal(lua,&ar,i)) != NULL) {\n            i++;\n            if (strcmp(varname,name) == 0) {\n                ldbLogStackValue(lua,\"<value> \");\n                lua_pop(lua,1);\n                return;\n            } else {\n                lua_pop(lua,1); /* Discard the var name on the stack. */\n            }\n        }\n    }\n\n    /* Let's try with global vars in two selected cases */\n    if (!strcmp(varname,\"ARGV\") || !strcmp(varname,\"KEYS\")) {\n        lua_getglobal(lua, varname);\n        ldbLogStackValue(lua,\"<value> \");\n        lua_pop(lua,1);\n    } else {\n        ldbLog(sdsnew(\"No such variable.\"));\n    }\n}\n\n/* Implements the \"print\" command (without arguments) of the Lua debugger.\n * Prints all the variables in the current stack frame. */\nvoid ldbPrintAll(lua_State *lua) {\n    lua_Debug ar;\n    int vars = 0;\n\n    if (lua_getstack(lua,0,&ar) != 0) {\n        const char *name;\n        int i = 1; /* Variable index. */\n        while((name = lua_getlocal(lua,&ar,i)) != NULL) {\n            i++;\n            if (!strstr(name,\"(*temporary)\")) {\n                sds prefix = sdscatprintf(sdsempty(),\"<value> %s = \",name);\n                ldbLogStackValue(lua,prefix);\n                sdsfree(prefix);\n                vars++;\n            }\n            lua_pop(lua,1);\n        }\n    }\n\n    if (vars == 0) {\n        ldbLog(sdsnew(\"No local variables in the current context.\"));\n    }\n}\n\n/* Implements the break command to list, add and remove breakpoints. */\nvoid ldbBreak(sds *argv, int argc) {\n    if (argc == 1) {\n        if (ldb.bpcount == 0) {\n            ldbLog(sdsnew(\"No breakpoints set. Use 'b <line>' to add one.\"));\n            return;\n        } else {\n            ldbLog(sdscatfmt(sdsempty(),\"%i breakpoints set:\",ldb.bpcount));\n            int j;\n            for (j = 0; j < ldb.bpcount; j++)\n                ldbLogSourceLine(ldb.bp[j]);\n        }\n    } else {\n        int j;\n        for (j = 1; j < argc; j++) {\n            char *arg = argv[j];\n            long line;\n            if (!string2l(arg,sdslen(arg),&line)) {\n                ldbLog(sdscatfmt(sdsempty(),\"Invalid argument:'%s'\",arg));\n            } else {\n                if (line == 0) {\n                    ldb.bpcount = 0;\n                    ldbLog(sdsnew(\"All breakpoints removed.\"));\n                } else if (line > 0) {\n                    if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {\n                        ldbLog(sdsnew(\"Too many breakpoints set.\"));\n                    } else if (ldbAddBreakpoint(line)) {\n                        ldbList(line,1);\n                    } else {\n                        ldbLog(sdsnew(\"Wrong line number.\"));\n                    }\n                } else if (line < 0) {\n                    if (ldbDelBreakpoint(-line))\n                        ldbLog(sdsnew(\"Breakpoint removed.\"));\n                    else\n                        ldbLog(sdsnew(\"No breakpoint in the specified line.\"));\n                }\n            }\n        }\n    }\n}\n\n/* Implements the Lua debugger \"eval\" command. It just compiles the user\n * passed fragment of code and executes it, showing the result left on\n * the stack. */\nvoid ldbEval(lua_State *lua, sds *argv, int argc) {\n    /* Glue the script together if it is composed of multiple arguments. */\n    sds code = sdsjoinsds(argv+1,argc-1,\" \",1);\n    sds expr = sdscatsds(sdsnew(\"return \"),code);\n\n    /* Try to compile it as an expression, prepending \"return \". */\n    if (luaL_loadbuffer(lua,expr,sdslen(expr),\"@ldb_eval\")) {\n        lua_pop(lua,1);\n        /* Failed? Try as a statement. */\n        if (luaL_loadbuffer(lua,code,sdslen(code),\"@ldb_eval\")) {\n            ldbLog(sdscatfmt(sdsempty(),\"<error> %s\",lua_tostring(lua,-1)));\n            lua_pop(lua,1);\n            sdsfree(code);\n            sdsfree(expr);\n            return;\n        }\n    }\n\n    /* Call it. */\n    sdsfree(code);\n    sdsfree(expr);\n    if (lua_pcall(lua,0,1,0)) {\n        ldbLog(sdscatfmt(sdsempty(),\"<error> %s\",lua_tostring(lua,-1)));\n        lua_pop(lua,1);\n        return;\n    }\n    ldbLogStackValue(lua,\"<retval> \");\n    lua_pop(lua,1);\n}\n\n/* Implement the debugger \"redis\" command. We use a trick in order to make\n * the implementation very simple: we just call the Lua redis.call() command\n * implementation, with ldb.step enabled, so as a side effect the Redis command\n * and its reply are logged. */\nvoid ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       /* Stack: redis, redis.call */\n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               /* Force redis.call() to log. */\n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */\n    ldb.step = 0;               /* Disable logging. */\n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             /* Discard the result and clean the stack. */\n}\n\n/* Implements \"trace\" command of the Lua debugger. It just prints a backtrace\n * querying Lua starting from the current callframe back to the outer one. */\nvoid ldbTrace(lua_State *lua) {\n    lua_Debug ar;\n    int level = 0;\n\n    while(lua_getstack(lua,level,&ar)) {\n        lua_getinfo(lua,\"Snl\",&ar);\n        if(strstr(ar.short_src,\"user_script\") != NULL) {\n            ldbLog(sdscatprintf(sdsempty(),\"%s %s:\",\n                (level == 0) ? \"In\" : \"From\",\n                ar.name ? ar.name : \"top level\"));\n            ldbLogSourceLine(ar.currentline);\n        }\n        level++;\n    }\n    if (level == 0) {\n        ldbLog(sdsnew(\"<error> Can't retrieve Lua stack.\"));\n    }\n}\n\n/* Implements the debugger \"maxlen\" command. It just queries or sets the\n * ldb.maxlen variable. */\nvoid ldbMaxlen(sds *argv, int argc) {\n    if (argc == 2) {\n        int newval = atoi(argv[1]);\n        ldb.maxlen_hint_sent = 1; /* User knows about this command. */\n        if (newval != 0 && newval <= 60) newval = 60;\n        ldb.maxlen = newval;\n    }\n    if (ldb.maxlen) {\n        ldbLog(sdscatprintf(sdsempty(),\"<value> replies are truncated at %d bytes.\",(int)ldb.maxlen));\n    } else {\n        ldbLog(sdscatprintf(sdsempty(),\"<value> replies are unlimited.\"));\n    }\n}\n\n/* Read debugging commands from client.\n * Return C_OK if the debugging session is continuing, otherwise\n * C_ERR if the client closed the connection or is timing out. */\nint ldbRepl(lua_State *lua) {\n    sds *argv;\n    int argc;\n    char* err = NULL;\n\n    /* We continue processing commands until a command that should return\n     * to the Lua interpreter is found. */\n    while(1) {\n        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {\n            char buf[1024];\n            if (err) {\n                lua_pushstring(lua, err);\n                lua_error(lua);\n            }\n            int nread = connRead(ldb.conn,buf,sizeof(buf));\n            if (nread <= 0) {\n                /* Make sure the script runs without user input since the\n                 * client is no longer connected. */\n                ldb.step = 0;\n                ldb.bpcount = 0;\n                return C_ERR;\n            }\n            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);\n            /* after 1M we will exit with an error\n             * so that the client will not blow the memory\n             */\n            if (sdslen(ldb.cbuf) > 1<<20) {\n                sdsfree(ldb.cbuf);\n                ldb.cbuf = sdsempty();\n                lua_pushstring(lua, \"max client buffer reached\");\n                lua_error(lua);\n            }\n        }\n\n        /* Flush the old buffer. */\n        sdsfree(ldb.cbuf);\n        ldb.cbuf = sdsempty();\n\n        /* Execute the command. */\n        if (!strcasecmp(argv[0],\"h\") || !strcasecmp(argv[0],\"help\")) {\nldbLog(sdsnew(\"Redis Lua debugger help:\"));\nldbLog(sdsnew(\"[h]elp               Show this help.\"));\nldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));\nldbLog(sdsnew(\"[n]ext               Alias for step.\"));\nldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));\nldbLog(sdsnew(\"[l]list              List source code around current line.\"));\nldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));\nldbLog(sdsnew(\"                     line = 0 means: current position.\"));\nldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));\nldbLog(sdsnew(\"                     to show before/after [line].\"));\nldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));\nldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));\nldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));\nldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));\nldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));\nldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));\nldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));\nldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));\nldbLog(sdsnew(\"[t]race              Show a backtrace.\"));\nldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));\nldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));\nldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));\nldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));\nldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));\nldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));\nldbLog(sdsnew(\"\"));\nldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));\nldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));\nldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));\nldbLog(sdsnew(\"                     next line of code.\"));\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"s\") || !strcasecmp(argv[0],\"step\") ||\n                   !strcasecmp(argv[0],\"n\") || !strcasecmp(argv[0],\"next\")) {\n            ldb.step = 1;\n            break;\n        } else if (!strcasecmp(argv[0],\"c\") || !strcasecmp(argv[0],\"continue\")){\n            break;\n        } else if (!strcasecmp(argv[0],\"t\") || !strcasecmp(argv[0],\"trace\")) {\n            ldbTrace(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"m\") || !strcasecmp(argv[0],\"maxlen\")) {\n            ldbMaxlen(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"b\") || !strcasecmp(argv[0],\"break\")) {\n            ldbBreak(argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"e\") || !strcasecmp(argv[0],\"eval\")) {\n            ldbEval(lua,argv,argc);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"a\") || !strcasecmp(argv[0],\"abort\")) {\n            lua_pushstring(lua, \"script aborted for user request\");\n            lua_error(lua);\n        } else if (argc > 1 &&\n                   (!strcasecmp(argv[0],\"r\") || !strcasecmp(argv[0],\"redis\"))) {\n            ldbRedis(lua,argv,argc);\n            ldbSendLogs();\n        } else if ((!strcasecmp(argv[0],\"p\") || !strcasecmp(argv[0],\"print\"))) {\n            if (argc == 2)\n                ldbPrint(lua,argv[1]);\n            else\n                ldbPrintAll(lua);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"l\") || !strcasecmp(argv[0],\"list\")){\n            int around = ldb.currentline, ctx = 5;\n            if (argc > 1) {\n                int num = atoi(argv[1]);\n                if (num > 0) around = num;\n            }\n            if (argc > 2) ctx = atoi(argv[2]);\n            ldbList(around,ctx);\n            ldbSendLogs();\n        } else if (!strcasecmp(argv[0],\"w\") || !strcasecmp(argv[0],\"whole\")){\n            ldbList(1,1000000);\n            ldbSendLogs();\n        } else {\n            ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"\n                          \"wrong number of arguments.\"));\n            ldbSendLogs();\n        }\n\n        /* Free the command vector. */\n        sdsfreesplitres(argv,argc);\n    }\n\n    /* Free the current command argv if we break inside the while loop. */\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}\n\n/* This is the core of our Lua debugger, called each time Lua is about\n * to start executing a new line. */\nvoid luaLdbLineHook(lua_State *lua, lua_Debug *ar) {\n    lua_getstack(lua,0,ar);\n    lua_getinfo(lua,\"Sl\",ar);\n    ldb.currentline = ar->currentline;\n\n    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;\n    int timeout = 0;\n\n    /* Events outside our script are not interesting. */\n    if(strstr(ar->short_src,\"user_script\") == NULL) return;\n\n    /* Check if a timeout occurred. */\n    if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {\n        mstime_t elapsed = mstime() - server.lua_time_start;\n        mstime_t timelimit = server.lua_time_limit ?\n                             server.lua_time_limit : 5000;\n        if (elapsed >= timelimit) {\n            timeout = 1;\n            ldb.step = 1;\n        } else {\n            return; /* No timeout, ignore the COUNT event. */\n        }\n    }\n\n    if (ldb.step || bp) {\n        char *reason = \"step over\";\n        if (bp) reason = ldb.luabp ? \"redis.breakpoint() called\" :\n                                     \"break point\";\n        else if (timeout) reason = \"timeout reached, infinite loop?\";\n        ldb.step = 0;\n        ldb.luabp = 0;\n        ldbLog(sdscatprintf(sdsempty(),\n            \"* Stopped at %d, stop reason = %s\",\n            ldb.currentline, reason));\n        ldbLogSourceLine(ldb.currentline);\n        ldbSendLogs();\n        if (ldbRepl(lua) == C_ERR && timeout) {\n            /* If the client closed the connection and we have a timeout\n             * connection, let's kill the script otherwise the process\n             * will remain blocked indefinitely. */\n            lua_pushstring(lua, \"timeout during Lua debugging with client closing connection\");\n            lua_error(lua);\n        }\n        server.lua_time_start = mstime();\n    }\n}\n\n", "start_server {tags {\"scripting\"}} {\n    test {EVAL - Does Lua interpreter replies to our requests?} {\n        r eval {return 'hello'} 0\n    } {hello}\n\n    test {EVAL - Lua integer -> Redis protocol type conversion} {\n        r eval {return 100.5} 0\n    } {100}\n\n    test {EVAL - Lua string -> Redis protocol type conversion} {\n        r eval {return 'hello world'} 0\n    } {hello world}\n\n    test {EVAL - Lua true boolean -> Redis protocol type conversion} {\n        r eval {return true} 0\n    } {1}\n\n    test {EVAL - Lua false boolean -> Redis protocol type conversion} {\n        r eval {return false} 0\n    } {}\n\n    test {EVAL - Lua status code reply -> Redis protocol type conversion} {\n        r eval {return {ok='fine'}} 0\n    } {fine}\n\n    test {EVAL - Lua error reply -> Redis protocol type conversion} {\n        catch {\n            r eval {return {err='this is an error'}} 0\n        } e\n        set _ $e\n    } {this is an error}\n\n    test {EVAL - Lua table -> Redis protocol type conversion} {\n        r eval {return {1,2,3,'ciao',{1,2}}} 0\n    } {1 2 3 ciao {1 2}}\n\n    test {EVAL - Are the KEYS and ARGV arrays populated correctly?} {\n        r eval {return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}} 2 a b c d\n    } {a b c d}\n\n    test {EVAL - is Lua able to call Redis API?} {\n        r set mykey myval\n        r eval {return redis.call('get',KEYS[1])} 1 mykey\n    } {myval}\n\n    test {EVALSHA - Can we call a SHA1 if already defined?} {\n        r evalsha fd758d1589d044dd850a6f05d52f2eefd27f033f 1 mykey\n    } {myval}\n\n    test {EVALSHA - Can we call a SHA1 in uppercase?} {\n        r evalsha FD758D1589D044DD850A6F05D52F2EEFD27F033F 1 mykey\n    } {myval}\n\n    test {EVALSHA - Do we get an error on invalid SHA1?} {\n        catch {r evalsha NotValidShaSUM 0} e\n        set _ $e\n    } {NOSCRIPT*}\n\n    test {EVALSHA - Do we get an error on non defined SHA1?} {\n        catch {r evalsha ffd632c7d33e571e9f24556ebed26c3479a87130 0} e\n        set _ $e\n    } {NOSCRIPT*}\n\n    test {EVAL - Redis integer -> Lua type conversion} {\n        r set x 0\n        r eval {\n            local foo = redis.pcall('incr',KEYS[1])\n            return {type(foo),foo}\n        } 1 x\n    } {number 1}\n\n    test {EVAL - Redis bulk -> Lua type conversion} {\n        r set mykey myval\n        r eval {\n            local foo = redis.pcall('get',KEYS[1])\n            return {type(foo),foo}\n        } 1 mykey\n    } {string myval}\n\n    test {EVAL - Redis multi bulk -> Lua type conversion} {\n        r del mylist\n        r rpush mylist a\n        r rpush mylist b\n        r rpush mylist c\n        r eval {\n            local foo = redis.pcall('lrange',KEYS[1],0,-1)\n            return {type(foo),foo[1],foo[2],foo[3],# foo}\n        } 1 mylist\n    } {table a b c 3}\n\n    test {EVAL - Redis status reply -> Lua type conversion} {\n        r eval {\n            local foo = redis.pcall('set',KEYS[1],'myval')\n            return {type(foo),foo['ok']}\n        } 1 mykey\n    } {table OK}\n\n    test {EVAL - Redis error reply -> Lua type conversion} {\n        r set mykey myval\n        r eval {\n            local foo = redis.pcall('incr',KEYS[1])\n            return {type(foo),foo['err']}\n        } 1 mykey\n    } {table {ERR value is not an integer or out of range}}\n\n    test {EVAL - Redis nil bulk reply -> Lua type conversion} {\n        r del mykey\n        r eval {\n            local foo = redis.pcall('get',KEYS[1])\n            return {type(foo),foo == false}\n        } 1 mykey\n    } {boolean 1}\n\n    test {EVAL - Is the Lua client using the currently selected DB?} {\n        r set mykey \"this is DB 9\"\n        r select 10\n        r set mykey \"this is DB 10\"\n        r eval {return redis.pcall('get',KEYS[1])} 1 mykey\n    } {this is DB 10}\n\n    test {EVAL - SELECT inside Lua should not affect the caller} {\n        # here we DB 10 is selected\n        r set mykey \"original value\"\n        r eval {return redis.pcall('select','9')} 0\n        set res [r get mykey]\n        r select 9\n        set res\n    } {original value}\n\n    if 0 {\n        test {EVAL - Script can't run more than configured time limit} {\n            r config set lua-time-limit 1\n            catch {\n                r eval {\n                    local i = 0\n                    while true do i=i+1 end\n                } 0\n            } e\n            set _ $e\n        } {*execution time*}\n    }\n\n    test {EVAL - Scripts can't run certain commands} {\n        set e {}\n        catch {r eval {return redis.pcall('blpop','x',0)} 0} e\n        set e\n    } {*not allowed*}\n\n    test {EVAL - Scripts can't run XREAD and XREADGROUP with BLOCK option} {\n        r del s\n        r xgroup create s g $ MKSTREAM\n        set res [r eval {return redis.pcall('xread','STREAMS','s','$')} 1 s]\n        assert {$res eq {}}\n        assert_error \"*xread command is not allowed with BLOCK option from scripts\" {r eval {return redis.pcall('xread','BLOCK',0,'STREAMS','s','$')} 1 s}\n        set res [r eval {return redis.pcall('xreadgroup','group','g','c','STREAMS','s','>')} 1 s]\n        assert {$res eq {}}\n        assert_error \"*xreadgroup command is not allowed with BLOCK option from scripts\" {r eval {return redis.pcall('xreadgroup','group','g','c','BLOCK',0,'STREAMS','s','>')} 1 s}\n    }\n\n    test {EVAL - Scripts can't run certain commands} {\n        set e {}\n        r debug lua-always-replicate-commands 0\n        catch {\n            r eval \"redis.pcall('randomkey'); return redis.pcall('set','x','ciao')\" 0\n        } e\n        r debug lua-always-replicate-commands 1\n        set e\n    } {*not allowed after*}\n\n    test {EVAL - No arguments to redis.call/pcall is considered an error} {\n        set e {}\n        catch {r eval {return redis.call()} 0} e\n        set e\n    } {*one argument*}\n\n    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {\n        set e {}\n        catch {\n            r eval \"redis.call('nosuchcommand')\" 0\n        } e\n        set e\n    } {*Unknown Redis*}\n\n    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {\n        set e {}\n        catch {\n            r eval \"redis.call('get','a','b','c')\" 0\n        } e\n        set e\n    } {*number of args*}\n\n    test {EVAL - redis.call variant raises a Lua error on Redis cmd error (1)} {\n        set e {}\n        r set foo bar\n        catch {\n            r eval {redis.call('lpush',KEYS[1],'val')} 1 foo\n        } e\n        set e\n    } {*against a key*}\n\n    test {EVAL - JSON numeric decoding} {\n        # We must return the table as a string because otherwise\n        # Redis converts floats to ints and we get 0 and 1023 instead\n        # of 0.0003 and 1023.2 as the parsed output.\n        r eval {return\n                 table.concat(\n                   cjson.decode(\n                    \"[0.0, -5e3, -1, 0.3e-3, 1023.2, 0e10]\"), \" \")\n        } 0\n    } {0 -5000 -1 0.0003 1023.2 0}\n\n    test {EVAL - JSON string decoding} {\n        r eval {local decoded = cjson.decode('{\"keya\": \"a\", \"keyb\": \"b\"}')\n                return {decoded.keya, decoded.keyb}\n        } 0\n    } {a b}\n\n    test {EVAL - cmsgpack can pack double?} {\n        r eval {local encoded = cmsgpack.pack(0.1)\n                local h = \"\"\n                for i = 1, #encoded do\n                    h = h .. string.format(\"%02x\",string.byte(encoded,i))\n                end\n                return h\n        } 0\n    } {cb3fb999999999999a}\n\n    test {EVAL - cmsgpack can pack negative int64?} {\n        r eval {local encoded = cmsgpack.pack(-1099511627776)\n                local h = \"\"\n                for i = 1, #encoded do\n                    h = h .. string.format(\"%02x\",string.byte(encoded,i))\n                end\n                return h\n        } 0\n    } {d3ffffff0000000000}\n\n    test {EVAL - cmsgpack can pack and unpack circular references?} {\n        r eval {local a = {x=nil,y=5}\n                local b = {x=a}\n                a['x'] = b\n                local encoded = cmsgpack.pack(a)\n                local h = \"\"\n                -- cmsgpack encodes to a depth of 16, but can't encode\n                -- references, so the encoded object has a deep copy recusive\n                -- depth of 16.\n                for i = 1, #encoded do\n                    h = h .. string.format(\"%02x\",string.byte(encoded,i))\n                end\n                -- when unpacked, re.x.x != re because the unpack creates\n                -- individual tables down to a depth of 16.\n                -- (that's why the encoded output is so large)\n                local re = cmsgpack.unpack(encoded)\n                assert(re)\n                assert(re.x)\n                assert(re.x.x.y == re.y)\n                assert(re.x.x.x.x.y == re.y)\n                assert(re.x.x.x.x.x.x.y == re.y)\n                assert(re.x.x.x.x.x.x.x.x.x.x.y == re.y)\n                -- maximum working depth:\n                assert(re.x.x.x.x.x.x.x.x.x.x.x.x.x.x.y == re.y)\n                -- now the last x would be b above and has no y\n                assert(re.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x)\n                -- so, the final x.x is at the depth limit and was assigned nil\n                assert(re.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x == nil)\n                return {h, re.x.x.x.x.x.x.x.x.y == re.y, re.y == 5}\n        } 0\n    } {82a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a17882a17905a17881a178c0 1 1}\n\n    test {EVAL - Numerical sanity check from bitop} {\n        r eval {assert(0x7fffffff == 2147483647, \"broken hex literals\");\n                assert(0xffffffff == -1 or 0xffffffff == 2^32-1,\n                    \"broken hex literals\");\n                assert(tostring(-1) == \"-1\", \"broken tostring()\");\n                assert(tostring(0xffffffff) == \"-1\" or\n                    tostring(0xffffffff) == \"4294967295\",\n                    \"broken tostring()\")\n        } 0\n    } {}\n\n    test {EVAL - Verify minimal bitop functionality} {\n        r eval {assert(bit.tobit(1) == 1);\n                assert(bit.band(1) == 1);\n                assert(bit.bxor(1,2) == 3);\n                assert(bit.bor(1,2,4,8,16,32,64,128) == 255)\n        } 0\n    } {}\n\n    test {EVAL - Able to parse trailing comments} {\n        r eval {return 'hello' --trailing comment} 0\n    } {hello}\n\n    test {SCRIPTING FLUSH - is able to clear the scripts cache?} {\n        r set mykey myval\n        set v [r evalsha fd758d1589d044dd850a6f05d52f2eefd27f033f 1 mykey]\n        assert_equal $v myval\n        set e \"\"\n        r script flush\n        catch {r evalsha fd758d1589d044dd850a6f05d52f2eefd27f033f 1 mykey} e\n        set e\n    } {NOSCRIPT*}\n\n    test {SCRIPT EXISTS - can detect already defined scripts?} {\n        r eval \"return 1+1\" 0\n        r script exists a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9 a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bda\n    } {1 0}\n\n    test {SCRIPT LOAD - is able to register scripts in the scripting cache} {\n        list \\\n            [r script load \"return 'loaded'\"] \\\n            [r evalsha b534286061d4b9e4026607613b95c06c06015ae8 0]\n    } {b534286061d4b9e4026607613b95c06c06015ae8 loaded}\n\n    test \"In the context of Lua the output of random commands gets ordered\" {\n        r debug lua-always-replicate-commands 0\n        r del myset\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        set res [r eval {return redis.call('smembers',KEYS[1])} 1 myset]\n        r debug lua-always-replicate-commands 1\n        set res\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z}\n\n    test \"SORT is normally not alpha re-ordered for the scripting engine\" {\n        r del myset\n        r sadd myset 1 2 3 4 10\n        r eval {return redis.call('sort',KEYS[1],'desc')} 1 myset\n    } {10 4 3 2 1}\n\n    test \"SORT BY <constant> output gets ordered for scripting\" {\n        r del myset\n        r sadd myset a b c d e f g h i l m n o p q r s t u v z aa aaa azz\n        r eval {return redis.call('sort',KEYS[1],'by','_')} 1 myset\n    } {a aa aaa azz b c d e f g h i l m n o p q r s t u v z}\n\n    test \"SORT BY <constant> with GET gets ordered for scripting\" {\n        r del myset\n        r sadd myset a b c\n        r eval {return redis.call('sort',KEYS[1],'by','_','get','#','get','_:*')} 1 myset\n    } {a {} b {} c {}}\n\n    test \"redis.sha1hex() implementation\" {\n        list [r eval {return redis.sha1hex('')} 0] \\\n             [r eval {return redis.sha1hex('Pizza & Mandolino')} 0]\n    } {da39a3ee5e6b4b0d3255bfef95601890afd80709 74822d82031af7493c20eefa13bd07ec4fada82f}\n\n    test {Globals protection reading an undeclared global variable} {\n        catch {r eval {return a} 0} e\n        set e\n    } {*ERR*attempted to access * global*}\n\n    test {Globals protection setting an undeclared global*} {\n        catch {r eval {a=10} 0} e\n        set e\n    } {*ERR*attempted to create global*}\n\n    test {Test an example script DECR_IF_GT} {\n        set decr_if_gt {\n            local current\n\n            current = redis.call('get',KEYS[1])\n            if not current then return nil end\n            if current > ARGV[1] then\n                return redis.call('decr',KEYS[1])\n            else\n                return redis.call('get',KEYS[1])\n            end\n        }\n        r set foo 5\n        set res {}\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        lappend res [r eval $decr_if_gt 1 foo 2]\n        set res\n    } {4 3 2 2 2}\n\n    test {Scripting engine resets PRNG at every script execution} {\n        set rand1 [r eval {return tostring(math.random())} 0]\n        set rand2 [r eval {return tostring(math.random())} 0]\n        assert_equal $rand1 $rand2\n    }\n\n    test {Scripting engine PRNG can be seeded correctly} {\n        set rand1 [r eval {\n            math.randomseed(ARGV[1]); return tostring(math.random())\n        } 0 10]\n        set rand2 [r eval {\n            math.randomseed(ARGV[1]); return tostring(math.random())\n        } 0 10]\n        set rand3 [r eval {\n            math.randomseed(ARGV[1]); return tostring(math.random())\n        } 0 20]\n        assert_equal $rand1 $rand2\n        assert {$rand2 ne $rand3}\n    }\n\n    test {EVAL does not leak in the Lua stack} {\n        r set x 0\n        # Use a non blocking client to speedup the loop.\n        set rd [redis_deferring_client]\n        for {set j 0} {$j < 10000} {incr j} {\n            $rd eval {return redis.call(\"incr\",KEYS[1])} 1 x\n        }\n        for {set j 0} {$j < 10000} {incr j} {\n            $rd read\n        }\n        assert {[s used_memory_lua] < 1024*100}\n        $rd close\n        r get x\n    } {10000}\n\n    test {EVAL processes writes from AOF in read-only slaves} {\n        r flushall\n        r config set appendonly yes\n        r config set aof-use-rdb-preamble no\n        r eval {redis.call(\"set\",KEYS[1],\"100\")} 1 foo\n        r eval {redis.call(\"incr\",KEYS[1])} 1 foo\n        r eval {redis.call(\"incr\",KEYS[1])} 1 foo\n        wait_for_condition 50 100 {\n            [s aof_rewrite_in_progress] == 0\n        } else {\n            fail \"AOF rewrite can't complete after CONFIG SET appendonly yes.\"\n        }\n        r config set slave-read-only yes\n        r slaveof 127.0.0.1 0\n        r debug loadaof\n        set res [r get foo]\n        r slaveof no one\n        set res\n    } {102}\n\n    test {EVAL timeout from AOF} {\n        # generate a long running script that is propagated to the AOF as script\n        # make sure that the script times out during loading\n        r config set appendonly no\n        r config set aof-use-rdb-preamble no\n        r config set lua-replicate-commands no\n        r flushall\n        r config set appendonly yes\n        wait_for_condition 50 100 {\n            [s aof_rewrite_in_progress] == 0\n        } else {\n            fail \"AOF rewrite can't complete after CONFIG SET appendonly yes.\"\n        }\n        r config set lua-time-limit 1\n        set rd [redis_deferring_client]\n        set start [clock clicks -milliseconds]\n        $rd eval {redis.call('set',KEYS[1],'y'); for i=1,1500000 do redis.call('ping') end return 'ok'} 1 x\n        $rd flush\n        after 100\n        catch {r ping} err\n        assert_match {BUSY*} $err\n        $rd read\n        set elapsed [expr [clock clicks -milliseconds]-$start]\n        if {$::verbose} { puts \"script took $elapsed milliseconds\" }\n        set start [clock clicks -milliseconds]\n        $rd debug loadaof\n        $rd flush\n        after 100\n        catch {r ping} err\n        assert_match {LOADING*} $err\n        $rd read\n        set elapsed [expr [clock clicks -milliseconds]-$start]\n        if {$::verbose} { puts \"loading took $elapsed milliseconds\" }\n        $rd close\n        r get x\n    } {y}\n    r config set aof-use-rdb-preamble yes\n    r config set lua-replicate-commands yes\n\n    test {We can call scripts rewriting client->argv from Lua} {\n        r del myset\n        r sadd myset a b c\n        r mset a 1 b 2 c 3 d 4\n        assert {[r spop myset] ne {}}\n        assert {[r spop myset 1] ne {}}\n        assert {[r spop myset] ne {}}\n        assert {[r mget a b c d] eq {1 2 3 4}}\n        assert {[r spop myset] eq {}}\n    }\n\n    test {Call Redis command with many args from Lua (issue #1764)} {\n        r eval {\n            local i\n            local x={}\n            redis.call('del','mylist')\n            for i=1,100 do\n                table.insert(x,i)\n            end\n            redis.call('rpush','mylist',unpack(x))\n            return redis.call('lrange','mylist',0,-1)\n        } 0\n    } {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100}\n\n    test {Number conversion precision test (issue #1118)} {\n        r eval {\n              local value = 9007199254740991\n              redis.call(\"set\",\"foo\",value)\n              return redis.call(\"get\",\"foo\")\n        } 0\n    } {9007199254740991}\n\n    test {String containing number precision test (regression of issue #1118)} {\n        r eval {\n            redis.call(\"set\", \"key\", \"12039611435714932082\")\n            return redis.call(\"get\", \"key\")\n        } 0\n    } {12039611435714932082}\n\n    test {Verify negative arg count is error instead of crash (issue #1842)} {\n        catch { r eval { return \"hello\" } -12 } e\n        set e\n    } {ERR Number of keys can't be negative}\n\n    test {Correct handling of reused argv (issue #1939)} {\n        r eval {\n              for i = 0, 10 do\n                  redis.call('SET', 'a', '1')\n                  redis.call('MGET', 'a', 'b', 'c')\n                  redis.call('EXPIRE', 'a', 0)\n                  redis.call('GET', 'a')\n                  redis.call('MGET', 'a', 'b', 'c')\n              end\n        } 0\n    }\n\n    test {Functions in the Redis namespace are able to report errors} {\n        catch {\n            r eval {\n                  redis.sha1hex()\n            } 0\n        } e\n        set e\n    } {*wrong number*}\n\n    test {Script with RESP3 map} {\n        set expected_dict [dict create field value]\n        set expected_list [list field value]\n\n        # Sanity test for RESP3 without scripts\n        r HELLO 3\n        r hset hash field value\n        set res [r hgetall hash]\n        assert_equal $res $expected_dict\n\n        # Test RESP3 client with script in both RESP2 and RESP3 modes\n        set res [r eval {redis.setresp(3); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_dict\n        set res [r eval {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_list\n\n        # Test RESP2 client with script in both RESP2 and RESP3 modes\n        r HELLO 2\n        set res [r eval {redis.setresp(3); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_list\n        set res [r eval {redis.setresp(2); return redis.call('hgetall', KEYS[1])} 1 hash]\n        assert_equal $res $expected_list\n    }\n}\n\n# Start a new server since the last test in this stanza will kill the\n# instance at all.\nstart_server {tags {\"scripting\"}} {\n    test {Timedout read-only scripts can be killed by SCRIPT KILL} {\n        set rd [redis_deferring_client]\n        r config set lua-time-limit 10\n        $rd eval {while true do end} 0\n        after 200\n        catch {r ping} e\n        assert_match {BUSY*} $e\n        r script kill\n        after 200 ; # Give some time to Lua to call the hook again...\n        assert_equal [r ping] \"PONG\"\n    }\n\n    test {Timedout script link is still usable after Lua returns} {\n        r config set lua-time-limit 10\n        r eval {for i=1,100000 do redis.call('ping') end return 'ok'} 0\n        r ping\n    } {PONG}\n\n    test {Timedout scripts that modified data can't be killed by SCRIPT KILL} {\n        set rd [redis_deferring_client]\n        r config set lua-time-limit 10\n        $rd eval {redis.call('set',KEYS[1],'y'); while true do end} 1 x\n        after 200\n        catch {r ping} e\n        assert_match {BUSY*} $e\n        catch {r script kill} e\n        assert_match {UNKILLABLE*} $e\n        catch {r ping} e\n        assert_match {BUSY*} $e\n    }\n\n    # Note: keep this test at the end of this server stanza because it\n    # kills the server.\n    test {SHUTDOWN NOSAVE can kill a timedout script anyway} {\n        # The server should be still unresponding to normal commands.\n        catch {r ping} e\n        assert_match {BUSY*} $e\n        catch {r shutdown nosave}\n        # Make sure the server was killed\n        catch {set rd [redis_deferring_client]} e\n        assert_match {*connection refused*} $e\n    }\n}\n\nforeach cmdrepl {0 1} {\n    start_server {tags {\"scripting repl\"}} {\n        start_server {} {\n            if {$cmdrepl == 1} {\n                set rt \"(commands replication)\"\n            } else {\n                set rt \"(scripts replication)\"\n                r debug lua-always-replicate-commands 1\n            }\n\n            test \"Before the replica connects we issue two EVAL commands $rt\" {\n                # One with an error, but still executing a command.\n                # SHA is: 67164fc43fa971f76fd1aaeeaf60c1c178d25876\n                catch {\n                    r eval {redis.call('incr',KEYS[1]); redis.call('nonexisting')} 1 x\n                }\n                # One command is correct:\n                # SHA is: 6f5ade10a69975e903c6d07b10ea44c6382381a5\n                r eval {return redis.call('incr',KEYS[1])} 1 x\n            } {2}\n\n            test \"Connect a replica to the master instance $rt\" {\n                r -1 slaveof [srv 0 host] [srv 0 port]\n                wait_for_condition 50 100 {\n                    [s -1 role] eq {slave} &&\n                    [string match {*master_link_status:up*} [r -1 info replication]]\n                } else {\n                    fail \"Can't turn the instance into a replica\"\n                }\n            }\n\n            test \"Now use EVALSHA against the master, with both SHAs $rt\" {\n                # The server should replicate successful and unsuccessful\n                # commands as EVAL instead of EVALSHA.\n                catch {\n                    r evalsha 67164fc43fa971f76fd1aaeeaf60c1c178d25876 1 x\n                }\n                r evalsha 6f5ade10a69975e903c6d07b10ea44c6382381a5 1 x\n            } {4}\n\n            test \"If EVALSHA was replicated as EVAL, 'x' should be '4' $rt\" {\n                wait_for_condition 50 100 {\n                    [r -1 get x] eq {4}\n                } else {\n                    fail \"Expected 4 in x, but value is '[r -1 get x]'\"\n                }\n            }\n\n            test \"Replication of script multiple pushes to list with BLPOP $rt\" {\n                set rd [redis_deferring_client]\n                $rd brpop a 0\n                r eval {\n                    redis.call(\"lpush\",KEYS[1],\"1\");\n                    redis.call(\"lpush\",KEYS[1],\"2\");\n                } 1 a\n                set res [$rd read]\n                $rd close\n                wait_for_condition 50 100 {\n                    [r -1 lrange a 0 -1] eq [r lrange a 0 -1]\n                } else {\n                    fail \"Expected list 'a' in replica and master to be the same, but they are respectively '[r -1 lrange a 0 -1]' and '[r lrange a 0 -1]'\"\n                }\n                set res\n            } {a 1}\n\n            test \"EVALSHA replication when first call is readonly $rt\" {\n                r del x\n                r eval {if tonumber(ARGV[1]) > 0 then redis.call('incr', KEYS[1]) end} 1 x 0\n                r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 0\n                r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 1\n                wait_for_condition 50 100 {\n                    [r -1 get x] eq {1}\n                } else {\n                    fail \"Expected 1 in x, but value is '[r -1 get x]'\"\n                }\n            }\n\n            test \"Lua scripts using SELECT are replicated correctly $rt\" {\n                r eval {\n                    redis.call(\"set\",\"foo1\",\"bar1\")\n                    redis.call(\"select\",\"10\")\n                    redis.call(\"incr\",\"x\")\n                    redis.call(\"select\",\"11\")\n                    redis.call(\"incr\",\"z\")\n                } 0\n                r eval {\n                    redis.call(\"set\",\"foo1\",\"bar1\")\n                    redis.call(\"select\",\"10\")\n                    redis.call(\"incr\",\"x\")\n                    redis.call(\"select\",\"11\")\n                    redis.call(\"incr\",\"z\")\n                } 0\n                wait_for_condition 50 100 {\n                    [r -1 debug digest] eq [r debug digest]\n                } else {\n                    fail \"Master-Replica desync after Lua script using SELECT.\"\n                }\n            }\n        }\n    }\n}\n\nstart_server {tags {\"scripting repl\"}} {\n    start_server {overrides {appendonly yes aof-use-rdb-preamble no}} {\n        test \"Connect a replica to the master instance\" {\n            r -1 slaveof [srv 0 host] [srv 0 port]\n            wait_for_condition 50 100 {\n                [s -1 role] eq {slave} &&\n                [string match {*master_link_status:up*} [r -1 info replication]]\n            } else {\n                fail \"Can't turn the instance into a replica\"\n            }\n        }\n\n        test \"Redis.replicate_commands() must be issued before any write\" {\n            r eval {\n                redis.call('set','foo','bar');\n                return redis.replicate_commands();\n            } 0\n        } {}\n\n        test \"Redis.replicate_commands() must be issued before any write (2)\" {\n            r eval {\n                return redis.replicate_commands();\n            } 0\n        } {1}\n\n        test \"Redis.set_repl() must be issued after replicate_commands()\" {\n            r debug lua-always-replicate-commands 0\n            catch {\n                r eval {\n                    redis.set_repl(redis.REPL_ALL);\n                } 0\n            } e\n            r debug lua-always-replicate-commands 1\n            set e\n        } {*only after turning on*}\n\n        test \"Redis.set_repl() don't accept invalid values\" {\n            catch {\n                r eval {\n                    redis.replicate_commands();\n                    redis.set_repl(12345);\n                } 0\n            } e\n            set e\n        } {*Invalid*flags*}\n\n        test \"Test selective replication of certain Redis commands from Lua\" {\n            r del a b c d\n            r eval {\n                redis.replicate_commands();\n                redis.call('set','a','1');\n                redis.set_repl(redis.REPL_NONE);\n                redis.call('set','b','2');\n                redis.set_repl(redis.REPL_AOF);\n                redis.call('set','c','3');\n                redis.set_repl(redis.REPL_ALL);\n                redis.call('set','d','4');\n            } 0\n\n            wait_for_condition 50 100 {\n                [r -1 mget a b c d] eq {1 {} {} 4}\n            } else {\n                fail \"Only a and c should be replicated to replica\"\n            }\n\n            # Master should have everything right now\n            assert {[r mget a b c d] eq {1 2 3 4}}\n\n            # After an AOF reload only a, c and d should exist\n            r debug loadaof\n\n            assert {[r mget a b c d] eq {1 {} 3 4}}\n        }\n\n        test \"PRNG is seeded randomly for command replication\" {\n            set a [\n                r eval {\n                    redis.replicate_commands();\n                    return math.random()*100000;\n                } 0\n            ]\n            set b [\n                r eval {\n                    redis.replicate_commands();\n                    return math.random()*100000;\n                } 0\n            ]\n            assert {$a ne $b}\n        }\n\n        test \"Using side effects is not a problem with command replication\" {\n            r eval {\n                redis.replicate_commands();\n                redis.call('set','time',redis.call('time')[1])\n            } 0\n\n            assert {[r get time] ne {}}\n\n            wait_for_condition 50 100 {\n                [r get time] eq [r -1 get time]\n            } else {\n                fail \"Time key does not match between master and replica\"\n            }\n        }\n    }\n}\n\nstart_server {tags {\"scripting\"}} {\n    r script debug sync\n    r eval {return 'hello'} 0\n    r eval {return 'hello'} 0\n}\n\nstart_server {tags {\"scripting needs:debug external:skip\"}} {\n    test {Test scripting debug protocol parsing} {\n        r script debug sync\n        r eval {return 'hello'} 0\n        catch {r 'hello\\0world'} e\n        assert_match {*Unknown Redis Lua debugger command*} $e\n        catch {r 'hello\\0'} e\n        assert_match {*Unknown Redis Lua debugger command*} $e\n        catch {r '\\0hello'} e\n        assert_match {*Unknown Redis Lua debugger command*} $e\n        catch {r '\\0hello\\0'} e\n        assert_match {*Unknown Redis Lua debugger command*} $e\n    }\n}\n"], "filenames": ["src/scripting.c", "tests/unit/scripting.tcl"], "buggy_code_start_loc": [2029, 822], "buggy_code_end_loc": [2572, 822], "fixing_code_start_loc": [2029, 823], "fixing_code_end_loc": [2594, 838], "type": "CWE-125", "message": "Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger\u2019s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14.", "other": {"cve": {"id": "CVE-2021-32672", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-04T18:15:08.780", "lastModified": "2022-10-06T16:50:52.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an open source, in-memory database that persists on disk. When using the Redis Lua Debugger, users can send malformed requests that cause the debugger\u2019s protocol parser to read data beyond the actual buffer. This issue affects all versions of Redis with Lua debugging support (3.2 or newer). The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14."}, {"lang": "es", "value": "Redis es una base de datos en memoria de c\u00f3digo abierto que persiste en el disco. Cuando es usado el depurador Lua de Redis, unos usuarios pueden enviar peticiones malformadas que causan que el analizador de protocolo del depurador lea datos m\u00e1s all\u00e1 del b\u00fafer real. Este problema afecta a todas las versiones de Redis con soporte de depuraci\u00f3n Lua (3.2 o m\u00e1s reciente). El problema es corregido en las versiones 6.2.6, 6.0.16 y 5.0.14"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "5.0.14", "matchCriteriaId": "B1D84464-9B7F-437E-8259-660417BE088D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.16", "matchCriteriaId": "02DF8086-645E-4D42-93D3-A4B11D289C7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.6", "matchCriteriaId": "4686800E-16BA-42CE-B691-011D1D5D0CC2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:software_collections:-:*:*:*:*:*:*:*", "matchCriteriaId": "749804DA-4B27-492A-9ABA-6BB562A6B3AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "86B51137-28D9-41F2-AFA2-3CC22B4954D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_netapp_hci:-:*:*:*:*:*:*:*", "matchCriteriaId": "4455CF3A-CC91-4BE4-A7AB-929AC82E34F5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBE1A019-7BB6-4226-8AC4-9D6927ADAEFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "B98BAEB2-A540-4E8A-A946-C4331B913AFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B8FBE260-E306-4215-80C0-D2D27CA43E0F"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-9mj9-xx53-qmxm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HTYQ5ZF37HNGTZWVNJD3VXP7I6MEEF42/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VL5KXFN3ATM7IIM7Q4O4PWTSRGZ5744Z/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WR5WKJWXD4D6S3DJCZ56V74ESLTDQRAB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-17", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211104-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-5001", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd"}}