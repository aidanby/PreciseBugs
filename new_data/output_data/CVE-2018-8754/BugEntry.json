{"buggy_code": ["AC_PREREQ( 2.59 )\n\nAC_INIT(\n [libevt],\n [20180125],\n [joachim.metz@gmail.com])\n\nAC_CONFIG_SRCDIR(\n [include/libevt.h.in])\n\nAM_INIT_AUTOMAKE([gnu 1.6 tar-ustar])\n\nAC_CONFIG_MACRO_DIR([m4])\n\ndnl Check for host type\nAC_CANONICAL_HOST\n\ndnl Check for libtool DLL support\nAC_LIBTOOL_WIN32_DLL\n\ndnl Checks for programs\nAC_PROG_CC\nAC_PROG_GCC_TRADITIONAL\nAC_PROG_MAKE_SET\nAC_PROG_INSTALL\n\ndnl Check for libtool\nAC_PROG_LIBTOOL\nAC_SUBST(LIBTOOL_DEPS)\n\ndnl Check for pkg-config\nAC_PATH_PROG(PKGCONFIG,[pkg-config])\n\ndnl Support of internationalization (i18n)\nAM_GNU_GETTEXT([external])\nAM_GNU_GETTEXT_VERSION([0.18.1])\n\ndnl Check for compiler language support\nAC_C_CONST\nAC_C_VOLATILE\n\ndnl Check for large file support\nAC_SYS_LARGEFILE\n\ndnl Check if WINAPI support should be enabled\nAX_COMMON_CHECK_ENABLE_WINAPI\n\ndnl Check if wide character type should be enabled\nAX_COMMON_CHECK_ENABLE_WIDE_CHARACTER_TYPE\n\ndnl Check for type definitions\nAX_TYPES_CHECK_LOCAL\n\ndnl Check if common required headers and functions are available\nAX_COMMON_CHECK_LOCAL\n\ndnl Check if libcerror or required headers and functions are available\nAX_LIBCERROR_CHECK_ENABLE\n\ndnl Check if libcthreads or required headers and functions are available\nAX_LIBCTHREADS_CHECK_ENABLE\n\ndnl Check if libcdata or required headers and functions are available\nAX_LIBCDATA_CHECK_ENABLE\n\ndnl Check if libclocale or required headers and functions are available\nAX_LIBCLOCALE_CHECK_ENABLE\n\ndnl Check if libcnotify or required headers and functions are available\nAX_LIBCNOTIFY_CHECK_ENABLE\n\ndnl Check if libcsplit or required headers and functions are available\nAX_LIBCSPLIT_CHECK_ENABLE\n\ndnl Check if libuna or required headers and functions are available\nAX_LIBUNA_CHECK_ENABLE\n\ndnl Check if libcfile or required headers and functions are available\nAX_LIBCFILE_CHECK_ENABLE\n\ndnl Check if libcpath or required headers and functions are available\nAX_LIBCPATH_CHECK_ENABLE\n\ndnl Check if libbfio or required headers and functions are available\nAX_LIBBFIO_CHECK_ENABLE\n\ndnl Check if libfcache or required headers and functions are available\nAX_LIBFCACHE_CHECK_ENABLE\n\ndnl Check if libfdata or required headers and functions are available\nAX_LIBFDATA_CHECK_ENABLE\n\ndnl Check if libfdatetime or required headers and functions are available\nAX_LIBFDATETIME_CHECK_ENABLE\n\ndnl Check if libfguid or required headers and functions are available\nAX_LIBFGUID_CHECK_ENABLE\n\ndnl Check if libfvalue or required headers and functions are available\nAX_LIBFVALUE_CHECK_ENABLE\n\ndnl Check if libfwnt or required headers and functions are available\nAX_LIBFWNT_CHECK_ENABLE\n\ndnl Check if libevt required headers and functions are available\nAX_LIBEVT_CHECK_LOCAL\n\ndnl Check if libevt Python bindings (pyevt) required headers and functions are available\nAX_PYTHON_CHECK_PYPREFIX\nAX_PYTHON_CHECK_ENABLE\nAX_PYTHON2_CHECK_ENABLE\nAX_PYTHON3_CHECK_ENABLE\n\nAS_IF(\n  [test \"x${ac_cv_enable_python}\" != xno || test \"x${ac_cv_enable_python2}\" != xno || test \"x${ac_cv_enable_python3}\" != xno],\n  [dnl Headers included in pyevt/pyevt_error.c\n  AC_CHECK_HEADERS([stdarg.h varargs.h])\n\n  AS_IF(\n    [test \"x$ac_cv_header_stdarg_h\" != xyes && test \"x$ac_cv_header_varargs_h\" != xyes],\n    [AC_MSG_FAILURE(\n      [Missing headers: stdarg.h and varargs.h],\n      [1])\n    ])\n  ])\n\nAM_CONDITIONAL(\n  HAVE_PYTHON_TESTS,\n  [test \"x${ac_cv_enable_python}\" != xno || test \"x${ac_cv_enable_python2}\" != xno || test \"x${ac_cv_enable_python3}\" != xno])\n\ndnl Check if libfwevt or required headers and functions are available\nAX_LIBFWEVT_CHECK_ENABLE\n\ndnl Check if libexe or required headers and functions are available\nAX_LIBEXE_CHECK_ENABLE\n\ndnl Check if libregf or required headers and functions are available\nAX_LIBREGF_CHECK_ENABLE\n\ndnl Check if libwrc or required headers and functions are available\nAX_LIBWRC_CHECK_ENABLE\n\ndnl Check if libcdirectory or required headers and functions are available\nAX_LIBCDIRECTORY_CHECK_ENABLE\n\ndnl Check if evttools required headers and functions are available\nAX_EVTTOOLS_CHECK_LOCAL\n\ndnl Check if libevt should be build with verbose output\nAX_COMMON_CHECK_ENABLE_VERBOSE_OUTPUT\n\ndnl Check if libevt should be build with debug output\nAX_COMMON_CHECK_ENABLE_DEBUG_OUTPUT\n\ndnl Check if tests required headers and functions are available\nAX_TESTS_CHECK_LOCAL\n\ndnl Check if DLL support is needed\nAS_IF(\n [test \"x$enable_shared\" = xyes],\n [AS_CASE(\n  [$host],\n  [*cygwin* | *mingw*],\n  [AC_DEFINE(\n   [HAVE_DLLMAIN],\n   [1],\n   [Define to 1 to enable the DllMain function.])\n  AC_SUBST(\n   [HAVE_DLLMAIN],\n   [1])\n\n  dnl Used in tests\n  AC_SUBST(\n   [LIBEVT_DLL_IMPORT],\n   [\"-DLIBEVT_DLL_IMPORT\"])\n  ])\n ])\n\ndnl Set additional compiler flags\nCFLAGS=\"$CFLAGS -Wall\";\n\ndnl Check if requires and build requires should be set in spec file\nAS_IF(\n [test \"x$ac_cv_libcerror\" = xyes || test \"x$ac_cv_libcthreads\" = xyes || test \"x$ac_cv_libcdata\" = xyes || test \"x$ac_cv_libclocale\" = xyes || test \"x$ac_cv_libcnotify\" = xyes || test \"x$ac_cv_libcsplit\" = xyes || test \"x$ac_cv_libuna\" = xyes || test \"x$ac_cv_libcfile\" = xyes || test \"x$ac_cv_libcpath\" = xyes || test \"x$ac_cv_libbfio\" = xyes || test \"x$ac_cv_libfcache\" = xyes || test \"x$ac_cv_libfdata\" = xyes || test \"x$ac_cv_libfdatetime\" = xyes || test \"x$ac_cv_libfguid\" = xyes || test \"x$ac_cv_libfvalue\" = xyes || test \"x$ac_cv_libfwnt\" = xyes],\n [AC_SUBST(\n  [libevt_spec_requires],\n  [Requires:])\n AC_SUBST(\n  [libevt_spec_build_requires],\n  [BuildRequires:])\n ])\n\nAS_IF(\n [test \"x$ac_cv_libfwevt\" = xyes || test \"x$ac_cv_libexe\" = xyes || test \"x$ac_cv_libregf\" = xyes || test \"x$ac_cv_libwrc\" = xyes || test \"x$ac_cv_libcdirectory\" = xyes],\n [AC_SUBST(\n  [libevt_spec_tools_build_requires],\n  [BuildRequires:])\n ])\n\ndnl Set the date for the dpkg files\nAC_SUBST(\n [DPKG_DATE],\n [`date -R 2> /dev/null`])\n\ndnl Set the date for the spec file\nAC_SUBST(\n [SPEC_DATE],\n [`date +\"%a %b %e %Y\" 2> /dev/null`])\n\ndnl Generate Makefiles\nAC_CONFIG_FILES([Makefile])\nAC_CONFIG_FILES([include/Makefile])\nAC_CONFIG_FILES([common/Makefile])\nAC_CONFIG_FILES([libcerror/Makefile])\nAC_CONFIG_FILES([libcthreads/Makefile])\nAC_CONFIG_FILES([libcdata/Makefile])\nAC_CONFIG_FILES([libclocale/Makefile])\nAC_CONFIG_FILES([libcnotify/Makefile])\nAC_CONFIG_FILES([libcsplit/Makefile])\nAC_CONFIG_FILES([libuna/Makefile])\nAC_CONFIG_FILES([libcfile/Makefile])\nAC_CONFIG_FILES([libcpath/Makefile])\nAC_CONFIG_FILES([libbfio/Makefile])\nAC_CONFIG_FILES([libfcache/Makefile])\nAC_CONFIG_FILES([libfdata/Makefile])\nAC_CONFIG_FILES([libfdatetime/Makefile])\nAC_CONFIG_FILES([libfguid/Makefile])\nAC_CONFIG_FILES([libfvalue/Makefile])\nAC_CONFIG_FILES([libfwnt/Makefile])\nAC_CONFIG_FILES([libevt/Makefile])\nAC_CONFIG_FILES([pyevt/Makefile])\nAC_CONFIG_FILES([pyevt-python2/Makefile])\nAC_CONFIG_FILES([pyevt-python3/Makefile])\nAC_CONFIG_FILES([libfwevt/Makefile])\nAC_CONFIG_FILES([libexe/Makefile])\nAC_CONFIG_FILES([libregf/Makefile])\nAC_CONFIG_FILES([libwrc/Makefile])\nAC_CONFIG_FILES([libcdirectory/Makefile])\nAC_CONFIG_FILES([evttools/Makefile])\nAC_CONFIG_FILES([po/Makefile.in])\nAC_CONFIG_FILES([po/Makevars])\nAC_CONFIG_FILES([manuals/Makefile])\nAC_CONFIG_FILES([tests/Makefile])\nAC_CONFIG_FILES([msvscpp/Makefile])\ndnl Generate header files\nAC_CONFIG_FILES([include/libevt.h])\nAC_CONFIG_FILES([include/libevt/definitions.h])\nAC_CONFIG_FILES([include/libevt/features.h])\nAC_CONFIG_FILES([include/libevt/types.h])\nAC_CONFIG_FILES([libevt/libevt_definitions.h])\ndnl Generate distribution specific files\nAC_CONFIG_FILES([common/types.h])\nAC_CONFIG_FILES([dpkg/changelog])\nAC_CONFIG_FILES([libevt/libevt.rc])\nAC_CONFIG_FILES([libevt.pc])\nAC_CONFIG_FILES([libevt.spec])\ndnl Generate a source configuration file\nAC_CONFIG_HEADERS([common/config.h])\n\nAC_OUTPUT\n\ndnl Print a summary\nAC_MSG_NOTICE([\nBuilding:\n   libcerror support:                        $ac_cv_libcerror\n   libcthreads support:                      $ac_cv_libcthreads\n   libcdata support:                         $ac_cv_libcdata\n   libclocale support:                       $ac_cv_libclocale\n   libcnotify support:                       $ac_cv_libcnotify\n   libcsplit support:                        $ac_cv_libcsplit\n   libuna support:                           $ac_cv_libuna\n   libcfile support:                         $ac_cv_libcfile\n   libcpath support:                         $ac_cv_libcpath\n   libbfio support:                          $ac_cv_libbfio\n   libfcache support:                        $ac_cv_libfcache\n   libfdata support:                         $ac_cv_libfdata\n   libfdatetime support:                     $ac_cv_libfdatetime\n   libfguid support:                         $ac_cv_libfguid\n   libfvalue support:                        $ac_cv_libfvalue\n   libfwnt support:                          $ac_cv_libfwnt\n   libfwevt support:                         $ac_cv_libfwevt\n   libexe support:                           $ac_cv_libexe\n   libregf support:                          $ac_cv_libregf\n   libwrc support:                           $ac_cv_libwrc\n   libcdirectory support:                    $ac_cv_libcdirectory\n\nFeatures:\n   Multi-threading support:                  $ac_cv_libcthreads_multi_threading\n   Wide character type support:              $ac_cv_enable_wide_character_type\n   evttools are build as static executables: $ac_cv_enable_static_executables\n   Python (pyevt) support:                   $ac_cv_enable_python\n   Python version 2 (pyevt) support:         $ac_cv_enable_python2\n   Python version 3 (pyevt) support:         $ac_cv_enable_python3\n   Verbose output:                           $ac_cv_enable_verbose_output\n   Debug output:                             $ac_cv_enable_debug_output\n]);\n\n", "<?xml version=\"1.0\"?>\r\n<package >\r\n  <metadata>\r\n    <id>libevt</id>\r\n    <version>20180125</version>\r\n    <authors>Joachim Metz</authors>\r\n    <owners>joachimmetz</owners>\r\n    <licenseUrl>https://raw.githubusercontent.com/libyal/libevt/master/COPYING</licenseUrl>\r\n    <projectUrl>https://github.com/libyal/libevt</projectUrl>\r\n    <requireLicenseAcceptance>false</requireLicenseAcceptance>\r\n    <title>libevt</title>\r\n    <description>Library to access the Windows Event Log (EVT) format</description>\r\n    <releaseNotes>Release of libevt 20180125</releaseNotes>\r\n    <copyright>Copyright (C) 2011-2018</copyright>\r\n    <tags>native</tags>\r\n  </metadata>\r\n  <files>\r\n    <file src=\"include\\*.h\" target=\"lib\\native\\include\\\" />\r\n    <file src=\"include\\libevt\\*.h\" target=\"lib\\native\\include\\libevt\\\" />\r\n    <file src=\"msvscpp\\Release\\Win32\\libevt.dll\" target=\"lib\\native\\lib\\Win32\\\" />\r\n    <file src=\"msvscpp\\Release\\Win32\\libevt.lib\" target=\"lib\\native\\lib\\Win32\\\" />\r\n    <file src=\"msvscpp\\Release\\Win32\\libevt.pdb\" target=\"lib\\native\\lib\\Win32\\\" />\r\n    <file src=\"msvscpp\\Release\\x64\\libevt.dll\" target=\"lib\\native\\lib\\x64\\\" />\r\n    <file src=\"msvscpp\\Release\\x64\\libevt.lib\" target=\"lib\\native\\lib\\x64\\\" />\r\n    <file src=\"msvscpp\\Release\\x64\\libevt.pdb\" target=\"lib\\native\\lib\\x64\\\" />\r\n  </files>\r\n</package>\r\n", "/*\n * The libfvalue header wrapper\n *\n * Copyright (C) 2011-2018, Joachim Metz <joachim.metz@gmail.com>\n *\n * Refer to AUTHORS for acknowledgements.\n *\n * This software is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this software.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#if !defined( _LIBEVT_LIBFVALUE_H )\n#define _LIBEVT_LIBFVALUE_H\n\n#include <common.h>\n\n/* Define HAVE_LOCAL_LIBFVALUE for local use of libfvalue\n */\n#if defined( HAVE_LOCAL_LIBFVALUE )\n\n#include <libfvalue_codepage.h>\n#include <libfvalue_definitions.h>\n#include <libfvalue_floating_point.h>\n#include <libfvalue_integer.h>\n#include <libfvalue_split_utf16_string.h>\n#include <libfvalue_split_utf8_string.h>\n#include <libfvalue_string.h>\n#include <libfvalue_table.h>\n#include <libfvalue_types.h>\n#include <libfvalue_value.h>\n#include <libfvalue_value_type.h>\n#include <libfvalue_utf16_string.h>\n#include <libfvalue_utf8_string.h>\n\n#else\n\n/* If libtool DLL support is enabled set LIBFVALUE_DLL_IMPORT\n * before including libfvalue.h\n */\n#if defined( _WIN32 ) && defined( DLL_IMPORT )\n#define LIBFVALUE_DLL_IMPORT\n#endif\n\n#include <libfvalue.h>\n\n#endif /* defined( HAVE_LOCAL_LIBFVALUE ) */\n\n#endif /* !defined( _LIBEVT_LIBFVALUE_H ) */\n\n", "/*\n * Record values functions\n *\n * Copyright (C) 2011-2018, Joachim Metz <joachim.metz@gmail.com>\n *\n * Refer to AUTHORS for acknowledgements.\n *\n * This software is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this software.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <common.h>\n#include <byte_stream.h>\n#include <memory.h>\n#include <system_string.h>\n#include <types.h>\n\n#include \"libevt_debug.h\"\n#include \"libevt_io_handle.h\"\n#include \"libevt_libbfio.h\"\n#include \"libevt_libcerror.h\"\n#include \"libevt_libcnotify.h\"\n#include \"libevt_libfdatetime.h\"\n#include \"libevt_libfvalue.h\"\n#include \"libevt_libfwnt.h\"\n#include \"libevt_record_values.h\"\n#include \"libevt_unused.h\"\n\n#include \"evt_file_header.h\"\n#include \"evt_record.h\"\n\nconst uint8_t evt_end_of_file_record_signature1[ 4 ] = { 0x11, 0x11, 0x11, 0x11 };\nconst uint8_t evt_end_of_file_record_signature2[ 4 ] = { 0x22, 0x22, 0x22, 0x22 };\nconst uint8_t evt_end_of_file_record_signature3[ 4 ] = { 0x33, 0x33, 0x33, 0x33 };\nconst uint8_t evt_end_of_file_record_signature4[ 4 ] = { 0x44, 0x44, 0x44, 0x44 };\n\n/* Creates record values\n * Make sure the value record_values is referencing, is set to NULL\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_initialize(\n     libevt_record_values_t **record_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_initialize\";\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *record_values != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid record values value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*record_values = memory_allocate_structure(\n\t                  libevt_record_values_t );\n\n\tif( *record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *record_values,\n\t     0,\n\t     sizeof( libevt_record_values_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *record_values != NULL )\n\t{\n\t\tmemory_free(\n\t\t *record_values );\n\n\t\t*record_values = NULL;\n\t}\n\treturn( -1 );\n}\n\n/* Frees record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_free(\n     libevt_record_values_t **record_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_free\";\n\tint result            = 1;\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *record_values != NULL )\n\t{\n\t\tif( ( *record_values )->source_name != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->source_name ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free source name value.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->computer_name != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->computer_name ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free computer name value.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->user_security_identifier != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->user_security_identifier ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free user security identifier (SID).\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->strings != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->strings ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free strings.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->data != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->data ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free data.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tmemory_free(\n\t\t *record_values );\n\n\t\t*record_values = NULL;\n\t}\n\treturn( result );\n}\n\n/* Clones the record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_clone(\n     libevt_record_values_t **destination_record_values,\n     libevt_record_values_t *source_record_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_clone\";\n\n\tif( destination_record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid destination record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *destination_record_values != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid destination record values value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( source_record_values == NULL )\n\t{\n\t\t*destination_record_values = NULL;\n\n\t\treturn( 1 );\n\t}\n\t*destination_record_values = memory_allocate_structure(\n\t                              libevt_record_values_t );\n\n\tif( *destination_record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create destination record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_copy(\n\t     *destination_record_values,\n\t     source_record_values,\n\t     sizeof( libevt_record_values_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_COPY_FAILED,\n\t\t \"%s: unable to copy source to destination record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *destination_record_values != NULL )\n\t{\n\t\tmemory_free(\n\t\t *destination_record_values );\n\n\t\t*destination_record_values = NULL;\n\t}\n\treturn( -1 );\n}\n\n/* Reads a record_values\n * Returns the number of bytes read if successful or -1 on error\n */\nssize_t libevt_record_values_read(\n         libevt_record_values_t *record_values,\n         libbfio_handle_t *file_io_handle,\n         libevt_io_handle_t *io_handle,\n         off64_t *file_offset,\n         uint8_t strict_mode,\n         libcerror_error_t **error )\n{\n\tuint8_t record_size_data[ 4 ];\n\n\tuint8_t *record_data      = NULL;\n\tstatic char *function     = \"libevt_record_values_read\";\n\tsize_t read_size          = 0;\n\tsize_t record_data_offset = 0;\n\tssize_t read_count        = 0;\n\tssize_t total_read_count  = 0;\n\tuint32_t record_data_size = 0;\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( file_offset == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid file offset.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\trecord_values->offset = *file_offset;\n\n\tread_count = libbfio_handle_read_buffer(\n\t              file_io_handle,\n\t              record_size_data,\n\t              sizeof( uint32_t ),\n\t              error );\n\n\tif( read_count != (ssize_t) sizeof( uint32_t ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t \"%s: unable to read record size data.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t*file_offset    += read_count;\n\ttotal_read_count = read_count;\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t record_size_data,\n\t record_data_size );\n\n\tif( record_data_size < 4 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#if SIZEOF_SIZE_T <= 4\n\tif( (size_t) record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\t/* Allocating record data as 4 bytes and then using realloc here\n\t * corrupts the memory\n\t */\n\trecord_data = (uint8_t *) memory_allocate(\n\t                           sizeof( uint8_t ) * record_data_size );\n\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create record data.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tbyte_stream_copy_from_uint32_little_endian(\n\t record_data,\n\t record_data_size );\n\n\trecord_data_offset = 4;\n\n\tread_size = record_data_size - record_data_offset;\n\n\tif( ( (size64_t) *file_offset + read_size ) > io_handle->file_size )\n\t{\n\t\tread_size = (size_t) ( io_handle->file_size - *file_offset );\n\t}\n\tread_count = libbfio_handle_read_buffer(\n\t              file_io_handle,\n\t              &( record_data[ record_data_offset ] ),\n\t              read_size,\n\t              error );\n\n\tif( read_count != (ssize_t) read_size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t \"%s: unable to read record data.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t*file_offset       += read_count;\n\trecord_data_offset += read_count;\n\ttotal_read_count   += read_count;\n\n\tif( record_data_offset < (size_t) record_data_size )\n\t{\n\t\tif( libbfio_handle_seek_offset(\n\t\t     file_io_handle,\n\t\t     (off64_t) sizeof( evt_file_header_t ),\n\t\t     SEEK_SET,\n\t\t     error ) == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_SEEK_FAILED,\n\t\t\t \"%s: unable to seek file header offset: %\" PRIzd \".\",\n\t\t\t function,\n\t\t\t sizeof( evt_file_header_t ) );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\t*file_offset = (off64_t) sizeof( evt_file_header_t );\n\n\t\tread_size = (size_t) record_data_size - record_data_offset;\n\n\t\tread_count = libbfio_handle_read_buffer(\n\t\t              file_io_handle,\n\t\t              &( record_data[ record_data_offset ] ),\n\t\t              read_size,\n\t\t              error );\n\n\t\tif( read_count != (ssize_t) read_size )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t\t \"%s: unable to read record data.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\t*file_offset     += read_count;\n\t\ttotal_read_count += read_count;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: record data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t record_data,\n\t\t (size_t) record_data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( memory_compare(\n\t     &( record_data[ 4 ] ),\n\t     evt_file_signature,\n\t     4 ) == 0 )\n\t{\n\t\trecord_values->type = LIBEVT_RECORD_TYPE_EVENT;\n\t}\n\telse if( memory_compare(\n\t          &( record_data[ 4 ] ),\n\t          evt_end_of_file_record_signature1,\n\t          4 ) == 0 )\n\t{\n\t\trecord_values->type = LIBEVT_RECORD_TYPE_END_OF_FILE;\n\t}\n\telse\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported record values signature.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( record_values->type == LIBEVT_RECORD_TYPE_EVENT )\n\t{\n\t\tif( libevt_record_values_read_event(\n\t\t     record_values,\n\t\t     record_data,\n\t\t     (size_t) record_data_size,\n\t\t     strict_mode,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t\t \"%s: unable to read event record values.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\telse if( record_values->type == LIBEVT_RECORD_TYPE_END_OF_FILE )\n\t{\n\t\tif( libevt_record_values_read_end_of_file(\n\t\t     record_values,\n\t\t     record_data,\n\t\t     (size_t) record_data_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t\t \"%s: unable to read end of file record values.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tmemory_free(\n\t record_data );\n\n\treturn( total_read_count );\n\non_error:\n\tif( record_data != NULL )\n\t{\n\t\tmemory_free(\n\t\t record_data );\n\t}\n\treturn( -1 );\n}\n\n/* Reads the event record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_read_event(\n     libevt_record_values_t *record_values,\n     uint8_t *record_data,\n     size_t record_data_size,\n     uint8_t strict_mode,\n     libcerror_error_t **error )\n{\n\tstatic char *function      = \"libevt_record_values_read_event\";\n\tsize_t record_data_offset  = 0;\n\tsize_t strings_data_offset = 0;\n\tssize_t value_data_size    = 0;\n\tuint32_t data_offset       = 0;\n\tuint32_t data_size         = 0;\n\tuint32_t members_data_size = 0;\n\tuint32_t size              = 0;\n\tuint32_t size_copy         = 0;\n\tuint32_t strings_offset    = 0;\n\tuint32_t strings_size      = 0;\n\tuint32_t user_sid_offset   = 0;\n\tuint32_t user_sid_size     = 0;\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tuint32_t value_32bit       = 0;\n\tuint16_t value_16bit       = 0;\n#endif\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size < ( sizeof( evt_record_event_header_t ) + 4 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->size,\n\t size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->record_number,\n\t record_values->number );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->creation_time,\n\t record_values->creation_time );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->written_time,\n\t record_values->written_time );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_identifier,\n\t record_values->event_identifier );\n\n\tbyte_stream_copy_to_uint16_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_type,\n\t record_values->event_type );\n\n\tbyte_stream_copy_to_uint16_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_category,\n\t record_values->event_category );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->strings_offset,\n\t strings_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->user_sid_size,\n\t user_sid_size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->user_sid_offset,\n\t user_sid_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->data_size,\n\t data_size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->data_offset,\n\t data_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t &( record_data[ record_data_size - 4 ] ),\n\t size_copy );\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: size\\t\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: signature\\t\\t\\t\\t: %c%c%c%c\\n\",\n\t\t function,\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 0 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 1 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 2 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 3 ] );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: record number\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t record_values->number );\n\n\t\tif( libevt_debug_print_posix_time_value(\n\t\t     function,\n\t\t     \"creation time\\t\\t\\t\\t\",\n\t\t     ( (evt_record_event_header_t *) record_data )->creation_time,\n\t\t     4,\n\t\t     LIBFDATETIME_ENDIAN_LITTLE,\n\t\t     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,\n\t\t     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t \"%s: unable to print POSIX time value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libevt_debug_print_posix_time_value(\n\t\t     function,\n\t\t     \"written time\\t\\t\\t\\t\",\n\t\t     ( (evt_record_event_header_t *) record_data )->written_time,\n\t\t     4,\n\t\t     LIBFDATETIME_ENDIAN_LITTLE,\n\t\t     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,\n\t\t     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t \"%s: unable to print POSIX time value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t record_values->event_identifier );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: code\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t record_values->event_identifier & 0x0000ffffUL );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: facility\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x0fff0000UL ) >> 16 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: reserved\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x10000000UL ) >> 28 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: customer flags\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x20000000UL ) >> 29 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: severity\\t\\t: %\" PRIu32 \" (\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0xc0000000UL ) >> 30 );\n\t\tlibevt_debug_print_event_identifier_severity(\n\t\t record_values->event_identifier );\n\t\tlibcnotify_printf(\n\t\t \")\\n\" );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event type\\t\\t\\t\\t: %\" PRIu16 \" (\",\n\t\t function,\n\t\t record_values->event_type );\n\t\tlibevt_debug_print_event_type(\n\t\t record_values->event_type );\n\t\tlibcnotify_printf(\n\t\t \")\\n\" );\n\n\t\tbyte_stream_copy_to_uint16_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->number_of_strings,\n\t\t value_16bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: number of strings\\t\\t\\t: %\" PRIu16 \"\\n\",\n\t\t function,\n\t\t value_16bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event category\\t\\t\\t\\t: %\" PRIu16 \"\\n\",\n\t\t function,\n\t\t record_values->event_category );\n\n\t\tbyte_stream_copy_to_uint16_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->event_flags,\n\t\t value_16bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: event flags\\t\\t\\t\\t: 0x%04\" PRIx16 \"\\n\",\n\t\t function,\n\t\t value_16bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->closing_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: closing record values number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: strings offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t strings_offset );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: user security identifier (SID) size\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t user_sid_size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: user security identifier (SID) offset\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t user_sid_offset );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: data size\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: data offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t data_offset );\n\t}\n#endif\n\trecord_data_offset = sizeof( evt_record_event_header_t );\n\n\tif( ( user_sid_offset == 0 )\n\t && ( user_sid_size != 0 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: user SID offset or size value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( user_sid_offset != 0 )\n\t{\n\t\tif( ( (size_t) user_sid_offset < record_data_offset )\n\t\t || ( (size_t) user_sid_offset >= ( record_data_size - 4 ) ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: user SID offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( user_sid_size != 0 )\n\t\t{\n\t\t\tif( (size_t) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t\t \"%s: user SID size value out of bounds.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\t/* If the strings offset is points at the offset at record data size - 4\n\t * the strings are empty. For this to be sane the data offset should\n\t * be the same as the strings offset or the data size 0.\n\t */\n\tif( ( (size_t) strings_offset < user_sid_offset )\n\t || ( (size_t) strings_offset >= ( record_data_size - 4 ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: strings offset value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( ( (size_t) data_offset < strings_offset )\n\t || ( (size_t) data_offset >= ( record_data_size - 4 ) ) )\n\t{\n\t\tif( data_size != 0 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tdata_offset = (uint32_t) record_data_size - 4;\n\t}\n\tif( ( (size_t) strings_offset >= ( record_data_size - 4 ) )\n\t && ( strings_offset != data_offset ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: strings offset value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( strings_offset != 0 )\n\t{\n\t\tif( strings_offset < record_data_offset )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: strings offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( user_sid_offset != 0 )\n\t{\n\t\tmembers_data_size = user_sid_offset - (uint32_t) record_data_offset;\n\t}\n\telse if( strings_offset != 0 )\n\t{\n\t\tmembers_data_size = strings_offset - (uint32_t) record_data_offset;\n\t}\n\tif( strings_offset != 0 )\n\t{\n\t\tstrings_size = data_offset - strings_offset;\n\t}\n\tif( data_size != 0 )\n\t{\n\t\tif( (size_t) ( data_offset + data_size ) > ( record_data_size - 4 ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data size value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( members_data_size != 0 )\n\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: members data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t members_data_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->source_name ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create source name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_string(\n\t\t                   record_values->source_name,\n\t\t                   &( record_data[ record_data_offset ] ),\n\t\t                   members_data_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of source name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: source name\\t\\t\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->source_name,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print source name value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += value_data_size;\n\t\tmembers_data_size  -= (uint32_t) value_data_size;\n\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->computer_name ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create computer name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_string(\n\t\t                   record_values->computer_name,\n\t\t                   &( record_data[ record_data_offset ] ),\n\t\t                   members_data_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of computer name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: computer name\\t\\t\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->computer_name,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print computer name value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += value_data_size;\n\t\tmembers_data_size  -= (uint32_t) value_data_size;\n\n\t\tif( members_data_size > 0 )\n\t\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\t\tif( libcnotify_verbose != 0 )\n\t\t\t{\n\t\t\t\tlibcnotify_printf(\n\t\t\t\t \"%s: members trailing data:\\n\",\n\t\t\t\t function );\n\t\t\t\tlibcnotify_print_data(\n\t\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t\t members_data_size,\n\t\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t\t}\n#endif\n\t\t\trecord_data_offset += members_data_size;\n\t\t}\n\t}\n\tif( user_sid_size != 0 )\n\t{\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->user_security_identifier ),\n\t\t     LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create user security identifier (SID) value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_set_data(\n\t\t     record_values->user_security_identifier,\n\t\t     &( record_data[ user_sid_offset ] ),\n\t\t     (size_t) user_sid_size,\n\t\t     LIBFVALUE_ENDIAN_LITTLE,\n\t\t     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of user security identifier (SID) value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: user security identifier (SID)\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->user_security_identifier,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print user security identifier (SID) value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += user_sid_size;\n\t}\n\tif( strings_size != 0 )\n\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: strings data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ strings_offset ] ),\n\t\t\t strings_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( size_copy == 0 )\n\t\t{\n\t\t\t/* If the strings data is truncated\n\t\t\t */\n\t\t\tstrings_data_offset = strings_offset + strings_size - 2;\n\n\t\t\twhile( strings_data_offset > strings_offset )\n\t\t\t{\n\t\t\t\tif( ( record_data[ strings_data_offset ] != 0 )\n\t\t\t\t || ( record_data[ strings_data_offset + 1 ] != 0 ) )\n\t\t\t\t{\n\t\t\t\t\tstrings_size += 2;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrings_data_offset -= 2;\n\t\t\t\tstrings_size        -= 2;\n\t\t\t}\n\t\t}\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->strings ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create strings value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_strings_array(\n\t\t                   record_values->strings,\n\t\t                   &( record_data[ strings_offset ] ),\n\t\t                   strings_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of strings value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\trecord_data_offset += strings_size;\n\t}\n\tif( data_size != 0 )\n\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ data_offset ] ),\n\t\t\t (size_t) data_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->data ),\n\t\t     LIBFVALUE_VALUE_TYPE_BINARY_DATA,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create data value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_set_data(\n\t\t     record_values->data,\n\t\t     &( record_data[ record_data_offset ] ),\n\t\t     (size_t) data_size,\n\t\t     LIBFVALUE_ENDIAN_LITTLE,\n\t\t     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of data value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\trecord_data_offset += data_size;\n#endif\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tif( record_data_offset < ( record_data_size - 4 ) )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: padding:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t (size_t) record_data_size - record_data_offset - 4,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n\t\tlibcnotify_printf(\n\t\t \"%s: size copy\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size_copy );\n\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\tif( ( strict_mode == 0 )\n\t && ( size_copy == 0 ) )\n\t{\n\t\tsize_copy = size;\n\t}\n\tif( size != size_copy )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for size and size copy.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( record_data_size != (size_t) size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for record_values data size and size.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( record_values->data != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->data ),\n\t\t NULL );\n\t}\n\tif( record_values->strings != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->strings ),\n\t\t NULL );\n\t}\n\tif( record_values->user_security_identifier != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->user_security_identifier ),\n\t\t NULL );\n\t}\n\tif( record_values->computer_name != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->computer_name ),\n\t\t NULL );\n\t}\n\tif( record_values->source_name != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->source_name ),\n\t\t NULL );\n\t}\n\treturn( -1 );\n}\n\n/* Reads the end of file record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_read_end_of_file(\n     libevt_record_values_t *record_values,\n     uint8_t *record_data,\n     size_t record_data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_read_end_of_file\";\n\tuint32_t size         = 0;\n\tuint32_t size_copy    = 0;\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tuint32_t value_32bit  = 0;\n#endif\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size < sizeof( evt_record_end_of_file_t ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_end_of_file_t *) record_data )->size,\n\t size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_end_of_file_t *) record_data )->size_copy,\n\t size_copy );\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: size\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature1,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature1\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature2,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature2\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature3,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature3\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature4,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature4\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->first_record_offset,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: first record offset\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->end_of_file_record_offset,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: end of file record offset\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->last_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: last record number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->first_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: first record number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: size copy\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size_copy );\n\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\tif( size != size_copy )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for size and size copy.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size != (size_t) size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for record data size and size.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n/* TODO correct values in IO handle if necessary */\n\n\treturn( 1 );\n}\n\n/* Retrieves the type\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_get_type(\n     libevt_record_values_t *record_values,\n     uint8_t *type,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_get_type\";\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( type == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid type.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*type = record_values->type;\n\n\treturn( 1 );\n}\n\n/* Reads record values\n * Callback for the (recovered) records list\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_read_element_data(\n     libevt_io_handle_t *io_handle,\n     libbfio_handle_t *file_io_handle,\n     libfdata_list_element_t *element,\n     libfcache_cache_t *cache,\n     int element_file_index LIBEVT_ATTRIBUTE_UNUSED,\n     off64_t element_offset,\n     size64_t element_size LIBEVT_ATTRIBUTE_UNUSED,\n     uint32_t element_flags LIBEVT_ATTRIBUTE_UNUSED,\n     uint8_t read_flags LIBEVT_ATTRIBUTE_UNUSED,\n     libcerror_error_t **error )\n{\n\tlibevt_record_values_t *record_values = NULL;\n\tstatic char *function                 = \"libevt_record_values_read_element_data\";\n\toff64_t file_offset                   = 0;\n\tssize_t read_count                    = 0;\n\n\tLIBEVT_UNREFERENCED_PARAMETER( element_size )\n\tLIBEVT_UNREFERENCED_PARAMETER( element_file_index )\n\tLIBEVT_UNREFERENCED_PARAMETER( element_flags )\n\tLIBEVT_UNREFERENCED_PARAMETER( read_flags )\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: reading record  at offset: %\" PRIi64 \" (0x%08\" PRIx64 \")\\n\",\n\t\t function,\n\t\t element_offset,\n\t\t element_offset );\n\t}\n#endif\n\tif( libbfio_handle_seek_offset(\n\t     file_io_handle,\n\t     element_offset,\n\t     SEEK_SET,\n\t     error ) == -1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_SEEK_FAILED,\n\t\t \"%s: unable to seek record offset: %\" PRIi64 \".\",\n\t\t function,\n\t\t element_offset );\n\n\t\tgoto on_error;\n\t}\n\tif( libevt_record_values_initialize(\n\t     &record_values,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t/* File offset must be before being passed to libevt_record_values_read\n\t */\n\tfile_offset = element_offset;\n\n\tread_count = libevt_record_values_read(\n\t\t      record_values,\n\t\t      file_io_handle,\n\t\t      io_handle,\n\t\t      &file_offset,\n\t\t      0,\n\t\t      error );\n\n\tif( read_count == -1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t \"%s: unable to read record at offset: %\" PRIi64 \".\",\n\t\t function,\n\t\t element_offset );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_element_set_element_value(\n\t     element,\n\t     (intptr_t *) file_io_handle,\n\t     cache,\n\t     (intptr_t *) record_values,\n\t     (int (*)(intptr_t **, libcerror_error_t **)) &libevt_record_values_free,\n\t     LIBFDATA_LIST_ELEMENT_VALUE_FLAG_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t \"%s: unable to set record values as element value.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( record_values != NULL )\n\t{\n\t\tlibevt_record_values_free(\n\t\t &record_values,\n\t\t NULL );\n\t}\n\treturn( -1 );\n}\n\n", "dnl Checks for libcdata or required headers and functions\ndnl\ndnl Version: 20170904\n\ndnl Function to detect if libcdata is available\ndnl ac_libcdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\nAC_DEFUN([AX_LIBCDATA_CHECK_LIB],\n  [dnl Check if parameters were provided\n  AS_IF(\n    [test \"x$ac_cv_with_libcdata\" != x && test \"x$ac_cv_with_libcdata\" != xno && test \"x$ac_cv_with_libcdata\" != xauto-detect],\n    [AS_IF(\n      [test -d \"$ac_cv_with_libcdata\"],\n      [CFLAGS=\"$CFLAGS -I${ac_cv_with_libcdata}/include\"\n      LDFLAGS=\"$LDFLAGS -L${ac_cv_with_libcdata}/lib\"],\n      [AC_MSG_WARN([no such directory: $ac_cv_with_libcdata])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_with_libcdata\" = xno],\n    [ac_cv_libcdata=no],\n    [dnl Check for a pkg-config file\n    AS_IF(\n      [test \"x$cross_compiling\" != \"xyes\" && test \"x$PKGCONFIG\" != \"x\"],\n      [PKG_CHECK_MODULES(\n        [libcdata],\n        [libcdata >= 20160108],\n        [ac_cv_libcdata=yes],\n        [ac_cv_libcdata=check])\n      ])\n\n    AS_IF(\n      [test \"x$ac_cv_libcdata\" = xyes],\n      [ac_cv_libcdata_CPPFLAGS=\"$pkg_cv_libcdata_CFLAGS\"\n      ac_cv_libcdata_LIBADD=\"$pkg_cv_libcdata_LIBS\"])\n\n    AS_IF(\n      [test \"x$ac_cv_libcdata\" = xcheck],\n      [dnl Check for headers\n      AC_CHECK_HEADERS([libcdata.h])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libcdata_h\" = xno],\n        [ac_cv_libcdata=no],\n        [dnl Check for the individual functions\n        ac_cv_libcdata=yes\n\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_get_version,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl Array functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_resize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_reverse,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_get_number_of_entries,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_get_entry_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_get_entry_by_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_set_entry_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_prepend_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_append_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_insert_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_remove_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl List functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_number_of_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_first_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_last_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_element_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_value_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_prepend_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_prepend_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_append_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_append_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_insert_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_insert_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_remove_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl List element functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_previous_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_previous_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_next_element,\n          [ac_cv_libcdata_dummy=yes],\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_next_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n          [ac_cv_libcdata=no])\n\n        dnl Range list functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_number_of_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_insert_range,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_insert_range_list,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_remove_range,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_range_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_range_at_offset,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_range_is_present,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_spanning_range,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl Tree node functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_parent_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_parent_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_previous_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_previous_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_next_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_next_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_nodes,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_nodes,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_append_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_append_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_insert_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_insert_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_replace_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_remove_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_number_of_sub_nodes,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_sub_node_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_leaf_node_list,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        ac_cv_libcdata_LIBADD=\"-lcdata\"\n        ])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_DEFINE(\n      [HAVE_LIBCDATA],\n      [1],\n      [Define to 1 if you have the `cdata' library (-lcdata).])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_SUBST(\n      [HAVE_LIBCDATA],\n      [1]) ],\n    [AC_SUBST(\n      [HAVE_LIBCDATA],\n      [0])\n    ])\n  ])\n\ndnl Function to detect if libcdata dependencies are available\nAC_DEFUN([AX_LIBCDATA_CHECK_LOCAL],\n  [dnl No additional checks.\n\n  ac_cv_libcdata_CPPFLAGS=\"-I../libcdata\";\n  ac_cv_libcdata_LIBADD=\"../libcdata/libcdata.la\";\n\n  ac_cv_libcdata=local\n  ])\n\ndnl Function to detect how to enable libcdata\nAC_DEFUN([AX_LIBCDATA_CHECK_ENABLE],\n  [AX_COMMON_ARG_WITH(\n    [libcdata],\n    [libcdata],\n    [search for libcdata in includedir and libdir or in the specified DIR, or no if to use local version],\n    [auto-detect],\n    [DIR])\n\n  dnl Check for a shared library version\n  AX_LIBCDATA_CHECK_LIB\n\n  dnl Check if the dependencies for the local library version\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" != xyes],\n    [AX_LIBCDATA_CHECK_LOCAL\n\n    AC_DEFINE(\n      [HAVE_LOCAL_LIBCDATA],\n      [1],\n      [Define to 1 if the local version of libcdata is used.])\n    AC_SUBST(\n      [HAVE_LOCAL_LIBCDATA],\n      [1])\n    ])\n\n  AM_CONDITIONAL(\n    [HAVE_LOCAL_LIBCDATA],\n    [test \"x$ac_cv_libcdata\" = xlocal])\n  AS_IF(\n    [test \"x$ac_cv_libcdata_CPPFLAGS\" != \"x\"],\n    [AC_SUBST(\n      [LIBCDATA_CPPFLAGS],\n      [$ac_cv_libcdata_CPPFLAGS])\n    ])\n  AS_IF(\n    [test \"x$ac_cv_libcdata_LIBADD\" != \"x\"],\n    [AC_SUBST(\n      [LIBCDATA_LIBADD],\n      [$ac_cv_libcdata_LIBADD])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_SUBST(\n      [ax_libcdata_pc_libs_private],\n      [-lcdata])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_SUBST(\n      [ax_libcdata_spec_requires],\n      [libcdata])\n    AC_SUBST(\n      [ax_libcdata_spec_build_requires],\n      [libcdata-devel])\n    ])\n  ])\n\n", "dnl Checks for libcsplit or required headers and functions\ndnl\ndnl Version: 20170903\n\ndnl Function to detect if libcsplit is available\ndnl ac_libcsplit_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\nAC_DEFUN([AX_LIBCSPLIT_CHECK_LIB],\n  [dnl Check if parameters were provided\n  AS_IF(\n    [test \"x$ac_cv_with_libcsplit\" != x && test \"x$ac_cv_with_libcsplit\" != xno && test \"x$ac_cv_with_libcsplit\" != xauto-detect],\n    [AS_IF(\n      [test -d \"$ac_cv_with_libcsplit\"],\n      [CFLAGS=\"$CFLAGS -I${ac_cv_with_libcsplit}/include\"\n      LDFLAGS=\"$LDFLAGS -L${ac_cv_with_libcsplit}/lib\"],\n      [AC_MSG_WARN([no such directory: $ac_cv_with_libcsplit])\n    ])\n  ])\n\n  AS_IF(\n    [test \"x$ac_cv_with_libcsplit\" = xno],\n    [ac_cv_libcsplit=no],\n    [dnl Check for a pkg-config file\n    AS_IF(\n      [test \"x$cross_compiling\" != \"xyes\" && test \"x$PKGCONFIG\" != \"x\"],\n      [PKG_CHECK_MODULES(\n        [libcsplit],\n        [libcsplit >= 20120701],\n        [ac_cv_libcsplit=yes],\n        [ac_cv_libcsplit=check])\n    ])\n\n    AS_IF(\n      [test \"x$ac_cv_libcsplit\" = xyes && test \"x$ac_cv_enable_wide_character_type\" != xno],\n      [AC_CACHE_CHECK(\n       [whether libcsplit/features.h defines LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE as 1],\n       [ac_cv_header_libcsplit_features_h_have_wide_character_type],\n       [AC_LANG_PUSH(C)\n       AC_COMPILE_IFELSE(\n         [AC_LANG_PROGRAM(\n           [[#include <libcsplit/features.h>]],\n           [[#if !defined( LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE != 1 )\n#error LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE not defined\n##endif]] )],\n         [ac_cv_header_libcsplit_features_h_have_wide_character_type=yes],\n         [ac_cv_header_libcsplit_features_h_have_wide_character_type=no])\n       AC_LANG_POP(C)],\n       [ac_cv_header_libcsplit_features_h_have_wide_character_type=no])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libcsplit_features_h_have_wide_character_type\" = xno],\n        [ac_cv_libcsplit=no])\n    ])\n\n    AS_IF(\n      [test \"x$ac_cv_libcsplit\" = xyes],\n      [ac_cv_libcsplit_CPPFLAGS=\"$pkg_cv_libcsplit_CFLAGS\"\n      ac_cv_libcsplit_LIBADD=\"$pkg_cv_libcsplit_LIBS\"])\n\n    AS_IF(\n      [test \"x$ac_cv_libcsplit\" = xcheck],\n      [dnl Check for headers\n      AC_CHECK_HEADERS([libcsplit.h])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libcsplit_h\" = xno],\n        [ac_cv_libcsplit=no],\n        [dnl Check for the individual functions\n        ac_cv_libcsplit=yes\n\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_get_version,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n\n        dnl Narrow string functions\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_string_split,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n\n        dnl Narrow split string functions\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_free,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_get_string,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_get_number_of_segments,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_get_segment_by_index,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_set_segment_by_index,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n\n        dnl Wide string functions\n        AS_IF(\n          [test \"x$ac_cv_enable_wide_character_type\" != xno],\n          [AC_CHECK_LIB(\n          csplit,\n            libcsplit_wide_string_split,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n\n        dnl Wide split string functions\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_free,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_get_string,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_get_number_of_segments,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_get_segment_by_index,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_set_segment_by_index,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          ])\n\n        ac_cv_libcsplit_LIBADD=\"-lcsplit\"\n        ])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_DEFINE(\n      [HAVE_LIBCSPLIT],\n      [1],\n      [Define to 1 if you have the `csplit' library (-lcsplit).])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_SUBST(\n      [HAVE_LIBCSPLIT],\n      [1]) ],\n    [AC_SUBST(\n      [HAVE_LIBCSPLIT],\n      [0])\n    ])\n  ])\n\ndnl Function to detect if libcsplit dependencies are available\nAC_DEFUN([AX_LIBCSPLIT_CHECK_LOCAL],\n  [dnl No additional checks.\n\n  ac_cv_libcsplit_CPPFLAGS=\"-I../libcsplit\";\n  ac_cv_libcsplit_LIBADD=\"../libcsplit/libcsplit.la\";\n\n  ac_cv_libcsplit=local\n  ])\n\ndnl Function to detect how to enable libcsplit\nAC_DEFUN([AX_LIBCSPLIT_CHECK_ENABLE],\n  [AX_COMMON_ARG_WITH(\n    [libcsplit],\n    [libcsplit],\n    [search for libcsplit in includedir and libdir or in the specified DIR, or no if to use local version],\n    [auto-detect],\n    [DIR])\n\n  dnl Check for a shared library version\n  AX_LIBCSPLIT_CHECK_LIB\n\n  dnl Check if the dependencies for the local library version\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" != xyes],\n    [AX_LIBCSPLIT_CHECK_LOCAL\n\n    AC_DEFINE(\n      [HAVE_LOCAL_LIBCSPLIT],\n      [1],\n      [Define to 1 if the local version of libcsplit is used.])\n    AC_SUBST(\n      [HAVE_LOCAL_LIBCSPLIT],\n      [1])\n    ])\n\n  AM_CONDITIONAL(\n    [HAVE_LOCAL_LIBCSPLIT],\n    [test \"x$ac_cv_libcsplit\" = xlocal])\n  AS_IF(\n    [test \"x$ac_cv_libcsplit_CPPFLAGS\" != \"x\"],\n    [AC_SUBST(\n      [LIBCSPLIT_CPPFLAGS],\n      [$ac_cv_libcsplit_CPPFLAGS])\n    ])\n  AS_IF(\n    [test \"x$ac_cv_libcsplit_LIBADD\" != \"x\"],\n    [AC_SUBST(\n      [LIBCSPLIT_LIBADD],\n      [$ac_cv_libcsplit_LIBADD])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_SUBST(\n      [ax_libcsplit_pc_libs_private],\n      [-lcsplit])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_SUBST(\n      [ax_libcsplit_spec_requires],\n      [libcsplit])\n    AC_SUBST(\n      [ax_libcsplit_spec_build_requires],\n      [libcsplit-devel])\n    ])\n  ])\n\n", "dnl Functions for libfdata\ndnl\ndnl Version: 20170905\n\ndnl Function to detect if libfdata is available\ndnl ac_libfdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\nAC_DEFUN([AX_LIBFDATA_CHECK_LIB],\n  [dnl Check if parameters were provided\n  AS_IF(\n    [test \"x$ac_cv_with_libfdata\" != x && test \"x$ac_cv_with_libfdata\" != xno && test \"x$ac_cv_with_libfdata\" != xauto-detect],\n    [AS_IF(\n      [test -d \"$ac_cv_with_libfdata\"],\n      [CFLAGS=\"$CFLAGS -I${ac_cv_with_libfdata}/include\"\n      LDFLAGS=\"$LDFLAGS -L${ac_cv_with_libfdata}/lib\"],\n      [AC_MSG_WARN([no such directory: $ac_cv_with_libfdata])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_with_libfdata\" = xno],\n    [ac_cv_libfdata=no],\n    [dnl Check for a pkg-config file\n    AS_IF(\n      [test \"x$cross_compiling\" != \"xyes\" && test \"x$PKGCONFIG\" != \"x\"],\n      [PKG_CHECK_MODULES(\n        [libfdata],\n        [libfdata >= 20160325],\n        [ac_cv_libfdata=yes],\n        [ac_cv_libfdata=no])\n      ])\n\n    AS_IF(\n      [test \"x$ac_cv_libfdata\" = xyes],\n      [ac_cv_libfdata_CPPFLAGS=\"$pkg_cv_libfdata_CFLAGS\"\n      ac_cv_libfdata_LIBADD=\"$pkg_cv_libfdata_LIBS\"],\n      [dnl Check for headers\n      AC_CHECK_HEADERS([libfdata.h])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libfdata_h\" = xno],\n        [ac_cv_libfdata=no],\n        [dnl Check for the individual functions\n        ac_cv_libfdata=yes\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_get_version,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Area functions\n        dnl TODO: add functions\n\n        dnl Balanced tree functions\n        dnl TODO: add functions\n\n        dnl List functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_initialize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_free,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_clone,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_empty,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_resize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_reverse,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_number_of_elements,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_list_element_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_prepend_element,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_append_element,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_append_list,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_is_element_set,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_mapped_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_mapped_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_mapped_size_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_mapped_size_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_by_index_with_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_by_index_with_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_append_element_with_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_index_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_list_element_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_cache_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_value_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_value_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_value_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_value_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl List element functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Range list functions\n        dnl TODO: add functions\n\n        dnl Stream functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_initialize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_free,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_clone,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_empty,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_resize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_reverse,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_number_of_segments,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_set_segment_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_prepend_segment,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_append_segment,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_set_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_mapped_range,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_index_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_read_buffer,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_read_buffer_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_write_buffer,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_seek_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Tree list functions\n        dnl TODO: add functions\n\n        dnl Vector list functions\n        dnl TODO: add functions\n\n        ac_cv_libfdata_LIBADD=\"-lfdata\"\n        ])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_DEFINE(\n      [HAVE_LIBFDATA],\n      [1],\n      [Define to 1 if you have the `fdata' library (-lfdata).])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_SUBST(\n      [HAVE_LIBFDATA],\n      [1]) ],\n    [AC_SUBST(\n      [HAVE_LIBFDATA],\n      [0])\n    ])\n  ])\n\ndnl Function to detect if libfdata dependencies are available\nAC_DEFUN([AX_LIBFDATA_CHECK_LOCAL],\n  [dnl No additional checks.\n\n  ac_cv_libfdata_CPPFLAGS=\"-I../libfdata\";\n  ac_cv_libfdata_LIBADD=\"../libfdata/libfdata.la\";\n\n  ac_cv_libfdata=local\n  ])\n\ndnl Function to detect how to enable libfdata\nAC_DEFUN([AX_LIBFDATA_CHECK_ENABLE],\n  [AX_COMMON_ARG_WITH(\n    [libfdata],\n    [libfdata],\n    [search for libfdata in includedir and libdir or in the specified DIR, or no if to use local version],\n    [auto-detect],\n    [DIR])\n\n  dnl Check for a shared library version\n  AX_LIBFDATA_CHECK_LIB\n\n  dnl Check if the dependencies for the local library version\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" != xyes],\n    [AX_LIBFDATA_CHECK_LOCAL\n\n    AC_DEFINE(\n      [HAVE_LOCAL_LIBFDATA],\n      [1],\n      [Define to 1 if the local version of libfdata is used.])\n    AC_SUBST(\n      [HAVE_LOCAL_LIBFDATA],\n      [1])\n    ])\n\n  AM_CONDITIONAL(\n    [HAVE_LOCAL_LIBFDATA],\n    [test \"x$ac_cv_libfdata\" = xlocal])\n  AS_IF(\n    [test \"x$ac_cv_libfdata_CPPFLAGS\" != \"x\"],\n    [AC_SUBST(\n      [LIBFDATA_CPPFLAGS],\n      [$ac_cv_libfdata_CPPFLAGS])\n    ])\n  AS_IF(\n    [test \"x$ac_cv_libfdata_LIBADD\" != \"x\"],\n    [AC_SUBST(\n      [LIBFDATA_LIBADD],\n      [$ac_cv_libfdata_LIBADD])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_SUBST(\n      [ax_libfdata_pc_libs_private],\n      [-lfdata])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_SUBST(\n      [ax_libfdata_spec_requires],\n      [libfdata])\n    AC_SUBST(\n      [ax_libfdata_spec_build_requires],\n      [libfdata-devel])\n    ])\n  ])\n", "#!/bin/bash\n# Script that runs the tests\n#\n# Version: 20171210\n\nEXIT_SUCCESS=0;\nEXIT_FAILURE=1;\n\nrun_configure_make()\n{\n\tlocal CONFIGURE_OPTIONS=$@;\n\n\t./configure ${CONFIGURE_OPTIONS[@]};\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: './configure' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\n\tmake clean > /dev/null;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make clean' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\n\tmake > /dev/null;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nrun_configure_make_check()\n{\n\trun_configure_make $@;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\treturn ${RESULT};\n\tfi\n\n\tmake check CHECK_WITH_STDERR=1;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make check' failed\";\n\n\t\tif test -f tests/test-suite.log;\n\t\tthen\n\t\t\tcat tests/test-suite.log;\n\t\tfi\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nrun_configure_make_check_with_asan()\n{\n\tlocal LDCONFIG=`which ldconfig 2> /dev/null`;\n\n\tif test -z ${LDCONFIG} || test ! -x ${LDCONFIG};\n\tthen\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\tlocal LIBASAN=`ldconfig -p | grep libasan | sed 's/^.* => //'`;\n\n\tif test -z ${LIBASAN} || test ! -f ${LIBASAN};\n\tthen\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\t# Using libasan is platform dependent.\n\tif test ${LIBASAN} != \"/lib64/libasan.so.4\";\n\tthen\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\n\texport CPPFLAGS=\"-DHAVE_ASAN\";\n\texport CFLAGS=\"-fno-omit-frame-pointer -fsanitize=address -g\";\n\texport LDFLAGS=\"-fsanitize=address -g\";\n\n\tif test -z ${CC} || test ${CC} != \"clang\";\n\tthen\n\t\tLDFLAGS=\"${LDFLAGS} -lasan\";\n\tfi\n\n\trun_configure_make $@;\n\tRESULT=$?;\n\n\texport CPPFLAGS=;\n\texport CFLAGS=;\n\texport LDFLAGS=;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\treturn ${RESULT};\n\tfi\n\n\tmake check CHECK_WITH_ASAN=1 CHECK_WITH_STDERR=1;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make check' failed\";\n\n\t\tif test -f tests/test-suite.log;\n\t\tthen\n\t\t\tcat tests/test-suite.log;\n\t\tfi\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${RESULT};\n}\n\nrun_configure_make_check_with_coverage()\n{\n\t# Disable optimization so we can hook malloc and realloc.\n\texport CPPFLAGS=\"-DOPTIMIZATION_DISABLED\";\n\texport CFLAGS=\"--coverage -O0\";\n\texport LDFLAGS=\"--coverage\";\n\n\t# Disable creating a shared library so we can hook memset.\n\trun_configure_make_check $@;\n\tRESULT=$?;\n\n\texport CPPFLAGS=;\n\texport CFLAGS=;\n\texport LDFLAGS=;\n\n\treturn ${RESULT};\n}\n\nrun_configure_make_check_python()\n{\n\trun_configure_make $@;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\treturn ${RESULT};\n\tfi\n\n\tmake check CHECK_WITH_STDERR=1 SKIP_LIBRARY_TESTS=1 SKIP_TOOLS_TESTS=1;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make check' failed\";\n\n\t\tif test -f tests/test-suite.log;\n\t\tthen\n\t\t\tcat tests/test-suite.log;\n\t\tfi\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nrun_setup_py_tests()\n{\n\t# Skip this test when running Cygwin on AppVeyor.\n\tif test -n \"${APPVEYOR}\" && test ${TARGET} = \"cygwin\";\n\tthen\n\t\techo \"Running: 'setup.py build' skipped\";\n\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\tPYTHON=$1;\n\n\t${PYTHON} setup.py build;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'setup.py build' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nCONFIGURE_HELP=`./configure --help`;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--enable-wide-character-type' > /dev/null;\n\nHAVE_ENABLE_WIDE_CHARACTER_TYPE=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--with-zlib' > /dev/null;\n\nHAVE_WITH_ZLIB=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--with-openssl' > /dev/null;\n\nHAVE_WITH_OPENSSL=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--enable-python' > /dev/null;\n\nHAVE_ENABLE_PYTHON=$?;\n\nPYTHON_CONFIG=\"\";\n\nif test -x /usr/bin/whereis;\nthen\n\tPYTHON_CONFIG=`/usr/bin/whereis python-config | sed 's/^.*:[ ]*//' 2> /dev/null`;\nfi\n\n# Test \"./configure && make && make check\" without options.\n\nrun_configure_make_check;\nRESULT=$?;\n\nif test ${RESULT} -ne ${EXIT_SUCCESS};\nthen\n\texit ${EXIT_FAILURE};\nfi\n\nif test ${HAVE_WITH_ZLIB} -eq 0;\nthen\n\t# Test \"./configure && make && make check\" with fallback zlib implementation.\n\n\trun_configure_make_check \"--with-zlib=no\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\nfi\n\nif test ${HAVE_WITH_OPENSSL} -eq 0;\nthen\n\t# Test \"./configure && make && make check\" with fallback crypto implementation.\n\n\trun_configure_make_check \"--with-openssl=no\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\n\n\t# Test \"./configure && make && make check\" with non-EVP openssl implementation.\n\n\trun_configure_make_check \"--enable-openssl-evp-cipher=no --enable-openssl-evp-md=no\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\nfi\n\nif test ${HAVE_ENABLE_PYTHON} -eq 0 && test -n \"${PYTHON_CONFIG}\";\nthen\n\t# Test with Python 2.\n\tPYTHON2=`which python2 2> /dev/null`;\n\n        # Note that \"test -x\" on Mac OS X will succeed if the argument is not set.\n\tif test -n \"${PYTHON2}\" && test -x ${PYTHON2};\n\tthen\n\t\texport PYTHON_VERSION=2;\n\n\t\trun_configure_make_check_python \"--enable-python\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\t\texport PYTHON_VERSION=;\n\n\t\trun_configure_make \"--enable-python2\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\n\t\tif test -f \"setup.py\" && ! run_setup_py_tests ${PYTHON2};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\tfi\n\n\t# Test with Python 3.\n\tPYTHON3=`which python3 2> /dev/null`;\n\n        # Note that \"test -x\" on Mac OS X will succeed if the argument is not set.\n\tif test -n \"${PYTHON3}\" && test -x ${PYTHON3};\n\tthen\n\t\texport PYTHON_VERSION=3;\n\n\t\trun_configure_make_check_python \"--enable-python\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\t\texport PYTHON_VERSION=;\n\n\t\trun_configure_make \"--enable-python3\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\n\t\tif test -f \"setup.py\" && ! run_setup_py_tests ${PYTHON3};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\tfi\n\n\t# Test with the default Python version.\n\tif test -z ${PYTHON2} && test -z ${PYTHON3};\n\tthen\n\t\trun_configure_make_check_python \"--enable-python\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\n\t\tPYTHON=`which python 2> /dev/null`;\n\n\t\tif test -f \"setup.py\" && ! run_setup_py_tests ${PYTHON};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\tfi\nfi\n\nCONFIGURE_OPTIONS=\"\";\n\nif test ${HAVE_ENABLE_PYTHON} -eq 0 && test -n \"${PYTHON_CONFIG}\";\nthen\n\t# Issue with running the python bindings with asan disabled for now.\n\t# CONFIGURE_OPTIONS=\"${CONFIGURE_OPTIONS} --enable-python\";\n\tCONFIGURE_OPTIONS=\"${CONFIGURE_OPTIONS}\";\nfi\n\nrun_configure_make_check_with_asan ${CONFIGURE_OPTIONS};\nRESULT=$?;\n\nif test ${RESULT} -ne ${EXIT_SUCCESS};\nthen\n\texit ${EXIT_FAILURE};\nfi\n\nCONFIGURE_OPTIONS=\"--enable-shared=no\";\n\nif test ${HAVE_ENABLE_WIDE_CHARACTER_TYPE} -eq 0;\nthen\n\tCONFIGURE_OPTIONS=\"${CONFIGURE_OPTIONS} --enable-wide-character-type\";\nfi\n\nrun_configure_make_check_with_coverage ${CONFIGURE_OPTIONS};\nRESULT=$?;\n\nif test ${RESULT} -ne ${EXIT_SUCCESS};\nthen\n\texit ${EXIT_FAILURE};\nfi\n\nexit ${EXIT_SUCCESS};\n\n"], "fixing_code": ["AC_PREREQ( 2.59 )\n\nAC_INIT(\n [libevt],\n [20180317],\n [joachim.metz@gmail.com])\n\nAC_CONFIG_SRCDIR(\n [include/libevt.h.in])\n\nAM_INIT_AUTOMAKE([gnu 1.6 tar-ustar])\n\nAC_CONFIG_MACRO_DIR([m4])\n\ndnl Check for host type\nAC_CANONICAL_HOST\n\ndnl Check for libtool DLL support\nAC_LIBTOOL_WIN32_DLL\n\ndnl Checks for programs\nAC_PROG_CC\nAC_PROG_GCC_TRADITIONAL\nAC_PROG_MAKE_SET\nAC_PROG_INSTALL\n\ndnl Check for libtool\nAC_PROG_LIBTOOL\nAC_SUBST(LIBTOOL_DEPS)\n\ndnl Check for pkg-config\nAC_PATH_PROG(PKGCONFIG,[pkg-config])\n\ndnl Support of internationalization (i18n)\nAM_GNU_GETTEXT([external])\nAM_GNU_GETTEXT_VERSION([0.18.1])\n\ndnl Check for compiler language support\nAC_C_CONST\nAC_C_VOLATILE\n\ndnl Check for large file support\nAC_SYS_LARGEFILE\n\ndnl Check if WINAPI support should be enabled\nAX_COMMON_CHECK_ENABLE_WINAPI\n\ndnl Check if wide character type should be enabled\nAX_COMMON_CHECK_ENABLE_WIDE_CHARACTER_TYPE\n\ndnl Check if verbose output should be enabled\nAX_COMMON_CHECK_ENABLE_VERBOSE_OUTPUT\n\ndnl Check if debug output should be enabled\nAX_COMMON_CHECK_ENABLE_DEBUG_OUTPUT\n\ndnl Check for type definitions\nAX_TYPES_CHECK_LOCAL\n\ndnl Check if common required headers and functions are available\nAX_COMMON_CHECK_LOCAL\n\ndnl Check if libcerror or required headers and functions are available\nAX_LIBCERROR_CHECK_ENABLE\n\ndnl Check if libcthreads or required headers and functions are available\nAX_LIBCTHREADS_CHECK_ENABLE\n\ndnl Check if libcdata or required headers and functions are available\nAX_LIBCDATA_CHECK_ENABLE\n\ndnl Check if libclocale or required headers and functions are available\nAX_LIBCLOCALE_CHECK_ENABLE\n\ndnl Check if libcnotify or required headers and functions are available\nAX_LIBCNOTIFY_CHECK_ENABLE\n\ndnl Check if libcsplit or required headers and functions are available\nAX_LIBCSPLIT_CHECK_ENABLE\n\ndnl Check if libuna or required headers and functions are available\nAX_LIBUNA_CHECK_ENABLE\n\ndnl Check if libcfile or required headers and functions are available\nAX_LIBCFILE_CHECK_ENABLE\n\ndnl Check if libcpath or required headers and functions are available\nAX_LIBCPATH_CHECK_ENABLE\n\ndnl Check if libbfio or required headers and functions are available\nAX_LIBBFIO_CHECK_ENABLE\n\ndnl Check if libfcache or required headers and functions are available\nAX_LIBFCACHE_CHECK_ENABLE\n\ndnl Check if libfdata or required headers and functions are available\nAX_LIBFDATA_CHECK_ENABLE\n\ndnl Check if libfdatetime or required headers and functions are available\nAX_LIBFDATETIME_CHECK_ENABLE\n\ndnl Check if libfguid or required headers and functions are available\nAX_LIBFGUID_CHECK_ENABLE\n\ndnl Check if libfvalue or required headers and functions are available\nAX_LIBFVALUE_CHECK_ENABLE\n\ndnl Check if libfwnt or required headers and functions are available\nAX_LIBFWNT_CHECK_ENABLE\n\ndnl Check if libevt required headers and functions are available\nAX_LIBEVT_CHECK_LOCAL\n\ndnl Check if libevt Python bindings (pyevt) required headers and functions are available\nAX_PYTHON_CHECK_PYPREFIX\nAX_PYTHON_CHECK_ENABLE\nAX_PYTHON2_CHECK_ENABLE\nAX_PYTHON3_CHECK_ENABLE\n\nAS_IF(\n  [test \"x${ac_cv_enable_python}\" != xno || test \"x${ac_cv_enable_python2}\" != xno || test \"x${ac_cv_enable_python3}\" != xno],\n  [dnl Headers included in pyevt/pyevt_error.c\n  AC_CHECK_HEADERS([stdarg.h varargs.h])\n\n  AS_IF(\n    [test \"x$ac_cv_header_stdarg_h\" != xyes && test \"x$ac_cv_header_varargs_h\" != xyes],\n    [AC_MSG_FAILURE(\n      [Missing headers: stdarg.h and varargs.h],\n      [1])\n    ])\n  ])\n\nAM_CONDITIONAL(\n  HAVE_PYTHON_TESTS,\n  [test \"x${ac_cv_enable_python}\" != xno || test \"x${ac_cv_enable_python2}\" != xno || test \"x${ac_cv_enable_python3}\" != xno])\n\ndnl Check if libfwevt or required headers and functions are available\nAX_LIBFWEVT_CHECK_ENABLE\n\ndnl Check if libexe or required headers and functions are available\nAX_LIBEXE_CHECK_ENABLE\n\ndnl Check if libregf or required headers and functions are available\nAX_LIBREGF_CHECK_ENABLE\n\ndnl Check if libwrc or required headers and functions are available\nAX_LIBWRC_CHECK_ENABLE\n\ndnl Check if libcdirectory or required headers and functions are available\nAX_LIBCDIRECTORY_CHECK_ENABLE\n\ndnl Check if evttools required headers and functions are available\nAX_EVTTOOLS_CHECK_LOCAL\n\ndnl Check if tests required headers and functions are available\nAX_TESTS_CHECK_LOCAL\n\ndnl Check if DLL support is needed\nAS_IF(\n [test \"x$enable_shared\" = xyes],\n [AS_CASE(\n  [$host],\n  [*cygwin* | *mingw*],\n  [AC_DEFINE(\n   [HAVE_DLLMAIN],\n   [1],\n   [Define to 1 to enable the DllMain function.])\n  AC_SUBST(\n   [HAVE_DLLMAIN],\n   [1])\n\n  dnl Used in tests\n  AC_SUBST(\n   [LIBEVT_DLL_IMPORT],\n   [\"-DLIBEVT_DLL_IMPORT\"])\n  ])\n ])\n\ndnl Set additional compiler flags\nCFLAGS=\"$CFLAGS -Wall\";\n\ndnl Check if requires and build requires should be set in spec file\nAS_IF(\n [test \"x$ac_cv_libcerror\" = xyes || test \"x$ac_cv_libcthreads\" = xyes || test \"x$ac_cv_libcdata\" = xyes || test \"x$ac_cv_libclocale\" = xyes || test \"x$ac_cv_libcnotify\" = xyes || test \"x$ac_cv_libcsplit\" = xyes || test \"x$ac_cv_libuna\" = xyes || test \"x$ac_cv_libcfile\" = xyes || test \"x$ac_cv_libcpath\" = xyes || test \"x$ac_cv_libbfio\" = xyes || test \"x$ac_cv_libfcache\" = xyes || test \"x$ac_cv_libfdata\" = xyes || test \"x$ac_cv_libfdatetime\" = xyes || test \"x$ac_cv_libfguid\" = xyes || test \"x$ac_cv_libfvalue\" = xyes || test \"x$ac_cv_libfwnt\" = xyes],\n [AC_SUBST(\n  [libevt_spec_requires],\n  [Requires:])\n AC_SUBST(\n  [libevt_spec_build_requires],\n  [BuildRequires:])\n ])\n\nAS_IF(\n [test \"x$ac_cv_libfwevt\" = xyes || test \"x$ac_cv_libexe\" = xyes || test \"x$ac_cv_libregf\" = xyes || test \"x$ac_cv_libwrc\" = xyes || test \"x$ac_cv_libcdirectory\" = xyes],\n [AC_SUBST(\n  [libevt_spec_tools_build_requires],\n  [BuildRequires:])\n ])\n\ndnl Set the date for the dpkg files\nAC_SUBST(\n [DPKG_DATE],\n [`date -R 2> /dev/null`])\n\ndnl Set the date for the spec file\nAC_SUBST(\n [SPEC_DATE],\n [`date +\"%a %b %e %Y\" 2> /dev/null`])\n\ndnl Generate Makefiles\nAC_CONFIG_FILES([Makefile])\nAC_CONFIG_FILES([include/Makefile])\nAC_CONFIG_FILES([common/Makefile])\nAC_CONFIG_FILES([libcerror/Makefile])\nAC_CONFIG_FILES([libcthreads/Makefile])\nAC_CONFIG_FILES([libcdata/Makefile])\nAC_CONFIG_FILES([libclocale/Makefile])\nAC_CONFIG_FILES([libcnotify/Makefile])\nAC_CONFIG_FILES([libcsplit/Makefile])\nAC_CONFIG_FILES([libuna/Makefile])\nAC_CONFIG_FILES([libcfile/Makefile])\nAC_CONFIG_FILES([libcpath/Makefile])\nAC_CONFIG_FILES([libbfio/Makefile])\nAC_CONFIG_FILES([libfcache/Makefile])\nAC_CONFIG_FILES([libfdata/Makefile])\nAC_CONFIG_FILES([libfdatetime/Makefile])\nAC_CONFIG_FILES([libfguid/Makefile])\nAC_CONFIG_FILES([libfvalue/Makefile])\nAC_CONFIG_FILES([libfwnt/Makefile])\nAC_CONFIG_FILES([libevt/Makefile])\nAC_CONFIG_FILES([pyevt/Makefile])\nAC_CONFIG_FILES([pyevt-python2/Makefile])\nAC_CONFIG_FILES([pyevt-python3/Makefile])\nAC_CONFIG_FILES([libfwevt/Makefile])\nAC_CONFIG_FILES([libexe/Makefile])\nAC_CONFIG_FILES([libregf/Makefile])\nAC_CONFIG_FILES([libwrc/Makefile])\nAC_CONFIG_FILES([libcdirectory/Makefile])\nAC_CONFIG_FILES([evttools/Makefile])\nAC_CONFIG_FILES([po/Makefile.in])\nAC_CONFIG_FILES([po/Makevars])\nAC_CONFIG_FILES([manuals/Makefile])\nAC_CONFIG_FILES([tests/Makefile])\nAC_CONFIG_FILES([msvscpp/Makefile])\ndnl Generate header files\nAC_CONFIG_FILES([include/libevt.h])\nAC_CONFIG_FILES([include/libevt/definitions.h])\nAC_CONFIG_FILES([include/libevt/features.h])\nAC_CONFIG_FILES([include/libevt/types.h])\nAC_CONFIG_FILES([libevt/libevt_definitions.h])\ndnl Generate distribution specific files\nAC_CONFIG_FILES([common/types.h])\nAC_CONFIG_FILES([dpkg/changelog])\nAC_CONFIG_FILES([libevt/libevt.rc])\nAC_CONFIG_FILES([libevt.pc])\nAC_CONFIG_FILES([libevt.spec])\ndnl Generate a source configuration file\nAC_CONFIG_HEADERS([common/config.h])\n\nAC_OUTPUT\n\ndnl Print a summary\nAC_MSG_NOTICE([\nBuilding:\n   libcerror support:                        $ac_cv_libcerror\n   libcthreads support:                      $ac_cv_libcthreads\n   libcdata support:                         $ac_cv_libcdata\n   libclocale support:                       $ac_cv_libclocale\n   libcnotify support:                       $ac_cv_libcnotify\n   libcsplit support:                        $ac_cv_libcsplit\n   libuna support:                           $ac_cv_libuna\n   libcfile support:                         $ac_cv_libcfile\n   libcpath support:                         $ac_cv_libcpath\n   libbfio support:                          $ac_cv_libbfio\n   libfcache support:                        $ac_cv_libfcache\n   libfdata support:                         $ac_cv_libfdata\n   libfdatetime support:                     $ac_cv_libfdatetime\n   libfguid support:                         $ac_cv_libfguid\n   libfvalue support:                        $ac_cv_libfvalue\n   libfwnt support:                          $ac_cv_libfwnt\n   libfwevt support:                         $ac_cv_libfwevt\n   libexe support:                           $ac_cv_libexe\n   libregf support:                          $ac_cv_libregf\n   libwrc support:                           $ac_cv_libwrc\n   libcdirectory support:                    $ac_cv_libcdirectory\n\nFeatures:\n   Multi-threading support:                  $ac_cv_libcthreads_multi_threading\n   Wide character type support:              $ac_cv_enable_wide_character_type\n   evttools are build as static executables: $ac_cv_enable_static_executables\n   Python (pyevt) support:                   $ac_cv_enable_python\n   Python version 2 (pyevt) support:         $ac_cv_enable_python2\n   Python version 3 (pyevt) support:         $ac_cv_enable_python3\n   Verbose output:                           $ac_cv_enable_verbose_output\n   Debug output:                             $ac_cv_enable_debug_output\n]);\n\n", "<?xml version=\"1.0\"?>\r\n<package >\r\n  <metadata>\r\n    <id>libevt</id>\r\n    <version>20180317</version>\r\n    <authors>Joachim Metz</authors>\r\n    <owners>joachimmetz</owners>\r\n    <licenseUrl>https://raw.githubusercontent.com/libyal/libevt/master/COPYING</licenseUrl>\r\n    <projectUrl>https://github.com/libyal/libevt</projectUrl>\r\n    <requireLicenseAcceptance>false</requireLicenseAcceptance>\r\n    <title>libevt</title>\r\n    <description>Library to access the Windows Event Log (EVT) format</description>\r\n    <releaseNotes>Release of libevt 20180317</releaseNotes>\r\n    <copyright>Copyright (C) 2011-2018</copyright>\r\n    <tags>native</tags>\r\n  </metadata>\r\n  <files>\r\n    <file src=\"include\\*.h\" target=\"lib\\native\\include\\\" />\r\n    <file src=\"include\\libevt\\*.h\" target=\"lib\\native\\include\\libevt\\\" />\r\n    <file src=\"msvscpp\\Release\\Win32\\libevt.dll\" target=\"lib\\native\\lib\\Win32\\\" />\r\n    <file src=\"msvscpp\\Release\\Win32\\libevt.lib\" target=\"lib\\native\\lib\\Win32\\\" />\r\n    <file src=\"msvscpp\\Release\\Win32\\libevt.pdb\" target=\"lib\\native\\lib\\Win32\\\" />\r\n    <file src=\"msvscpp\\Release\\x64\\libevt.dll\" target=\"lib\\native\\lib\\x64\\\" />\r\n    <file src=\"msvscpp\\Release\\x64\\libevt.lib\" target=\"lib\\native\\lib\\x64\\\" />\r\n    <file src=\"msvscpp\\Release\\x64\\libevt.pdb\" target=\"lib\\native\\lib\\x64\\\" />\r\n  </files>\r\n</package>\r\n", "/*\n * The libfvalue header wrapper\n *\n * Copyright (C) 2011-2018, Joachim Metz <joachim.metz@gmail.com>\n *\n * Refer to AUTHORS for acknowledgements.\n *\n * This software is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this software.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#if !defined( _LIBEVT_LIBFVALUE_H )\n#define _LIBEVT_LIBFVALUE_H\n\n#include <common.h>\n\n/* Define HAVE_LOCAL_LIBFVALUE for local use of libfvalue\n */\n#if defined( HAVE_LOCAL_LIBFVALUE )\n\n#include <libfvalue_codepage.h>\n#include <libfvalue_data_handle.h>\n#include <libfvalue_definitions.h>\n#include <libfvalue_floating_point.h>\n#include <libfvalue_integer.h>\n#include <libfvalue_split_utf16_string.h>\n#include <libfvalue_split_utf8_string.h>\n#include <libfvalue_string.h>\n#include <libfvalue_table.h>\n#include <libfvalue_types.h>\n#include <libfvalue_value.h>\n#include <libfvalue_value_type.h>\n#include <libfvalue_utf16_string.h>\n#include <libfvalue_utf8_string.h>\n\n#else\n\n/* If libtool DLL support is enabled set LIBFVALUE_DLL_IMPORT\n * before including libfvalue.h\n */\n#if defined( _WIN32 ) && defined( DLL_IMPORT )\n#define LIBFVALUE_DLL_IMPORT\n#endif\n\n#include <libfvalue.h>\n\n#endif /* defined( HAVE_LOCAL_LIBFVALUE ) */\n\n#endif /* !defined( _LIBEVT_LIBFVALUE_H ) */\n\n", "/*\n * Record values functions\n *\n * Copyright (C) 2011-2018, Joachim Metz <joachim.metz@gmail.com>\n *\n * Refer to AUTHORS for acknowledgements.\n *\n * This software is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this software.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <common.h>\n#include <byte_stream.h>\n#include <memory.h>\n#include <system_string.h>\n#include <types.h>\n\n#include \"libevt_debug.h\"\n#include \"libevt_io_handle.h\"\n#include \"libevt_libbfio.h\"\n#include \"libevt_libcerror.h\"\n#include \"libevt_libcnotify.h\"\n#include \"libevt_libfdatetime.h\"\n#include \"libevt_libfvalue.h\"\n#include \"libevt_libfwnt.h\"\n#include \"libevt_record_values.h\"\n#include \"libevt_unused.h\"\n\n#include \"evt_file_header.h\"\n#include \"evt_record.h\"\n\nconst uint8_t evt_end_of_file_record_signature1[ 4 ] = { 0x11, 0x11, 0x11, 0x11 };\nconst uint8_t evt_end_of_file_record_signature2[ 4 ] = { 0x22, 0x22, 0x22, 0x22 };\nconst uint8_t evt_end_of_file_record_signature3[ 4 ] = { 0x33, 0x33, 0x33, 0x33 };\nconst uint8_t evt_end_of_file_record_signature4[ 4 ] = { 0x44, 0x44, 0x44, 0x44 };\n\n/* Creates record values\n * Make sure the value record_values is referencing, is set to NULL\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_initialize(\n     libevt_record_values_t **record_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_initialize\";\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *record_values != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid record values value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*record_values = memory_allocate_structure(\n\t                  libevt_record_values_t );\n\n\tif( *record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_set(\n\t     *record_values,\n\t     0,\n\t     sizeof( libevt_record_values_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_SET_FAILED,\n\t\t \"%s: unable to clear record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *record_values != NULL )\n\t{\n\t\tmemory_free(\n\t\t *record_values );\n\n\t\t*record_values = NULL;\n\t}\n\treturn( -1 );\n}\n\n/* Frees record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_free(\n     libevt_record_values_t **record_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_free\";\n\tint result            = 1;\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *record_values != NULL )\n\t{\n\t\tif( ( *record_values )->source_name != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->source_name ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free source name value.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->computer_name != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->computer_name ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free computer name value.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->user_security_identifier != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->user_security_identifier ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free user security identifier (SID).\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->strings != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->strings ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free strings.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tif( ( *record_values )->data != NULL )\n\t\t{\n\t\t\tif( libfvalue_value_free(\n\t\t\t     &( ( *record_values )->data ),\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_FINALIZE_FAILED,\n\t\t\t\t \"%s: unable to free data.\",\n\t\t\t\t function );\n\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\tmemory_free(\n\t\t *record_values );\n\n\t\t*record_values = NULL;\n\t}\n\treturn( result );\n}\n\n/* Clones the record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_clone(\n     libevt_record_values_t **destination_record_values,\n     libevt_record_values_t *source_record_values,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_clone\";\n\n\tif( destination_record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid destination record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( *destination_record_values != NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_ALREADY_SET,\n\t\t \"%s: invalid destination record values value already set.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( source_record_values == NULL )\n\t{\n\t\t*destination_record_values = NULL;\n\n\t\treturn( 1 );\n\t}\n\t*destination_record_values = memory_allocate_structure(\n\t                              libevt_record_values_t );\n\n\tif( *destination_record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create destination record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( memory_copy(\n\t     *destination_record_values,\n\t     source_record_values,\n\t     sizeof( libevt_record_values_t ) ) == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_COPY_FAILED,\n\t\t \"%s: unable to copy source to destination record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( *destination_record_values != NULL )\n\t{\n\t\tmemory_free(\n\t\t *destination_record_values );\n\n\t\t*destination_record_values = NULL;\n\t}\n\treturn( -1 );\n}\n\n/* Reads a record_values\n * Returns the number of bytes read if successful or -1 on error\n */\nssize_t libevt_record_values_read(\n         libevt_record_values_t *record_values,\n         libbfio_handle_t *file_io_handle,\n         libevt_io_handle_t *io_handle,\n         off64_t *file_offset,\n         uint8_t strict_mode,\n         libcerror_error_t **error )\n{\n\tuint8_t record_size_data[ 4 ];\n\n\tuint8_t *record_data      = NULL;\n\tstatic char *function     = \"libevt_record_values_read\";\n\tsize_t read_size          = 0;\n\tsize_t record_data_offset = 0;\n\tssize_t read_count        = 0;\n\tssize_t total_read_count  = 0;\n\tuint32_t record_data_size = 0;\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( io_handle == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid IO handle.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( file_offset == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid file offset.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\trecord_values->offset = *file_offset;\n\n\tread_count = libbfio_handle_read_buffer(\n\t              file_io_handle,\n\t              record_size_data,\n\t              sizeof( uint32_t ),\n\t              error );\n\n\tif( read_count != (ssize_t) sizeof( uint32_t ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t \"%s: unable to read record size data.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t*file_offset    += read_count;\n\ttotal_read_count = read_count;\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t record_size_data,\n\t record_data_size );\n\n\tif( record_data_size < 4 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#if SIZEOF_SIZE_T <= 4\n\tif( (size_t) record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n#endif\n\t/* Allocating record data as 4 bytes and then using realloc here\n\t * corrupts the memory\n\t */\n\trecord_data = (uint8_t *) memory_allocate(\n\t                           sizeof( uint8_t ) * record_data_size );\n\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_MEMORY,\n\t\t LIBCERROR_MEMORY_ERROR_INSUFFICIENT,\n\t\t \"%s: unable to create record data.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tbyte_stream_copy_from_uint32_little_endian(\n\t record_data,\n\t record_data_size );\n\n\trecord_data_offset = 4;\n\n\tread_size = record_data_size - record_data_offset;\n\n\tif( ( (size64_t) *file_offset + read_size ) > io_handle->file_size )\n\t{\n\t\tread_size = (size_t) ( io_handle->file_size - *file_offset );\n\t}\n\tread_count = libbfio_handle_read_buffer(\n\t              file_io_handle,\n\t              &( record_data[ record_data_offset ] ),\n\t              read_size,\n\t              error );\n\n\tif( read_count != (ssize_t) read_size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t \"%s: unable to read record data.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t*file_offset       += read_count;\n\trecord_data_offset += read_count;\n\ttotal_read_count   += read_count;\n\n\tif( record_data_offset < (size_t) record_data_size )\n\t{\n\t\tif( libbfio_handle_seek_offset(\n\t\t     file_io_handle,\n\t\t     (off64_t) sizeof( evt_file_header_t ),\n\t\t     SEEK_SET,\n\t\t     error ) == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_SEEK_FAILED,\n\t\t\t \"%s: unable to seek file header offset: %\" PRIzd \".\",\n\t\t\t function,\n\t\t\t sizeof( evt_file_header_t ) );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\t*file_offset = (off64_t) sizeof( evt_file_header_t );\n\n\t\tread_size = (size_t) record_data_size - record_data_offset;\n\n\t\tread_count = libbfio_handle_read_buffer(\n\t\t              file_io_handle,\n\t\t              &( record_data[ record_data_offset ] ),\n\t\t              read_size,\n\t\t              error );\n\n\t\tif( read_count != (ssize_t) read_size )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t\t \"%s: unable to read record data.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\t*file_offset     += read_count;\n\t\ttotal_read_count += read_count;\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: record data:\\n\",\n\t\t function );\n\t\tlibcnotify_print_data(\n\t\t record_data,\n\t\t (size_t) record_data_size,\n\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t}\n#endif\n\tif( memory_compare(\n\t     &( record_data[ 4 ] ),\n\t     evt_file_signature,\n\t     4 ) == 0 )\n\t{\n\t\trecord_values->type = LIBEVT_RECORD_TYPE_EVENT;\n\t}\n\telse if( memory_compare(\n\t          &( record_data[ 4 ] ),\n\t          evt_end_of_file_record_signature1,\n\t          4 ) == 0 )\n\t{\n\t\trecord_values->type = LIBEVT_RECORD_TYPE_END_OF_FILE;\n\t}\n\telse\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_UNSUPPORTED_VALUE,\n\t\t \"%s: unsupported record values signature.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( record_values->type == LIBEVT_RECORD_TYPE_EVENT )\n\t{\n\t\tif( libevt_record_values_read_event(\n\t\t     record_values,\n\t\t     record_data,\n\t\t     (size_t) record_data_size,\n\t\t     strict_mode,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t\t \"%s: unable to read event record values.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\telse if( record_values->type == LIBEVT_RECORD_TYPE_END_OF_FILE )\n\t{\n\t\tif( libevt_record_values_read_end_of_file(\n\t\t     record_values,\n\t\t     record_data,\n\t\t     (size_t) record_data_size,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t\t \"%s: unable to read end of file record values.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tmemory_free(\n\t record_data );\n\n\treturn( total_read_count );\n\non_error:\n\tif( record_data != NULL )\n\t{\n\t\tmemory_free(\n\t\t record_data );\n\t}\n\treturn( -1 );\n}\n\n/* Reads the event record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_read_event(\n     libevt_record_values_t *record_values,\n     uint8_t *record_data,\n     size_t record_data_size,\n     uint8_t strict_mode,\n     libcerror_error_t **error )\n{\n\tstatic char *function      = \"libevt_record_values_read_event\";\n\tsize_t record_data_offset  = 0;\n\tsize_t strings_data_offset = 0;\n\tssize_t value_data_size    = 0;\n\tuint32_t data_offset       = 0;\n\tuint32_t data_size         = 0;\n\tuint32_t members_data_size = 0;\n\tuint32_t size              = 0;\n\tuint32_t size_copy         = 0;\n\tuint32_t strings_offset    = 0;\n\tuint32_t strings_size      = 0;\n\tuint32_t user_sid_offset   = 0;\n\tuint32_t user_sid_size     = 0;\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tuint32_t value_32bit       = 0;\n\tuint16_t value_16bit       = 0;\n#endif\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size < ( sizeof( evt_record_event_header_t ) + 4 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->size,\n\t size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->record_number,\n\t record_values->number );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->creation_time,\n\t record_values->creation_time );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->written_time,\n\t record_values->written_time );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_identifier,\n\t record_values->event_identifier );\n\n\tbyte_stream_copy_to_uint16_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_type,\n\t record_values->event_type );\n\n\tbyte_stream_copy_to_uint16_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->event_category,\n\t record_values->event_category );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->strings_offset,\n\t strings_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->user_sid_size,\n\t user_sid_size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->user_sid_offset,\n\t user_sid_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->data_size,\n\t data_size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_event_header_t *) record_data )->data_offset,\n\t data_offset );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t &( record_data[ record_data_size - 4 ] ),\n\t size_copy );\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: size\\t\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: signature\\t\\t\\t\\t: %c%c%c%c\\n\",\n\t\t function,\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 0 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 1 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 2 ],\n\t\t ( (evt_record_event_header_t *) record_data )->signature[ 3 ] );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: record number\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t record_values->number );\n\n\t\tif( libevt_debug_print_posix_time_value(\n\t\t     function,\n\t\t     \"creation time\\t\\t\\t\\t\",\n\t\t     ( (evt_record_event_header_t *) record_data )->creation_time,\n\t\t     4,\n\t\t     LIBFDATETIME_ENDIAN_LITTLE,\n\t\t     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,\n\t\t     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t \"%s: unable to print POSIX time value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libevt_debug_print_posix_time_value(\n\t\t     function,\n\t\t     \"written time\\t\\t\\t\\t\",\n\t\t     ( (evt_record_event_header_t *) record_data )->written_time,\n\t\t     4,\n\t\t     LIBFDATETIME_ENDIAN_LITTLE,\n\t\t     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,\n\t\t     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t \"%s: unable to print POSIX time value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t record_values->event_identifier );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: code\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t record_values->event_identifier & 0x0000ffffUL );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: facility\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x0fff0000UL ) >> 16 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: reserved\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x10000000UL ) >> 28 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: customer flags\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0x20000000UL ) >> 29 );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event identifier: severity\\t\\t: %\" PRIu32 \" (\",\n\t\t function,\n\t\t ( record_values->event_identifier & 0xc0000000UL ) >> 30 );\n\t\tlibevt_debug_print_event_identifier_severity(\n\t\t record_values->event_identifier );\n\t\tlibcnotify_printf(\n\t\t \")\\n\" );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event type\\t\\t\\t\\t: %\" PRIu16 \" (\",\n\t\t function,\n\t\t record_values->event_type );\n\t\tlibevt_debug_print_event_type(\n\t\t record_values->event_type );\n\t\tlibcnotify_printf(\n\t\t \")\\n\" );\n\n\t\tbyte_stream_copy_to_uint16_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->number_of_strings,\n\t\t value_16bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: number of strings\\t\\t\\t: %\" PRIu16 \"\\n\",\n\t\t function,\n\t\t value_16bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: event category\\t\\t\\t\\t: %\" PRIu16 \"\\n\",\n\t\t function,\n\t\t record_values->event_category );\n\n\t\tbyte_stream_copy_to_uint16_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->event_flags,\n\t\t value_16bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: event flags\\t\\t\\t\\t: 0x%04\" PRIx16 \"\\n\",\n\t\t function,\n\t\t value_16bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_event_header_t *) record_data )->closing_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: closing record values number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: strings offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t strings_offset );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: user security identifier (SID) size\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t user_sid_size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: user security identifier (SID) offset\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t user_sid_offset );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: data size\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t data_size );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: data offset\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t data_offset );\n\t}\n#endif\n\trecord_data_offset = sizeof( evt_record_event_header_t );\n\n\tif( ( user_sid_offset == 0 )\n\t && ( user_sid_size != 0 ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: user SID offset or size value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( user_sid_offset != 0 )\n\t{\n\t\tif( ( (size_t) user_sid_offset < record_data_offset )\n\t\t || ( (size_t) user_sid_offset >= ( record_data_size - 4 ) ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: user SID offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( user_sid_size != 0 )\n\t\t{\n\t\t\tif( (size_t) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t\t \"%s: user SID size value out of bounds.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t}\n\t}\n\t/* If the strings offset is points at the offset at record data size - 4\n\t * the strings are empty. For this to be sane the data offset should\n\t * be the same as the strings offset or the data size 0.\n\t */\n\tif( ( (size_t) strings_offset < user_sid_offset )\n\t || ( (size_t) strings_offset >= ( record_data_size - 4 ) ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: strings offset value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( ( (size_t) data_offset < strings_offset )\n\t || ( (size_t) data_offset >= ( record_data_size - 4 ) ) )\n\t{\n\t\tif( data_size != 0 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tdata_offset = (uint32_t) record_data_size - 4;\n\t}\n\tif( ( (size_t) strings_offset >= ( record_data_size - 4 ) )\n\t && ( strings_offset != data_offset ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: strings offset value out of bounds.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( strings_offset != 0 )\n\t{\n\t\tif( strings_offset < record_data_offset )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: strings offset value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( user_sid_offset != 0 )\n\t{\n\t\tmembers_data_size = user_sid_offset - (uint32_t) record_data_offset;\n\t}\n\telse if( strings_offset != 0 )\n\t{\n\t\tmembers_data_size = strings_offset - (uint32_t) record_data_offset;\n\t}\n\tif( strings_offset != 0 )\n\t{\n\t\tstrings_size = data_offset - strings_offset;\n\t}\n\tif( data_size != 0 )\n\t{\n\t\tif( (size_t) ( data_offset + data_size ) > ( record_data_size - 4 ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data size value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\tif( members_data_size != 0 )\n\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: members data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t members_data_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->source_name ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create source name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_string(\n\t\t                   record_values->source_name,\n\t\t                   &( record_data[ record_data_offset ] ),\n\t\t                   members_data_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of source name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: source name\\t\\t\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->source_name,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print source name value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += value_data_size;\n\t\tmembers_data_size  -= (uint32_t) value_data_size;\n\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->computer_name ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create computer name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_string(\n\t\t                   record_values->computer_name,\n\t\t                   &( record_data[ record_data_offset ] ),\n\t\t                   members_data_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of computer name value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: computer name\\t\\t\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->computer_name,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print computer name value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += value_data_size;\n\t\tmembers_data_size  -= (uint32_t) value_data_size;\n\n\t\tif( members_data_size > 0 )\n\t\t{\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\t\tif( libcnotify_verbose != 0 )\n\t\t\t{\n\t\t\t\tlibcnotify_printf(\n\t\t\t\t \"%s: members trailing data:\\n\",\n\t\t\t\t function );\n\t\t\t\tlibcnotify_print_data(\n\t\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t\t members_data_size,\n\t\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t\t}\n#endif\n\t\t\trecord_data_offset += members_data_size;\n\t\t}\n\t}\n\tif( user_sid_size != 0 )\n\t{\n\t\tif( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: user SID data size value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->user_security_identifier ),\n\t\t     LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create user security identifier (SID) value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_set_data(\n\t\t     record_values->user_security_identifier,\n\t\t     &( record_data[ user_sid_offset ] ),\n\t\t     (size_t) user_sid_size,\n\t\t     LIBFVALUE_ENDIAN_LITTLE,\n\t\t     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of user security identifier (SID) value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: user security identifier (SID)\\t\\t: \",\n\t\t\t function );\n\n\t\t\tif( libfvalue_value_print(\n\t\t\t     record_values->user_security_identifier,\n\t\t\t     0,\n\t\t\t     0,\n\t\t\t     error ) != 1 )\n\t\t\t{\n\t\t\t\tlibcerror_error_set(\n\t\t\t\t error,\n\t\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t\t LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,\n\t\t\t\t \"%s: unable to print user security identifier (SID) value.\",\n\t\t\t\t function );\n\n\t\t\t\tgoto on_error;\n\t\t\t}\n\t\t\tlibcnotify_printf(\n\t\t\t \"\\n\" );\n\t\t}\n#endif\n\t\trecord_data_offset += user_sid_size;\n\t}\n\tif( strings_size != 0 )\n\t{\n\t\tif( strings_size > ( ( record_data_size - 4 ) - strings_offset ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: strings size value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: strings data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ strings_offset ] ),\n\t\t\t strings_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( size_copy == 0 )\n\t\t{\n\t\t\t/* If the strings data is truncated\n\t\t\t */\n\t\t\tstrings_data_offset = strings_offset + strings_size - 2;\n\n\t\t\twhile( strings_data_offset > strings_offset )\n\t\t\t{\n\t\t\t\tif( ( record_data[ strings_data_offset ] != 0 )\n\t\t\t\t || ( record_data[ strings_data_offset + 1 ] != 0 ) )\n\t\t\t\t{\n\t\t\t\t\tstrings_size += 2;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrings_data_offset -= 2;\n\t\t\t\tstrings_size        -= 2;\n\t\t\t}\n\t\t}\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->strings ),\n\t\t     LIBFVALUE_VALUE_TYPE_STRING_UTF16,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create strings value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tvalue_data_size = libfvalue_value_type_set_data_strings_array(\n\t\t                   record_values->strings,\n\t\t                   &( record_data[ strings_offset ] ),\n\t\t                   strings_size,\n\t\t                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,\n\t\t                   error );\n\n\t\tif( value_data_size == -1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of strings value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\trecord_data_offset += strings_size;\n\t}\n\tif( data_size != 0 )\n\t{\n\t\tif( data_size > ( ( record_data_size - 4 ) - record_data_offset ) )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t\t \"%s: data size value out of bounds.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\tif( libcnotify_verbose != 0 )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: data:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t (size_t) data_size,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n#endif\n\t\tif( libfvalue_value_type_initialize(\n\t\t     &( record_values->data ),\n\t\t     LIBFVALUE_VALUE_TYPE_BINARY_DATA,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t\t \"%s: unable to create data value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n\t\tif( libfvalue_value_set_data(\n\t\t     record_values->data,\n\t\t     &( record_data[ record_data_offset ] ),\n\t\t     (size_t) data_size,\n\t\t     LIBFVALUE_ENDIAN_LITTLE,\n\t\t     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,\n\t\t     error ) != 1 )\n\t\t{\n\t\t\tlibcerror_error_set(\n\t\t\t error,\n\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t\t \"%s: unable to set data of data value.\",\n\t\t\t function );\n\n\t\t\tgoto on_error;\n\t\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\t\trecord_data_offset += data_size;\n#endif\n\t}\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tif( record_data_offset < ( record_data_size - 4 ) )\n\t\t{\n\t\t\tlibcnotify_printf(\n\t\t\t \"%s: padding:\\n\",\n\t\t\t function );\n\t\t\tlibcnotify_print_data(\n\t\t\t &( record_data[ record_data_offset ] ),\n\t\t\t (size_t) record_data_size - record_data_offset - 4,\n\t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n\t\t}\n\t\tlibcnotify_printf(\n\t\t \"%s: size copy\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size_copy );\n\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\tif( ( strict_mode == 0 )\n\t && ( size_copy == 0 ) )\n\t{\n\t\tsize_copy = size;\n\t}\n\tif( size != size_copy )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for size and size copy.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\tif( record_data_size != (size_t) size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for record_values data size and size.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( record_values->data != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->data ),\n\t\t NULL );\n\t}\n\tif( record_values->strings != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->strings ),\n\t\t NULL );\n\t}\n\tif( record_values->user_security_identifier != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->user_security_identifier ),\n\t\t NULL );\n\t}\n\tif( record_values->computer_name != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->computer_name ),\n\t\t NULL );\n\t}\n\tif( record_values->source_name != NULL )\n\t{\n\t\tlibfvalue_value_free(\n\t\t &( record_values->source_name ),\n\t\t NULL );\n\t}\n\treturn( -1 );\n}\n\n/* Reads the end of file record values\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_read_end_of_file(\n     libevt_record_values_t *record_values,\n     uint8_t *record_data,\n     size_t record_data_size,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_read_end_of_file\";\n\tuint32_t size         = 0;\n\tuint32_t size_copy    = 0;\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tuint32_t value_32bit  = 0;\n#endif\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record data.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size > (size_t) SSIZE_MAX )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,\n\t\t \"%s: invalid record data size value exceeds maximum.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size < sizeof( evt_record_end_of_file_t ) )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n\t\t \"%s: record data size value out of bounds.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_end_of_file_t *) record_data )->size,\n\t size );\n\n\tbyte_stream_copy_to_uint32_little_endian(\n\t ( (evt_record_end_of_file_t *) record_data )->size_copy,\n\t size_copy );\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: size\\t\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature1,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature1\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature2,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature2\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature3,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature3\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->signature4,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: signature4\\t\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->first_record_offset,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: first record offset\\t\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->end_of_file_record_offset,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: end of file record offset\\t: 0x%08\" PRIx32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->last_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: last record number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tbyte_stream_copy_to_uint32_little_endian(\n\t\t ( (evt_record_end_of_file_t *) record_data )->first_record_number,\n\t\t value_32bit );\n\t\tlibcnotify_printf(\n\t\t \"%s: first record number\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t value_32bit );\n\n\t\tlibcnotify_printf(\n\t\t \"%s: size copy\\t\\t\\t: %\" PRIu32 \"\\n\",\n\t\t function,\n\t\t size_copy );\n\n\t\tlibcnotify_printf(\n\t\t \"\\n\" );\n\t}\n#endif\n\tif( size != size_copy )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for size and size copy.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( record_data_size != (size_t) size )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_INPUT,\n\t\t LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,\n\t\t \"%s: value mismatch for record data size and size.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n/* TODO correct values in IO handle if necessary */\n\n\treturn( 1 );\n}\n\n/* Retrieves the type\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_get_type(\n     libevt_record_values_t *record_values,\n     uint8_t *type,\n     libcerror_error_t **error )\n{\n\tstatic char *function = \"libevt_record_values_get_type\";\n\n\tif( record_values == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid record values.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\tif( type == NULL )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_ARGUMENTS,\n\t\t LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,\n\t\t \"%s: invalid type.\",\n\t\t function );\n\n\t\treturn( -1 );\n\t}\n\t*type = record_values->type;\n\n\treturn( 1 );\n}\n\n/* Reads record values\n * Callback for the (recovered) records list\n * Returns 1 if successful or -1 on error\n */\nint libevt_record_values_read_element_data(\n     libevt_io_handle_t *io_handle,\n     libbfio_handle_t *file_io_handle,\n     libfdata_list_element_t *element,\n     libfcache_cache_t *cache,\n     int element_file_index LIBEVT_ATTRIBUTE_UNUSED,\n     off64_t element_offset,\n     size64_t element_size LIBEVT_ATTRIBUTE_UNUSED,\n     uint32_t element_flags LIBEVT_ATTRIBUTE_UNUSED,\n     uint8_t read_flags LIBEVT_ATTRIBUTE_UNUSED,\n     libcerror_error_t **error )\n{\n\tlibevt_record_values_t *record_values = NULL;\n\tstatic char *function                 = \"libevt_record_values_read_element_data\";\n\toff64_t file_offset                   = 0;\n\tssize_t read_count                    = 0;\n\n\tLIBEVT_UNREFERENCED_PARAMETER( element_size )\n\tLIBEVT_UNREFERENCED_PARAMETER( element_file_index )\n\tLIBEVT_UNREFERENCED_PARAMETER( element_flags )\n\tLIBEVT_UNREFERENCED_PARAMETER( read_flags )\n\n#if defined( HAVE_DEBUG_OUTPUT )\n\tif( libcnotify_verbose != 0 )\n\t{\n\t\tlibcnotify_printf(\n\t\t \"%s: reading record  at offset: %\" PRIi64 \" (0x%08\" PRIx64 \")\\n\",\n\t\t function,\n\t\t element_offset,\n\t\t element_offset );\n\t}\n#endif\n\tif( libbfio_handle_seek_offset(\n\t     file_io_handle,\n\t     element_offset,\n\t     SEEK_SET,\n\t     error ) == -1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_SEEK_FAILED,\n\t\t \"%s: unable to seek record offset: %\" PRIi64 \".\",\n\t\t function,\n\t\t element_offset );\n\n\t\tgoto on_error;\n\t}\n\tif( libevt_record_values_initialize(\n\t     &record_values,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,\n\t\t \"%s: unable to create record values.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\t/* File offset must be before being passed to libevt_record_values_read\n\t */\n\tfile_offset = element_offset;\n\n\tread_count = libevt_record_values_read(\n\t\t      record_values,\n\t\t      file_io_handle,\n\t\t      io_handle,\n\t\t      &file_offset,\n\t\t      0,\n\t\t      error );\n\n\tif( read_count == -1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_IO,\n\t\t LIBCERROR_IO_ERROR_READ_FAILED,\n\t\t \"%s: unable to read record at offset: %\" PRIi64 \".\",\n\t\t function,\n\t\t element_offset );\n\n\t\tgoto on_error;\n\t}\n\tif( libfdata_list_element_set_element_value(\n\t     element,\n\t     (intptr_t *) file_io_handle,\n\t     cache,\n\t     (intptr_t *) record_values,\n\t     (int (*)(intptr_t **, libcerror_error_t **)) &libevt_record_values_free,\n\t     LIBFDATA_LIST_ELEMENT_VALUE_FLAG_MANAGED,\n\t     error ) != 1 )\n\t{\n\t\tlibcerror_error_set(\n\t\t error,\n\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n\t\t LIBCERROR_RUNTIME_ERROR_SET_FAILED,\n\t\t \"%s: unable to set record values as element value.\",\n\t\t function );\n\n\t\tgoto on_error;\n\t}\n\treturn( 1 );\n\non_error:\n\tif( record_values != NULL )\n\t{\n\t\tlibevt_record_values_free(\n\t\t &record_values,\n\t\t NULL );\n\t}\n\treturn( -1 );\n}\n\n", "dnl Checks for libcdata or required headers and functions\ndnl\ndnl Version: 20180316\n\ndnl Function to detect if libcdata is available\ndnl ac_libcdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\nAC_DEFUN([AX_LIBCDATA_CHECK_LIB],\n  [dnl Check if parameters were provided\n  AS_IF(\n    [test \"x$ac_cv_with_libcdata\" != x && test \"x$ac_cv_with_libcdata\" != xno && test \"x$ac_cv_with_libcdata\" != xauto-detect],\n    [AS_IF(\n      [test -d \"$ac_cv_with_libcdata\"],\n      [CFLAGS=\"$CFLAGS -I${ac_cv_with_libcdata}/include\"\n      LDFLAGS=\"$LDFLAGS -L${ac_cv_with_libcdata}/lib\"],\n      [AC_MSG_WARN([no such directory: $ac_cv_with_libcdata])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_with_libcdata\" = xno],\n    [ac_cv_libcdata=no],\n    [dnl Check for a pkg-config file\n    AS_IF(\n      [test \"x$cross_compiling\" != \"xyes\" && test \"x$PKGCONFIG\" != \"x\"],\n      [PKG_CHECK_MODULES(\n        [libcdata],\n        [libcdata >= 20160108],\n        [ac_cv_libcdata=yes],\n        [ac_cv_libcdata=check])\n      ])\n\n    AS_IF(\n      [test \"x$ac_cv_libcdata\" = xyes],\n      [ac_cv_libcdata_CPPFLAGS=\"$pkg_cv_libcdata_CFLAGS\"\n      ac_cv_libcdata_LIBADD=\"$pkg_cv_libcdata_LIBS\"])\n\n    AS_IF(\n      [test \"x$ac_cv_libcdata\" = xcheck],\n      [dnl Check for headers\n      AC_CHECK_HEADERS([libcdata.h])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libcdata_h\" = xno],\n        [ac_cv_libcdata=no],\n        [dnl Check for the individual functions\n        ac_cv_libcdata=yes\n\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_get_version,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl Array functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_resize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_reverse,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_get_number_of_entries,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_get_entry_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_get_entry_by_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_set_entry_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_prepend_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_append_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_insert_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_array_remove_entry,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl Balanced tree functions\n        AC_CHECK_LIB(\n          cdata,\n          libfdata_btree_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_get_number_of_values,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_get_value_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_get_value_by_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_insert_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_replace_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_btree_remove_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl List functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_number_of_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_first_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_last_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_element_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_get_value_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_prepend_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_prepend_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_append_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_append_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_insert_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_insert_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_remove_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl List element functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_previous_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_previous_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_next_element,\n          [ac_cv_libcdata_dummy=yes],\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_next_element,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_get_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_list_element_set_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n          [ac_cv_libcdata=no])\n\n        dnl Range list functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_number_of_elements,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_insert_range,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_insert_range_list,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_remove_range,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_range_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_range_at_offset,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_range_is_present,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_range_list_get_spanning_range,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        dnl Tree node functions\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_initialize,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_free,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_empty,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_clone,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_parent_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_parent_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_previous_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_previous_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_next_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_next_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_nodes,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_set_nodes,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_append_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_append_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_insert_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_insert_value,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_replace_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_remove_node,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_number_of_sub_nodes,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_sub_node_by_index,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n        AC_CHECK_LIB(\n          cdata,\n          libcdata_tree_node_get_leaf_node_list,\n          [ac_cv_libcdata_dummy=yes],\n          [ac_cv_libcdata=no])\n\n        ac_cv_libcdata_LIBADD=\"-lcdata\"\n        ])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_DEFINE(\n      [HAVE_LIBCDATA],\n      [1],\n      [Define to 1 if you have the `cdata' library (-lcdata).])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_SUBST(\n      [HAVE_LIBCDATA],\n      [1]) ],\n    [AC_SUBST(\n      [HAVE_LIBCDATA],\n      [0])\n    ])\n  ])\n\ndnl Function to detect if libcdata dependencies are available\nAC_DEFUN([AX_LIBCDATA_CHECK_LOCAL],\n  [dnl No additional checks.\n\n  ac_cv_libcdata_CPPFLAGS=\"-I../libcdata\";\n  ac_cv_libcdata_LIBADD=\"../libcdata/libcdata.la\";\n\n  ac_cv_libcdata=local\n  ])\n\ndnl Function to detect how to enable libcdata\nAC_DEFUN([AX_LIBCDATA_CHECK_ENABLE],\n  [AX_COMMON_ARG_WITH(\n    [libcdata],\n    [libcdata],\n    [search for libcdata in includedir and libdir or in the specified DIR, or no if to use local version],\n    [auto-detect],\n    [DIR])\n\n  dnl Check for a shared library version\n  AX_LIBCDATA_CHECK_LIB\n\n  dnl Check if the dependencies for the local library version\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" != xyes],\n    [AX_LIBCDATA_CHECK_LOCAL\n\n    AC_DEFINE(\n      [HAVE_LOCAL_LIBCDATA],\n      [1],\n      [Define to 1 if the local version of libcdata is used.])\n    AC_SUBST(\n      [HAVE_LOCAL_LIBCDATA],\n      [1])\n    ])\n\n  AM_CONDITIONAL(\n    [HAVE_LOCAL_LIBCDATA],\n    [test \"x$ac_cv_libcdata\" = xlocal])\n  AS_IF(\n    [test \"x$ac_cv_libcdata_CPPFLAGS\" != \"x\"],\n    [AC_SUBST(\n      [LIBCDATA_CPPFLAGS],\n      [$ac_cv_libcdata_CPPFLAGS])\n    ])\n  AS_IF(\n    [test \"x$ac_cv_libcdata_LIBADD\" != \"x\"],\n    [AC_SUBST(\n      [LIBCDATA_LIBADD],\n      [$ac_cv_libcdata_LIBADD])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_SUBST(\n      [ax_libcdata_pc_libs_private],\n      [-lcdata])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcdata\" = xyes],\n    [AC_SUBST(\n      [ax_libcdata_spec_requires],\n      [libcdata])\n    AC_SUBST(\n      [ax_libcdata_spec_build_requires],\n      [libcdata-devel])\n    ])\n  ])\n\n", "dnl Checks for libcsplit or required headers and functions\ndnl\ndnl Version: 20180217\n\ndnl Function to detect if libcsplit is available\ndnl ac_libcsplit_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\nAC_DEFUN([AX_LIBCSPLIT_CHECK_LIB],\n  [dnl Check if parameters were provided\n  AS_IF(\n    [test \"x$ac_cv_with_libcsplit\" != x && test \"x$ac_cv_with_libcsplit\" != xno && test \"x$ac_cv_with_libcsplit\" != xauto-detect],\n    [AS_IF(\n      [test -d \"$ac_cv_with_libcsplit\"],\n      [CFLAGS=\"$CFLAGS -I${ac_cv_with_libcsplit}/include\"\n      LDFLAGS=\"$LDFLAGS -L${ac_cv_with_libcsplit}/lib\"],\n      [AC_MSG_WARN([no such directory: $ac_cv_with_libcsplit])\n    ])\n  ])\n\n  AS_IF(\n    [test \"x$ac_cv_with_libcsplit\" = xno],\n    [ac_cv_libcsplit=no],\n    [dnl Check for a pkg-config file\n    AS_IF(\n      [test \"x$cross_compiling\" != \"xyes\" && test \"x$PKGCONFIG\" != \"x\"],\n      [PKG_CHECK_MODULES(\n        [libcsplit],\n        [libcsplit >= 20120701],\n        [ac_cv_libcsplit=yes],\n        [ac_cv_libcsplit=check])\n    ])\n\n    AS_IF(\n      [test \"x$ac_cv_libcsplit\" = xyes && test \"x$ac_cv_enable_wide_character_type\" != xno],\n      [AC_CACHE_CHECK(\n       [whether libcsplit/features.h defines LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE as 1],\n       [ac_cv_header_libcsplit_features_h_have_wide_character_type],\n       [AC_LANG_PUSH(C)\n       AC_COMPILE_IFELSE(\n         [AC_LANG_PROGRAM(\n           [[#include <libcsplit/features.h>]],\n           [[#if !defined( LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE ) || ( LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE != 1 )\n#error LIBCSPLIT_HAVE_WIDE_CHARACTER_TYPE not defined\n##endif]] )],\n         [ac_cv_header_libcsplit_features_h_have_wide_character_type=yes],\n         [ac_cv_header_libcsplit_features_h_have_wide_character_type=no])\n       AC_LANG_POP(C)],\n       [ac_cv_header_libcsplit_features_h_have_wide_character_type=no])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libcsplit_features_h_have_wide_character_type\" = xno],\n        [ac_cv_libcsplit=no])\n    ])\n\n    AS_IF(\n      [test \"x$ac_cv_libcsplit\" = xyes],\n      [ac_cv_libcsplit_CPPFLAGS=\"$pkg_cv_libcsplit_CFLAGS\"\n      ac_cv_libcsplit_LIBADD=\"$pkg_cv_libcsplit_LIBS\"])\n\n    AS_IF(\n      [test \"x$ac_cv_libcsplit\" = xcheck],\n      [dnl Check for headers\n      AC_CHECK_HEADERS([libcsplit.h])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libcsplit_h\" = xno],\n        [ac_cv_libcsplit=no],\n        [dnl Check for the individual functions\n        ac_cv_libcsplit=yes\n\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_get_version,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n\n        dnl Narrow string functions\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_string_split,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n\n        dnl Narrow split string functions\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_free,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_get_string,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_get_number_of_segments,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_get_segment_by_index,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n        AC_CHECK_LIB(\n          csplit,\n          libcsplit_narrow_split_string_set_segment_by_index,\n          [ac_cv_libcsplit_dummy=yes],\n          [ac_cv_libcsplit=no])\n\n        dnl Wide string functions\n        AS_IF(\n          [test \"x$ac_cv_enable_wide_character_type\" != xno],\n          [AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_string_split,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n\n        dnl Wide split string functions\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_free,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_get_string,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_get_number_of_segments,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_get_segment_by_index,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          AC_CHECK_LIB(\n            csplit,\n            libcsplit_wide_split_string_set_segment_by_index,\n            [ac_cv_libcsplit_dummy=yes],\n            [ac_cv_libcsplit=no])\n          ])\n\n        ac_cv_libcsplit_LIBADD=\"-lcsplit\"\n        ])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_DEFINE(\n      [HAVE_LIBCSPLIT],\n      [1],\n      [Define to 1 if you have the `csplit' library (-lcsplit).])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_SUBST(\n      [HAVE_LIBCSPLIT],\n      [1]) ],\n    [AC_SUBST(\n      [HAVE_LIBCSPLIT],\n      [0])\n    ])\n  ])\n\ndnl Function to detect if libcsplit dependencies are available\nAC_DEFUN([AX_LIBCSPLIT_CHECK_LOCAL],\n  [dnl No additional checks.\n\n  ac_cv_libcsplit_CPPFLAGS=\"-I../libcsplit\";\n  ac_cv_libcsplit_LIBADD=\"../libcsplit/libcsplit.la\";\n\n  ac_cv_libcsplit=local\n  ])\n\ndnl Function to detect how to enable libcsplit\nAC_DEFUN([AX_LIBCSPLIT_CHECK_ENABLE],\n  [AX_COMMON_ARG_WITH(\n    [libcsplit],\n    [libcsplit],\n    [search for libcsplit in includedir and libdir or in the specified DIR, or no if to use local version],\n    [auto-detect],\n    [DIR])\n\n  dnl Check for a shared library version\n  AX_LIBCSPLIT_CHECK_LIB\n\n  dnl Check if the dependencies for the local library version\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" != xyes],\n    [AX_LIBCSPLIT_CHECK_LOCAL\n\n    AC_DEFINE(\n      [HAVE_LOCAL_LIBCSPLIT],\n      [1],\n      [Define to 1 if the local version of libcsplit is used.])\n    AC_SUBST(\n      [HAVE_LOCAL_LIBCSPLIT],\n      [1])\n    ])\n\n  AM_CONDITIONAL(\n    [HAVE_LOCAL_LIBCSPLIT],\n    [test \"x$ac_cv_libcsplit\" = xlocal])\n  AS_IF(\n    [test \"x$ac_cv_libcsplit_CPPFLAGS\" != \"x\"],\n    [AC_SUBST(\n      [LIBCSPLIT_CPPFLAGS],\n      [$ac_cv_libcsplit_CPPFLAGS])\n    ])\n  AS_IF(\n    [test \"x$ac_cv_libcsplit_LIBADD\" != \"x\"],\n    [AC_SUBST(\n      [LIBCSPLIT_LIBADD],\n      [$ac_cv_libcsplit_LIBADD])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_SUBST(\n      [ax_libcsplit_pc_libs_private],\n      [-lcsplit])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libcsplit\" = xyes],\n    [AC_SUBST(\n      [ax_libcsplit_spec_requires],\n      [libcsplit])\n    AC_SUBST(\n      [ax_libcsplit_spec_build_requires],\n      [libcsplit-devel])\n    ])\n  ])\n\n", "dnl Functions for libfdata\ndnl\ndnl Version: 20180316\n\ndnl Function to detect if libfdata is available\ndnl ac_libfdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\nAC_DEFUN([AX_LIBFDATA_CHECK_LIB],\n  [dnl Check if parameters were provided\n  AS_IF(\n    [test \"x$ac_cv_with_libfdata\" != x && test \"x$ac_cv_with_libfdata\" != xno && test \"x$ac_cv_with_libfdata\" != xauto-detect],\n    [AS_IF(\n      [test -d \"$ac_cv_with_libfdata\"],\n      [CFLAGS=\"$CFLAGS -I${ac_cv_with_libfdata}/include\"\n      LDFLAGS=\"$LDFLAGS -L${ac_cv_with_libfdata}/lib\"],\n      [AC_MSG_WARN([no such directory: $ac_cv_with_libfdata])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_with_libfdata\" = xno],\n    [ac_cv_libfdata=no],\n    [dnl Check for a pkg-config file\n    AS_IF(\n      [test \"x$cross_compiling\" != \"xyes\" && test \"x$PKGCONFIG\" != \"x\"],\n      [PKG_CHECK_MODULES(\n        [libfdata],\n        [libfdata >= 20160325],\n        [ac_cv_libfdata=yes],\n        [ac_cv_libfdata=no])\n      ])\n\n    AS_IF(\n      [test \"x$ac_cv_libfdata\" = xyes],\n      [ac_cv_libfdata_CPPFLAGS=\"$pkg_cv_libfdata_CFLAGS\"\n      ac_cv_libfdata_LIBADD=\"$pkg_cv_libfdata_LIBS\"],\n      [dnl Check for headers\n      AC_CHECK_HEADERS([libfdata.h])\n\n      AS_IF(\n        [test \"x$ac_cv_header_libfdata_h\" = xno],\n        [ac_cv_libfdata=no],\n        [dnl Check for the individual functions\n        ac_cv_libfdata=yes\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_get_version,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Area functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_initialize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_free,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_clone,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_empty,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_resize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_get_number_of_segments,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_get_segment_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_set_segment_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_prepend_segment,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_append_segment,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_get_element_data_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_get_element_value_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_set_element_value_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_area_get_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Balanced tree functions\n        dnl TODO: add functions\n\n        dnl List functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_initialize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_free,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_clone,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_empty,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_resize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_reverse,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_number_of_elements,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_list_element_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_prepend_element,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_append_element,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_append_list,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_is_element_set,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_mapped_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_mapped_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_mapped_size_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_mapped_size_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_by_index_with_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_by_index_with_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_append_element_with_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_index_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_list_element_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_cache_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_value_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_element_value_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_value_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_set_element_value_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_get_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl List element functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_get_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_list_element_set_element_value,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Range list functions\n        dnl TODO: add functions\n\n        dnl Stream functions\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_initialize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_free,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_clone,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_empty,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_resize,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_reverse,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_number_of_segments,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_set_segment_by_index,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_prepend_segment,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_append_segment,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_set_mapped_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_mapped_range,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_index_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_segment_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_read_buffer,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_read_buffer_at_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_write_buffer,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_seek_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_offset,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n        AC_CHECK_LIB(\n          fdata,\n          libfdata_stream_get_size,\n          [ac_cv_libfdata_dummy=yes],\n          [ac_cv_libfdata=no])\n\n        dnl Tree list functions\n        dnl TODO: add functions\n\n        dnl Vector list functions\n        dnl TODO: add functions\n\n        ac_cv_libfdata_LIBADD=\"-lfdata\"\n        ])\n      ])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_DEFINE(\n      [HAVE_LIBFDATA],\n      [1],\n      [Define to 1 if you have the `fdata' library (-lfdata).])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_SUBST(\n      [HAVE_LIBFDATA],\n      [1]) ],\n    [AC_SUBST(\n      [HAVE_LIBFDATA],\n      [0])\n    ])\n  ])\n\ndnl Function to detect if libfdata dependencies are available\nAC_DEFUN([AX_LIBFDATA_CHECK_LOCAL],\n  [dnl No additional checks.\n\n  ac_cv_libfdata_CPPFLAGS=\"-I../libfdata\";\n  ac_cv_libfdata_LIBADD=\"../libfdata/libfdata.la\";\n\n  ac_cv_libfdata=local\n  ])\n\ndnl Function to detect how to enable libfdata\nAC_DEFUN([AX_LIBFDATA_CHECK_ENABLE],\n  [AX_COMMON_ARG_WITH(\n    [libfdata],\n    [libfdata],\n    [search for libfdata in includedir and libdir or in the specified DIR, or no if to use local version],\n    [auto-detect],\n    [DIR])\n\n  dnl Check for a shared library version\n  AX_LIBFDATA_CHECK_LIB\n\n  dnl Check if the dependencies for the local library version\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" != xyes],\n    [AX_LIBFDATA_CHECK_LOCAL\n\n    AC_DEFINE(\n      [HAVE_LOCAL_LIBFDATA],\n      [1],\n      [Define to 1 if the local version of libfdata is used.])\n    AC_SUBST(\n      [HAVE_LOCAL_LIBFDATA],\n      [1])\n    ])\n\n  AM_CONDITIONAL(\n    [HAVE_LOCAL_LIBFDATA],\n    [test \"x$ac_cv_libfdata\" = xlocal])\n  AS_IF(\n    [test \"x$ac_cv_libfdata_CPPFLAGS\" != \"x\"],\n    [AC_SUBST(\n      [LIBFDATA_CPPFLAGS],\n      [$ac_cv_libfdata_CPPFLAGS])\n    ])\n  AS_IF(\n    [test \"x$ac_cv_libfdata_LIBADD\" != \"x\"],\n    [AC_SUBST(\n      [LIBFDATA_LIBADD],\n      [$ac_cv_libfdata_LIBADD])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_SUBST(\n      [ax_libfdata_pc_libs_private],\n      [-lfdata])\n    ])\n\n  AS_IF(\n    [test \"x$ac_cv_libfdata\" = xyes],\n    [AC_SUBST(\n      [ax_libfdata_spec_requires],\n      [libfdata])\n    AC_SUBST(\n      [ax_libfdata_spec_build_requires],\n      [libfdata-devel])\n    ])\n  ])\n", "#!/bin/bash\n# Script that runs the tests\n#\n# Version: 20180214\n\nEXIT_SUCCESS=0;\nEXIT_FAILURE=1;\n\nrun_configure_make()\n{\n\tlocal CONFIGURE_OPTIONS=$@;\n\n\t./configure ${CONFIGURE_OPTIONS[@]};\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: './configure' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\n\tmake clean > /dev/null;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make clean' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\n\tmake > /dev/null;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nrun_configure_make_check()\n{\n\trun_configure_make $@;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\treturn ${RESULT};\n\tfi\n\n\tmake check CHECK_WITH_STDERR=1;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make check' failed\";\n\n\t\tif test -f tests/test-suite.log;\n\t\tthen\n\t\t\tcat tests/test-suite.log;\n\t\tfi\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nrun_configure_make_check_with_asan()\n{\n\tlocal LDCONFIG=`which ldconfig 2> /dev/null`;\n\n\tif test -z ${LDCONFIG} || test ! -x ${LDCONFIG};\n\tthen\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\tlocal LIBASAN=`ldconfig -p | grep libasan | sed 's/^.* => //'`;\n\n\tif test -z ${LIBASAN} || test ! -f ${LIBASAN};\n\tthen\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\t# Using libasan is platform dependent.\n\tif test ${LIBASAN} != \"/lib64/libasan.so.4\";\n\tthen\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\n\texport CPPFLAGS=\"-DHAVE_ASAN\";\n\texport CFLAGS=\"-fno-omit-frame-pointer -fsanitize=address -g\";\n\texport LDFLAGS=\"-fsanitize=address -g\";\n\n\tif test -z ${CC} || test ${CC} != \"clang\";\n\tthen\n\t\tLDFLAGS=\"${LDFLAGS} -lasan\";\n\tfi\n\n\trun_configure_make $@;\n\tRESULT=$?;\n\n\texport CPPFLAGS=;\n\texport CFLAGS=;\n\texport LDFLAGS=;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\treturn ${RESULT};\n\tfi\n\n\tmake check CHECK_WITH_ASAN=1 CHECK_WITH_STDERR=1;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make check' failed\";\n\n\t\tif test -f tests/test-suite.log;\n\t\tthen\n\t\t\tcat tests/test-suite.log;\n\t\tfi\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${RESULT};\n}\n\nrun_configure_make_check_with_coverage()\n{\n\t# Disable optimization so we can hook malloc and realloc.\n\texport CPPFLAGS=\"-DOPTIMIZATION_DISABLED\";\n\texport CFLAGS=\"--coverage -O0\";\n\texport LDFLAGS=\"--coverage\";\n\n\t# Disable creating a shared library so we can hook memset.\n\trun_configure_make_check $@;\n\tRESULT=$?;\n\n\texport CPPFLAGS=;\n\texport CFLAGS=;\n\texport LDFLAGS=;\n\n\treturn ${RESULT};\n}\n\nrun_configure_make_check_python()\n{\n\trun_configure_make $@;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\treturn ${RESULT};\n\tfi\n\n\tmake check CHECK_WITH_STDERR=1 SKIP_LIBRARY_TESTS=1 SKIP_TOOLS_TESTS=1;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'make check' failed\";\n\n\t\tif test -f tests/test-suite.log;\n\t\tthen\n\t\t\tcat tests/test-suite.log;\n\t\tfi\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nrun_setup_py_tests()\n{\n\t# Skip this test when running Cygwin on AppVeyor.\n\tif test -n \"${APPVEYOR}\" && test ${TARGET} = \"cygwin\";\n\tthen\n\t\techo \"Running: 'setup.py build' skipped\";\n\n\t\treturn ${EXIT_SUCCESS};\n\tfi\n\tPYTHON=$1;\n\n\t${PYTHON} setup.py build;\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\techo \"Running: 'setup.py build' failed\";\n\n\t\treturn ${RESULT};\n\tfi\n\treturn ${EXIT_SUCCESS};\n}\n\nCONFIGURE_HELP=`./configure --help`;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--enable-wide-character-type' > /dev/null;\n\nHAVE_ENABLE_WIDE_CHARACTER_TYPE=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--enable-verbose-output' > /dev/null;\n\nHAVE_ENABLE_VERBOSE_OUTPUT=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--enable-debug-output' > /dev/null;\n\nHAVE_ENABLE_DEBUG_OUTPUT=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--with-zlib' > /dev/null;\n\nHAVE_WITH_ZLIB=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--with-openssl' > /dev/null;\n\nHAVE_WITH_OPENSSL=$?;\n\necho \"${CONFIGURE_HELP}\" | grep -- '--enable-python' > /dev/null;\n\nHAVE_ENABLE_PYTHON=$?;\n\nPYTHON_CONFIG=\"\";\n\nif test -x /usr/bin/whereis;\nthen\n\tPYTHON_CONFIG=`/usr/bin/whereis python-config | sed 's/^.*:[ ]*//' 2> /dev/null`;\nfi\n\n# Test \"./configure && make && make check\" without options.\n\nrun_configure_make_check;\nRESULT=$?;\n\nif test ${RESULT} -ne ${EXIT_SUCCESS};\nthen\n\texit ${EXIT_FAILURE};\nfi\n\nif test ${HAVE_ENABLE_VERBOSE_OUTPUT} -eq 0 && test ${HAVE_ENABLE_DEBUG_OUTPUT} -eq 0;\nthen\n\t# Test \"./configure && make && make check\" with verbose and debug output.\n\n\trun_configure_make_check \"--enable-verbose-output --enable-debug-output\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\nfi\n\nif test ${HAVE_WITH_ZLIB} -eq 0;\nthen\n\t# Test \"./configure && make && make check\" with fallback zlib implementation.\n\n\trun_configure_make_check \"--with-zlib=no\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\nfi\n\nif test ${HAVE_WITH_OPENSSL} -eq 0;\nthen\n\t# Test \"./configure && make && make check\" with fallback crypto implementation.\n\n\trun_configure_make_check \"--with-openssl=no\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\n\n\t# Test \"./configure && make && make check\" with non-EVP openssl implementation.\n\n\trun_configure_make_check \"--enable-openssl-evp-cipher=no --enable-openssl-evp-md=no\";\n\tRESULT=$?;\n\n\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\tthen\n\t\texit ${EXIT_FAILURE};\n\tfi\nfi\n\nif test ${HAVE_ENABLE_PYTHON} -eq 0 && test -n \"${PYTHON_CONFIG}\";\nthen\n\t# Test with Python 2.\n\tPYTHON2=`which python2 2> /dev/null`;\n\n        # Note that \"test -x\" on Mac OS X will succeed if the argument is not set.\n\tif test -n \"${PYTHON2}\" && test -x ${PYTHON2};\n\tthen\n\t\texport PYTHON_VERSION=2;\n\n\t\trun_configure_make_check_python \"--enable-python\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\t\texport PYTHON_VERSION=;\n\n\t\trun_configure_make \"--enable-python2\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\n\t\tif test -f \"setup.py\" && ! run_setup_py_tests ${PYTHON2};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\tfi\n\n\t# Test with Python 3.\n\tPYTHON3=`which python3 2> /dev/null`;\n\n        # Note that \"test -x\" on Mac OS X will succeed if the argument is not set.\n\tif test -n \"${PYTHON3}\" && test -x ${PYTHON3};\n\tthen\n\t\texport PYTHON_VERSION=3;\n\n\t\trun_configure_make_check_python \"--enable-python\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\t\texport PYTHON_VERSION=;\n\n\t\trun_configure_make \"--enable-python3\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\n\t\tif test -f \"setup.py\" && ! run_setup_py_tests ${PYTHON3};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\tfi\n\n\t# Test with the default Python version.\n\tif test -z ${PYTHON2} && test -z ${PYTHON3};\n\tthen\n\t\trun_configure_make_check_python \"--enable-python\";\n\t\tRESULT=$?;\n\n\t\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\n\t\tPYTHON=`which python 2> /dev/null`;\n\n\t\tif test -f \"setup.py\" && ! run_setup_py_tests ${PYTHON};\n\t\tthen\n\t\t\texit ${EXIT_FAILURE};\n\t\tfi\n\tfi\nfi\n\nCONFIGURE_OPTIONS=\"\";\n\nif test ${HAVE_ENABLE_PYTHON} -eq 0 && test -n \"${PYTHON_CONFIG}\";\nthen\n\t# Issue with running the python bindings with asan disabled for now.\n\t# CONFIGURE_OPTIONS=\"${CONFIGURE_OPTIONS} --enable-python\";\n\tCONFIGURE_OPTIONS=\"${CONFIGURE_OPTIONS}\";\nfi\n\nrun_configure_make_check_with_asan ${CONFIGURE_OPTIONS};\nRESULT=$?;\n\nif test ${RESULT} -ne ${EXIT_SUCCESS};\nthen\n\texit ${EXIT_FAILURE};\nfi\n\nCONFIGURE_OPTIONS=\"--enable-shared=no\";\n\nif test ${HAVE_ENABLE_WIDE_CHARACTER_TYPE} -eq 0;\nthen\n\tCONFIGURE_OPTIONS=\"${CONFIGURE_OPTIONS} --enable-wide-character-type\";\nfi\n\nrun_configure_make_check_with_coverage ${CONFIGURE_OPTIONS};\nRESULT=$?;\n\nif test ${RESULT} -ne ${EXIT_SUCCESS};\nthen\n\texit ${EXIT_FAILURE};\nfi\n\nexit ${EXIT_SUCCESS};\n\n"], "filenames": ["configure.ac", "libevt.nuspec", "libevt/libevt_libfvalue.h", "libevt/libevt_record_values.c", "m4/libcdata.m4", "m4/libcsplit.m4", "m4/libfdata.m4", "runtests.sh"], "buggy_code_start_loc": [5, 5, 31, 1159, 3, 3, 3, 4], "buggy_code_end_loc": [154, 14, 31, 1296, 125, 115, 53, 230], "fixing_code_start_loc": [5, 5, 32, 1160, 3, 3, 3, 4], "fixing_code_end_loc": [153, 14, 33, 1329, 168, 115, 122, 252], "type": "CWE-125", "message": "** DISPUTED ** The libevt_record_values_read_event() function in libevt_record_values.c in libevt before 2018-03-17 does not properly check for out-of-bounds values of user SID data size, strings size, or data size. NOTE: the vendor has disputed this as described in libyal/libevt issue 5 on GitHub.", "other": {"cve": {"id": "CVE-2018-8754", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-18T03:29:00.277", "lastModified": "2020-10-14T18:14:43.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** The libevt_record_values_read_event() function in libevt_record_values.c in libevt before 2018-03-17 does not properly check for out-of-bounds values of user SID data size, strings size, or data size. NOTE: the vendor has disputed this as described in libyal/libevt issue 5 on GitHub."}, {"lang": "es", "value": "** EN DISPUTA ** La funci\u00f3n libevt_record_values_read_event() en libevt_record_values.c en libevt, en versiones anteriores a 2018-03-17, no comprueba correctamente los valores fuera de l\u00edmites del tama\u00f1o de datos DIC de usuario, del tama\u00f1o de cadenas o del tama\u00f1o de datos. NOTA: el fabricante ha disputado esto, tal y como se describe en el issue 5 de libyal/libevt en GitHub."}], "vendorComments": [{"organization": "libevt", "comment": "For a project specific advisory see: https://github.com/libyal/libevt/issues/5.", "lastModified": "2018-07-11T09:30:03.943"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libevt_project:libevt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180317", "matchCriteriaId": "112E2024-E82C-473E-BD1E-94590CC641D6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/libyal/libevt/commit/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4160", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libyal/libevt/commit/9d2cc3ca0a1612a6b271abcacffc2e3eea42925e"}}