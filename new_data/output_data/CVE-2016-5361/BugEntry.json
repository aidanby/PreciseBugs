{"buggy_code": ["/* State machine for IKEv1\n * Copyright (C) 1997 Angelos D. Keromytis.\n * Copyright (C) 1998-2010,2013-2015 D. Hugh Redelmeier <hugh@mimosa.com>\n * Copyright (C) 2003-2008 Michael Richardson <mcr@xelerance.com>\n * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>\n * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>\n * Copyright (C) 2011 Avesh Agarwal <avagarwa@redhat.com>\n * Copyright (C) 2008 Hiren Joshi <joshihirenn@gmail.com>\n * Copyright (C) 2009 Anthony Tong <atong@TrustedCS.com>\n * Copyright (C) 2012-2013 Paul Wouters <pwouters@redhat.com>\n * Copyright (C) 2013 Wolfgang Nothdurft <wolfgang@linogate.de>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * for more details.\n *\n */\n\n/* Ordering Constraints on Payloads\n *\n * rfc2409: The Internet Key Exchange (IKE)\n *\n * 5 Exchanges:\n *   \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n *\n *   \"Except where otherwise noted, there are no requirements for ISAKMP\n *    payloads in any message to be in any particular order.\"\n *\n * 5.3 Phase 1 Authenticated With a Revised Mode of Public Key Encryption:\n *\n *   \"If the HASH payload is sent it MUST be the first payload of the\n *    second message exchange and MUST be followed by the encrypted\n *    nonce. If the HASH payload is not sent, the first payload of the\n *    second message exchange MUST be the encrypted nonce.\"\n *\n *   \"Save the requirements on the location of the optional HASH payload\n *    and the mandatory nonce payload there are no further payload\n *    requirements. All payloads-- in whatever order-- following the\n *    encrypted nonce MUST be encrypted with Ke_i or Ke_r depending on the\n *    direction.\"\n *\n * 5.5 Phase 2 - Quick Mode\n *\n *   \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n *    header and a SA payload MUST immediately follow the HASH.\"\n *   [NOTE: there may be more than one SA payload, so this is not\n *    totally reasonable.  Probably all SAs should be so constrained.]\n *\n *   \"If ISAKMP is acting as a client negotiator on behalf of another\n *    party, the identities of the parties MUST be passed as IDci and\n *    then IDcr.\"\n *\n *   \"With the exception of the HASH, SA, and the optional ID payloads,\n *    there are no payload ordering restrictions on Quick Mode.\"\n */\n\n/* Unfolding of Identity -- a central mystery\n *\n * This concerns Phase 1 identities, those of the IKE hosts.\n * These are the only ones that are authenticated.  Phase 2\n * identities are for IPsec SAs.\n *\n * There are three case of interest:\n *\n * (1) We initiate, based on a whack command specifying a Connection.\n *     We know the identity of the peer from the Connection.\n *\n * (2) (to be implemented) we initiate based on a flow from our client\n *     to some IP address.\n *     We immediately know one of the peer's client IP addresses from\n *     the flow.  We must use this to figure out the peer's IP address\n *     and Id.  To be solved.\n *\n * (3) We respond to an IKE negotiation.\n *     We immediately know the peer's IP address.\n *     We get an ID Payload in Main I2.\n *\n *     Unfortunately, this is too late for a number of things:\n *     - the ISAKMP SA proposals have already been made (Main I1)\n *       AND one accepted (Main R1)\n *     - the SA includes a specification of the type of ID\n *       authentication so this is negotiated without being told the ID.\n *     - with Preshared Key authentication, Main I2 is encrypted\n *       using the key, so it cannot be decoded to reveal the ID\n *       without knowing (or guessing) which key to use.\n *\n *     There are three reasonable choices here for the responder:\n *     + assume that the initiator is making wise offers since it\n *       knows the IDs involved.  We can balk later (but not gracefully)\n *       when we find the actual initiator ID\n *     + attempt to infer identity by IP address.  Again, we can balk\n *       when the true identity is revealed.  Actually, it is enough\n *       to infer properties of the identity (eg. SA properties and\n *       PSK, if needed).\n *     + make all properties universal so discrimination based on\n *       identity isn't required.  For example, always accept the same\n *       kinds of encryption.  Accept Public Key Id authentication\n *       since the Initiator presumably has our public key and thinks\n *       we must have / can find his.  This approach is weakest\n *       for preshared key since the actual key must be known to\n *       decrypt the Initiator's ID Payload.\n *     These choices can be blended.  For example, a class of Identities\n *     can be inferred, sufficient to select a preshared key but not\n *     sufficient to infer a unique identity.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <libreswan.h>\n\n#include \"sysdep.h\"\n#include \"constants.h\"\n#include \"lswlog.h\"\n\n#include \"defs.h\"\n#include \"cookie.h\"\n#include \"id.h\"\n#include \"x509.h\"\n#include \"pluto_x509.h\"\n#include \"certs.h\"\n#include \"connections.h\"        /* needs id.h */\n#include \"state.h\"\n#include \"ikev1_msgid.h\"\n#include \"packet.h\"\n#include \"md5.h\"\n#include \"sha1.h\"\n#include \"crypto.h\" /* requires sha1.h and md5.h */\n#include \"ike_alg.h\"\n#include \"log.h\"\n#include \"demux.h\"      /* needs packet.h */\n#include \"ikev1.h\"\n#include \"ipsec_doi.h\"  /* needs demux.h and state.h */\n#include \"ikev1_quick.h\"\n#include \"timer.h\"\n#include \"whack.h\"      /* requires connections.h */\n#include \"server.h\"\n\n#include \"ikev1_xauth.h\"\n\n#include \"nat_traversal.h\"\n#include \"vendor.h\"\n#include \"ikev1_dpd.h\"\n#include \"hostpair.h\"\n#include \"pluto_crypt.h\"\t/* just for log_crypto_workers() */\n\n#ifdef HAVE_NM\n#include \"kernel.h\"\n#endif\n\n/* state_microcode is a tuple of information parameterizing certain\n * centralized processing of a packet.  For example, it roughly\n * specifies what payloads are expected in this message.\n * The microcode is selected primarily based on the state.\n * In Phase 1, the payload structure often depends on the\n * authentication technique, so that too plays a part in selecting\n * the state_microcode to use.\n */\n\nstruct state_microcode {\n\tenum state_kind state, next_state;\n\tlset_t flags;\n\tlset_t req_payloads;    /* required payloads (allows just one) */\n\tlset_t opt_payloads;    /* optional payloads (any mumber) */\n\t/* if not ISAKMP_NEXT_NONE, process_packet will emit HDR with this as np */\n\tu_int8_t first_out_payload;\n\tenum event_type timeout_event;\n\tstate_transition_fn *processor;\n};\n\n/* State Microcode Flags, in several groups */\n\n/* Oakley Auth values: to which auth values does this entry apply?\n * Most entries will use SMF_ALL_AUTH because they apply to all.\n * Note: SMF_ALL_AUTH matches 0 for those circumstances when no auth\n * has been set.\n */\n#define SMF_ALL_AUTH    LRANGE(0, OAKLEY_AUTH_ROOF - 1)\n#define SMF_PSK_AUTH    LELEM(OAKLEY_PRESHARED_KEY)\n#define SMF_DS_AUTH     (LELEM(OAKLEY_DSS_SIG) | LELEM(OAKLEY_RSA_SIG))\n#define SMF_PKE_AUTH    LELEM(OAKLEY_RSA_ENC)\n#define SMF_RPKE_AUTH   LELEM(OAKLEY_RSA_REVISED_MODE)\n\n/* misc flags */\n#define SMF_INITIATOR   LELEM(OAKLEY_AUTH_ROOF + 0)\n#define SMF_FIRST_ENCRYPTED_INPUT       LELEM(OAKLEY_AUTH_ROOF + 1)\n#define SMF_INPUT_ENCRYPTED     LELEM(OAKLEY_AUTH_ROOF + 2)\n#define SMF_OUTPUT_ENCRYPTED    LELEM(OAKLEY_AUTH_ROOF + 3)\n#define SMF_RETRANSMIT_ON_DUPLICATE     LELEM(OAKLEY_AUTH_ROOF + 4)\n\n#define SMF_ENCRYPTED (SMF_INPUT_ENCRYPTED | SMF_OUTPUT_ENCRYPTED)\n\n/* this state generates a reply message */\n#define SMF_REPLY   LELEM(OAKLEY_AUTH_ROOF + 5)\n\n/* this state completes P1, so any pending P2 negotiations should start */\n#define SMF_RELEASE_PENDING_P2  LELEM(OAKLEY_AUTH_ROOF + 6)\n\n/* if we have canoncalized the authentication from XAUTH mode */\n#define SMF_XAUTH_AUTH  LELEM(OAKLEY_AUTH_ROOF + 7)\n\n/* end of flags */\n\nstatic state_transition_fn      /* forward declaration */\n\tunexpected,\n\tinformational;\n\n/* v1_state_microcode_table is a table of all state_microcode tuples.\n * It must be in order of state (the first element).\n * After initialization, ike_microcode_index[s] points to the\n * first entry in v1_state_microcode_table for state s.\n * Remember that each state name in Main or Quick Mode describes\n * what has happened in the past, not what this message is.\n */\n\nstatic const struct state_microcode\n\t*ike_microcode_index[STATE_IKE_ROOF - STATE_IKE_FLOOR];\n\nstatic const struct state_microcode v1_state_microcode_table[] = {\n\n#define PT(n) ISAKMP_NEXT_ ## n\n#define P(n) LELEM(PT(n))\n\n\t/***** Phase 1 Main Mode *****/\n\n\t/* No state for main_outI1: --> HDR, SA */\n\n\t/* STATE_MAIN_R0: I1 --> R1\n\t * HDR, SA --> HDR, SA\n\t */\n\t{ STATE_MAIN_R0, STATE_MAIN_R1,\n\t  SMF_ALL_AUTH | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR), PT(NONE),\n\t  EVENT_v1_RETRANSMIT, main_inI1_outR1 },\n\n\t/* STATE_MAIN_I1: R1 --> I2\n\t * HDR, SA --> auth dependent\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: --> HDR, KE, Ni\n\t * SMF_PKE_AUTH:\n\t *\t--> HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t * SMF_RPKE_AUTH:\n\t *\t--> HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t * Note: since we don't know auth at start, we cannot differentiate\n\t * microcode entries based on it.\n\t */\n\t{ STATE_MAIN_I1, STATE_MAIN_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR), PT(NONE), /* don't know yet */\n\t  EVENT_v1_RETRANSMIT, main_inR1_outI2 },\n\n\t/* STATE_MAIN_R1: I2 --> R2\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: HDR, KE, Ni --> HDR, KE, Nr\n\t * SMF_PKE_AUTH: HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t *\t    --> HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t * SMF_RPKE_AUTH:\n\t *\t    HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t *\t    --> HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t */\n\t{ STATE_MAIN_R1, STATE_MAIN_R2,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY\n\t  , P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC), PT(NONE)\n\t  , EVENT_v1_RETRANSMIT, main_inI2_outR2 },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_REPLY,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR) | P(HASH), PT(KE),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_RPKE_AUTH | SMF_REPLY,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR) | P(HASH) | P(CERT), PT(\n\t\t  NONCE),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t/* for states from here on, output message must be encrypted */\n\n\t/* STATE_MAIN_I2: R2 --> I3\n\t * SMF_PSK_AUTH: HDR, KE, Nr --> HDR*, IDi1, HASH_I\n\t * SMF_DS_AUTH: HDR, KE, Nr --> HDR*, IDi1, [ CERT, ] SIG_I\n\t * SMF_PKE_AUTH: HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t *\t    --> HDR*, HASH_I\n\t * SMF_RPKE_AUTH: HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t *\t    --> HDR*, HASH_I\n\t */\n\t{ STATE_MAIN_I2, STATE_MAIN_I3,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED |\n\t\tSMF_REPLY\n\t  , P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC), PT(ID)\n\t  , EVENT_v1_RETRANSMIT, main_inR2_outI3 },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR), PT(HASH),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR), PT(HASH),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t/* for states from here on, input message must be encrypted */\n\n\t/* STATE_MAIN_R2: I3 --> R3\n\t * SMF_PSK_AUTH: HDR*, IDi1, HASH_I --> HDR*, IDr1, HASH_R\n\t * SMF_DS_AUTH: HDR*, IDi1, [ CERT, ] SIG_I --> HDR*, IDr1, [ CERT, ] SIG_R\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_I --> HDR*, HASH_R\n\t */\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inI3_outR3 },\n\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inI3_outR3 },\n\n\t{ STATE_MAIN_R2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, unexpected /* ??? not yet implemented */ },\n\n\t/* STATE_MAIN_I3: R3 --> done\n\t * SMF_PSK_AUTH: HDR*, IDr1, HASH_R --> done\n\t * SMF_DS_AUTH: HDR*, IDr1, [ CERT, ] SIG_R --> done\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_R --> done\n\t * May initiate quick mode by calling quick_outI1\n\t */\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_PSK_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inR3 },\n\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_DS_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inR3 },\n\n\t{ STATE_MAIN_I3, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, unexpected /* ??? not yet implemented */ },\n\n\t/* STATE_MAIN_R3: can only get here due to packet loss */\n\t{ STATE_MAIN_R3, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY,\n\t  PT(NONE), EVENT_NULL, unexpected },\n\n\t/* STATE_MAIN_I4: can only get here due to packet loss */\n\t{ STATE_MAIN_I4, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  PT(NONE), EVENT_NULL, unexpected },\n\n\t/***** Phase 1 Aggressive Mode *****/\n\n\t/* No initial state for aggr_outI1:\n\t * SMF_DS_AUTH (RFC 2409 5.1) and SMF_PSK_AUTH (RFC 2409 5.4):\n\t * -->HDR, SA, KE, Ni, IDii\n\t *\n\t * Not implemented:\n\t * RFC 2409 5.2: --> HDR, SA, [ HASH(1),] KE, <IDii_b>Pubkey_r, <Ni_b>Pubkey_r\n\t * RFC 2409 5.3: --> HDR, SA, [ HASH(1),] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDii_b>Ke_i [, <Cert-I_b>Ke_i ]\n\t */\n\n\t/* STATE_AGGR_R0:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Ni, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, HASH_R\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t */\n\t{ STATE_AGGR_R0, STATE_AGGR_R1,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC), PT(NONE),\n\t  EVENT_v1_RETRANSMIT, aggr_inI1_outR1 },\n\n\t/* STATE_AGGR_I1:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Nr, IDir, HASH_R\n\t *           --> HDR*, HASH_I\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t *           --> HDR*, [CERT,] SIG_I\n\t */\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_PSK_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(HASH), P(VID) | P(NATD_RFC),\n\t  PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inR1_outI2 },\n\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(SIG), P(VID) | P(NATD_RFC),\n\t  PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inR1_outI2 },\n\n\t/* STATE_AGGR_R1:\n\t * SMF_PSK_AUTH: HDR*, HASH_I --> done\n\t * SMF_DS_AUTH:  HDR*, SIG_I  --> done\n\t */\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(NATD_RFC), PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inI2 },\n\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(SIG), P(VID) | P(NATD_RFC), PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inI2 },\n\n\t/* STATE_AGGR_I2: can only get here due to packet loss */\n\t{ STATE_AGGR_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY, PT(NONE), EVENT_NULL, unexpected },\n\n\t/* STATE_AGGR_R2: can only get here due to packet loss */\n\t{ STATE_AGGR_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY, PT(NONE), EVENT_NULL, unexpected },\n\n\t/***** Phase 2 Quick Mode *****/\n\n\t/* No state for quick_outI1:\n\t * --> HDR*, HASH(1), SA, Nr [, KE ] [, IDci, IDcr ]\n\t */\n\n\t/* STATE_QUICK_R0:\n\t * HDR*, HASH(1), SA, Ni [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ]\n\t * Installs inbound IPsec SAs.\n\t * Because it may suspend for asynchronous DNS, first_out_payload\n\t * is set to NONE to suppress early emission of HDR*.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_R0, STATE_QUICK_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY\n\t  , P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(\n\t\t  NATOA_RFC), PT(NONE)\n\t  , EVENT_v1_RETRANSMIT, quick_inI1_outR1 },\n\n\t/* STATE_QUICK_I1:\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(3)\n\t * Installs inbound and outbound IPsec SAs, routing, etc.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_I1, STATE_QUICK_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED | SMF_REPLY\n\t  , P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(\n\t\t  NATOA_RFC), PT(HASH)\n\t  , EVENT_SA_REPLACE, quick_inR1_outI2 },\n\n\t/* STATE_QUICK_R1: HDR*, HASH(3) --> done\n\t * Installs outbound IPsec SAs, routing, etc.\n\t */\n\t{ STATE_QUICK_R1, STATE_QUICK_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY, PT(NONE),\n\t  EVENT_SA_REPLACE, quick_inI2 },\n\n\t/* STATE_QUICK_I2: can only happen due to lost packet */\n\t{ STATE_QUICK_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, unexpected },\n\n\t/* STATE_QUICK_R2: can only happen due to lost packet */\n\t{ STATE_QUICK_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, unexpected },\n\n\t/***** informational messages *****/\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR N/D\n\t * Unencrypted: must not occur after ISAKMP Phase 1 exchange of keying material.\n\t */\n\t/* STATE_INFO: */\n\t{ STATE_INFO, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, informational },\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR* N/D\n\t */\n\t/* STATE_INFO_PROTECTED: */\n\t{ STATE_INFO_PROTECTED, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY, PT(NONE),\n\t  EVENT_NULL, informational },\n\n\t{ STATE_XAUTH_R0, STATE_XAUTH_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_NULL, xauth_inR0 }, /*Re-transmit may be done by previous state*/\n\n\t{ STATE_XAUTH_R1, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_SA_REPLACE, xauth_inR1 },\n\n#if 0\n\t/* for situation where there is XAUTH + ModeCFG */\n\t{ STATE_XAUTH_R2, STATE_XAUTH_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_SA_REPLACE, xauth_inR2 },\n\n\t{ STATE_XAUTH_R3, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_SA_REPLACE, xauth_inR3 },\n#endif\n\n/* MODE_CFG_x:\n * Case R0:  Responder\t->\tInitiator\n *\t\t\t<-\tReq(addr=0)\n *\t    Reply(ad=x)\t->\n *\n * Case R1: Set(addr=x)\t->\n *\t\t\t<-\tAck(ok)\n */\n\n\t{ STATE_MODE_CFG_R0, STATE_MODE_CFG_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, modecfg_inR0 },\n\n\t{ STATE_MODE_CFG_R1, STATE_MODE_CFG_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, modecfg_inR1 },\n\n\t{ STATE_MODE_CFG_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, unexpected },\n\n\t{ STATE_MODE_CFG_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, modecfg_inR1 },\n\n\t{ STATE_XAUTH_I0, STATE_XAUTH_I1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, xauth_inI0 },\n\n\t{ STATE_XAUTH_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, xauth_inI1 },\n\n#undef P\n#undef PT\n};\n\nvoid init_ikev1(void)\n{\n\t/* fill ike_microcode_index:\n\t * make ike_microcode_index[s] point to first entry in\n\t * v1_state_microcode_table for state s (backward scan makes this easier).\n\t * Check that table is in order -- catch coding errors.\n\t * For what it's worth, this routine is idempotent.\n\t */\n\tconst struct state_microcode *t;\n\n\tfor (t = &v1_state_microcode_table[elemsof(v1_state_microcode_table) - 1];;)\n\t{\n\t\tpassert(STATE_IKE_FLOOR <= t->state &&\n\t\t\tt->state < STATE_IKE_ROOF);\n\t\tike_microcode_index[t->state - STATE_IKE_FLOOR] = t;\n\t\tif (t == v1_state_microcode_table)\n\t\t\tbreak;\n\t\tt--;\n\t\tpassert(t[0].state <= t[1].state);\n\t}\n}\n\nstatic stf_status unexpected(struct msg_digest *md)\n{\n\tloglog(RC_LOG_SERIOUS, \"unexpected message received in state %s\",\n\t       enum_name(&state_names, md->st->st_state));\n\treturn STF_IGNORE;\n}\n\n/*\n * RFC 2408 Section 4.6\n *\n *  #   Initiator  Direction Responder  NOTE\n * (1)  HDR*; N/D     =>                Error Notification or Deletion\n */\nstatic stf_status informational(struct msg_digest *md)\n{\n\tstruct payload_digest *const n_pld = md->chain[ISAKMP_NEXT_N];\n\n\t/* If the Notification Payload is not null... */\n\tif (n_pld != NULL) {\n\t\tpb_stream *const n_pbs = &n_pld->pbs;\n\t\tstruct isakmp_notification *const n =\n\t\t\t&n_pld->payload.notification;\n\t\tstruct state *st = md->st;    /* may be NULL */\n\n\t\t/* Switch on Notification Type (enum) */\n\t\t/* note that we _can_ get notification payloads unencrypted\n\t\t * once we are at least in R3/I4.\n\t\t * and that the handler is expected to treat them suspiciously.\n\t\t */\n\t\tDBG(DBG_CONTROL, DBG_log(\"processing informational %s (%d)\",\n\t\t\t\t\t enum_name(&ikev1_notify_names,\n\t\t\t\t\t\t   n->isan_type),\n\t\t\t\t\t n->isan_type));\n\n\t\tswitch (n->isan_type) {\n\t\tcase R_U_THERE:\n\t\t\tif (st == NULL) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"received bogus  R_U_THERE informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inI_outR(st, n, n_pbs);\n\n\t\tcase R_U_THERE_ACK:\n\t\t\tif (st == NULL) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"received bogus R_U_THERE_ACK informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inR(st, n, n_pbs);\n\n\t\tcase PAYLOAD_MALFORMED:\n\t\t\tif (st != NULL) {\n\t\t\t\tst->hidden_variables.st_malformed_received++;\n\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"received %u malformed payload notifies\",\n\t\t\t\t\tst->hidden_variables.st_malformed_received);\n\n\t\t\t\tif (st->hidden_variables.st_malformed_sent >\n\t\t\t\t    MAXIMUM_MALFORMED_NOTIFY / 2 &&\n\t\t\t\t    ((st->hidden_variables.st_malformed_sent +\n\t\t\t\t      st->hidden_variables.\n\t\t\t\t      st_malformed_received) >\n\t\t\t\t     MAXIMUM_MALFORMED_NOTIFY)) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"too many malformed payloads (we sent %u and received %u\",\n\t\t\t\t\t\tst->hidden_variables.st_malformed_sent,\n\t\t\t\t\t\tst->hidden_variables.st_malformed_received);\n\t\t\t\t\tdelete_state(st);\n\t\t\t\t\tmd->st = st = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn STF_IGNORE;\n\n\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tif (st != NULL && IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\t/* Saving connection name and whack sock id */\n\t\t\t\tconst char *tmp_name = st->st_connection->name;\n\t\t\t\tint tmp_whack_sock = dup_any(st->st_whack_sock);\n\n\t\t\t\t/* deleting ISAKMP SA with the current remote peer */\n\t\t\t\tdelete_state(st);\n\t\t\t\tmd->st = st = NULL;\n\n\t\t\t\t/* to find and store the connection associated with tmp_name */\n\t\t\t\t/* ??? how do we know that tmp_name hasn't been freed? */\n\t\t\t\tstruct connection *tmp_c = con_by_name(tmp_name, FALSE);\n\n\t\t\t\tDBG_cond_dump(DBG_PARSING,\n\t\t\t\t\t      \"redirected remote end info:\", n_pbs->cur + pbs_left(\n\t\t\t\t\t\t      n_pbs) - 4, 4);\n\n\t\t\t\t/* Current remote peer info */\n\t\t\t\t{\n\n\t\t\t\t\tipstr_buf b;\n\t\t\t\t\tconst struct spd_route *tmp_spd =\n\t\t\t\t\t\t&tmp_c->spd;\n\t\t\t\t\tint count_spd = 0;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"spd route number: %d\",\n\t\t\t\t\t\t\t    ++count_spd));\n\n\t\t\t\t\t\t/**that info**/\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that id kind: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.id.kind));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that id ipaddr: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.id.ip_addr, &b)));\n\t\t\t\t\t\tif (tmp_spd->that.id.name.ptr\n\t\t\t\t\t\t    != NULL)\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t\t    DBG_dump_chunk(\n\t\t\t\t\t\t\t\t    \"that id name\",\n\t\t\t\t\t\t\t\t    tmp_spd->\n\t\t\t\t\t\t\t\t    that.id.\n\t\t\t\t\t\t\t\t    name));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that host_addr: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.host_addr, &b)));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that nexthop: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.host_nexthop, &b)));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that srcip: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.host_srcip, &b)));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that client_addr: %s, maskbits:%d\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.client.addr, &b),\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    client.maskbits));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_client: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_client));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_client_wildcard: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_client_wildcard));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_port_wildcard: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_port_wildcard));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_id_wildcards: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_id_wildcards));\n\n\t\t\t\t\t\ttmp_spd = tmp_spd->spd_next;\n\t\t\t\t\t} while (tmp_spd != NULL);\n\n\t\t\t\t\tif (tmp_c->interface != NULL) {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"Current interface_addr: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_c->interface->ip_addr, &b)));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp_c->gw_info != NULL) {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE, {\n\t\t\t\t\t\t\t    DBG_log(\"Current gw_client_addr: %s\",\n\t\t\t\t\t\t\t\t    ipstr(&tmp_c->gw_info->client_id.ip_addr, &b));\n\t\t\t\t\t\t\t    DBG_log(\"Current gw_gw_addr: %s\",\n\t\t\t\t\t\t\t\t    ipstr(&tmp_c->gw_info->gw_id.ip_addr, &b));\n\t\t\t\t\t\t    });\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/* storing old address for comparison purposes */\n\t\t\t\tip_address old_addr = tmp_c->spd.that.host_addr;\n\n\t\t\t\t/* Decoding remote peer address info where connection has to be redirected to */\n\t\t\t\tmemcpy(&tmp_c->spd.that.host_addr.u.v4.sin_addr.s_addr,\n\t\t\t\t\t(u_int32_t *)(n_pbs->cur +\n\t\t\t\t\t\t      pbs_left(n_pbs) - 4),\n\t\t\t\t\tsizeof(tmp_c->spd.that.host_addr.u.v4.\n\t\t\t\t\t       sin_addr.\n\t\t\t\t\t       s_addr));\n\n\t\t\t\t/* Modifying connection info to store the redirected remote peer info */\n\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t    DBG_log(\"Old host_addr_name : %s\",\n\t\t\t\t\t    tmp_c->spd.that.host_addr_name));\n\t\t\t\ttmp_c->spd.that.host_addr_name = NULL;\n\t\t\t\ttmp_c->spd.that.id.ip_addr =\n\t\t\t\t\ttmp_c->spd.that.host_addr;\n\n\t\t\t\tDBG(DBG_CONTROLMORE, {\n\t\t\t\t\tipstr_buf b;\n\t\t\t\t\tif (sameaddr(&tmp_c->spd.this.\n\t\t\t\t\t\t     host_nexthop,\n\t\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\t\tDBG_log(\"Old remote addr %s\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"Old this host next hop %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.this.host_nexthop, &b));\n\t\t\t\t\t\ttmp_c->spd.this.host_nexthop = tmp_c->spd.that.host_addr;\n\t\t\t\t\t\tDBG_log(\"New this host next hop %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.this.host_nexthop, &b));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sameaddr(&tmp_c->spd.that.\n\t\t\t\t\t\t     host_srcip,\n\t\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\t\tDBG_log(\"Old that host srcip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.host_srcip, &b));\n\t\t\t\t\t\ttmp_c->spd.that.host_srcip = tmp_c->spd.that.host_addr;\n\t\t\t\t\t\tDBG_log(\"New that host srcip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.host_srcip, &b));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sameaddr(&tmp_c->spd.that.\n\t\t\t\t\t\t     client.addr,\n\t\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\t\tDBG_log(\"Old that client ip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.client.addr, &b));\n\t\t\t\t\t\ttmp_c->spd.that.client.addr = tmp_c->spd.that.host_addr;\n\t\t\t\t\t\tDBG_log(\"New that client ip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.client.addr, &b));\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\ttmp_c->host_pair->him.addr =\n\t\t\t\t\ttmp_c->spd.that.host_addr;\n\n\t\t\t\t/* Initiating connection to the redirected peer */\n\t\t\t\tinitiate_connection(tmp_name, tmp_whack_sock,\n\t\t\t\t\t\t    LEMPTY, pcim_demand_crypto);\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"received and ignored informational message with ISAKMP_N_CISCO_LOAD_BALANCE for unestablished state.\");\n\t\t\treturn STF_IGNORE;\n\t\tdefault:\n\t\t\tif (st != NULL &&\n\t\t\t    (st->st_connection->extra_debugging &\n\t\t\t     IMPAIR_DIE_ONINFO)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"received unhandled informational notification payload %d: '%s'\",\n\t\t\t\t       n->isan_type,\n\t\t\t\t       enum_name(&ikev1_notify_names,\n\t\t\t\t\t\t n->isan_type));\n\t\t\t\treturn STF_FATAL;\n\t\t\t}\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"received and ignored informational message\");\n\t\t\treturn STF_IGNORE;\n\t\t}\n\t} else {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"received and ignored empty informational notification payload\");\n\t\treturn STF_IGNORE;\n\t}\n}\n\n/* create output HDR as replica of input HDR - IKEv1 only */\nvoid ikev1_echo_hdr(struct msg_digest *md, bool enc, u_int8_t np)\n{\n\tstruct isakmp_hdr hdr = md->hdr; /* mostly same as incoming header */\n\n\t/* make sure we start with a clean buffer */\n\tinit_out_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\thdr.isa_flags = 0; /* zero all flags */\n\tif (enc)\n\t\thdr.isa_flags |= ISAKMP_FLAGS_v1_ENCRYPTION;\n\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\thdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;\n\t}\n\n\t/* there is only one IKEv1 version, and no new one will ever come - no need to set version */\n\thdr.isa_np = np;\n\tif (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream, &md->rbody))\n\t\timpossible(); /* surely must have room and be well-formed */\n}\n\n/* process an input packet, possibly generating a reply.\n *\n * If all goes well, this routine eventually calls a state-specific\n * transition function.\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_v1_packet(struct msg_digest **mdp)\n{\n\tstruct msg_digest *md = *mdp;\n\tconst struct state_microcode *smc;\n\tbool new_iv_set = FALSE;\n\tstruct state *st = NULL;\n\tenum state_kind from_state = STATE_UNDEFINED;   /* state we started in */\n\n#define SEND_NOTIFICATION(t) { \\\n\t\tif (st != NULL) \\\n\t\t\tsend_notification_from_state(st, from_state, t); \\\n\t\telse \\\n\t\t\tsend_notification_from_md(md, t); }\n\n\tswitch (md->hdr.isa_xchg) {\n#ifdef NOTYET\n\tcase ISAKMP_XCHG_NONE:\n\tcase ISAKMP_XCHG_BASE:\n\tcase ISAKMP_XCHG_AO:\n#endif\n\n\tcase ISAKMP_XCHG_AGGR:\n\tcase ISAKMP_XCHG_IDPROT: /* part of a Main Mode exchange */\n\t\tif (md->hdr.isa_msgid != v1_MAINMODE_MSGID) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"Message ID was 0x%08lx but should be zero in phase 1\",\n\t\t\t\t(unsigned long) md->hdr.isa_msgid);\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_icookie)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"Initiator Cookie must not be zero in phase 1 message\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_rcookie)) {\n\t\t\t/* initial message from initiator\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\t\tlibreswan_log(\"initial phase 1 message is invalid:\"\n\t\t\t\t\t      \" its Encrypted Flag is on\");\n\t\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* don't build a state until the message looks tasty */\n\t\t\tfrom_state = (md->hdr.isa_xchg == ISAKMP_XCHG_IDPROT ?\n\t\t\t\t      STATE_MAIN_R0 : STATE_AGGR_R0);\n\t\t} else {\n\t\t\t/* not an initial message */\n\n\t\t\tst = find_state_ikev1(md->hdr.isa_icookie,\n\t\t\t\t\t      md->hdr.isa_rcookie,\n\t\t\t\t\t      md->hdr.isa_msgid);\n\n\t\t\tif (st == NULL) {\n\t\t\t\t/* perhaps this is a first message from the responder\n\t\t\t\t * and contains a responder cookie that we've not yet seen.\n\t\t\t\t */\n\t\t\t\tst = find_state_ikev1(md->hdr.isa_icookie,\n\t\t\t\t\t\t      zero_cookie,\n\t\t\t\t\t\t      md->hdr.isa_msgid);\n\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"phase 1 message is part of an unknown exchange\");\n\t\t\t\t\t/* XXX Could send notification back */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_INFO:  /* an informational exchange */\n\t\tst = ikev1_find_info_state(md->hdr.isa_icookie, md->hdr.isa_rcookie,\n\t\t\t\t     &md->sender, v1_MAINMODE_MSGID);\n\n\t\tif (st == NULL) {\n\t\t\t/*\n\t\t\t * might be an informational response to our first\n\t\t\t * message, in which case, we don't know the rcookie yet.\n\t\t\t */\n\t\t\tst = find_state_ikev1(md->hdr.isa_icookie, zero_cookie,\n\t\t\t\t\t      v1_MAINMODE_MSGID);\n\t\t}\n\n\t\tif (st != NULL)\n\t\t\tset_cur_state(st);\n\n\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\tbool quiet = (st == NULL ||\n\t\t\t\t     (st->st_connection->policy & POLICY_OPPORTUNISTIC));\n\n\t\t\tif (st == NULL) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\t\"Informational Exchange is for an unknown (expired?) SA with MSGID:0x%08lx\",\n\t\t\t\t\t\t\t(unsigned long)md->hdr.isa_msgid));\n\n\t\t\t\t/* Let's try to log some info about these to track them down */\n\t\t\t\tDBG(DBG_CONTROL, {\n\t\t\t\t\t    DBG_dump(\"- unknown SA's md->hdr.isa_icookie:\",\n\t\t\t\t\t\t    md->hdr.isa_icookie,\n\t\t\t\t\t\t    COOKIE_SIZE);\n\t\t\t\t\t    DBG_dump(\"- unknown SA's md->hdr.isa_rcookie:\",\n\t\t\t\t\t\t    md->hdr.isa_rcookie,\n\t\t\t\t\t\t    COOKIE_SIZE);\n\t\t\t\t    });\n\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IS_ISAKMP_ENCRYPTED(st->st_state)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"encrypted Informational Exchange message is invalid because no key is known\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Informational Exchange message is invalid because it has a Message ID of 0\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Informational Exchange message is invalid because it has a previously used Message ID (0x%08lx)\",\n\t\t\t\t\t\t(unsigned long)md->hdr.isa_msgid);\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_msgid_reserved = FALSE;\n\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_INFO_PROTECTED;\n\t\t} else {\n\t\t\tif (st != NULL &&\n\t\t\t    IS_ISAKMP_AUTHENTICATED(st->st_state)) {\n\t\t\t\tif ((st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Informational Exchange message must be encrypted\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfrom_state = STATE_INFO;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_QUICK: /* part of a Quick Mode exchange */\n\n\t\tif (is_zero_cookie(md->hdr.isa_icookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"Quick Mode message is invalid because it has an Initiator Cookie of 0\"));\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_rcookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"Quick Mode message is invalid because it has a Responder Cookie of 0\"));\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"Quick Mode message is invalid because it has a Message ID of 0\"));\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tst = find_state_ikev1(md->hdr.isa_icookie, md->hdr.isa_rcookie,\n\t\t\t\t      md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\t/* No appropriate Quick Mode state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tst = find_state_ikev1(md->hdr.isa_icookie,\n\t\t\t\t\t      md->hdr.isa_rcookie,\n\t\t\t\t\t      v1_MAINMODE_MSGID);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"Quick Mode message is for a non-existent (expired?) ISAKMP SA\"));\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"Cannot do Quick Mode until XAUTH done.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Have we just given an IP address to peer? */\n\t\t\tif (st->st_state == STATE_MODE_CFG_R2) {\n\t\t\t\t/* ISAKMP is up... */\n\t\t\t\tchange_state(st, STATE_MAIN_R3);\n\t\t\t}\n\n#ifdef SOFTREMOTE_CLIENT_WORKAROUND\n\t\t\t/* See: http://popoludnica.pl/?id=10100110 */\n\t\t\tif (st->st_state == STATE_MODE_CFG_R1) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"SoftRemote workaround: Cannot do Quick Mode until MODECFG done.\");\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\tset_cur_state(st);\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tif (DBGP(DBG_OPPO) || (st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Quick Mode message is unacceptable because it is for an incomplete ISAKMP SA\");\n\t\t\t\t}\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED /* XXX ? */);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tif (DBGP(DBG_OPPO) || (st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Quick Mode I1 message is unacceptable because it uses a previously used Message ID 0x%08lx (perhaps this is a duplicated packet)\",\n\t\t\t\t\t\t(unsigned long) md->hdr.isa_msgid);\n\t\t\t\t}\n\t\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_msgid_reserved = FALSE;\n\n\t\t\t/* Quick Mode Initial IV */\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_QUICK_R0;\n\t\t} else {\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tif (DBGP(DBG_OPPO) ||\n\t\t\t\t    (st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tlibreswan_log(\"Cannot do Quick Mode until XAUTH done.\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_MODE_CFG:\n\t\tif (is_zero_cookie(md->hdr.isa_icookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"Mode Config message is invalid because it has an Initiator Cookie of 0\"));\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_rcookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"Mode Config message is invalid because it has a Responder Cookie of 0\"));\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == 0) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"Mode Config message is invalid because it has a Message ID of 0\"));\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tst = ikev1_find_info_state(md->hdr.isa_icookie, md->hdr.isa_rcookie,\n\t\t\t\t     &md->sender, md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"No appropriate Mode Config state yet.See if we have a Main Mode state\"));\n\t\t\t/* No appropriate Mode Config state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tst = ikev1_find_info_state(md->hdr.isa_icookie,\n\t\t\t\t\t     md->hdr.isa_rcookie,\n\t\t\t\t\t     &md->sender, 0);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"Mode Config message is for a non-existent (expired?) ISAKMP SA\"));\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tset_cur_state(st);\n\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\" processing received \"\n\t\t\t\t\t\t     \"isakmp_xchg_type %s.\",\n\t\t\t\t\t\t     enum_show(&ikev1_exchange_names,\n\t\t\t\t\t\t\t       md->hdr.isa_xchg)));\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\" this is a%s%s%s%s\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.xauth_server ?\n\t\t\t\t\t\t     \" xauthserver\" : \"\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.xauth_client ?\n\t\t\t\t\t\t     \" xauthclient\" : \"\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.modecfg_server ?\n\t\t\t\t\t\t     \" modecfgserver\" : \"\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.modecfg_client  ?\n\t\t\t\t\t\t     \" modecfgclient\" : \"\"\n\t\t\t\t\t\t     ));\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\"Mode Config message is unacceptable because it is for an incomplete ISAKMP SA (state=%s)\",\n\t\t\t\t       enum_name(&state_names, st->st_state)));\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\" call  init_phase2_iv\"));\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\t/*\n\t\t\t * okay, now we have to figure out if we are receiving a bogus\n\t\t\t * new message in an oustanding XAUTH server conversation\n\t\t\t * (i.e. a reply to our challenge)\n\t\t\t * (this occurs with some broken other implementations).\n\t\t\t *\n\t\t\t * or if receiving for the first time, an XAUTH challenge.\n\t\t\t *\n\t\t\t * or if we are getting a MODECFG request.\n\t\t\t *\n\t\t\t * we distinguish these states because we cannot both be an\n\t\t\t * XAUTH server and client, and our policy tells us which\n\t\t\t * one we are.\n\t\t\t *\n\t\t\t * to complicate further, it is normal to start a new msgid\n\t\t\t * when going from one state to another, or when restarting\n\t\t\t * the challenge.\n\t\t\t *\n\t\t\t */\n\n\t\t\tif (st->st_connection->spd.this.xauth_server &&\n\t\t\t    st->st_state == STATE_XAUTH_R1 &&\n\t\t\t    st->quirks.xauth_ack_msgid) {\n\t\t\t\tfrom_state = STATE_XAUTH_R1;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s state is STATE_XAUTH_R1 and quirks.xauth_ack_msgid is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.xauth_client\n\t\t\t\t   &&\n\t\t\t\t   IS_PHASE1(st->st_state)) {\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is xauthclient and IS_PHASE1() is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.xauth_client\n\t\t\t\t   &&\n\t\t\t\t   st->st_state == STATE_XAUTH_I1) {\n\t\t\t\t/*\n\t\t\t\t * in this case, we got a new MODECFG message after I0, maybe\n\t\t\t\t * because it wants to start over again.\n\t\t\t\t */\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is xauthclient and state == STATE_XAUTH_I1\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.modecfg_server\n\t\t\t\t   &&\n\t\t\t\t   IS_PHASE1(st->st_state)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R0;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is modecfgserver and IS_PHASE1() is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.modecfg_client\n\t\t\t\t   &&\n\t\t\t\t   IS_PHASE1(st->st_state)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R1;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is modecfgclient and IS_PHASE1() is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else {\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\"received isakmp_xchg_type %s\",\n\t\t\t\t\t    enum_show(&ikev1_exchange_names,\n\t\t\t\t\t\t      md->hdr.isa_xchg)));\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\"this is a%s%s%s%s in state %s. Reply with UNSUPPORTED_EXCHANGE_TYPE\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.xauth_server ?\n\t\t\t\t\t    \" xauthserver\" : \"\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.xauth_client ?\n\t\t\t\t\t    \" xauthclient\" : \"\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.modecfg_server ?\n\t\t\t\t\t    \" modecfgserver\" :\n\t\t\t\t\t    \"\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.modecfg_client  ?\n\t\t\t\t\t    \" modecfgclient\" :\n\t\t\t\t\t    \"\",\n\t\t\t\t\t    enum_name(&\n\t\t\t\t\t\t      state_names,\n\t\t\t\t\t\t      st->st_state)\n\t\t\t\t\t    ));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (st->st_connection->spd.this.xauth_server &&\n\t\t\t    IS_PHASE1(st->st_state)) {\n\t\t\t\t/* Switch from Phase1 to Mode Config */\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"We were in phase 1, with no state, so we went to XAUTH_R0\"));\n\t\t\t\tchange_state(st, STATE_XAUTH_R0);\n\t\t\t}\n\n\t\t\t/* otherweise, this is fine, we continue in the state we are in */\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_NGRP:\n\tdefault:\n\t\tDBG(DBG_CONTROL, DBG_log(\"unsupported exchange type %s in message\",\n\t\t\t      enum_show(&ikev1_exchange_names, md->hdr.isa_xchg)));\n\t\tSEND_NOTIFICATION(UNSUPPORTED_EXCHANGE_TYPE);\n\t\treturn;\n\t}\n\n\t/* We have found a from_state, and perhaps a state object.\n\t * If we need to build a new state object,\n\t * we wait until the packet has been sanity checked.\n\t */\n\n\t/* We don't support the Commit Flag.  It is such a bad feature.\n\t * It isn't protected -- neither encrypted nor authenticated.\n\t * A man in the middle turns it on, leading to DoS.\n\t * We just ignore it, with a warning.\n\t */\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_COMMIT)\n\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\"IKE message has the Commit Flag set but Pluto doesn't implement this feature due to security concerns; ignoring flag\"));\n\n\n\t/* Handle IKE fragmentation payloads */\n\tif (md->hdr.isa_np == ISAKMP_NEXT_IKE_FRAGMENTATION) {\n\t\tstruct isakmp_ikefrag fraghdr;\n\t\tstruct ike_frag *ike_frag, **i;\n\t\tint last_frag_index = 0;  /* index of the last fragment */\n\t\tpb_stream frag_pbs;\n\n\t\tif (st == NULL) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"received IKE fragment, but have no state. Ignoring packet.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif ((st->st_connection->policy & POLICY_IKE_FRAG_ALLOW) == 0) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t       \"discarding IKE fragment packet - fragmentation not allowed by local policy (ike_frag=no)\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!in_struct(&fraghdr, &isakmp_ikefrag_desc,\n\t\t\t       &md->message_pbs, &frag_pbs) ||\n\t\t    pbs_room(&frag_pbs) != fraghdr.isafrag_length ||\n\t\t    fraghdr.isafrag_np != 0 ||\n\t\t    fraghdr.isafrag_number == 0 || fraghdr.isafrag_number >\n\t\t    16) {\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"received IKE fragment id '%d', number '%u'%s\",\n\t\t\t    fraghdr.isafrag_id,\n\t\t\t    fraghdr.isafrag_number,\n\t\t\t    (fraghdr.isafrag_flags == 1) ? \"(last)\" : \"\"));\n\n\t\tike_frag = alloc_thing(struct ike_frag, \"ike_frag\");\n\t\tike_frag->md = md;\n\t\tike_frag->index = fraghdr.isafrag_number;\n\t\tike_frag->last = (fraghdr.isafrag_flags & 1);\n\t\tike_frag->size = pbs_left(&frag_pbs);\n\t\tike_frag->data = frag_pbs.cur;\n\n#if 0\n/* is this ever hit? It was wrongly checking one byte instead of 4 bytes of marker */\n\t\t/* Strip non-ESP marker from first fragment */\n\t\tif (md->iface->ike_float && ike_frag->index == 1 &&\n\t\t    (ike_frag->size >= NON_ESP_MARKER_SIZE &&\n\t\t     memeq(non_ESP_marker, ike_frag->data,\n\t\t\t    NON_ESP_MARKER_SIZE))) {\n\t\t\tike_frag->data += NON_ESP_MARKER_SIZE;\n\t\t\tike_frag->size -= NON_ESP_MARKER_SIZE;\n\t\t}\n#endif\n\n\t\t/* Add the fragment to the state */\n\t\ti = &st->ike_frags;\n\t\tfor (;;) {\n\t\t\tif (ike_frag != NULL) {\n\t\t\t\t/* Still looking for a place to insert ike_frag */\n\t\t\t\tif (*i == NULL ||\n\t\t\t\t    (*i)->index > ike_frag->index) {\n\t\t\t\t\tike_frag->next = *i;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t} else if ((*i)->index == ike_frag->index) {\n\t\t\t\t\t/* Replace fragment with same index */\n\t\t\t\t\tstruct ike_frag *old = *i;\n\n\t\t\t\t\tike_frag->next = old->next;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\trelease_md(old->md);\n\t\t\t\t\tpfree(old);\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*i == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif ((*i)->last)\n\t\t\t\tlast_frag_index = (*i)->index;\n\n\t\t\ti = &(*i)->next;\n\t\t}\n\n\t\t/* We have the last fragment, reassemble if complete */\n\t\tif (last_frag_index != 0) {\n\t\t\tsize_t size = 0;\n\t\t\tint prev_index = 0;\n\t\t\tstruct ike_frag *frag;\n\n\t\t\tfor (frag = st->ike_frags; frag; frag = frag->next) {\n\t\t\t\tsize += frag->size;\n\t\t\t\tif (frag->index != ++prev_index) {\n\t\t\t\t\tbreak; /* fragment list incomplete */\n\t\t\t\t} else if (frag->index == last_frag_index) {\n\t\t\t\t\tstruct msg_digest *whole_md = alloc_md();\n\t\t\t\t\tu_int8_t *buffer = alloc_bytes(size,\n\t\t\t\t\t\t\t\t       \"IKE fragments buffer\");\n\t\t\t\t\tsize_t offset = 0;\n\n\t\t\t\t\twhole_md->iface = frag->md->iface;\n\t\t\t\t\twhole_md->sender = frag->md->sender;\n\t\t\t\t\twhole_md->sender_port =\n\t\t\t\t\t\tfrag->md->sender_port;\n\n\t\t\t\t\t/* Reassemble fragments in buffer */\n\t\t\t\t\tfrag = st->ike_frags;\n\t\t\t\t\twhile (frag != NULL &&\n\t\t\t\t\t       frag->index <= last_frag_index)\n\t\t\t\t\t{\n\t\t\t\t\t\tpassert(offset + frag->size <=\n\t\t\t\t\t\t\tsize);\n\t\t\t\t\t\tmemcpy(buffer + offset,\n\t\t\t\t\t\t       frag->data, frag->size);\n\t\t\t\t\t\toffset += frag->size;\n\t\t\t\t\t\tfrag = frag->next;\n\t\t\t\t\t}\n\n\t\t\t\t\tinit_pbs(&whole_md->packet_pbs, buffer, size,\n\t\t\t\t\t\t \"packet\");\n\n\t\t\t\t\tprocess_packet(&whole_md);\n\t\t\t\t\trelease_any_md(&whole_md);\n\t\t\t\t\trelease_fragments(st);\n\t\t\t\t\t/* optimize: if receiving fragments, immediately respond with fragments too */\n\t\t\t\t\tst->st_seen_fragments = TRUE;\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\t\" updated IKE fragment state to respond using fragments without waiting for re-transmits\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Don't release the md, taken care of by the ike_frag code */\n\t\t/* ??? I'm not sure -- DHR */\n\t\t*mdp = NULL;\n\t\treturn;\n\t}\n\n\t/* Set smc to describe this state's properties.\n\t * Look up the appropriate microcode based on state and\n\t * possibly Oakley Auth type.\n\t */\n\tpassert(STATE_IKE_FLOOR <= from_state && from_state <= STATE_IKE_ROOF);\n\tsmc = ike_microcode_index[from_state - STATE_IKE_FLOOR];\n\n\tif (st != NULL) {\n\t\toakley_auth_t baseauth =\n\t\t\txauth_calcbaseauth(st->st_oakley.auth);\n\n\t\twhile (!LHAS(smc->flags, baseauth)) {\n\t\t\tsmc++;\n\t\t\tpassert(smc->state == from_state);\n\t\t}\n\t}\n\n\tif (state_busy(st))\n\t\treturn;\n\n\t/* Detect and handle duplicated packets.\n\t * This won't work for the initial packet of an exchange\n\t * because we won't have a state object to remember it.\n\t * If we are in a non-receiving state (terminal), and the preceding\n\t * state did transmit, then the duplicate may indicate that that\n\t * transmission wasn't received -- retransmit it.\n\t * Otherwise, just discard it.\n\t * ??? Notification packets are like exchanges -- I hope that\n\t * they are idempotent!\n\t */\n\tif (st != NULL &&\n\t    st->st_rpacket.ptr != NULL &&\n\t    st->st_rpacket.len == pbs_room(&md->packet_pbs) &&\n\t    memeq(st->st_rpacket.ptr, md->packet_pbs.start,\n\t\t   st->st_rpacket.len)) {\n\t\tif (smc->flags & SMF_RETRANSMIT_ON_DUPLICATE) {\n\t\t\tif (st->st_retransmit < MAXIMUM_v1_ACCEPTED_DUPLICATES) {\n\t\t\t\tst->st_retransmit++;\n\t\t\t\tloglog(RC_RETRANSMISSION,\n\t\t\t\t       \"retransmitting in response to duplicate packet; already %s\",\n\t\t\t\t       enum_name(&state_names, st->st_state));\n\t\t\t\tresend_ike_v1_msg(st,\n\t\t\t\t\t\t  \"retransmit in response to duplicate\");\n\t\t\t} else {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"discarding duplicate packet -- exhausted retransmission; already %s\",\n\t\t\t\t       enum_name(&state_names, st->st_state));\n\t\t\t}\n\t\t} else {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"discarding duplicate packet; already %s\",\n\t\t\t       enum_name(&state_names, st->st_state));\n\t\t}\n\t\treturn;\n\t}\n\n\t/* save values for use in resumption of processing below.\n\t * (may be suspended due to crypto operation not yet complete)\n\t */\n\tmd->st = st;\n\tmd->from_state = from_state;\n\tmd->smc = smc;\n\tmd->new_iv_set = new_iv_set;\n\n\t/*\n\t * look for encrypt packets. We cannot handle them if we have not\n\t * yet calculated the skeyids. We will just store the packet in\n\t * the suspended state, since the calculation is likely underway.\n\t *\n\t * note that this differs from above, because skeyid is calculated\n\t * in between states. (or will be, once DH is async)\n\t *\n\t */\n\tif ((md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) &&\n\t    st != NULL && !st->hidden_variables.st_skeyid_calculated ) {\n\t\tDBG(DBG_CRYPT | DBG_CONTROL, {\n\t\t\tipstr_buf b;\n\t\t\tDBG_log(\"received encrypted packet from %s:%u but exponentiation still in progress\",\n\t\t\t\tipstr(&md->sender, &b),\n\t\t\t\t(unsigned)md->sender_port);\n\t\t});\n\n\t\t/* if there was a previous packet, let it go, and go with most\n\t\t * recent one.\n\t\t */\n\t\tif (st->st_suspended_md != NULL) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"releasing suspended operation before completion: %p\",\n\t\t\t\t    st->st_suspended_md));\n\t\t\trelease_any_md(&st->st_suspended_md);\n\t\t}\n\n\t\tset_suspended(st, md);\n\t\t*mdp = NULL;\n\t\treturn;\n\t}\n\n\tprocess_packet_tail(mdp);\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_packet_tail(struct msg_digest **mdp)\n{\n\tstruct msg_digest *md = *mdp;\n\tstruct state *st = md->st;\n\tenum state_kind from_state = md->from_state;\n\tconst struct state_microcode *smc = md->smc;\n\tbool new_iv_set = md->new_iv_set;\n\tbool self_delete = FALSE;\n\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\tDBG(DBG_CRYPT, {\n\t\t\tipstr_buf b;\n\t\t\tDBG_log(\"received encrypted packet from %s:%u\",\n\t\t\t\tipstr(&md->sender, &b),\n\t\t\t\t(unsigned)md->sender_port);\n\t\t});\n\n\t\tif (st == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"discarding encrypted message for an unknown ISAKMP SA\");\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED /* XXX ? */);\n\t\t\treturn;\n\t\t}\n\t\tif (st->st_skey_ei_nss == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\"discarding encrypted message because we haven't yet negotiated keying material\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Mark as encrypted */\n\t\tmd->encrypted = TRUE;\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_log(\"decrypting %u bytes using algorithm %s\",\n\t\t\t    (unsigned) pbs_left(&md->message_pbs),\n\t\t\t    enum_show(&oakley_enc_names,\n\t\t\t\t      st->st_oakley.encrypt)));\n\n\t\t/* do the specified decryption\n\t\t *\n\t\t * IV is from st->st_iv or (if new_iv_set) st->st_new_iv.\n\t\t * The new IV is placed in st->st_new_iv\n\t\t *\n\t\t * See RFC 2409 \"IKE\" Appendix B\n\t\t *\n\t\t * XXX The IV should only be updated really if the packet\n\t\t * is successfully processed.\n\t\t * We should keep this value, check for a success return\n\t\t * value from the parsing routines and then replace.\n\t\t *\n\t\t * Each post phase 1 exchange generates IVs from\n\t\t * the last phase 1 block, not the last block sent.\n\t\t */\n\t\t{\n\t\t\tconst struct encrypt_desc *e = st->st_oakley.encrypter;\n\n\t\t\tif (pbs_left(&md->message_pbs) % e->enc_blocksize != 0)\n\t\t\t{\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"malformed message: not a multiple of encryption blocksize\");\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* XXX Detect weak keys */\n\n\t\t\t/* grab a copy of raw packet (for duplicate packet detection) */\n\t\t\tclonetochunk(md->raw_packet, md->packet_pbs.start,\n\t\t\t\t     pbs_room(&md->packet_pbs), \"raw packet\");\n\n\t\t\t/* Decrypt everything after header */\n\t\t\tif (!new_iv_set) {\n\t\t\t\tif (st->st_iv_len == 0) {\n\t\t\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\t\t} else {\n\t\t\t\t\t/* use old IV */\n\t\t\t\t\trestore_new_iv(st, st->st_iv, st->st_iv_len);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcrypto_cbc_encrypt(e, FALSE, md->message_pbs.cur,\n\t\t\t\t\t   pbs_left(&md->message_pbs), st);\n\n\t\t}\n\n\t\tDBG_cond_dump(DBG_CRYPT, \"decrypted:\\n\", md->message_pbs.cur,\n\t\t\t      md->message_pbs.roof - md->message_pbs.cur);\n\n\t\tDBG_cond_dump(DBG_CRYPT, \"next IV:\",\n\t\t\t      st->st_new_iv, st->st_new_iv_len);\n\t} else {\n\t\t/* packet was not encryped -- should it have been? */\n\n\t\tif (smc->flags & SMF_INPUT_ENCRYPTED) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"packet rejected: should have been encrypted\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Digest the message.\n\t * Padding must be removed to make hashing work.\n\t * Padding comes from encryption (so this code must be after decryption).\n\t * Padding rules are described before the definition of\n\t * struct isakmp_hdr in packet.h.\n\t */\n\t{\n\t\tstruct payload_digest *pd = md->digest;\n\t\tenum next_payload_types_ikev1 np = md->hdr.isa_np;\n\t\tlset_t needed = smc->req_payloads;\n\t\tconst char *excuse =\n\t\t\tLIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,\n\t\t\t    smc->flags) ?\n\t\t\t\"probable authentication failure (mismatch of preshared secrets?): \"\n\t\t\t:\n\t\t\t\"\";\n\n\t\twhile (np != ISAKMP_NEXT_NONE) {\n\t\t\tstruct_desc *sd = v1_payload_desc(np);\n\n\t\t\tif (pd == &md->digest[PAYLIMIT]) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"more than %d payloads in message; ignored\",\n\t\t\t\t       PAYLIMIT);\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * only do this in main mode. In aggressive mode, there\n\t\t\t * is no negotiation of NAT-T method. Get it right.\n\t\t\t */\n\t\t\tif (st != NULL && st->st_connection != NULL &&\n\t\t\t    (st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)\n\t\t\t{\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_NATD_RFC:\n\t\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t\tif ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t\t\t\t\t * unless we're using NAT-T RFC\n\t\t\t\t\t\t */\n\t\t\t\t\t\tDBG(DBG_NATT,\n\t\t\t\t\t\t    DBG_log(\"st_nat_traversal was: %s\",\n\t\t\t\t\t\t\t    bitnamesof(natt_bit_names,\n\t\t\t\t\t\t\t\t       st->hidden_variables.st_nat_traversal)));\n\t\t\t\t\t\tsd = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd == NULL) {\n\t\t\t\t/* payload type is out of range or requires special handling */\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\t\t\t/* ??? two kinds of ID payloads */\n\t\t\t\t\tsd = (IS_PHASE1(from_state) ||\n\t\t\t\t\t      IS_PHASE15(from_state)) ?\n\t\t\t\t\t\t&isakmp_identification_desc :\n\t\t\t\t\t\t&isakmp_ipsec_identification_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATD_DRAFTS:\n\t\t\t\t\t/* NAT-D was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATD_RFC;\n\t\t\t\t\tsd = v1_payload_desc(np);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATOA_DRAFTS:\n\t\t\t\t\t/* NAT-OA was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATOA_RFC;\n\t\t\t\t\tsd = v1_payload_desc(np);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_SAK: /* or ISAKMP_NEXT_NATD_BADDRAFTS */\n\t\t\t\t\t/*\n\t\t\t\t\t * Official standards say that this is ISAKMP_NEXT_SAK,\n\t\t\t\t\t * a part of Group DOI, something we don't implement.\n\t\t\t\t\t * Old non-updated Cisco gear abused this number in ancient NAT drafts.\n\t\t\t\t\t * We ignore (rather than reject) this in support of people\n\t\t\t\t\t * with crufty Cisco machines.\n\t\t\t\t\t */\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored\",\n\t\t\t\t\t\texcuse);\n\t\t\t\t\t/*\n\t\t\t\t\t * Hack to discard payload, whatever it was.\n\t\t\t\t\t * Since we are skipping the rest of the loop\n\t\t\t\t\t * body we must do some things ourself:\n\t\t\t\t\t * - demarshall the payload\n\t\t\t\t\t * - grab the next payload number (np)\n\t\t\t\t\t * - don't keep payload (don't increment pd)\n\t\t\t\t\t * - skip rest of loop body\n\t\t\t\t\t */\n\t\t\t\t\tif (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,\n\t\t\t\t\t\t       &pd->pbs)) {\n\t\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t\t\t       excuse);\n\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\t\t\t/* NOTE: we do not increment pd! */\n\t\t\t\t\tcontinue;  /* skip rest of the loop */\n\n\t\t\t\tdefault:\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpassert(sd != NULL);\n\t\t\t}\n\n\t\t\tpassert(np < LELEM_ROOF);\n\n\t\t\t{\n\t\t\t\tlset_t s = LELEM(np);\n\n\t\t\t\tif (LDISJOINT(s,\n\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"%smessage ignored because it \"\n\t\t\t\t\t       \"contains an unexpected payload type (%s)\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \"opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));\n\t\t\t\tneeded &= ~s;\n\t\t\t}\n\n\t\t\tif (!in_struct(&pd->payload, sd, &md->message_pbs,\n\t\t\t\t       &pd->pbs)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t       excuse);\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* do payload-type specific debugging */\n\t\t\tswitch (np) {\n\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t/* dump ID section */\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_dump(\"     obj: \", pd->pbs.cur,\n\t\t\t\t\t     pbs_left(&pd->pbs)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* place this payload at the end of the chain for this type */\n\t\t\t{\n\t\t\t\tstruct payload_digest **p;\n\n\t\t\t\tfor (p = &md->chain[np]; *p != NULL;\n\t\t\t\t     p = &(*p)->next)\n\t\t\t\t\t;\n\t\t\t\t*p = pd;\n\t\t\t\tpd->next = NULL;\n\t\t\t}\n\n\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\tpd++;\n\n\t\t\t/* since we've digested one payload happily, it is probably\n\t\t\t * the case that any decryption worked.  So we will not suggest\n\t\t\t * encryption failure as an excuse for subsequent payload\n\t\t\t * problems.\n\t\t\t */\n\t\t\texcuse = \"\";\n\t\t}\n\n\t\tmd->digest_roof = pd;\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    if (pbs_left(&md->message_pbs) != 0)\n\t\t\t\t    DBG_log(\"removing %d bytes of padding\",\n\t\t\t\t\t    (int) pbs_left(&md->message_pbs));\n\t\t    });\n\n\t\tmd->message_pbs.roof = md->message_pbs.cur;\n\n\t\t/* check that all mandatory payloads appeared */\n\n\t\tif (needed != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"message for %s is missing payloads %s\",\n\t\t\t       enum_show(&state_names, from_state),\n\t\t\t       bitnamesof(payload_name_ikev1, needed));\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* more sanity checking: enforce most ordering constraints */\n\n\tif (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5 Exchanges:\n\t\t * \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n\t\t */\n\t\tif (md->chain[ISAKMP_NEXT_SA] != NULL &&\n\t\t    md->hdr.isa_np != ISAKMP_NEXT_SA) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Phase 1 message: does not start with an SA payload\");\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\t} else if (IS_QUICK(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode\n\t\t *\n\t\t * \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n\t\t *  header and a SA payload MUST immediately follow the HASH.\"\n\t\t * [NOTE: there may be more than one SA payload, so this is not\n\t\t *  totally reasonable.  Probably all SAs should be so constrained.]\n\t\t *\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t *\n\t\t * \"With the exception of the HASH, SA, and the optional ID payloads,\n\t\t *  there are no payload ordering restrictions on Quick Mode.\"\n\t\t */\n\n\t\tif (md->hdr.isa_np != ISAKMP_NEXT_HASH) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Quick Mode message: does not start with a HASH payload\");\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\n\t\t{\n\t\t\tstruct payload_digest *p;\n\t\t\tint i;\n\n\t\t\tp = md->chain[ISAKMP_NEXT_SA];\n\t\t\ti = 1;\n\t\t\twhile (p != NULL) {\n\t\t\t\tif (p != &md->digest[i]) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"malformed Quick Mode message: SA payload is in wrong position\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tp = p->next;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode:\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t */\n\t\t{\n\t\t\tstruct payload_digest *id = md->chain[ISAKMP_NEXT_ID];\n\n\t\t\tif (id != NULL) {\n\t\t\t\tif (id->next == NULL ||\n\t\t\t\t    id->next->next != NULL) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"malformed Quick Mode message:\"\n\t\t\t\t\t       \" if any ID payload is present,\"\n\t\t\t\t\t       \" there must be exactly two\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (id + 1 != id->next) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"malformed Quick Mode message:\"\n\t\t\t\t\t       \" the ID payloads are not adjacent\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Ignore payloads that we don't handle:\n\t */\n\t/* XXX Handle Notifications */\n\t{\n\t\tstruct payload_digest *p = md->chain[ISAKMP_NEXT_N];\n\n\t\twhile (p != NULL) {\n\t\t\tswitch (p->payload.notification.isan_type) {\n\n\t\t\tcase R_U_THERE:\n\t\t\tcase R_U_THERE_ACK:\n\t\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tcase PAYLOAD_MALFORMED:\n\t\t\tcase INVALID_MESSAGE_ID:\n\t\t\tcase IPSEC_RESPONDER_LIFETIME:\n\t\t\t\tif (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {\n\t\t\t\t\t/* these are handled later on in informational() */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tdefault:\n\t\t\t\tif (st == NULL || (st != NULL &&\n\t\t\t\t\t\t   (st->st_connection->policy & POLICY_OPPORTUNISTIC))) {\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t       \"ignoring informational payload %s, no corresponding state\",\n\t\t\t\t\t       enum_show(& ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.\n\t\t\t\t\t\t\t notification.isan_type)));\n\t\t\t\t} else {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"ignoring informational payload %s, msgid=%08\" PRIx32 \", length=%d\",\n\t\t\t\t\t       enum_show(&ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.\n\t\t\t\t\t\t\t notification.isan_type),\n\t\t\t\t\t       st->st_msgid,\n\t\t\t\t\t       p->payload.notification.isan_length);\n\t\t\t\t\tDBG_dump_pbs(&p->pbs);\n\t\t\t\t}\n\t\t\t\tif (st != NULL &&\n\t\t\t\t    st->st_connection->extra_debugging &\n\t\t\t\t    IMPAIR_DIE_ONINFO) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"received and failed on unknown informational message\");\n\t\t\t\t\tcomplete_v1_state_transition(mdp,\n\t\t\t\t\t\t\t\t     STF_FATAL);\n\t\t\t\t\t/* our caller will release_any_md(mdp); */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_cond_dump(DBG_PARSING, \"info:\", p->pbs.cur, pbs_left(\n\t\t\t\t\t      &p->pbs));\n\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_D];\n\t\twhile (p != NULL) {\n\t\t\tself_delete |= accept_delete(md, p);\n\t\t\tDBG_cond_dump(DBG_PARSING, \"del:\", p->pbs.cur, pbs_left(\n\t\t\t\t\t      &p->pbs));\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_VID];\n\t\twhile (p != NULL) {\n\t\t\thandle_vendorid(md, (char *)p->pbs.cur,\n\t\t\t\t\tpbs_left(&p->pbs), FALSE);\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (self_delete) {\n\t\taccept_self_delete(md);\n\t\tst = md->st;\t/* st not subsequently used */\n\t\t/* note: st ought to be NULL from here on */\n\t}\n\n#if 0\n\t/* this does not seem to be right */\n\n\t/* VERIFY that we only accept NAT-D/NAT-OE when they sent us the VID */\n\tif ((md->chain[ISAKMP_NEXT_NATD_RFC] != NULL ||\n\t     md->chain[ISAKMP_NEXT_NATOA_RFC] != NULL) &&\n\t    (st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t/*\n\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t * unless we're using NAT-T RFC\n\t\t */\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"message ignored because it contains a NAT payload, when we did not receive the appropriate VendorID\");\n\t\treturn;\n\t}\n#endif\n\n\t/* possibly fill in hdr */\n\tif (smc->first_out_payload != ISAKMP_NEXT_NONE)\n\t\tikev1_echo_hdr(md, (smc->flags & SMF_OUTPUT_ENCRYPTED) != 0,\n\t\t\t smc->first_out_payload);\n\n\tcomplete_v1_state_transition(mdp, smc->processor(md));\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * replace previous receive packet with latest, to update\n * our notion of a retransmitted packet. This is important\n * to do, even for failing transitions, and suspended transitions\n * because the sender may well retransmit their request.\n * We had better be idempotent since we can be called\n * multiple times in handling a packet due to crypto helper logic.\n */\nstatic void remember_received_packet(struct state *st, struct msg_digest *md)\n{\n\tif (md->encrypted) {\n\t\t/* if encrypted, duplication already done */\n\t\tif (md->raw_packet.ptr != NULL) {\n\t\t\tpfreeany(st->st_rpacket.ptr);\n\t\t\tst->st_rpacket = md->raw_packet;\n\t\t\tmd->raw_packet.ptr = NULL;\n\t\t}\n\t} else {\n\t\t/* this may be a repeat, but it will work */\n\t\tpfreeany(st->st_rpacket.ptr);\n\t\tclonetochunk(st->st_rpacket,\n\t\t\t     md->packet_pbs.start,\n\t\t\t     pbs_room(&md->packet_pbs), \"raw packet\");\n\t}\n}\n\n/* complete job started by the state-specific state transition function\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n *\n * md is used to:\n * - find st\n * - find from_state (st might be gone)\n * - find note for STF_FAIL (might not be part of result (STF_FAIL+note))\n * - find note for STF_INTERNAL_ERROR\n * - record md->event_already_set\n * - remember_received_packet(st, md);\n * - nat_traversal_change_port_lookup(md, st);\n * - smc for smc->next_state\n * - smc for smc->flags & SMF_REPLY to trigger a reply\n * - smc for smc->timeout_event\n * - smc for !(smc->flags & SMF_INITIATOR) for Contivity mode\n * - smc for smc->flags & SMF_RELEASE_PENDING_P2 to trigger unpend call\n * - smc for smc->flags & SMF_INITIATOR to adjust retransmission\n * - fragvid, dpd, nortel\n */\nvoid complete_v1_state_transition(struct msg_digest **mdp, stf_status result)\n{\n\tstruct msg_digest *md = *mdp;\n\tenum state_kind from_state;\n\tstruct state *st;\n\n\tpassert(md != NULL);\n\n\t/* handle oddball/meta results now */\n\n\tswitch (result) {\n\tcase STF_SUSPEND:\n\t\tcur_state = md->st;\t/* might have changed */\n\t\t/* FALL THROUGH */\n\tcase STF_INLINE:\t/* all done, including release_any_md */\n\t\t*mdp = NULL;\t/* take md away from parent */\n\t\t/* FALL THROUGH */\n\tcase STF_IGNORE:\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"complete v1 state transition with %s\",\n\t\t\t    enum_show(&stfstatus_name, result)));\n\t\treturn;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tDBG(DBG_CONTROL,\n\t    DBG_log(\"complete v1 state transition with %s\",\n\t\tresult > STF_FAIL ?\n\t\t    enum_name(&ikev1_notify_names, result - STF_FAIL) :\n\t\t    enum_name(&stfstatus_name, result)));\n\n\t/* safe to refer to *md */\n\n\tfrom_state = md->from_state;\n\n\tcur_state = st = md->st; /* might have changed */\n\n\tpassert(st != NULL);\n\n\tpassert(!st->st_calculating);\n\n\tswitch (result) {\n\tcase STF_OK:\n\t{\n\t\t/* advance the state */\n\t\tconst struct state_microcode *smc = md->smc;\n\n\t\tlibreswan_log(\"transition from state %s to state %s\",\n\t\t\t      enum_name(&state_names, from_state),\n\t\t\t      enum_name(&state_names, smc->next_state));\n\n\t\t/* accept info from VID because we accept this message */\n\n\t\t/* If state has FRAGMENTATION support, import it */\n\t\tif (md->fragvid) {\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\"peer supports fragmentation\"));\n\t\t\tst->st_seen_fragvid = TRUE;\n\t\t}\n\n\t\t/* If state has DPD support, import it */\n\t\tif (md->dpd &&\n\t\t    st->hidden_variables.st_peer_supports_dpd != md->dpd) {\n\t\t\tDBG(DBG_DPD, DBG_log(\"peer supports dpd\"));\n\t\t\tst->hidden_variables.st_peer_supports_dpd = md->dpd;\n\n\t\t\tif (dpd_active_locally(st)) {\n\t\t\t\tDBG(DBG_DPD, DBG_log(\"dpd is active locally\"));\n\t\t\t}\n\t\t}\n\n\t\t/* If state has VID_NORTEL, import it to activate workaround */\n\t\tif (md->nortel) {\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\"peer requires Nortel Contivity workaround\"));\n\t\t\tst->st_seen_nortel_vid = TRUE;\n\t\t}\n\n\t\tif (!st->st_msgid_reserved &&\n\t\t    IS_CHILD_SA(st) &&\n\t\t    st->st_msgid != v1_MAINMODE_MSGID) {\n\t\t\tstruct state *p1st = state_with_serialno(\n\t\t\t\tst->st_clonedfrom);\n\n\t\t\tif (p1st != NULL) {\n\t\t\t\t/* do message ID reservation */\n\t\t\t\treserve_msgid(p1st, st->st_msgid);\n\t\t\t}\n\n\t\t\tst->st_msgid_reserved = TRUE;\n\t\t}\n\n\t\tchange_state(st, smc->next_state);\n\n\t\t/* XAUTH negotiation withOUT modecfg ends in STATE_XAUTH_I1\n\t\t * which is wrong and creates issues further in several places\n\t\t * As per libreswan design, it seems every phase 1 negotiation\n\t\t * including xauth/modecfg must end with STATE_MAIN_I4 to mark\n\t\t * actual end of phase 1. With modecfg, negotiation ends with\n\t\t * STATE_MAIN_I4 already.\n\t\t */\n#if 0\t/* ??? what's this code for? */\n\t\tif (st->st_connection->spd.this.xauth_client\n\t\t    && st->hidden_variables.st_xauth_client_done\n\t\t    && !st->st_connection->spd.this.modecfg_client\n\t\t    && st->st_state == STATE_XAUTH_I1) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"As XAUTH is done and modecfg is not configured, so Phase 1 neogtiation finishes successfully\"));\n\t\t\tchange_state(st, STATE_MAIN_I4);\n\t\t}\n#endif\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\t/* Delete previous retransmission event.\n\t\t\t * New event will be scheduled below.\n\t\t\t */\n\t\t\tdelete_event(st);\n\t\t}\n\n\t\t/* Delete IKE fragments */\n\t\trelease_fragments(st);\n\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\n\t\t/* free previous transmit packet */\n\t\tfreeanychunk(st->st_tpacket);\n\n\t\t/* in aggressive mode, there will be no reply packet in transition\n\t\t * from STATE_AGGR_R1 to STATE_AGGR_R2\n\t\t */\n\t\tif (nat_traversal_enabled) {\n\t\t\t/* adjust our destination port if necessary */\n\t\t\tnat_traversal_change_port_lookup(md, st);\n\t\t}\n\n\t\t/* if requested, send the new reply packet */\n\t\tif (smc->flags & SMF_REPLY) {\n\t\t\tDBG(DBG_CONTROL, {\n\t\t\t\tipstr_buf b;\n\t\t\t\tDBG_log(\"sending reply packet to %s:%u (from port %u)\",\n\t\t\t\t\tipstr(&st->st_remoteaddr, &b),\n\t\t\t\t\tst->st_remoteport,\n\t\t\t\t\tst->st_interface->port);\n\t\t\t});\n\n\t\t\tclose_output_pbs(&reply_stream); /* good form, but actually a no-op */\n\n\t\t\trecord_and_send_ike_msg(st, &reply_stream,\n\t\t\t\tenum_name(&state_names, from_state));\n\t\t}\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\tunsigned long delay_ms; /* delay is in milliseconds here */\n\t\t\tenum event_type kind = smc->timeout_event;\n\t\t\tbool agreed_time = FALSE;\n\t\t\tstruct connection *c = st->st_connection;\n\n\t\t\tswitch (kind) {\n\t\t\tcase EVENT_v1_RETRANSMIT: /* Retransmit packet */\n\t\t\t\tdelay_ms = c->r_interval;\n\t\t\t\tbreak;\n\n\t\t\tcase EVENT_SA_REPLACE: /* SA replacement event */\n\t\t\t\tif (IS_PHASE1(st->st_state) ||\n\t\t\t\t    IS_PHASE15(st->st_state )) {\n\t\t\t\t\t/* Note: we will defer to the \"negotiated\" (dictated)\n\t\t\t\t\t * lifetime if we are POLICY_DONT_REKEY.\n\t\t\t\t\t * This allows the other side to dictate\n\t\t\t\t\t * a time we would not otherwise accept\n\t\t\t\t\t * but it prevents us from having to initiate\n\t\t\t\t\t * rekeying.  The negative consequences seem\n\t\t\t\t\t * minor.\n\t\t\t\t\t */\n\t\t\t\t\tdelay_ms = deltamillisecs(c->sa_ike_life_seconds);\n\t\t\t\t\tif ((c->policy & POLICY_DONT_REKEY) ||\n\t\t\t\t\t    delay_ms >= deltamillisecs(st->st_oakley.life_seconds))\n\t\t\t\t\t{\n\t\t\t\t\t\tagreed_time = TRUE;\n\t\t\t\t\t\tdelay_ms = deltamillisecs(st->st_oakley.life_seconds);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Delay is min of up to four things:\n\t\t\t\t\t * each can limit the lifetime.\n\t\t\t\t\t */\n\t\t\t\t\ttime_t delay = deltasecs(c->sa_ipsec_life_seconds);\n\n#define clamp_delay(trans) { \\\n\t\tif (st->trans.present && \\\n\t\t    delay >= deltasecs(st->trans.attrs.life_seconds)) { \\\n\t\t\tagreed_time = TRUE; \\\n\t\t\tdelay = deltasecs(st->trans.attrs.life_seconds); \\\n\t\t} \\\n\t}\n\t\t\t\t\tclamp_delay(st_ah);\n\t\t\t\t\tclamp_delay(st_esp);\n\t\t\t\t\tclamp_delay(st_ipcomp);\n\t\t\t\t\tdelay_ms = delay * 1000;\n#undef clamp_delay\n\t\t\t\t}\n\n\t\t\t\t/* By default, we plan to rekey.\n\t\t\t\t *\n\t\t\t\t * If there isn't enough time to rekey, plan to\n\t\t\t\t * expire.\n\t\t\t\t *\n\t\t\t\t * If we are --dontrekey, a lot more rules apply.\n\t\t\t\t * If we are the Initiator, use REPLACE_IF_USED.\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * was unacceptable (too large), plan to REPLACE\n\t\t\t\t * (the only way to ratchet down the time).\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * is acceptable, plan to EXPIRE.\n\t\t\t\t *\n\t\t\t\t * Important policy lies buried here.\n\t\t\t\t * For example, we favour the initiator over the\n\t\t\t\t * responder by making the initiator start rekeying\n\t\t\t\t * sooner.  Also, fuzz is only added to the\n\t\t\t\t * initiator's margin.\n\t\t\t\t *\n\t\t\t\t * Note: for ISAKMP SA, we let the negotiated\n\t\t\t\t * time stand (implemented by earlier logic).\n\t\t\t\t */\n\t\t\t\tif (agreed_time &&\n\t\t\t\t    (c->policy & POLICY_DONT_REKEY)) {\n\t\t\t\t\tkind = (smc->flags & SMF_INITIATOR) ?\n\t\t\t\t\t       EVENT_SA_REPLACE_IF_USED :\n\t\t\t\t\t       EVENT_SA_EXPIRE;\n\t\t\t\t}\n\t\t\t\tif (kind != EVENT_SA_EXPIRE) {\n\t\t\t\t\ttime_t marg =\n\t\t\t\t\t\tdeltasecs(c->sa_rekey_margin);\n\n\t\t\t\t\tif (smc->flags & SMF_INITIATOR) {\n\t\t\t\t\t\tmarg += marg *\n\t\t\t\t\t\t\tc->sa_rekey_fuzz /\n\t\t\t\t\t\t\t100.E0 *\n\t\t\t\t\t\t\t(rand() /\n\t\t\t\t\t\t\t (RAND_MAX + 1.E0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarg /= 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (delay_ms > (unsigned long)marg * 1000) {\n\t\t\t\t\t\tdelay_ms -= (unsigned long)marg * 1000;\n\t\t\t\t\t\tst->st_margin = deltatime(marg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkind = EVENT_SA_EXPIRE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbad_case(kind);\n\t\t\t}\n\t\t\tevent_schedule_ms(kind, delay_ms, st);\n\t\t}\n\n\t\t/* tell whack and log of progress */\n\t\t{\n\t\t\tconst char *story = enum_name(&state_stories,\n\t\t\t\t\t\t      st->st_state);\n\t\t\tenum rc_type w = RC_NEW_STATE + st->st_state;\n\t\t\tchar sadetails[512];\n\n\t\t\tpassert(st->st_state < STATE_IKE_ROOF);\n\n\t\t\tsadetails[0] = '\\0';\n\n\t\t\t/* document IPsec SA details for admin's pleasure */\n\t\t\tif (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tfmt_ipsec_sa_established(st, sadetails,\n\t\t\t\t\t\t\t sizeof(sadetails));\n\t\t\t} else if (IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t\t\t   !st->hidden_variables.st_logged_p1algos) {\n\t\t\t\tfmt_isakmp_sa_established(st, sadetails,\n\t\t\t\t\t\t\t  sizeof(sadetails));\n\t\t\t}\n\n\t\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||\n\t\t\t    IS_IPSEC_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\t/* log our success */\n\t\t\t\tw = RC_SUCCESS;\n\t\t\t}\n\n\t\t\t/* tell whack and logs our progress */\n\t\t\tloglog(w,\n\t\t\t       \"%s: %s%s\",\n\t\t\t       enum_name(&state_names, st->st_state),\n\t\t\t       story,\n\t\t\t       sadetails);\n\t\t}\n\n\t\t/*\n\t\t * make sure that a DPD event gets created for a new phase 1\n\t\t * SA.\n\t\t */\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\tif (deltasecs(st->st_connection->dpd_delay) > 0 &&\n\t\t\t    deltasecs(st->st_connection->dpd_timeout) > 0) {\n\t\t\t\t/* don't ignore failure */\n\t\t\t\t/* ??? in fact, we do ignore this:\n\t\t\t\t * result is NEVER used\n\t\t\t\t * (clang 3.4 noticed this)\n\t\t\t\t */\n\t\t\t\tstf_status s = dpd_init(st);\n\n\t\t\t\tpexpect(s != STF_FAIL);\n\t\t\t\tif (s == STF_FAIL)\n\t\t\t\t\tresult = STF_FAIL; /* ??? fall through !?! */\n\t\t\t}\n\t\t}\n\n\t\t/* Special case for XAUTH server */\n\t\tif (st->st_connection->spd.this.xauth_server) {\n\t\t\tif (st->st_oakley.doing_xauth &&\n\t\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t\t\tDBG_log(\"XAUTH: \"\n\t\t\t\t\t\t       \"Sending XAUTH Login/Password Request\"));\n\t\t\t\tevent_schedule_ms(EVENT_v1_SEND_XAUTH,\n\t\t\t\t\t\tEVENT_v1_SEND_XAUTH_DELAY, st);\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * for XAUTH client, we are also done, because we need to\n\t\t * stay in this state, and let the server query us\n\t\t */\n\t\tif (!IS_QUICK(st->st_state) &&\n\t\t    st->st_connection->spd.this.xauth_client &&\n\t\t    !st->hidden_variables.st_xauth_client_done) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"XAUTH client is not yet authenticated\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * when talking to some vendors, we need to initiate a mode\n\t\t * cfg request to get challenged, but there is also an\n\t\t * override in the form of a policy bit.\n\t\t */\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"modecfg pull: %s policy:%s %s\",\n\t\t\t    (st->quirks.modecfg_pull_mode ?\n\t\t\t     \"quirk-poll\" : \"noquirk\"),\n\t\t\t    (st->st_connection->policy & POLICY_MODECFG_PULL) ?\n\t\t\t    \"pull\" : \"push\",\n\t\t\t    (st->st_connection->spd.this.modecfg_client ?\n\t\t\t     \"modecfg-client\" : \"not-client\")));\n\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    (st->quirks.modecfg_pull_mode ||\n\t\t     st->st_connection->policy & POLICY_MODECFG_PULL) &&\n\t\t    !st->hidden_variables.st_modecfg_started) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"modecfg client is starting due to %s\",\n\t\t\t\t    st->quirks.modecfg_pull_mode ? \"quirk\" :\n\t\t\t\t    \"policy\"));\n\t\t\tmodecfg_send_request(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Should we set the peer's IP address regardless? */\n\t\tif (st->st_connection->spd.this.modecfg_server &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set &&\n\t\t    !(st->st_connection->policy & POLICY_MODECFG_PULL)) {\n\t\t\tchange_state(st, STATE_MODE_CFG_R1);\n\t\t\tset_cur_state(st);\n\t\t\tlibreswan_log(\"Sending MODE CONFIG set\");\n\t\t\tmodecfg_start_set(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we are the responder and the client is in \"Contivity mode\",\n\t\t * we need to initiate Quick mode\n\t\t */\n\t\tif (!(smc->flags & SMF_INITIATOR) &&\n\t\t    IS_MODE_CFG_ESTABLISHED(st->st_state) &&\n\t\t    (st->st_seen_nortel_vid)) {\n\t\t\tlibreswan_log(\"Nortel 'Contivity Mode' detected, starting Quick Mode\");\n\t\t\tchange_state(st, STATE_MAIN_R3); /* ISAKMP is up... */\n\t\t\tset_cur_state(st);\n\t\t\tquick_outI1(st->st_whack_sock, st, st->st_connection,\n\t\t\t\t    st->st_connection->policy, 1, SOS_NOBODY\n#ifdef HAVE_LABELED_IPSEC\n\t\t\t\t    , NULL /* Setting NULL as this is responder and will not have sec ctx from a flow*/\n#endif\n\t\t\t\t    );\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wait for modecfg_set */\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"waiting for modecfg set from server\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (st->st_rekeytov2) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"waiting for IKEv1 -> IKEv2 rekey\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"phase 1 is done, looking for phase 2 to unpend\"));\n\n\t\tif (smc->flags & SMF_RELEASE_PENDING_P2) {\n\t\t\t/* Initiate any Quick Mode negotiations that\n\t\t\t * were waiting to piggyback on this Keying Channel.\n\t\t\t *\n\t\t\t * ??? there is a potential race condition\n\t\t\t * if we are the responder: the initial Phase 2\n\t\t\t * message might outrun the final Phase 1 message.\n\t\t\t *\n\t\t\t * so, instead of actually sending the traffic now,\n\t\t\t * we schedule an event to do so.\n\t\t\t *\n\t\t\t * but, in fact, quick_mode will enqueue a cryptographic operation\n\t\t\t * anyway, which will get done \"later\" anyway, so maybe it is just fine\n\t\t\t * as it is.\n\t\t\t *\n\t\t\t */\n\t\t\tunpend(st);\n\t\t}\n\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||\n\t\t    IS_IPSEC_SA_ESTABLISHED(st->st_state))\n\t\t\trelease_whack(st);\n\n\t\tif (IS_QUICK(st->st_state))\n\t\t\tbreak;\n\n\t\tbreak;\n\t}\n\n\tcase STF_INTERNAL_ERROR:\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\n\t\twhack_log(RC_INTERNALERR + md->note,\n\t\t\t  \"%s: internal error\",\n\t\t\t  enum_name(&state_names, st->st_state));\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"state transition function for %s had internal error\",\n\t\t\t    enum_name(&state_names, from_state)));\n\t\tbreak;\n\n\tcase STF_TOOMUCHCRYPTO:\n\t\t/* ??? Why is this comment useful:\n\t\t * well, this should never happen during a whack, since\n\t\t * a whack will always force crypto.\n\t\t */\n\t\t/* ??? why no call of remember_received_packet? */\n\t\tunset_suspended(st);\n\t\tlibreswan_log(\n\t\t\t\"message in state %s ignored due to cryptographic overload\",\n\t\t\tenum_name(&state_names, from_state));\n\t\tlog_crypto_workers();\n\t\t/* ??? the ikev2.c version used to FALL THROUGH to STF_FATAL */\n\t\tbreak;\n\n\tcase STF_FATAL:\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\n\t\twhack_log(RC_FATAL,\n\t\t\t  \"encountered fatal error in state %s\",\n\t\t\t  enum_name(&state_names, st->st_state));\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\trelease_pending_whacks(st, \"fatal error\");\n\t\tdelete_state(st);\n\t\tmd->st = st = NULL;\n\t\tbreak;\n\n\tdefault:        /* a shortcut to STF_FAIL, setting md->note */\n\t\tpassert(result > STF_FAIL);\n\t\tmd->note = result - STF_FAIL;\n\t\t/* FALL THROUGH */\n\tcase STF_FAIL:\n\t\t/* As it is, we act as if this message never happened:\n\t\t * whatever retrying was in place, remains in place.\n\t\t */\n\t\t/*\n\t\t * ??? why no call of remember_received_packet?\n\t\t * Perhaps because the message hasn't been authenticated?\n\t\t * But then then any duplicate would lose too, I would think.\n\t\t */\n\t\twhack_log(RC_NOTIFICATION + md->note,\n\t\t\t  \"%s: %s\", enum_name(&state_names, st->st_state),\n\t\t\t  enum_name(&ikev1_notify_names, md->note));\n\n\t\tif (md->note != NOTHING_WRONG)\n\t\t\tSEND_NOTIFICATION(md->note);\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"state transition function for %s failed: %s\",\n\t\t\t    enum_name(&state_names, from_state),\n\t\t\t    enum_name(&ikev1_notify_names, md->note)));\n\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\tif (IS_PHASE1_INIT(st->st_state)) {\n\t\t\tdelete_event(st);\n\t\t\trelease_whack(st);\n\t\t}\n\t\tif (IS_QUICK(st->st_state)) {\n\t\t\tdelete_state(st);\n\t\t\t/* wipe out dangling pointer to st */\n\t\t\tmd->st = NULL;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/* note: may change which connection is referenced by md->st->st_connection */\nbool ikev1_decode_peer_id(struct msg_digest *md, bool initiator, bool aggrmode)\n{\n\tstruct state *const st = md->st;\n\tstruct payload_digest *const id_pld = md->chain[ISAKMP_NEXT_ID];\n\tconst pb_stream *const id_pbs = &id_pld->pbs;\n\tstruct isakmp_id *const id = &id_pld->payload.id;\n\tstruct id peer;\n\n\t/* I think that RFC2407 (IPSEC DOI) 4.6.2 is confused.\n\t * It talks about the protocol ID and Port fields of the ID\n\t * Payload, but they don't exist as such in Phase 1.\n\t * We use more appropriate names.\n\t * isaid_doi_specific_a is in place of Protocol ID.\n\t * isaid_doi_specific_b is in place of Port.\n\t * Besides, there is no good reason for allowing these to be\n\t * other than 0 in Phase 1.\n\t */\n\tif (st->hidden_variables.st_nat_traversal != LEMPTY &&\n\t    id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t    (id->isaid_doi_specific_b == 0 ||\n\t     id->isaid_doi_specific_b == pluto_nat_port)) {\n\t\tDBG_log(\"protocol/port in Phase 1 ID Payload is %d/%d. \"\n\t\t\t\"accepted with port_floating NAT-T\",\n\t\t\tid->isaid_doi_specific_a, id->isaid_doi_specific_b);\n\t} else if (!(id->isaid_doi_specific_a == 0 &&\n\t\t     id->isaid_doi_specific_b == 0) &&\n\t\t   !(id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t\t     id->isaid_doi_specific_b == pluto_port))\n\t{\n\t\tloglog(RC_LOG_SERIOUS, \"protocol/port in Phase 1 ID Payload MUST be 0/0 or %d/%d\"\n\t\t       \" but are %d/%d (attempting to continue)\",\n\t\t       IPPROTO_UDP, pluto_port,\n\t\t       id->isaid_doi_specific_a,\n\t\t       id->isaid_doi_specific_b);\n\t\t/* we have turned this into a warning because of bugs in other vendors\n\t\t * products. Specifically CISCO VPN3000.\n\t\t */\n\t\t/* return FALSE; */\n\t}\n\n\tzero(&peer);\t/* ??? pointer fields might not be NULLed */\n\tpeer.kind = id->isaid_idtype;\n\n\tif (!extract_peer_id(&peer, id_pbs))\n\t\treturn FALSE;\n\n\t/*\n\t * For interop with SoftRemote/aggressive mode we need to remember some\n\t * things for checking the hash\n\t */\n\tst->st_peeridentity_protocol = id->isaid_doi_specific_a;\n\tst->st_peeridentity_port = ntohs(id->isaid_doi_specific_b);\n\n\t{\n\t\tchar buf[IDTOA_BUF];\n\n\t\tidtoa(&peer, buf, sizeof(buf));\n\t\tlibreswan_log(\"%s mode peer ID is %s: '%s'\",\n\t\t\t      aggrmode ? \"Aggressive\" : \"Main\",\n\t\t\t      enum_show(&ike_idtype_names, id->isaid_idtype), buf);\n\t}\n\n\t/* check for certificates */\n\tif (!ikev1_decode_cert(md))\n\t\treturn FALSE;\n\n\t/* Now that we've decoded the ID payload, let's see if we\n\t * need to switch connections.\n\t * We must not switch horses if we initiated:\n\t * - if the initiation was explicit, we'd be ignoring user's intent\n\t * - if opportunistic, we'll lose our HOLD info\n\t */\n\tif (initiator) {\n\t\tif (!same_id(&st->st_connection->spd.that.id, &peer) &&\n\t\t     id_kind(&st->st_connection->spd.that.id) != ID_FROMCERT) {\n\t\t\tchar expect[IDTOA_BUF],\n\t\t\t     found[IDTOA_BUF];\n\n\t\t\tidtoa(&st->st_connection->spd.that.id, expect,\n\t\t\t      sizeof(expect));\n\t\t\tidtoa(&peer, found, sizeof(found));\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"we require IKEv1 peer to have ID '%s', but peer declares '%s'\",\n\t\t\t       expect, found);\n\t\t\treturn FALSE;\n\t\t} else if (id_kind(&st->st_connection->spd.that.id) == ID_FROMCERT) {\n\t\t\tif (id_kind(&peer) != ID_DER_ASN1_DN) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"peer ID is not a certificate type\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tduplicate_id(&st->st_connection->spd.that.id, &peer);\n\t\t}\n\t} else {\n\t\tstruct connection *c = st->st_connection;\n\t\tstruct connection *r = NULL;\n\t\tbool fromcert;\n\t\tuint16_t auth = xauth_calcbaseauth(st->st_oakley.auth);\n\t\tlset_t auth_policy = LEMPTY;\n\n\t\tswitch (auth) {\n\t\tcase OAKLEY_PRESHARED_KEY:\n\t\t\tauth_policy = POLICY_PSK;\n\t\t\tbreak;\n\t\tcase OAKLEY_RSA_SIG:\n\t\t\tauth_policy = POLICY_RSASIG;\n\t\t\tbreak;\n\t\t/* Not implemented */\n\t\tcase OAKLEY_DSS_SIG:\n\t\tcase OAKLEY_RSA_ENC:\n\t\tcase OAKLEY_RSA_REVISED_MODE:\n\t\tcase OAKLEY_ECDSA_P256:\n\t\tcase OAKLEY_ECDSA_P384:\n\t\tcase OAKLEY_ECDSA_P521:\n\t\tdefault:\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"ikev1 ikev1_decode_peer_id bad_case due to not supported policy\"));\n\t\t\t// bad_case(auth);\n\t\t}\n\n\t\tif (aggrmode)\n\t\t\tauth_policy |=  POLICY_AGGRESSIVE;\n\n\t\t/* check for certificate requests */\n\t\tikev1_decode_cr(md);\n\n\t\tif ((auth_policy & ~POLICY_AGGRESSIVE) != LEMPTY) {\n\t\t\tr = refine_host_connection(st, &peer, initiator, auth_policy, &fromcert);\n\t\t\tpexpect(r != NULL);\n\t\t}\n\n\t\tif (r == NULL) {\n\t\t\tchar buf[IDTOA_BUF];\n\n\t\t\tidtoa(&peer, buf, sizeof(buf));\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"no suitable connection for peer '%s'\",\n\t\t\t       buf);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tDBG(DBG_CONTROL, {\n\t\t\t    char buf[IDTOA_BUF];\n\t\t\t    dntoa_or_null(buf, IDTOA_BUF, r->spd.this.ca,\n\t\t\t\t\t  \"%none\");\n\t\t\t    DBG_log(\"offered CA: '%s'\", buf);\n\t\t    });\n\n\t\tif (r != c) {\n\t\t\tchar b1[CONN_INST_BUF];\n\t\t\tchar b2[CONN_INST_BUF];\n\n\t\t\t/* apparently, r is an improvement on c -- replace */\n\t\t\tlibreswan_log(\"switched from \\\"%s\\\"%s to \\\"%s\\\"%s\",\n\t\t\t\tc->name,\n\t\t\t\tfmt_conn_instance(c, b1),\n\t\t\t\tr->name,\n\t\t\t\tfmt_conn_instance(r, b2));\n\t\t\tif (r->kind == CK_TEMPLATE || r->kind == CK_GROUP) {\n\t\t\t\t/* instantiate it, filling in peer's ID */\n\t\t\t\tr = rw_instantiate(r, &c->spd.that.host_addr,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   &peer);\n\t\t\t}\n\n\t\t\tupdate_state_connection(st, r);\n\t\t} else if (c->spd.that.has_id_wildcards) {\n\t\t\tfree_id_content(&c->spd.that.id);\n\t\t\tc->spd.that.id = peer;\n\t\t\tc->spd.that.has_id_wildcards = FALSE;\n\t\t\tunshare_id_content(&c->spd.that.id);\n\t\t} else if (fromcert) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"copying ID for fromcert\"));\n\t\t\tduplicate_id(&r->spd.that.id, &peer);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nbool ikev1_ship_chain(chunk_t *chain, int n, pb_stream *outs,\n\t\t\t\t\t     u_int8_t type,\n\t\t\t\t\t     u_int8_t setnp)\n{\n\tint i;\n\tu_int8_t np;\n\n\tfor (i = 0; i < n; i++) {\n\t\t/* set np for last cert, or another */\n\t\tnp = i == n - 1 ? setnp : ISAKMP_NEXT_CERT;\n\n\t\tif (!ikev1_ship_CERT(type, chain[i], outs, np))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid doi_log_cert_thinking(u_int16_t auth,\n\t\t\t\tenum ike_cert_type certtype,\n\t\t\t\tenum certpolicy policy,\n\t\t\t\tbool gotcertrequest,\n\t\t\t\tbool send_cert,\n\t\t\t\tbool send_chain)\n{\n\tDBG(DBG_CONTROL,\n\t\tDBG_log(\"thinking about whether to send my certificate:\"));\n\n\tDBG(DBG_CONTROL, {\n\t\tstruct esb_buf esb;\n\n\t\tDBG_log(\"  I have RSA key: %s cert.type: %s \",\n\t\t\tenum_showb(&oakley_auth_names, auth, &esb),\n\t\t\tenum_show(&ike_cert_type_names, certtype));\n\t});\n\n\tDBG(DBG_CONTROL,\n\t\tDBG_log(\"  sendcert: %s and I did%s get a certificate request \",\n\t\t\tenum_show(&certpolicy_type_names, policy),\n\t\t\tgotcertrequest ? \"\" : \" not\"));\n\n\tDBG(DBG_CONTROL,\n\t\tDBG_log(\"  so %ssend cert.\", send_cert ? \"\" : \"do not \"));\n\n\tif (!send_cert) {\n\t\tif (auth == OAKLEY_PRESHARED_KEY) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"I did not send a certificate \"\n\t\t\t\t\t\"because digital signatures are not \"\n\t\t\t\t\t\"being used. (PSK)\"));\n\t\t} else if (certtype == CERT_NONE) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"I did not send a certificate because \"\n\t\t\t\t\t\"I do not have one.\"));\n\t\t} else if (policy == cert_sendifasked) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"I did not send my certificate \"\n\t\t\t\t\t\"because I was not asked to.\"));\n\t\t}\n\t\t/* ??? should there be an additional else catch-all? */\n\t}\n\tif (send_chain)\n\t\tDBG(DBG_CONTROL, DBG_log(\"Sending one or more authcerts\"));\n}\n"], "fixing_code": ["/* State machine for IKEv1\n * Copyright (C) 1997 Angelos D. Keromytis.\n * Copyright (C) 1998-2010,2013-2015 D. Hugh Redelmeier <hugh@mimosa.com>\n * Copyright (C) 2003-2008 Michael Richardson <mcr@xelerance.com>\n * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>\n * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>\n * Copyright (C) 2011 Avesh Agarwal <avagarwa@redhat.com>\n * Copyright (C) 2008 Hiren Joshi <joshihirenn@gmail.com>\n * Copyright (C) 2009 Anthony Tong <atong@TrustedCS.com>\n * Copyright (C) 2012-2013 Paul Wouters <pwouters@redhat.com>\n * Copyright (C) 2013 Wolfgang Nothdurft <wolfgang@linogate.de>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * for more details.\n *\n */\n\n/* Ordering Constraints on Payloads\n *\n * rfc2409: The Internet Key Exchange (IKE)\n *\n * 5 Exchanges:\n *   \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n *\n *   \"Except where otherwise noted, there are no requirements for ISAKMP\n *    payloads in any message to be in any particular order.\"\n *\n * 5.3 Phase 1 Authenticated With a Revised Mode of Public Key Encryption:\n *\n *   \"If the HASH payload is sent it MUST be the first payload of the\n *    second message exchange and MUST be followed by the encrypted\n *    nonce. If the HASH payload is not sent, the first payload of the\n *    second message exchange MUST be the encrypted nonce.\"\n *\n *   \"Save the requirements on the location of the optional HASH payload\n *    and the mandatory nonce payload there are no further payload\n *    requirements. All payloads-- in whatever order-- following the\n *    encrypted nonce MUST be encrypted with Ke_i or Ke_r depending on the\n *    direction.\"\n *\n * 5.5 Phase 2 - Quick Mode\n *\n *   \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n *    header and a SA payload MUST immediately follow the HASH.\"\n *   [NOTE: there may be more than one SA payload, so this is not\n *    totally reasonable.  Probably all SAs should be so constrained.]\n *\n *   \"If ISAKMP is acting as a client negotiator on behalf of another\n *    party, the identities of the parties MUST be passed as IDci and\n *    then IDcr.\"\n *\n *   \"With the exception of the HASH, SA, and the optional ID payloads,\n *    there are no payload ordering restrictions on Quick Mode.\"\n */\n\n/* Unfolding of Identity -- a central mystery\n *\n * This concerns Phase 1 identities, those of the IKE hosts.\n * These are the only ones that are authenticated.  Phase 2\n * identities are for IPsec SAs.\n *\n * There are three case of interest:\n *\n * (1) We initiate, based on a whack command specifying a Connection.\n *     We know the identity of the peer from the Connection.\n *\n * (2) (to be implemented) we initiate based on a flow from our client\n *     to some IP address.\n *     We immediately know one of the peer's client IP addresses from\n *     the flow.  We must use this to figure out the peer's IP address\n *     and Id.  To be solved.\n *\n * (3) We respond to an IKE negotiation.\n *     We immediately know the peer's IP address.\n *     We get an ID Payload in Main I2.\n *\n *     Unfortunately, this is too late for a number of things:\n *     - the ISAKMP SA proposals have already been made (Main I1)\n *       AND one accepted (Main R1)\n *     - the SA includes a specification of the type of ID\n *       authentication so this is negotiated without being told the ID.\n *     - with Preshared Key authentication, Main I2 is encrypted\n *       using the key, so it cannot be decoded to reveal the ID\n *       without knowing (or guessing) which key to use.\n *\n *     There are three reasonable choices here for the responder:\n *     + assume that the initiator is making wise offers since it\n *       knows the IDs involved.  We can balk later (but not gracefully)\n *       when we find the actual initiator ID\n *     + attempt to infer identity by IP address.  Again, we can balk\n *       when the true identity is revealed.  Actually, it is enough\n *       to infer properties of the identity (eg. SA properties and\n *       PSK, if needed).\n *     + make all properties universal so discrimination based on\n *       identity isn't required.  For example, always accept the same\n *       kinds of encryption.  Accept Public Key Id authentication\n *       since the Initiator presumably has our public key and thinks\n *       we must have / can find his.  This approach is weakest\n *       for preshared key since the actual key must be known to\n *       decrypt the Initiator's ID Payload.\n *     These choices can be blended.  For example, a class of Identities\n *     can be inferred, sufficient to select a preshared key but not\n *     sufficient to infer a unique identity.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <libreswan.h>\n\n#include \"sysdep.h\"\n#include \"constants.h\"\n#include \"lswlog.h\"\n\n#include \"defs.h\"\n#include \"cookie.h\"\n#include \"id.h\"\n#include \"x509.h\"\n#include \"pluto_x509.h\"\n#include \"certs.h\"\n#include \"connections.h\"        /* needs id.h */\n#include \"state.h\"\n#include \"ikev1_msgid.h\"\n#include \"packet.h\"\n#include \"md5.h\"\n#include \"sha1.h\"\n#include \"crypto.h\" /* requires sha1.h and md5.h */\n#include \"ike_alg.h\"\n#include \"log.h\"\n#include \"demux.h\"      /* needs packet.h */\n#include \"ikev1.h\"\n#include \"ipsec_doi.h\"  /* needs demux.h and state.h */\n#include \"ikev1_quick.h\"\n#include \"timer.h\"\n#include \"whack.h\"      /* requires connections.h */\n#include \"server.h\"\n\n#include \"ikev1_xauth.h\"\n\n#include \"nat_traversal.h\"\n#include \"vendor.h\"\n#include \"ikev1_dpd.h\"\n#include \"hostpair.h\"\n#include \"pluto_crypt.h\"\t/* just for log_crypto_workers() */\n\n#ifdef HAVE_NM\n#include \"kernel.h\"\n#endif\n\n/* state_microcode is a tuple of information parameterizing certain\n * centralized processing of a packet.  For example, it roughly\n * specifies what payloads are expected in this message.\n * The microcode is selected primarily based on the state.\n * In Phase 1, the payload structure often depends on the\n * authentication technique, so that too plays a part in selecting\n * the state_microcode to use.\n */\n\nstruct state_microcode {\n\tenum state_kind state, next_state;\n\tlset_t flags;\n\tlset_t req_payloads;    /* required payloads (allows just one) */\n\tlset_t opt_payloads;    /* optional payloads (any mumber) */\n\t/* if not ISAKMP_NEXT_NONE, process_packet will emit HDR with this as np */\n\tu_int8_t first_out_payload;\n\tenum event_type timeout_event;\n\tstate_transition_fn *processor;\n};\n\n/* State Microcode Flags, in several groups */\n\n/* Oakley Auth values: to which auth values does this entry apply?\n * Most entries will use SMF_ALL_AUTH because they apply to all.\n * Note: SMF_ALL_AUTH matches 0 for those circumstances when no auth\n * has been set.\n */\n#define SMF_ALL_AUTH    LRANGE(0, OAKLEY_AUTH_ROOF - 1)\n#define SMF_PSK_AUTH    LELEM(OAKLEY_PRESHARED_KEY)\n#define SMF_DS_AUTH     (LELEM(OAKLEY_DSS_SIG) | LELEM(OAKLEY_RSA_SIG))\n#define SMF_PKE_AUTH    LELEM(OAKLEY_RSA_ENC)\n#define SMF_RPKE_AUTH   LELEM(OAKLEY_RSA_REVISED_MODE)\n\n/* misc flags */\n#define SMF_INITIATOR   LELEM(OAKLEY_AUTH_ROOF + 0)\n#define SMF_FIRST_ENCRYPTED_INPUT       LELEM(OAKLEY_AUTH_ROOF + 1)\n#define SMF_INPUT_ENCRYPTED     LELEM(OAKLEY_AUTH_ROOF + 2)\n#define SMF_OUTPUT_ENCRYPTED    LELEM(OAKLEY_AUTH_ROOF + 3)\n#define SMF_RETRANSMIT_ON_DUPLICATE     LELEM(OAKLEY_AUTH_ROOF + 4)\n\n#define SMF_ENCRYPTED (SMF_INPUT_ENCRYPTED | SMF_OUTPUT_ENCRYPTED)\n\n/* this state generates a reply message */\n#define SMF_REPLY   LELEM(OAKLEY_AUTH_ROOF + 5)\n\n/* this state completes P1, so any pending P2 negotiations should start */\n#define SMF_RELEASE_PENDING_P2  LELEM(OAKLEY_AUTH_ROOF + 6)\n\n/* if we have canoncalized the authentication from XAUTH mode */\n#define SMF_XAUTH_AUTH  LELEM(OAKLEY_AUTH_ROOF + 7)\n\n/* end of flags */\n\nstatic state_transition_fn      /* forward declaration */\n\tunexpected,\n\tinformational;\n\n/* v1_state_microcode_table is a table of all state_microcode tuples.\n * It must be in order of state (the first element).\n * After initialization, ike_microcode_index[s] points to the\n * first entry in v1_state_microcode_table for state s.\n * Remember that each state name in Main or Quick Mode describes\n * what has happened in the past, not what this message is.\n */\n\nstatic const struct state_microcode\n\t*ike_microcode_index[STATE_IKE_ROOF - STATE_IKE_FLOOR];\n\nstatic const struct state_microcode v1_state_microcode_table[] = {\n\n#define PT(n) ISAKMP_NEXT_ ## n\n#define P(n) LELEM(PT(n))\n\n\t/***** Phase 1 Main Mode *****/\n\n\t/* No state for main_outI1: --> HDR, SA */\n\n\t/* STATE_MAIN_R0: I1 --> R1\n\t * HDR, SA --> HDR, SA\n\t */\n\t{ STATE_MAIN_R0, STATE_MAIN_R1,\n\t  SMF_ALL_AUTH | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR), PT(NONE),\n\t  EVENT_NULL, main_inI1_outR1 },\n\n\t/* STATE_MAIN_I1: R1 --> I2\n\t * HDR, SA --> auth dependent\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: --> HDR, KE, Ni\n\t * SMF_PKE_AUTH:\n\t *\t--> HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t * SMF_RPKE_AUTH:\n\t *\t--> HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t * Note: since we don't know auth at start, we cannot differentiate\n\t * microcode entries based on it.\n\t */\n\t{ STATE_MAIN_I1, STATE_MAIN_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR), PT(NONE), /* don't know yet */\n\t  EVENT_v1_RETRANSMIT, main_inR1_outI2 },\n\n\t/* STATE_MAIN_R1: I2 --> R2\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: HDR, KE, Ni --> HDR, KE, Nr\n\t * SMF_PKE_AUTH: HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t *\t    --> HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t * SMF_RPKE_AUTH:\n\t *\t    HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t *\t    --> HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t */\n\t{ STATE_MAIN_R1, STATE_MAIN_R2,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY\n\t  , P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC), PT(NONE)\n\t  , EVENT_v1_RETRANSMIT, main_inI2_outR2 },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_REPLY,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR) | P(HASH), PT(KE),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_RPKE_AUTH | SMF_REPLY,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR) | P(HASH) | P(CERT), PT(\n\t\t  NONCE),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t/* for states from here on, output message must be encrypted */\n\n\t/* STATE_MAIN_I2: R2 --> I3\n\t * SMF_PSK_AUTH: HDR, KE, Nr --> HDR*, IDi1, HASH_I\n\t * SMF_DS_AUTH: HDR, KE, Nr --> HDR*, IDi1, [ CERT, ] SIG_I\n\t * SMF_PKE_AUTH: HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t *\t    --> HDR*, HASH_I\n\t * SMF_RPKE_AUTH: HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t *\t    --> HDR*, HASH_I\n\t */\n\t{ STATE_MAIN_I2, STATE_MAIN_I3,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED |\n\t\tSMF_REPLY\n\t  , P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC), PT(ID)\n\t  , EVENT_v1_RETRANSMIT, main_inR2_outI3 },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR), PT(HASH),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR), PT(HASH),\n\t  EVENT_v1_RETRANSMIT, unexpected /* ??? not yet implemented */ },\n\n\t/* for states from here on, input message must be encrypted */\n\n\t/* STATE_MAIN_R2: I3 --> R3\n\t * SMF_PSK_AUTH: HDR*, IDi1, HASH_I --> HDR*, IDr1, HASH_R\n\t * SMF_DS_AUTH: HDR*, IDi1, [ CERT, ] SIG_I --> HDR*, IDr1, [ CERT, ] SIG_R\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_I --> HDR*, HASH_R\n\t */\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inI3_outR3 },\n\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inI3_outR3 },\n\n\t{ STATE_MAIN_R2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, unexpected /* ??? not yet implemented */ },\n\n\t/* STATE_MAIN_I3: R3 --> done\n\t * SMF_PSK_AUTH: HDR*, IDr1, HASH_R --> done\n\t * SMF_DS_AUTH: HDR*, IDr1, [ CERT, ] SIG_R --> done\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_R --> done\n\t * May initiate quick mode by calling quick_outI1\n\t */\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_PSK_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inR3 },\n\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_DS_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT), PT(NONE),\n\t  EVENT_SA_REPLACE, main_inR3 },\n\n\t{ STATE_MAIN_I3, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR), PT(NONE),\n\t  EVENT_SA_REPLACE, unexpected /* ??? not yet implemented */ },\n\n\t/* STATE_MAIN_R3: can only get here due to packet loss */\n\t{ STATE_MAIN_R3, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY,\n\t  PT(NONE), EVENT_NULL, unexpected },\n\n\t/* STATE_MAIN_I4: can only get here due to packet loss */\n\t{ STATE_MAIN_I4, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  PT(NONE), EVENT_NULL, unexpected },\n\n\t/***** Phase 1 Aggressive Mode *****/\n\n\t/* No initial state for aggr_outI1:\n\t * SMF_DS_AUTH (RFC 2409 5.1) and SMF_PSK_AUTH (RFC 2409 5.4):\n\t * -->HDR, SA, KE, Ni, IDii\n\t *\n\t * Not implemented:\n\t * RFC 2409 5.2: --> HDR, SA, [ HASH(1),] KE, <IDii_b>Pubkey_r, <Ni_b>Pubkey_r\n\t * RFC 2409 5.3: --> HDR, SA, [ HASH(1),] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDii_b>Ke_i [, <Cert-I_b>Ke_i ]\n\t */\n\n\t/* STATE_AGGR_R0:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Ni, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, HASH_R\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t */\n\t{ STATE_AGGR_R0, STATE_AGGR_R1,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC), PT(NONE),\n\t  EVENT_NULL, aggr_inI1_outR1 },\n\n\t/* STATE_AGGR_I1:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Nr, IDir, HASH_R\n\t *           --> HDR*, HASH_I\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t *           --> HDR*, [CERT,] SIG_I\n\t */\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_PSK_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(HASH), P(VID) | P(NATD_RFC),\n\t  PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inR1_outI2 },\n\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(SIG), P(VID) | P(NATD_RFC),\n\t  PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inR1_outI2 },\n\n\t/* STATE_AGGR_R1:\n\t * SMF_PSK_AUTH: HDR*, HASH_I --> done\n\t * SMF_DS_AUTH:  HDR*, SIG_I  --> done\n\t */\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(NATD_RFC), PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inI2 },\n\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(SIG), P(VID) | P(NATD_RFC), PT(NONE),\n\t  EVENT_SA_REPLACE, aggr_inI2 },\n\n\t/* STATE_AGGR_I2: can only get here due to packet loss */\n\t{ STATE_AGGR_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY, PT(NONE), EVENT_NULL, unexpected },\n\n\t/* STATE_AGGR_R2: can only get here due to packet loss */\n\t{ STATE_AGGR_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY, PT(NONE), EVENT_NULL, unexpected },\n\n\t/***** Phase 2 Quick Mode *****/\n\n\t/* No state for quick_outI1:\n\t * --> HDR*, HASH(1), SA, Nr [, KE ] [, IDci, IDcr ]\n\t */\n\n\t/* STATE_QUICK_R0:\n\t * HDR*, HASH(1), SA, Ni [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ]\n\t * Installs inbound IPsec SAs.\n\t * Because it may suspend for asynchronous DNS, first_out_payload\n\t * is set to NONE to suppress early emission of HDR*.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_R0, STATE_QUICK_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY\n\t  , P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(\n\t\t  NATOA_RFC), PT(NONE)\n\t  , EVENT_v1_RETRANSMIT, quick_inI1_outR1 },\n\n\t/* STATE_QUICK_I1:\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(3)\n\t * Installs inbound and outbound IPsec SAs, routing, etc.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_I1, STATE_QUICK_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED | SMF_REPLY\n\t  , P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(\n\t\t  NATOA_RFC), PT(HASH)\n\t  , EVENT_SA_REPLACE, quick_inR1_outI2 },\n\n\t/* STATE_QUICK_R1: HDR*, HASH(3) --> done\n\t * Installs outbound IPsec SAs, routing, etc.\n\t */\n\t{ STATE_QUICK_R1, STATE_QUICK_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY, PT(NONE),\n\t  EVENT_SA_REPLACE, quick_inI2 },\n\n\t/* STATE_QUICK_I2: can only happen due to lost packet */\n\t{ STATE_QUICK_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, unexpected },\n\n\t/* STATE_QUICK_R2: can only happen due to lost packet */\n\t{ STATE_QUICK_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, unexpected },\n\n\t/***** informational messages *****/\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR N/D\n\t * Unencrypted: must not occur after ISAKMP Phase 1 exchange of keying material.\n\t */\n\t/* STATE_INFO: */\n\t{ STATE_INFO, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, informational },\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR* N/D\n\t */\n\t/* STATE_INFO_PROTECTED: */\n\t{ STATE_INFO_PROTECTED, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY, PT(NONE),\n\t  EVENT_NULL, informational },\n\n\t{ STATE_XAUTH_R0, STATE_XAUTH_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_NULL, xauth_inR0 }, /*Re-transmit may be done by previous state*/\n\n\t{ STATE_XAUTH_R1, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_SA_REPLACE, xauth_inR1 },\n\n#if 0\n\t/* for situation where there is XAUTH + ModeCFG */\n\t{ STATE_XAUTH_R2, STATE_XAUTH_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_SA_REPLACE, xauth_inR2 },\n\n\t{ STATE_XAUTH_R3, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(NONE),\n\t  EVENT_SA_REPLACE, xauth_inR3 },\n#endif\n\n/* MODE_CFG_x:\n * Case R0:  Responder\t->\tInitiator\n *\t\t\t<-\tReq(addr=0)\n *\t    Reply(ad=x)\t->\n *\n * Case R1: Set(addr=x)\t->\n *\t\t\t<-\tAck(ok)\n */\n\n\t{ STATE_MODE_CFG_R0, STATE_MODE_CFG_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, modecfg_inR0 },\n\n\t{ STATE_MODE_CFG_R1, STATE_MODE_CFG_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, modecfg_inR1 },\n\n\t{ STATE_MODE_CFG_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY, PT(NONE),\n\t  EVENT_NULL, unexpected },\n\n\t{ STATE_MODE_CFG_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_SA_REPLACE, modecfg_inR1 },\n\n\t{ STATE_XAUTH_I0, STATE_XAUTH_I1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_v1_RETRANSMIT, xauth_inI0 },\n\n\t{ STATE_XAUTH_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n\t  EVENT_v1_RETRANSMIT, xauth_inI1 },\n\n#undef P\n#undef PT\n};\n\nvoid init_ikev1(void)\n{\n\t/* fill ike_microcode_index:\n\t * make ike_microcode_index[s] point to first entry in\n\t * v1_state_microcode_table for state s (backward scan makes this easier).\n\t * Check that table is in order -- catch coding errors.\n\t * For what it's worth, this routine is idempotent.\n\t */\n\tconst struct state_microcode *t;\n\n\tfor (t = &v1_state_microcode_table[elemsof(v1_state_microcode_table) - 1];;)\n\t{\n\t\tpassert(STATE_IKE_FLOOR <= t->state &&\n\t\t\tt->state < STATE_IKE_ROOF);\n\t\tike_microcode_index[t->state - STATE_IKE_FLOOR] = t;\n\t\tif (t == v1_state_microcode_table)\n\t\t\tbreak;\n\t\tt--;\n\t\tpassert(t[0].state <= t[1].state);\n\t}\n}\n\nstatic stf_status unexpected(struct msg_digest *md)\n{\n\tloglog(RC_LOG_SERIOUS, \"unexpected message received in state %s\",\n\t       enum_name(&state_names, md->st->st_state));\n\treturn STF_IGNORE;\n}\n\n/*\n * RFC 2408 Section 4.6\n *\n *  #   Initiator  Direction Responder  NOTE\n * (1)  HDR*; N/D     =>                Error Notification or Deletion\n */\nstatic stf_status informational(struct msg_digest *md)\n{\n\tstruct payload_digest *const n_pld = md->chain[ISAKMP_NEXT_N];\n\n\t/* If the Notification Payload is not null... */\n\tif (n_pld != NULL) {\n\t\tpb_stream *const n_pbs = &n_pld->pbs;\n\t\tstruct isakmp_notification *const n =\n\t\t\t&n_pld->payload.notification;\n\t\tstruct state *st = md->st;    /* may be NULL */\n\n\t\t/* Switch on Notification Type (enum) */\n\t\t/* note that we _can_ get notification payloads unencrypted\n\t\t * once we are at least in R3/I4.\n\t\t * and that the handler is expected to treat them suspiciously.\n\t\t */\n\t\tDBG(DBG_CONTROL, DBG_log(\"processing informational %s (%d)\",\n\t\t\t\t\t enum_name(&ikev1_notify_names,\n\t\t\t\t\t\t   n->isan_type),\n\t\t\t\t\t n->isan_type));\n\n\t\tswitch (n->isan_type) {\n\t\tcase R_U_THERE:\n\t\t\tif (st == NULL) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"received bogus  R_U_THERE informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inI_outR(st, n, n_pbs);\n\n\t\tcase R_U_THERE_ACK:\n\t\t\tif (st == NULL) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"received bogus R_U_THERE_ACK informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inR(st, n, n_pbs);\n\n\t\tcase PAYLOAD_MALFORMED:\n\t\t\tif (st != NULL) {\n\t\t\t\tst->hidden_variables.st_malformed_received++;\n\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"received %u malformed payload notifies\",\n\t\t\t\t\tst->hidden_variables.st_malformed_received);\n\n\t\t\t\tif (st->hidden_variables.st_malformed_sent >\n\t\t\t\t    MAXIMUM_MALFORMED_NOTIFY / 2 &&\n\t\t\t\t    ((st->hidden_variables.st_malformed_sent +\n\t\t\t\t      st->hidden_variables.\n\t\t\t\t      st_malformed_received) >\n\t\t\t\t     MAXIMUM_MALFORMED_NOTIFY)) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"too many malformed payloads (we sent %u and received %u\",\n\t\t\t\t\t\tst->hidden_variables.st_malformed_sent,\n\t\t\t\t\t\tst->hidden_variables.st_malformed_received);\n\t\t\t\t\tdelete_state(st);\n\t\t\t\t\tmd->st = st = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn STF_IGNORE;\n\n\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tif (st != NULL && IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\t/* Saving connection name and whack sock id */\n\t\t\t\tconst char *tmp_name = st->st_connection->name;\n\t\t\t\tint tmp_whack_sock = dup_any(st->st_whack_sock);\n\n\t\t\t\t/* deleting ISAKMP SA with the current remote peer */\n\t\t\t\tdelete_state(st);\n\t\t\t\tmd->st = st = NULL;\n\n\t\t\t\t/* to find and store the connection associated with tmp_name */\n\t\t\t\t/* ??? how do we know that tmp_name hasn't been freed? */\n\t\t\t\tstruct connection *tmp_c = con_by_name(tmp_name, FALSE);\n\n\t\t\t\tDBG_cond_dump(DBG_PARSING,\n\t\t\t\t\t      \"redirected remote end info:\", n_pbs->cur + pbs_left(\n\t\t\t\t\t\t      n_pbs) - 4, 4);\n\n\t\t\t\t/* Current remote peer info */\n\t\t\t\t{\n\n\t\t\t\t\tipstr_buf b;\n\t\t\t\t\tconst struct spd_route *tmp_spd =\n\t\t\t\t\t\t&tmp_c->spd;\n\t\t\t\t\tint count_spd = 0;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"spd route number: %d\",\n\t\t\t\t\t\t\t    ++count_spd));\n\n\t\t\t\t\t\t/**that info**/\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that id kind: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.id.kind));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that id ipaddr: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.id.ip_addr, &b)));\n\t\t\t\t\t\tif (tmp_spd->that.id.name.ptr\n\t\t\t\t\t\t    != NULL)\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t\t    DBG_dump_chunk(\n\t\t\t\t\t\t\t\t    \"that id name\",\n\t\t\t\t\t\t\t\t    tmp_spd->\n\t\t\t\t\t\t\t\t    that.id.\n\t\t\t\t\t\t\t\t    name));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that host_addr: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.host_addr, &b)));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that nexthop: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.host_nexthop, &b)));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that srcip: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.host_srcip, &b)));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that client_addr: %s, maskbits:%d\",\n\t\t\t\t\t\t\t    ipstr(&tmp_spd->that.client.addr, &b),\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    client.maskbits));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_client: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_client));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_client_wildcard: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_client_wildcard));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_port_wildcard: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_port_wildcard));\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"that has_id_wildcards: %d\",\n\t\t\t\t\t\t\t    tmp_spd->that.\n\t\t\t\t\t\t\t    has_id_wildcards));\n\n\t\t\t\t\t\ttmp_spd = tmp_spd->spd_next;\n\t\t\t\t\t} while (tmp_spd != NULL);\n\n\t\t\t\t\tif (tmp_c->interface != NULL) {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\"Current interface_addr: %s\",\n\t\t\t\t\t\t\t    ipstr(&tmp_c->interface->ip_addr, &b)));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp_c->gw_info != NULL) {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE, {\n\t\t\t\t\t\t\t    DBG_log(\"Current gw_client_addr: %s\",\n\t\t\t\t\t\t\t\t    ipstr(&tmp_c->gw_info->client_id.ip_addr, &b));\n\t\t\t\t\t\t\t    DBG_log(\"Current gw_gw_addr: %s\",\n\t\t\t\t\t\t\t\t    ipstr(&tmp_c->gw_info->gw_id.ip_addr, &b));\n\t\t\t\t\t\t    });\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/* storing old address for comparison purposes */\n\t\t\t\tip_address old_addr = tmp_c->spd.that.host_addr;\n\n\t\t\t\t/* Decoding remote peer address info where connection has to be redirected to */\n\t\t\t\tmemcpy(&tmp_c->spd.that.host_addr.u.v4.sin_addr.s_addr,\n\t\t\t\t\t(u_int32_t *)(n_pbs->cur +\n\t\t\t\t\t\t      pbs_left(n_pbs) - 4),\n\t\t\t\t\tsizeof(tmp_c->spd.that.host_addr.u.v4.\n\t\t\t\t\t       sin_addr.\n\t\t\t\t\t       s_addr));\n\n\t\t\t\t/* Modifying connection info to store the redirected remote peer info */\n\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t    DBG_log(\"Old host_addr_name : %s\",\n\t\t\t\t\t    tmp_c->spd.that.host_addr_name));\n\t\t\t\ttmp_c->spd.that.host_addr_name = NULL;\n\t\t\t\ttmp_c->spd.that.id.ip_addr =\n\t\t\t\t\ttmp_c->spd.that.host_addr;\n\n\t\t\t\tDBG(DBG_CONTROLMORE, {\n\t\t\t\t\tipstr_buf b;\n\t\t\t\t\tif (sameaddr(&tmp_c->spd.this.\n\t\t\t\t\t\t     host_nexthop,\n\t\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\t\tDBG_log(\"Old remote addr %s\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"Old this host next hop %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.this.host_nexthop, &b));\n\t\t\t\t\t\ttmp_c->spd.this.host_nexthop = tmp_c->spd.that.host_addr;\n\t\t\t\t\t\tDBG_log(\"New this host next hop %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.this.host_nexthop, &b));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sameaddr(&tmp_c->spd.that.\n\t\t\t\t\t\t     host_srcip,\n\t\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\t\tDBG_log(\"Old that host srcip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.host_srcip, &b));\n\t\t\t\t\t\ttmp_c->spd.that.host_srcip = tmp_c->spd.that.host_addr;\n\t\t\t\t\t\tDBG_log(\"New that host srcip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.host_srcip, &b));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sameaddr(&tmp_c->spd.that.\n\t\t\t\t\t\t     client.addr,\n\t\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\t\tDBG_log(\"Old that client ip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.client.addr, &b));\n\t\t\t\t\t\ttmp_c->spd.that.client.addr = tmp_c->spd.that.host_addr;\n\t\t\t\t\t\tDBG_log(\"New that client ip %s\",\n\t\t\t\t\t\t\tipstr(&tmp_c->spd.that.client.addr, &b));\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\ttmp_c->host_pair->him.addr =\n\t\t\t\t\ttmp_c->spd.that.host_addr;\n\n\t\t\t\t/* Initiating connection to the redirected peer */\n\t\t\t\tinitiate_connection(tmp_name, tmp_whack_sock,\n\t\t\t\t\t\t    LEMPTY, pcim_demand_crypto);\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"received and ignored informational message with ISAKMP_N_CISCO_LOAD_BALANCE for unestablished state.\");\n\t\t\treturn STF_IGNORE;\n\t\tdefault:\n\t\t\tif (st != NULL &&\n\t\t\t    (st->st_connection->extra_debugging &\n\t\t\t     IMPAIR_DIE_ONINFO)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"received unhandled informational notification payload %d: '%s'\",\n\t\t\t\t       n->isan_type,\n\t\t\t\t       enum_name(&ikev1_notify_names,\n\t\t\t\t\t\t n->isan_type));\n\t\t\t\treturn STF_FATAL;\n\t\t\t}\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"received and ignored informational message\");\n\t\t\treturn STF_IGNORE;\n\t\t}\n\t} else {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"received and ignored empty informational notification payload\");\n\t\treturn STF_IGNORE;\n\t}\n}\n\n/* create output HDR as replica of input HDR - IKEv1 only */\nvoid ikev1_echo_hdr(struct msg_digest *md, bool enc, u_int8_t np)\n{\n\tstruct isakmp_hdr hdr = md->hdr; /* mostly same as incoming header */\n\n\t/* make sure we start with a clean buffer */\n\tinit_out_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\thdr.isa_flags = 0; /* zero all flags */\n\tif (enc)\n\t\thdr.isa_flags |= ISAKMP_FLAGS_v1_ENCRYPTION;\n\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\thdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;\n\t}\n\n\t/* there is only one IKEv1 version, and no new one will ever come - no need to set version */\n\thdr.isa_np = np;\n\tif (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream, &md->rbody))\n\t\timpossible(); /* surely must have room and be well-formed */\n}\n\n/* process an input packet, possibly generating a reply.\n *\n * If all goes well, this routine eventually calls a state-specific\n * transition function.\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_v1_packet(struct msg_digest **mdp)\n{\n\tstruct msg_digest *md = *mdp;\n\tconst struct state_microcode *smc;\n\tbool new_iv_set = FALSE;\n\tstruct state *st = NULL;\n\tenum state_kind from_state = STATE_UNDEFINED;   /* state we started in */\n\n#define SEND_NOTIFICATION(t) { \\\n\t\tif (st != NULL) \\\n\t\t\tsend_notification_from_state(st, from_state, t); \\\n\t\telse \\\n\t\t\tsend_notification_from_md(md, t); }\n\n\tswitch (md->hdr.isa_xchg) {\n#ifdef NOTYET\n\tcase ISAKMP_XCHG_NONE:\n\tcase ISAKMP_XCHG_BASE:\n\tcase ISAKMP_XCHG_AO:\n#endif\n\n\tcase ISAKMP_XCHG_AGGR:\n\tcase ISAKMP_XCHG_IDPROT: /* part of a Main Mode exchange */\n\t\tif (md->hdr.isa_msgid != v1_MAINMODE_MSGID) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"Message ID was 0x%08lx but should be zero in phase 1\",\n\t\t\t\t(unsigned long) md->hdr.isa_msgid);\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_icookie)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"Initiator Cookie must not be zero in phase 1 message\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_rcookie)) {\n\t\t\t/* initial message from initiator\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\t\tlibreswan_log(\"initial phase 1 message is invalid:\"\n\t\t\t\t\t      \" its Encrypted Flag is on\");\n\t\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* don't build a state until the message looks tasty */\n\t\t\tfrom_state = (md->hdr.isa_xchg == ISAKMP_XCHG_IDPROT ?\n\t\t\t\t      STATE_MAIN_R0 : STATE_AGGR_R0);\n\t\t} else {\n\t\t\t/* not an initial message */\n\n\t\t\tst = find_state_ikev1(md->hdr.isa_icookie,\n\t\t\t\t\t      md->hdr.isa_rcookie,\n\t\t\t\t\t      md->hdr.isa_msgid);\n\n\t\t\tif (st == NULL) {\n\t\t\t\t/* perhaps this is a first message from the responder\n\t\t\t\t * and contains a responder cookie that we've not yet seen.\n\t\t\t\t */\n\t\t\t\tst = find_state_ikev1(md->hdr.isa_icookie,\n\t\t\t\t\t\t      zero_cookie,\n\t\t\t\t\t\t      md->hdr.isa_msgid);\n\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"phase 1 message is part of an unknown exchange\");\n\t\t\t\t\t/* XXX Could send notification back */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_INFO:  /* an informational exchange */\n\t\tst = ikev1_find_info_state(md->hdr.isa_icookie, md->hdr.isa_rcookie,\n\t\t\t\t     &md->sender, v1_MAINMODE_MSGID);\n\n\t\tif (st == NULL) {\n\t\t\t/*\n\t\t\t * might be an informational response to our first\n\t\t\t * message, in which case, we don't know the rcookie yet.\n\t\t\t */\n\t\t\tst = find_state_ikev1(md->hdr.isa_icookie, zero_cookie,\n\t\t\t\t\t      v1_MAINMODE_MSGID);\n\t\t}\n\n\t\tif (st != NULL)\n\t\t\tset_cur_state(st);\n\n\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\tbool quiet = (st == NULL ||\n\t\t\t\t     (st->st_connection->policy & POLICY_OPPORTUNISTIC));\n\n\t\t\tif (st == NULL) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\t\"Informational Exchange is for an unknown (expired?) SA with MSGID:0x%08lx\",\n\t\t\t\t\t\t\t(unsigned long)md->hdr.isa_msgid));\n\n\t\t\t\t/* Let's try to log some info about these to track them down */\n\t\t\t\tDBG(DBG_CONTROL, {\n\t\t\t\t\t    DBG_dump(\"- unknown SA's md->hdr.isa_icookie:\",\n\t\t\t\t\t\t    md->hdr.isa_icookie,\n\t\t\t\t\t\t    COOKIE_SIZE);\n\t\t\t\t\t    DBG_dump(\"- unknown SA's md->hdr.isa_rcookie:\",\n\t\t\t\t\t\t    md->hdr.isa_rcookie,\n\t\t\t\t\t\t    COOKIE_SIZE);\n\t\t\t\t    });\n\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IS_ISAKMP_ENCRYPTED(st->st_state)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"encrypted Informational Exchange message is invalid because no key is known\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Informational Exchange message is invalid because it has a Message ID of 0\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Informational Exchange message is invalid because it has a previously used Message ID (0x%08lx)\",\n\t\t\t\t\t\t(unsigned long)md->hdr.isa_msgid);\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_msgid_reserved = FALSE;\n\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_INFO_PROTECTED;\n\t\t} else {\n\t\t\tif (st != NULL &&\n\t\t\t    IS_ISAKMP_AUTHENTICATED(st->st_state)) {\n\t\t\t\tif ((st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Informational Exchange message must be encrypted\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfrom_state = STATE_INFO;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_QUICK: /* part of a Quick Mode exchange */\n\n\t\tif (is_zero_cookie(md->hdr.isa_icookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"Quick Mode message is invalid because it has an Initiator Cookie of 0\"));\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_rcookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"Quick Mode message is invalid because it has a Responder Cookie of 0\"));\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"Quick Mode message is invalid because it has a Message ID of 0\"));\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tst = find_state_ikev1(md->hdr.isa_icookie, md->hdr.isa_rcookie,\n\t\t\t\t      md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\t/* No appropriate Quick Mode state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tst = find_state_ikev1(md->hdr.isa_icookie,\n\t\t\t\t\t      md->hdr.isa_rcookie,\n\t\t\t\t\t      v1_MAINMODE_MSGID);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"Quick Mode message is for a non-existent (expired?) ISAKMP SA\"));\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"Cannot do Quick Mode until XAUTH done.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Have we just given an IP address to peer? */\n\t\t\tif (st->st_state == STATE_MODE_CFG_R2) {\n\t\t\t\t/* ISAKMP is up... */\n\t\t\t\tchange_state(st, STATE_MAIN_R3);\n\t\t\t}\n\n#ifdef SOFTREMOTE_CLIENT_WORKAROUND\n\t\t\t/* See: http://popoludnica.pl/?id=10100110 */\n\t\t\tif (st->st_state == STATE_MODE_CFG_R1) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"SoftRemote workaround: Cannot do Quick Mode until MODECFG done.\");\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\tset_cur_state(st);\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tif (DBGP(DBG_OPPO) || (st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Quick Mode message is unacceptable because it is for an incomplete ISAKMP SA\");\n\t\t\t\t}\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED /* XXX ? */);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tif (DBGP(DBG_OPPO) || (st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"Quick Mode I1 message is unacceptable because it uses a previously used Message ID 0x%08lx (perhaps this is a duplicated packet)\",\n\t\t\t\t\t\t(unsigned long) md->hdr.isa_msgid);\n\t\t\t\t}\n\t\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_msgid_reserved = FALSE;\n\n\t\t\t/* Quick Mode Initial IV */\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_QUICK_R0;\n\t\t} else {\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tif (DBGP(DBG_OPPO) ||\n\t\t\t\t    (st->st_connection->policy & POLICY_OPPORTUNISTIC) == LEMPTY) {\n\t\t\t\t\tlibreswan_log(\"Cannot do Quick Mode until XAUTH done.\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_MODE_CFG:\n\t\tif (is_zero_cookie(md->hdr.isa_icookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"Mode Config message is invalid because it has an Initiator Cookie of 0\"));\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_zero_cookie(md->hdr.isa_rcookie)) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"Mode Config message is invalid because it has a Responder Cookie of 0\"));\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == 0) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"Mode Config message is invalid because it has a Message ID of 0\"));\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tst = ikev1_find_info_state(md->hdr.isa_icookie, md->hdr.isa_rcookie,\n\t\t\t\t     &md->sender, md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"No appropriate Mode Config state yet.See if we have a Main Mode state\"));\n\t\t\t/* No appropriate Mode Config state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tst = ikev1_find_info_state(md->hdr.isa_icookie,\n\t\t\t\t\t     md->hdr.isa_rcookie,\n\t\t\t\t\t     &md->sender, 0);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"Mode Config message is for a non-existent (expired?) ISAKMP SA\"));\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tset_cur_state(st);\n\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\" processing received \"\n\t\t\t\t\t\t     \"isakmp_xchg_type %s.\",\n\t\t\t\t\t\t     enum_show(&ikev1_exchange_names,\n\t\t\t\t\t\t\t       md->hdr.isa_xchg)));\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\" this is a%s%s%s%s\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.xauth_server ?\n\t\t\t\t\t\t     \" xauthserver\" : \"\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.xauth_client ?\n\t\t\t\t\t\t     \" xauthclient\" : \"\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.modecfg_server ?\n\t\t\t\t\t\t     \" modecfgserver\" : \"\",\n\t\t\t\t\t\t     st->st_connection->spd.\n\t\t\t\t\t\t     this.modecfg_client  ?\n\t\t\t\t\t\t     \" modecfgclient\" : \"\"\n\t\t\t\t\t\t     ));\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\"Mode Config message is unacceptable because it is for an incomplete ISAKMP SA (state=%s)\",\n\t\t\t\t       enum_name(&state_names, st->st_state)));\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\" call  init_phase2_iv\"));\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\t/*\n\t\t\t * okay, now we have to figure out if we are receiving a bogus\n\t\t\t * new message in an oustanding XAUTH server conversation\n\t\t\t * (i.e. a reply to our challenge)\n\t\t\t * (this occurs with some broken other implementations).\n\t\t\t *\n\t\t\t * or if receiving for the first time, an XAUTH challenge.\n\t\t\t *\n\t\t\t * or if we are getting a MODECFG request.\n\t\t\t *\n\t\t\t * we distinguish these states because we cannot both be an\n\t\t\t * XAUTH server and client, and our policy tells us which\n\t\t\t * one we are.\n\t\t\t *\n\t\t\t * to complicate further, it is normal to start a new msgid\n\t\t\t * when going from one state to another, or when restarting\n\t\t\t * the challenge.\n\t\t\t *\n\t\t\t */\n\n\t\t\tif (st->st_connection->spd.this.xauth_server &&\n\t\t\t    st->st_state == STATE_XAUTH_R1 &&\n\t\t\t    st->quirks.xauth_ack_msgid) {\n\t\t\t\tfrom_state = STATE_XAUTH_R1;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s state is STATE_XAUTH_R1 and quirks.xauth_ack_msgid is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.xauth_client\n\t\t\t\t   &&\n\t\t\t\t   IS_PHASE1(st->st_state)) {\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is xauthclient and IS_PHASE1() is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.xauth_client\n\t\t\t\t   &&\n\t\t\t\t   st->st_state == STATE_XAUTH_I1) {\n\t\t\t\t/*\n\t\t\t\t * in this case, we got a new MODECFG message after I0, maybe\n\t\t\t\t * because it wants to start over again.\n\t\t\t\t */\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is xauthclient and state == STATE_XAUTH_I1\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.modecfg_server\n\t\t\t\t   &&\n\t\t\t\t   IS_PHASE1(st->st_state)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R0;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is modecfgserver and IS_PHASE1() is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else if (st->st_connection->spd.this.modecfg_client\n\t\t\t\t   &&\n\t\t\t\t   IS_PHASE1(st->st_state)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R1;\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\" set from_state to %s this is modecfgclient and IS_PHASE1() is TRUE\",\n\t\t\t\t\t    enum_name(&state_names,\n\t\t\t\t\t\t      st->st_state\n\t\t\t\t\t\t      )));\n\t\t\t} else {\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\"received isakmp_xchg_type %s\",\n\t\t\t\t\t    enum_show(&ikev1_exchange_names,\n\t\t\t\t\t\t      md->hdr.isa_xchg)));\n\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\"this is a%s%s%s%s in state %s. Reply with UNSUPPORTED_EXCHANGE_TYPE\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.xauth_server ?\n\t\t\t\t\t    \" xauthserver\" : \"\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.xauth_client ?\n\t\t\t\t\t    \" xauthclient\" : \"\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.modecfg_server ?\n\t\t\t\t\t    \" modecfgserver\" :\n\t\t\t\t\t    \"\",\n\t\t\t\t\t    st->st_connection\n\t\t\t\t\t    ->spd.this.modecfg_client  ?\n\t\t\t\t\t    \" modecfgclient\" :\n\t\t\t\t\t    \"\",\n\t\t\t\t\t    enum_name(&\n\t\t\t\t\t\t      state_names,\n\t\t\t\t\t\t      st->st_state)\n\t\t\t\t\t    ));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (st->st_connection->spd.this.xauth_server &&\n\t\t\t    IS_PHASE1(st->st_state)) {\n\t\t\t\t/* Switch from Phase1 to Mode Config */\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\"We were in phase 1, with no state, so we went to XAUTH_R0\"));\n\t\t\t\tchange_state(st, STATE_XAUTH_R0);\n\t\t\t}\n\n\t\t\t/* otherweise, this is fine, we continue in the state we are in */\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_NGRP:\n\tdefault:\n\t\tDBG(DBG_CONTROL, DBG_log(\"unsupported exchange type %s in message\",\n\t\t\t      enum_show(&ikev1_exchange_names, md->hdr.isa_xchg)));\n\t\tSEND_NOTIFICATION(UNSUPPORTED_EXCHANGE_TYPE);\n\t\treturn;\n\t}\n\n\t/* We have found a from_state, and perhaps a state object.\n\t * If we need to build a new state object,\n\t * we wait until the packet has been sanity checked.\n\t */\n\n\t/* We don't support the Commit Flag.  It is such a bad feature.\n\t * It isn't protected -- neither encrypted nor authenticated.\n\t * A man in the middle turns it on, leading to DoS.\n\t * We just ignore it, with a warning.\n\t */\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_COMMIT)\n\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\"IKE message has the Commit Flag set but Pluto doesn't implement this feature due to security concerns; ignoring flag\"));\n\n\n\t/* Handle IKE fragmentation payloads */\n\tif (md->hdr.isa_np == ISAKMP_NEXT_IKE_FRAGMENTATION) {\n\t\tstruct isakmp_ikefrag fraghdr;\n\t\tstruct ike_frag *ike_frag, **i;\n\t\tint last_frag_index = 0;  /* index of the last fragment */\n\t\tpb_stream frag_pbs;\n\n\t\tif (st == NULL) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\"received IKE fragment, but have no state. Ignoring packet.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif ((st->st_connection->policy & POLICY_IKE_FRAG_ALLOW) == 0) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t       \"discarding IKE fragment packet - fragmentation not allowed by local policy (ike_frag=no)\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!in_struct(&fraghdr, &isakmp_ikefrag_desc,\n\t\t\t       &md->message_pbs, &frag_pbs) ||\n\t\t    pbs_room(&frag_pbs) != fraghdr.isafrag_length ||\n\t\t    fraghdr.isafrag_np != 0 ||\n\t\t    fraghdr.isafrag_number == 0 || fraghdr.isafrag_number >\n\t\t    16) {\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"received IKE fragment id '%d', number '%u'%s\",\n\t\t\t    fraghdr.isafrag_id,\n\t\t\t    fraghdr.isafrag_number,\n\t\t\t    (fraghdr.isafrag_flags == 1) ? \"(last)\" : \"\"));\n\n\t\tike_frag = alloc_thing(struct ike_frag, \"ike_frag\");\n\t\tike_frag->md = md;\n\t\tike_frag->index = fraghdr.isafrag_number;\n\t\tike_frag->last = (fraghdr.isafrag_flags & 1);\n\t\tike_frag->size = pbs_left(&frag_pbs);\n\t\tike_frag->data = frag_pbs.cur;\n\n#if 0\n/* is this ever hit? It was wrongly checking one byte instead of 4 bytes of marker */\n\t\t/* Strip non-ESP marker from first fragment */\n\t\tif (md->iface->ike_float && ike_frag->index == 1 &&\n\t\t    (ike_frag->size >= NON_ESP_MARKER_SIZE &&\n\t\t     memeq(non_ESP_marker, ike_frag->data,\n\t\t\t    NON_ESP_MARKER_SIZE))) {\n\t\t\tike_frag->data += NON_ESP_MARKER_SIZE;\n\t\t\tike_frag->size -= NON_ESP_MARKER_SIZE;\n\t\t}\n#endif\n\n\t\t/* Add the fragment to the state */\n\t\ti = &st->ike_frags;\n\t\tfor (;;) {\n\t\t\tif (ike_frag != NULL) {\n\t\t\t\t/* Still looking for a place to insert ike_frag */\n\t\t\t\tif (*i == NULL ||\n\t\t\t\t    (*i)->index > ike_frag->index) {\n\t\t\t\t\tike_frag->next = *i;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t} else if ((*i)->index == ike_frag->index) {\n\t\t\t\t\t/* Replace fragment with same index */\n\t\t\t\t\tstruct ike_frag *old = *i;\n\n\t\t\t\t\tike_frag->next = old->next;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\trelease_md(old->md);\n\t\t\t\t\tpfree(old);\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*i == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif ((*i)->last)\n\t\t\t\tlast_frag_index = (*i)->index;\n\n\t\t\ti = &(*i)->next;\n\t\t}\n\n\t\t/* We have the last fragment, reassemble if complete */\n\t\tif (last_frag_index != 0) {\n\t\t\tsize_t size = 0;\n\t\t\tint prev_index = 0;\n\t\t\tstruct ike_frag *frag;\n\n\t\t\tfor (frag = st->ike_frags; frag; frag = frag->next) {\n\t\t\t\tsize += frag->size;\n\t\t\t\tif (frag->index != ++prev_index) {\n\t\t\t\t\tbreak; /* fragment list incomplete */\n\t\t\t\t} else if (frag->index == last_frag_index) {\n\t\t\t\t\tstruct msg_digest *whole_md = alloc_md();\n\t\t\t\t\tu_int8_t *buffer = alloc_bytes(size,\n\t\t\t\t\t\t\t\t       \"IKE fragments buffer\");\n\t\t\t\t\tsize_t offset = 0;\n\n\t\t\t\t\twhole_md->iface = frag->md->iface;\n\t\t\t\t\twhole_md->sender = frag->md->sender;\n\t\t\t\t\twhole_md->sender_port =\n\t\t\t\t\t\tfrag->md->sender_port;\n\n\t\t\t\t\t/* Reassemble fragments in buffer */\n\t\t\t\t\tfrag = st->ike_frags;\n\t\t\t\t\twhile (frag != NULL &&\n\t\t\t\t\t       frag->index <= last_frag_index)\n\t\t\t\t\t{\n\t\t\t\t\t\tpassert(offset + frag->size <=\n\t\t\t\t\t\t\tsize);\n\t\t\t\t\t\tmemcpy(buffer + offset,\n\t\t\t\t\t\t       frag->data, frag->size);\n\t\t\t\t\t\toffset += frag->size;\n\t\t\t\t\t\tfrag = frag->next;\n\t\t\t\t\t}\n\n\t\t\t\t\tinit_pbs(&whole_md->packet_pbs, buffer, size,\n\t\t\t\t\t\t \"packet\");\n\n\t\t\t\t\tprocess_packet(&whole_md);\n\t\t\t\t\trelease_any_md(&whole_md);\n\t\t\t\t\trelease_fragments(st);\n\t\t\t\t\t/* optimize: if receiving fragments, immediately respond with fragments too */\n\t\t\t\t\tst->st_seen_fragments = TRUE;\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t\t\" updated IKE fragment state to respond using fragments without waiting for re-transmits\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Don't release the md, taken care of by the ike_frag code */\n\t\t/* ??? I'm not sure -- DHR */\n\t\t*mdp = NULL;\n\t\treturn;\n\t}\n\n\t/* Set smc to describe this state's properties.\n\t * Look up the appropriate microcode based on state and\n\t * possibly Oakley Auth type.\n\t */\n\tpassert(STATE_IKE_FLOOR <= from_state && from_state <= STATE_IKE_ROOF);\n\tsmc = ike_microcode_index[from_state - STATE_IKE_FLOOR];\n\n\tif (st != NULL) {\n\t\toakley_auth_t baseauth =\n\t\t\txauth_calcbaseauth(st->st_oakley.auth);\n\n\t\twhile (!LHAS(smc->flags, baseauth)) {\n\t\t\tsmc++;\n\t\t\tpassert(smc->state == from_state);\n\t\t}\n\t}\n\n\tif (state_busy(st))\n\t\treturn;\n\n\t/* Detect and handle duplicated packets.\n\t * This won't work for the initial packet of an exchange\n\t * because we won't have a state object to remember it.\n\t * If we are in a non-receiving state (terminal), and the preceding\n\t * state did transmit, then the duplicate may indicate that that\n\t * transmission wasn't received -- retransmit it.\n\t * Otherwise, just discard it.\n\t * ??? Notification packets are like exchanges -- I hope that\n\t * they are idempotent!\n\t */\n\tif (st != NULL &&\n\t    st->st_rpacket.ptr != NULL &&\n\t    st->st_rpacket.len == pbs_room(&md->packet_pbs) &&\n\t    memeq(st->st_rpacket.ptr, md->packet_pbs.start,\n\t\t   st->st_rpacket.len)) {\n\t\tif (smc->flags & SMF_RETRANSMIT_ON_DUPLICATE) {\n\t\t\tif (st->st_retransmit < MAXIMUM_v1_ACCEPTED_DUPLICATES) {\n\t\t\t\tst->st_retransmit++;\n\t\t\t\tloglog(RC_RETRANSMISSION,\n\t\t\t\t       \"retransmitting in response to duplicate packet; already %s\",\n\t\t\t\t       enum_name(&state_names, st->st_state));\n\t\t\t\tresend_ike_v1_msg(st,\n\t\t\t\t\t\t  \"retransmit in response to duplicate\");\n\t\t\t} else {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"discarding duplicate packet -- exhausted retransmission; already %s\",\n\t\t\t\t       enum_name(&state_names, st->st_state));\n\t\t\t}\n\t\t} else {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"discarding duplicate packet; already %s\",\n\t\t\t       enum_name(&state_names, st->st_state));\n\t\t}\n\t\treturn;\n\t}\n\n\t/* save values for use in resumption of processing below.\n\t * (may be suspended due to crypto operation not yet complete)\n\t */\n\tmd->st = st;\n\tmd->from_state = from_state;\n\tmd->smc = smc;\n\tmd->new_iv_set = new_iv_set;\n\n\t/*\n\t * look for encrypt packets. We cannot handle them if we have not\n\t * yet calculated the skeyids. We will just store the packet in\n\t * the suspended state, since the calculation is likely underway.\n\t *\n\t * note that this differs from above, because skeyid is calculated\n\t * in between states. (or will be, once DH is async)\n\t *\n\t */\n\tif ((md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) &&\n\t    st != NULL && !st->hidden_variables.st_skeyid_calculated ) {\n\t\tDBG(DBG_CRYPT | DBG_CONTROL, {\n\t\t\tipstr_buf b;\n\t\t\tDBG_log(\"received encrypted packet from %s:%u but exponentiation still in progress\",\n\t\t\t\tipstr(&md->sender, &b),\n\t\t\t\t(unsigned)md->sender_port);\n\t\t});\n\n\t\t/* if there was a previous packet, let it go, and go with most\n\t\t * recent one.\n\t\t */\n\t\tif (st->st_suspended_md != NULL) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"releasing suspended operation before completion: %p\",\n\t\t\t\t    st->st_suspended_md));\n\t\t\trelease_any_md(&st->st_suspended_md);\n\t\t}\n\n\t\tset_suspended(st, md);\n\t\t*mdp = NULL;\n\t\treturn;\n\t}\n\n\tprocess_packet_tail(mdp);\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_packet_tail(struct msg_digest **mdp)\n{\n\tstruct msg_digest *md = *mdp;\n\tstruct state *st = md->st;\n\tenum state_kind from_state = md->from_state;\n\tconst struct state_microcode *smc = md->smc;\n\tbool new_iv_set = md->new_iv_set;\n\tbool self_delete = FALSE;\n\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\tDBG(DBG_CRYPT, {\n\t\t\tipstr_buf b;\n\t\t\tDBG_log(\"received encrypted packet from %s:%u\",\n\t\t\t\tipstr(&md->sender, &b),\n\t\t\t\t(unsigned)md->sender_port);\n\t\t});\n\n\t\tif (st == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"discarding encrypted message for an unknown ISAKMP SA\");\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED /* XXX ? */);\n\t\t\treturn;\n\t\t}\n\t\tif (st->st_skey_ei_nss == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\"discarding encrypted message because we haven't yet negotiated keying material\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Mark as encrypted */\n\t\tmd->encrypted = TRUE;\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_log(\"decrypting %u bytes using algorithm %s\",\n\t\t\t    (unsigned) pbs_left(&md->message_pbs),\n\t\t\t    enum_show(&oakley_enc_names,\n\t\t\t\t      st->st_oakley.encrypt)));\n\n\t\t/* do the specified decryption\n\t\t *\n\t\t * IV is from st->st_iv or (if new_iv_set) st->st_new_iv.\n\t\t * The new IV is placed in st->st_new_iv\n\t\t *\n\t\t * See RFC 2409 \"IKE\" Appendix B\n\t\t *\n\t\t * XXX The IV should only be updated really if the packet\n\t\t * is successfully processed.\n\t\t * We should keep this value, check for a success return\n\t\t * value from the parsing routines and then replace.\n\t\t *\n\t\t * Each post phase 1 exchange generates IVs from\n\t\t * the last phase 1 block, not the last block sent.\n\t\t */\n\t\t{\n\t\t\tconst struct encrypt_desc *e = st->st_oakley.encrypter;\n\n\t\t\tif (pbs_left(&md->message_pbs) % e->enc_blocksize != 0)\n\t\t\t{\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"malformed message: not a multiple of encryption blocksize\");\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* XXX Detect weak keys */\n\n\t\t\t/* grab a copy of raw packet (for duplicate packet detection) */\n\t\t\tclonetochunk(md->raw_packet, md->packet_pbs.start,\n\t\t\t\t     pbs_room(&md->packet_pbs), \"raw packet\");\n\n\t\t\t/* Decrypt everything after header */\n\t\t\tif (!new_iv_set) {\n\t\t\t\tif (st->st_iv_len == 0) {\n\t\t\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\t\t} else {\n\t\t\t\t\t/* use old IV */\n\t\t\t\t\trestore_new_iv(st, st->st_iv, st->st_iv_len);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcrypto_cbc_encrypt(e, FALSE, md->message_pbs.cur,\n\t\t\t\t\t   pbs_left(&md->message_pbs), st);\n\n\t\t}\n\n\t\tDBG_cond_dump(DBG_CRYPT, \"decrypted:\\n\", md->message_pbs.cur,\n\t\t\t      md->message_pbs.roof - md->message_pbs.cur);\n\n\t\tDBG_cond_dump(DBG_CRYPT, \"next IV:\",\n\t\t\t      st->st_new_iv, st->st_new_iv_len);\n\t} else {\n\t\t/* packet was not encryped -- should it have been? */\n\n\t\tif (smc->flags & SMF_INPUT_ENCRYPTED) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"packet rejected: should have been encrypted\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Digest the message.\n\t * Padding must be removed to make hashing work.\n\t * Padding comes from encryption (so this code must be after decryption).\n\t * Padding rules are described before the definition of\n\t * struct isakmp_hdr in packet.h.\n\t */\n\t{\n\t\tstruct payload_digest *pd = md->digest;\n\t\tenum next_payload_types_ikev1 np = md->hdr.isa_np;\n\t\tlset_t needed = smc->req_payloads;\n\t\tconst char *excuse =\n\t\t\tLIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,\n\t\t\t    smc->flags) ?\n\t\t\t\"probable authentication failure (mismatch of preshared secrets?): \"\n\t\t\t:\n\t\t\t\"\";\n\n\t\twhile (np != ISAKMP_NEXT_NONE) {\n\t\t\tstruct_desc *sd = v1_payload_desc(np);\n\n\t\t\tif (pd == &md->digest[PAYLIMIT]) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"more than %d payloads in message; ignored\",\n\t\t\t\t       PAYLIMIT);\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * only do this in main mode. In aggressive mode, there\n\t\t\t * is no negotiation of NAT-T method. Get it right.\n\t\t\t */\n\t\t\tif (st != NULL && st->st_connection != NULL &&\n\t\t\t    (st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)\n\t\t\t{\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_NATD_RFC:\n\t\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t\tif ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t\t\t\t\t * unless we're using NAT-T RFC\n\t\t\t\t\t\t */\n\t\t\t\t\t\tDBG(DBG_NATT,\n\t\t\t\t\t\t    DBG_log(\"st_nat_traversal was: %s\",\n\t\t\t\t\t\t\t    bitnamesof(natt_bit_names,\n\t\t\t\t\t\t\t\t       st->hidden_variables.st_nat_traversal)));\n\t\t\t\t\t\tsd = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd == NULL) {\n\t\t\t\t/* payload type is out of range or requires special handling */\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\t\t\t/* ??? two kinds of ID payloads */\n\t\t\t\t\tsd = (IS_PHASE1(from_state) ||\n\t\t\t\t\t      IS_PHASE15(from_state)) ?\n\t\t\t\t\t\t&isakmp_identification_desc :\n\t\t\t\t\t\t&isakmp_ipsec_identification_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATD_DRAFTS:\n\t\t\t\t\t/* NAT-D was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATD_RFC;\n\t\t\t\t\tsd = v1_payload_desc(np);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATOA_DRAFTS:\n\t\t\t\t\t/* NAT-OA was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATOA_RFC;\n\t\t\t\t\tsd = v1_payload_desc(np);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_SAK: /* or ISAKMP_NEXT_NATD_BADDRAFTS */\n\t\t\t\t\t/*\n\t\t\t\t\t * Official standards say that this is ISAKMP_NEXT_SAK,\n\t\t\t\t\t * a part of Group DOI, something we don't implement.\n\t\t\t\t\t * Old non-updated Cisco gear abused this number in ancient NAT drafts.\n\t\t\t\t\t * We ignore (rather than reject) this in support of people\n\t\t\t\t\t * with crufty Cisco machines.\n\t\t\t\t\t */\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored\",\n\t\t\t\t\t\texcuse);\n\t\t\t\t\t/*\n\t\t\t\t\t * Hack to discard payload, whatever it was.\n\t\t\t\t\t * Since we are skipping the rest of the loop\n\t\t\t\t\t * body we must do some things ourself:\n\t\t\t\t\t * - demarshall the payload\n\t\t\t\t\t * - grab the next payload number (np)\n\t\t\t\t\t * - don't keep payload (don't increment pd)\n\t\t\t\t\t * - skip rest of loop body\n\t\t\t\t\t */\n\t\t\t\t\tif (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,\n\t\t\t\t\t\t       &pd->pbs)) {\n\t\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t\t\t       excuse);\n\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\t\t\t/* NOTE: we do not increment pd! */\n\t\t\t\t\tcontinue;  /* skip rest of the loop */\n\n\t\t\t\tdefault:\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpassert(sd != NULL);\n\t\t\t}\n\n\t\t\tpassert(np < LELEM_ROOF);\n\n\t\t\t{\n\t\t\t\tlset_t s = LELEM(np);\n\n\t\t\t\tif (LDISJOINT(s,\n\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"%smessage ignored because it \"\n\t\t\t\t\t       \"contains an unexpected payload type (%s)\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \"opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));\n\t\t\t\tneeded &= ~s;\n\t\t\t}\n\n\t\t\tif (!in_struct(&pd->payload, sd, &md->message_pbs,\n\t\t\t\t       &pd->pbs)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t       excuse);\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* do payload-type specific debugging */\n\t\t\tswitch (np) {\n\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t/* dump ID section */\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_dump(\"     obj: \", pd->pbs.cur,\n\t\t\t\t\t     pbs_left(&pd->pbs)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* place this payload at the end of the chain for this type */\n\t\t\t{\n\t\t\t\tstruct payload_digest **p;\n\n\t\t\t\tfor (p = &md->chain[np]; *p != NULL;\n\t\t\t\t     p = &(*p)->next)\n\t\t\t\t\t;\n\t\t\t\t*p = pd;\n\t\t\t\tpd->next = NULL;\n\t\t\t}\n\n\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\tpd++;\n\n\t\t\t/* since we've digested one payload happily, it is probably\n\t\t\t * the case that any decryption worked.  So we will not suggest\n\t\t\t * encryption failure as an excuse for subsequent payload\n\t\t\t * problems.\n\t\t\t */\n\t\t\texcuse = \"\";\n\t\t}\n\n\t\tmd->digest_roof = pd;\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    if (pbs_left(&md->message_pbs) != 0)\n\t\t\t\t    DBG_log(\"removing %d bytes of padding\",\n\t\t\t\t\t    (int) pbs_left(&md->message_pbs));\n\t\t    });\n\n\t\tmd->message_pbs.roof = md->message_pbs.cur;\n\n\t\t/* check that all mandatory payloads appeared */\n\n\t\tif (needed != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"message for %s is missing payloads %s\",\n\t\t\t       enum_show(&state_names, from_state),\n\t\t\t       bitnamesof(payload_name_ikev1, needed));\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* more sanity checking: enforce most ordering constraints */\n\n\tif (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5 Exchanges:\n\t\t * \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n\t\t */\n\t\tif (md->chain[ISAKMP_NEXT_SA] != NULL &&\n\t\t    md->hdr.isa_np != ISAKMP_NEXT_SA) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Phase 1 message: does not start with an SA payload\");\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\t} else if (IS_QUICK(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode\n\t\t *\n\t\t * \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n\t\t *  header and a SA payload MUST immediately follow the HASH.\"\n\t\t * [NOTE: there may be more than one SA payload, so this is not\n\t\t *  totally reasonable.  Probably all SAs should be so constrained.]\n\t\t *\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t *\n\t\t * \"With the exception of the HASH, SA, and the optional ID payloads,\n\t\t *  there are no payload ordering restrictions on Quick Mode.\"\n\t\t */\n\n\t\tif (md->hdr.isa_np != ISAKMP_NEXT_HASH) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Quick Mode message: does not start with a HASH payload\");\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\n\t\t{\n\t\t\tstruct payload_digest *p;\n\t\t\tint i;\n\n\t\t\tp = md->chain[ISAKMP_NEXT_SA];\n\t\t\ti = 1;\n\t\t\twhile (p != NULL) {\n\t\t\t\tif (p != &md->digest[i]) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"malformed Quick Mode message: SA payload is in wrong position\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tp = p->next;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode:\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t */\n\t\t{\n\t\t\tstruct payload_digest *id = md->chain[ISAKMP_NEXT_ID];\n\n\t\t\tif (id != NULL) {\n\t\t\t\tif (id->next == NULL ||\n\t\t\t\t    id->next->next != NULL) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"malformed Quick Mode message:\"\n\t\t\t\t\t       \" if any ID payload is present,\"\n\t\t\t\t\t       \" there must be exactly two\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (id + 1 != id->next) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS, \"malformed Quick Mode message:\"\n\t\t\t\t\t       \" the ID payloads are not adjacent\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Ignore payloads that we don't handle:\n\t */\n\t/* XXX Handle Notifications */\n\t{\n\t\tstruct payload_digest *p = md->chain[ISAKMP_NEXT_N];\n\n\t\twhile (p != NULL) {\n\t\t\tswitch (p->payload.notification.isan_type) {\n\n\t\t\tcase R_U_THERE:\n\t\t\tcase R_U_THERE_ACK:\n\t\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tcase PAYLOAD_MALFORMED:\n\t\t\tcase INVALID_MESSAGE_ID:\n\t\t\tcase IPSEC_RESPONDER_LIFETIME:\n\t\t\t\tif (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {\n\t\t\t\t\t/* these are handled later on in informational() */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tdefault:\n\t\t\t\tif (st == NULL || (st != NULL &&\n\t\t\t\t\t\t   (st->st_connection->policy & POLICY_OPPORTUNISTIC))) {\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t       \"ignoring informational payload %s, no corresponding state\",\n\t\t\t\t\t       enum_show(& ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.\n\t\t\t\t\t\t\t notification.isan_type)));\n\t\t\t\t} else {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"ignoring informational payload %s, msgid=%08\" PRIx32 \", length=%d\",\n\t\t\t\t\t       enum_show(&ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.\n\t\t\t\t\t\t\t notification.isan_type),\n\t\t\t\t\t       st->st_msgid,\n\t\t\t\t\t       p->payload.notification.isan_length);\n\t\t\t\t\tDBG_dump_pbs(&p->pbs);\n\t\t\t\t}\n\t\t\t\tif (st != NULL &&\n\t\t\t\t    st->st_connection->extra_debugging &\n\t\t\t\t    IMPAIR_DIE_ONINFO) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"received and failed on unknown informational message\");\n\t\t\t\t\tcomplete_v1_state_transition(mdp,\n\t\t\t\t\t\t\t\t     STF_FATAL);\n\t\t\t\t\t/* our caller will release_any_md(mdp); */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_cond_dump(DBG_PARSING, \"info:\", p->pbs.cur, pbs_left(\n\t\t\t\t\t      &p->pbs));\n\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_D];\n\t\twhile (p != NULL) {\n\t\t\tself_delete |= accept_delete(md, p);\n\t\t\tDBG_cond_dump(DBG_PARSING, \"del:\", p->pbs.cur, pbs_left(\n\t\t\t\t\t      &p->pbs));\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_VID];\n\t\twhile (p != NULL) {\n\t\t\thandle_vendorid(md, (char *)p->pbs.cur,\n\t\t\t\t\tpbs_left(&p->pbs), FALSE);\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (self_delete) {\n\t\taccept_self_delete(md);\n\t\tst = md->st;\t/* st not subsequently used */\n\t\t/* note: st ought to be NULL from here on */\n\t}\n\n#if 0\n\t/* this does not seem to be right */\n\n\t/* VERIFY that we only accept NAT-D/NAT-OE when they sent us the VID */\n\tif ((md->chain[ISAKMP_NEXT_NATD_RFC] != NULL ||\n\t     md->chain[ISAKMP_NEXT_NATOA_RFC] != NULL) &&\n\t    (st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t/*\n\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t * unless we're using NAT-T RFC\n\t\t */\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"message ignored because it contains a NAT payload, when we did not receive the appropriate VendorID\");\n\t\treturn;\n\t}\n#endif\n\n\t/* possibly fill in hdr */\n\tif (smc->first_out_payload != ISAKMP_NEXT_NONE)\n\t\tikev1_echo_hdr(md, (smc->flags & SMF_OUTPUT_ENCRYPTED) != 0,\n\t\t\t smc->first_out_payload);\n\n\tcomplete_v1_state_transition(mdp, smc->processor(md));\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * replace previous receive packet with latest, to update\n * our notion of a retransmitted packet. This is important\n * to do, even for failing transitions, and suspended transitions\n * because the sender may well retransmit their request.\n * We had better be idempotent since we can be called\n * multiple times in handling a packet due to crypto helper logic.\n */\nstatic void remember_received_packet(struct state *st, struct msg_digest *md)\n{\n\tif (md->encrypted) {\n\t\t/* if encrypted, duplication already done */\n\t\tif (md->raw_packet.ptr != NULL) {\n\t\t\tpfreeany(st->st_rpacket.ptr);\n\t\t\tst->st_rpacket = md->raw_packet;\n\t\t\tmd->raw_packet.ptr = NULL;\n\t\t}\n\t} else {\n\t\t/* this may be a repeat, but it will work */\n\t\tpfreeany(st->st_rpacket.ptr);\n\t\tclonetochunk(st->st_rpacket,\n\t\t\t     md->packet_pbs.start,\n\t\t\t     pbs_room(&md->packet_pbs), \"raw packet\");\n\t}\n}\n\n/* complete job started by the state-specific state transition function\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n *\n * md is used to:\n * - find st\n * - find from_state (st might be gone)\n * - find note for STF_FAIL (might not be part of result (STF_FAIL+note))\n * - find note for STF_INTERNAL_ERROR\n * - record md->event_already_set\n * - remember_received_packet(st, md);\n * - nat_traversal_change_port_lookup(md, st);\n * - smc for smc->next_state\n * - smc for smc->flags & SMF_REPLY to trigger a reply\n * - smc for smc->timeout_event\n * - smc for !(smc->flags & SMF_INITIATOR) for Contivity mode\n * - smc for smc->flags & SMF_RELEASE_PENDING_P2 to trigger unpend call\n * - smc for smc->flags & SMF_INITIATOR to adjust retransmission\n * - fragvid, dpd, nortel\n */\nvoid complete_v1_state_transition(struct msg_digest **mdp, stf_status result)\n{\n\tstruct msg_digest *md = *mdp;\n\tenum state_kind from_state;\n\tstruct state *st;\n\n\tpassert(md != NULL);\n\n\t/* handle oddball/meta results now */\n\n\tswitch (result) {\n\tcase STF_SUSPEND:\n\t\tcur_state = md->st;\t/* might have changed */\n\t\t/* FALL THROUGH */\n\tcase STF_INLINE:\t/* all done, including release_any_md */\n\t\t*mdp = NULL;\t/* take md away from parent */\n\t\t/* FALL THROUGH */\n\tcase STF_IGNORE:\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"complete v1 state transition with %s\",\n\t\t\t    enum_show(&stfstatus_name, result)));\n\t\treturn;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tDBG(DBG_CONTROL,\n\t    DBG_log(\"complete v1 state transition with %s\",\n\t\tresult > STF_FAIL ?\n\t\t    enum_name(&ikev1_notify_names, result - STF_FAIL) :\n\t\t    enum_name(&stfstatus_name, result)));\n\n\t/* safe to refer to *md */\n\n\tfrom_state = md->from_state;\n\n\tcur_state = st = md->st; /* might have changed */\n\n\tpassert(st != NULL);\n\n\tpassert(!st->st_calculating);\n\n\tswitch (result) {\n\tcase STF_OK:\n\t{\n\t\t/* advance the state */\n\t\tconst struct state_microcode *smc = md->smc;\n\n\t\tlibreswan_log(\"transition from state %s to state %s\",\n\t\t\t      enum_name(&state_names, from_state),\n\t\t\t      enum_name(&state_names, smc->next_state));\n\n\t\t/* accept info from VID because we accept this message */\n\n\t\t/* If state has FRAGMENTATION support, import it */\n\t\tif (md->fragvid) {\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\"peer supports fragmentation\"));\n\t\t\tst->st_seen_fragvid = TRUE;\n\t\t}\n\n\t\t/* If state has DPD support, import it */\n\t\tif (md->dpd &&\n\t\t    st->hidden_variables.st_peer_supports_dpd != md->dpd) {\n\t\t\tDBG(DBG_DPD, DBG_log(\"peer supports dpd\"));\n\t\t\tst->hidden_variables.st_peer_supports_dpd = md->dpd;\n\n\t\t\tif (dpd_active_locally(st)) {\n\t\t\t\tDBG(DBG_DPD, DBG_log(\"dpd is active locally\"));\n\t\t\t}\n\t\t}\n\n\t\t/* If state has VID_NORTEL, import it to activate workaround */\n\t\tif (md->nortel) {\n\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\"peer requires Nortel Contivity workaround\"));\n\t\t\tst->st_seen_nortel_vid = TRUE;\n\t\t}\n\n\t\tif (!st->st_msgid_reserved &&\n\t\t    IS_CHILD_SA(st) &&\n\t\t    st->st_msgid != v1_MAINMODE_MSGID) {\n\t\t\tstruct state *p1st = state_with_serialno(\n\t\t\t\tst->st_clonedfrom);\n\n\t\t\tif (p1st != NULL) {\n\t\t\t\t/* do message ID reservation */\n\t\t\t\treserve_msgid(p1st, st->st_msgid);\n\t\t\t}\n\n\t\t\tst->st_msgid_reserved = TRUE;\n\t\t}\n\n\t\tchange_state(st, smc->next_state);\n\n\t\t/* XAUTH negotiation withOUT modecfg ends in STATE_XAUTH_I1\n\t\t * which is wrong and creates issues further in several places\n\t\t * As per libreswan design, it seems every phase 1 negotiation\n\t\t * including xauth/modecfg must end with STATE_MAIN_I4 to mark\n\t\t * actual end of phase 1. With modecfg, negotiation ends with\n\t\t * STATE_MAIN_I4 already.\n\t\t */\n#if 0\t/* ??? what's this code for? */\n\t\tif (st->st_connection->spd.this.xauth_client\n\t\t    && st->hidden_variables.st_xauth_client_done\n\t\t    && !st->st_connection->spd.this.modecfg_client\n\t\t    && st->st_state == STATE_XAUTH_I1) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"As XAUTH is done and modecfg is not configured, so Phase 1 neogtiation finishes successfully\"));\n\t\t\tchange_state(st, STATE_MAIN_I4);\n\t\t}\n#endif\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\t/* Delete previous retransmission event.\n\t\t\t * New event will be scheduled below.\n\t\t\t */\n\t\t\tdelete_event(st);\n\t\t}\n\n\t\t/* Delete IKE fragments */\n\t\trelease_fragments(st);\n\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\n\t\t/* free previous transmit packet */\n\t\tfreeanychunk(st->st_tpacket);\n\n\t\t/* in aggressive mode, there will be no reply packet in transition\n\t\t * from STATE_AGGR_R1 to STATE_AGGR_R2\n\t\t */\n\t\tif (nat_traversal_enabled) {\n\t\t\t/* adjust our destination port if necessary */\n\t\t\tnat_traversal_change_port_lookup(md, st);\n\t\t}\n\n\t\t/* if requested, send the new reply packet */\n\t\tif (smc->flags & SMF_REPLY) {\n\t\t\tDBG(DBG_CONTROL, {\n\t\t\t\tipstr_buf b;\n\t\t\t\tDBG_log(\"sending reply packet to %s:%u (from port %u)\",\n\t\t\t\t\tipstr(&st->st_remoteaddr, &b),\n\t\t\t\t\tst->st_remoteport,\n\t\t\t\t\tst->st_interface->port);\n\t\t\t});\n\n\t\t\tclose_output_pbs(&reply_stream); /* good form, but actually a no-op */\n\n\t\t\trecord_and_send_ike_msg(st, &reply_stream,\n\t\t\t\tenum_name(&state_names, from_state));\n\t\t}\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\tunsigned long delay_ms; /* delay is in milliseconds here */\n\t\t\tenum event_type kind = smc->timeout_event;\n\t\t\tbool agreed_time = FALSE;\n\t\t\tstruct connection *c = st->st_connection;\n\n\t\t\tswitch (kind) {\n\t\t\tcase EVENT_v1_RETRANSMIT: /* Retransmit packet */\n\t\t\t\tdelay_ms = c->r_interval;\n\t\t\t\tbreak;\n\n\t\t\tcase EVENT_SA_REPLACE: /* SA replacement event */\n\t\t\t\tif (IS_PHASE1(st->st_state) ||\n\t\t\t\t    IS_PHASE15(st->st_state )) {\n\t\t\t\t\t/* Note: we will defer to the \"negotiated\" (dictated)\n\t\t\t\t\t * lifetime if we are POLICY_DONT_REKEY.\n\t\t\t\t\t * This allows the other side to dictate\n\t\t\t\t\t * a time we would not otherwise accept\n\t\t\t\t\t * but it prevents us from having to initiate\n\t\t\t\t\t * rekeying.  The negative consequences seem\n\t\t\t\t\t * minor.\n\t\t\t\t\t */\n\t\t\t\t\tdelay_ms = deltamillisecs(c->sa_ike_life_seconds);\n\t\t\t\t\tif ((c->policy & POLICY_DONT_REKEY) ||\n\t\t\t\t\t    delay_ms >= deltamillisecs(st->st_oakley.life_seconds))\n\t\t\t\t\t{\n\t\t\t\t\t\tagreed_time = TRUE;\n\t\t\t\t\t\tdelay_ms = deltamillisecs(st->st_oakley.life_seconds);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Delay is min of up to four things:\n\t\t\t\t\t * each can limit the lifetime.\n\t\t\t\t\t */\n\t\t\t\t\ttime_t delay = deltasecs(c->sa_ipsec_life_seconds);\n\n#define clamp_delay(trans) { \\\n\t\tif (st->trans.present && \\\n\t\t    delay >= deltasecs(st->trans.attrs.life_seconds)) { \\\n\t\t\tagreed_time = TRUE; \\\n\t\t\tdelay = deltasecs(st->trans.attrs.life_seconds); \\\n\t\t} \\\n\t}\n\t\t\t\t\tclamp_delay(st_ah);\n\t\t\t\t\tclamp_delay(st_esp);\n\t\t\t\t\tclamp_delay(st_ipcomp);\n\t\t\t\t\tdelay_ms = delay * 1000;\n#undef clamp_delay\n\t\t\t\t}\n\n\t\t\t\t/* By default, we plan to rekey.\n\t\t\t\t *\n\t\t\t\t * If there isn't enough time to rekey, plan to\n\t\t\t\t * expire.\n\t\t\t\t *\n\t\t\t\t * If we are --dontrekey, a lot more rules apply.\n\t\t\t\t * If we are the Initiator, use REPLACE_IF_USED.\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * was unacceptable (too large), plan to REPLACE\n\t\t\t\t * (the only way to ratchet down the time).\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * is acceptable, plan to EXPIRE.\n\t\t\t\t *\n\t\t\t\t * Important policy lies buried here.\n\t\t\t\t * For example, we favour the initiator over the\n\t\t\t\t * responder by making the initiator start rekeying\n\t\t\t\t * sooner.  Also, fuzz is only added to the\n\t\t\t\t * initiator's margin.\n\t\t\t\t *\n\t\t\t\t * Note: for ISAKMP SA, we let the negotiated\n\t\t\t\t * time stand (implemented by earlier logic).\n\t\t\t\t */\n\t\t\t\tif (agreed_time &&\n\t\t\t\t    (c->policy & POLICY_DONT_REKEY)) {\n\t\t\t\t\tkind = (smc->flags & SMF_INITIATOR) ?\n\t\t\t\t\t       EVENT_SA_REPLACE_IF_USED :\n\t\t\t\t\t       EVENT_SA_EXPIRE;\n\t\t\t\t}\n\t\t\t\tif (kind != EVENT_SA_EXPIRE) {\n\t\t\t\t\ttime_t marg =\n\t\t\t\t\t\tdeltasecs(c->sa_rekey_margin);\n\n\t\t\t\t\tif (smc->flags & SMF_INITIATOR) {\n\t\t\t\t\t\tmarg += marg *\n\t\t\t\t\t\t\tc->sa_rekey_fuzz /\n\t\t\t\t\t\t\t100.E0 *\n\t\t\t\t\t\t\t(rand() /\n\t\t\t\t\t\t\t (RAND_MAX + 1.E0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarg /= 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (delay_ms > (unsigned long)marg * 1000) {\n\t\t\t\t\t\tdelay_ms -= (unsigned long)marg * 1000;\n\t\t\t\t\t\tst->st_margin = deltatime(marg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkind = EVENT_SA_EXPIRE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbad_case(kind);\n\t\t\t}\n\t\t\tevent_schedule_ms(kind, delay_ms, st);\n\t\t}\n\n\t\t/* tell whack and log of progress */\n\t\t{\n\t\t\tconst char *story = enum_name(&state_stories,\n\t\t\t\t\t\t      st->st_state);\n\t\t\tenum rc_type w = RC_NEW_STATE + st->st_state;\n\t\t\tchar sadetails[512];\n\n\t\t\tpassert(st->st_state < STATE_IKE_ROOF);\n\n\t\t\tsadetails[0] = '\\0';\n\n\t\t\t/* document IPsec SA details for admin's pleasure */\n\t\t\tif (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tfmt_ipsec_sa_established(st, sadetails,\n\t\t\t\t\t\t\t sizeof(sadetails));\n\t\t\t} else if (IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t\t\t   !st->hidden_variables.st_logged_p1algos) {\n\t\t\t\tfmt_isakmp_sa_established(st, sadetails,\n\t\t\t\t\t\t\t  sizeof(sadetails));\n\t\t\t}\n\n\t\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||\n\t\t\t    IS_IPSEC_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\t/* log our success */\n\t\t\t\tw = RC_SUCCESS;\n\t\t\t}\n\n\t\t\t/* tell whack and logs our progress */\n\t\t\tloglog(w,\n\t\t\t       \"%s: %s%s\",\n\t\t\t       enum_name(&state_names, st->st_state),\n\t\t\t       story,\n\t\t\t       sadetails);\n\t\t}\n\n\t\t/*\n\t\t * make sure that a DPD event gets created for a new phase 1\n\t\t * SA.\n\t\t */\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\tif (deltasecs(st->st_connection->dpd_delay) > 0 &&\n\t\t\t    deltasecs(st->st_connection->dpd_timeout) > 0) {\n\t\t\t\t/* don't ignore failure */\n\t\t\t\t/* ??? in fact, we do ignore this:\n\t\t\t\t * result is NEVER used\n\t\t\t\t * (clang 3.4 noticed this)\n\t\t\t\t */\n\t\t\t\tstf_status s = dpd_init(st);\n\n\t\t\t\tpexpect(s != STF_FAIL);\n\t\t\t\tif (s == STF_FAIL)\n\t\t\t\t\tresult = STF_FAIL; /* ??? fall through !?! */\n\t\t\t}\n\t\t}\n\n\t\t/* Special case for XAUTH server */\n\t\tif (st->st_connection->spd.this.xauth_server) {\n\t\t\tif (st->st_oakley.doing_xauth &&\n\t\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t\t\tDBG_log(\"XAUTH: \"\n\t\t\t\t\t\t       \"Sending XAUTH Login/Password Request\"));\n\t\t\t\tevent_schedule_ms(EVENT_v1_SEND_XAUTH,\n\t\t\t\t\t\tEVENT_v1_SEND_XAUTH_DELAY, st);\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * for XAUTH client, we are also done, because we need to\n\t\t * stay in this state, and let the server query us\n\t\t */\n\t\tif (!IS_QUICK(st->st_state) &&\n\t\t    st->st_connection->spd.this.xauth_client &&\n\t\t    !st->hidden_variables.st_xauth_client_done) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"XAUTH client is not yet authenticated\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * when talking to some vendors, we need to initiate a mode\n\t\t * cfg request to get challenged, but there is also an\n\t\t * override in the form of a policy bit.\n\t\t */\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"modecfg pull: %s policy:%s %s\",\n\t\t\t    (st->quirks.modecfg_pull_mode ?\n\t\t\t     \"quirk-poll\" : \"noquirk\"),\n\t\t\t    (st->st_connection->policy & POLICY_MODECFG_PULL) ?\n\t\t\t    \"pull\" : \"push\",\n\t\t\t    (st->st_connection->spd.this.modecfg_client ?\n\t\t\t     \"modecfg-client\" : \"not-client\")));\n\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    (st->quirks.modecfg_pull_mode ||\n\t\t     st->st_connection->policy & POLICY_MODECFG_PULL) &&\n\t\t    !st->hidden_variables.st_modecfg_started) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"modecfg client is starting due to %s\",\n\t\t\t\t    st->quirks.modecfg_pull_mode ? \"quirk\" :\n\t\t\t\t    \"policy\"));\n\t\t\tmodecfg_send_request(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Should we set the peer's IP address regardless? */\n\t\tif (st->st_connection->spd.this.modecfg_server &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set &&\n\t\t    !(st->st_connection->policy & POLICY_MODECFG_PULL)) {\n\t\t\tchange_state(st, STATE_MODE_CFG_R1);\n\t\t\tset_cur_state(st);\n\t\t\tlibreswan_log(\"Sending MODE CONFIG set\");\n\t\t\tmodecfg_start_set(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we are the responder and the client is in \"Contivity mode\",\n\t\t * we need to initiate Quick mode\n\t\t */\n\t\tif (!(smc->flags & SMF_INITIATOR) &&\n\t\t    IS_MODE_CFG_ESTABLISHED(st->st_state) &&\n\t\t    (st->st_seen_nortel_vid)) {\n\t\t\tlibreswan_log(\"Nortel 'Contivity Mode' detected, starting Quick Mode\");\n\t\t\tchange_state(st, STATE_MAIN_R3); /* ISAKMP is up... */\n\t\t\tset_cur_state(st);\n\t\t\tquick_outI1(st->st_whack_sock, st, st->st_connection,\n\t\t\t\t    st->st_connection->policy, 1, SOS_NOBODY\n#ifdef HAVE_LABELED_IPSEC\n\t\t\t\t    , NULL /* Setting NULL as this is responder and will not have sec ctx from a flow*/\n#endif\n\t\t\t\t    );\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wait for modecfg_set */\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"waiting for modecfg set from server\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (st->st_rekeytov2) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"waiting for IKEv1 -> IKEv2 rekey\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"phase 1 is done, looking for phase 2 to unpend\"));\n\n\t\tif (smc->flags & SMF_RELEASE_PENDING_P2) {\n\t\t\t/* Initiate any Quick Mode negotiations that\n\t\t\t * were waiting to piggyback on this Keying Channel.\n\t\t\t *\n\t\t\t * ??? there is a potential race condition\n\t\t\t * if we are the responder: the initial Phase 2\n\t\t\t * message might outrun the final Phase 1 message.\n\t\t\t *\n\t\t\t * so, instead of actually sending the traffic now,\n\t\t\t * we schedule an event to do so.\n\t\t\t *\n\t\t\t * but, in fact, quick_mode will enqueue a cryptographic operation\n\t\t\t * anyway, which will get done \"later\" anyway, so maybe it is just fine\n\t\t\t * as it is.\n\t\t\t *\n\t\t\t */\n\t\t\tunpend(st);\n\t\t}\n\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||\n\t\t    IS_IPSEC_SA_ESTABLISHED(st->st_state))\n\t\t\trelease_whack(st);\n\n\t\tif (IS_QUICK(st->st_state))\n\t\t\tbreak;\n\n\t\tbreak;\n\t}\n\n\tcase STF_INTERNAL_ERROR:\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\n\t\twhack_log(RC_INTERNALERR + md->note,\n\t\t\t  \"%s: internal error\",\n\t\t\t  enum_name(&state_names, st->st_state));\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"state transition function for %s had internal error\",\n\t\t\t    enum_name(&state_names, from_state)));\n\t\tbreak;\n\n\tcase STF_TOOMUCHCRYPTO:\n\t\t/* ??? Why is this comment useful:\n\t\t * well, this should never happen during a whack, since\n\t\t * a whack will always force crypto.\n\t\t */\n\t\t/* ??? why no call of remember_received_packet? */\n\t\tunset_suspended(st);\n\t\tlibreswan_log(\n\t\t\t\"message in state %s ignored due to cryptographic overload\",\n\t\t\tenum_name(&state_names, from_state));\n\t\tlog_crypto_workers();\n\t\t/* ??? the ikev2.c version used to FALL THROUGH to STF_FATAL */\n\t\tbreak;\n\n\tcase STF_FATAL:\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\n\t\twhack_log(RC_FATAL,\n\t\t\t  \"encountered fatal error in state %s\",\n\t\t\t  enum_name(&state_names, st->st_state));\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\trelease_pending_whacks(st, \"fatal error\");\n\t\tdelete_state(st);\n\t\tmd->st = st = NULL;\n\t\tbreak;\n\n\tdefault:        /* a shortcut to STF_FAIL, setting md->note */\n\t\tpassert(result > STF_FAIL);\n\t\tmd->note = result - STF_FAIL;\n\t\t/* FALL THROUGH */\n\tcase STF_FAIL:\n\t\t/* As it is, we act as if this message never happened:\n\t\t * whatever retrying was in place, remains in place.\n\t\t */\n\t\t/*\n\t\t * ??? why no call of remember_received_packet?\n\t\t * Perhaps because the message hasn't been authenticated?\n\t\t * But then then any duplicate would lose too, I would think.\n\t\t */\n\t\twhack_log(RC_NOTIFICATION + md->note,\n\t\t\t  \"%s: %s\", enum_name(&state_names, st->st_state),\n\t\t\t  enum_name(&ikev1_notify_names, md->note));\n\n\t\tif (md->note != NOTHING_WRONG)\n\t\t\tSEND_NOTIFICATION(md->note);\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"state transition function for %s failed: %s\",\n\t\t\t    enum_name(&state_names, from_state),\n\t\t\t    enum_name(&ikev1_notify_names, md->note)));\n\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\tif (IS_PHASE1_INIT(st->st_state)) {\n\t\t\tdelete_event(st);\n\t\t\trelease_whack(st);\n\t\t}\n\t\tif (IS_QUICK(st->st_state)) {\n\t\t\tdelete_state(st);\n\t\t\t/* wipe out dangling pointer to st */\n\t\t\tmd->st = NULL;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/* note: may change which connection is referenced by md->st->st_connection */\nbool ikev1_decode_peer_id(struct msg_digest *md, bool initiator, bool aggrmode)\n{\n\tstruct state *const st = md->st;\n\tstruct payload_digest *const id_pld = md->chain[ISAKMP_NEXT_ID];\n\tconst pb_stream *const id_pbs = &id_pld->pbs;\n\tstruct isakmp_id *const id = &id_pld->payload.id;\n\tstruct id peer;\n\n\t/* I think that RFC2407 (IPSEC DOI) 4.6.2 is confused.\n\t * It talks about the protocol ID and Port fields of the ID\n\t * Payload, but they don't exist as such in Phase 1.\n\t * We use more appropriate names.\n\t * isaid_doi_specific_a is in place of Protocol ID.\n\t * isaid_doi_specific_b is in place of Port.\n\t * Besides, there is no good reason for allowing these to be\n\t * other than 0 in Phase 1.\n\t */\n\tif (st->hidden_variables.st_nat_traversal != LEMPTY &&\n\t    id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t    (id->isaid_doi_specific_b == 0 ||\n\t     id->isaid_doi_specific_b == pluto_nat_port)) {\n\t\tDBG_log(\"protocol/port in Phase 1 ID Payload is %d/%d. \"\n\t\t\t\"accepted with port_floating NAT-T\",\n\t\t\tid->isaid_doi_specific_a, id->isaid_doi_specific_b);\n\t} else if (!(id->isaid_doi_specific_a == 0 &&\n\t\t     id->isaid_doi_specific_b == 0) &&\n\t\t   !(id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t\t     id->isaid_doi_specific_b == pluto_port))\n\t{\n\t\tloglog(RC_LOG_SERIOUS, \"protocol/port in Phase 1 ID Payload MUST be 0/0 or %d/%d\"\n\t\t       \" but are %d/%d (attempting to continue)\",\n\t\t       IPPROTO_UDP, pluto_port,\n\t\t       id->isaid_doi_specific_a,\n\t\t       id->isaid_doi_specific_b);\n\t\t/* we have turned this into a warning because of bugs in other vendors\n\t\t * products. Specifically CISCO VPN3000.\n\t\t */\n\t\t/* return FALSE; */\n\t}\n\n\tzero(&peer);\t/* ??? pointer fields might not be NULLed */\n\tpeer.kind = id->isaid_idtype;\n\n\tif (!extract_peer_id(&peer, id_pbs))\n\t\treturn FALSE;\n\n\t/*\n\t * For interop with SoftRemote/aggressive mode we need to remember some\n\t * things for checking the hash\n\t */\n\tst->st_peeridentity_protocol = id->isaid_doi_specific_a;\n\tst->st_peeridentity_port = ntohs(id->isaid_doi_specific_b);\n\n\t{\n\t\tchar buf[IDTOA_BUF];\n\n\t\tidtoa(&peer, buf, sizeof(buf));\n\t\tlibreswan_log(\"%s mode peer ID is %s: '%s'\",\n\t\t\t      aggrmode ? \"Aggressive\" : \"Main\",\n\t\t\t      enum_show(&ike_idtype_names, id->isaid_idtype), buf);\n\t}\n\n\t/* check for certificates */\n\tif (!ikev1_decode_cert(md))\n\t\treturn FALSE;\n\n\t/* Now that we've decoded the ID payload, let's see if we\n\t * need to switch connections.\n\t * We must not switch horses if we initiated:\n\t * - if the initiation was explicit, we'd be ignoring user's intent\n\t * - if opportunistic, we'll lose our HOLD info\n\t */\n\tif (initiator) {\n\t\tif (!same_id(&st->st_connection->spd.that.id, &peer) &&\n\t\t     id_kind(&st->st_connection->spd.that.id) != ID_FROMCERT) {\n\t\t\tchar expect[IDTOA_BUF],\n\t\t\t     found[IDTOA_BUF];\n\n\t\t\tidtoa(&st->st_connection->spd.that.id, expect,\n\t\t\t      sizeof(expect));\n\t\t\tidtoa(&peer, found, sizeof(found));\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"we require IKEv1 peer to have ID '%s', but peer declares '%s'\",\n\t\t\t       expect, found);\n\t\t\treturn FALSE;\n\t\t} else if (id_kind(&st->st_connection->spd.that.id) == ID_FROMCERT) {\n\t\t\tif (id_kind(&peer) != ID_DER_ASN1_DN) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"peer ID is not a certificate type\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tduplicate_id(&st->st_connection->spd.that.id, &peer);\n\t\t}\n\t} else {\n\t\tstruct connection *c = st->st_connection;\n\t\tstruct connection *r = NULL;\n\t\tbool fromcert;\n\t\tuint16_t auth = xauth_calcbaseauth(st->st_oakley.auth);\n\t\tlset_t auth_policy = LEMPTY;\n\n\t\tswitch (auth) {\n\t\tcase OAKLEY_PRESHARED_KEY:\n\t\t\tauth_policy = POLICY_PSK;\n\t\t\tbreak;\n\t\tcase OAKLEY_RSA_SIG:\n\t\t\tauth_policy = POLICY_RSASIG;\n\t\t\tbreak;\n\t\t/* Not implemented */\n\t\tcase OAKLEY_DSS_SIG:\n\t\tcase OAKLEY_RSA_ENC:\n\t\tcase OAKLEY_RSA_REVISED_MODE:\n\t\tcase OAKLEY_ECDSA_P256:\n\t\tcase OAKLEY_ECDSA_P384:\n\t\tcase OAKLEY_ECDSA_P521:\n\t\tdefault:\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"ikev1 ikev1_decode_peer_id bad_case due to not supported policy\"));\n\t\t\t// bad_case(auth);\n\t\t}\n\n\t\tif (aggrmode)\n\t\t\tauth_policy |=  POLICY_AGGRESSIVE;\n\n\t\t/* check for certificate requests */\n\t\tikev1_decode_cr(md);\n\n\t\tif ((auth_policy & ~POLICY_AGGRESSIVE) != LEMPTY) {\n\t\t\tr = refine_host_connection(st, &peer, initiator, auth_policy, &fromcert);\n\t\t\tpexpect(r != NULL);\n\t\t}\n\n\t\tif (r == NULL) {\n\t\t\tchar buf[IDTOA_BUF];\n\n\t\t\tidtoa(&peer, buf, sizeof(buf));\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"no suitable connection for peer '%s'\",\n\t\t\t       buf);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tDBG(DBG_CONTROL, {\n\t\t\t    char buf[IDTOA_BUF];\n\t\t\t    dntoa_or_null(buf, IDTOA_BUF, r->spd.this.ca,\n\t\t\t\t\t  \"%none\");\n\t\t\t    DBG_log(\"offered CA: '%s'\", buf);\n\t\t    });\n\n\t\tif (r != c) {\n\t\t\tchar b1[CONN_INST_BUF];\n\t\t\tchar b2[CONN_INST_BUF];\n\n\t\t\t/* apparently, r is an improvement on c -- replace */\n\t\t\tlibreswan_log(\"switched from \\\"%s\\\"%s to \\\"%s\\\"%s\",\n\t\t\t\tc->name,\n\t\t\t\tfmt_conn_instance(c, b1),\n\t\t\t\tr->name,\n\t\t\t\tfmt_conn_instance(r, b2));\n\t\t\tif (r->kind == CK_TEMPLATE || r->kind == CK_GROUP) {\n\t\t\t\t/* instantiate it, filling in peer's ID */\n\t\t\t\tr = rw_instantiate(r, &c->spd.that.host_addr,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   &peer);\n\t\t\t}\n\n\t\t\tupdate_state_connection(st, r);\n\t\t} else if (c->spd.that.has_id_wildcards) {\n\t\t\tfree_id_content(&c->spd.that.id);\n\t\t\tc->spd.that.id = peer;\n\t\t\tc->spd.that.has_id_wildcards = FALSE;\n\t\t\tunshare_id_content(&c->spd.that.id);\n\t\t} else if (fromcert) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"copying ID for fromcert\"));\n\t\t\tduplicate_id(&r->spd.that.id, &peer);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nbool ikev1_ship_chain(chunk_t *chain, int n, pb_stream *outs,\n\t\t\t\t\t     u_int8_t type,\n\t\t\t\t\t     u_int8_t setnp)\n{\n\tint i;\n\tu_int8_t np;\n\n\tfor (i = 0; i < n; i++) {\n\t\t/* set np for last cert, or another */\n\t\tnp = i == n - 1 ? setnp : ISAKMP_NEXT_CERT;\n\n\t\tif (!ikev1_ship_CERT(type, chain[i], outs, np))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid doi_log_cert_thinking(u_int16_t auth,\n\t\t\t\tenum ike_cert_type certtype,\n\t\t\t\tenum certpolicy policy,\n\t\t\t\tbool gotcertrequest,\n\t\t\t\tbool send_cert,\n\t\t\t\tbool send_chain)\n{\n\tDBG(DBG_CONTROL,\n\t\tDBG_log(\"thinking about whether to send my certificate:\"));\n\n\tDBG(DBG_CONTROL, {\n\t\tstruct esb_buf esb;\n\n\t\tDBG_log(\"  I have RSA key: %s cert.type: %s \",\n\t\t\tenum_showb(&oakley_auth_names, auth, &esb),\n\t\t\tenum_show(&ike_cert_type_names, certtype));\n\t});\n\n\tDBG(DBG_CONTROL,\n\t\tDBG_log(\"  sendcert: %s and I did%s get a certificate request \",\n\t\t\tenum_show(&certpolicy_type_names, policy),\n\t\t\tgotcertrequest ? \"\" : \" not\"));\n\n\tDBG(DBG_CONTROL,\n\t\tDBG_log(\"  so %ssend cert.\", send_cert ? \"\" : \"do not \"));\n\n\tif (!send_cert) {\n\t\tif (auth == OAKLEY_PRESHARED_KEY) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"I did not send a certificate \"\n\t\t\t\t\t\"because digital signatures are not \"\n\t\t\t\t\t\"being used. (PSK)\"));\n\t\t} else if (certtype == CERT_NONE) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"I did not send a certificate because \"\n\t\t\t\t\t\"I do not have one.\"));\n\t\t} else if (policy == cert_sendifasked) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t\tDBG_log(\"I did not send my certificate \"\n\t\t\t\t\t\"because I was not asked to.\"));\n\t\t}\n\t\t/* ??? should there be an additional else catch-all? */\n\t}\n\tif (send_chain)\n\t\tDBG(DBG_CONTROL, DBG_log(\"Sending one or more authcerts\"));\n}\n"], "filenames": ["programs/pluto/ikev1.c"], "buggy_code_start_loc": [248], "buggy_code_end_loc": [580], "fixing_code_start_loc": [248], "fixing_code_end_loc": [580], "type": "CWE-20", "message": "programs/pluto/ikev1.c in libreswan before 3.17 retransmits in initial-responder states, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed UDP packet. NOTE: the original behavior complies with the IKEv1 protocol, but has a required security update from the libreswan vendor; as of 2016-06-10, it is expected that several other IKEv1 implementations will have vendor-required security updates, with separate CVE IDs assigned to each.", "other": {"cve": {"id": "CVE-2016-5361", "sourceIdentifier": "cve@mitre.org", "published": "2016-06-16T14:59:51.890", "lastModified": "2017-01-18T02:59:07.907", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "programs/pluto/ikev1.c in libreswan before 3.17 retransmits in initial-responder states, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed UDP packet. NOTE: the original behavior complies with the IKEv1 protocol, but has a required security update from the libreswan vendor; as of 2016-06-10, it is expected that several other IKEv1 implementations will have vendor-required security updates, with separate CVE IDs assigned to each."}, {"lang": "es", "value": "programs/pluto/ikev1.c en libreswan en versiones anteriores a 3.17 retransmite en estados inicial-respuesta, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (amplificaci\u00f3n de tr\u00e1fico) a trav\u00e9s de un paquete UDP suplantado. NOTA: el comportamiento original cumple con el protocolo IKEv1, pero tiene una actualizaci\u00f3n de seguridad requerida por el vendedor de libreswan; a partir de 2016-06-10, se espera que otras varias implementaciones IKEv1 tengan actualizaciones de seguridad requeridas por el vendedor, con separadas CVEs IDs asignadas a cada una."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.16", "matchCriteriaId": "0FF60B77-0610-4B1F-A8B0-012DC533C144"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2016-2603.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/10/4", "source": "cve@mitre.org"}, {"url": "https://github.com/libreswan/libreswan/commit/152d6d95632d8b9477c170f1de99bcd86d7fb1d6", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.libreswan.org/pipermail/swan-dev/2016-March/001394.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libreswan/libreswan/commit/152d6d95632d8b9477c170f1de99bcd86d7fb1d6"}}