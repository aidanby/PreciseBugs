{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Xilinx EmacLite Linux driver for the Xilinx Ethernet MAC Lite device.\n *\n * This is a new flat driver which is based on the original emac_lite\n * driver from John Williams <john.williams@xilinx.com>.\n *\n * 2007 - 2013 (c) Xilinx, Inc.\n */\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n\n#define DRIVER_NAME \"xilinx_emaclite\"\n\n/* Register offsets for the EmacLite Core */\n#define XEL_TXBUFF_OFFSET\t0x0\t\t/* Transmit Buffer */\n#define XEL_MDIOADDR_OFFSET\t0x07E4\t\t/* MDIO Address Register */\n#define XEL_MDIOWR_OFFSET\t0x07E8\t\t/* MDIO Write Data Register */\n#define XEL_MDIORD_OFFSET\t0x07EC\t\t/* MDIO Read Data Register */\n#define XEL_MDIOCTRL_OFFSET\t0x07F0\t\t/* MDIO Control Register */\n#define XEL_GIER_OFFSET\t\t0x07F8\t\t/* GIE Register */\n#define XEL_TSR_OFFSET\t\t0x07FC\t\t/* Tx status */\n#define XEL_TPLR_OFFSET\t\t0x07F4\t\t/* Tx packet length */\n\n#define XEL_RXBUFF_OFFSET\t0x1000\t\t/* Receive Buffer */\n#define XEL_RPLR_OFFSET\t\t0x100C\t\t/* Rx packet length */\n#define XEL_RSR_OFFSET\t\t0x17FC\t\t/* Rx status */\n\n#define XEL_BUFFER_OFFSET\t0x0800\t\t/* Next Tx/Rx buffer's offset */\n\n/* MDIO Address Register Bit Masks */\n#define XEL_MDIOADDR_REGADR_MASK  0x0000001F\t/* Register Address */\n#define XEL_MDIOADDR_PHYADR_MASK  0x000003E0\t/* PHY Address */\n#define XEL_MDIOADDR_PHYADR_SHIFT 5\n#define XEL_MDIOADDR_OP_MASK\t  0x00000400\t/* RD/WR Operation */\n\n/* MDIO Write Data Register Bit Masks */\n#define XEL_MDIOWR_WRDATA_MASK\t  0x0000FFFF\t/* Data to be Written */\n\n/* MDIO Read Data Register Bit Masks */\n#define XEL_MDIORD_RDDATA_MASK\t  0x0000FFFF\t/* Data to be Read */\n\n/* MDIO Control Register Bit Masks */\n#define XEL_MDIOCTRL_MDIOSTS_MASK 0x00000001\t/* MDIO Status Mask */\n#define XEL_MDIOCTRL_MDIOEN_MASK  0x00000008\t/* MDIO Enable */\n\n/* Global Interrupt Enable Register (GIER) Bit Masks */\n#define XEL_GIER_GIE_MASK\t0x80000000\t/* Global Enable */\n\n/* Transmit Status Register (TSR) Bit Masks */\n#define XEL_TSR_XMIT_BUSY_MASK\t 0x00000001\t/* Tx complete */\n#define XEL_TSR_PROGRAM_MASK\t 0x00000002\t/* Program the MAC address */\n#define XEL_TSR_XMIT_IE_MASK\t 0x00000008\t/* Tx interrupt enable bit */\n#define XEL_TSR_XMIT_ACTIVE_MASK 0x80000000\t/* Buffer is active, SW bit\n\t\t\t\t\t\t * only. This is not documented\n\t\t\t\t\t\t * in the HW spec\n\t\t\t\t\t\t */\n\n/* Define for programming the MAC address into the EmacLite */\n#define XEL_TSR_PROG_MAC_ADDR\t(XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_PROGRAM_MASK)\n\n/* Receive Status Register (RSR) */\n#define XEL_RSR_RECV_DONE_MASK\t0x00000001\t/* Rx complete */\n#define XEL_RSR_RECV_IE_MASK\t0x00000008\t/* Rx interrupt enable bit */\n\n/* Transmit Packet Length Register (TPLR) */\n#define XEL_TPLR_LENGTH_MASK\t0x0000FFFF\t/* Tx packet length */\n\n/* Receive Packet Length Register (RPLR) */\n#define XEL_RPLR_LENGTH_MASK\t0x0000FFFF\t/* Rx packet length */\n\n#define XEL_HEADER_OFFSET\t12\t\t/* Offset to length field */\n#define XEL_HEADER_SHIFT\t16\t\t/* Shift value for length */\n\n/* General Ethernet Definitions */\n#define XEL_ARP_PACKET_SIZE\t\t28\t/* Max ARP packet size */\n#define XEL_HEADER_IP_LENGTH_OFFSET\t16\t/* IP Length Offset */\n\n\n\n#define TX_TIMEOUT\t\t(60 * HZ)\t/* Tx timeout is 60 seconds. */\n#define ALIGNMENT\t\t4\n\n/* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */\n#define BUFFER_ALIGN(adr) ((ALIGNMENT - ((uintptr_t)adr)) % ALIGNMENT)\n\n#ifdef __BIG_ENDIAN\n#define xemaclite_readl\t\tioread32be\n#define xemaclite_writel\tiowrite32be\n#else\n#define xemaclite_readl\t\tioread32\n#define xemaclite_writel\tiowrite32\n#endif\n\n/**\n * struct net_local - Our private per device data\n * @ndev:\t\tinstance of the network device\n * @tx_ping_pong:\tindicates whether Tx Pong buffer is configured in HW\n * @rx_ping_pong:\tindicates whether Rx Pong buffer is configured in HW\n * @next_tx_buf_to_use:\tnext Tx buffer to write to\n * @next_rx_buf_to_use:\tnext Rx buffer to read from\n * @base_addr:\t\tbase address of the Emaclite device\n * @reset_lock:\t\tlock used for synchronization\n * @deferred_skb:\tholds an skb (for transmission at a later time) when the\n *\t\t\tTx buffer is not free\n * @phy_dev:\t\tpointer to the PHY device\n * @phy_node:\t\tpointer to the PHY device node\n * @mii_bus:\t\tpointer to the MII bus\n * @last_link:\t\tlast link status\n */\nstruct net_local {\n\n\tstruct net_device *ndev;\n\n\tbool tx_ping_pong;\n\tbool rx_ping_pong;\n\tu32 next_tx_buf_to_use;\n\tu32 next_rx_buf_to_use;\n\tvoid __iomem *base_addr;\n\n\tspinlock_t reset_lock;\n\tstruct sk_buff *deferred_skb;\n\n\tstruct phy_device *phy_dev;\n\tstruct device_node *phy_node;\n\n\tstruct mii_bus *mii_bus;\n\n\tint last_link;\n};\n\n\n/*************************/\n/* EmacLite driver calls */\n/*************************/\n\n/**\n * xemaclite_enable_interrupts - Enable the interrupts for the EmacLite device\n * @drvdata:\tPointer to the Emaclite device private data\n *\n * This function enables the Tx and Rx interrupts for the Emaclite device along\n * with the Global Interrupt Enable.\n */\nstatic void xemaclite_enable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t/* Enable the Tx interrupts for the first Buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data | XEL_TSR_XMIT_IE_MASK,\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t/* Enable the Rx interrupts for the first buffer */\n\txemaclite_writel(XEL_RSR_RECV_IE_MASK, drvdata->base_addr + XEL_RSR_OFFSET);\n\n\t/* Enable the Global Interrupt Enable */\n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n}\n\n/**\n * xemaclite_disable_interrupts - Disable the interrupts for the EmacLite device\n * @drvdata:\tPointer to the Emaclite device private data\n *\n * This function disables the Tx and Rx interrupts for the Emaclite device,\n * along with the Global Interrupt Enable.\n */\nstatic void xemaclite_disable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t/* Disable the Global Interrupt Enable */\n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n\n\t/* Disable the Tx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t/* Disable the Rx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_RSR_OFFSET);\n}\n\n/**\n * xemaclite_aligned_write - Write from 16-bit aligned to 32-bit aligned address\n * @src_ptr:\tVoid pointer to the 16-bit aligned source address\n * @dest_ptr:\tPointer to the 32-bit aligned destination address\n * @length:\tNumber bytes to write from source to destination\n *\n * This function writes data from a 16-bit aligned buffer to a 32-bit aligned\n * address in the EmacLite device.\n */\nstatic void xemaclite_aligned_write(void *src_ptr, u32 *dest_ptr,\n\t\t\t\t    unsigned length)\n{\n\tu32 align_buffer;\n\tu32 *to_u32_ptr;\n\tu16 *from_u16_ptr, *to_u16_ptr;\n\n\tto_u32_ptr = dest_ptr;\n\tfrom_u16_ptr = src_ptr;\n\talign_buffer = 0;\n\n\tfor (; length > 3; length -= 4) {\n\t\tto_u16_ptr = (u16 *)&align_buffer;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\n\t\t/* This barrier resolves occasional issues seen around\n\t\t * cases where the data is not properly flushed out\n\t\t * from the processor store buffers to the destination\n\t\t * memory locations.\n\t\t */\n\t\twmb();\n\n\t\t/* Output a word */\n\t\t*to_u32_ptr++ = align_buffer;\n\t}\n\tif (length) {\n\t\tu8 *from_u8_ptr, *to_u8_ptr;\n\n\t\t/* Set up to output the remaining data */\n\t\talign_buffer = 0;\n\t\tto_u8_ptr = (u8 *)&align_buffer;\n\t\tfrom_u8_ptr = (u8 *)from_u16_ptr;\n\n\t\t/* Output the remaining data */\n\t\tfor (; length > 0; length--)\n\t\t\t*to_u8_ptr++ = *from_u8_ptr++;\n\n\t\t/* This barrier resolves occasional issues seen around\n\t\t * cases where the data is not properly flushed out\n\t\t * from the processor store buffers to the destination\n\t\t * memory locations.\n\t\t */\n\t\twmb();\n\t\t*to_u32_ptr = align_buffer;\n\t}\n}\n\n/**\n * xemaclite_aligned_read - Read from 32-bit aligned to 16-bit aligned buffer\n * @src_ptr:\tPointer to the 32-bit aligned source address\n * @dest_ptr:\tPointer to the 16-bit aligned destination address\n * @length:\tNumber bytes to read from source to destination\n *\n * This function reads data from a 32-bit aligned address in the EmacLite device\n * to a 16-bit aligned buffer.\n */\nstatic void xemaclite_aligned_read(u32 *src_ptr, u8 *dest_ptr,\n\t\t\t\t   unsigned length)\n{\n\tu16 *to_u16_ptr, *from_u16_ptr;\n\tu32 *from_u32_ptr;\n\tu32 align_buffer;\n\n\tfrom_u32_ptr = src_ptr;\n\tto_u16_ptr = (u16 *)dest_ptr;\n\n\tfor (; length > 3; length -= 4) {\n\t\t/* Copy each word into the temporary buffer */\n\t\talign_buffer = *from_u32_ptr++;\n\t\tfrom_u16_ptr = (u16 *)&align_buffer;\n\n\t\t/* Read data from source */\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t}\n\n\tif (length) {\n\t\tu8 *to_u8_ptr, *from_u8_ptr;\n\n\t\t/* Set up to read the remaining data */\n\t\tto_u8_ptr = (u8 *)to_u16_ptr;\n\t\talign_buffer = *from_u32_ptr++;\n\t\tfrom_u8_ptr = (u8 *)&align_buffer;\n\n\t\t/* Read the remaining data */\n\t\tfor (; length > 0; length--)\n\t\t\t*to_u8_ptr = *from_u8_ptr;\n\t}\n}\n\n/**\n * xemaclite_send_data - Send an Ethernet frame\n * @drvdata:\tPointer to the Emaclite device private data\n * @data:\tPointer to the data to be sent\n * @byte_count:\tTotal frame size, including header\n *\n * This function checks if the Tx buffer of the Emaclite device is free to send\n * data. If so, it fills the Tx buffer with data for transmission. Otherwise, it\n * returns an error.\n *\n * Return:\t0 upon success or -1 if the buffer(s) are full.\n *\n * Note:\tThe maximum Tx packet size can not be more than Ethernet header\n *\t\t(14 Bytes) + Maximum MTU (1500 bytes). This is excluding FCS.\n */\nstatic int xemaclite_send_data(struct net_local *drvdata, u8 *data,\n\t\t\t       unsigned int byte_count)\n{\n\tu32 reg_data;\n\tvoid __iomem *addr;\n\n\t/* Determine the expected Tx buffer address */\n\taddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\n\n\t/* If the length is too large, truncate it */\n\tif (byte_count > ETH_FRAME_LEN)\n\t\tbyte_count = ETH_FRAME_LEN;\n\n\t/* Check if the expected buffer is available */\n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\tif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\n\t     XEL_TSR_XMIT_ACTIVE_MASK)) == 0) {\n\n\t\t/* Switch to next buffer if configured */\n\t\tif (drvdata->tx_ping_pong != 0)\n\t\t\tdrvdata->next_tx_buf_to_use ^= XEL_BUFFER_OFFSET;\n\t} else if (drvdata->tx_ping_pong != 0) {\n\t\t/* If the expected buffer is full, try the other buffer,\n\t\t * if it is configured in HW\n\t\t */\n\n\t\taddr = (void __iomem __force *)((uintptr_t __force)addr ^\n\t\t\t\t\t\t XEL_BUFFER_OFFSET);\n\t\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\n\t\tif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\n\t\t     XEL_TSR_XMIT_ACTIVE_MASK)) != 0)\n\t\t\treturn -1; /* Buffers were full, return failure */\n\t} else\n\t\treturn -1; /* Buffer was full, return failure */\n\n\t/* Write the frame to the buffer */\n\txemaclite_aligned_write(data, (u32 __force *)addr, byte_count);\n\n\txemaclite_writel((byte_count & XEL_TPLR_LENGTH_MASK),\n\t\t\t addr + XEL_TPLR_OFFSET);\n\n\t/* Update the Tx Status Register to indicate that there is a\n\t * frame to send. Set the XEL_TSR_XMIT_ACTIVE_MASK flag which\n\t * is used by the interrupt handler to check whether a frame\n\t * has been transmitted\n\t */\n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\treg_data |= (XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_XMIT_ACTIVE_MASK);\n\txemaclite_writel(reg_data, addr + XEL_TSR_OFFSET);\n\n\treturn 0;\n}\n\n/**\n * xemaclite_recv_data - Receive a frame\n * @drvdata:\tPointer to the Emaclite device private data\n * @data:\tAddress where the data is to be received\n * @maxlen:    Maximum supported ethernet packet length\n *\n * This function is intended to be called from the interrupt context or\n * with a wrapper which waits for the receive frame to be available.\n *\n * Return:\tTotal number of bytes received\n */\nstatic u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data, int maxlen)\n{\n\tvoid __iomem *addr;\n\tu16 length, proto_type;\n\tu32 reg_data;\n\n\t/* Determine the expected buffer address */\n\taddr = (drvdata->base_addr + drvdata->next_rx_buf_to_use);\n\n\t/* Verify which buffer has valid data */\n\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\n\tif ((reg_data & XEL_RSR_RECV_DONE_MASK) == XEL_RSR_RECV_DONE_MASK) {\n\t\tif (drvdata->rx_ping_pong != 0)\n\t\t\tdrvdata->next_rx_buf_to_use ^= XEL_BUFFER_OFFSET;\n\t} else {\n\t\t/* The instance is out of sync, try other buffer if other\n\t\t * buffer is configured, return 0 otherwise. If the instance is\n\t\t * out of sync, do not update the 'next_rx_buf_to_use' since it\n\t\t * will correct on subsequent calls\n\t\t */\n\t\tif (drvdata->rx_ping_pong != 0)\n\t\t\taddr = (void __iomem __force *)\n\t\t\t\t((uintptr_t __force)addr ^\n\t\t\t\t XEL_BUFFER_OFFSET);\n\t\telse\n\t\t\treturn 0;\t/* No data was available */\n\n\t\t/* Verify that buffer has valid data */\n\t\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\t\tif ((reg_data & XEL_RSR_RECV_DONE_MASK) !=\n\t\t     XEL_RSR_RECV_DONE_MASK)\n\t\t\treturn 0;\t/* No data was available */\n\t}\n\n\t/* Get the protocol type of the ethernet frame that arrived\n\t */\n\tproto_type = ((ntohl(xemaclite_readl(addr + XEL_HEADER_OFFSET +\n\t\t\tXEL_RXBUFF_OFFSET)) >> XEL_HEADER_SHIFT) &\n\t\t\tXEL_RPLR_LENGTH_MASK);\n\n\t/* Check if received ethernet frame is a raw ethernet frame\n\t * or an IP packet or an ARP packet\n\t */\n\tif (proto_type > ETH_DATA_LEN) {\n\n\t\tif (proto_type == ETH_P_IP) {\n\t\t\tlength = ((ntohl(xemaclite_readl(addr +\n\t\t\t\t\tXEL_HEADER_IP_LENGTH_OFFSET +\n\t\t\t\t\tXEL_RXBUFF_OFFSET)) >>\n\t\t\t\t\tXEL_HEADER_SHIFT) &\n\t\t\t\t\tXEL_RPLR_LENGTH_MASK);\n\t\t\tlength = min_t(u16, length, ETH_DATA_LEN);\n\t\t\tlength += ETH_HLEN + ETH_FCS_LEN;\n\n\t\t} else if (proto_type == ETH_P_ARP)\n\t\t\tlength = XEL_ARP_PACKET_SIZE + ETH_HLEN + ETH_FCS_LEN;\n\t\telse\n\t\t\t/* Field contains type other than IP or ARP, use max\n\t\t\t * frame size and let user parse it\n\t\t\t */\n\t\t\tlength = ETH_FRAME_LEN + ETH_FCS_LEN;\n\t} else\n\t\t/* Use the length in the frame, plus the header and trailer */\n\t\tlength = proto_type + ETH_HLEN + ETH_FCS_LEN;\n\n\tif (WARN_ON(length > maxlen))\n\t\tlength = maxlen;\n\n\t/* Read from the EmacLite device */\n\txemaclite_aligned_read((u32 __force *)(addr + XEL_RXBUFF_OFFSET),\n\t\t\t\tdata, length);\n\n\t/* Acknowledge the frame */\n\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\treg_data &= ~XEL_RSR_RECV_DONE_MASK;\n\txemaclite_writel(reg_data, addr + XEL_RSR_OFFSET);\n\n\treturn length;\n}\n\n/**\n * xemaclite_update_address - Update the MAC address in the device\n * @drvdata:\tPointer to the Emaclite device private data\n * @address_ptr:Pointer to the MAC address (MAC address is a 48-bit value)\n *\n * Tx must be idle and Rx should be idle for deterministic results.\n * It is recommended that this function should be called after the\n * initialization and before transmission of any packets from the device.\n * The MAC address can be programmed using any of the two transmit\n * buffers (if configured).\n */\nstatic void xemaclite_update_address(struct net_local *drvdata,\n\t\t\t\t     u8 *address_ptr)\n{\n\tvoid __iomem *addr;\n\tu32 reg_data;\n\n\t/* Determine the expected Tx buffer address */\n\taddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\n\n\txemaclite_aligned_write(address_ptr, (u32 __force *)addr, ETH_ALEN);\n\n\txemaclite_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);\n\n\t/* Update the MAC address in the EmacLite */\n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);\n\n\t/* Wait for EmacLite to finish with the MAC address update */\n\twhile ((xemaclite_readl(addr + XEL_TSR_OFFSET) &\n\t\tXEL_TSR_PROG_MAC_ADDR) != 0)\n\t\t;\n}\n\n/**\n * xemaclite_set_mac_address - Set the MAC address for this device\n * @dev:\tPointer to the network device instance\n * @address:\tVoid pointer to the sockaddr structure\n *\n * This function copies the HW address from the sockaddr strucutre to the\n * net_device structure and updates the address in HW.\n *\n * Return:\tError if the net device is busy or 0 if the addr is set\n *\t\tsuccessfully\n */\nstatic int xemaclite_set_mac_address(struct net_device *dev, void *address)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sockaddr *addr = address;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\n\txemaclite_update_address(lp, dev->dev_addr);\n\treturn 0;\n}\n\n/**\n * xemaclite_tx_timeout - Callback for Tx Timeout\n * @dev:\tPointer to the network device\n * @txqueue:\tUnused\n *\n * This function is called when Tx time out occurs for Emaclite device.\n */\nstatic void xemaclite_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tdev_err(&lp->ndev->dev, \"Exceeded transmit timeout of %lu ms\\n\",\n\t\tTX_TIMEOUT * 1000UL / HZ);\n\n\tdev->stats.tx_errors++;\n\n\t/* Reset the device */\n\tspin_lock_irqsave(&lp->reset_lock, flags);\n\n\t/* Shouldn't really be necessary, but shouldn't hurt */\n\tnetif_stop_queue(dev);\n\n\txemaclite_disable_interrupts(lp);\n\txemaclite_enable_interrupts(lp);\n\n\tif (lp->deferred_skb) {\n\t\tdev_kfree_skb(lp->deferred_skb);\n\t\tlp->deferred_skb = NULL;\n\t\tdev->stats.tx_errors++;\n\t}\n\n\t/* To exclude tx timeout */\n\tnetif_trans_update(dev); /* prevent tx timeout */\n\n\t/* We're all ready to go. Start the queue */\n\tnetif_wake_queue(dev);\n\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n}\n\n/**********************/\n/* Interrupt Handlers */\n/**********************/\n\n/**\n * xemaclite_tx_handler - Interrupt handler for frames sent\n * @dev:\tPointer to the network device\n *\n * This function updates the number of packets transmitted and handles the\n * deferred skb, if there is one.\n */\nstatic void xemaclite_tx_handler(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tdev->stats.tx_packets++;\n\n\tif (!lp->deferred_skb)\n\t\treturn;\n\n\tif (xemaclite_send_data(lp, (u8 *)lp->deferred_skb->data,\n\t\t\t\tlp->deferred_skb->len))\n\t\treturn;\n\n\tdev->stats.tx_bytes += lp->deferred_skb->len;\n\tdev_consume_skb_irq(lp->deferred_skb);\n\tlp->deferred_skb = NULL;\n\tnetif_trans_update(dev); /* prevent tx timeout */\n\tnetif_wake_queue(dev);\n}\n\n/**\n * xemaclite_rx_handler- Interrupt handler for frames received\n * @dev:\tPointer to the network device\n *\n * This function allocates memory for a socket buffer, fills it with data\n * received and hands it over to the TCP/IP stack.\n */\nstatic void xemaclite_rx_handler(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tunsigned int align;\n\tu32 len;\n\n\tlen = ETH_FRAME_LEN + ETH_FCS_LEN;\n\tskb = netdev_alloc_skb(dev, len + ALIGNMENT);\n\tif (!skb) {\n\t\t/* Couldn't get memory. */\n\t\tdev->stats.rx_dropped++;\n\t\tdev_err(&lp->ndev->dev, \"Could not allocate receive buffer\\n\");\n\t\treturn;\n\t}\n\n\t/* A new skb should have the data halfword aligned, but this code is\n\t * here just in case that isn't true. Calculate how many\n\t * bytes we should reserve to get the data to start on a word\n\t * boundary\n\t */\n\talign = BUFFER_ALIGN(skb->data);\n\tif (align)\n\t\tskb_reserve(skb, align);\n\n\tskb_reserve(skb, 2);\n\n\tlen = xemaclite_recv_data(lp, (u8 *)skb->data, len);\n\n\tif (!len) {\n\t\tdev->stats.rx_errors++;\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, len);\t/* Tell the skb how much data we got */\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tskb_checksum_none_assert(skb);\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\tif (!skb_defer_rx_timestamp(skb))\n\t\tnetif_rx(skb);\t/* Send the packet upstream */\n}\n\n/**\n * xemaclite_interrupt - Interrupt handler for this driver\n * @irq:\tIrq of the Emaclite device\n * @dev_id:\tVoid pointer to the network device instance used as callback\n *\t\treference\n *\n * Return:\tIRQ_HANDLED\n *\n * This function handles the Tx and Rx interrupts of the EmacLite device.\n */\nstatic irqreturn_t xemaclite_interrupt(int irq, void *dev_id)\n{\n\tbool tx_complete = false;\n\tstruct net_device *dev = dev_id;\n\tstruct net_local *lp = netdev_priv(dev);\n\tvoid __iomem *base_addr = lp->base_addr;\n\tu32 tx_status;\n\n\t/* Check if there is Rx Data available */\n\tif ((xemaclite_readl(base_addr + XEL_RSR_OFFSET) &\n\t\t\t XEL_RSR_RECV_DONE_MASK) ||\n\t    (xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)\n\t\t\t & XEL_RSR_RECV_DONE_MASK))\n\n\t\txemaclite_rx_handler(dev);\n\n\t/* Check if the Transmission for the first buffer is completed */\n\ttx_status = xemaclite_readl(base_addr + XEL_TSR_OFFSET);\n\tif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\n\t\t(tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\n\n\t\ttx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\n\t\txemaclite_writel(tx_status, base_addr + XEL_TSR_OFFSET);\n\n\t\ttx_complete = true;\n\t}\n\n\t/* Check if the Transmission for the second buffer is completed */\n\ttx_status = xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\tif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\n\t\t(tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\n\n\t\ttx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\n\t\txemaclite_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +\n\t\t\t\t XEL_TSR_OFFSET);\n\n\t\ttx_complete = true;\n\t}\n\n\t/* If there was a Tx interrupt, call the Tx Handler */\n\tif (tx_complete != 0)\n\t\txemaclite_tx_handler(dev);\n\n\treturn IRQ_HANDLED;\n}\n\n/**********************/\n/* MDIO Bus functions */\n/**********************/\n\n/**\n * xemaclite_mdio_wait - Wait for the MDIO to be ready to use\n * @lp:\t\tPointer to the Emaclite device private data\n *\n * This function waits till the device is ready to accept a new MDIO\n * request.\n *\n * Return:\t0 for success or ETIMEDOUT for a timeout\n */\n\nstatic int xemaclite_mdio_wait(struct net_local *lp)\n{\n\tu32 val;\n\n\t/* wait for the MDIO interface to not be busy or timeout\n\t * after some time.\n\t */\n\treturn readx_poll_timeout(xemaclite_readl,\n\t\t\t\t  lp->base_addr + XEL_MDIOCTRL_OFFSET,\n\t\t\t\t  val, !(val & XEL_MDIOCTRL_MDIOSTS_MASK),\n\t\t\t\t  1000, 20000);\n}\n\n/**\n * xemaclite_mdio_read - Read from a given MII management register\n * @bus:\tthe mii_bus struct\n * @phy_id:\tthe phy address\n * @reg:\tregister number to read from\n *\n * This function waits till the device is ready to accept a new MDIO\n * request and then writes the phy address to the MDIO Address register\n * and reads data from MDIO Read Data register, when its available.\n *\n * Return:\tValue read from the MII management register\n */\nstatic int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct net_local *lp = bus->priv;\n\tu32 ctrl_reg;\n\tu32 rc;\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\t/* Write the PHY address, register number and set the OP bit in the\n\t * MDIO Address register. Set the Status bit in the MDIO Control\n\t * register to start a MDIO read transaction.\n\t */\n\tctrl_reg = xemaclite_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\txemaclite_writel(XEL_MDIOADDR_OP_MASK |\n\t\t\t ((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\n\t\t\t lp->base_addr + XEL_MDIOADDR_OFFSET);\n\txemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\trc = xemaclite_readl(lp->base_addr + XEL_MDIORD_OFFSET);\n\n\tdev_dbg(&lp->ndev->dev,\n\t\t\"%s(phy_id=%i, reg=%x) == %x\\n\", __func__,\n\t\tphy_id, reg, rc);\n\n\treturn rc;\n}\n\n/**\n * xemaclite_mdio_write - Write to a given MII management register\n * @bus:\tthe mii_bus struct\n * @phy_id:\tthe phy address\n * @reg:\tregister number to write to\n * @val:\tvalue to write to the register number specified by reg\n *\n * This function waits till the device is ready to accept a new MDIO\n * request and then writes the val to the MDIO Write Data register.\n *\n * Return:      0 upon success or a negative error upon failure\n */\nstatic int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,\n\t\t\t\tu16 val)\n{\n\tstruct net_local *lp = bus->priv;\n\tu32 ctrl_reg;\n\n\tdev_dbg(&lp->ndev->dev,\n\t\t\"%s(phy_id=%i, reg=%x, val=%x)\\n\", __func__,\n\t\tphy_id, reg, val);\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\t/* Write the PHY address, register number and clear the OP bit in the\n\t * MDIO Address register and then write the value into the MDIO Write\n\t * Data register. Finally, set the Status bit in the MDIO Control\n\t * register to start a MDIO write transaction.\n\t */\n\tctrl_reg = xemaclite_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\txemaclite_writel(~XEL_MDIOADDR_OP_MASK &\n\t\t\t ((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\n\t\t\t lp->base_addr + XEL_MDIOADDR_OFFSET);\n\txemaclite_writel(val, lp->base_addr + XEL_MDIOWR_OFFSET);\n\txemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\treturn 0;\n}\n\n/**\n * xemaclite_mdio_setup - Register mii_bus for the Emaclite device\n * @lp:\t\tPointer to the Emaclite device private data\n * @dev:\tPointer to OF device structure\n *\n * This function enables MDIO bus in the Emaclite device and registers a\n * mii_bus.\n *\n * Return:\t0 upon success or a negative error upon failure\n */\nstatic int xemaclite_mdio_setup(struct net_local *lp, struct device *dev)\n{\n\tstruct mii_bus *bus;\n\tint rc;\n\tstruct resource res;\n\tstruct device_node *np = of_get_parent(lp->phy_node);\n\tstruct device_node *npp;\n\n\t/* Don't register the MDIO bus if the phy_node or its parent node\n\t * can't be found.\n\t */\n\tif (!np) {\n\t\tdev_err(dev, \"Failed to register mdio bus.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tnpp = of_get_parent(np);\n\n\tof_address_to_resource(npp, 0, &res);\n\tif (lp->ndev->mem_start != res.start) {\n\t\tstruct phy_device *phydev;\n\t\tphydev = of_phy_find_device(lp->phy_node);\n\t\tif (!phydev)\n\t\t\tdev_info(dev,\n\t\t\t\t \"MDIO of the phy is not registered yet\\n\");\n\t\telse\n\t\t\tput_device(&phydev->mdio.dev);\n\t\treturn 0;\n\t}\n\n\t/* Enable the MDIO bus by asserting the enable bit in MDIO Control\n\t * register.\n\t */\n\txemaclite_writel(XEL_MDIOCTRL_MDIOEN_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\tbus = mdiobus_alloc();\n\tif (!bus) {\n\t\tdev_err(dev, \"Failed to allocate mdiobus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%.8llx\",\n\t\t (unsigned long long)res.start);\n\tbus->priv = lp;\n\tbus->name = \"Xilinx Emaclite MDIO\";\n\tbus->read = xemaclite_mdio_read;\n\tbus->write = xemaclite_mdio_write;\n\tbus->parent = dev;\n\n\trc = of_mdiobus_register(bus, np);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to register mdio bus.\\n\");\n\t\tgoto err_register;\n\t}\n\n\tlp->mii_bus = bus;\n\n\treturn 0;\n\nerr_register:\n\tmdiobus_free(bus);\n\treturn rc;\n}\n\n/**\n * xemaclite_adjust_link - Link state callback for the Emaclite device\n * @ndev: pointer to net_device struct\n *\n * There's nothing in the Emaclite device to be configured when the link\n * state changes. We just print the status.\n */\nstatic void xemaclite_adjust_link(struct net_device *ndev)\n{\n\tstruct net_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phy = lp->phy_dev;\n\tint link_state;\n\n\t/* hash together the state values to decide if something has changed */\n\tlink_state = phy->speed | (phy->duplex << 1) | phy->link;\n\n\tif (lp->last_link != link_state) {\n\t\tlp->last_link = link_state;\n\t\tphy_print_status(phy);\n\t}\n}\n\n/**\n * xemaclite_open - Open the network device\n * @dev:\tPointer to the network device\n *\n * This function sets the MAC address, requests an IRQ and enables interrupts\n * for the Emaclite device and starts the Tx queue.\n * It also connects to the phy device, if MDIO is included in Emaclite device.\n *\n * Return:\t0 on success. -ENODEV, if PHY cannot be connected.\n *\t\tNon-zero error value on failure.\n */\nstatic int xemaclite_open(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint retval;\n\n\t/* Just to be safe, stop the device first */\n\txemaclite_disable_interrupts(lp);\n\n\tif (lp->phy_node) {\n\t\tu32 bmcr;\n\n\t\tlp->phy_dev = of_phy_connect(lp->ndev, lp->phy_node,\n\t\t\t\t\t     xemaclite_adjust_link, 0,\n\t\t\t\t\t     PHY_INTERFACE_MODE_MII);\n\t\tif (!lp->phy_dev) {\n\t\t\tdev_err(&lp->ndev->dev, \"of_phy_connect() failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* EmacLite doesn't support giga-bit speeds */\n\t\tphy_set_max_speed(lp->phy_dev, SPEED_100);\n\n\t\t/* Don't advertise 1000BASE-T Full/Half duplex speeds */\n\t\tphy_write(lp->phy_dev, MII_CTRL1000, 0);\n\n\t\t/* Advertise only 10 and 100mbps full/half duplex speeds */\n\t\tphy_write(lp->phy_dev, MII_ADVERTISE, ADVERTISE_ALL |\n\t\t\t  ADVERTISE_CSMA);\n\n\t\t/* Restart auto negotiation */\n\t\tbmcr = phy_read(lp->phy_dev, MII_BMCR);\n\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\tphy_write(lp->phy_dev, MII_BMCR, bmcr);\n\n\t\tphy_start(lp->phy_dev);\n\t}\n\n\t/* Set the MAC address each time opened */\n\txemaclite_update_address(lp, dev->dev_addr);\n\n\t/* Grab the IRQ */\n\tretval = request_irq(dev->irq, xemaclite_interrupt, 0, dev->name, dev);\n\tif (retval) {\n\t\tdev_err(&lp->ndev->dev, \"Could not allocate interrupt %d\\n\",\n\t\t\tdev->irq);\n\t\tif (lp->phy_dev)\n\t\t\tphy_disconnect(lp->phy_dev);\n\t\tlp->phy_dev = NULL;\n\n\t\treturn retval;\n\t}\n\n\t/* Enable Interrupts */\n\txemaclite_enable_interrupts(lp);\n\n\t/* We're ready to go */\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n/**\n * xemaclite_close - Close the network device\n * @dev:\tPointer to the network device\n *\n * This function stops the Tx queue, disables interrupts and frees the IRQ for\n * the Emaclite device.\n * It also disconnects the phy device associated with the Emaclite device.\n *\n * Return:\t0, always.\n */\nstatic int xemaclite_close(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\txemaclite_disable_interrupts(lp);\n\tfree_irq(dev->irq, dev);\n\n\tif (lp->phy_dev)\n\t\tphy_disconnect(lp->phy_dev);\n\tlp->phy_dev = NULL;\n\n\treturn 0;\n}\n\n/**\n * xemaclite_send - Transmit a frame\n * @orig_skb:\tPointer to the socket buffer to be transmitted\n * @dev:\tPointer to the network device\n *\n * This function checks if the Tx buffer of the Emaclite device is free to send\n * data. If so, it fills the Tx buffer with data from socket buffer data,\n * updates the stats and frees the socket buffer. The Tx completion is signaled\n * by an interrupt. If the Tx buffer isn't free, then the socket buffer is\n * deferred and the Tx queue is stopped so that the deferred socket buffer can\n * be transmitted when the Emaclite device is free to transmit data.\n *\n * Return:\tNETDEV_TX_OK, always.\n */\nstatic netdev_tx_t\nxemaclite_send(struct sk_buff *orig_skb, struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *new_skb;\n\tunsigned int len;\n\tunsigned long flags;\n\n\tlen = orig_skb->len;\n\n\tnew_skb = orig_skb;\n\n\tspin_lock_irqsave(&lp->reset_lock, flags);\n\tif (xemaclite_send_data(lp, (u8 *)new_skb->data, len) != 0) {\n\t\t/* If the Emaclite Tx buffer is busy, stop the Tx queue and\n\t\t * defer the skb for transmission during the ISR, after the\n\t\t * current transmission is complete\n\t\t */\n\t\tnetif_stop_queue(dev);\n\t\tlp->deferred_skb = new_skb;\n\t\t/* Take the time stamp now, since we can't do this in an ISR. */\n\t\tskb_tx_timestamp(new_skb);\n\t\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n\n\tskb_tx_timestamp(new_skb);\n\n\tdev->stats.tx_bytes += len;\n\tdev_consume_skb_any(new_skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n/**\n * get_bool - Get a parameter from the OF device\n * @ofdev:\tPointer to OF device structure\n * @s:\t\tProperty to be retrieved\n *\n * This function looks for a property in the device node and returns the value\n * of the property if its found or 0 if the property is not found.\n *\n * Return:\tValue of the parameter if the parameter is found, or 0 otherwise\n */\nstatic bool get_bool(struct platform_device *ofdev, const char *s)\n{\n\tu32 *p = (u32 *)of_get_property(ofdev->dev.of_node, s, NULL);\n\n\tif (!p) {\n\t\tdev_warn(&ofdev->dev, \"Parameter %s not found, defaulting to false\\n\", s);\n\t\treturn false;\n\t}\n\n\treturn (bool)*p;\n}\n\n/**\n * xemaclite_ethtools_get_drvinfo - Get various Axi Emac Lite driver info\n * @ndev:       Pointer to net_device structure\n * @ed:         Pointer to ethtool_drvinfo structure\n *\n * This implements ethtool command for getting the driver information.\n * Issue \"ethtool -i ethX\" under linux prompt to execute this function.\n */\nstatic void xemaclite_ethtools_get_drvinfo(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_drvinfo *ed)\n{\n\tstrlcpy(ed->driver, DRIVER_NAME, sizeof(ed->driver));\n}\n\nstatic const struct ethtool_ops xemaclite_ethtool_ops = {\n\t.get_drvinfo    = xemaclite_ethtools_get_drvinfo,\n\t.get_link       = ethtool_op_get_link,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops xemaclite_netdev_ops;\n\n/**\n * xemaclite_of_probe - Probe method for the Emaclite device.\n * @ofdev:\tPointer to OF device structure\n *\n * This function probes for the Emaclite device in the device tree.\n * It initializes the driver data structure and the hardware, sets the MAC\n * address and registers the network device.\n * It also registers a mii_bus for the Emaclite device, if MDIO is included\n * in the device.\n *\n * Return:\t0, if the driver is bound to the Emaclite device, or\n *\t\ta negative error if there is failure.\n */\nstatic int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%08lX, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start,\n\t\t (unsigned long __force)lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}\n\n/**\n * xemaclite_of_remove - Unbind the driver from the Emaclite device.\n * @of_dev:\tPointer to OF device structure\n *\n * This function is called if a device is physically removed from the system or\n * if the driver module is being unloaded. It frees any resources allocated to\n * the device.\n *\n * Return:\t0, always.\n */\nstatic int xemaclite_of_remove(struct platform_device *of_dev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(of_dev);\n\n\tstruct net_local *lp = netdev_priv(ndev);\n\n\t/* Un-register the mii_bus, if configured */\n\tif (lp->mii_bus) {\n\t\tmdiobus_unregister(lp->mii_bus);\n\t\tmdiobus_free(lp->mii_bus);\n\t\tlp->mii_bus = NULL;\n\t}\n\n\tunregister_netdev(ndev);\n\n\tof_node_put(lp->phy_node);\n\tlp->phy_node = NULL;\n\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\nxemaclite_poll_controller(struct net_device *ndev)\n{\n\tdisable_irq(ndev->irq);\n\txemaclite_interrupt(ndev->irq, ndev);\n\tenable_irq(ndev->irq);\n}\n#endif\n\n/* Ioctl MII Interface */\nstatic int xemaclite_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tif (!dev->phydev || !netif_running(dev))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn phy_mii_ioctl(dev->phydev, rq, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops xemaclite_netdev_ops = {\n\t.ndo_open\t\t= xemaclite_open,\n\t.ndo_stop\t\t= xemaclite_close,\n\t.ndo_start_xmit\t\t= xemaclite_send,\n\t.ndo_set_mac_address\t= xemaclite_set_mac_address,\n\t.ndo_tx_timeout\t\t= xemaclite_tx_timeout,\n\t.ndo_do_ioctl\t\t= xemaclite_ioctl,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = xemaclite_poll_controller,\n#endif\n};\n\n/* Match table for OF platform binding */\nstatic const struct of_device_id xemaclite_of_match[] = {\n\t{ .compatible = \"xlnx,opb-ethernetlite-1.01.a\", },\n\t{ .compatible = \"xlnx,opb-ethernetlite-1.01.b\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-1.00.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-2.01.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-3.00.a\", },\n\t{ /* end of list */ },\n};\nMODULE_DEVICE_TABLE(of, xemaclite_of_match);\n\nstatic struct platform_driver xemaclite_of_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = xemaclite_of_match,\n\t},\n\t.probe\t\t= xemaclite_of_probe,\n\t.remove\t\t= xemaclite_of_remove,\n};\n\nmodule_platform_driver(xemaclite_of_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx Ethernet MAC Lite driver\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Xilinx EmacLite Linux driver for the Xilinx Ethernet MAC Lite device.\n *\n * This is a new flat driver which is based on the original emac_lite\n * driver from John Williams <john.williams@xilinx.com>.\n *\n * 2007 - 2013 (c) Xilinx, Inc.\n */\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n\n#define DRIVER_NAME \"xilinx_emaclite\"\n\n/* Register offsets for the EmacLite Core */\n#define XEL_TXBUFF_OFFSET\t0x0\t\t/* Transmit Buffer */\n#define XEL_MDIOADDR_OFFSET\t0x07E4\t\t/* MDIO Address Register */\n#define XEL_MDIOWR_OFFSET\t0x07E8\t\t/* MDIO Write Data Register */\n#define XEL_MDIORD_OFFSET\t0x07EC\t\t/* MDIO Read Data Register */\n#define XEL_MDIOCTRL_OFFSET\t0x07F0\t\t/* MDIO Control Register */\n#define XEL_GIER_OFFSET\t\t0x07F8\t\t/* GIE Register */\n#define XEL_TSR_OFFSET\t\t0x07FC\t\t/* Tx status */\n#define XEL_TPLR_OFFSET\t\t0x07F4\t\t/* Tx packet length */\n\n#define XEL_RXBUFF_OFFSET\t0x1000\t\t/* Receive Buffer */\n#define XEL_RPLR_OFFSET\t\t0x100C\t\t/* Rx packet length */\n#define XEL_RSR_OFFSET\t\t0x17FC\t\t/* Rx status */\n\n#define XEL_BUFFER_OFFSET\t0x0800\t\t/* Next Tx/Rx buffer's offset */\n\n/* MDIO Address Register Bit Masks */\n#define XEL_MDIOADDR_REGADR_MASK  0x0000001F\t/* Register Address */\n#define XEL_MDIOADDR_PHYADR_MASK  0x000003E0\t/* PHY Address */\n#define XEL_MDIOADDR_PHYADR_SHIFT 5\n#define XEL_MDIOADDR_OP_MASK\t  0x00000400\t/* RD/WR Operation */\n\n/* MDIO Write Data Register Bit Masks */\n#define XEL_MDIOWR_WRDATA_MASK\t  0x0000FFFF\t/* Data to be Written */\n\n/* MDIO Read Data Register Bit Masks */\n#define XEL_MDIORD_RDDATA_MASK\t  0x0000FFFF\t/* Data to be Read */\n\n/* MDIO Control Register Bit Masks */\n#define XEL_MDIOCTRL_MDIOSTS_MASK 0x00000001\t/* MDIO Status Mask */\n#define XEL_MDIOCTRL_MDIOEN_MASK  0x00000008\t/* MDIO Enable */\n\n/* Global Interrupt Enable Register (GIER) Bit Masks */\n#define XEL_GIER_GIE_MASK\t0x80000000\t/* Global Enable */\n\n/* Transmit Status Register (TSR) Bit Masks */\n#define XEL_TSR_XMIT_BUSY_MASK\t 0x00000001\t/* Tx complete */\n#define XEL_TSR_PROGRAM_MASK\t 0x00000002\t/* Program the MAC address */\n#define XEL_TSR_XMIT_IE_MASK\t 0x00000008\t/* Tx interrupt enable bit */\n#define XEL_TSR_XMIT_ACTIVE_MASK 0x80000000\t/* Buffer is active, SW bit\n\t\t\t\t\t\t * only. This is not documented\n\t\t\t\t\t\t * in the HW spec\n\t\t\t\t\t\t */\n\n/* Define for programming the MAC address into the EmacLite */\n#define XEL_TSR_PROG_MAC_ADDR\t(XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_PROGRAM_MASK)\n\n/* Receive Status Register (RSR) */\n#define XEL_RSR_RECV_DONE_MASK\t0x00000001\t/* Rx complete */\n#define XEL_RSR_RECV_IE_MASK\t0x00000008\t/* Rx interrupt enable bit */\n\n/* Transmit Packet Length Register (TPLR) */\n#define XEL_TPLR_LENGTH_MASK\t0x0000FFFF\t/* Tx packet length */\n\n/* Receive Packet Length Register (RPLR) */\n#define XEL_RPLR_LENGTH_MASK\t0x0000FFFF\t/* Rx packet length */\n\n#define XEL_HEADER_OFFSET\t12\t\t/* Offset to length field */\n#define XEL_HEADER_SHIFT\t16\t\t/* Shift value for length */\n\n/* General Ethernet Definitions */\n#define XEL_ARP_PACKET_SIZE\t\t28\t/* Max ARP packet size */\n#define XEL_HEADER_IP_LENGTH_OFFSET\t16\t/* IP Length Offset */\n\n\n\n#define TX_TIMEOUT\t\t(60 * HZ)\t/* Tx timeout is 60 seconds. */\n#define ALIGNMENT\t\t4\n\n/* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */\n#define BUFFER_ALIGN(adr) ((ALIGNMENT - ((uintptr_t)adr)) % ALIGNMENT)\n\n#ifdef __BIG_ENDIAN\n#define xemaclite_readl\t\tioread32be\n#define xemaclite_writel\tiowrite32be\n#else\n#define xemaclite_readl\t\tioread32\n#define xemaclite_writel\tiowrite32\n#endif\n\n/**\n * struct net_local - Our private per device data\n * @ndev:\t\tinstance of the network device\n * @tx_ping_pong:\tindicates whether Tx Pong buffer is configured in HW\n * @rx_ping_pong:\tindicates whether Rx Pong buffer is configured in HW\n * @next_tx_buf_to_use:\tnext Tx buffer to write to\n * @next_rx_buf_to_use:\tnext Rx buffer to read from\n * @base_addr:\t\tbase address of the Emaclite device\n * @reset_lock:\t\tlock used for synchronization\n * @deferred_skb:\tholds an skb (for transmission at a later time) when the\n *\t\t\tTx buffer is not free\n * @phy_dev:\t\tpointer to the PHY device\n * @phy_node:\t\tpointer to the PHY device node\n * @mii_bus:\t\tpointer to the MII bus\n * @last_link:\t\tlast link status\n */\nstruct net_local {\n\n\tstruct net_device *ndev;\n\n\tbool tx_ping_pong;\n\tbool rx_ping_pong;\n\tu32 next_tx_buf_to_use;\n\tu32 next_rx_buf_to_use;\n\tvoid __iomem *base_addr;\n\n\tspinlock_t reset_lock;\n\tstruct sk_buff *deferred_skb;\n\n\tstruct phy_device *phy_dev;\n\tstruct device_node *phy_node;\n\n\tstruct mii_bus *mii_bus;\n\n\tint last_link;\n};\n\n\n/*************************/\n/* EmacLite driver calls */\n/*************************/\n\n/**\n * xemaclite_enable_interrupts - Enable the interrupts for the EmacLite device\n * @drvdata:\tPointer to the Emaclite device private data\n *\n * This function enables the Tx and Rx interrupts for the Emaclite device along\n * with the Global Interrupt Enable.\n */\nstatic void xemaclite_enable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t/* Enable the Tx interrupts for the first Buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data | XEL_TSR_XMIT_IE_MASK,\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t/* Enable the Rx interrupts for the first buffer */\n\txemaclite_writel(XEL_RSR_RECV_IE_MASK, drvdata->base_addr + XEL_RSR_OFFSET);\n\n\t/* Enable the Global Interrupt Enable */\n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n}\n\n/**\n * xemaclite_disable_interrupts - Disable the interrupts for the EmacLite device\n * @drvdata:\tPointer to the Emaclite device private data\n *\n * This function disables the Tx and Rx interrupts for the Emaclite device,\n * along with the Global Interrupt Enable.\n */\nstatic void xemaclite_disable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t/* Disable the Global Interrupt Enable */\n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n\n\t/* Disable the Tx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t/* Disable the Rx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_RSR_OFFSET);\n}\n\n/**\n * xemaclite_aligned_write - Write from 16-bit aligned to 32-bit aligned address\n * @src_ptr:\tVoid pointer to the 16-bit aligned source address\n * @dest_ptr:\tPointer to the 32-bit aligned destination address\n * @length:\tNumber bytes to write from source to destination\n *\n * This function writes data from a 16-bit aligned buffer to a 32-bit aligned\n * address in the EmacLite device.\n */\nstatic void xemaclite_aligned_write(void *src_ptr, u32 *dest_ptr,\n\t\t\t\t    unsigned length)\n{\n\tu32 align_buffer;\n\tu32 *to_u32_ptr;\n\tu16 *from_u16_ptr, *to_u16_ptr;\n\n\tto_u32_ptr = dest_ptr;\n\tfrom_u16_ptr = src_ptr;\n\talign_buffer = 0;\n\n\tfor (; length > 3; length -= 4) {\n\t\tto_u16_ptr = (u16 *)&align_buffer;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\n\t\t/* This barrier resolves occasional issues seen around\n\t\t * cases where the data is not properly flushed out\n\t\t * from the processor store buffers to the destination\n\t\t * memory locations.\n\t\t */\n\t\twmb();\n\n\t\t/* Output a word */\n\t\t*to_u32_ptr++ = align_buffer;\n\t}\n\tif (length) {\n\t\tu8 *from_u8_ptr, *to_u8_ptr;\n\n\t\t/* Set up to output the remaining data */\n\t\talign_buffer = 0;\n\t\tto_u8_ptr = (u8 *)&align_buffer;\n\t\tfrom_u8_ptr = (u8 *)from_u16_ptr;\n\n\t\t/* Output the remaining data */\n\t\tfor (; length > 0; length--)\n\t\t\t*to_u8_ptr++ = *from_u8_ptr++;\n\n\t\t/* This barrier resolves occasional issues seen around\n\t\t * cases where the data is not properly flushed out\n\t\t * from the processor store buffers to the destination\n\t\t * memory locations.\n\t\t */\n\t\twmb();\n\t\t*to_u32_ptr = align_buffer;\n\t}\n}\n\n/**\n * xemaclite_aligned_read - Read from 32-bit aligned to 16-bit aligned buffer\n * @src_ptr:\tPointer to the 32-bit aligned source address\n * @dest_ptr:\tPointer to the 16-bit aligned destination address\n * @length:\tNumber bytes to read from source to destination\n *\n * This function reads data from a 32-bit aligned address in the EmacLite device\n * to a 16-bit aligned buffer.\n */\nstatic void xemaclite_aligned_read(u32 *src_ptr, u8 *dest_ptr,\n\t\t\t\t   unsigned length)\n{\n\tu16 *to_u16_ptr, *from_u16_ptr;\n\tu32 *from_u32_ptr;\n\tu32 align_buffer;\n\n\tfrom_u32_ptr = src_ptr;\n\tto_u16_ptr = (u16 *)dest_ptr;\n\n\tfor (; length > 3; length -= 4) {\n\t\t/* Copy each word into the temporary buffer */\n\t\talign_buffer = *from_u32_ptr++;\n\t\tfrom_u16_ptr = (u16 *)&align_buffer;\n\n\t\t/* Read data from source */\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t\t*to_u16_ptr++ = *from_u16_ptr++;\n\t}\n\n\tif (length) {\n\t\tu8 *to_u8_ptr, *from_u8_ptr;\n\n\t\t/* Set up to read the remaining data */\n\t\tto_u8_ptr = (u8 *)to_u16_ptr;\n\t\talign_buffer = *from_u32_ptr++;\n\t\tfrom_u8_ptr = (u8 *)&align_buffer;\n\n\t\t/* Read the remaining data */\n\t\tfor (; length > 0; length--)\n\t\t\t*to_u8_ptr = *from_u8_ptr;\n\t}\n}\n\n/**\n * xemaclite_send_data - Send an Ethernet frame\n * @drvdata:\tPointer to the Emaclite device private data\n * @data:\tPointer to the data to be sent\n * @byte_count:\tTotal frame size, including header\n *\n * This function checks if the Tx buffer of the Emaclite device is free to send\n * data. If so, it fills the Tx buffer with data for transmission. Otherwise, it\n * returns an error.\n *\n * Return:\t0 upon success or -1 if the buffer(s) are full.\n *\n * Note:\tThe maximum Tx packet size can not be more than Ethernet header\n *\t\t(14 Bytes) + Maximum MTU (1500 bytes). This is excluding FCS.\n */\nstatic int xemaclite_send_data(struct net_local *drvdata, u8 *data,\n\t\t\t       unsigned int byte_count)\n{\n\tu32 reg_data;\n\tvoid __iomem *addr;\n\n\t/* Determine the expected Tx buffer address */\n\taddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\n\n\t/* If the length is too large, truncate it */\n\tif (byte_count > ETH_FRAME_LEN)\n\t\tbyte_count = ETH_FRAME_LEN;\n\n\t/* Check if the expected buffer is available */\n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\tif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\n\t     XEL_TSR_XMIT_ACTIVE_MASK)) == 0) {\n\n\t\t/* Switch to next buffer if configured */\n\t\tif (drvdata->tx_ping_pong != 0)\n\t\t\tdrvdata->next_tx_buf_to_use ^= XEL_BUFFER_OFFSET;\n\t} else if (drvdata->tx_ping_pong != 0) {\n\t\t/* If the expected buffer is full, try the other buffer,\n\t\t * if it is configured in HW\n\t\t */\n\n\t\taddr = (void __iomem __force *)((uintptr_t __force)addr ^\n\t\t\t\t\t\t XEL_BUFFER_OFFSET);\n\t\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\n\t\tif ((reg_data & (XEL_TSR_XMIT_BUSY_MASK |\n\t\t     XEL_TSR_XMIT_ACTIVE_MASK)) != 0)\n\t\t\treturn -1; /* Buffers were full, return failure */\n\t} else\n\t\treturn -1; /* Buffer was full, return failure */\n\n\t/* Write the frame to the buffer */\n\txemaclite_aligned_write(data, (u32 __force *)addr, byte_count);\n\n\txemaclite_writel((byte_count & XEL_TPLR_LENGTH_MASK),\n\t\t\t addr + XEL_TPLR_OFFSET);\n\n\t/* Update the Tx Status Register to indicate that there is a\n\t * frame to send. Set the XEL_TSR_XMIT_ACTIVE_MASK flag which\n\t * is used by the interrupt handler to check whether a frame\n\t * has been transmitted\n\t */\n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\treg_data |= (XEL_TSR_XMIT_BUSY_MASK | XEL_TSR_XMIT_ACTIVE_MASK);\n\txemaclite_writel(reg_data, addr + XEL_TSR_OFFSET);\n\n\treturn 0;\n}\n\n/**\n * xemaclite_recv_data - Receive a frame\n * @drvdata:\tPointer to the Emaclite device private data\n * @data:\tAddress where the data is to be received\n * @maxlen:    Maximum supported ethernet packet length\n *\n * This function is intended to be called from the interrupt context or\n * with a wrapper which waits for the receive frame to be available.\n *\n * Return:\tTotal number of bytes received\n */\nstatic u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data, int maxlen)\n{\n\tvoid __iomem *addr;\n\tu16 length, proto_type;\n\tu32 reg_data;\n\n\t/* Determine the expected buffer address */\n\taddr = (drvdata->base_addr + drvdata->next_rx_buf_to_use);\n\n\t/* Verify which buffer has valid data */\n\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\n\tif ((reg_data & XEL_RSR_RECV_DONE_MASK) == XEL_RSR_RECV_DONE_MASK) {\n\t\tif (drvdata->rx_ping_pong != 0)\n\t\t\tdrvdata->next_rx_buf_to_use ^= XEL_BUFFER_OFFSET;\n\t} else {\n\t\t/* The instance is out of sync, try other buffer if other\n\t\t * buffer is configured, return 0 otherwise. If the instance is\n\t\t * out of sync, do not update the 'next_rx_buf_to_use' since it\n\t\t * will correct on subsequent calls\n\t\t */\n\t\tif (drvdata->rx_ping_pong != 0)\n\t\t\taddr = (void __iomem __force *)\n\t\t\t\t((uintptr_t __force)addr ^\n\t\t\t\t XEL_BUFFER_OFFSET);\n\t\telse\n\t\t\treturn 0;\t/* No data was available */\n\n\t\t/* Verify that buffer has valid data */\n\t\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\t\tif ((reg_data & XEL_RSR_RECV_DONE_MASK) !=\n\t\t     XEL_RSR_RECV_DONE_MASK)\n\t\t\treturn 0;\t/* No data was available */\n\t}\n\n\t/* Get the protocol type of the ethernet frame that arrived\n\t */\n\tproto_type = ((ntohl(xemaclite_readl(addr + XEL_HEADER_OFFSET +\n\t\t\tXEL_RXBUFF_OFFSET)) >> XEL_HEADER_SHIFT) &\n\t\t\tXEL_RPLR_LENGTH_MASK);\n\n\t/* Check if received ethernet frame is a raw ethernet frame\n\t * or an IP packet or an ARP packet\n\t */\n\tif (proto_type > ETH_DATA_LEN) {\n\n\t\tif (proto_type == ETH_P_IP) {\n\t\t\tlength = ((ntohl(xemaclite_readl(addr +\n\t\t\t\t\tXEL_HEADER_IP_LENGTH_OFFSET +\n\t\t\t\t\tXEL_RXBUFF_OFFSET)) >>\n\t\t\t\t\tXEL_HEADER_SHIFT) &\n\t\t\t\t\tXEL_RPLR_LENGTH_MASK);\n\t\t\tlength = min_t(u16, length, ETH_DATA_LEN);\n\t\t\tlength += ETH_HLEN + ETH_FCS_LEN;\n\n\t\t} else if (proto_type == ETH_P_ARP)\n\t\t\tlength = XEL_ARP_PACKET_SIZE + ETH_HLEN + ETH_FCS_LEN;\n\t\telse\n\t\t\t/* Field contains type other than IP or ARP, use max\n\t\t\t * frame size and let user parse it\n\t\t\t */\n\t\t\tlength = ETH_FRAME_LEN + ETH_FCS_LEN;\n\t} else\n\t\t/* Use the length in the frame, plus the header and trailer */\n\t\tlength = proto_type + ETH_HLEN + ETH_FCS_LEN;\n\n\tif (WARN_ON(length > maxlen))\n\t\tlength = maxlen;\n\n\t/* Read from the EmacLite device */\n\txemaclite_aligned_read((u32 __force *)(addr + XEL_RXBUFF_OFFSET),\n\t\t\t\tdata, length);\n\n\t/* Acknowledge the frame */\n\treg_data = xemaclite_readl(addr + XEL_RSR_OFFSET);\n\treg_data &= ~XEL_RSR_RECV_DONE_MASK;\n\txemaclite_writel(reg_data, addr + XEL_RSR_OFFSET);\n\n\treturn length;\n}\n\n/**\n * xemaclite_update_address - Update the MAC address in the device\n * @drvdata:\tPointer to the Emaclite device private data\n * @address_ptr:Pointer to the MAC address (MAC address is a 48-bit value)\n *\n * Tx must be idle and Rx should be idle for deterministic results.\n * It is recommended that this function should be called after the\n * initialization and before transmission of any packets from the device.\n * The MAC address can be programmed using any of the two transmit\n * buffers (if configured).\n */\nstatic void xemaclite_update_address(struct net_local *drvdata,\n\t\t\t\t     u8 *address_ptr)\n{\n\tvoid __iomem *addr;\n\tu32 reg_data;\n\n\t/* Determine the expected Tx buffer address */\n\taddr = drvdata->base_addr + drvdata->next_tx_buf_to_use;\n\n\txemaclite_aligned_write(address_ptr, (u32 __force *)addr, ETH_ALEN);\n\n\txemaclite_writel(ETH_ALEN, addr + XEL_TPLR_OFFSET);\n\n\t/* Update the MAC address in the EmacLite */\n\treg_data = xemaclite_readl(addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data | XEL_TSR_PROG_MAC_ADDR, addr + XEL_TSR_OFFSET);\n\n\t/* Wait for EmacLite to finish with the MAC address update */\n\twhile ((xemaclite_readl(addr + XEL_TSR_OFFSET) &\n\t\tXEL_TSR_PROG_MAC_ADDR) != 0)\n\t\t;\n}\n\n/**\n * xemaclite_set_mac_address - Set the MAC address for this device\n * @dev:\tPointer to the network device instance\n * @address:\tVoid pointer to the sockaddr structure\n *\n * This function copies the HW address from the sockaddr strucutre to the\n * net_device structure and updates the address in HW.\n *\n * Return:\tError if the net device is busy or 0 if the addr is set\n *\t\tsuccessfully\n */\nstatic int xemaclite_set_mac_address(struct net_device *dev, void *address)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sockaddr *addr = address;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\n\txemaclite_update_address(lp, dev->dev_addr);\n\treturn 0;\n}\n\n/**\n * xemaclite_tx_timeout - Callback for Tx Timeout\n * @dev:\tPointer to the network device\n * @txqueue:\tUnused\n *\n * This function is called when Tx time out occurs for Emaclite device.\n */\nstatic void xemaclite_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tdev_err(&lp->ndev->dev, \"Exceeded transmit timeout of %lu ms\\n\",\n\t\tTX_TIMEOUT * 1000UL / HZ);\n\n\tdev->stats.tx_errors++;\n\n\t/* Reset the device */\n\tspin_lock_irqsave(&lp->reset_lock, flags);\n\n\t/* Shouldn't really be necessary, but shouldn't hurt */\n\tnetif_stop_queue(dev);\n\n\txemaclite_disable_interrupts(lp);\n\txemaclite_enable_interrupts(lp);\n\n\tif (lp->deferred_skb) {\n\t\tdev_kfree_skb(lp->deferred_skb);\n\t\tlp->deferred_skb = NULL;\n\t\tdev->stats.tx_errors++;\n\t}\n\n\t/* To exclude tx timeout */\n\tnetif_trans_update(dev); /* prevent tx timeout */\n\n\t/* We're all ready to go. Start the queue */\n\tnetif_wake_queue(dev);\n\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n}\n\n/**********************/\n/* Interrupt Handlers */\n/**********************/\n\n/**\n * xemaclite_tx_handler - Interrupt handler for frames sent\n * @dev:\tPointer to the network device\n *\n * This function updates the number of packets transmitted and handles the\n * deferred skb, if there is one.\n */\nstatic void xemaclite_tx_handler(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tdev->stats.tx_packets++;\n\n\tif (!lp->deferred_skb)\n\t\treturn;\n\n\tif (xemaclite_send_data(lp, (u8 *)lp->deferred_skb->data,\n\t\t\t\tlp->deferred_skb->len))\n\t\treturn;\n\n\tdev->stats.tx_bytes += lp->deferred_skb->len;\n\tdev_consume_skb_irq(lp->deferred_skb);\n\tlp->deferred_skb = NULL;\n\tnetif_trans_update(dev); /* prevent tx timeout */\n\tnetif_wake_queue(dev);\n}\n\n/**\n * xemaclite_rx_handler- Interrupt handler for frames received\n * @dev:\tPointer to the network device\n *\n * This function allocates memory for a socket buffer, fills it with data\n * received and hands it over to the TCP/IP stack.\n */\nstatic void xemaclite_rx_handler(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tunsigned int align;\n\tu32 len;\n\n\tlen = ETH_FRAME_LEN + ETH_FCS_LEN;\n\tskb = netdev_alloc_skb(dev, len + ALIGNMENT);\n\tif (!skb) {\n\t\t/* Couldn't get memory. */\n\t\tdev->stats.rx_dropped++;\n\t\tdev_err(&lp->ndev->dev, \"Could not allocate receive buffer\\n\");\n\t\treturn;\n\t}\n\n\t/* A new skb should have the data halfword aligned, but this code is\n\t * here just in case that isn't true. Calculate how many\n\t * bytes we should reserve to get the data to start on a word\n\t * boundary\n\t */\n\talign = BUFFER_ALIGN(skb->data);\n\tif (align)\n\t\tskb_reserve(skb, align);\n\n\tskb_reserve(skb, 2);\n\n\tlen = xemaclite_recv_data(lp, (u8 *)skb->data, len);\n\n\tif (!len) {\n\t\tdev->stats.rx_errors++;\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, len);\t/* Tell the skb how much data we got */\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tskb_checksum_none_assert(skb);\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\tif (!skb_defer_rx_timestamp(skb))\n\t\tnetif_rx(skb);\t/* Send the packet upstream */\n}\n\n/**\n * xemaclite_interrupt - Interrupt handler for this driver\n * @irq:\tIrq of the Emaclite device\n * @dev_id:\tVoid pointer to the network device instance used as callback\n *\t\treference\n *\n * Return:\tIRQ_HANDLED\n *\n * This function handles the Tx and Rx interrupts of the EmacLite device.\n */\nstatic irqreturn_t xemaclite_interrupt(int irq, void *dev_id)\n{\n\tbool tx_complete = false;\n\tstruct net_device *dev = dev_id;\n\tstruct net_local *lp = netdev_priv(dev);\n\tvoid __iomem *base_addr = lp->base_addr;\n\tu32 tx_status;\n\n\t/* Check if there is Rx Data available */\n\tif ((xemaclite_readl(base_addr + XEL_RSR_OFFSET) &\n\t\t\t XEL_RSR_RECV_DONE_MASK) ||\n\t    (xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_RSR_OFFSET)\n\t\t\t & XEL_RSR_RECV_DONE_MASK))\n\n\t\txemaclite_rx_handler(dev);\n\n\t/* Check if the Transmission for the first buffer is completed */\n\ttx_status = xemaclite_readl(base_addr + XEL_TSR_OFFSET);\n\tif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\n\t\t(tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\n\n\t\ttx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\n\t\txemaclite_writel(tx_status, base_addr + XEL_TSR_OFFSET);\n\n\t\ttx_complete = true;\n\t}\n\n\t/* Check if the Transmission for the second buffer is completed */\n\ttx_status = xemaclite_readl(base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\tif (((tx_status & XEL_TSR_XMIT_BUSY_MASK) == 0) &&\n\t\t(tx_status & XEL_TSR_XMIT_ACTIVE_MASK) != 0) {\n\n\t\ttx_status &= ~XEL_TSR_XMIT_ACTIVE_MASK;\n\t\txemaclite_writel(tx_status, base_addr + XEL_BUFFER_OFFSET +\n\t\t\t\t XEL_TSR_OFFSET);\n\n\t\ttx_complete = true;\n\t}\n\n\t/* If there was a Tx interrupt, call the Tx Handler */\n\tif (tx_complete != 0)\n\t\txemaclite_tx_handler(dev);\n\n\treturn IRQ_HANDLED;\n}\n\n/**********************/\n/* MDIO Bus functions */\n/**********************/\n\n/**\n * xemaclite_mdio_wait - Wait for the MDIO to be ready to use\n * @lp:\t\tPointer to the Emaclite device private data\n *\n * This function waits till the device is ready to accept a new MDIO\n * request.\n *\n * Return:\t0 for success or ETIMEDOUT for a timeout\n */\n\nstatic int xemaclite_mdio_wait(struct net_local *lp)\n{\n\tu32 val;\n\n\t/* wait for the MDIO interface to not be busy or timeout\n\t * after some time.\n\t */\n\treturn readx_poll_timeout(xemaclite_readl,\n\t\t\t\t  lp->base_addr + XEL_MDIOCTRL_OFFSET,\n\t\t\t\t  val, !(val & XEL_MDIOCTRL_MDIOSTS_MASK),\n\t\t\t\t  1000, 20000);\n}\n\n/**\n * xemaclite_mdio_read - Read from a given MII management register\n * @bus:\tthe mii_bus struct\n * @phy_id:\tthe phy address\n * @reg:\tregister number to read from\n *\n * This function waits till the device is ready to accept a new MDIO\n * request and then writes the phy address to the MDIO Address register\n * and reads data from MDIO Read Data register, when its available.\n *\n * Return:\tValue read from the MII management register\n */\nstatic int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct net_local *lp = bus->priv;\n\tu32 ctrl_reg;\n\tu32 rc;\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\t/* Write the PHY address, register number and set the OP bit in the\n\t * MDIO Address register. Set the Status bit in the MDIO Control\n\t * register to start a MDIO read transaction.\n\t */\n\tctrl_reg = xemaclite_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\txemaclite_writel(XEL_MDIOADDR_OP_MASK |\n\t\t\t ((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\n\t\t\t lp->base_addr + XEL_MDIOADDR_OFFSET);\n\txemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\trc = xemaclite_readl(lp->base_addr + XEL_MDIORD_OFFSET);\n\n\tdev_dbg(&lp->ndev->dev,\n\t\t\"%s(phy_id=%i, reg=%x) == %x\\n\", __func__,\n\t\tphy_id, reg, rc);\n\n\treturn rc;\n}\n\n/**\n * xemaclite_mdio_write - Write to a given MII management register\n * @bus:\tthe mii_bus struct\n * @phy_id:\tthe phy address\n * @reg:\tregister number to write to\n * @val:\tvalue to write to the register number specified by reg\n *\n * This function waits till the device is ready to accept a new MDIO\n * request and then writes the val to the MDIO Write Data register.\n *\n * Return:      0 upon success or a negative error upon failure\n */\nstatic int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,\n\t\t\t\tu16 val)\n{\n\tstruct net_local *lp = bus->priv;\n\tu32 ctrl_reg;\n\n\tdev_dbg(&lp->ndev->dev,\n\t\t\"%s(phy_id=%i, reg=%x, val=%x)\\n\", __func__,\n\t\tphy_id, reg, val);\n\n\tif (xemaclite_mdio_wait(lp))\n\t\treturn -ETIMEDOUT;\n\n\t/* Write the PHY address, register number and clear the OP bit in the\n\t * MDIO Address register and then write the value into the MDIO Write\n\t * Data register. Finally, set the Status bit in the MDIO Control\n\t * register to start a MDIO write transaction.\n\t */\n\tctrl_reg = xemaclite_readl(lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\txemaclite_writel(~XEL_MDIOADDR_OP_MASK &\n\t\t\t ((phy_id << XEL_MDIOADDR_PHYADR_SHIFT) | reg),\n\t\t\t lp->base_addr + XEL_MDIOADDR_OFFSET);\n\txemaclite_writel(val, lp->base_addr + XEL_MDIOWR_OFFSET);\n\txemaclite_writel(ctrl_reg | XEL_MDIOCTRL_MDIOSTS_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\treturn 0;\n}\n\n/**\n * xemaclite_mdio_setup - Register mii_bus for the Emaclite device\n * @lp:\t\tPointer to the Emaclite device private data\n * @dev:\tPointer to OF device structure\n *\n * This function enables MDIO bus in the Emaclite device and registers a\n * mii_bus.\n *\n * Return:\t0 upon success or a negative error upon failure\n */\nstatic int xemaclite_mdio_setup(struct net_local *lp, struct device *dev)\n{\n\tstruct mii_bus *bus;\n\tint rc;\n\tstruct resource res;\n\tstruct device_node *np = of_get_parent(lp->phy_node);\n\tstruct device_node *npp;\n\n\t/* Don't register the MDIO bus if the phy_node or its parent node\n\t * can't be found.\n\t */\n\tif (!np) {\n\t\tdev_err(dev, \"Failed to register mdio bus.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tnpp = of_get_parent(np);\n\n\tof_address_to_resource(npp, 0, &res);\n\tif (lp->ndev->mem_start != res.start) {\n\t\tstruct phy_device *phydev;\n\t\tphydev = of_phy_find_device(lp->phy_node);\n\t\tif (!phydev)\n\t\t\tdev_info(dev,\n\t\t\t\t \"MDIO of the phy is not registered yet\\n\");\n\t\telse\n\t\t\tput_device(&phydev->mdio.dev);\n\t\treturn 0;\n\t}\n\n\t/* Enable the MDIO bus by asserting the enable bit in MDIO Control\n\t * register.\n\t */\n\txemaclite_writel(XEL_MDIOCTRL_MDIOEN_MASK,\n\t\t\t lp->base_addr + XEL_MDIOCTRL_OFFSET);\n\n\tbus = mdiobus_alloc();\n\tif (!bus) {\n\t\tdev_err(dev, \"Failed to allocate mdiobus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%.8llx\",\n\t\t (unsigned long long)res.start);\n\tbus->priv = lp;\n\tbus->name = \"Xilinx Emaclite MDIO\";\n\tbus->read = xemaclite_mdio_read;\n\tbus->write = xemaclite_mdio_write;\n\tbus->parent = dev;\n\n\trc = of_mdiobus_register(bus, np);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to register mdio bus.\\n\");\n\t\tgoto err_register;\n\t}\n\n\tlp->mii_bus = bus;\n\n\treturn 0;\n\nerr_register:\n\tmdiobus_free(bus);\n\treturn rc;\n}\n\n/**\n * xemaclite_adjust_link - Link state callback for the Emaclite device\n * @ndev: pointer to net_device struct\n *\n * There's nothing in the Emaclite device to be configured when the link\n * state changes. We just print the status.\n */\nstatic void xemaclite_adjust_link(struct net_device *ndev)\n{\n\tstruct net_local *lp = netdev_priv(ndev);\n\tstruct phy_device *phy = lp->phy_dev;\n\tint link_state;\n\n\t/* hash together the state values to decide if something has changed */\n\tlink_state = phy->speed | (phy->duplex << 1) | phy->link;\n\n\tif (lp->last_link != link_state) {\n\t\tlp->last_link = link_state;\n\t\tphy_print_status(phy);\n\t}\n}\n\n/**\n * xemaclite_open - Open the network device\n * @dev:\tPointer to the network device\n *\n * This function sets the MAC address, requests an IRQ and enables interrupts\n * for the Emaclite device and starts the Tx queue.\n * It also connects to the phy device, if MDIO is included in Emaclite device.\n *\n * Return:\t0 on success. -ENODEV, if PHY cannot be connected.\n *\t\tNon-zero error value on failure.\n */\nstatic int xemaclite_open(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint retval;\n\n\t/* Just to be safe, stop the device first */\n\txemaclite_disable_interrupts(lp);\n\n\tif (lp->phy_node) {\n\t\tu32 bmcr;\n\n\t\tlp->phy_dev = of_phy_connect(lp->ndev, lp->phy_node,\n\t\t\t\t\t     xemaclite_adjust_link, 0,\n\t\t\t\t\t     PHY_INTERFACE_MODE_MII);\n\t\tif (!lp->phy_dev) {\n\t\t\tdev_err(&lp->ndev->dev, \"of_phy_connect() failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* EmacLite doesn't support giga-bit speeds */\n\t\tphy_set_max_speed(lp->phy_dev, SPEED_100);\n\n\t\t/* Don't advertise 1000BASE-T Full/Half duplex speeds */\n\t\tphy_write(lp->phy_dev, MII_CTRL1000, 0);\n\n\t\t/* Advertise only 10 and 100mbps full/half duplex speeds */\n\t\tphy_write(lp->phy_dev, MII_ADVERTISE, ADVERTISE_ALL |\n\t\t\t  ADVERTISE_CSMA);\n\n\t\t/* Restart auto negotiation */\n\t\tbmcr = phy_read(lp->phy_dev, MII_BMCR);\n\t\tbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\t\tphy_write(lp->phy_dev, MII_BMCR, bmcr);\n\n\t\tphy_start(lp->phy_dev);\n\t}\n\n\t/* Set the MAC address each time opened */\n\txemaclite_update_address(lp, dev->dev_addr);\n\n\t/* Grab the IRQ */\n\tretval = request_irq(dev->irq, xemaclite_interrupt, 0, dev->name, dev);\n\tif (retval) {\n\t\tdev_err(&lp->ndev->dev, \"Could not allocate interrupt %d\\n\",\n\t\t\tdev->irq);\n\t\tif (lp->phy_dev)\n\t\t\tphy_disconnect(lp->phy_dev);\n\t\tlp->phy_dev = NULL;\n\n\t\treturn retval;\n\t}\n\n\t/* Enable Interrupts */\n\txemaclite_enable_interrupts(lp);\n\n\t/* We're ready to go */\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n/**\n * xemaclite_close - Close the network device\n * @dev:\tPointer to the network device\n *\n * This function stops the Tx queue, disables interrupts and frees the IRQ for\n * the Emaclite device.\n * It also disconnects the phy device associated with the Emaclite device.\n *\n * Return:\t0, always.\n */\nstatic int xemaclite_close(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\txemaclite_disable_interrupts(lp);\n\tfree_irq(dev->irq, dev);\n\n\tif (lp->phy_dev)\n\t\tphy_disconnect(lp->phy_dev);\n\tlp->phy_dev = NULL;\n\n\treturn 0;\n}\n\n/**\n * xemaclite_send - Transmit a frame\n * @orig_skb:\tPointer to the socket buffer to be transmitted\n * @dev:\tPointer to the network device\n *\n * This function checks if the Tx buffer of the Emaclite device is free to send\n * data. If so, it fills the Tx buffer with data from socket buffer data,\n * updates the stats and frees the socket buffer. The Tx completion is signaled\n * by an interrupt. If the Tx buffer isn't free, then the socket buffer is\n * deferred and the Tx queue is stopped so that the deferred socket buffer can\n * be transmitted when the Emaclite device is free to transmit data.\n *\n * Return:\tNETDEV_TX_OK, always.\n */\nstatic netdev_tx_t\nxemaclite_send(struct sk_buff *orig_skb, struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *new_skb;\n\tunsigned int len;\n\tunsigned long flags;\n\n\tlen = orig_skb->len;\n\n\tnew_skb = orig_skb;\n\n\tspin_lock_irqsave(&lp->reset_lock, flags);\n\tif (xemaclite_send_data(lp, (u8 *)new_skb->data, len) != 0) {\n\t\t/* If the Emaclite Tx buffer is busy, stop the Tx queue and\n\t\t * defer the skb for transmission during the ISR, after the\n\t\t * current transmission is complete\n\t\t */\n\t\tnetif_stop_queue(dev);\n\t\tlp->deferred_skb = new_skb;\n\t\t/* Take the time stamp now, since we can't do this in an ISR. */\n\t\tskb_tx_timestamp(new_skb);\n\t\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tspin_unlock_irqrestore(&lp->reset_lock, flags);\n\n\tskb_tx_timestamp(new_skb);\n\n\tdev->stats.tx_bytes += len;\n\tdev_consume_skb_any(new_skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n/**\n * get_bool - Get a parameter from the OF device\n * @ofdev:\tPointer to OF device structure\n * @s:\t\tProperty to be retrieved\n *\n * This function looks for a property in the device node and returns the value\n * of the property if its found or 0 if the property is not found.\n *\n * Return:\tValue of the parameter if the parameter is found, or 0 otherwise\n */\nstatic bool get_bool(struct platform_device *ofdev, const char *s)\n{\n\tu32 *p = (u32 *)of_get_property(ofdev->dev.of_node, s, NULL);\n\n\tif (!p) {\n\t\tdev_warn(&ofdev->dev, \"Parameter %s not found, defaulting to false\\n\", s);\n\t\treturn false;\n\t}\n\n\treturn (bool)*p;\n}\n\n/**\n * xemaclite_ethtools_get_drvinfo - Get various Axi Emac Lite driver info\n * @ndev:       Pointer to net_device structure\n * @ed:         Pointer to ethtool_drvinfo structure\n *\n * This implements ethtool command for getting the driver information.\n * Issue \"ethtool -i ethX\" under linux prompt to execute this function.\n */\nstatic void xemaclite_ethtools_get_drvinfo(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_drvinfo *ed)\n{\n\tstrlcpy(ed->driver, DRIVER_NAME, sizeof(ed->driver));\n}\n\nstatic const struct ethtool_ops xemaclite_ethtool_ops = {\n\t.get_drvinfo    = xemaclite_ethtools_get_drvinfo,\n\t.get_link       = ethtool_op_get_link,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops xemaclite_netdev_ops;\n\n/**\n * xemaclite_of_probe - Probe method for the Emaclite device.\n * @ofdev:\tPointer to OF device structure\n *\n * This function probes for the Emaclite device in the device tree.\n * It initializes the driver data structure and the hardware, sets the MAC\n * address and registers the network device.\n * It also registers a mii_bus for the Emaclite device, if MDIO is included\n * in the device.\n *\n * Return:\t0, if the driver is bound to the Emaclite device, or\n *\t\ta negative error if there is failure.\n */\nstatic int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start, lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}\n\n/**\n * xemaclite_of_remove - Unbind the driver from the Emaclite device.\n * @of_dev:\tPointer to OF device structure\n *\n * This function is called if a device is physically removed from the system or\n * if the driver module is being unloaded. It frees any resources allocated to\n * the device.\n *\n * Return:\t0, always.\n */\nstatic int xemaclite_of_remove(struct platform_device *of_dev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(of_dev);\n\n\tstruct net_local *lp = netdev_priv(ndev);\n\n\t/* Un-register the mii_bus, if configured */\n\tif (lp->mii_bus) {\n\t\tmdiobus_unregister(lp->mii_bus);\n\t\tmdiobus_free(lp->mii_bus);\n\t\tlp->mii_bus = NULL;\n\t}\n\n\tunregister_netdev(ndev);\n\n\tof_node_put(lp->phy_node);\n\tlp->phy_node = NULL;\n\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void\nxemaclite_poll_controller(struct net_device *ndev)\n{\n\tdisable_irq(ndev->irq);\n\txemaclite_interrupt(ndev->irq, ndev);\n\tenable_irq(ndev->irq);\n}\n#endif\n\n/* Ioctl MII Interface */\nstatic int xemaclite_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tif (!dev->phydev || !netif_running(dev))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn phy_mii_ioctl(dev->phydev, rq, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops xemaclite_netdev_ops = {\n\t.ndo_open\t\t= xemaclite_open,\n\t.ndo_stop\t\t= xemaclite_close,\n\t.ndo_start_xmit\t\t= xemaclite_send,\n\t.ndo_set_mac_address\t= xemaclite_set_mac_address,\n\t.ndo_tx_timeout\t\t= xemaclite_tx_timeout,\n\t.ndo_do_ioctl\t\t= xemaclite_ioctl,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = xemaclite_poll_controller,\n#endif\n};\n\n/* Match table for OF platform binding */\nstatic const struct of_device_id xemaclite_of_match[] = {\n\t{ .compatible = \"xlnx,opb-ethernetlite-1.01.a\", },\n\t{ .compatible = \"xlnx,opb-ethernetlite-1.01.b\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-1.00.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-2.00.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-2.01.a\", },\n\t{ .compatible = \"xlnx,xps-ethernetlite-3.00.a\", },\n\t{ /* end of list */ },\n};\nMODULE_DEVICE_TABLE(of, xemaclite_of_match);\n\nstatic struct platform_driver xemaclite_of_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = xemaclite_of_match,\n\t},\n\t.probe\t\t= xemaclite_of_probe,\n\t.remove\t\t= xemaclite_of_remove,\n};\n\nmodule_platform_driver(xemaclite_of_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"Xilinx Ethernet MAC Lite driver\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/net/ethernet/xilinx/xilinx_emaclite.c"], "buggy_code_start_loc": [1192], "buggy_code_end_loc": [1195], "fixing_code_start_loc": [1192], "fixing_code_end_loc": [1194], "type": "CWE-824", "message": "drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).", "other": {"cve": {"id": "CVE-2021-38205", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.283", "lastModified": "2022-01-04T16:38:48.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer)."}, {"lang": "es", "value": "El archivo drivers/net/ethernet/xilinx/xilinx_emaclite.c en el kernel de Linux versiones anteriores a 5.13.3, facilita a atacantes derrotar un mecanismo de protecci\u00f3n ASLR porque imprime un puntero del kernel (es decir, el puntero real de IOMEM)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.13.3", "matchCriteriaId": "DD89F539-A702-48B0-BFD3-7AC4E4A0A41C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d0d62baa7f505bd4c59cd169692ff07ec49dde37", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/10/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d0d62baa7f505bd4c59cd169692ff07ec49dde37"}}