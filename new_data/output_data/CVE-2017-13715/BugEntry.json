{"buggy_code": ["#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/if_vlan.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/igmp.h>\n#include <linux/icmp.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/if_tunnel.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/stddef.h>\n#include <linux/if_ether.h>\n#include <linux/mpls.h>\n#include <net/flow_dissector.h>\n#include <scsi/fc/fc_fcoe.h>\n\nstatic bool skb_flow_dissector_uses_key(struct flow_dissector *flow_dissector,\n\t\t\t\t\tenum flow_dissector_key_id key_id)\n{\n\treturn flow_dissector->used_keys & (1 << key_id);\n}\n\nstatic void skb_flow_dissector_set_key(struct flow_dissector *flow_dissector,\n\t\t\t\t       enum flow_dissector_key_id key_id)\n{\n\tflow_dissector->used_keys |= (1 << key_id);\n}\n\nstatic void *skb_flow_dissector_target(struct flow_dissector *flow_dissector,\n\t\t\t\t       enum flow_dissector_key_id key_id,\n\t\t\t\t       void *target_container)\n{\n\treturn ((char *) target_container) + flow_dissector->offset[key_id];\n}\n\nvoid skb_flow_dissector_init(struct flow_dissector *flow_dissector,\n\t\t\t     const struct flow_dissector_key *key,\n\t\t\t     unsigned int key_count)\n{\n\tunsigned int i;\n\n\tmemset(flow_dissector, 0, sizeof(*flow_dissector));\n\n\tfor (i = 0; i < key_count; i++, key++) {\n\t\t/* User should make sure that every key target offset is withing\n\t\t * boundaries of unsigned short.\n\t\t */\n\t\tBUG_ON(key->offset > USHRT_MAX);\n\t\tBUG_ON(skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t   key->key_id));\n\n\t\tskb_flow_dissector_set_key(flow_dissector, key->key_id);\n\t\tflow_dissector->offset[key->key_id] = key->offset;\n\t}\n\n\t/* Ensure that the dissector always includes control and basic key.\n\t * That way we are able to avoid handling lack of these in fast path.\n\t */\n\tBUG_ON(!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_CONTROL));\n\tBUG_ON(!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_BASIC));\n}\nEXPORT_SYMBOL(skb_flow_dissector_init);\n\n/**\n * __skb_flow_get_ports - extract the upper layer ports and return them\n * @skb: sk_buff to extract the ports from\n * @thoff: transport header offset\n * @ip_proto: protocol for which to get port offset\n * @data: raw buffer pointer to the packet, if NULL use skb->data\n * @hlen: packet header length, if @data is NULL use skb_headlen(skb)\n *\n * The function will try to retrieve the ports at offset thoff + poff where poff\n * is the protocol port offset returned from proto_ports_offset\n */\n__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,\n\t\t\t    void *data, int hlen)\n{\n\tint poff = proto_ports_offset(ip_proto);\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\thlen = skb_headlen(skb);\n\t}\n\n\tif (poff >= 0) {\n\t\t__be32 *ports, _ports;\n\n\t\tports = __skb_header_pointer(skb, thoff + poff,\n\t\t\t\t\t     sizeof(_ports), data, hlen, &_ports);\n\t\tif (ports)\n\t\t\treturn *ports;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__skb_flow_get_ports);\n\n/**\n * __skb_flow_dissect - extract the flow_keys struct and return it\n * @skb: sk_buff to extract the flow from, can be NULL if the rest are specified\n * @flow_dissector: list of keys to dissect\n * @target_container: target structure to put dissected values into\n * @data: raw buffer pointer to the packet, if NULL use skb->data\n * @proto: protocol for which to get the flow, if @data is NULL use skb->protocol\n * @nhoff: network header offset, if @data is NULL use skb_network_offset(skb)\n * @hlen: packet header length, if @data is NULL use skb_headlen(skb)\n *\n * The function will try to retrieve individual keys into target specified\n * by flow_dissector from either the skbuff or a raw buffer specified by the\n * rest parameters.\n *\n * Caller must take care of zeroing target container memory.\n */\nbool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tkey_basic->n_proto = proto;\n\t\tkey_control->thoff = (u16)nhoff;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tkey_basic->n_proto = proto;\n\t\t\tkey_basic->ip_proto = ip_proto;\n\t\t\tkey_control->thoff = (u16)nhoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\treturn false;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn false;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\treturn false;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(__skb_flow_dissect);\n\nstatic u32 hashrnd __read_mostly;\nstatic __always_inline void __flow_hash_secret_init(void)\n{\n\tnet_get_random_once(&hashrnd, sizeof(hashrnd));\n}\n\nstatic __always_inline u32 __flow_hash_words(u32 *words, u32 length, u32 keyval)\n{\n\treturn jhash2(words, length, keyval);\n}\n\nstatic inline void *flow_keys_hash_start(struct flow_keys *flow)\n{\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\n\treturn (void *)flow + FLOW_KEYS_HASH_OFFSET;\n}\n\nstatic inline size_t flow_keys_hash_length(struct flow_keys *flow)\n{\n\tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n\tBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\n\t\t     sizeof(*flow) - sizeof(flow->addrs));\n\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v4addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v6addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_TIPC_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.tipcaddrs);\n\t\tbreak;\n\t}\n\treturn (sizeof(*flow) - diff) / sizeof(u32);\n}\n\n__be32 flow_get_u32_src(const struct flow_keys *flow)\n{\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\treturn flow->addrs.v4addrs.src;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\treturn (__force __be32)ipv6_addr_hash(\n\t\t\t&flow->addrs.v6addrs.src);\n\tcase FLOW_DISSECTOR_KEY_TIPC_ADDRS:\n\t\treturn flow->addrs.tipcaddrs.srcnode;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(flow_get_u32_src);\n\n__be32 flow_get_u32_dst(const struct flow_keys *flow)\n{\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\treturn flow->addrs.v4addrs.dst;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\treturn (__force __be32)ipv6_addr_hash(\n\t\t\t&flow->addrs.v6addrs.dst);\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(flow_get_u32_dst);\n\nstatic inline void __flow_hash_consistentify(struct flow_keys *keys)\n{\n\tint addr_diff, i;\n\n\tswitch (keys->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\taddr_diff = (__force u32)keys->addrs.v4addrs.dst -\n\t\t\t    (__force u32)keys->addrs.v4addrs.src;\n\t\tif ((addr_diff < 0) ||\n\t\t    (addr_diff == 0 &&\n\t\t     ((__force u16)keys->ports.dst <\n\t\t      (__force u16)keys->ports.src))) {\n\t\t\tswap(keys->addrs.v4addrs.src, keys->addrs.v4addrs.dst);\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\taddr_diff = memcmp(&keys->addrs.v6addrs.dst,\n\t\t\t\t   &keys->addrs.v6addrs.src,\n\t\t\t\t   sizeof(keys->addrs.v6addrs.dst));\n\t\tif ((addr_diff < 0) ||\n\t\t    (addr_diff == 0 &&\n\t\t     ((__force u16)keys->ports.dst <\n\t\t      (__force u16)keys->ports.src))) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tswap(keys->addrs.v6addrs.src.s6_addr32[i],\n\t\t\t\t     keys->addrs.v6addrs.dst.s6_addr32[i]);\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = __flow_hash_words((u32 *)flow_keys_hash_start(keys),\n\t\t\t\t flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}\n\nu32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, hashrnd);\n}\nEXPORT_SYMBOL(flow_hash_from_keys);\n\nstatic inline u32 ___skb_get_hash(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys, u32 keyval)\n{\n\tif (!skb_flow_dissect_flow_keys(skb, keys))\n\t\treturn 0;\n\n\treturn __flow_hash_from_keys(keys, keyval);\n}\n\nstruct _flow_keys_digest_data {\n\t__be16\tn_proto;\n\tu8\tip_proto;\n\tu8\tpadding;\n\t__be32\tports;\n\t__be32\tsrc;\n\t__be32\tdst;\n};\n\nvoid make_flow_keys_digest(struct flow_keys_digest *digest,\n\t\t\t   const struct flow_keys *flow)\n{\n\tstruct _flow_keys_digest_data *data =\n\t    (struct _flow_keys_digest_data *)digest;\n\n\tBUILD_BUG_ON(sizeof(*data) > sizeof(*digest));\n\n\tmemset(digest, 0, sizeof(*digest));\n\n\tdata->n_proto = flow->basic.n_proto;\n\tdata->ip_proto = flow->basic.ip_proto;\n\tdata->ports = flow->ports.ports;\n\tdata->src = flow->addrs.v4addrs.src;\n\tdata->dst = flow->addrs.v4addrs.dst;\n}\nEXPORT_SYMBOL(make_flow_keys_digest);\n\n/**\n * __skb_get_hash: calculate a flow hash\n * @skb: sk_buff to calculate flow hash from\n *\n * This function calculates a flow hash based on src/dst addresses\n * and src/dst port numbers.  Sets hash in skb to non-zero hash value\n * on success, zero indicates no valid hash.  Also, sets l4_hash in skb\n * if hash is a canonical 4-tuple hash over transport ports.\n */\nvoid __skb_get_hash(struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\tu32 hash;\n\n\t__flow_hash_secret_init();\n\n\thash = ___skb_get_hash(skb, &keys, hashrnd);\n\tif (!hash)\n\t\treturn;\n\n\t__skb_set_sw_hash(skb, hash,\n\t\t\t  flow_keys_have_l4(&keys));\n}\nEXPORT_SYMBOL(__skb_get_hash);\n\n__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)\n{\n\tstruct flow_keys keys;\n\n\treturn ___skb_get_hash(skb, &keys, perturb);\n}\nEXPORT_SYMBOL(skb_get_hash_perturb);\n\n__u32 __skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6)\n{\n\tstruct flow_keys keys;\n\n\tmemset(&keys, 0, sizeof(keys));\n\n\tmemcpy(&keys.addrs.v6addrs.src, &fl6->saddr,\n\t       sizeof(keys.addrs.v6addrs.src));\n\tmemcpy(&keys.addrs.v6addrs.dst, &fl6->daddr,\n\t       sizeof(keys.addrs.v6addrs.dst));\n\tkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tkeys.ports.src = fl6->fl6_sport;\n\tkeys.ports.dst = fl6->fl6_dport;\n\tkeys.keyid.keyid = fl6->fl6_gre_key;\n\tkeys.tags.flow_label = (__force u32)fl6->flowlabel;\n\tkeys.basic.ip_proto = fl6->flowi6_proto;\n\n\t__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\n\t\t\t  flow_keys_have_l4(&keys));\n\n\treturn skb->hash;\n}\nEXPORT_SYMBOL(__skb_get_hash_flowi6);\n\n__u32 __skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl4)\n{\n\tstruct flow_keys keys;\n\n\tmemset(&keys, 0, sizeof(keys));\n\n\tkeys.addrs.v4addrs.src = fl4->saddr;\n\tkeys.addrs.v4addrs.dst = fl4->daddr;\n\tkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\tkeys.ports.src = fl4->fl4_sport;\n\tkeys.ports.dst = fl4->fl4_dport;\n\tkeys.keyid.keyid = fl4->fl4_gre_key;\n\tkeys.basic.ip_proto = fl4->flowi4_proto;\n\n\t__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\n\t\t\t  flow_keys_have_l4(&keys));\n\n\treturn skb->hash;\n}\nEXPORT_SYMBOL(__skb_get_hash_flowi4);\n\nu32 __skb_get_poff(const struct sk_buff *skb, void *data,\n\t\t   const struct flow_keys *keys, int hlen)\n{\n\tu32 poff = keys->control.thoff;\n\n\tswitch (keys->basic.ip_proto) {\n\tcase IPPROTO_TCP: {\n\t\t/* access doff as u8 to avoid unaligned access */\n\t\tconst u8 *doff;\n\t\tu8 _doff;\n\n\t\tdoff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),\n\t\t\t\t\t    data, hlen, &_doff);\n\t\tif (!doff)\n\t\t\treturn poff;\n\n\t\tpoff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tpoff += sizeof(struct udphdr);\n\t\tbreak;\n\t/* For the rest, we do not really care about header\n\t * extensions at this point for now.\n\t */\n\tcase IPPROTO_ICMP:\n\t\tpoff += sizeof(struct icmphdr);\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\tpoff += sizeof(struct icmp6hdr);\n\t\tbreak;\n\tcase IPPROTO_IGMP:\n\t\tpoff += sizeof(struct igmphdr);\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tpoff += sizeof(struct dccp_hdr);\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\tpoff += sizeof(struct sctphdr);\n\t\tbreak;\n\t}\n\n\treturn poff;\n}\n\n/**\n * skb_get_poff - get the offset to the payload\n * @skb: sk_buff to get the payload offset from\n *\n * The function will get the offset to the payload as far as it could\n * be dissected.  The main user is currently BPF, so that we can dynamically\n * truncate packets without needing to push actual payload to the user\n * space and can analyze headers only, instead.\n */\nu32 skb_get_poff(const struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\n\tif (!skb_flow_dissect_flow_keys(skb, &keys))\n\t\treturn 0;\n\n\treturn __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));\n}\n\nstatic const struct flow_dissector_key flow_keys_dissector_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v4addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v6addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.tipcaddrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_PORTS,\n\t\t.offset = offsetof(struct flow_keys, ports),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_VLANID,\n\t\t.offset = offsetof(struct flow_keys, tags),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t.offset = offsetof(struct flow_keys, tags),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t.offset = offsetof(struct flow_keys, keyid),\n\t},\n};\n\nstatic const struct flow_dissector_key flow_keys_buf_dissector_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n};\n\nstruct flow_dissector flow_keys_dissector __read_mostly;\nEXPORT_SYMBOL(flow_keys_dissector);\n\nstruct flow_dissector flow_keys_buf_dissector __read_mostly;\n\nstatic int __init init_default_flow_dissectors(void)\n{\n\tskb_flow_dissector_init(&flow_keys_dissector,\n\t\t\t\tflow_keys_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_keys));\n\tskb_flow_dissector_init(&flow_keys_buf_dissector,\n\t\t\t\tflow_keys_buf_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_buf_dissector_keys));\n\treturn 0;\n}\n\nlate_initcall_sync(init_default_flow_dissectors);\n"], "fixing_code": ["#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/if_vlan.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/igmp.h>\n#include <linux/icmp.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/if_tunnel.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/stddef.h>\n#include <linux/if_ether.h>\n#include <linux/mpls.h>\n#include <net/flow_dissector.h>\n#include <scsi/fc/fc_fcoe.h>\n\nstatic bool skb_flow_dissector_uses_key(struct flow_dissector *flow_dissector,\n\t\t\t\t\tenum flow_dissector_key_id key_id)\n{\n\treturn flow_dissector->used_keys & (1 << key_id);\n}\n\nstatic void skb_flow_dissector_set_key(struct flow_dissector *flow_dissector,\n\t\t\t\t       enum flow_dissector_key_id key_id)\n{\n\tflow_dissector->used_keys |= (1 << key_id);\n}\n\nstatic void *skb_flow_dissector_target(struct flow_dissector *flow_dissector,\n\t\t\t\t       enum flow_dissector_key_id key_id,\n\t\t\t\t       void *target_container)\n{\n\treturn ((char *) target_container) + flow_dissector->offset[key_id];\n}\n\nvoid skb_flow_dissector_init(struct flow_dissector *flow_dissector,\n\t\t\t     const struct flow_dissector_key *key,\n\t\t\t     unsigned int key_count)\n{\n\tunsigned int i;\n\n\tmemset(flow_dissector, 0, sizeof(*flow_dissector));\n\n\tfor (i = 0; i < key_count; i++, key++) {\n\t\t/* User should make sure that every key target offset is withing\n\t\t * boundaries of unsigned short.\n\t\t */\n\t\tBUG_ON(key->offset > USHRT_MAX);\n\t\tBUG_ON(skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t   key->key_id));\n\n\t\tskb_flow_dissector_set_key(flow_dissector, key->key_id);\n\t\tflow_dissector->offset[key->key_id] = key->offset;\n\t}\n\n\t/* Ensure that the dissector always includes control and basic key.\n\t * That way we are able to avoid handling lack of these in fast path.\n\t */\n\tBUG_ON(!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_CONTROL));\n\tBUG_ON(!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t    FLOW_DISSECTOR_KEY_BASIC));\n}\nEXPORT_SYMBOL(skb_flow_dissector_init);\n\n/**\n * __skb_flow_get_ports - extract the upper layer ports and return them\n * @skb: sk_buff to extract the ports from\n * @thoff: transport header offset\n * @ip_proto: protocol for which to get port offset\n * @data: raw buffer pointer to the packet, if NULL use skb->data\n * @hlen: packet header length, if @data is NULL use skb_headlen(skb)\n *\n * The function will try to retrieve the ports at offset thoff + poff where poff\n * is the protocol port offset returned from proto_ports_offset\n */\n__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,\n\t\t\t    void *data, int hlen)\n{\n\tint poff = proto_ports_offset(ip_proto);\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\thlen = skb_headlen(skb);\n\t}\n\n\tif (poff >= 0) {\n\t\t__be32 *ports, _ports;\n\n\t\tports = __skb_header_pointer(skb, thoff + poff,\n\t\t\t\t\t     sizeof(_ports), data, hlen, &_ports);\n\t\tif (ports)\n\t\t\treturn *ports;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__skb_flow_get_ports);\n\n/**\n * __skb_flow_dissect - extract the flow_keys struct and return it\n * @skb: sk_buff to extract the flow from, can be NULL if the rest are specified\n * @flow_dissector: list of keys to dissect\n * @target_container: target structure to put dissected values into\n * @data: raw buffer pointer to the packet, if NULL use skb->data\n * @proto: protocol for which to get the flow, if @data is NULL use skb->protocol\n * @nhoff: network header offset, if @data is NULL use skb_network_offset(skb)\n * @hlen: packet header length, if @data is NULL use skb_headlen(skb)\n *\n * The function will try to retrieve individual keys into target specified\n * by flow_dissector from either the skbuff or a raw buffer specified by the\n * rest parameters.\n *\n * Caller must take care of zeroing target container memory.\n */\nbool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\tbool ret = false;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\tgoto out_bad;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\tgoto out_bad;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tgoto out_good;\n\t\t}\n\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\tgoto out_bad;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\tgoto out_bad;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\nout_good:\n\tret = true;\n\nout_bad:\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__skb_flow_dissect);\n\nstatic u32 hashrnd __read_mostly;\nstatic __always_inline void __flow_hash_secret_init(void)\n{\n\tnet_get_random_once(&hashrnd, sizeof(hashrnd));\n}\n\nstatic __always_inline u32 __flow_hash_words(u32 *words, u32 length, u32 keyval)\n{\n\treturn jhash2(words, length, keyval);\n}\n\nstatic inline void *flow_keys_hash_start(struct flow_keys *flow)\n{\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\n\treturn (void *)flow + FLOW_KEYS_HASH_OFFSET;\n}\n\nstatic inline size_t flow_keys_hash_length(struct flow_keys *flow)\n{\n\tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n\tBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\n\t\t     sizeof(*flow) - sizeof(flow->addrs));\n\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v4addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v6addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_TIPC_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.tipcaddrs);\n\t\tbreak;\n\t}\n\treturn (sizeof(*flow) - diff) / sizeof(u32);\n}\n\n__be32 flow_get_u32_src(const struct flow_keys *flow)\n{\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\treturn flow->addrs.v4addrs.src;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\treturn (__force __be32)ipv6_addr_hash(\n\t\t\t&flow->addrs.v6addrs.src);\n\tcase FLOW_DISSECTOR_KEY_TIPC_ADDRS:\n\t\treturn flow->addrs.tipcaddrs.srcnode;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(flow_get_u32_src);\n\n__be32 flow_get_u32_dst(const struct flow_keys *flow)\n{\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\treturn flow->addrs.v4addrs.dst;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\treturn (__force __be32)ipv6_addr_hash(\n\t\t\t&flow->addrs.v6addrs.dst);\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(flow_get_u32_dst);\n\nstatic inline void __flow_hash_consistentify(struct flow_keys *keys)\n{\n\tint addr_diff, i;\n\n\tswitch (keys->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\taddr_diff = (__force u32)keys->addrs.v4addrs.dst -\n\t\t\t    (__force u32)keys->addrs.v4addrs.src;\n\t\tif ((addr_diff < 0) ||\n\t\t    (addr_diff == 0 &&\n\t\t     ((__force u16)keys->ports.dst <\n\t\t      (__force u16)keys->ports.src))) {\n\t\t\tswap(keys->addrs.v4addrs.src, keys->addrs.v4addrs.dst);\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\taddr_diff = memcmp(&keys->addrs.v6addrs.dst,\n\t\t\t\t   &keys->addrs.v6addrs.src,\n\t\t\t\t   sizeof(keys->addrs.v6addrs.dst));\n\t\tif ((addr_diff < 0) ||\n\t\t    (addr_diff == 0 &&\n\t\t     ((__force u16)keys->ports.dst <\n\t\t      (__force u16)keys->ports.src))) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tswap(keys->addrs.v6addrs.src.s6_addr32[i],\n\t\t\t\t     keys->addrs.v6addrs.dst.s6_addr32[i]);\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = __flow_hash_words((u32 *)flow_keys_hash_start(keys),\n\t\t\t\t flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}\n\nu32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, hashrnd);\n}\nEXPORT_SYMBOL(flow_hash_from_keys);\n\nstatic inline u32 ___skb_get_hash(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys, u32 keyval)\n{\n\tif (!skb_flow_dissect_flow_keys(skb, keys))\n\t\treturn 0;\n\n\treturn __flow_hash_from_keys(keys, keyval);\n}\n\nstruct _flow_keys_digest_data {\n\t__be16\tn_proto;\n\tu8\tip_proto;\n\tu8\tpadding;\n\t__be32\tports;\n\t__be32\tsrc;\n\t__be32\tdst;\n};\n\nvoid make_flow_keys_digest(struct flow_keys_digest *digest,\n\t\t\t   const struct flow_keys *flow)\n{\n\tstruct _flow_keys_digest_data *data =\n\t    (struct _flow_keys_digest_data *)digest;\n\n\tBUILD_BUG_ON(sizeof(*data) > sizeof(*digest));\n\n\tmemset(digest, 0, sizeof(*digest));\n\n\tdata->n_proto = flow->basic.n_proto;\n\tdata->ip_proto = flow->basic.ip_proto;\n\tdata->ports = flow->ports.ports;\n\tdata->src = flow->addrs.v4addrs.src;\n\tdata->dst = flow->addrs.v4addrs.dst;\n}\nEXPORT_SYMBOL(make_flow_keys_digest);\n\n/**\n * __skb_get_hash: calculate a flow hash\n * @skb: sk_buff to calculate flow hash from\n *\n * This function calculates a flow hash based on src/dst addresses\n * and src/dst port numbers.  Sets hash in skb to non-zero hash value\n * on success, zero indicates no valid hash.  Also, sets l4_hash in skb\n * if hash is a canonical 4-tuple hash over transport ports.\n */\nvoid __skb_get_hash(struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\tu32 hash;\n\n\t__flow_hash_secret_init();\n\n\thash = ___skb_get_hash(skb, &keys, hashrnd);\n\tif (!hash)\n\t\treturn;\n\n\t__skb_set_sw_hash(skb, hash,\n\t\t\t  flow_keys_have_l4(&keys));\n}\nEXPORT_SYMBOL(__skb_get_hash);\n\n__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)\n{\n\tstruct flow_keys keys;\n\n\treturn ___skb_get_hash(skb, &keys, perturb);\n}\nEXPORT_SYMBOL(skb_get_hash_perturb);\n\n__u32 __skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6)\n{\n\tstruct flow_keys keys;\n\n\tmemset(&keys, 0, sizeof(keys));\n\n\tmemcpy(&keys.addrs.v6addrs.src, &fl6->saddr,\n\t       sizeof(keys.addrs.v6addrs.src));\n\tmemcpy(&keys.addrs.v6addrs.dst, &fl6->daddr,\n\t       sizeof(keys.addrs.v6addrs.dst));\n\tkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tkeys.ports.src = fl6->fl6_sport;\n\tkeys.ports.dst = fl6->fl6_dport;\n\tkeys.keyid.keyid = fl6->fl6_gre_key;\n\tkeys.tags.flow_label = (__force u32)fl6->flowlabel;\n\tkeys.basic.ip_proto = fl6->flowi6_proto;\n\n\t__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\n\t\t\t  flow_keys_have_l4(&keys));\n\n\treturn skb->hash;\n}\nEXPORT_SYMBOL(__skb_get_hash_flowi6);\n\n__u32 __skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl4)\n{\n\tstruct flow_keys keys;\n\n\tmemset(&keys, 0, sizeof(keys));\n\n\tkeys.addrs.v4addrs.src = fl4->saddr;\n\tkeys.addrs.v4addrs.dst = fl4->daddr;\n\tkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\tkeys.ports.src = fl4->fl4_sport;\n\tkeys.ports.dst = fl4->fl4_dport;\n\tkeys.keyid.keyid = fl4->fl4_gre_key;\n\tkeys.basic.ip_proto = fl4->flowi4_proto;\n\n\t__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\n\t\t\t  flow_keys_have_l4(&keys));\n\n\treturn skb->hash;\n}\nEXPORT_SYMBOL(__skb_get_hash_flowi4);\n\nu32 __skb_get_poff(const struct sk_buff *skb, void *data,\n\t\t   const struct flow_keys *keys, int hlen)\n{\n\tu32 poff = keys->control.thoff;\n\n\tswitch (keys->basic.ip_proto) {\n\tcase IPPROTO_TCP: {\n\t\t/* access doff as u8 to avoid unaligned access */\n\t\tconst u8 *doff;\n\t\tu8 _doff;\n\n\t\tdoff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),\n\t\t\t\t\t    data, hlen, &_doff);\n\t\tif (!doff)\n\t\t\treturn poff;\n\n\t\tpoff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_UDPLITE:\n\t\tpoff += sizeof(struct udphdr);\n\t\tbreak;\n\t/* For the rest, we do not really care about header\n\t * extensions at this point for now.\n\t */\n\tcase IPPROTO_ICMP:\n\t\tpoff += sizeof(struct icmphdr);\n\t\tbreak;\n\tcase IPPROTO_ICMPV6:\n\t\tpoff += sizeof(struct icmp6hdr);\n\t\tbreak;\n\tcase IPPROTO_IGMP:\n\t\tpoff += sizeof(struct igmphdr);\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tpoff += sizeof(struct dccp_hdr);\n\t\tbreak;\n\tcase IPPROTO_SCTP:\n\t\tpoff += sizeof(struct sctphdr);\n\t\tbreak;\n\t}\n\n\treturn poff;\n}\n\n/**\n * skb_get_poff - get the offset to the payload\n * @skb: sk_buff to get the payload offset from\n *\n * The function will get the offset to the payload as far as it could\n * be dissected.  The main user is currently BPF, so that we can dynamically\n * truncate packets without needing to push actual payload to the user\n * space and can analyze headers only, instead.\n */\nu32 skb_get_poff(const struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\n\tif (!skb_flow_dissect_flow_keys(skb, &keys))\n\t\treturn 0;\n\n\treturn __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));\n}\n\nstatic const struct flow_dissector_key flow_keys_dissector_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v4addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.v6addrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t.offset = offsetof(struct flow_keys, addrs.tipcaddrs),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_PORTS,\n\t\t.offset = offsetof(struct flow_keys, ports),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_VLANID,\n\t\t.offset = offsetof(struct flow_keys, tags),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t.offset = offsetof(struct flow_keys, tags),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t.offset = offsetof(struct flow_keys, keyid),\n\t},\n};\n\nstatic const struct flow_dissector_key flow_keys_buf_dissector_keys[] = {\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_CONTROL,\n\t\t.offset = offsetof(struct flow_keys, control),\n\t},\n\t{\n\t\t.key_id = FLOW_DISSECTOR_KEY_BASIC,\n\t\t.offset = offsetof(struct flow_keys, basic),\n\t},\n};\n\nstruct flow_dissector flow_keys_dissector __read_mostly;\nEXPORT_SYMBOL(flow_keys_dissector);\n\nstruct flow_dissector flow_keys_buf_dissector __read_mostly;\n\nstatic int __init init_default_flow_dissectors(void)\n{\n\tskb_flow_dissector_init(&flow_keys_dissector,\n\t\t\t\tflow_keys_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_dissector_keys));\n\tskb_flow_dissector_init(&flow_keys_buf_dissector,\n\t\t\t\tflow_keys_buf_dissector_keys,\n\t\t\t\tARRAY_SIZE(flow_keys_buf_dissector_keys));\n\treturn 0;\n}\n\nlate_initcall_sync(init_default_flow_dissectors);\n"], "filenames": ["net/core/flow_dissector.c"], "buggy_code_start_loc": [132], "buggy_code_end_loc": [432], "fixing_code_start_loc": [133], "fixing_code_end_loc": [431], "type": "CWE-665", "message": "The __skb_flow_dissect function in net/core/flow_dissector.c in the Linux kernel before 4.3 does not ensure that n_proto, ip_proto, and thoff are initialized, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a single crafted MPLS packet.", "other": {"cve": {"id": "CVE-2017-13715", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-29T01:35:13.453", "lastModified": "2023-01-17T21:21:01.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The __skb_flow_dissect function in net/core/flow_dissector.c in the Linux kernel before 4.3 does not ensure that n_proto, ip_proto, and thoff are initialized, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a single crafted MPLS packet."}, {"lang": "es", "value": "funci\u00f3n __skb_flow_dissect en net/core/flow_dissector.c en el kernel Linux en versiones anteriores a la 4.3 no garantiza que se inicialicen n_proto, ip_proto y thoff. Esto permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (bloqueo del sistema) o que ejecuten c\u00f3digo arbitrario mediante un \u00fanico paquete MPLS manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.3", "matchCriteriaId": "2D7D2BE9-1366-4308-965F-0AD4FD7A85F0"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://seclists.org/oss-sec/2017/q3/345", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/100517", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0"}}