{"buggy_code": ["<?php\n/**\n * @package content\n */\n\n/**\n * This page controls the creation and maintenance of Symphony\n * Sections through the Section Index and Section Editor.\n */\n\nclass contentBlueprintsSections extends AdministrationPage\n{\n    public $_errors = array();\n\n    public function build(array $context = array())\n    {\n        $section_id = $context[1];\n\n        if (isset($section_id)) {\n            $context['associations'] = array(\n                'parent' => SectionManager::fetchParentAssociations($section_id),\n                'child' => SectionManager::fetchChildAssociations($section_id)\n            );\n        }\n\n        return parent::build($context);\n    }\n\n    public function __viewIndex()\n    {\n        $this->setPageType('table');\n        $this->setTitle(__('%1$s &ndash; %2$s', array(__('Sections'), __('Symphony'))));\n        $this->appendSubheading(__('Sections'), Widget::Anchor(__('Create New'), Administration::instance()->getCurrentPageURL().'new/', __('Create a section'), 'create button', null, array('accesskey' => 'c')));\n\n        $sections = SectionManager::fetch(null, 'ASC', 'sortorder');\n\n        $aTableHead = array(\n            array(__('Name'), 'col'),\n            array(__('Entries'), 'col'),\n            array(__('Navigation Group'), 'col')\n        );\n\n        $aTableBody = array();\n\n        if (!is_array($sections) || empty($sections)) {\n            $aTableBody = array(\n                Widget::TableRow(array(Widget::TableData(__('None found.'), 'inactive', null, count($aTableHead))), 'odd')\n            );\n        } else {\n            foreach ($sections as $s) {\n                $entry_count = EntryManager::fetchCount($s->get('id'));\n\n                // Setup each cell\n                $td1 = Widget::TableData(Widget::Anchor($s->get('name'), Administration::instance()->getCurrentPageURL() . 'edit/' . $s->get('id') .'/', null, 'content'));\n                $td1->appendChild(Widget::Label(__('Select Section %s', array($s->get('name'))), null, 'accessible', null, array(\n                    'for' => 'section-' . $s->get('id')\n                )));\n                $td1->appendChild(Widget::Input('items['.$s->get('id').']', 'on', 'checkbox', array(\n                    'id' => 'section-' . $s->get('id')\n                )));\n\n                $td2 = Widget::TableData(Widget::Anchor(\"$entry_count\", SYMPHONY_URL . '/publish/' . $s->get('handle') . '/'));\n                $td3 = Widget::TableData($s->get('navigation_group'));\n\n                // Create row\n                $tr = Widget::TableRow(array($td1, $td2, $td3));\n\n                if ($s->get('hidden') === 'yes') {\n                    $tr->setAttribute('class', 'inactive');\n                }\n\n                $aTableBody[] = $tr;\n            }\n        }\n\n        $table = Widget::Table(\n            Widget::TableHead($aTableHead),\n            null,\n            Widget::TableBody($aTableBody),\n            'orderable selectable',\n            null,\n            array('role' => 'directory', 'aria-labelledby' => 'symphony-subheading', 'data-interactive' => 'data-interactive')\n        );\n\n        $this->Form->appendChild($table);\n\n        $version = new XMLElement('p', 'Symphony ' . Symphony::Configuration()->get('version', 'symphony'), array(\n            'id' => 'version'\n        ));\n\n        $this->Form->appendChild($version);\n\n        $tableActions = new XMLElement('div');\n        $tableActions->setAttribute('class', 'actions');\n\n        $options = array(\n            array(null, false, __('With Selected...')),\n            array('delete', false, __('Delete'), 'confirm', null, array(\n                'data-message' => __('Are you sure you want to delete the selected sections?')\n            )),\n            array('delete-entries', false, __('Delete Entries'), 'confirm', null, array(\n                'data-message' => __('Are you sure you want to delete all entries in the selected sections?')\n            ))\n        );\n\n        if (is_array($sections) && !empty($sections)) {\n            $index = 3;\n            $options[$index] = array('label' => __('Set navigation group'), 'options' => array());\n\n            $groups = array();\n\n            foreach ($sections as $s) {\n                if (in_array($s->get('navigation_group'), $groups)) {\n                    continue;\n                }\n\n                $groups[] = $s->get('navigation_group');\n\n                $value = 'set-navigation-group-' . urlencode($s->get('navigation_group'));\n                $options[$index]['options'][] = array($value, false, $s->get('navigation_group'));\n            }\n        }\n\n        /**\n         * Allows an extension to modify the existing options for this page's\n         * With Selected menu. If the `$options` parameter is an empty array,\n         * the 'With Selected' menu will not be rendered.\n         *\n         * @delegate AddCustomActions\n         * @since Symphony 2.3.2\n         * @param string $context\n         * '/blueprints/sections/'\n         * @param array $options\n         *  An array of arrays, where each child array represents an option\n         *  in the With Selected menu. Options should follow the same format\n         *  expected by `Widget::__SelectBuildOption`. Passed by reference.\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddCustomActions', '/blueprints/sections/', array(\n            'options' => &$options\n        ));\n\n        if (!empty($options)) {\n            $tableActions->appendChild(Widget::Apply($options));\n            $this->Form->appendChild($tableActions);\n        }\n    }\n\n    public function __viewNew()\n    {\n        $this->setPageType('form');\n        $this->setTitle(__('%1$s &ndash; %2$s', array(__('Sections'), __('Symphony'))));\n        $this->appendSubheading(__('Untitled'));\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor(__('Sections'), SYMPHONY_URL . '/blueprints/sections/'),\n        ));\n\n        $types = array();\n\n        $fields = (isset($_POST['fields']) && is_array($_POST['fields'])) ? $_POST['fields'] : array();\n        $meta = (isset($_POST['meta']) && is_array($_POST['meta'])) ? $_POST['meta'] : array('name'=>null);\n\n        $formHasErrors = (is_array($this->_errors) && !empty($this->_errors));\n\n        if ($formHasErrors) {\n            $this->pageAlert(\n                __('An error occurred while processing this form. See below for details.'),\n                Alert::ERROR\n            );\n        }\n\n        $showEmptyTemplate = (is_array($fields) && !empty($fields) ? false : true);\n\n        if (!$showEmptyTemplate) {\n            ksort($fields);\n        }\n\n        // Set navigation group, if not already set\n        if (!isset($meta['navigation_group'])) {\n            $meta['navigation_group'] = (isset($this->_navigation[0]['name']) ? $this->_navigation[0]['name'] : __('Content'));\n        }\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n        $fieldset->appendChild(new XMLElement('legend', __('Essentials')));\n\n        $namediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Name'));\n        $label->appendChild(Widget::Input('meta[name]', (isset($meta['name']) ? General::sanitize($meta['name']) : null)));\n\n        if (isset($this->_errors['name'])) {\n            $namediv->appendChild(Widget::Error($label, $this->_errors['name']));\n        } else {\n            $namediv->appendChild($label);\n        }\n\n        $fieldset->appendChild($namediv);\n\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        $handlediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Handle'));\n        $label->appendChild(Widget::Input('meta[handle]', (isset($meta['handle']) ? General::sanitize($meta['handle']) : null)));\n\n        if (isset($this->_errors['handle'])) {\n            $handlediv->appendChild(Widget::Error($label, $this->_errors['handle']));\n        } else {\n            $handlediv->appendChild($label);\n        }\n\n        $div->appendChild($handlediv);\n\n        $navgroupdiv = new XMLElement('div', null, array('class' => 'column'));\n\n        $sections = SectionManager::fetch(null, 'ASC', 'sortorder');\n        $label = Widget::Label(__('Navigation Group'));\n        $label->appendChild(Widget::Input('meta[navigation_group]', $meta['navigation_group']));\n\n        if (isset($this->_errors['navigation_group'])) {\n            $navgroupdiv->appendChild(Widget::Error($label, $this->_errors['navigation_group']));\n        } else {\n            $navgroupdiv->appendChild($label);\n        }\n\n        if (is_array($sections) && !empty($sections)) {\n            $ul = new XMLElement('ul', null, array('class' => 'tags singular', 'data-interactive' => 'data-interactive'));\n            $groups = array();\n\n            foreach ($sections as $s) {\n                if (in_array($s->get('navigation_group'), $groups)) {\n                    continue;\n                }\n\n                $ul->appendChild(new XMLElement('li', $s->get('navigation_group')));\n                $groups[] = $s->get('navigation_group');\n            }\n\n            $navgroupdiv->appendChild($ul);\n        }\n\n        $div->appendChild($navgroupdiv);\n        $fieldset->appendChild($div);\n        $this->Form->appendChild($fieldset);\n\n        $this->addSectionOptions($meta);\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n\n        $legend = new XMLElement('legend', __('Fields'));\n        $legend->setAttribute('id', 'fields-legend');\n        $fieldset->appendChild($legend);\n\n        $div = new XMLElement('div', null, array('class' => 'frame', 'id' => 'fields-duplicator'));\n\n        $ol = new XMLElement('ol');\n        $ol->setAttribute('data-add', __('Add field'));\n        $ol->setAttribute('data-remove', __('Remove field'));\n\n        if (!$showEmptyTemplate) {\n            foreach ($fields as $position => $data) {\n                if ($input = FieldManager::create($data['type'])) {\n                    $input->setArray($data);\n\n                    $wrapper = new XMLElement('li');\n\n                    $input->set('sortorder', $position);\n                    $input->displaySettingsPanel($wrapper, (isset($this->_errors[$position]) ? $this->_errors[$position] : null));\n                    $ol->appendChild($wrapper);\n                }\n            }\n        }\n\n        foreach (FieldManager::listAll() as $type) {\n            if ($type = FieldManager::create($type)) {\n                $types[] = $type;\n            }\n        }\n\n        uasort($types, function($a, $b) {\n            return strnatcasecmp($a->_name, $b->_name);\n        });\n\n        foreach ($types as $type) {\n            $defaults = array();\n\n            $type->findDefaults($defaults);\n            $type->setArray($defaults);\n\n            $wrapper = new XMLElement('li');\n            $wrapper->setAttribute('class', 'template field-' . $type->handle() . ($type->mustBeUnique() ? ' unique' : null));\n            $wrapper->setAttribute('data-type', $type->handle());\n\n            $type->set('sortorder', '-1');\n            $type->displaySettingsPanel($wrapper);\n\n            $ol->appendChild($wrapper);\n        }\n\n        $div->appendChild($ol);\n        $fieldset->appendChild($div);\n\n        $this->Form->appendChild($fieldset);\n\n        $div = new XMLElement('div');\n        $div->setAttribute('class', 'actions');\n        $div->appendChild(Widget::Input('action[save]', __('Create Section'), 'submit', array('accesskey' => 's')));\n\n        $this->Form->appendChild($div);\n    }\n\n    public function __viewEdit()\n    {\n        $section_id = $this->_context[1];\n\n        if (!$section = SectionManager::fetch($section_id)) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array($section_id)),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n\n        $meta = $section->get();\n        $section_id = $meta['id'];\n        $types = array();\n\n        $formHasErrors = (is_array($this->_errors) && !empty($this->_errors));\n\n        if ($formHasErrors) {\n            $this->pageAlert(\n                __('An error occurred while processing this form. See below for details.'),\n                Alert::ERROR\n            );\n\n            // These alerts are only valid if the form doesn't have errors\n        } elseif (isset($this->_context[2])) {\n            $time = Widget::Time();\n\n            switch ($this->_context[2]) {\n                case 'saved':\n                    $message = __('Section updated at %s.', array($time->generate()));\n                    break;\n                case 'created':\n                    $message = __('Section created at %s.', array($time->generate()));\n            }\n\n            $this->pageAlert(\n                $message\n                . ' <a href=\"' . SYMPHONY_URL . '/blueprints/sections/new/\" accesskey=\"c\">'\n                . __('Create another?')\n                . '</a> <a href=\"' . SYMPHONY_URL . '/blueprints/sections/\" accesskey=\"a\">'\n                . __('View all Sections')\n                . '</a>',\n                Alert::SUCCESS\n            );\n        }\n\n        if (isset($_POST['fields'])) {\n            $fields = array();\n\n            if (is_array($_POST['fields']) && !empty($_POST['fields'])) {\n                foreach ($_POST['fields'] as $position => $data) {\n                    if ($fields[$position] = FieldManager::create($data['type'])) {\n                        $fields[$position]->setArray($data);\n                        $fields[$position]->set('sortorder', $position);\n                    }\n                }\n            }\n        } else {\n            $fields = FieldManager::fetch(null, $section_id);\n            $fields = array_values($fields);\n        }\n\n        if (isset($_POST['meta'])) {\n            $meta = $_POST['meta'];\n            if ($meta['name'] == '') {\n                $meta['name'] = $section->get('name');\n            }\n        }\n\n        $this->setPageType('form');\n        $this->setTitle(__('%1$s &ndash; %2$s &ndash; %3$s', array($meta['name'], __('Sections'), __('Symphony'))));\n        $this->appendSubheading($meta['name'],\n            Widget::Anchor(__('View Entries'), SYMPHONY_URL . '/publish/' . $section->get('handle'), __('View Section Entries'), 'button')\n        );\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor(__('Sections'), SYMPHONY_URL . '/blueprints/sections/'),\n        ));\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n        $fieldset->appendChild(new XMLElement('legend', __('Essentials')));\n\n        $namediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Name'));\n        $label->appendChild(Widget::Input('meta[name]', (isset($meta['name']) ? General::sanitize($meta['name']) : null)));\n\n        if (isset($this->_errors['name'])) {\n            $namediv->appendChild(Widget::Error($label, $this->_errors['name']));\n        } else {\n            $namediv->appendChild($label);\n        }\n\n        $fieldset->appendChild($namediv);\n\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        $handlediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Handle'));\n        $label->appendChild(Widget::Input('meta[handle]', (isset($meta['handle']) ? General::sanitize($meta['handle']) : null)));\n\n        if (isset($this->_errors['handle'])) {\n            $handlediv->appendChild(Widget::Error($label, $this->_errors['handle']));\n        } else {\n            $handlediv->appendChild($label);\n        }\n\n        $div->appendChild($handlediv);\n\n        $navgroupdiv = new XMLElement('div', null, array('class' => 'column'));\n\n        $sections = SectionManager::fetch(null, 'ASC', 'sortorder');\n        $label = Widget::Label(__('Navigation Group'));\n        $label->appendChild(Widget::Input('meta[navigation_group]', $meta['navigation_group']));\n\n        if (isset($this->_errors['navigation_group'])) {\n            $navgroupdiv->appendChild(Widget::Error($label, $this->_errors['navigation_group']));\n        } else {\n            $navgroupdiv->appendChild($label);\n        }\n\n        if (is_array($sections) && !empty($sections)) {\n            $ul = new XMLElement('ul', null, array('class' => 'tags singular', 'data-interactive' => 'data-interactive'));\n            $groups = array();\n\n            foreach ($sections as $s) {\n                if (in_array($s->get('navigation_group'), $groups)) {\n                    continue;\n                }\n\n                $ul->appendChild(new XMLElement('li', $s->get('navigation_group')));\n                $groups[] = $s->get('navigation_group');\n            }\n\n            $navgroupdiv->appendChild($ul);\n        }\n\n        $div->appendChild($navgroupdiv);\n        $fieldset->appendChild($div);\n        $this->Form->appendChild($fieldset);\n\n        $this->addSectionOptions($meta);\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n\n        $legend = new XMLElement('legend', __('Fields'));\n        $legend->setAttribute('id', 'fields-legend');\n        $fieldset->appendChild($legend);\n\n        $div = new XMLElement('div', null, array('class' => 'frame', 'id' => 'fields-duplicator'));\n\n        $ol = new XMLElement('ol');\n        $ol->setAttribute('data-add', __('Add field'));\n        $ol->setAttribute('data-remove', __('Remove field'));\n\n        if (is_array($fields) && !empty($fields)) {\n            foreach ($fields as $position => $field) {\n                $wrapper = new XMLElement('li', null, array('class' => 'field-' . $field->handle() . ($field->mustBeUnique() ? ' unique' : null)));\n                $wrapper->setAttribute('data-type', $field->handle());\n\n                $field->set('sortorder', $position);\n                $field->displaySettingsPanel($wrapper, (isset($this->_errors[$position]) ? $this->_errors[$position] : null));\n                $ol->appendChild($wrapper);\n            }\n        }\n\n        foreach (FieldManager::listAll() as $type) {\n            if ($type = FieldManager::create($type)) {\n                array_push($types, $type);\n            }\n        }\n\n        uasort($types, function($a, $b) {\n            return strnatcasecmp($a->_name, $b->_name);\n        });\n\n        foreach ($types as $type) {\n            $defaults = array();\n\n            $type->findDefaults($defaults);\n            $type->setArray($defaults);\n\n            $wrapper = new XMLElement('li');\n\n            $wrapper->setAttribute('class', 'template field-' . $type->handle() . ($type->mustBeUnique() ? ' unique' : null));\n            $wrapper->setAttribute('data-type', $type->handle());\n\n            $type->set('sortorder', '-1');\n            $type->displaySettingsPanel($wrapper);\n\n            $ol->appendChild($wrapper);\n        }\n\n        $div->appendChild($ol);\n        $fieldset->appendChild($div);\n\n        $this->Form->appendChild($fieldset);\n\n        $div = new XMLElement('div');\n        $div->setAttribute('class', 'actions');\n        $div->appendChild(Widget::Input('action[save]', __('Save Changes'), 'submit', array('accesskey' => 's')));\n\n        $button = new XMLElement('button', __('Delete'));\n        $button->setAttributeArray(array('name' => 'action[delete]', 'class' => 'button confirm delete', 'title' => __('Delete this section'), 'type' => 'submit', 'accesskey' => 'd', 'data-message' => __('Are you sure you want to delete this section?')));\n        $div->appendChild($button);\n\n        $this->Form->appendChild($div);\n    }\n\n    public function __actionIndex()\n    {\n        $checked = (is_array($_POST['items'])) ? array_keys($_POST['items']) : null;\n\n        if (is_array($checked) && !empty($checked)) {\n            /**\n             * Extensions can listen for any custom actions that were added\n             * through `AddCustomPreferenceFieldsets` or `AddCustomActions`\n             * delegates.\n             *\n             * @delegate CustomActions\n             * @since Symphony 2.3.2\n             * @param string $context\n             *  '/blueprints/sections/'\n             * @param array $checked\n             *  An array of the selected rows. The value is usually the ID of the\n             *  the associated object.\n             */\n            Symphony::ExtensionManager()->notifyMembers('CustomActions', '/blueprints/sections/', array(\n                'checked' => $checked\n            ));\n\n            if ($_POST['with-selected'] == 'delete') {\n                /**\n                 * Just prior to calling the Section Manager's delete function\n                 *\n                 * @delegate SectionPreDelete\n                 * @since Symphony 2.2\n                 * @param string $context\n                 * '/blueprints/sections/'\n                 * @param array $section_ids\n                 *  An array of Section ID's passed by reference\n                 */\n                Symphony::ExtensionManager()->notifyMembers('SectionPreDelete', '/blueprints/sections/', array('section_ids' => &$checked));\n\n                foreach ($checked as $section_id) {\n                    SectionManager::delete($section_id);\n                }\n\n                redirect(SYMPHONY_URL . '/blueprints/sections/');\n            } elseif ($_POST['with-selected'] == 'delete-entries') {\n                foreach ($checked as $section_id) {\n                    $entries = EntryManager::fetch(null, $section_id, null, null, null, null, false, false, null, false);\n                    $entry_ids = array();\n\n                    foreach ($entries as $entry) {\n                        $entry_ids[] = $entry['id'];\n                    }\n\n                    /**\n                     * Prior to deletion of entries.\n                     *\n                     * @delegate Delete\n                     * @param string $context\n                     * '/publish/'\n                     * @param array $entry_id\n                     *  An array of Entry ID's that are about to be deleted, passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('Delete', '/publish/', array('entry_id' => &$entry_ids));\n\n                    EntryManager::delete($entry_ids, $section_id);\n                }\n\n                redirect(SYMPHONY_URL . '/blueprints/sections/');\n            } elseif (preg_match('/^set-navigation-group-/', $_POST['with-selected'])) {\n                $navigation_group = preg_replace('/^set-navigation-group-/', null, $_POST['with-selected']);\n\n                foreach ($checked as $section_id) {\n                    SectionManager::edit($section_id, array('navigation_group' => urldecode($navigation_group)));\n                }\n\n                redirect(SYMPHONY_URL . '/blueprints/sections/');\n            }\n        }\n    }\n\n    public function __actionNew()\n    {\n        if (@array_key_exists('save', $_POST['action']) || @array_key_exists('done', $_POST['action'])) {\n            $canProceed = true;\n            $edit = ($this->_context[0] == \"edit\");\n            $this->_errors = array();\n\n            $fields = isset($_POST['fields']) ? $_POST['fields'] : array();\n            $meta = $_POST['meta'];\n\n            if ($edit) {\n                $section_id = $this->_context[1];\n                $existing_section = SectionManager::fetch($section_id);\n            }\n\n            // Check handle to ensure it is unique\n            $meta['handle'] = $_POST['meta']['handle'] = Lang::createHandle((isset($meta['handle']) && !empty($meta['handle']))\n                ? $meta['handle']\n                : $meta['name']);\n\n            // Check to ensure all the required section fields are filled\n            if (!isset($meta['name']) || strlen(trim($meta['name'])) == 0) {\n                $this->_errors['name'] = __('This is a required field.');\n                $canProceed = false;\n\n                // Check for duplicate section handle during edit\n            } elseif ($edit) {\n                $s = SectionManager::fetchIDFromHandle(Lang::createHandle($meta['handle']));\n\n                if (\n                    $meta['handle'] !== $existing_section->get('handle')\n                    && !is_null($s) && $s !== $section_id\n                ) {\n                    $this->_errors['handle'] = __('A Section with the handle %s already exists', array('<code>' . $meta['handle'] . '</code>'));\n                    $canProceed = false;\n                }\n\n                // Existing section during creation\n            } elseif (!is_null(SectionManager::fetchIDFromHandle(Lang::createHandle($meta['handle'])))) {\n                $this->_errors['handle'] = __('A Section with the handle %s already exists', array('<code>' . $meta['handle'] . '</code>'));\n                $canProceed = false;\n            }\n\n            // Check to ensure all the required section fields are filled\n            if (!isset($meta['navigation_group']) || strlen(trim($meta['navigation_group'])) == 0) {\n                $this->_errors['navigation_group'] = __('This is a required field.');\n                $canProceed = false;\n            }\n\n            // Basic custom field checking\n            if (is_array($fields) && !empty($fields)) {\n                // Check for duplicate CF names\n                if ($canProceed) {\n                    $name_list = array();\n\n                    foreach ($fields as $position => $data) {\n                        if (trim($data['element_name']) == '') {\n                            $data['element_name'] = $fields[$position]['element_name'] = $_POST['fields'][$position]['element_name'] = Lang::createHandle($data['label'], 255, '-', false, true, array('@^[\\d-]+@i' => ''));\n                        }\n\n                        if (trim($data['element_name']) != '' && in_array($data['element_name'], $name_list)) {\n                            $this->_errors[$position] = array('element_name' => __('A field with this handle already exists. All handle must be unique.'));\n                            $canProceed = false;\n                            break;\n                        }\n\n                        $name_list[] = $data['element_name'];\n                    }\n                }\n\n                if ($canProceed) {\n                    $unique = array();\n\n                    foreach ($fields as $position => $data) {\n                        $field = FieldManager::create($data['type']);\n                        $field->setFromPOST($data);\n\n                        if (isset($existing_section)) {\n                            $field->set('parent_section', $existing_section->get('id'));\n                        }\n\n                        if ($field->mustBeUnique() && !in_array($field->get('type'), $unique)) {\n                            $unique[] = $field->get('type');\n                        } elseif ($field->mustBeUnique() && in_array($field->get('type'), $unique)) {\n                            // Warning. cannot have 2 of this field!\n                            $canProceed = false;\n                            $this->_errors[$position] = array('label' => __('There is already a field of type %s. There can only be one per section.', array('<code>' . $field->handle() . '</code>')));\n                        }\n\n                        $errors = array();\n\n                        if (Field::__OK__ != $field->checkFields($errors, false) && !empty($errors)) {\n                            $this->_errors[$position] = $errors;\n                            $canProceed = false;\n                        }\n                    }\n                }\n            }\n\n            if ($canProceed) {\n                // If we are creating a new Section\n                if (!$edit) {\n                    $meta['sortorder'] = SectionManager::fetchNextSortOrder();\n\n                    /**\n                     * Just prior to saving the Section settings. Use with caution as\n                     * there is no additional processing to ensure that Field's or Section's\n                     * are unique.\n                     *\n                     * @delegate SectionPreCreate\n                     * @since Symphony 2.2\n                     * @param string $context\n                     * '/blueprints/sections/'\n                     * @param array $meta\n                     *  The section's settings, passed by reference\n                     * @param array $fields\n                     *  An associative array of the fields that will be saved to this\n                     *  section with the key being the position in the Section Editor\n                     *  and the value being a Field object, passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('SectionPreCreate', '/blueprints/sections/', array('meta' => &$meta, 'fields' => &$fields));\n\n                    if (!$section_id = SectionManager::add($meta)) {\n                        $this->pageAlert(__('An unknown database occurred while attempting to create the section.'), Alert::ERROR);\n                    }\n\n                    // We are editing a Section\n                } else {\n\n                    /**\n                     * Just prior to updating the Section settings. Use with caution as\n                     * there is no additional processing to ensure that Field's or Section's\n                     * are unique.\n                     *\n                     * @delegate SectionPreEdit\n                     * @since Symphony 2.2\n                     * @param string $context\n                     * '/blueprints/sections/'\n                     * @param integer $section_id\n                     *  The Section ID that is about to be edited.\n                     * @param array $meta\n                     *  The section's settings, passed by reference\n                     * @param array $fields\n                     *  An associative array of the fields that will be saved to this\n                     *  section with the key being the position in the Section Editor\n                     *  and the value being a Field object, passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('SectionPreEdit', '/blueprints/sections/', array('section_id' => $section_id, 'meta' => &$meta, 'fields' => &$fields));\n\n                    if (!SectionManager::edit($section_id, $meta)) {\n                        $canProceed = false;\n                        $this->pageAlert(__('An unknown database occurred while attempting to create the section.'), Alert::ERROR);\n                    }\n                }\n\n                if ($section_id && $canProceed) {\n                    if ($edit) {\n                        // Delete missing CF's\n                        $id_list = array();\n\n                        if (is_array($fields) && !empty($fields)) {\n                            foreach ($fields as $position => $data) {\n                                if (isset($data['id'])) {\n                                    $id_list[] = $data['id'];\n                                }\n                            }\n                        }\n\n                        $missing_cfs = Symphony::Database()->fetchCol('id', \"SELECT `id` FROM `tbl_fields` WHERE `parent_section` = '$section_id' AND `id` NOT IN ('\".@implode(\"', '\", $id_list).\"')\");\n\n                        if (is_array($missing_cfs) && !empty($missing_cfs)) {\n                            foreach ($missing_cfs as $id) {\n                                FieldManager::delete($id);\n                            }\n                        }\n                    }\n\n                    // Save each custom field\n                    if (is_array($fields) && !empty($fields)) {\n                        foreach ($fields as $position => $data) {\n                            $field = FieldManager::create($data['type']);\n                            $field->setFromPOST($data);\n                            $field->set('sortorder', (string)$position);\n                            $field->set('parent_section', $section_id);\n\n                            $newField = !(boolean)$field->get('id');\n\n                            $field->commit();\n                            $field_id = $field->get('id');\n\n                            if ($field_id) {\n                                if ($newField) {\n                                    /**\n                                     * After creation of a Field.\n                                     *\n                                     * @delegate FieldPostCreate\n                                     * @param string $context\n                                     * '/blueprints/sections/'\n                                     * @param Field $field\n                                     *  The Field object, passed by reference\n                                     * @param array $data\n                                     *  The settings for ths `$field`, passed by reference\n                                     */\n                                    Symphony::ExtensionManager()->notifyMembers('FieldPostCreate', '/blueprints/sections/', array('field' => &$field, 'data' => &$data));\n                                } else {\n                                    /**\n                                     * After editing of a Field.\n                                     *\n                                     * @delegate FieldPostEdit\n                                     * @param string $context\n                                     * '/blueprints/sections/'\n                                     * @param Field $field\n                                     *  The Field object, passed by reference\n                                     * @param array $data\n                                     *  The settings for ths `$field`, passed by reference\n                                     */\n                                    Symphony::ExtensionManager()->notifyMembers('FieldPostEdit', '/blueprints/sections/', array('field' => &$field, 'data' => &$data));\n                                }\n                            }\n                        }\n                    }\n\n                    if (!$edit) {\n                        /**\n                         * After the Section has been created, and all the Field's have been\n                         * created for this section, but just before the redirect\n                         *\n                         * @delegate SectionPostCreate\n                         * @since Symphony 2.2\n                         * @param string $context\n                         * '/blueprints/sections/'\n                         * @param integer $section_id\n                         *  The newly created Section ID.\n                         */\n                        Symphony::ExtensionManager()->notifyMembers('SectionPostCreate', '/blueprints/sections/', array('section_id' => $section_id));\n\n                        redirect(SYMPHONY_URL . \"/blueprints/sections/edit/$section_id/created/\");\n                    } else {\n                        /**\n                         * After the Section has been updated, and all the Field's have been\n                         * updated for this section, but just before the redirect\n                         *\n                         * @delegate SectionPostEdit\n                         * @since Symphony 2.2\n                         * @param string $context\n                         * '/blueprints/sections/'\n                         * @param integer $section_id\n                         *  The edited Section ID.\n                         */\n                        Symphony::ExtensionManager()->notifyMembers('SectionPostEdit', '/blueprints/sections/', array('section_id' => $section_id));\n\n                        redirect(SYMPHONY_URL . \"/blueprints/sections/edit/$section_id/saved/\");\n                    }\n                }\n            }\n        }\n\n        if (@array_key_exists(\"delete\", $_POST['action'])) {\n            $section_id = array($this->_context[1]);\n\n            /**\n             * Just prior to calling the Section Manager's delete function\n             *\n             * @delegate SectionPreDelete\n             * @since Symphony 2.2\n             * @param string $context\n             * '/blueprints/sections/'\n             * @param array $section_ids\n             *  An array of Section ID's passed by reference\n             */\n            Symphony::ExtensionManager()->notifyMembers('SectionPreDelete', '/blueprints/sections/', array('section_ids' => &$section_id));\n\n            foreach ($section_id as $section) {\n                SectionManager::delete($section);\n            }\n\n            redirect(SYMPHONY_URL . '/blueprints/sections/');\n        }\n    }\n\n    public function __actionEdit()\n    {\n        return $this->__actionNew();\n    }\n\n    public function addSectionOptions(array &$meta = null)\n    {\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n        $fieldset->appendChild(new XMLElement('legend', __('Options')));\n\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        $hidediv = new XMLElement('div', null, array('class' => 'column'));\n        $label = Widget::Checkbox('meta[hidden]', $meta['hidden'], __('Hide this section from the back-end menu'));\n        $hidediv->appendChild($label);\n        $div->appendChild($hidediv);\n\n        $filterdiv = new XMLElement('div', null, array('class' => 'column'));\n        $label = Widget::Checkbox('meta[filter]', $meta['filter'], __('Allow filtering of section entries'));\n        $filterdiv->appendChild($label);\n\n        $div->appendChild($filterdiv);\n        $fieldset->appendChild($div);\n        $this->Form->appendChild($fieldset);\n\n        /**\n         * Allows extensions to add elements to the header of the Section Editor\n         * form. Usually for section settings, this delegate is passed the current\n         * `$meta` array and the `$this->_errors` array.\n         *\n         * @delegate AddSectionElements\n         * @since Symphony 2.2\n         * @param string $context\n         * '/blueprints/sections/'\n         * @param XMLElement $form\n         *  An XMLElement of the current `$this->Form`, just after the Section\n         *  settings have been appended, but before the Fields duplicator\n         * @param array $meta\n         *  The current $_POST['meta'] array\n         * @param array $errors\n         *  The current errors array\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddSectionElements', '/blueprints/sections/', array(\n            'form' => &$this->Form,\n            'meta' => &$meta,\n            'errors' => &$this->_errors\n        ));\n    }\n}\n", "<?php\n\n/**\n * @package content\n */\n/**\n * The Publish page is where the majority of an Authors time will\n * be spent in Symphony with adding, editing and removing entries\n * from Sections. This Page controls the entries table as well as\n * the Entry creation screens.\n */\n\nclass contentPublish extends AdministrationPage\n{\n    public $_errors = array();\n\n    public function sort(&$sort, &$order, $params)\n    {\n        $section = $params['current-section'];\n\n        // If `?unsort` is appended to the URL, then sorting is reverted\n        // to 'none', aka. by 'entry-id'.\n        if ($params['unsort']) {\n            $section->setSortingField('id', false);\n            $section->setSortingOrder('desc');\n\n            redirect(Administration::instance()->getCurrentPageURL());\n        }\n\n        // By default, sorting information are retrieved from\n        // the filesystem and stored inside the `Configuration` object\n        if (is_null($sort) && is_null($order)) {\n            $sort = $section->getSortingField();\n            $order = $section->getSortingOrder();\n\n            // Set the sorting in the `EntryManager` for subsequent use\n            EntryManager::setFetchSorting($sort, $order);\n        } else {\n            $sort = General::sanitize($sort);\n\n            // Ensure that this field is infact sortable, otherwise\n            // fallback to IDs\n            if (($field = FieldManager::fetch($sort)) instanceof Field && !$field->isSortable()) {\n                $sort = $section->getDefaultSortingField();\n            }\n\n            // If the sort order or direction differs from what is saved,\n            // update the config file and reload the page\n            if ($sort != $section->getSortingField() || $order != $section->getSortingOrder()) {\n                $section->setSortingField($sort, false);\n                $section->setSortingOrder($order);\n\n                if ($params['filters']) {\n                    $params['filters'] = '?' . trim($params['filters'], '&amp;');\n                }\n\n                redirect(Administration::instance()->getCurrentPageURL() . $params['filters']);\n            }\n\n            // If the sort order or direction remains the same, reload the page\n            if ($sort == $section->getSortingField() && $order == $section->getSortingOrder()) {\n                if ($params['filters']) {\n                    $params['filters'] = '?' . trim($params['filters'], '&amp;');\n                }\n\n                redirect(Administration::instance()->getCurrentPageURL() . $params['filters']);\n            }\n        }\n    }\n\n    /**\n     * Append filtering interface\n     */\n    public function createFilteringInterface()\n    {\n        //Check if section has filtering enabled\n        $context = $this->getContext();\n        $handle = $context['section_handle'];\n        $section_id = SectionManager::fetchIDFromHandle($handle);\n        $section = SectionManager::fetch($section_id);\n        $filter = $section->get('filter');\n        $count = EntryManager::fetchCount($section_id);\n\n        if ($filter !== 'no' && $count > 1) {\n            $drawer = Widget::Drawer('filtering-' . $section_id, __('Filter Entries'), $this->createFilteringDrawer($section));\n            $drawer->addClass('drawer-filtering');\n            $this->insertDrawer($drawer);\n        }\n    }\n\n    /**\n     * Create filtering drawer\n     */\n    public function createFilteringDrawer($section)\n    {\n        $this->filteringForm = Widget::Form(null, 'get', 'filtering');\n        $this->createFilteringDuplicator($section);\n\n        return $this->filteringForm;\n    }\n\n    public function createFilteringDuplicator($section)\n    {\n        $div = new XMLElement('div');\n        $div->setAttribute('class', 'frame filters-duplicator');\n        $div->setAttribute('data-interactive', 'data-interactive');\n\n        $ol = new XMLElement('ol');\n        $ol->setAttribute('data-add', __('Add filter'));\n        $ol->setAttribute('data-remove', __('Clear filter'));\n        $ol->setAttribute('data-empty', __('No filters applied yet.'));\n\n        $this->createFieldFilters($ol, $section);\n        $this->createSystemDateFilters($ol);\n\n        $div->appendChild($ol);\n        $this->filteringForm->appendChild($div);\n    }\n\n    private function createFieldFilters(&$wrapper, $section)\n    {\n        $filters = $_GET['filter'];\n\n        foreach ($section->fetchFilterableFields() as $field) {\n            if (!$field->canPublishFilter()) {\n                continue;\n            }\n\n            $filter = $filters[$field->get('element_name')];\n\n            // Filter data\n            $data = array();\n            $data['type'] = $field->get('element_name');\n            $data['name'] = $field->get('label');\n            $data['filter'] = $filter;\n            $data['instance'] = 'unique';\n            $data['search'] = $field->fetchSuggestionTypes();\n            $data['operators'] = $field->fetchFilterableOperators();\n            $data['comparisons'] = $this->createFilterComparisons($data);\n            $data['query'] = $this->getFilterQuery($data);\n            $data['field-id'] = $field->get('id');\n\n            // Add existing filter\n            if (isset($filter)) {\n                $this->createFilter($wrapper, $data);\n            }\n\n            // Add filter template\n            $data['instance'] = 'unique template';\n            $data['query'] = '';\n            $this->createFilter($wrapper, $data);\n        }\n    }\n\n    private function createSystemDateFilters(&$wrapper)\n    {\n        $filters = $_GET['filter'];\n        $dateField = new FieldDate;\n\n        $fields = array(\n            array(\n                'type' => 'system:creation-date',\n                'label' => __('System Creation Date')\n            ),\n            array(\n                'type' => 'system:modification-date',\n                'label' => __('System Modification Date')\n            )\n        );\n\n        foreach ($fields as $field) {\n            $filter = $filters[$field['type']];\n\n            // Filter data\n            $data = array();\n            $data['type'] = $field['type'];\n            $data['name'] = $field['label'];\n            $data['filter'] = $filter;\n            $data['instance'] = 'unique';\n            $data['search'] = $dateField->fetchSuggestionTypes();\n            $data['operators'] = $dateField->fetchFilterableOperators();\n            $data['comparisons'] = $this->createFilterComparisons($data);\n            $data['query'] = $this->getFilterQuery($data);\n\n            // Add existing filter\n            if (isset($filter)) {\n                $this->createFilter($wrapper, $data);\n            }\n\n            // Add filter template\n            $data['instance'] = 'unique template';\n            $data['query'] = '';\n            $this->createFilter($wrapper, $data);\n        }\n    }\n\n    private function createFilter(&$wrapper, $data)\n    {\n        $li = new XMLElement('li');\n        $li->setAttribute('class', $data['instance']);\n        $li->setAttribute('data-type', $data['type']);\n\n        // Header\n        $li->appendChild(new XMLElement('header', $data['name'], array(\n            'data-name' => $data['name']\n        )));\n\n        // Settings\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        // Comparisons\n        $label = Widget::Label();\n        $label->setAttribute('class', 'column secondary');\n\n        $select = Widget::Select($data['type'] . '-comparison', $data['comparisons'], array(\n            'class' => 'comparison'\n        ));\n\n        $label->appendChild($select);\n        $div->appendChild($label);\n\n        // Query\n        $label = Widget::Label();\n        $label->setAttribute('class', 'column primary');\n\n        $input = Widget::Input($data['type'], General::sanitize($data['query']), 'text', array(\n            'placeholder' => __('Type and hit enter to apply filter\u2026'),\n            'autocomplete' => 'off'\n        ));\n        $input->setAttribute('class', 'filter');\n        $label->appendChild($input);\n\n        $this->createFilterSuggestions($label, $data);\n\n        $div->appendChild($label);\n        $li->appendChild($div);\n        $wrapper->appendChild($li);\n    }\n\n    private function createFilterComparisons($data)\n    {\n        // Default comparison\n        $comparisons = array();\n\n        // Custom field comparisons\n        foreach ($data['operators'] as $operator) {\n\n            $filter = trim($operator['filter']);\n\n            // Check selected state\n            $selected = false;\n\n            // Selected state : Comparison mode \"between\" (x to y)\n            if ($operator['title'] === 'between' && preg_match('/^(-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)) to (-?(?:\\d+(?:\\.\\d+)?|\\.\\d+))$/i', $data['filter'] )) {\n                $selected = true;\n            // Selected state : Other comparison modes (except \"is\")\n            } else if ((!empty($filter) && strpos($data['filter'], $filter) === 0)) {\n                $selected = true;\n            }\n\n            $comparisons[] = array(\n                $operator['filter'],\n                $selected,\n                __($operator['title']),\n                null,\n                null,\n                array('data-comparison' => $operator['title'])\n            );\n        }\n\n        return $comparisons;\n    }\n\n    private function createFilterSuggestions(&$wrapper, $data)\n    {\n        $ul = new XMLElement('ul');\n        $ul->setAttribute('class', 'suggestions');\n        $ul->setAttribute('data-field-id', $data['field-id']);\n        $ul->setAttribute('data-associated-ids', '0');\n        $ul->setAttribute('data-search-types', implode($data['search'], ','));\n\n        // Add help text for each filter operator\n        foreach ($data['operators'] as $operator) {\n            $this->createFilterHelp($ul, $operator);\n        }\n\n        $wrapper->appendChild($ul);\n    }\n\n    private function createFilterHelp(&$wrapper, $operator)\n    {\n        if (empty($operator['help'])) {\n            return;\n        }\n\n        $li = new XMLElement('li', __('Comparison mode') . ': ' . $operator['help'], array(\n            'class' => 'help',\n            'data-comparison' => $operator['title']\n        ));\n\n        $wrapper->appendChild($li);\n    }\n\n    private function getFilterQuery($data)\n    {\n        $query = $data['filter'];\n\n        foreach ($data['operators'] as $operator) {\n            $filter = trim($operator['filter']);\n\n            if (!empty($filter) && strpos($data['filter'], $filter) === 0) {\n                $query = substr($data['filter'], strlen($operator['filter']));\n            }\n        }\n\n        return (string)$query;\n    }\n\n    public function build(array $context = array())\n    {\n        $section_id = SectionManager::fetchIDFromHandle($context['section_handle']);\n\n        if ($section_id) {\n            $context['associations'] = array(\n                'parent' => SectionManager::fetchParentAssociations($section_id),\n                'child' => SectionManager::fetchChildAssociations($section_id)\n            );\n        }\n\n        return parent::build($context);\n    }\n\n    public function action()\n    {\n        $this->__switchboard('action');\n    }\n\n    public function __switchboard($type = 'view')\n    {\n        $function = ($type == 'action' ? '__action' : '__view') . ucfirst($this->_context['page']);\n\n        if (!method_exists($this, $function)) {\n            // If there is no action function, just return without doing anything\n            if ($type == 'action') {\n                return;\n            }\n\n            Administration::instance()->errorPageNotFound();\n        }\n\n        // Is this request allowed by server?\n        if ($this->isRequestValid() === false) {\n            $this->pageAlert(__('This request exceeds the maximum allowed request size of %s specified by your host.', array(\n                    ini_get('post_max_size')\n                )),\n                Alert::ERROR\n            );\n        }\n        $this->$function();\n    }\n\n    public function view()\n    {\n        $this->__switchboard();\n    }\n\n    public function __viewIndex()\n    {\n        if (!$section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle'])) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        } elseif (!is_writable(CONFIG)) {\n            $this->pageAlert(__('The Symphony configuration file, %s, is not writable. The sort order cannot be modified.', array('<code>/manifest/config.php</code>')), Alert::NOTICE);\n        }\n\n        $section = SectionManager::fetch($section_id);\n\n        $this->setPageType('table');\n        $this->setTitle(__('%1$s &ndash; %2$s', array($section->get('name'), __('Symphony'))));\n\n        $filters = array();\n        $filter_querystring = $prepopulate_querystring = $where = $joins = null;\n        $current_page = (isset($_REQUEST['pg']) && is_numeric($_REQUEST['pg']) ? max(1, intval($_REQUEST['pg'])) : 1);\n\n        if (isset($_REQUEST['filter'])) {\n            // legacy implementation, convert single filter to an array\n            // split string in the form ?filter=handle:value\n            if (!is_array($_REQUEST['filter'])) {\n                list($field_handle, $filter_value) = explode(':', $_REQUEST['filter'], 2);\n                $filters[$field_handle] = rawurldecode($filter_value);\n            } else {\n                $filters = $_REQUEST['filter'];\n            }\n\n            foreach ($filters as $handle => $value) {\n                // Handle multiple values through filtering. RE: #2290\n                if ((is_array($value) && empty($value)) || trim($value) == '') {\n                    continue;\n                }\n\n                if (!is_array($value)) {\n                    $filter_type = Datasource::determineFilterType($value);\n                    $value = preg_split('/'.($filter_type == Datasource::FILTER_AND ? '\\+' : '(?<!\\\\\\\\),').'\\s*/', $value, -1, PREG_SPLIT_NO_EMPTY);\n                    $value = array_map('trim', $value);\n                    $value = array_map(array('Datasource', 'removeEscapedCommas'), $value);\n                }\n\n                // Handle date meta data #2003\n                $handle = Symphony::Database()->cleanValue($handle);\n                if (in_array($handle, array('system:creation-date', 'system:modification-date'))) {\n                    $date_joins = '';\n                    $date_where = '';\n                    $date = new FieldDate();\n                    $date->buildDSRetrievalSQL($value, $date_joins, $date_where, ($filter_type == Datasource::FILTER_AND ? true : false));\n\n                    // Replace the date field where with the `creation_date` or `modification_date`.\n                    $date_where = preg_replace('/`t\\d+`.date/', ($field_id !== 'system:modification-date') ? '`e`.creation_date_gmt' : '`e`.modification_date_gmt', $date_where);\n                    $where .= $date_where;\n                } else {\n                    // Handle normal fields\n                    $field_id = FieldManager::fetchFieldIDFromElementName(\n                        $handle,\n                        $section->get('id')\n                    );\n\n                    $field = FieldManager::fetch($field_id);\n                    if ($field instanceof Field) {\n                        $field->buildDSRetrievalSQL($value, $joins, $where, ($filter_type == Datasource::FILTER_AND ? true : false));\n\n                        $value = implode(',', $value);\n                        $encoded_value = rawurlencode($value);\n                        $filter_querystring .= sprintf(\"filter[%s]=%s&amp;\", $handle, $encoded_value);\n\n                        // Some fields require that prepopulation be done via ID. RE: #2331\n                        if (!is_numeric($value) && method_exists($field, 'fetchIDfromValue')) {\n                            $encoded_value = $field->fetchIDfromValue($value);\n                        }\n                        $prepopulate_querystring .= sprintf(\"prepopulate[%d]=%s&amp;\", $field_id, $encoded_value);\n                    } else {\n                        unset($filters[$handle]);\n                    }\n                }\n            }\n\n            $filter_querystring = preg_replace(\"/&amp;$/\", '', $filter_querystring);\n            $prepopulate_querystring = preg_replace(\"/&amp;$/\", '', $prepopulate_querystring);\n        }\n\n        Sortable::initialize($this, $entries, $sort, $order, array(\n            'current-section' => $section,\n            'filters' => ($filter_querystring ? \"&amp;\" . $filter_querystring : ''),\n            'unsort' => isset($_REQUEST['unsort'])\n        ));\n\n        $this->Form->setAttribute('action', Administration::instance()->getCurrentPageURL(). '?pg=' . $current_page.($filter_querystring ? \"&amp;\" . $filter_querystring : ''));\n\n        // Build filtering interface\n        $this->createFilteringInterface();\n\n        $subheading_buttons = array(\n            Widget::Anchor(__('Create New'), Administration::instance()->getCurrentPageURL().'new/'.($prepopulate_querystring ? '?' . $prepopulate_querystring : ''), __('Create a new entry'), 'create button', null, array('accesskey' => 'c'))\n        );\n\n        // Only show the Edit Section button if the Author is a developer. #938 ^BA\n        if (Symphony::Author()->isDeveloper()) {\n            array_unshift($subheading_buttons, Widget::Anchor(__('Edit Section'), SYMPHONY_URL . '/blueprints/sections/edit/' . $section_id . '/', __('Edit Section Configuration'), 'button'));\n        }\n\n        $this->appendSubheading($section->get('name'), $subheading_buttons);\n\n        /**\n         * Allows adjustments to be made to the SQL where and joins statements\n         * before they are used to fetch the entries for the page\n         *\n         * @delegate AdjustPublishFiltering\n         * @since Symphony 2.3.3\n         * @param string $context\n         * '/publish/'\n         * @param integer $section_id\n         * An array of the current columns, passed by reference\n         * @param string $where\n         * The current where statement, or null if not set\n         * @param string $joins\n         */\n        Symphony::ExtensionManager()->notifyMembers('AdjustPublishFiltering', '/publish/', array('section-id' => $section_id, 'where' => &$where, 'joins' => &$joins));\n\n        // get visible columns\n        $visible_columns = $section->fetchVisibleColumns();\n        // extract the needed schema\n        $element_names = array_values(array_map(function ($field) {\n            return $field->get('element_name');\n        }, $visible_columns));\n\n        // Check that the filtered query fails that the filter is dropped and an\n        // error is logged. #841 ^BA\n        try {\n            $entries = EntryManager::fetchByPage($current_page, $section_id, Symphony::Configuration()->get('pagination_maximum_rows', 'symphony'), $where, $joins, true, false, true, $element_names);\n        } catch (DatabaseException $ex) {\n            $this->pageAlert(__('An error occurred while retrieving filtered entries. Showing all entries instead.'), Alert::ERROR);\n            $filter_querystring = null;\n            Symphony::Log()->pushToLog(sprintf(\n                    '%s - %s%s%s',\n                    $section->get('name') . ' Publish Index',\n                    $ex->getMessage(),\n                    ($ex->getFile() ? \" in file \" .  $ex->getFile() : null),\n                    ($ex->getLine() ? \" on line \" . $ex->getLine() : null)\n                ),\n                E_NOTICE,\n                true\n            );\n            $entries = EntryManager::fetchByPage($current_page, $section_id, Symphony::Configuration()->get('pagination_maximum_rows', 'symphony'), null, null, true, false, true, $element_names);\n        }\n\n        // Flag filtering\n        if (isset($_REQUEST['filter'])) {\n            $filter_stats = new XMLElement('p', '<span>\u2013 ' . __('%d of %d entries (filtered)', array($entries['total-entries'], EntryManager::fetchCount($section_id))) . '</span>', array('class' => 'inactive'));\n        } else {\n            $filter_stats = new XMLElement('p', '<span>\u2013 ' . __('%d entries', array($entries['total-entries'])) . '</span>', array('class' => 'inactive'));\n        }\n        $this->Breadcrumbs->appendChild($filter_stats);\n\n        // Build table\n        $columns = array();\n\n        if (is_array($visible_columns) && !empty($visible_columns)) {\n            foreach ($visible_columns as $column) {\n                $columns[] = array(\n                    'label' => $column->get('label'),\n                    'sortable' => $column->isSortable(),\n                    'handle' => $column->get('id'),\n                    'attrs' => array(\n                        'id' => 'field-' . $column->get('id'),\n                        'class' => 'field-' . $column->get('type')\n                    )\n                );\n            }\n        } else {\n            $columns[] = array(\n                'label' => __('ID'),\n                'sortable' => true,\n                'handle' => 'id'\n            );\n        }\n\n        $aTableHead = Sortable::buildTableHeaders($columns, $sort, $order, ($filter_querystring) ? \"&amp;\" . $filter_querystring : '');\n\n        $child_sections = array();\n        $associated_sections = $section->fetchChildAssociations(true);\n\n        if (is_array($associated_sections) && !empty($associated_sections)) {\n            foreach ($associated_sections as $key => $as) {\n                $child_sections[$key] = SectionManager::fetch($as['child_section_id']);\n                $aTableHead[] = array($child_sections[$key]->get('name'), 'col');\n            }\n        }\n\n        /**\n         * Allows the creation of custom table columns for each entry. Called\n         * after all the Section Visible columns have been added as well\n         * as the Section Associations\n         *\n         * @delegate AddCustomPublishColumn\n         * @since Symphony 2.2\n         * @param string $context\n         * '/publish/'\n         * @param array $tableHead\n         * An array of the current columns, passed by reference\n         * @param integer $section_id\n         * The current Section ID\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddCustomPublishColumn', '/publish/', array('tableHead' => &$aTableHead, 'section_id' => $section->get('id')));\n\n        // Table Body\n        $aTableBody = array();\n\n        if (!is_array($entries['records']) || empty($entries['records'])) {\n            $aTableBody = array(\n                Widget::TableRow(array(Widget::TableData(__('None found.'), 'inactive', null, count($aTableHead))), 'odd')\n            );\n        } else {\n            $field_pool = array();\n\n            if (is_array($visible_columns) && !empty($visible_columns)) {\n                foreach ($visible_columns as $column) {\n                    $field_pool[$column->get('id')] = $column;\n                }\n            }\n\n            $link_column = array_reverse($visible_columns);\n            $link_column = end($link_column);\n            reset($visible_columns);\n\n            foreach ($entries['records'] as $entry) {\n                $tableData = array();\n\n                // Setup each cell\n                if (!is_array($visible_columns) || empty($visible_columns)) {\n                    $tableData[] = Widget::TableData(Widget::Anchor($entry->get('id'), Administration::instance()->getCurrentPageURL() . 'edit/' . $entry->get('id') . '/'));\n                } else {\n                    $link = Widget::Anchor(\n                        '',\n                        Administration::instance()->getCurrentPageURL() . 'edit/' . $entry->get('id') . '/'.($filter_querystring ? '?' . $prepopulate_querystring : ''),\n                        $entry->get('id'),\n                        'content'\n                    );\n\n                    foreach ($visible_columns as $position => $column) {\n                        $data = $entry->getData($column->get('id'));\n                        $field = $field_pool[$column->get('id')];\n\n                        $value = $field->prepareTableValue($data, ($column == $link_column) ? $link : null, $entry->get('id'));\n\n                        if (!is_object($value) && (strlen(trim($value)) == 0 || $value == __('None'))) {\n                            $value = ($position == 0 ? $link->generate() : __('None'));\n                        }\n\n                        if ($value == __('None')) {\n                            $tableData[] = Widget::TableData($value, 'inactive field-' . $column->get('type') . ' field-' . $column->get('id'));\n                        } else {\n                            $tableData[] = Widget::TableData($value, 'field-' . $column->get('type') . ' field-' . $column->get('id'));\n                        }\n\n                        unset($field);\n                    }\n                }\n\n                if (is_array($child_sections) && !empty($child_sections)) {\n                    foreach ($child_sections as $key => $as) {\n                        $field = FieldManager::fetch((int)$associated_sections[$key]['child_section_field_id']);\n                        $parent_section_field_id = (int)$associated_sections[$key]['parent_section_field_id'];\n\n                        if (!is_null($parent_section_field_id)) {\n                            $search_value = $field->fetchAssociatedEntrySearchValue(\n                                $entry->getData($parent_section_field_id),\n                                $parent_section_field_id,\n                                $entry->get('id')\n                            );\n                        } else {\n                            $search_value = $entry->get('id');\n                        }\n\n                        if (!is_array($search_value)) {\n                            $associated_entry_count = $field->fetchAssociatedEntryCount($search_value);\n\n                            $tableData[] = Widget::TableData(\n                                Widget::Anchor(\n                                    sprintf('%d &rarr;', max(0, intval($associated_entry_count))),\n                                    sprintf(\n                                        '%s/publish/%s/?filter[%s]=%s',\n                                        SYMPHONY_URL,\n                                        $as->get('handle'),\n                                        $field->get('element_name'),\n                                        rawurlencode($search_value)\n                                    ),\n                                    $entry->get('id'),\n                                    'content'\n                                )\n                            );\n                        }\n                    }\n                }\n\n                /**\n                 * Allows Extensions to inject custom table data for each Entry\n                 * into the Publish Index\n                 *\n                 * @delegate AddCustomPublishColumnData\n                 * @since Symphony 2.2\n                 * @param string $context\n                 * '/publish/'\n                 * @param array $tableData\n                 *  An array of `Widget::TableData`, passed by reference\n                 * @param integer $section_id\n                 *  The current Section ID\n                 * @param Entry $entry_id\n                 *  The entry object, please note that this is by error and this will\n                 *  be removed in Symphony 2.4. The entry object is available in\n                 *  the 'entry' key as of Symphony 2.3.1.\n                 * @param Entry $entry\n                 *  The entry object for this row\n                 */\n                Symphony::ExtensionManager()->notifyMembers('AddCustomPublishColumnData', '/publish/', array(\n                    'tableData' => &$tableData,\n                    'section_id' => $section->get('id'),\n                    'entry_id' => $entry,\n                    'entry' => $entry\n                ));\n\n                $tableData[count($tableData) - 1]->appendChild(Widget::Label(__('Select Entry %d', array($entry->get('id'))), null, 'accessible', null, array(\n                    'for' => 'entry-' . $entry->get('id')\n                )));\n                $tableData[count($tableData) - 1]->appendChild(Widget::Input('items['.$entry->get('id').']', null, 'checkbox', array(\n                    'id' => 'entry-' . $entry->get('id')\n                )));\n\n                // Add a row to the body array, assigning each cell to the row\n                $aTableBody[] = Widget::TableRow($tableData, null, 'id-' . $entry->get('id'));\n            }\n        }\n\n        $table = Widget::Table(\n            Widget::TableHead($aTableHead),\n            null,\n            Widget::TableBody($aTableBody),\n            'selectable',\n            null,\n            array('role' => 'directory', 'aria-labelledby' => 'symphony-subheading', 'data-interactive' => 'data-interactive')\n        );\n\n        $this->Form->appendChild($table);\n\n        $tableActions = new XMLElement('div');\n        $tableActions->setAttribute('class', 'actions');\n\n        $options = array(\n            array(null, false, __('With Selected...')),\n            array('delete', false, __('Delete'), 'confirm', null, array(\n                'data-message' => __('Are you sure you want to delete the selected entries?')\n            ))\n        );\n\n        $toggable_fields = $section->fetchToggleableFields();\n\n        if (is_array($toggable_fields) && !empty($toggable_fields)) {\n            $index = 2;\n\n            foreach ($toggable_fields as $field) {\n                $toggle_states = $field->getToggleStates();\n\n                if (is_array($toggle_states)) {\n                    $options[$index] = array('label' => __('Set %s', array($field->get('label'))), 'options' => array());\n\n                    foreach ($toggle_states as $value => $state) {\n                        $options[$index]['options'][] = array('toggle-' . $field->get('id') . '-' . $value, false, $state);\n                    }\n                }\n\n                $index++;\n            }\n        }\n\n        /**\n         * Allows an extension to modify the existing options for this page's\n         * With Selected menu. If the `$options` parameter is an empty array,\n         * the 'With Selected' menu will not be rendered.\n         *\n         * @delegate AddCustomActions\n         * @since Symphony 2.3.2\n         * @param string $context\n         * '/publish/'\n         * @param array $options\n         *  An array of arrays, where each child array represents an option\n         *  in the With Selected menu. Options should follow the same format\n         *  expected by `Widget::__SelectBuildOption`. Passed by reference.\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddCustomActions', '/publish/', array(\n            'options' => &$options\n        ));\n\n        if (!empty($options)) {\n            $tableActions->appendChild(Widget::Apply($options));\n            $this->Form->appendChild($tableActions);\n        }\n\n        if ($entries['total-pages'] > 1) {\n            $ul = new XMLElement('ul');\n            $ul->setAttribute('class', 'page');\n\n            // First\n            $li = new XMLElement('li');\n\n            if ($current_page > 1) {\n                $li->appendChild(Widget::Anchor(__('First'), Administration::instance()->getCurrentPageURL(). '?pg=1'.($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('First'));\n            }\n\n            $ul->appendChild($li);\n\n            // Previous\n            $li = new XMLElement('li');\n\n            if ($current_page > 1) {\n                $li->appendChild(Widget::Anchor(__('&larr; Previous'), Administration::instance()->getCurrentPageURL(). '?pg=' . ($current_page - 1).($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('&larr; Previous'));\n            }\n\n            $ul->appendChild($li);\n\n            // Summary\n            $li = new XMLElement('li');\n\n            $li->setAttribute('title', __('Viewing %1$s - %2$s of %3$s entries', array(\n                $entries['start'],\n                ($current_page != $entries['total-pages']) ? $current_page * Symphony::Configuration()->get('pagination_maximum_rows', 'symphony') : $entries['total-entries'],\n                $entries['total-entries']\n            )));\n\n            $pgform = Widget::Form(Administration::instance()->getCurrentPageURL(), 'get', 'paginationform');\n\n            $pgmax = max($current_page, $entries['total-pages']);\n            $pgform->appendChild(Widget::Input('pg', null, 'text', array(\n                'data-active' => __('Go to page \u2026'),\n                'data-inactive' => __('Page %1$s of %2$s', array((string)$current_page, $pgmax)),\n                'data-max' => $pgmax\n            )));\n\n            $li->appendChild($pgform);\n            $ul->appendChild($li);\n\n            // Next\n            $li = new XMLElement('li');\n\n            if ($current_page < $entries['total-pages']) {\n                $li->appendChild(Widget::Anchor(__('Next &rarr;'), Administration::instance()->getCurrentPageURL(). '?pg=' . ($current_page + 1).($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('Next &rarr;'));\n            }\n\n            $ul->appendChild($li);\n\n            // Last\n            $li = new XMLElement('li');\n\n            if ($current_page < $entries['total-pages']) {\n                $li->appendChild(Widget::Anchor(__('Last'), Administration::instance()->getCurrentPageURL(). '?pg=' . $entries['total-pages'].($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('Last'));\n            }\n\n            $ul->appendChild($li);\n\n            $this->Contents->appendChild($ul);\n        }\n    }\n\n    public function __actionIndex()\n    {\n        $checked = (is_array($_POST['items'])) ? array_keys($_POST['items']) : null;\n\n        if (is_array($checked) && !empty($checked)) {\n            /**\n             * Extensions can listen for any custom actions that were added\n             * through `AddCustomPreferenceFieldsets` or `AddCustomActions`\n             * delegates.\n             *\n             * @delegate CustomActions\n             * @since Symphony 2.3.2\n             * @param string $context\n             *  '/publish/'\n             * @param array $checked\n             *  An array of the selected rows. The value is usually the ID of the\n             *  the associated object.\n             */\n            Symphony::ExtensionManager()->notifyMembers('CustomActions', '/publish/', array(\n                'checked' => $checked\n            ));\n\n            switch ($_POST['with-selected']) {\n                case 'delete':\n                    /**\n                     * Prior to deletion of entries. An array of Entry ID's is provided which\n                     * can be manipulated. This delegate was renamed from `Delete` to `EntryPreDelete`\n                     * in Symphony 2.3.\n                     *\n                     * @delegate EntryPreDelete\n                     * @param string $context\n                     * '/publish/'\n                     * @param array $entry_id\n                     *  An array of Entry ID's passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPreDelete', '/publish/', array('entry_id' => &$checked));\n\n                    EntryManager::delete($checked);\n\n                    /**\n                     * After the deletion of entries, this delegate provides an array of Entry ID's\n                     * that were deleted.\n                     *\n                     * @since Symphony 2.3\n                     * @delegate EntryPostDelete\n                     * @param string $context\n                     * '/publish/'\n                     * @param array $entry_id\n                     *  An array of Entry ID's that were deleted.\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPostDelete', '/publish/', array('entry_id' => $checked));\n\n                    redirect(server_safe('REQUEST_URI'));\n                    break;\n                default:\n                    list($option, $field_id, $value) = explode('-', $_POST['with-selected'], 3);\n\n                    if ($option == 'toggle') {\n                        $field = FieldManager::fetch($field_id);\n                        $fields = array($field->get('element_name') => $value);\n\n                        $section = SectionManager::fetch($field->get('parent_section'));\n\n                        foreach ($checked as $entry_id) {\n                            $entry = EntryManager::fetch($entry_id);\n                            $existing_data = $entry[0]->getData($field_id);\n                            $entry[0]->setData($field_id, $field->toggleFieldData(is_array($existing_data) ? $existing_data : array(), $value, $entry_id));\n\n                            /**\n                             * Just prior to editing of an Entry\n                             *\n                             * @delegate EntryPreEdit\n                             * @param string $context\n                             * '/publish/edit/'\n                             * @param Section $section\n                             * @param Entry $entry\n                             * @param array $fields\n                             */\n                            Symphony::ExtensionManager()->notifyMembers('EntryPreEdit', '/publish/edit/', array(\n                                'section' => $section,\n                                'entry' => &$entry[0],\n                                'fields' => $fields\n                            ));\n\n                            $entry[0]->commit();\n\n                            /**\n                             * Editing an entry. Entry object is provided.\n                             *\n                             * @delegate EntryPostEdit\n                             * @param string $context\n                             * '/publish/edit/'\n                             * @param Section $section\n                             * @param Entry $entry\n                             * @param array $fields\n                             */\n                            Symphony::ExtensionManager()->notifyMembers('EntryPostEdit', '/publish/edit/', array(\n                                'section' => $section,\n                                'entry' => $entry[0],\n                                'fields' => $fields\n                            ));\n                        }\n\n                        redirect(server_safe('REQUEST_URI'));\n                    }\n            }\n        }\n    }\n\n    public function __viewNew()\n    {\n        if (!$section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle'])) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n\n        $section = SectionManager::fetch($section_id);\n\n        $this->setPageType('form');\n        $this->setTitle(__('%1$s &ndash; %2$s', array($section->get('name'), __('Symphony'))));\n\n        // Ensure errored entries still maintain any prepopulated values [#2211]\n        $this->Form->setAttribute('action', $this->Form->getAttribute('action') . $this->getPrepopulateString());\n        $this->Form->setAttribute('enctype', 'multipart/form-data');\n\n        $sidebar_fields = $section->fetchFields(null, 'sidebar');\n        $main_fields = $section->fetchFields(null, 'main');\n\n        if (!empty($sidebar_fields) && !empty($main_fields)) {\n            $this->Form->setAttribute('class', 'two columns');\n        } else {\n            $this->Form->setAttribute('class', 'columns');\n        }\n\n        // Only show the Edit Section button if the Author is a developer. #938 ^BA\n        if (Symphony::Author()->isDeveloper()) {\n            $this->appendSubheading(__('Untitled'),\n                Widget::Anchor(__('Edit Section'), SYMPHONY_URL . '/blueprints/sections/edit/' . $section_id . '/', __('Edit Section Configuration'), 'button')\n            );\n        } else {\n            $this->appendSubheading(__('Untitled'));\n        }\n\n        // Build filtered breadcrumb [#1378}\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor($section->get('name'), SYMPHONY_URL . '/publish/' . $this->_context['section_handle'] . '/' . $this->getFilterString()),\n        ));\n\n        $this->Form->appendChild(Widget::Input('MAX_FILE_SIZE', Symphony::Configuration()->get('max_upload_size', 'admin'), 'hidden'));\n\n        // If there is post data floating around, due to errors, create an entry object\n        if (isset($_POST['fields'])) {\n            $entry = EntryManager::create();\n            $entry->set('section_id', $section_id);\n            $entry->setDataFromPost($_POST['fields'], $error, true);\n\n            // Brand new entry, so need to create some various objects\n        } else {\n            $entry = EntryManager::create();\n            $entry->set('section_id', $section_id);\n        }\n\n        // Check if there is a field to prepopulate\n        if (isset($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                $this->Form->prependChild(Widget::Input(\n                    \"prepopulate[{$field_id}]\",\n                    rawurlencode($value),\n                    'hidden'\n                ));\n\n                // The actual pre-populating should only happen if there is not existing fields post data\n                if (!isset($_POST['fields']) && $field = FieldManager::fetch($field_id)) {\n                    $entry->setData(\n                        $field->get('id'),\n                        $field->processRawFieldData($value, $error, $message, true)\n                    );\n                }\n            }\n        }\n\n        $primary = new XMLElement('fieldset');\n        $primary->setAttribute('class', 'primary column');\n\n        if ((!is_array($main_fields) || empty($main_fields)) && (!is_array($sidebar_fields) || empty($sidebar_fields))) {\n            $message = __('Fields must be added to this section before an entry can be created.');\n\n            if (Symphony::Author()->isDeveloper()) {\n                $message .= ' <a href=\"' . SYMPHONY_URL . '/blueprints/sections/edit/' . $section->get('id') . '/\" accesskey=\"c\">'\n                . __('Add fields')\n                . '</a>';\n            }\n\n            $this->pageAlert($message, Alert::ERROR);\n        } else {\n            if (is_array($main_fields) && !empty($main_fields)) {\n                foreach ($main_fields as $field) {\n                    $primary->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($primary);\n            }\n\n            if (is_array($sidebar_fields) && !empty($sidebar_fields)) {\n                $sidebar = new XMLElement('fieldset');\n                $sidebar->setAttribute('class', 'secondary column');\n\n                foreach ($sidebar_fields as $field) {\n                    $sidebar->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($sidebar);\n            }\n\n            $div = new XMLElement('div');\n            $div->setAttribute('class', 'actions');\n            $div->appendChild(Widget::Input('action[save]', __('Create Entry'), 'submit', array('accesskey' => 's')));\n\n            $this->Form->appendChild($div);\n\n            // Create a Drawer for Associated Sections\n            $this->prepareAssociationsDrawer($section);\n        }\n    }\n\n    public function __actionNew()\n    {\n        if (is_array($_POST['action']) && (array_key_exists('save', $_POST['action']) || array_key_exists('done', $_POST['action']))) {\n            $section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle']);\n\n            if (!$section = SectionManager::fetch($section_id)) {\n                Administration::instance()->throwCustomError(\n                    __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                    __('Unknown Section'),\n                    Page::HTTP_STATUS_NOT_FOUND\n                );\n            }\n\n            $entry = EntryManager::create();\n            $entry->set('author_id', Symphony::Author()->get('id'));\n            $entry->set('section_id', $section_id);\n            $entry->set('creation_date', DateTimeObj::get('c'));\n            $entry->set('modification_date', DateTimeObj::get('c'));\n\n            $fields = $_POST['fields'];\n\n            // Combine FILES and POST arrays, indexed by their custom field handles\n            if (isset($_FILES['fields'])) {\n                $filedata = General::processFilePostData($_FILES['fields']);\n\n                foreach ($filedata as $handle => $data) {\n                    if (!isset($fields[$handle])) {\n                        $fields[$handle] = $data;\n                    } elseif (isset($data['error']) && $data['error'] == UPLOAD_ERR_NO_FILE) {\n                        $fields[$handle] = null;\n                    } else {\n                        foreach ($data as $ii => $d) {\n                            if (isset($d['error']) && $d['error'] == UPLOAD_ERR_NO_FILE) {\n                                $fields[$handle][$ii] = null;\n                            } elseif (is_array($d) && !empty($d)) {\n                                foreach ($d as $key => $val) {\n                                    $fields[$handle][$ii][$key] = $val;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Initial checks to see if the Entry is ok\n            if (Entry::__ENTRY_FIELD_ERROR__ == $entry->checkPostData($fields, $this->_errors)) {\n                $this->pageAlert(__('Some errors were encountered while attempting to save.'), Alert::ERROR);\n\n                // Secondary checks, this will actually process the data and attempt to save\n            } elseif (Entry::__ENTRY_OK__ != $entry->setDataFromPost($fields, $errors)) {\n                foreach ($errors as $field_id => $message) {\n                    $this->pageAlert($message, Alert::ERROR);\n                }\n\n                // Everything is awesome. Dance.\n            } else {\n                /**\n                 * Just prior to creation of an Entry\n                 *\n                 * @delegate EntryPreCreate\n                 * @param string $context\n                 * '/publish/new/'\n                 * @param Section $section\n                 * @param Entry $entry\n                 * @param array $fields\n                 */\n                Symphony::ExtensionManager()->notifyMembers('EntryPreCreate', '/publish/new/', array('section' => $section, 'entry' => &$entry, 'fields' => &$fields));\n\n                // Check to see if the dancing was premature\n                if (!$entry->commit()) {\n                    $this->pageAlert(null, Alert::ERROR);\n                } else {\n                    /**\n                     * Creation of an Entry. New Entry object is provided.\n                     *\n                     * @delegate EntryPostCreate\n                     * @param string $context\n                     * '/publish/new/'\n                     * @param Section $section\n                     * @param Entry $entry\n                     * @param array $fields\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPostCreate', '/publish/new/', array('section' => $section, 'entry' => $entry, 'fields' => $fields));\n\n                    $prepopulate_querystring = $this->getPrepopulateString();\n                    redirect(sprintf(\n                        '%s/publish/%s/edit/%d/created/%s',\n                        SYMPHONY_URL,\n                        $this->_context['section_handle'],\n                        $entry->get('id'),\n                        (!empty($prepopulate_querystring) ? $prepopulate_querystring : null)\n                    ));\n                }\n            }\n        }\n    }\n\n    public function __viewEdit()\n    {\n        if (!$section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle'])) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n\n        $section = SectionManager::fetch($section_id);\n        $entry_id = intval($this->_context['entry_id']);\n        $base = '/publish/'.$this->_context['section_handle'] . '/';\n        $new_link = $base . 'new/';\n        $filter_link = $base;\n\n        EntryManager::setFetchSorting('id', 'DESC');\n\n        if (!$existingEntry = EntryManager::fetch($entry_id)) {\n            Administration::instance()->throwCustomError(\n                __('Unknown Entry'),\n                __('The Entry, %s, could not be found.', array($entry_id)),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n        $existingEntry = $existingEntry[0];\n\n        // If there is post data floating around, due to errors, create an entry object\n        if (isset($_POST['fields'])) {\n            $fields = $_POST['fields'];\n\n            $entry = EntryManager::create();\n            $entry->set('id', $entry_id);\n            $entry->set('author_id', $existingEntry->get('author_id'));\n            $entry->set('section_id', $existingEntry->get('section_id'));\n            $entry->set('creation_date', $existingEntry->get('creation_date'));\n            $entry->set('modification_date', $existingEntry->get('modification_date'));\n            $entry->setDataFromPost($fields, $errors, true);\n\n            // Editing an entry, so need to create some various objects\n        } else {\n            $entry = $existingEntry;\n            $fields = array();\n\n            if (!$section) {\n                $section = SectionManager::fetch($entry->get('section_id'));\n            }\n        }\n\n        /**\n         * Just prior to rendering of an Entry edit form.\n         *\n         * @delegate EntryPreRender\n         * @param string $context\n         * '/publish/edit/'\n         * @param Section $section\n         * @param Entry $entry\n         * @param array $fields\n         */\n        Symphony::ExtensionManager()->notifyMembers('EntryPreRender', '/publish/edit/', array(\n            'section' => $section,\n            'entry' => &$entry,\n            'fields' => $fields\n        ));\n\n        // Iterate over the `prepopulate` parameters to build a URL\n        // to remember this state for Create New, View all Entries and\n        // Breadcrumb links. If `prepopulate` doesn't exist, this will\n        // just use the standard pages (ie. no filtering)\n        if (isset($_REQUEST['prepopulate'])) {\n            $new_link .= $this->getPrepopulateString();\n            $filter_link .= $this->getFilterString();\n        }\n\n        if (isset($this->_context['flag'])) {\n            // These flags are only relevant if there are no errors\n            if (empty($this->_errors)) {\n                $time = Widget::Time();\n\n                switch ($this->_context['flag']) {\n                    case 'saved':\n                        $message = __('Entry updated at %s.', array($time->generate()));\n                        break;\n                    case 'created':\n                        $message = __('Entry created at %s.', array($time->generate()));\n                }\n\n                $this->pageAlert(\n                    $message\n                    . ' <a href=\"' . SYMPHONY_URL . $new_link . '\" accesskey=\"c\">'\n                    . __('Create another?')\n                    . '</a> <a href=\"' . SYMPHONY_URL . $filter_link . '\" accesskey=\"a\">'\n                    . __('View all Entries')\n                    . '</a>',\n                    Alert::SUCCESS\n                );\n            }\n        }\n\n        // Determine the page title\n        $field_id = Symphony::Database()->fetchVar('id', 0, sprintf(\"\n            SELECT `id`\n            FROM `tbl_fields`\n            WHERE `parent_section` = %d\n            ORDER BY `sortorder` LIMIT 1\",\n            $section->get('id')\n        ));\n        if (!is_null($field_id)) {\n            $field = FieldManager::fetch($field_id);\n        }\n\n        if ($field) {\n            $title = $field->prepareReadableValue($existingEntry->getData($field->get('id')), $entry_id, true);\n        } else {\n            $title = '';\n        }\n\n        if (trim($title) == '') {\n            $title = __('Untitled');\n        }\n\n        // Check if there is a field to prepopulate\n        if (isset($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                $this->Form->prependChild(Widget::Input(\n                    \"prepopulate[{$field_id}]\",\n                    rawurlencode($value),\n                    'hidden'\n                ));\n            }\n        }\n\n        $this->setPageType('form');\n        $this->Form->setAttribute('enctype', 'multipart/form-data');\n        $this->setTitle(__('%1$s &ndash; %2$s &ndash; %3$s', array($title, $section->get('name'), __('Symphony'))));\n\n        $sidebar_fields = $section->fetchFields(null, 'sidebar');\n        $main_fields = $section->fetchFields(null, 'main');\n\n        if (!empty($sidebar_fields) && !empty($main_fields)) {\n            $this->Form->setAttribute('class', 'two columns');\n        } else {\n            $this->Form->setAttribute('class', 'columns');\n        }\n\n        // Only show the Edit Section button if the Author is a developer. #938 ^BA\n        if (Symphony::Author()->isDeveloper()) {\n            $this->appendSubheading($title, Widget::Anchor(__('Edit Section'), SYMPHONY_URL . '/blueprints/sections/edit/' . $section_id . '/', __('Edit Section Configuration'), 'button'));\n        } else {\n            $this->appendSubheading($title);\n        }\n\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor($section->get('name'), SYMPHONY_URL . (isset($filter_link) ? $filter_link : $base)),\n        ));\n\n        $this->Form->appendChild(Widget::Input('MAX_FILE_SIZE', Symphony::Configuration()->get('max_upload_size', 'admin'), 'hidden'));\n\n        $primary = new XMLElement('fieldset');\n        $primary->setAttribute('class', 'primary column');\n\n        if ((!is_array($main_fields) || empty($main_fields)) && (!is_array($sidebar_fields) || empty($sidebar_fields))) {\n            $message = __('Fields must be added to this section before an entry can be created.');\n\n            if (Symphony::Author()->isDeveloper()) {\n                $message .= ' <a href=\"' . SYMPHONY_URL . '/blueprints/sections/edit/' . $section->get('id') . '/\" accesskey=\"c\">'\n                . __('Add fields')\n                . '</a>';\n            }\n\n            $this->pageAlert($message, Alert::ERROR);\n        } else {\n            if (is_array($main_fields) && !empty($main_fields)) {\n                foreach ($main_fields as $field) {\n                    $primary->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($primary);\n            }\n\n            if (is_array($sidebar_fields) && !empty($sidebar_fields)) {\n                $sidebar = new XMLElement('fieldset');\n                $sidebar->setAttribute('class', 'secondary column');\n\n                foreach ($sidebar_fields as $field) {\n                    $sidebar->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($sidebar);\n            }\n\n            $div = new XMLElement('div');\n            $div->setAttribute('class', 'actions');\n            $div->appendChild(Widget::Input('action[save]', __('Save Changes'), 'submit', array('accesskey' => 's')));\n\n            $button = new XMLElement('button', __('Delete'));\n            $button->setAttributeArray(array('name' => 'action[delete]', 'class' => 'button confirm delete', 'title' => __('Delete this entry'), 'type' => 'submit', 'accesskey' => 'd', 'data-message' => __('Are you sure you want to delete this entry?')));\n            $div->appendChild($button);\n\n            $this->Form->appendChild($div);\n\n            // Create a Drawer for Associated Sections\n            $this->prepareAssociationsDrawer($section);\n        }\n    }\n\n    public function __actionEdit()\n    {\n        $entry_id = intval($this->_context['entry_id']);\n\n        if (is_array($_POST['action']) && (array_key_exists('save', $_POST['action']) || array_key_exists(\"done\", $_POST['action']))) {\n            if (!$ret = EntryManager::fetch($entry_id)) {\n                Administration::instance()->throwCustomError(\n                    __('The Entry, %s, could not be found.', array($entry_id)),\n                    __('Unknown Entry'),\n                    Page::HTTP_STATUS_NOT_FOUND\n                );\n            }\n\n            $entry = $ret[0];\n\n            $section = SectionManager::fetch($entry->get('section_id'));\n\n            $post = General::getPostData();\n            $fields = $post['fields'];\n\n            // Initial checks to see if the Entry is ok\n            if (Entry::__ENTRY_FIELD_ERROR__ == $entry->checkPostData($fields, $this->_errors)) {\n                $this->pageAlert(__('Some errors were encountered while attempting to save.'), Alert::ERROR);\n\n                // Secondary checks, this will actually process the data and attempt to save\n            } elseif (Entry::__ENTRY_OK__ != $entry->setDataFromPost($fields, $errors)) {\n                foreach ($errors as $field_id => $message) {\n                    $this->pageAlert($message, Alert::ERROR);\n                }\n\n                // Everything is awesome. Dance.\n            } else {\n                /**\n                 * Just prior to editing of an Entry.\n                 *\n                 * @delegate EntryPreEdit\n                 * @param string $context\n                 * '/publish/edit/'\n                 * @param Section $section\n                 * @param Entry $entry\n                 * @param array $fields\n                 */\n                Symphony::ExtensionManager()->notifyMembers('EntryPreEdit', '/publish/edit/', array('section' => $section, 'entry' => &$entry, 'fields' => $fields));\n\n                // Check to see if the dancing was premature\n                if (!$entry->commit()) {\n                    $this->pageAlert(null, Alert::ERROR);\n                } else {\n                    /**\n                     * Just after the editing of an Entry\n                     *\n                     * @delegate EntryPostEdit\n                     * @param string $context\n                     * '/publish/edit/'\n                     * @param Section $section\n                     * @param Entry $entry\n                     * @param array $fields\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPostEdit', '/publish/edit/', array('section' => $section, 'entry' => $entry, 'fields' => $fields));\n\n                    redirect(sprintf(\n                        '%s/publish/%s/edit/%d/saved/%s',\n                        SYMPHONY_URL,\n                        $this->_context['section_handle'],\n                        $entry->get('id'),\n                        $this->getPrepopulateString()\n                    ));\n                }\n            }\n        } elseif (is_array($_POST['action']) && array_key_exists('delete', $_POST['action']) && is_numeric($entry_id)) {\n            /**\n             * Prior to deletion of entries. An array of Entry ID's is provided which\n             * can be manipulated. This delegate was renamed from `Delete` to `EntryPreDelete`\n             * in Symphony 2.3.\n             *\n             * @delegate EntryPreDelete\n             * @param string $context\n             * '/publish/'\n             * @param array $entry_id\n             *    An array of Entry ID's passed by reference\n             */\n            $checked = array($entry_id);\n            Symphony::ExtensionManager()->notifyMembers('EntryPreDelete', '/publish/', array('entry_id' => &$checked));\n\n            EntryManager::delete($checked);\n\n            /**\n             * After the deletion of entries, this delegate provides an array of Entry ID's\n             * that were deleted.\n             *\n             * @since Symphony 2.3\n             * @delegate EntryPostDelete\n             * @param string $context\n             * '/publish/'\n             * @param array $entry_id\n             *  An array of Entry ID's that were deleted.\n             */\n            Symphony::ExtensionManager()->notifyMembers('EntryPostDelete', '/publish/', array('entry_id' => $checked));\n\n            redirect(SYMPHONY_URL . '/publish/'.$this->_context['section_handle'].'/');\n        }\n    }\n\n    /**\n     * Given a Field and Entry object, this function will wrap\n     * the Field's displayPublishPanel result with a div that\n     * contains some contextual information such as the Field ID,\n     * the Field handle and whether it is required or not.\n     *\n     * @param Field $field\n     * @param Entry $entry\n     * @return XMLElement\n     */\n    private function __wrapFieldWithDiv(Field $field, Entry $entry)\n    {\n        $is_hidden = $this->isFieldHidden($field);\n        $div = new XMLElement('div', null, array('id' => 'field-' . $field->get('id'), 'class' => 'field field-'.$field->handle().($field->get('required') == 'yes' ? ' required' : '').($is_hidden === true ? ' irrelevant' : '')));\n\n        $field->setAssociationContext($div);\n\n        $field->displayPublishPanel(\n            $div, $entry->getData($field->get('id')),\n            (isset($this->_errors[$field->get('id')]) ? $this->_errors[$field->get('id')] : null),\n            null, null, (is_numeric($entry->get('id')) ? $entry->get('id') : null)\n        );\n\n        /**\n         * Allows developers modify the field before it is rendered in the publish\n         * form. Passes the `Field` object, `Entry` object, the `XMLElement` div and\n         * any errors for the entire `Entry`. Only the `$div` element\n         * will be altered before appending to the page, the rest are read only.\n         *\n         * @since Symphony 2.5.0\n         * @delegate ModifyFieldPublishWidget\n         * @param string $context\n         * '/backend/'\n         * @param Field $field\n         * @param Entry $entry\n         * @param array $errors\n         * @param Widget $widget\n         */\n        Symphony::ExtensionManager()->notifyMembers('ModifyFieldPublishWidget', '/backend/', array(\n            'field' => $field,\n            'entry' => $entry,\n            'errors' => $this->_errors,\n            'widget' => &$div\n        ));\n\n        return $div;\n    }\n\n    /**\n     * Check whether the given `$field` will be hidden because it's been\n     * prepopulated.\n     *\n     * @param  Field  $field\n     * @return boolean\n     */\n    public function isFieldHidden(Field $field)\n    {\n        if ($field->get('hide_when_prepopulated') == 'yes') {\n            if (isset($_REQUEST['prepopulate'])) {\n                foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                    if ($field_id == $field->get('id')) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Prepare a Drawer to visualize section associations\n     *\n     * @param  Section $section The current Section object\n     * @throws InvalidArgumentException\n     * @throws Exception\n     */\n    private function prepareAssociationsDrawer($section)\n    {\n        $entry_id = (!is_null($this->_context['entry_id'])) ? $this->_context['entry_id'] : null;\n        $show_entries = Symphony::Configuration()->get('association_maximum_rows', 'symphony');\n\n        if (is_null($entry_id) && !isset($_GET['prepopulate']) || is_null($show_entries) || $show_entries == 0) {\n            return;\n        }\n\n        $parent_associations = SectionManager::fetchParentAssociations($section->get('id'), true);\n        $child_associations = SectionManager::fetchChildAssociations($section->get('id'), true);\n        $content = null;\n        $drawer_position = 'vertical-right';\n\n        /**\n         * Prepare Associations Drawer from an Extension\n         *\n         * @since Symphony 2.3.3\n         * @delegate PrepareAssociationsDrawer\n         * @param string $context\n         * '/publish/'\n         * @param integer $entry_id\n         *  The entry ID or null\n         * @param array $parent_associations\n         *  Array of Sections\n         * @param array $child_associations\n         *  Array of Sections\n         * @param string $drawer_position\n         *  The position of the Drawer, defaults to `vertical-right`. Available\n         *  values of `vertical-left, `vertical-right` and `horizontal`\n         */\n        Symphony::ExtensionManager()->notifyMembers('PrepareAssociationsDrawer', '/publish/', array(\n            'entry_id' => $entry_id,\n            'parent_associations' => &$parent_associations,\n            'child_associations' => &$child_associations,\n            'content' => &$content,\n            'drawer-position' => &$drawer_position\n        ));\n\n        // If there are no associations, return now.\n        if (\n            (is_null($parent_associations) || empty($parent_associations))\n            &&\n            (is_null($child_associations) || empty($child_associations))\n        ) {\n            return;\n        }\n\n        if (!($content instanceof XMLElement)) {\n            $content = new XMLElement('div', null, array('class' => 'content'));\n            $content->setSelfClosingTag(false);\n\n            // backup global sorting\n            $sorting = EntryManager::getFetchSorting();\n\n            // Process Parent Associations\n            if (!is_null($parent_associations) && !empty($parent_associations)) {\n                foreach ($parent_associations as $as) {\n                    if (empty($as['parent_section_field_id'])) {\n                        continue; \n                    }\n                    if ($field = FieldManager::fetch($as['parent_section_field_id'])) {\n\n                        // Get the related section\n                        $parent_section = SectionManager::fetch($as['child_parent_id']);\n\n                        if (!($parent_section instanceof Section)) {\n                            continue;\n                        }\n\n                        // set global sorting for associated section\n                        EntryManager::setFetchSorting(\n                            $parent_section->getSortingField(),\n                            $parent_section->getSortingOrder()\n                        );\n\n                        if (isset($_GET['prepopulate'])) {\n                            $prepopulate_field = key($_GET['prepopulate']);\n                        }\n\n                        // get associated entries if entry exists,\n                        if ($entry_id) {\n                            $entry_ids = $field->findParentRelatedEntries($as['child_section_field_id'], $entry_id);\n\n                            // get prepopulated entry otherwise\n                        } elseif (isset($_GET['prepopulate'])) {\n                            $entry_ids = array(intval(current($_GET['prepopulate'])));\n                        } else {\n                            $entry_ids = array();\n                        }\n\n                        // Use $schema for perf reasons\n                        $schema = array($field->get('element_name'));\n                        $where = (!empty($entry_ids)) ? sprintf(' AND `e`.`id` IN (%s)', implode(', ', $entry_ids)) : null;\n                        $entries = (!empty($entry_ids) || isset($_GET['prepopulate']) && $field->get('id') === $prepopulate_field)\n                            ? EntryManager::fetchByPage(1, $as['parent_section_id'], $show_entries, $where, null, false, false, true, $schema)\n                            : array();\n                        $has_entries = !empty($entries) && $entries['total-entries'] != 0;\n\n                        if ($has_entries) {\n                            $element = new XMLElement('section', null, array('class' => 'association parent'));\n                            $header = new XMLElement('header');\n                            $header->appendChild(new XMLElement('p', __('Linked to %s in', array('<a class=\"association-section\" href=\"' . SYMPHONY_URL . '/publish/' . $as['handle'] . '/\">' . $as['name'] . '</a>'))));\n                            $element->appendChild($header);\n\n                            $ul = new XMLElement('ul', null, array(\n                                'class' => 'association-links',\n                                'data-section-id' => $as['child_section_id'],\n                                'data-association-ids' => implode(', ', $entry_ids)\n                            ));\n\n                            foreach ($entries['records'] as $e) {\n                                // let the field create the mark up\n                                $li = $field->prepareAssociationsDrawerXMLElement($e, $as);\n                                // add it to the unordered list\n                                $ul->appendChild($li);\n                            }\n\n                            $element->appendChild($ul);\n                            $content->appendChild($element);\n                        }\n                    }\n                }\n            }\n\n            // Process Child Associations\n            if (!is_null($child_associations) && !empty($child_associations)) {\n                foreach ($child_associations as $as) {\n                    // Get the related section\n                    $child_section = SectionManager::fetch($as['child_section_id']);\n\n                    if (!($child_section instanceof Section)) {\n                        continue;\n                    }\n\n                    // set global sorting for associated section\n                    EntryManager::setFetchSorting(\n                        $child_section->getSortingField(),\n                        $child_section->getSortingOrder()\n                    );\n\n                    // Get the visible field instance (using the sorting field, this is more flexible than visibleColumns())\n                    // Get the link field instance\n                    $visible_field   = current($child_section->fetchVisibleColumns());\n                    $relation_field  = FieldManager::fetch($as['child_section_field_id']);\n\n                    // Get entries, using $schema for performance reasons.\n                    if (!is_null($parent_section_field_id)) {\n                        $entry_ids = $relation_field->findRelatedEntries($entry_id, $as['parent_section_field_id']);\n                    } else {\n                        $entry_ids = $relation_field->findRelatedEntries($entry_id, $as['child_section_field_id']);\n                    }\n                    $schema = $visible_field ? array($visible_field->get('element_name')) : array();\n                    $where = sprintf(' AND `e`.`id` IN (%s)', implode(', ', $entry_ids));\n\n                    $entries = (!empty($entry_ids)) ? EntryManager::fetchByPage(1, $as['child_section_id'], $show_entries, $where, null, false, false, true, $schema) : array();\n                    $has_entries = !empty($entries) && $entries['total-entries'] != 0;\n\n                    // Build the HTML of the relationship\n                    $element = new XMLElement('section', null, array('class' => 'association child'));\n                    $header = new XMLElement('header');\n                    $filter = '?filter[' . $relation_field->get('element_name') . ']=' . $entry_id;\n                    $prepopulate = '?prepopulate[' . $as['child_section_field_id'] . ']=' . $entry_id;\n\n                    // Create link with filter or prepopulate\n                    $link = SYMPHONY_URL . '/publish/' . $as['handle'] . '/' . $filter;\n                    $a = new XMLElement('a', $as['name'], array(\n                        'class' => 'association-section',\n                        'href' => $link\n                    ));\n\n                    // Create new entries\n                    $create = new XMLElement('a', __('Create New'), array(\n                        'class' => 'button association-new',\n                        'href' => SYMPHONY_URL . '/publish/' . $as['handle'] . '/new/' . $prepopulate\n                    ));\n\n                    // Display existing entries\n                    if ($has_entries) {\n                        $header->appendChild(new XMLElement('p', __('Links in %s', array($a->generate()))));\n\n                        $ul = new XMLElement('ul', null, array(\n                            'class' => 'association-links',\n                            'data-section-id' => $as['child_section_id'],\n                            'data-association-ids' => implode(', ', $entry_ids)\n                        ));\n\n                        foreach ($entries['records'] as $key => $e) {\n                            // let the first visible field create the mark up\n                            if ($visible_field) {\n                                $li = $visible_field->prepareAssociationsDrawerXMLElement($e, $as, $prepopulate);\n                            }\n                            // or use the system:id if no visible field exists.\n                            else {\n                                $li = Field::createAssociationsDrawerXMLElement($e->get('id'), $e, $as, $prepopulate);\n                            }\n\n                            // add it to the unordered list\n                            $ul->appendChild($li);\n                        }\n\n                        $element->appendChild($ul);\n\n                        // If we are only showing 'some' of the entries, then show this on the UI\n                        if ($entries['total-entries'] > $show_entries) {\n                            $pagination = new XMLElement('li', null, array(\n                                'class' => 'association-more',\n                                'data-current-page' => '1',\n                                'data-total-pages' => ceil($entries['total-entries'] / $show_entries),\n                                'data-total-entries' => $entries['total-entries']\n                            ));\n                            $counts = new XMLElement('a', __('Show more entries'), array(\n                                'href' => $link\n                            ));\n\n                            $pagination->appendChild($counts);\n                            $ul->appendChild($pagination);\n                        }\n\n                        // No entries\n                    } else {\n                        $element->setAttribute('class', 'association child empty');\n                        $header->appendChild(new XMLElement('p', __('No links in %s', array($a->generate()))));\n                    }\n\n                    $header->appendChild($create);\n                    $element->prependChild($header);\n                    $content->appendChild($element);\n                }\n            }\n\n            // reset global sorting\n            EntryManager::setFetchSorting(\n                $sorting->field,\n                $sorting->direction\n            );\n        }\n\n        $drawer = Widget::Drawer('section-associations', __('Show Associations'), $content);\n        $this->insertDrawer($drawer, $drawer_position, 'prepend');\n    }\n\n    /**\n     * If this entry is being prepopulated, this function will return the prepopulated\n     * fields and values as a query string.\n     *\n     * @since Symphony 2.5.2\n     * @return string\n     */\n    public function getPrepopulateString()\n    {\n        $prepopulate_querystring = '';\n\n        if (isset($_REQUEST['prepopulate']) && is_array($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                // Properly decode and re-encode value for output\n                $value = rawurlencode(rawurldecode($value));\n                $prepopulate_querystring .= sprintf(\"prepopulate[%s]=%s&\", $field_id, $value);\n            }\n            $prepopulate_querystring = trim($prepopulate_querystring, '&');\n        }\n\n        // This is to prevent the value being interpreted as an additional GET\n        // parameter. eg. prepopulate[cat]=Minx&June, would come through as:\n        // $_GET['cat'] = Minx\n        // $_GET['June'] = ''\n        $prepopulate_querystring = preg_replace(\"/&amp;$/\", '', $prepopulate_querystring);\n\n        return $prepopulate_querystring ? '?' . $prepopulate_querystring : null;\n    }\n\n    /**\n     * If the entry is being prepopulated, we may want to filter other views by this entry's\n     * value. This function will create that filter query string.\n     *\n     * @since Symphony 2.5.2\n     * @return string\n     */\n    public function getFilterString()\n    {\n        $filter_querystring = '';\n\n        if (isset($_REQUEST['prepopulate']) && is_array($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                $handle = FieldManager::fetchHandleFromID($field_id);\n                // Properly decode and re-encode value for output\n                $value = rawurlencode(rawurldecode($value));\n                $filter_querystring .= sprintf('filter[%s]=%s&', $handle, $value);\n            }\n            $filter_querystring = trim($filter_querystring, '&');\n        }\n\n        // This is to prevent the value being interpreted as an additional GET\n        // parameter. eg. filter[cat]=Minx&June, would come through as:\n        // $_GET['cat'] = Minx\n        // $_GET['June'] = ''\n        $filter_querystring = preg_replace(\"/&amp;$/\", '', $filter_querystring);\n\n        return $filter_querystring ? '?' . $filter_querystring : null;\n    }\n}\n", "<?php\n\n/**\n * @package toolkit\n */\n/**\n * The AdministrationPage class represents a Symphony backend page.\n * It extends the HTMLPage class and unlike the Frontend, is generated\n * using a number XMLElement objects. Instances of this class override\n * the view, switchboard and action functions to construct the page. These\n * functions act as pseudo MVC, with the switchboard being controller,\n * and the view/action being the view.\n */\n\nclass AdministrationPage extends HTMLPage\n{\n    /**\n     * An array of `Alert` objects used to display page level\n     * messages to Symphony backend users one by one. Prior to Symphony 2.3\n     * this variable only held a single `Alert` object.\n     * @var array\n     */\n    public $Alert = array();\n\n    /**\n     * As the name suggests, a `<div>` that holds the following `$Header`,\n     * `$Contents` and `$Footer`.\n     * @var XMLElement\n     */\n    public $Wrapper = null;\n\n    /**\n     * A `<div>` that contains the header of a Symphony backend page, which\n     * typically contains the Site title and the navigation.\n     * @var XMLElement\n     */\n    public $Header = null;\n\n    /**\n     * A `<div>` that contains the breadcrumbs, the page title and some contextual\n     * actions (e.g. \"Create new\").\n     * @since Symphony 2.3\n     * @var XMLElement\n     */\n    public $Context = null;\n\n    /**\n     * An object that stores the markup for the breadcrumbs and is only used\n     * internally.\n     * @since Symphony 2.3\n     * @var XMLElement\n     */\n    public $Breadcrumbs = null;\n\n    /**\n     * An array of Drawer widgets for the current page\n     * @since Symphony 2.3\n     * @var array\n     */\n    public $Drawer = array();\n\n    /**\n     * A `<div>` that contains the content of a Symphony backend page.\n     * @var XMLElement\n     */\n    public $Contents = null;\n\n    /**\n     * An associative array of the navigation where the key is the group\n     * index, and the value is an associative array of 'name', 'index' and\n     * 'children'. Name is the name of the this group, index is the same as\n     * the key and children is an associative array of navigation items containing\n     * the keys 'link', 'name' and 'visible'. In Symphony, all navigation items\n     * are contained within a group, and the group has no 'default' link, therefore\n     * it is up to the children to provide the link to pages. This link should be\n     * relative to the Symphony path, although it is possible to provide an\n     * absolute link by providing a key, 'relative' with the value false.\n     * @var array\n     */\n    public $_navigation = array();\n\n    /**\n     *  An associative array describing this pages context. This\n     *  can include the section handle, the current entry_id, the page\n     *  name and any flags such as 'saved' or 'created'. This variable\n     *  often provided in delegates so extensions can manipulate based\n     *  off the current context or add new keys.\n     * @var array\n     */\n    public $_context = null;\n\n    /**\n     * The class attribute of the `<body>` element for this page. Defaults\n     * to an empty string\n     * @var string\n     */\n    private $_body_class = '';\n\n    /**\n     * Constructor calls the parent constructor to set up\n     * the basic HTML, Head and Body `XMLElement`'s. This function\n     * also sets the `XMLElement` element style to be HTML, instead of XML\n     */\n    public function __construct()\n    {\n        parent::__construct();\n\n        $this->Html->setElementStyle('html');\n    }\n\n    /**\n     * Specifies the type of page that being created. This is used to\n     * trigger various styling hooks. If your page is mainly a form,\n     * pass 'form' as the parameter, if it's displaying a single entry,\n     * pass 'single'. If any other parameter is passed, the 'index'\n     * styling will be applied.\n     *\n     * @param string $type\n     *  Accepts 'form' or 'single', any other `$type` will trigger 'index'\n     *  styling.\n     */\n    public function setPageType($type = 'form')\n    {\n        $this->setBodyClass($type == 'form' || $type == 'single' ? 'single' : 'index');\n    }\n\n    /**\n     * Setter function to set the class attribute on the `<body>` element.\n     * This function will respect any previous classes that have been added\n     * to this `<body>`\n     *\n     * @param string $class\n     *  The string of the classname, multiple classes can be specified by\n     *  uses a space separator\n     */\n    public function setBodyClass($class)\n    {\n        // Prevents duplicate \"index\" classes\n        if (!isset($this->_context['page']) || $this->_context['page'] !== 'index' || $class !== 'index') {\n            $this->_body_class .= $class;\n        }\n    }\n\n    /**\n     * Accessor for `$this->_context` which includes contextual information\n     * about the current page such as the class, file location or page root.\n     * This information varies depending on if the page is provided by an\n     * extension, is for the publish area, is the login page or any other page\n     *\n     * @since Symphony 2.3\n     * @return array\n     */\n    public function getContext()\n    {\n        return $this->_context;\n    }\n\n    /**\n     * Given a `$message` and an optional `$type`, this function will\n     * add an Alert instance into this page's `$this->Alert` property.\n     * Since Symphony 2.3, there may be more than one `Alert` per page.\n     * Unless the Alert is an Error, it is required the `$message` be\n     * passed to this function.\n     *\n     * @param string $message\n     *  The message to display to users\n     * @param string $type\n     *  An Alert constant, being `Alert::NOTICE`, `Alert::ERROR` or\n     *  `Alert::SUCCESS`. The differing types will show the error\n     *  in a different style in the backend. If omitted, this defaults\n     *  to `Alert::NOTICE`.\n     * @throws Exception\n     */\n    public function pageAlert($message = null, $type = Alert::NOTICE)\n    {\n        if (is_null($message) && $type == Alert::ERROR) {\n            $message = __('There was a problem rendering this page. Please check the activity log for more details.');\n        } else {\n            $message = __($message);\n        }\n\n        if (strlen(trim($message)) == 0) {\n            throw new Exception(__('A message must be supplied unless the alert is of type Alert::ERROR'));\n        }\n\n        $this->Alert[] = new Alert($message, $type);\n    }\n\n    /**\n     * Appends the heading of this Symphony page to the Context element.\n     * Action buttons can be provided (e.g. \"Create new\") as second parameter.\n     *\n     * @since Symphony 2.3\n     * @param string $value\n     *  The heading text\n     * @param array|XMLElement|string $actions\n     *  Some contextual actions to append to the heading, they can be provided as\n     *  an array of XMLElements or strings. Traditionally Symphony uses this to append\n     *  a \"Create new\" link to the Context div.\n     */\n    public function appendSubheading($value, $actions = null)\n    {\n        if (!is_array($actions) && $actions) { // Backward compatibility\n            $actions = array($actions);\n        }\n\n        if (!empty($actions)) {\n            foreach ($actions as $a) {\n                $this->insertAction($a);\n            }\n        }\n\n        $this->Breadcrumbs->appendChild(new XMLElement('h2', $value, array('role' => 'heading', 'id' => 'symphony-subheading')));\n    }\n\n    /**\n     * This function allows a user to insert an Action button to the page.\n     * It accepts an `XMLElement` (which should be of the `Anchor` type),\n     * an optional parameter `$prepend`, which when `true` will add this\n     * action before any existing actions.\n     *\n     * @since Symphony 2.3\n     * @see core.Widget#Anchor\n     * @param XMLElement $action\n     *  An Anchor element to add to the top of the page.\n     * @param boolean $append\n     *  If true, this will add the `$action` after existing actions, otherwise\n     *  it will be added before existing actions. By default this is `true`,\n     *  which will add the `$action` after current actions.\n     */\n    public function insertAction(XMLElement $action, $append = true)\n    {\n        $actions = $this->Context->getChildrenByName('ul');\n\n        // Actions haven't be added yet, create the element\n        if (empty($actions)) {\n            $ul = new XMLElement('ul', null, array('class' => 'actions'));\n            $this->Context->appendChild($ul);\n        } else {\n            $ul = current($actions);\n            $this->Context->replaceChildAt(1, $ul);\n        }\n\n        $li = new XMLElement('li', $action);\n\n        if ($append) {\n            $ul->prependChild($li);\n        } else {\n            $ul->appendChild($li);\n        }\n    }\n\n    /**\n     * Allows developers to specify a list of nav items that build the\n     * path to the current page or, in jargon, \"breadcrumbs\".\n     *\n     * @since Symphony 2.3\n     * @param array $values\n     *  An array of `XMLElement`'s or strings that compose the path. If breadcrumbs\n     *  already exist, any new item will be appended to the rightmost part of the\n     *  path.\n     */\n    public function insertBreadcrumbs(array $values)\n    {\n        if (empty($values)) {\n            return;\n        }\n\n        if ($this->Breadcrumbs instanceof XMLELement && count($this->Breadcrumbs->getChildrenByName('nav')) === 1) {\n            $nav = $this->Breadcrumbs->getChildrenByName('nav');\n            $nav = $nav[0];\n\n            $p = $nav->getChild(0);\n        } else {\n            $p = new XMLElement('p');\n            $nav = new XMLElement('nav');\n            $nav->appendChild($p);\n\n            $this->Breadcrumbs->prependChild($nav);\n        }\n\n        foreach ($values as $v) {\n            $p->appendChild($v);\n            $p->appendChild(new XMLElement('span', '&#8250;', array('class' => 'sep')));\n        }\n    }\n\n    /**\n     * Allows a Drawer element to added to the backend page in one of three\n     * positions, `horizontal`, `vertical-left` or `vertical-right`. The button\n     * to trigger the visibility of the drawer will be added after existing\n     * actions by default.\n     *\n     * @since Symphony 2.3\n     * @see core.Widget#Drawer\n     * @param XMLElement $drawer\n     *  An XMLElement representing the drawer, use `Widget::Drawer` to construct\n     * @param string $position\n     *  Where `$position` can be `horizontal`, `vertical-left` or\n     *  `vertical-right`. Defaults to `horizontal`.\n     * @param string $button\n     *  If not passed, a button to open/close the drawer will not be added\n     *  to the interface. Accepts 'prepend' or 'append' values, which will\n     *  add the button before or after existing buttons. Defaults to `prepend`.\n     *  If any other value is passed, no button will be added.\n     * @throws InvalidArgumentException\n     */\n    public function insertDrawer(XMLElement $drawer, $position = 'horizontal', $button = 'append')\n    {\n        $drawer->addClass($position);\n        $drawer->setAttribute('data-position', $position);\n        $drawer->setAttribute('role', 'complementary');\n        $this->Drawer[$position][] = $drawer;\n\n        if (in_array($button, array('prepend', 'append'))) {\n            $this->insertAction(\n                Widget::Anchor(\n                    $drawer->getAttribute('data-label'),\n                    '#' . $drawer->getAttribute('id'),\n                    null,\n                    'button drawer ' . $position\n                ),\n                ($button === 'append' ? true : false)\n            );\n        }\n    }\n\n    /**\n     * This function initialises a lot of the basic elements that make up a Symphony\n     * backend page such as the default stylesheets and scripts, the navigation and\n     * the footer. Any alerts are also appended by this function. `view()` is called to\n     * build the actual content of the page. The `InitialiseAdminPageHead` delegate\n     * allows extensions to add elements to the `<head>`.\n     *\n     * @see view()\n     * @uses InitialiseAdminPageHead\n     * @param array $context\n     *  An associative array describing this pages context. This\n     *  can include the section handle, the current entry_id, the page\n     *  name and any flags such as 'saved' or 'created'. This list is not exhaustive\n     *  and extensions can add their own keys to the array.\n     * @throws InvalidArgumentException\n     * @throws SymphonyErrorPage\n     */\n    public function build(array $context = array())\n    {\n        $this->_context = $context;\n\n        if (!$this->canAccessPage()) {\n            Administration::instance()->throwCustomError(\n                __('You are not authorised to access this page.'),\n                __('Access Denied'),\n                Page::HTTP_STATUS_UNAUTHORIZED\n            );\n        }\n\n        $this->Html->setDTD('<!DOCTYPE html>');\n        $this->Html->setAttribute('lang', Lang::get());\n        $this->addElementToHead(new XMLElement('meta', null, array('charset' => 'UTF-8')), 0);\n        $this->addElementToHead(new XMLElement('meta', null, array('http-equiv' => 'X-UA-Compatible', 'content' => 'IE=edge,chrome=1')), 1);\n        $this->addElementToHead(new XMLElement('meta', null, array('name' => 'viewport', 'content' => 'width=device-width, initial-scale=1')), 2);\n\n        // Add styles\n        $this->addStylesheetToHead(ASSETS_URL . '/css/symphony.min.css', 'screen', 2, false);\n\n        // Calculate timezone offset from UTC\n        $timezone = new DateTimeZone(Symphony::Configuration()->get('timezone', 'region'));\n        $datetime = new DateTime('now', $timezone);\n        $timezoneOffset = intval($timezone->getOffset($datetime)) / 60;\n\n        // Add scripts\n        $environment = array(\n\n            'root'     => URL,\n            'symphony' => SYMPHONY_URL,\n            'path'     => '/' . Symphony::Configuration()->get('admin-path', 'symphony'),\n            'route'    => getCurrentPage(),\n            'version'  => Symphony::Configuration()->get('version', 'symphony'),\n            'lang'     => Lang::get(),\n            'user'     => array(\n\n                'fullname' => Symphony::Author()->getFullName(),\n                'name'     => Symphony::Author()->get('first_name'),\n                'type'     => Symphony::Author()->get('user_type'),\n                'id'       => Symphony::Author()->get('id')\n            ),\n            'datetime' => array(\n\n                'formats'         => DateTimeObj::getDateFormatMappings(),\n                'timezone-offset' => $timezoneOffset\n            ),\n            'env' => array_merge(\n\n                array('page-namespace' => Symphony::getPageNamespace()),\n                $this->_context\n            )\n        );\n\n        $this->addElementToHead(\n            new XMLElement('script', json_encode($environment), array(\n                'type' => 'application/json',\n                'id' => 'environment'\n            )),\n            4\n        );\n\n        $this->addScriptToHead(ASSETS_URL . '/js/symphony.min.js', 6, false);\n\n        // Initialise page containers\n        $this->Wrapper = new XMLElement('div', null, array('id' => 'wrapper'));\n        $this->Header = new XMLElement('header', null, array('id' => 'header'));\n        $this->Context = new XMLElement('div', null, array('id' => 'context'));\n        $this->Breadcrumbs = new XMLElement('div', null, array('id' => 'breadcrumbs'));\n        $this->Contents = new XMLElement('div', null, array('id' => 'contents', 'role' => 'main'));\n        $this->Form = Widget::Form(Administration::instance()->getCurrentPageURL(), 'post', null, null, array('role' => 'form'));\n\n        /**\n         * Allows developers to insert items into the page HEAD. Use\n         * `Administration::instance()->Page` for access to the page object.\n         *\n         * @since In Symphony 2.3.2 this delegate was renamed from\n         *  `InitaliseAdminPageHead` to the correct spelling of\n         *  `InitialiseAdminPageHead`. The old delegate is supported\n         *  until Symphony 3.0\n         *\n         * @delegate InitialiseAdminPageHead\n         * @param string $context\n         *  '/backend/'\n         */\n        Symphony::ExtensionManager()->notifyMembers('InitialiseAdminPageHead', '/backend/');\n        Symphony::ExtensionManager()->notifyMembers('InitaliseAdminPageHead', '/backend/');\n\n        $this->addHeaderToPage('Content-Type', 'text/html; charset=UTF-8');\n        $this->addHeaderToPage('Cache-Control', 'no-cache, must-revalidate, max-age=0');\n        $this->addHeaderToPage('Expires', 'Mon, 12 Dec 1982 06:14:00 GMT');\n        $this->addHeaderToPage('Last-Modified', gmdate('D, d M Y H:i:s') . ' GMT');\n        $this->addHeaderToPage('Pragma', 'no-cache');\n\n        // If not set by another extension, lock down the backend\n        if (!array_key_exists('x-frame-options', $this->headers())) {\n            $this->addHeaderToPage('X-Frame-Options', 'SAMEORIGIN');\n        }\n\n        if (!array_key_exists('access-control-allow-origin', $this->headers())) {\n            $this->addHeaderToPage('Access-Control-Allow-Origin', URL);\n        }\n\n        if (isset($_REQUEST['action'])) {\n            $this->action();\n            Symphony::Profiler()->sample('Page action run', PROFILE_LAP);\n        }\n\n        $h1 = new XMLElement('h1');\n        $h1->appendChild(Widget::Anchor(Symphony::Configuration()->get('sitename', 'general'), rtrim(URL, '/') . '/'));\n        $this->Header->appendChild($h1);\n\n        $this->appendUserLinks();\n        $this->appendNavigation();\n\n        // Add Breadcrumbs\n        $this->Context->prependChild($this->Breadcrumbs);\n        $this->Contents->appendChild($this->Form);\n\n        $this->view();\n\n        $this->appendAlert();\n\n        Symphony::Profiler()->sample('Page content created', PROFILE_LAP);\n    }\n\n    /**\n     * Checks the current Symphony Author can access the current page.\n     * This check uses the `ASSETS . /xml/navigation.xml` file to determine\n     * if the current page (or the current page namespace) can be viewed\n     * by the currently logged in Author.\n     *\n     * @link http://github.com/symphonycms/symphony-2/blob/master/symphony/assets/xml/navigation.xml\n     * @return boolean\n     *  True if the Author can access the current page, false otherwise\n     */\n    public function canAccessPage()\n    {\n        $nav = $this->getNavigationArray();\n        $page = '/' . trim(getCurrentPage(), '/') . '/';\n\n        $page_limit = 'author';\n\n        foreach ($nav as $item) {\n            if (\n                // If page directly matches one of the children\n                General::in_array_multi($page, $item['children'])\n                // If the page namespace matches one of the children (this will usually drop query\n                // string parameters such as /edit/1/)\n                || General::in_array_multi(Symphony::getPageNamespace() . '/', $item['children'])\n            ) {\n                if (is_array($item['children'])) {\n                    foreach ($item['children'] as $c) {\n                        if ($c['link'] === $page && isset($c['limit'])) {\n                            $page_limit = $c['limit'];\n                        }\n                    }\n                }\n\n                if (isset($item['limit']) && $page_limit !== 'primary') {\n                    if ($page_limit === 'author' && $item['limit'] === 'developer') {\n                        $page_limit = 'developer';\n                    }\n                }\n            } elseif (isset($item['link']) && $page === $item['link'] && isset($item['limit'])) {\n                $page_limit = $item['limit'];\n            }\n        }\n\n        return $this->doesAuthorHaveAccess($page_limit);\n    }\n\n    /**\n     * Given the limit of the current navigation item or page, this function\n     * returns if the current Author can access that item or not.\n     *\n     * @since Symphony 2.5.1\n     * @param string $item_limit\n     * @return boolean\n     */\n    public function doesAuthorHaveAccess($item_limit = null)\n    {\n        $can_access = false;\n\n        if (!isset($item_limit) || $item_limit === 'author') {\n            $can_access = true;\n        } elseif ($item_limit === 'developer' && Symphony::Author()->isDeveloper()) {\n            $can_access = true;\n        } elseif ($item_limit === 'manager' && (Symphony::Author()->isManager() || Symphony::Author()->isDeveloper())) {\n            $can_access = true;\n        } elseif ($item_limit === 'primary' && Symphony::Author()->isPrimaryAccount()) {\n            $can_access = true;\n        }\n\n        return $can_access;\n    }\n\n    /**\n     * Appends the `$this->Header`, `$this->Context` and `$this->Contents`\n     * to `$this->Wrapper` before adding the ID and class attributes for\n     * the `<body>` element. This function will also place any Drawer elements\n     * in their relevant positions in the page. After this has completed the\n     * parent `generate()` is called which will convert the `XMLElement`'s\n     * into strings ready for output.\n     *\n     * @see core.HTMLPage#generate()\n     * @param null $page\n     * @return string\n     */\n    public function generate($page = null)\n    {\n        $this->Wrapper->appendChild($this->Header);\n\n        // Add horizontal drawers (inside #context)\n        if (isset($this->Drawer['horizontal'])) {\n            $this->Context->appendChildArray($this->Drawer['horizontal']);\n        }\n\n        $this->Wrapper->appendChild($this->Context);\n\n        // Add vertical-left drawers (between #context and #contents)\n        if (isset($this->Drawer['vertical-left'])) {\n            $this->Contents->appendChildArray($this->Drawer['vertical-left']);\n        }\n\n        // Add vertical-right drawers (after #contents)\n        if (isset($this->Drawer['vertical-right'])) {\n            $this->Contents->appendChildArray($this->Drawer['vertical-right']);\n        }\n\n        $this->Wrapper->appendChild($this->Contents);\n\n        $this->Body->appendChild($this->Wrapper);\n\n        $this->__appendBodyId();\n        $this->__appendBodyClass($this->_context);\n\n        return parent::generate($page);\n    }\n\n    /**\n     * Uses this pages PHP classname as the `<body>` ID attribute.\n     * This function removes 'content' from the start of the classname\n     * and converts all uppercase letters to lowercase and prefixes them\n     * with a hyphen.\n     */\n    private function __appendBodyId()\n    {\n        // trim \"content\" from beginning of class name\n        $body_id = preg_replace(\"/^content/\", '', get_class($this));\n\n        // lowercase any uppercase letters and prefix with a hyphen\n        $body_id = trim(\n            preg_replace_callback(\n                \"/([A-Z])/\",\n                function($id) {\n                    return \"-\" . strtolower($id[0]);\n                },\n                $body_id\n            ),\n            '-'\n        );\n\n        if (!empty($body_id)) {\n            $this->Body->setAttribute('id', trim($body_id));\n        }\n    }\n\n    /**\n     * Given the context of the current page, which is an associative\n     * array, this function will append the values to the page's body as\n     * classes. If an context value is numeric it will be prepended by 'id-',\n     * otherwise all classes will be prefixed by the context key.\n     *\n     * @param array $context\n     */\n    private function __appendBodyClass(array $context = array())\n    {\n        $body_class = '';\n\n        foreach ($context as $key => $value) {\n            if (is_numeric($value)) {\n                $value = 'id-' . $value;\n\n                // Add prefixes to all context values by making the\n                // class be {key}-{value}. #1397 ^BA\n            } else if (!is_numeric($key) && isset($value)) {\n                // Skip arrays\n                if (is_array($value)) {\n                    $value = null;\n                } else {\n                    $value = str_replace('_', '-', $key) . '-'. $value;\n                }\n            }\n\n            if ($value !== null) {\n                $body_class .= trim($value) . ' ';\n            }\n        }\n\n        $classes = array_merge(explode(' ', trim($body_class)), explode(' ', trim($this->_body_class)));\n        $body_class = trim(implode(' ', $classes));\n\n        if (!empty($body_class)) {\n            $this->Body->setAttribute('class', $body_class);\n        }\n    }\n\n    /**\n     * Called to build the content for the page. This function immediately calls\n     * `__switchboard()` which acts a bit of a controller to show content based on\n     * off a type, such as 'view' or 'action'. `AdministrationPages` can override this\n     * function to just display content if they do not need the switchboard functionality\n     *\n     * @see __switchboard()\n     */\n    public function view()\n    {\n        $this->__switchboard();\n    }\n\n    /**\n     * This function is called when `$_REQUEST` contains a key of 'action'.\n     * Any logic that needs to occur immediately for the action to complete\n     * should be contained within this function. By default this calls the\n     * `__switchboard` with the type set to 'action'.\n     *\n     * @see __switchboard()\n     */\n    public function action()\n    {\n        $this->__switchboard('action');\n    }\n\n    /**\n     * The `__switchboard` function acts as a controller to display content\n     * based off the $type. By default, the `$type` is 'view' but it can be set\n     * also set to 'action'. The `$type` is prepended by __ and the context is\n     * append to the $type to create the name of the function that will provide\n     * that logic. For example, if the $type was action and the context of the\n     * current page was new, the resulting function to be called would be named\n     * `__actionNew()`. If an action function is not provided by the Page, this function\n     * returns nothing, however if a view function is not provided, a 404 page\n     * will be returned.\n     *\n     * @param string $type\n     *  Either 'view' or 'action', by default this will be 'view'\n     * @throws SymphonyErrorPage\n     */\n    public function __switchboard($type = 'view')\n    {\n        if (!isset($this->_context[0]) || trim($this->_context[0]) === '') {\n            $context = 'index';\n        } else {\n            $context = $this->_context[0];\n        }\n\n        $function = ($type == 'action' ? '__action' : '__view') . ucfirst($context);\n\n        if (!method_exists($this, $function)) {\n            // If there is no action function, just return without doing anything\n            if ($type == 'action') {\n                return;\n            }\n\n            Administration::instance()->errorPageNotFound();\n        }\n\n        $this->$function(null);\n    }\n\n    /**\n     * If `$this->Alert` is set, it will be added to this page. The\n     * `AppendPageAlert` delegate is fired to allow extensions to provide their\n     * their own Alert messages for this page. Since Symphony 2.3, there may be\n     * more than one `Alert` per page. Alerts are displayed in the order of\n     * severity, with Errors first, then Success alerts followed by Notices.\n     *\n     * @uses AppendPageAlert\n     */\n    public function appendAlert()\n    {\n        /**\n         * Allows for appending of alerts. Administration::instance()->Page->Alert is way to tell what\n         * is currently in the system\n         *\n         * @delegate AppendPageAlert\n         * @param string $context\n         *  '/backend/'\n         */\n        Symphony::ExtensionManager()->notifyMembers('AppendPageAlert', '/backend/');\n\n\n        if (!is_array($this->Alert) || empty($this->Alert)) {\n            return;\n        }\n\n        usort($this->Alert, array($this, 'sortAlerts'));\n\n        // Using prependChild ruins our order (it's backwards, but with most\n        // recent notices coming after oldest notices), so reversing the array\n        // fixes this. We need to prepend so that without Javascript the notices\n        // are at the top of the markup. See #1312\n        $this->Alert = array_reverse($this->Alert);\n\n        foreach ($this->Alert as $alert) {\n            $this->Header->prependChild($alert->asXML());\n        }\n    }\n\n    // Errors first, success next, then notices.\n    public function sortAlerts($a, $b)\n    {\n        if ($a->{'type'} === $b->{'type'}) {\n            return 0;\n        }\n\n        if (\n            ($a->{'type'} === Alert::ERROR && $a->{'type'} !== $b->{'type'})\n            || ($a->{'type'} === Alert::SUCCESS && $b->{'type'} === Alert::NOTICE)\n        ) {\n            return -1;\n        }\n\n        return 1;\n    }\n\n    /**\n     * This function will append the Navigation to the AdministrationPage.\n     * It fires a delegate, NavigationPreRender, to allow extensions to manipulate\n     * the navigation. Extensions should not use this to add their own navigation,\n     * they should provide the navigation through their fetchNavigation function.\n     * Note with the Section navigation groups, if there is only one section in a group\n     * and that section is set to visible, the group will not appear in the navigation.\n     *\n     * @uses NavigationPreRender\n     * @see getNavigationArray()\n     * @see toolkit.Extension#fetchNavigation()\n     */\n    public function appendNavigation()\n    {\n        $nav = $this->getNavigationArray();\n\n        /**\n         * Immediately before displaying the admin navigation. Provided with the\n         * navigation array. Manipulating it will alter the navigation for all pages.\n         *\n         * @delegate NavigationPreRender\n         * @param string $context\n         *  '/backend/'\n         * @param array $nav\n         *  An associative array of the current navigation, passed by reference\n         */\n        Symphony::ExtensionManager()->notifyMembers('NavigationPreRender', '/backend/', array('navigation' => &$nav));\n\n        $navElement = new XMLElement('nav', null, array('id' => 'nav', 'role' => 'navigation'));\n        $contentNav = new XMLElement('ul', null, array('class' => 'content', 'role' => 'menubar'));\n        $structureNav = new XMLElement('ul', null, array('class' => 'structure', 'role' => 'menubar'));\n\n        foreach ($nav as $n) {\n            if (isset($n['visible']) && $n['visible'] === 'no') {\n                continue;\n            }\n\n            if ($this->doesAuthorHaveAccess($n['limit'])) {\n                $xGroup = new XMLElement('li', $n['name'], array('role' => 'presentation'));\n\n                if (isset($n['class']) && trim($n['name']) !== '') {\n                    $xGroup->setAttribute('class', $n['class']);\n                }\n\n                $hasChildren = false;\n                $xChildren = new XMLElement('ul', null, array('role' => 'menu'));\n\n                if (is_array($n['children']) && !empty($n['children'])) {\n                    foreach ($n['children'] as $c) {\n                        // adapt for Yes and yes\n                        if (strtolower($c['visible']) !== 'yes') {\n                            continue;\n                        }\n\n                        if ($this->doesAuthorHaveAccess($c['limit'])) {\n                            $xChild = new XMLElement('li');\n                            $xChild->setAttribute('role', 'menuitem');\n                            $linkChild = Widget::Anchor($c['name'], SYMPHONY_URL . $c['link']);\n                            if (isset($c['target'])) {\n                                $linkChild->setAttribute('target', $c['target']);\n                            }\n                            $xChild->appendChild($linkChild);\n                            $xChildren->appendChild($xChild);\n                            $hasChildren = true;\n                        }\n                    }\n\n                    if ($hasChildren) {\n                        $xGroup->setAttribute('aria-haspopup', 'true');\n                        $xGroup->appendChild($xChildren);\n\n                        if ($n['type'] === 'content') {\n                            $contentNav->appendChild($xGroup);\n                        } elseif ($n['type'] === 'structure') {\n                            $structureNav->prependChild($xGroup);\n                        }\n                    }\n                }\n            }\n        }\n\n        $navElement->appendChild($contentNav);\n        $navElement->appendChild($structureNav);\n        $this->Header->appendChild($navElement);\n        Symphony::Profiler()->sample('Navigation Built', PROFILE_LAP);\n    }\n\n    /**\n     * Returns the `$_navigation` variable of this Page. If it is empty,\n     * it will be built by `__buildNavigation`\n     *\n     * @see __buildNavigation()\n     * @return array\n     */\n    public function getNavigationArray()\n    {\n        if (empty($this->_navigation)) {\n            $this->__buildNavigation();\n        }\n\n        return $this->_navigation;\n    }\n\n    /**\n     * This method fills the `$nav` array with value\n     * from the `ASSETS/xml/navigation.xml` file\n     *\n     * @link http://github.com/symphonycms/symphony-2/blob/master/symphony/assets/xml/navigation.xml\n     *\n     * @since Symphony 2.3.2\n     *\n     * @param array $nav\n     *  The navigation array that will receive nav nodes\n     */\n    private function buildXmlNavigation(&$nav)\n    {\n        $xml = simplexml_load_file(ASSETS . '/xml/navigation.xml');\n\n        // Loop over the default Symphony navigation file, converting\n        // it into an associative array representation\n        foreach ($xml->xpath('/navigation/group') as $n) {\n            $index = (string)$n->attributes()->index;\n            $children = $n->xpath('children/item');\n            $content = $n->attributes();\n\n            // If the index is already set, increment the index and check again.\n            // Rinse and repeat until the index is not set.\n            if (isset($nav[$index])) {\n                do {\n                    $index++;\n                } while (isset($nav[$index]));\n            }\n\n            $nav[$index] = array(\n                'name' => __(strval($content->name)),\n                'type' => 'structure',\n                'index' => $index,\n                'children' => array()\n            );\n\n            if (strlen(trim((string)$content->limit)) > 0) {\n                $nav[$index]['limit'] = (string)$content->limit;\n            }\n\n            if (count($children) > 0) {\n                foreach ($children as $child) {\n                    $item = array(\n                        'link' => (string)$child->attributes()->link,\n                        'name' => __(strval($child->attributes()->name)),\n                        'visible' => ((string)$child->attributes()->visible == 'no' ? 'no' : 'yes'),\n                    );\n\n                    $limit = (string)$child->attributes()->limit;\n\n                    if (strlen(trim($limit)) > 0) {\n                        $item['limit'] = $limit;\n                    }\n\n                    $nav[$index]['children'][] = $item;\n                }\n            }\n        }\n    }\n\n    /**\n     * This method fills the `$nav` array with value\n     * from each Section\n     *\n     * @since Symphony 2.3.2\n     *\n     * @param array $nav\n     *  The navigation array that will receive nav nodes\n     */\n    private function buildSectionNavigation(&$nav)\n    {\n        // Build the section navigation, grouped by their navigation groups\n        $sections = SectionManager::fetch(null, 'asc', 'sortorder');\n\n        if (is_array($sections) && !empty($sections)) {\n            foreach ($sections as $s) {\n                $group_index = self::__navigationFindGroupIndex($nav, $s->get('navigation_group'));\n\n                if ($group_index === false) {\n                    $group_index = General::array_find_available_index($nav, 0);\n\n                    $nav[$group_index] = array(\n                        'name' => $s->get('navigation_group'),\n                        'type' => 'content',\n                        'index' => $group_index,\n                        'children' => array()\n                    );\n                }\n\n                $nav[$group_index]['children'][] = array(\n                    'link' => '/publish/' . $s->get('handle') . '/',\n                    'name' => $s->get('name'),\n                    'type' => 'section',\n                    'section' => array('id' => $s->get('id'), 'handle' => $s->get('handle')),\n                    'visible' => ($s->get('hidden') == 'no' ? 'yes' : 'no')\n                );\n            }\n        }\n    }\n\n    /**\n     * This method fills the `$nav` array with value\n     * from each Extension's `fetchNavigation` method\n     *\n     * @since Symphony 2.3.2\n     *\n     * @param array $nav\n     *  The navigation array that will receive nav nodes\n     * @throws Exception\n     * @throws SymphonyErrorPage\n     */\n    private function buildExtensionsNavigation(&$nav)\n    {\n        // Loop over all the installed extensions to add in other navigation items\n        $extensions = Symphony::ExtensionManager()->listInstalledHandles();\n\n        foreach ($extensions as $e) {\n            $extension = Symphony::ExtensionManager()->getInstance($e);\n            $extension_navigation = $extension->fetchNavigation();\n\n            if (is_array($extension_navigation) && !empty($extension_navigation)) {\n                foreach ($extension_navigation as $item) {\n                    $type = isset($item['children']) ? Extension::NAV_GROUP : Extension::NAV_CHILD;\n\n                    switch ($type) {\n                        case Extension::NAV_GROUP:\n                            $index = General::array_find_available_index($nav, $item['location']);\n\n                            // Actual group\n                            $nav[$index] = self::createParentNavItem($index, $item);\n\n                            // Render its children\n                            foreach ($item['children'] as $child) {\n                                $nav[$index]['children'][] = self::createChildNavItem($child, $e);\n                            }\n\n                            break;\n\n                        case Extension::NAV_CHILD:\n                            if (!is_numeric($item['location'])) {\n                                // is a navigation group\n                                $group_name = $item['location'];\n                                $group_index = self::__navigationFindGroupIndex($nav, $item['location']);\n                            } else {\n                                // is a legacy numeric index\n                                $group_index = $item['location'];\n                            }\n\n                            $child = self::createChildNavItem($item, $e);\n\n                            if ($group_index === false) {\n                                $group_index = General::array_find_available_index($nav, 0);\n\n                                $nav_parent = self::createParentNavItem($group_index, $item);\n                                $nav_parent['name'] = $group_name;\n                                $nav_parent['children'] = array($child);\n\n                                // add new navigation group\n                                $nav[$group_index] = $nav_parent;\n                            } else {\n                                // add new location by index\n                                $nav[$group_index]['children'][] = $child;\n                            }\n\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * This function builds out a navigation menu item for parents. Parents display\n     * in the top level navigation of the backend and may have children (dropdown menus)\n     *\n     * @since Symphony 2.5.1\n     * @param integer $index\n     * @param array $item\n     * @return array\n     */\n    private static function createParentNavItem($index, $item)\n    {\n        $nav_item = array(\n            'name' => $item['name'],\n            'type' => isset($item['type']) ? $item['type'] : 'structure',\n            'index' => $index,\n            'children' => array(),\n            'limit' => isset($item['limit']) ? $item['limit'] : null\n        );\n\n        return $nav_item;\n    }\n\n    /**\n     * This function builds out a navigation menu item for children. Children\n     * live under a parent navigation item and are shown on hover.\n     *\n     * @since Symphony 2.5.1\n     * @param array $item\n     * @param string $extension_handle\n     * @return array\n     */\n    private static function createChildNavItem($item, $extension_handle)\n    {\n        if (!isset($item['relative']) || $item['relative'] === true) {\n            $link = '/extension/' . $extension_handle . '/' . ltrim($item['link'], '/');\n        } else {\n            $link = '/' . ltrim($item['link'], '/');\n        }\n\n        $nav_item = array(\n            'link' => $link,\n            'name' => $item['name'],\n            'visible' => (isset($item['visible']) && $item['visible'] == 'no') ? 'no' : 'yes',\n            'limit' => isset($item['limit']) ? $item['limit'] : null,\n            'target' => isset($item['target']) ? $item['target'] : null\n        );\n\n        return $nav_item;\n    }\n\n    /**\n     * This function populates the `$_navigation` array with an associative array\n     * of all the navigation groups and their links. Symphony only supports one\n     * level of navigation, so children links cannot have children links. The default\n     * Symphony navigation is found in the `ASSETS/xml/navigation.xml` folder. This is\n     * loaded first, and then the Section navigation is built, followed by the Extension\n     * navigation. Additionally, this function will set the active group of the navigation\n     * by checking the current page against the array of links.\n     *\n     * @link https://github.com/symphonycms/symphony-2/blob/master/symphony/assets/xml/navigation.xml\n     * @link https://github.com/symphonycms/symphony-2/blob/master/symphony/lib/toolkit/class.extension.php\n     */\n    public function __buildNavigation()\n    {\n        $nav = array();\n\n        $this->buildXmlNavigation($nav);\n        $this->buildSectionNavigation($nav);\n        $this->buildExtensionsNavigation($nav);\n\n        $pageCallback = Administration::instance()->getPageCallback();\n\n        $pageRoot = $pageCallback['pageroot'] . (isset($pageCallback['context'][0]) ? $pageCallback['context'][0] . '/' : '');\n        $found = self::__findActiveNavigationGroup($nav, $pageRoot);\n\n        // Normal searches failed. Use a regular expression using the page root. This is less\n        // efficient and should never really get invoked unless something weird is going on\n        if (!$found) {\n            self::__findActiveNavigationGroup($nav, '/^' . str_replace('/', '\\/', $pageCallback['pageroot']) . '/i', true);\n        }\n\n        ksort($nav);\n        $this->_navigation = $nav;\n    }\n\n    /**\n     * Given an associative array representing the navigation, and a group,\n     * this function will attempt to return the index of the group in the navigation\n     * array. If it is found, it will return the index, otherwise it will return false.\n     *\n     * @param array $nav\n     *  An associative array of the navigation where the key is the group\n     *  index, and the value is an associative array of 'name', 'index' and\n     *  'children'. Name is the name of the this group, index is the same as\n     *  the key and children is an associative array of navigation items containing\n     *  the keys 'link', 'name' and 'visible'. The 'haystack'.\n     * @param string $group\n     *  The group name to find, the 'needle'.\n     * @return integer|boolean\n     *  If the group is found, the index will be returned, otherwise false.\n     */\n    private static function __navigationFindGroupIndex(array $nav, $group)\n    {\n        foreach ($nav as $index => $item) {\n            if ($item['name'] === $group) {\n                return $index;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Given the navigation array, this function will loop over all the items\n     * to determine which is the 'active' navigation group, or in other words,\n     * what group best represents the current page `$this->Author` is viewing.\n     * This is done by checking the current page's link against all the links\n     * provided in the `$nav`, and then flagging the group of the found link\n     * with an 'active' CSS class. The current page's link omits any flags or\n     * URL parameters and just uses the root page URL.\n     *\n     * @param array $nav\n     *  An associative array of the navigation where the key is the group\n     *  index, and the value is an associative array of 'name', 'index' and\n     *  'children'. Name is the name of the this group, index is the same as\n     *  the key and children is an associative array of navigation items containing\n     *  the keys 'link', 'name' and 'visible'. The 'haystack'. This parameter is passed\n     *  by reference to this function.\n     * @param string $pageroot\n     *  The current page the Author is the viewing, minus any flags or URL\n     *  parameters such as a Symphony object ID. eg. Section ID, Entry ID. This\n     *  parameter is also be a regular expression, but this is highly unlikely.\n     * @param boolean $pattern\n     *  If set to true, the `$pageroot` represents a regular expression which will\n     *  determine if the active navigation item\n     * @return boolean\n     *  Returns true if an active link was found, false otherwise. If true, the\n     *  navigation group of the active link will be given the CSS class 'active'\n     */\n    private static function __findActiveNavigationGroup(array &$nav, $pageroot, $pattern = false)\n    {\n        foreach ($nav as $index => $contents) {\n            if (is_array($contents['children']) && !empty($contents['children'])) {\n                foreach ($contents['children'] as $item) {\n                    if ($pattern && preg_match($pageroot, $item['link'])) {\n                        $nav[$index]['class'] = 'active';\n                        return true;\n                    } elseif ($item['link'] == $pageroot) {\n                        $nav[$index]['class'] = 'active';\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates the Symphony footer for an Administration page. By default\n     * this includes the installed Symphony version and the currently logged\n     * in Author. A delegate is provided to allow extensions to manipulate the\n     * footer HTML, which is an XMLElement of a `<ul>` element.\n     * Since Symphony 2.3, it no longer uses the `AddElementToFooter` delegate.\n     */\n    public function appendUserLinks()\n    {\n        $ul = new XMLElement('ul', null, array('id' => 'session'));\n\n        $li = new XMLElement('li');\n        $li->appendChild(\n            Widget::Anchor(\n                Symphony::Author()->getFullName(),\n                SYMPHONY_URL . '/system/authors/edit/' . Symphony::Author()->get('id') . '/'\n            )\n        );\n        $ul->appendChild($li);\n\n        $li = new XMLElement('li');\n        $li->appendChild(Widget::Anchor(__('Log out'), SYMPHONY_URL . '/logout/', null, null, null, array('accesskey' => 'l')));\n        $ul->appendChild($li);\n\n        $this->Header->appendChild($ul);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * @package content\n */\n\n/**\n * This page controls the creation and maintenance of Symphony\n * Sections through the Section Index and Section Editor.\n */\n\nclass contentBlueprintsSections extends AdministrationPage\n{\n    public $_errors = array();\n\n    public function build(array $context = array())\n    {\n        $section_id = $context[1];\n\n        if (isset($section_id)) {\n            $context['associations'] = array(\n                'parent' => SectionManager::fetchParentAssociations($section_id),\n                'child' => SectionManager::fetchChildAssociations($section_id)\n            );\n        }\n\n        return parent::build($context);\n    }\n\n    public function __viewIndex()\n    {\n        $this->setPageType('table');\n        $this->setTitle(__('%1$s &ndash; %2$s', array(__('Sections'), __('Symphony'))));\n        $this->appendSubheading(__('Sections'), Widget::Anchor(__('Create New'), Administration::instance()->getCurrentPageURL().'new/', __('Create a section'), 'create button', null, array('accesskey' => 'c')));\n\n        $sections = SectionManager::fetch(null, 'ASC', 'sortorder');\n\n        $aTableHead = array(\n            array(__('Name'), 'col'),\n            array(__('Entries'), 'col'),\n            array(__('Navigation Group'), 'col')\n        );\n\n        $aTableBody = array();\n\n        if (!is_array($sections) || empty($sections)) {\n            $aTableBody = array(\n                Widget::TableRow(array(Widget::TableData(__('None found.'), 'inactive', null, count($aTableHead))), 'odd')\n            );\n        } else {\n            foreach ($sections as $s) {\n                $entry_count = EntryManager::fetchCount($s->get('id'));\n\n                // Setup each cell\n                $td1 = Widget::TableData(Widget::Anchor($s->get('name'), Administration::instance()->getCurrentPageURL() . 'edit/' . $s->get('id') .'/', null, 'content'));\n                $td1->appendChild(Widget::Label(__('Select Section %s', array($s->get('name'))), null, 'accessible', null, array(\n                    'for' => 'section-' . $s->get('id')\n                )));\n                $td1->appendChild(Widget::Input('items['.$s->get('id').']', 'on', 'checkbox', array(\n                    'id' => 'section-' . $s->get('id')\n                )));\n\n                $td2 = Widget::TableData(Widget::Anchor(\"$entry_count\", SYMPHONY_URL . '/publish/' . $s->get('handle') . '/'));\n                $td3 = Widget::TableData($s->get('navigation_group'));\n\n                // Create row\n                $tr = Widget::TableRow(array($td1, $td2, $td3));\n\n                if ($s->get('hidden') === 'yes') {\n                    $tr->setAttribute('class', 'inactive');\n                }\n\n                $aTableBody[] = $tr;\n            }\n        }\n\n        $table = Widget::Table(\n            Widget::TableHead($aTableHead),\n            null,\n            Widget::TableBody($aTableBody),\n            'orderable selectable',\n            null,\n            array('role' => 'directory', 'aria-labelledby' => 'symphony-subheading', 'data-interactive' => 'data-interactive')\n        );\n\n        $this->Form->appendChild($table);\n\n        $version = new XMLElement('p', 'Symphony ' . Symphony::Configuration()->get('version', 'symphony'), array(\n            'id' => 'version'\n        ));\n\n        $this->Form->appendChild($version);\n\n        $tableActions = new XMLElement('div');\n        $tableActions->setAttribute('class', 'actions');\n\n        $options = array(\n            array(null, false, __('With Selected...')),\n            array('delete', false, __('Delete'), 'confirm', null, array(\n                'data-message' => __('Are you sure you want to delete the selected sections?')\n            )),\n            array('delete-entries', false, __('Delete Entries'), 'confirm', null, array(\n                'data-message' => __('Are you sure you want to delete all entries in the selected sections?')\n            ))\n        );\n\n        if (is_array($sections) && !empty($sections)) {\n            $index = 3;\n            $options[$index] = array('label' => __('Set navigation group'), 'options' => array());\n\n            $groups = array();\n\n            foreach ($sections as $s) {\n                if (in_array($s->get('navigation_group'), $groups)) {\n                    continue;\n                }\n\n                $groups[] = $s->get('navigation_group');\n\n                $value = 'set-navigation-group-' . urlencode($s->get('navigation_group'));\n                $options[$index]['options'][] = array($value, false, $s->get('navigation_group'));\n            }\n        }\n\n        /**\n         * Allows an extension to modify the existing options for this page's\n         * With Selected menu. If the `$options` parameter is an empty array,\n         * the 'With Selected' menu will not be rendered.\n         *\n         * @delegate AddCustomActions\n         * @since Symphony 2.3.2\n         * @param string $context\n         * '/blueprints/sections/'\n         * @param array $options\n         *  An array of arrays, where each child array represents an option\n         *  in the With Selected menu. Options should follow the same format\n         *  expected by `Widget::__SelectBuildOption`. Passed by reference.\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddCustomActions', '/blueprints/sections/', array(\n            'options' => &$options\n        ));\n\n        if (!empty($options)) {\n            $tableActions->appendChild(Widget::Apply($options));\n            $this->Form->appendChild($tableActions);\n        }\n    }\n\n    public function __viewNew()\n    {\n        $this->setPageType('form');\n        $this->setTitle(__('%1$s &ndash; %2$s', array(__('Sections'), __('Symphony'))));\n        $this->appendSubheading(__('Untitled'));\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor(__('Sections'), SYMPHONY_URL . '/blueprints/sections/'),\n        ));\n\n        $types = array();\n\n        $fields = (isset($_POST['fields']) && is_array($_POST['fields'])) ? $_POST['fields'] : array();\n        $meta = (isset($_POST['meta']) && is_array($_POST['meta'])) ? $_POST['meta'] : array('name'=>null);\n\n        $formHasErrors = (is_array($this->_errors) && !empty($this->_errors));\n\n        if ($formHasErrors) {\n            $this->pageAlert(\n                __('An error occurred while processing this form. See below for details.'),\n                Alert::ERROR\n            );\n        }\n\n        $showEmptyTemplate = (is_array($fields) && !empty($fields) ? false : true);\n\n        if (!$showEmptyTemplate) {\n            ksort($fields);\n        }\n\n        // Set navigation group, if not already set\n        if (!isset($meta['navigation_group'])) {\n            $meta['navigation_group'] = (isset($this->_navigation[0]['name']) ? $this->_navigation[0]['name'] : __('Content'));\n        }\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n        $fieldset->appendChild(new XMLElement('legend', __('Essentials')));\n\n        $namediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Name'));\n        $label->appendChild(Widget::Input('meta[name]', (isset($meta['name']) ? General::sanitize($meta['name']) : null)));\n\n        if (isset($this->_errors['name'])) {\n            $namediv->appendChild(Widget::Error($label, $this->_errors['name']));\n        } else {\n            $namediv->appendChild($label);\n        }\n\n        $fieldset->appendChild($namediv);\n\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        $handlediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Handle'));\n        $label->appendChild(Widget::Input('meta[handle]', (isset($meta['handle']) ? General::sanitize($meta['handle']) : null)));\n\n        if (isset($this->_errors['handle'])) {\n            $handlediv->appendChild(Widget::Error($label, $this->_errors['handle']));\n        } else {\n            $handlediv->appendChild($label);\n        }\n\n        $div->appendChild($handlediv);\n\n        $navgroupdiv = new XMLElement('div', null, array('class' => 'column'));\n\n        $sections = SectionManager::fetch(null, 'ASC', 'sortorder');\n        $label = Widget::Label(__('Navigation Group'));\n        $label->appendChild(Widget::Input('meta[navigation_group]', (isset($meta['navigation_group']) ? General::sanitize($meta['navigation_group']) : null)));\n\n        if (isset($this->_errors['navigation_group'])) {\n            $navgroupdiv->appendChild(Widget::Error($label, $this->_errors['navigation_group']));\n        } else {\n            $navgroupdiv->appendChild($label);\n        }\n\n        if (is_array($sections) && !empty($sections)) {\n            $ul = new XMLElement('ul', null, array('class' => 'tags singular', 'data-interactive' => 'data-interactive'));\n            $groups = array();\n\n            foreach ($sections as $s) {\n                if (in_array($s->get('navigation_group'), $groups)) {\n                    continue;\n                }\n\n                $ul->appendChild(new XMLElement('li', General::sanitize($s->get('navigation_group'))));\n                $groups[] = $s->get('navigation_group');\n            }\n\n            $navgroupdiv->appendChild($ul);\n        }\n\n        $div->appendChild($navgroupdiv);\n        $fieldset->appendChild($div);\n        $this->Form->appendChild($fieldset);\n\n        $this->addSectionOptions($meta);\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n\n        $legend = new XMLElement('legend', __('Fields'));\n        $legend->setAttribute('id', 'fields-legend');\n        $fieldset->appendChild($legend);\n\n        $div = new XMLElement('div', null, array('class' => 'frame', 'id' => 'fields-duplicator'));\n\n        $ol = new XMLElement('ol');\n        $ol->setAttribute('data-add', __('Add field'));\n        $ol->setAttribute('data-remove', __('Remove field'));\n\n        if (!$showEmptyTemplate) {\n            foreach ($fields as $position => $data) {\n                if ($input = FieldManager::create($data['type'])) {\n                    $input->setArray($data);\n\n                    $wrapper = new XMLElement('li');\n\n                    $input->set('sortorder', $position);\n                    $input->displaySettingsPanel($wrapper, (isset($this->_errors[$position]) ? $this->_errors[$position] : null));\n                    $ol->appendChild($wrapper);\n                }\n            }\n        }\n\n        foreach (FieldManager::listAll() as $type) {\n            if ($type = FieldManager::create($type)) {\n                $types[] = $type;\n            }\n        }\n\n        uasort($types, function($a, $b) {\n            return strnatcasecmp($a->_name, $b->_name);\n        });\n\n        foreach ($types as $type) {\n            $defaults = array();\n\n            $type->findDefaults($defaults);\n            $type->setArray($defaults);\n\n            $wrapper = new XMLElement('li');\n            $wrapper->setAttribute('class', 'template field-' . $type->handle() . ($type->mustBeUnique() ? ' unique' : null));\n            $wrapper->setAttribute('data-type', $type->handle());\n\n            $type->set('sortorder', '-1');\n            $type->displaySettingsPanel($wrapper);\n\n            $ol->appendChild($wrapper);\n        }\n\n        $div->appendChild($ol);\n        $fieldset->appendChild($div);\n\n        $this->Form->appendChild($fieldset);\n\n        $div = new XMLElement('div');\n        $div->setAttribute('class', 'actions');\n        $div->appendChild(Widget::Input('action[save]', __('Create Section'), 'submit', array('accesskey' => 's')));\n\n        $this->Form->appendChild($div);\n    }\n\n    public function __viewEdit()\n    {\n        $section_id = $this->_context[1];\n\n        if (!$section = SectionManager::fetch($section_id)) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array($section_id)),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n\n        $meta = $section->get();\n        $section_id = $meta['id'];\n        $types = array();\n\n        $formHasErrors = (is_array($this->_errors) && !empty($this->_errors));\n\n        if ($formHasErrors) {\n            $this->pageAlert(\n                __('An error occurred while processing this form. See below for details.'),\n                Alert::ERROR\n            );\n\n            // These alerts are only valid if the form doesn't have errors\n        } elseif (isset($this->_context[2])) {\n            $time = Widget::Time();\n\n            switch ($this->_context[2]) {\n                case 'saved':\n                    $message = __('Section updated at %s.', array($time->generate()));\n                    break;\n                case 'created':\n                    $message = __('Section created at %s.', array($time->generate()));\n            }\n\n            $this->pageAlert(\n                $message\n                . ' <a href=\"' . SYMPHONY_URL . '/blueprints/sections/new/\" accesskey=\"c\">'\n                . __('Create another?')\n                . '</a> <a href=\"' . SYMPHONY_URL . '/blueprints/sections/\" accesskey=\"a\">'\n                . __('View all Sections')\n                . '</a>',\n                Alert::SUCCESS\n            );\n        }\n\n        if (isset($_POST['fields'])) {\n            $fields = array();\n\n            if (is_array($_POST['fields']) && !empty($_POST['fields'])) {\n                foreach ($_POST['fields'] as $position => $data) {\n                    if ($fields[$position] = FieldManager::create($data['type'])) {\n                        $fields[$position]->setArray($data);\n                        $fields[$position]->set('sortorder', $position);\n                    }\n                }\n            }\n        } else {\n            $fields = FieldManager::fetch(null, $section_id);\n            $fields = array_values($fields);\n        }\n\n        if (isset($_POST['meta'])) {\n            $meta = $_POST['meta'];\n            if ($meta['name'] == '') {\n                $meta['name'] = $section->get('name');\n            }\n        }\n\n        $this->setPageType('form');\n        $this->setTitle(__('%1$s &ndash; %2$s &ndash; %3$s', array(General::sanitize($meta['name']), __('Sections'), __('Symphony'))));\n        $this->appendSubheading(General::sanitize($meta['name']),\n            Widget::Anchor(__('View Entries'), SYMPHONY_URL . '/publish/' . $section->get('handle'), __('View Section Entries'), 'button')\n        );\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor(__('Sections'), SYMPHONY_URL . '/blueprints/sections/'),\n        ));\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n        $fieldset->appendChild(new XMLElement('legend', __('Essentials')));\n\n        $namediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Name'));\n        $label->appendChild(Widget::Input('meta[name]', (isset($meta['name']) ? General::sanitize($meta['name']) : null)));\n\n        if (isset($this->_errors['name'])) {\n            $namediv->appendChild(Widget::Error($label, $this->_errors['name']));\n        } else {\n            $namediv->appendChild($label);\n        }\n\n        $fieldset->appendChild($namediv);\n\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        $handlediv = new XMLElement('div', null, array('class' => 'column'));\n\n        $label = Widget::Label(__('Handle'));\n        $label->appendChild(Widget::Input('meta[handle]', (isset($meta['handle']) ? General::sanitize($meta['handle']) : null)));\n\n        if (isset($this->_errors['handle'])) {\n            $handlediv->appendChild(Widget::Error($label, $this->_errors['handle']));\n        } else {\n            $handlediv->appendChild($label);\n        }\n\n        $div->appendChild($handlediv);\n\n        $navgroupdiv = new XMLElement('div', null, array('class' => 'column'));\n\n        $sections = SectionManager::fetch(null, 'ASC', 'sortorder');\n        $label = Widget::Label(__('Navigation Group'));\n        $label->appendChild(Widget::Input('meta[navigation_group]', General::sanitize($meta['navigation_group'])));\n\n        if (isset($this->_errors['navigation_group'])) {\n            $navgroupdiv->appendChild(Widget::Error($label, $this->_errors['navigation_group']));\n        } else {\n            $navgroupdiv->appendChild($label);\n        }\n\n        if (is_array($sections) && !empty($sections)) {\n            $ul = new XMLElement('ul', null, array('class' => 'tags singular', 'data-interactive' => 'data-interactive'));\n            $groups = array();\n\n            foreach ($sections as $s) {\n                if (in_array($s->get('navigation_group'), $groups)) {\n                    continue;\n                }\n\n                $ul->appendChild(new XMLElement('li', General::sanitize($s->get('navigation_group'))));\n                $groups[] = $s->get('navigation_group');\n            }\n\n            $navgroupdiv->appendChild($ul);\n        }\n\n        $div->appendChild($navgroupdiv);\n        $fieldset->appendChild($div);\n        $this->Form->appendChild($fieldset);\n\n        $this->addSectionOptions($meta);\n\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n\n        $legend = new XMLElement('legend', __('Fields'));\n        $legend->setAttribute('id', 'fields-legend');\n        $fieldset->appendChild($legend);\n\n        $div = new XMLElement('div', null, array('class' => 'frame', 'id' => 'fields-duplicator'));\n\n        $ol = new XMLElement('ol');\n        $ol->setAttribute('data-add', __('Add field'));\n        $ol->setAttribute('data-remove', __('Remove field'));\n\n        if (is_array($fields) && !empty($fields)) {\n            foreach ($fields as $position => $field) {\n                $wrapper = new XMLElement('li', null, array('class' => 'field-' . $field->handle() . ($field->mustBeUnique() ? ' unique' : null)));\n                $wrapper->setAttribute('data-type', $field->handle());\n\n                $field->set('sortorder', $position);\n                $field->displaySettingsPanel($wrapper, (isset($this->_errors[$position]) ? $this->_errors[$position] : null));\n                $ol->appendChild($wrapper);\n            }\n        }\n\n        foreach (FieldManager::listAll() as $type) {\n            if ($type = FieldManager::create($type)) {\n                array_push($types, $type);\n            }\n        }\n\n        uasort($types, function($a, $b) {\n            return strnatcasecmp($a->_name, $b->_name);\n        });\n\n        foreach ($types as $type) {\n            $defaults = array();\n\n            $type->findDefaults($defaults);\n            $type->setArray($defaults);\n\n            $wrapper = new XMLElement('li');\n\n            $wrapper->setAttribute('class', 'template field-' . $type->handle() . ($type->mustBeUnique() ? ' unique' : null));\n            $wrapper->setAttribute('data-type', $type->handle());\n\n            $type->set('sortorder', '-1');\n            $type->displaySettingsPanel($wrapper);\n\n            $ol->appendChild($wrapper);\n        }\n\n        $div->appendChild($ol);\n        $fieldset->appendChild($div);\n\n        $this->Form->appendChild($fieldset);\n\n        $div = new XMLElement('div');\n        $div->setAttribute('class', 'actions');\n        $div->appendChild(Widget::Input('action[save]', __('Save Changes'), 'submit', array('accesskey' => 's')));\n\n        $button = new XMLElement('button', __('Delete'));\n        $button->setAttributeArray(array('name' => 'action[delete]', 'class' => 'button confirm delete', 'title' => __('Delete this section'), 'type' => 'submit', 'accesskey' => 'd', 'data-message' => __('Are you sure you want to delete this section?')));\n        $div->appendChild($button);\n\n        $this->Form->appendChild($div);\n    }\n\n    public function __actionIndex()\n    {\n        $checked = (is_array($_POST['items'])) ? array_keys($_POST['items']) : null;\n\n        if (is_array($checked) && !empty($checked)) {\n            /**\n             * Extensions can listen for any custom actions that were added\n             * through `AddCustomPreferenceFieldsets` or `AddCustomActions`\n             * delegates.\n             *\n             * @delegate CustomActions\n             * @since Symphony 2.3.2\n             * @param string $context\n             *  '/blueprints/sections/'\n             * @param array $checked\n             *  An array of the selected rows. The value is usually the ID of the\n             *  the associated object.\n             */\n            Symphony::ExtensionManager()->notifyMembers('CustomActions', '/blueprints/sections/', array(\n                'checked' => $checked\n            ));\n\n            if ($_POST['with-selected'] == 'delete') {\n                /**\n                 * Just prior to calling the Section Manager's delete function\n                 *\n                 * @delegate SectionPreDelete\n                 * @since Symphony 2.2\n                 * @param string $context\n                 * '/blueprints/sections/'\n                 * @param array $section_ids\n                 *  An array of Section ID's passed by reference\n                 */\n                Symphony::ExtensionManager()->notifyMembers('SectionPreDelete', '/blueprints/sections/', array('section_ids' => &$checked));\n\n                foreach ($checked as $section_id) {\n                    SectionManager::delete($section_id);\n                }\n\n                redirect(SYMPHONY_URL . '/blueprints/sections/');\n            } elseif ($_POST['with-selected'] == 'delete-entries') {\n                foreach ($checked as $section_id) {\n                    $entries = EntryManager::fetch(null, $section_id, null, null, null, null, false, false, null, false);\n                    $entry_ids = array();\n\n                    foreach ($entries as $entry) {\n                        $entry_ids[] = $entry['id'];\n                    }\n\n                    /**\n                     * Prior to deletion of entries.\n                     *\n                     * @delegate Delete\n                     * @param string $context\n                     * '/publish/'\n                     * @param array $entry_id\n                     *  An array of Entry ID's that are about to be deleted, passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('Delete', '/publish/', array('entry_id' => &$entry_ids));\n\n                    EntryManager::delete($entry_ids, $section_id);\n                }\n\n                redirect(SYMPHONY_URL . '/blueprints/sections/');\n            } elseif (preg_match('/^set-navigation-group-/', $_POST['with-selected'])) {\n                $navigation_group = preg_replace('/^set-navigation-group-/', null, $_POST['with-selected']);\n\n                foreach ($checked as $section_id) {\n                    SectionManager::edit($section_id, array('navigation_group' => urldecode($navigation_group)));\n                }\n\n                redirect(SYMPHONY_URL . '/blueprints/sections/');\n            }\n        }\n    }\n\n    public function __actionNew()\n    {\n        if (@array_key_exists('save', $_POST['action']) || @array_key_exists('done', $_POST['action'])) {\n            $canProceed = true;\n            $edit = ($this->_context[0] == \"edit\");\n            $this->_errors = array();\n\n            $fields = isset($_POST['fields']) ? $_POST['fields'] : array();\n            $meta = $_POST['meta'];\n\n            if ($edit) {\n                $section_id = $this->_context[1];\n                $existing_section = SectionManager::fetch($section_id);\n            }\n\n            // Check handle to ensure it is unique\n            $meta['handle'] = $_POST['meta']['handle'] = Lang::createHandle((isset($meta['handle']) && !empty($meta['handle']))\n                ? $meta['handle']\n                : $meta['name']);\n\n            // Check to ensure all the required section fields are filled\n            if (!isset($meta['name']) || strlen(trim($meta['name'])) == 0) {\n                $this->_errors['name'] = __('This is a required field.');\n                $canProceed = false;\n\n                // Check for duplicate section handle during edit\n            } elseif ($edit) {\n                $s = SectionManager::fetchIDFromHandle(Lang::createHandle($meta['handle']));\n\n                if (\n                    $meta['handle'] !== $existing_section->get('handle')\n                    && !is_null($s) && $s !== $section_id\n                ) {\n                    $this->_errors['handle'] = __('A Section with the handle %s already exists', array('<code>' . $meta['handle'] . '</code>'));\n                    $canProceed = false;\n                }\n\n                // Existing section during creation\n            } elseif (!is_null(SectionManager::fetchIDFromHandle(Lang::createHandle($meta['handle'])))) {\n                $this->_errors['handle'] = __('A Section with the handle %s already exists', array('<code>' . $meta['handle'] . '</code>'));\n                $canProceed = false;\n            }\n\n            // Check to ensure all the required section fields are filled\n            if (!isset($meta['navigation_group']) || strlen(trim($meta['navigation_group'])) == 0) {\n                $this->_errors['navigation_group'] = __('This is a required field.');\n                $canProceed = false;\n            }\n\n            // Basic custom field checking\n            if (is_array($fields) && !empty($fields)) {\n                // Check for duplicate CF names\n                if ($canProceed) {\n                    $name_list = array();\n\n                    foreach ($fields as $position => $data) {\n                        if (trim($data['element_name']) == '') {\n                            $data['element_name'] = $fields[$position]['element_name'] = $_POST['fields'][$position]['element_name'] = Lang::createHandle($data['label'], 255, '-', false, true, array('@^[\\d-]+@i' => ''));\n                        }\n\n                        if (trim($data['element_name']) != '' && in_array($data['element_name'], $name_list)) {\n                            $this->_errors[$position] = array('element_name' => __('A field with this handle already exists. All handle must be unique.'));\n                            $canProceed = false;\n                            break;\n                        }\n\n                        $name_list[] = $data['element_name'];\n                    }\n                }\n\n                if ($canProceed) {\n                    $unique = array();\n\n                    foreach ($fields as $position => $data) {\n                        $field = FieldManager::create($data['type']);\n                        $field->setFromPOST($data);\n\n                        if (isset($existing_section)) {\n                            $field->set('parent_section', $existing_section->get('id'));\n                        }\n\n                        if ($field->mustBeUnique() && !in_array($field->get('type'), $unique)) {\n                            $unique[] = $field->get('type');\n                        } elseif ($field->mustBeUnique() && in_array($field->get('type'), $unique)) {\n                            // Warning. cannot have 2 of this field!\n                            $canProceed = false;\n                            $this->_errors[$position] = array('label' => __('There is already a field of type %s. There can only be one per section.', array('<code>' . $field->handle() . '</code>')));\n                        }\n\n                        $errors = array();\n\n                        if (Field::__OK__ != $field->checkFields($errors, false) && !empty($errors)) {\n                            $this->_errors[$position] = $errors;\n                            $canProceed = false;\n                        }\n                    }\n                }\n            }\n\n            if ($canProceed) {\n                // If we are creating a new Section\n                if (!$edit) {\n                    $meta['sortorder'] = SectionManager::fetchNextSortOrder();\n\n                    /**\n                     * Just prior to saving the Section settings. Use with caution as\n                     * there is no additional processing to ensure that Field's or Section's\n                     * are unique.\n                     *\n                     * @delegate SectionPreCreate\n                     * @since Symphony 2.2\n                     * @param string $context\n                     * '/blueprints/sections/'\n                     * @param array $meta\n                     *  The section's settings, passed by reference\n                     * @param array $fields\n                     *  An associative array of the fields that will be saved to this\n                     *  section with the key being the position in the Section Editor\n                     *  and the value being a Field object, passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('SectionPreCreate', '/blueprints/sections/', array('meta' => &$meta, 'fields' => &$fields));\n\n                    if (!$section_id = SectionManager::add($meta)) {\n                        $this->pageAlert(__('An unknown database occurred while attempting to create the section.'), Alert::ERROR);\n                    }\n\n                    // We are editing a Section\n                } else {\n\n                    /**\n                     * Just prior to updating the Section settings. Use with caution as\n                     * there is no additional processing to ensure that Field's or Section's\n                     * are unique.\n                     *\n                     * @delegate SectionPreEdit\n                     * @since Symphony 2.2\n                     * @param string $context\n                     * '/blueprints/sections/'\n                     * @param integer $section_id\n                     *  The Section ID that is about to be edited.\n                     * @param array $meta\n                     *  The section's settings, passed by reference\n                     * @param array $fields\n                     *  An associative array of the fields that will be saved to this\n                     *  section with the key being the position in the Section Editor\n                     *  and the value being a Field object, passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('SectionPreEdit', '/blueprints/sections/', array('section_id' => $section_id, 'meta' => &$meta, 'fields' => &$fields));\n\n                    if (!SectionManager::edit($section_id, $meta)) {\n                        $canProceed = false;\n                        $this->pageAlert(__('An unknown database occurred while attempting to create the section.'), Alert::ERROR);\n                    }\n                }\n\n                if ($section_id && $canProceed) {\n                    if ($edit) {\n                        // Delete missing CF's\n                        $id_list = array();\n\n                        if (is_array($fields) && !empty($fields)) {\n                            foreach ($fields as $position => $data) {\n                                if (isset($data['id'])) {\n                                    $id_list[] = $data['id'];\n                                }\n                            }\n                        }\n\n                        $missing_cfs = Symphony::Database()->fetchCol('id', \"SELECT `id` FROM `tbl_fields` WHERE `parent_section` = '$section_id' AND `id` NOT IN ('\".@implode(\"', '\", $id_list).\"')\");\n\n                        if (is_array($missing_cfs) && !empty($missing_cfs)) {\n                            foreach ($missing_cfs as $id) {\n                                FieldManager::delete($id);\n                            }\n                        }\n                    }\n\n                    // Save each custom field\n                    if (is_array($fields) && !empty($fields)) {\n                        foreach ($fields as $position => $data) {\n                            $field = FieldManager::create($data['type']);\n                            $field->setFromPOST($data);\n                            $field->set('sortorder', (string)$position);\n                            $field->set('parent_section', $section_id);\n\n                            $newField = !(boolean)$field->get('id');\n\n                            $field->commit();\n                            $field_id = $field->get('id');\n\n                            if ($field_id) {\n                                if ($newField) {\n                                    /**\n                                     * After creation of a Field.\n                                     *\n                                     * @delegate FieldPostCreate\n                                     * @param string $context\n                                     * '/blueprints/sections/'\n                                     * @param Field $field\n                                     *  The Field object, passed by reference\n                                     * @param array $data\n                                     *  The settings for ths `$field`, passed by reference\n                                     */\n                                    Symphony::ExtensionManager()->notifyMembers('FieldPostCreate', '/blueprints/sections/', array('field' => &$field, 'data' => &$data));\n                                } else {\n                                    /**\n                                     * After editing of a Field.\n                                     *\n                                     * @delegate FieldPostEdit\n                                     * @param string $context\n                                     * '/blueprints/sections/'\n                                     * @param Field $field\n                                     *  The Field object, passed by reference\n                                     * @param array $data\n                                     *  The settings for ths `$field`, passed by reference\n                                     */\n                                    Symphony::ExtensionManager()->notifyMembers('FieldPostEdit', '/blueprints/sections/', array('field' => &$field, 'data' => &$data));\n                                }\n                            }\n                        }\n                    }\n\n                    if (!$edit) {\n                        /**\n                         * After the Section has been created, and all the Field's have been\n                         * created for this section, but just before the redirect\n                         *\n                         * @delegate SectionPostCreate\n                         * @since Symphony 2.2\n                         * @param string $context\n                         * '/blueprints/sections/'\n                         * @param integer $section_id\n                         *  The newly created Section ID.\n                         */\n                        Symphony::ExtensionManager()->notifyMembers('SectionPostCreate', '/blueprints/sections/', array('section_id' => $section_id));\n\n                        redirect(SYMPHONY_URL . \"/blueprints/sections/edit/$section_id/created/\");\n                    } else {\n                        /**\n                         * After the Section has been updated, and all the Field's have been\n                         * updated for this section, but just before the redirect\n                         *\n                         * @delegate SectionPostEdit\n                         * @since Symphony 2.2\n                         * @param string $context\n                         * '/blueprints/sections/'\n                         * @param integer $section_id\n                         *  The edited Section ID.\n                         */\n                        Symphony::ExtensionManager()->notifyMembers('SectionPostEdit', '/blueprints/sections/', array('section_id' => $section_id));\n\n                        redirect(SYMPHONY_URL . \"/blueprints/sections/edit/$section_id/saved/\");\n                    }\n                }\n            }\n        }\n\n        if (@array_key_exists(\"delete\", $_POST['action'])) {\n            $section_id = array($this->_context[1]);\n\n            /**\n             * Just prior to calling the Section Manager's delete function\n             *\n             * @delegate SectionPreDelete\n             * @since Symphony 2.2\n             * @param string $context\n             * '/blueprints/sections/'\n             * @param array $section_ids\n             *  An array of Section ID's passed by reference\n             */\n            Symphony::ExtensionManager()->notifyMembers('SectionPreDelete', '/blueprints/sections/', array('section_ids' => &$section_id));\n\n            foreach ($section_id as $section) {\n                SectionManager::delete($section);\n            }\n\n            redirect(SYMPHONY_URL . '/blueprints/sections/');\n        }\n    }\n\n    public function __actionEdit()\n    {\n        return $this->__actionNew();\n    }\n\n    public function addSectionOptions(array &$meta = null)\n    {\n        $fieldset = new XMLElement('fieldset');\n        $fieldset->setAttribute('class', 'settings');\n        $fieldset->appendChild(new XMLElement('legend', __('Options')));\n\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        $hidediv = new XMLElement('div', null, array('class' => 'column'));\n        $label = Widget::Checkbox('meta[hidden]', $meta['hidden'], __('Hide this section from the back-end menu'));\n        $hidediv->appendChild($label);\n        $div->appendChild($hidediv);\n\n        $filterdiv = new XMLElement('div', null, array('class' => 'column'));\n        $label = Widget::Checkbox('meta[filter]', $meta['filter'], __('Allow filtering of section entries'));\n        $filterdiv->appendChild($label);\n\n        $div->appendChild($filterdiv);\n        $fieldset->appendChild($div);\n        $this->Form->appendChild($fieldset);\n\n        /**\n         * Allows extensions to add elements to the header of the Section Editor\n         * form. Usually for section settings, this delegate is passed the current\n         * `$meta` array and the `$this->_errors` array.\n         *\n         * @delegate AddSectionElements\n         * @since Symphony 2.2\n         * @param string $context\n         * '/blueprints/sections/'\n         * @param XMLElement $form\n         *  An XMLElement of the current `$this->Form`, just after the Section\n         *  settings have been appended, but before the Fields duplicator\n         * @param array $meta\n         *  The current $_POST['meta'] array\n         * @param array $errors\n         *  The current errors array\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddSectionElements', '/blueprints/sections/', array(\n            'form' => &$this->Form,\n            'meta' => &$meta,\n            'errors' => &$this->_errors\n        ));\n    }\n}\n", "<?php\n\n/**\n * @package content\n */\n/**\n * The Publish page is where the majority of an Authors time will\n * be spent in Symphony with adding, editing and removing entries\n * from Sections. This Page controls the entries table as well as\n * the Entry creation screens.\n */\n\nclass contentPublish extends AdministrationPage\n{\n    public $_errors = array();\n\n    public function sort(&$sort, &$order, $params)\n    {\n        $section = $params['current-section'];\n\n        // If `?unsort` is appended to the URL, then sorting is reverted\n        // to 'none', aka. by 'entry-id'.\n        if ($params['unsort']) {\n            $section->setSortingField('id', false);\n            $section->setSortingOrder('desc');\n\n            redirect(Administration::instance()->getCurrentPageURL());\n        }\n\n        // By default, sorting information are retrieved from\n        // the filesystem and stored inside the `Configuration` object\n        if (is_null($sort) && is_null($order)) {\n            $sort = $section->getSortingField();\n            $order = $section->getSortingOrder();\n\n            // Set the sorting in the `EntryManager` for subsequent use\n            EntryManager::setFetchSorting($sort, $order);\n        } else {\n            $sort = General::sanitize($sort);\n\n            // Ensure that this field is infact sortable, otherwise\n            // fallback to IDs\n            if (($field = FieldManager::fetch($sort)) instanceof Field && !$field->isSortable()) {\n                $sort = $section->getDefaultSortingField();\n            }\n\n            // If the sort order or direction differs from what is saved,\n            // update the config file and reload the page\n            if ($sort != $section->getSortingField() || $order != $section->getSortingOrder()) {\n                $section->setSortingField($sort, false);\n                $section->setSortingOrder($order);\n\n                if ($params['filters']) {\n                    $params['filters'] = '?' . trim($params['filters'], '&amp;');\n                }\n\n                redirect(Administration::instance()->getCurrentPageURL() . $params['filters']);\n            }\n\n            // If the sort order or direction remains the same, reload the page\n            if ($sort == $section->getSortingField() && $order == $section->getSortingOrder()) {\n                if ($params['filters']) {\n                    $params['filters'] = '?' . trim($params['filters'], '&amp;');\n                }\n\n                redirect(Administration::instance()->getCurrentPageURL() . $params['filters']);\n            }\n        }\n    }\n\n    /**\n     * Append filtering interface\n     */\n    public function createFilteringInterface()\n    {\n        //Check if section has filtering enabled\n        $context = $this->getContext();\n        $handle = $context['section_handle'];\n        $section_id = SectionManager::fetchIDFromHandle($handle);\n        $section = SectionManager::fetch($section_id);\n        $filter = $section->get('filter');\n        $count = EntryManager::fetchCount($section_id);\n\n        if ($filter !== 'no' && $count > 1) {\n            $drawer = Widget::Drawer('filtering-' . $section_id, __('Filter Entries'), $this->createFilteringDrawer($section));\n            $drawer->addClass('drawer-filtering');\n            $this->insertDrawer($drawer);\n        }\n    }\n\n    /**\n     * Create filtering drawer\n     */\n    public function createFilteringDrawer($section)\n    {\n        $this->filteringForm = Widget::Form(null, 'get', 'filtering');\n        $this->createFilteringDuplicator($section);\n\n        return $this->filteringForm;\n    }\n\n    public function createFilteringDuplicator($section)\n    {\n        $div = new XMLElement('div');\n        $div->setAttribute('class', 'frame filters-duplicator');\n        $div->setAttribute('data-interactive', 'data-interactive');\n\n        $ol = new XMLElement('ol');\n        $ol->setAttribute('data-add', __('Add filter'));\n        $ol->setAttribute('data-remove', __('Clear filter'));\n        $ol->setAttribute('data-empty', __('No filters applied yet.'));\n\n        $this->createFieldFilters($ol, $section);\n        $this->createSystemDateFilters($ol);\n\n        $div->appendChild($ol);\n        $this->filteringForm->appendChild($div);\n    }\n\n    private function createFieldFilters(&$wrapper, $section)\n    {\n        $filters = $_GET['filter'];\n\n        foreach ($section->fetchFilterableFields() as $field) {\n            if (!$field->canPublishFilter()) {\n                continue;\n            }\n\n            $filter = $filters[$field->get('element_name')];\n\n            // Filter data\n            $data = array();\n            $data['type'] = $field->get('element_name');\n            $data['name'] = $field->get('label');\n            $data['filter'] = $filter;\n            $data['instance'] = 'unique';\n            $data['search'] = $field->fetchSuggestionTypes();\n            $data['operators'] = $field->fetchFilterableOperators();\n            $data['comparisons'] = $this->createFilterComparisons($data);\n            $data['query'] = $this->getFilterQuery($data);\n            $data['field-id'] = $field->get('id');\n\n            // Add existing filter\n            if (isset($filter)) {\n                $this->createFilter($wrapper, $data);\n            }\n\n            // Add filter template\n            $data['instance'] = 'unique template';\n            $data['query'] = '';\n            $this->createFilter($wrapper, $data);\n        }\n    }\n\n    private function createSystemDateFilters(&$wrapper)\n    {\n        $filters = $_GET['filter'];\n        $dateField = new FieldDate;\n\n        $fields = array(\n            array(\n                'type' => 'system:creation-date',\n                'label' => __('System Creation Date')\n            ),\n            array(\n                'type' => 'system:modification-date',\n                'label' => __('System Modification Date')\n            )\n        );\n\n        foreach ($fields as $field) {\n            $filter = $filters[$field['type']];\n\n            // Filter data\n            $data = array();\n            $data['type'] = $field['type'];\n            $data['name'] = $field['label'];\n            $data['filter'] = $filter;\n            $data['instance'] = 'unique';\n            $data['search'] = $dateField->fetchSuggestionTypes();\n            $data['operators'] = $dateField->fetchFilterableOperators();\n            $data['comparisons'] = $this->createFilterComparisons($data);\n            $data['query'] = $this->getFilterQuery($data);\n\n            // Add existing filter\n            if (isset($filter)) {\n                $this->createFilter($wrapper, $data);\n            }\n\n            // Add filter template\n            $data['instance'] = 'unique template';\n            $data['query'] = '';\n            $this->createFilter($wrapper, $data);\n        }\n    }\n\n    private function createFilter(&$wrapper, $data)\n    {\n        $li = new XMLElement('li');\n        $li->setAttribute('class', $data['instance']);\n        $li->setAttribute('data-type', $data['type']);\n\n        // Header\n        $li->appendChild(new XMLElement('header', $data['name'], array(\n            'data-name' => $data['name']\n        )));\n\n        // Settings\n        $div = new XMLElement('div', null, array('class' => 'two columns'));\n\n        // Comparisons\n        $label = Widget::Label();\n        $label->setAttribute('class', 'column secondary');\n\n        $select = Widget::Select($data['type'] . '-comparison', $data['comparisons'], array(\n            'class' => 'comparison'\n        ));\n\n        $label->appendChild($select);\n        $div->appendChild($label);\n\n        // Query\n        $label = Widget::Label();\n        $label->setAttribute('class', 'column primary');\n\n        $input = Widget::Input($data['type'], General::sanitize($data['query']), 'text', array(\n            'placeholder' => __('Type and hit enter to apply filter\u2026'),\n            'autocomplete' => 'off'\n        ));\n        $input->setAttribute('class', 'filter');\n        $label->appendChild($input);\n\n        $this->createFilterSuggestions($label, $data);\n\n        $div->appendChild($label);\n        $li->appendChild($div);\n        $wrapper->appendChild($li);\n    }\n\n    private function createFilterComparisons($data)\n    {\n        // Default comparison\n        $comparisons = array();\n\n        // Custom field comparisons\n        foreach ($data['operators'] as $operator) {\n\n            $filter = trim($operator['filter']);\n\n            // Check selected state\n            $selected = false;\n\n            // Selected state : Comparison mode \"between\" (x to y)\n            if ($operator['title'] === 'between' && preg_match('/^(-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)) to (-?(?:\\d+(?:\\.\\d+)?|\\.\\d+))$/i', $data['filter'] )) {\n                $selected = true;\n            // Selected state : Other comparison modes (except \"is\")\n            } else if ((!empty($filter) && strpos($data['filter'], $filter) === 0)) {\n                $selected = true;\n            }\n\n            $comparisons[] = array(\n                $operator['filter'],\n                $selected,\n                __($operator['title']),\n                null,\n                null,\n                array('data-comparison' => $operator['title'])\n            );\n        }\n\n        return $comparisons;\n    }\n\n    private function createFilterSuggestions(&$wrapper, $data)\n    {\n        $ul = new XMLElement('ul');\n        $ul->setAttribute('class', 'suggestions');\n        $ul->setAttribute('data-field-id', $data['field-id']);\n        $ul->setAttribute('data-associated-ids', '0');\n        $ul->setAttribute('data-search-types', implode($data['search'], ','));\n\n        // Add help text for each filter operator\n        foreach ($data['operators'] as $operator) {\n            $this->createFilterHelp($ul, $operator);\n        }\n\n        $wrapper->appendChild($ul);\n    }\n\n    private function createFilterHelp(&$wrapper, $operator)\n    {\n        if (empty($operator['help'])) {\n            return;\n        }\n\n        $li = new XMLElement('li', __('Comparison mode') . ': ' . $operator['help'], array(\n            'class' => 'help',\n            'data-comparison' => $operator['title']\n        ));\n\n        $wrapper->appendChild($li);\n    }\n\n    private function getFilterQuery($data)\n    {\n        $query = $data['filter'];\n\n        foreach ($data['operators'] as $operator) {\n            $filter = trim($operator['filter']);\n\n            if (!empty($filter) && strpos($data['filter'], $filter) === 0) {\n                $query = substr($data['filter'], strlen($operator['filter']));\n            }\n        }\n\n        return (string)$query;\n    }\n\n    public function build(array $context = array())\n    {\n        $section_id = SectionManager::fetchIDFromHandle($context['section_handle']);\n\n        if ($section_id) {\n            $context['associations'] = array(\n                'parent' => SectionManager::fetchParentAssociations($section_id),\n                'child' => SectionManager::fetchChildAssociations($section_id)\n            );\n        }\n\n        return parent::build($context);\n    }\n\n    public function action()\n    {\n        $this->__switchboard('action');\n    }\n\n    public function __switchboard($type = 'view')\n    {\n        $function = ($type == 'action' ? '__action' : '__view') . ucfirst($this->_context['page']);\n\n        if (!method_exists($this, $function)) {\n            // If there is no action function, just return without doing anything\n            if ($type == 'action') {\n                return;\n            }\n\n            Administration::instance()->errorPageNotFound();\n        }\n\n        // Is this request allowed by server?\n        if ($this->isRequestValid() === false) {\n            $this->pageAlert(__('This request exceeds the maximum allowed request size of %s specified by your host.', array(\n                    ini_get('post_max_size')\n                )),\n                Alert::ERROR\n            );\n        }\n        $this->$function();\n    }\n\n    public function view()\n    {\n        $this->__switchboard();\n    }\n\n    public function __viewIndex()\n    {\n        if (!$section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle'])) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        } elseif (!is_writable(CONFIG)) {\n            $this->pageAlert(__('The Symphony configuration file, %s, is not writable. The sort order cannot be modified.', array('<code>/manifest/config.php</code>')), Alert::NOTICE);\n        }\n\n        $section = SectionManager::fetch($section_id);\n\n        $this->setPageType('table');\n        $this->setTitle(__('%1$s &ndash; %2$s', array(General::sanitize($section->get('name')), __('Symphony'))));\n\n        $filters = array();\n        $filter_querystring = $prepopulate_querystring = $where = $joins = null;\n        $current_page = (isset($_REQUEST['pg']) && is_numeric($_REQUEST['pg']) ? max(1, intval($_REQUEST['pg'])) : 1);\n\n        if (isset($_REQUEST['filter'])) {\n            // legacy implementation, convert single filter to an array\n            // split string in the form ?filter=handle:value\n            if (!is_array($_REQUEST['filter'])) {\n                list($field_handle, $filter_value) = explode(':', $_REQUEST['filter'], 2);\n                $filters[$field_handle] = rawurldecode($filter_value);\n            } else {\n                $filters = $_REQUEST['filter'];\n            }\n\n            foreach ($filters as $handle => $value) {\n                // Handle multiple values through filtering. RE: #2290\n                if ((is_array($value) && empty($value)) || trim($value) == '') {\n                    continue;\n                }\n\n                if (!is_array($value)) {\n                    $filter_type = Datasource::determineFilterType($value);\n                    $value = preg_split('/'.($filter_type == Datasource::FILTER_AND ? '\\+' : '(?<!\\\\\\\\),').'\\s*/', $value, -1, PREG_SPLIT_NO_EMPTY);\n                    $value = array_map('trim', $value);\n                    $value = array_map(array('Datasource', 'removeEscapedCommas'), $value);\n                }\n\n                // Handle date meta data #2003\n                $handle = Symphony::Database()->cleanValue($handle);\n                if (in_array($handle, array('system:creation-date', 'system:modification-date'))) {\n                    $date_joins = '';\n                    $date_where = '';\n                    $date = new FieldDate();\n                    $date->buildDSRetrievalSQL($value, $date_joins, $date_where, ($filter_type == Datasource::FILTER_AND ? true : false));\n\n                    // Replace the date field where with the `creation_date` or `modification_date`.\n                    $date_where = preg_replace('/`t\\d+`.date/', ($field_id !== 'system:modification-date') ? '`e`.creation_date_gmt' : '`e`.modification_date_gmt', $date_where);\n                    $where .= $date_where;\n                } else {\n                    // Handle normal fields\n                    $field_id = FieldManager::fetchFieldIDFromElementName(\n                        $handle,\n                        $section->get('id')\n                    );\n\n                    $field = FieldManager::fetch($field_id);\n                    if ($field instanceof Field) {\n                        $field->buildDSRetrievalSQL($value, $joins, $where, ($filter_type == Datasource::FILTER_AND ? true : false));\n\n                        $value = implode(',', $value);\n                        $encoded_value = rawurlencode($value);\n                        $filter_querystring .= sprintf(\"filter[%s]=%s&amp;\", $handle, $encoded_value);\n\n                        // Some fields require that prepopulation be done via ID. RE: #2331\n                        if (!is_numeric($value) && method_exists($field, 'fetchIDfromValue')) {\n                            $encoded_value = $field->fetchIDfromValue($value);\n                        }\n                        $prepopulate_querystring .= sprintf(\"prepopulate[%d]=%s&amp;\", $field_id, $encoded_value);\n                    } else {\n                        unset($filters[$handle]);\n                    }\n                }\n            }\n\n            $filter_querystring = preg_replace(\"/&amp;$/\", '', $filter_querystring);\n            $prepopulate_querystring = preg_replace(\"/&amp;$/\", '', $prepopulate_querystring);\n        }\n\n        Sortable::initialize($this, $entries, $sort, $order, array(\n            'current-section' => $section,\n            'filters' => ($filter_querystring ? \"&amp;\" . $filter_querystring : ''),\n            'unsort' => isset($_REQUEST['unsort'])\n        ));\n\n        $this->Form->setAttribute('action', Administration::instance()->getCurrentPageURL(). '?pg=' . $current_page.($filter_querystring ? \"&amp;\" . $filter_querystring : ''));\n\n        // Build filtering interface\n        $this->createFilteringInterface();\n\n        $subheading_buttons = array(\n            Widget::Anchor(__('Create New'), Administration::instance()->getCurrentPageURL().'new/'.($prepopulate_querystring ? '?' . $prepopulate_querystring : ''), __('Create a new entry'), 'create button', null, array('accesskey' => 'c'))\n        );\n\n        // Only show the Edit Section button if the Author is a developer. #938 ^BA\n        if (Symphony::Author()->isDeveloper()) {\n            array_unshift($subheading_buttons, Widget::Anchor(__('Edit Section'), SYMPHONY_URL . '/blueprints/sections/edit/' . $section_id . '/', __('Edit Section Configuration'), 'button'));\n        }\n\n        $this->appendSubheading(General::sanitize($section->get('name')), $subheading_buttons);\n\n        /**\n         * Allows adjustments to be made to the SQL where and joins statements\n         * before they are used to fetch the entries for the page\n         *\n         * @delegate AdjustPublishFiltering\n         * @since Symphony 2.3.3\n         * @param string $context\n         * '/publish/'\n         * @param integer $section_id\n         * An array of the current columns, passed by reference\n         * @param string $where\n         * The current where statement, or null if not set\n         * @param string $joins\n         */\n        Symphony::ExtensionManager()->notifyMembers('AdjustPublishFiltering', '/publish/', array('section-id' => $section_id, 'where' => &$where, 'joins' => &$joins));\n\n        // get visible columns\n        $visible_columns = $section->fetchVisibleColumns();\n        // extract the needed schema\n        $element_names = array_values(array_map(function ($field) {\n            return $field->get('element_name');\n        }, $visible_columns));\n\n        // Check that the filtered query fails that the filter is dropped and an\n        // error is logged. #841 ^BA\n        try {\n            $entries = EntryManager::fetchByPage($current_page, $section_id, Symphony::Configuration()->get('pagination_maximum_rows', 'symphony'), $where, $joins, true, false, true, $element_names);\n        } catch (DatabaseException $ex) {\n            $this->pageAlert(__('An error occurred while retrieving filtered entries. Showing all entries instead.'), Alert::ERROR);\n            $filter_querystring = null;\n            Symphony::Log()->pushToLog(sprintf(\n                    '%s - %s%s%s',\n                    $section->get('name') . ' Publish Index',\n                    $ex->getMessage(),\n                    ($ex->getFile() ? \" in file \" .  $ex->getFile() : null),\n                    ($ex->getLine() ? \" on line \" . $ex->getLine() : null)\n                ),\n                E_NOTICE,\n                true\n            );\n            $entries = EntryManager::fetchByPage($current_page, $section_id, Symphony::Configuration()->get('pagination_maximum_rows', 'symphony'), null, null, true, false, true, $element_names);\n        }\n\n        // Flag filtering\n        if (isset($_REQUEST['filter'])) {\n            $filter_stats = new XMLElement('p', '<span>\u2013 ' . __('%d of %d entries (filtered)', array($entries['total-entries'], EntryManager::fetchCount($section_id))) . '</span>', array('class' => 'inactive'));\n        } else {\n            $filter_stats = new XMLElement('p', '<span>\u2013 ' . __('%d entries', array($entries['total-entries'])) . '</span>', array('class' => 'inactive'));\n        }\n        $this->Breadcrumbs->appendChild($filter_stats);\n\n        // Build table\n        $columns = array();\n\n        if (is_array($visible_columns) && !empty($visible_columns)) {\n            foreach ($visible_columns as $column) {\n                $columns[] = array(\n                    'label' => $column->get('label'),\n                    'sortable' => $column->isSortable(),\n                    'handle' => $column->get('id'),\n                    'attrs' => array(\n                        'id' => 'field-' . $column->get('id'),\n                        'class' => 'field-' . $column->get('type')\n                    )\n                );\n            }\n        } else {\n            $columns[] = array(\n                'label' => __('ID'),\n                'sortable' => true,\n                'handle' => 'id'\n            );\n        }\n\n        $aTableHead = Sortable::buildTableHeaders($columns, $sort, $order, ($filter_querystring) ? \"&amp;\" . $filter_querystring : '');\n\n        $child_sections = array();\n        $associated_sections = $section->fetchChildAssociations(true);\n\n        if (is_array($associated_sections) && !empty($associated_sections)) {\n            foreach ($associated_sections as $key => $as) {\n                $child_sections[$key] = SectionManager::fetch($as['child_section_id']);\n                $aTableHead[] = array($child_sections[$key]->get('name'), 'col');\n            }\n        }\n\n        /**\n         * Allows the creation of custom table columns for each entry. Called\n         * after all the Section Visible columns have been added as well\n         * as the Section Associations\n         *\n         * @delegate AddCustomPublishColumn\n         * @since Symphony 2.2\n         * @param string $context\n         * '/publish/'\n         * @param array $tableHead\n         * An array of the current columns, passed by reference\n         * @param integer $section_id\n         * The current Section ID\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddCustomPublishColumn', '/publish/', array('tableHead' => &$aTableHead, 'section_id' => $section->get('id')));\n\n        // Table Body\n        $aTableBody = array();\n\n        if (!is_array($entries['records']) || empty($entries['records'])) {\n            $aTableBody = array(\n                Widget::TableRow(array(Widget::TableData(__('None found.'), 'inactive', null, count($aTableHead))), 'odd')\n            );\n        } else {\n            $field_pool = array();\n\n            if (is_array($visible_columns) && !empty($visible_columns)) {\n                foreach ($visible_columns as $column) {\n                    $field_pool[$column->get('id')] = $column;\n                }\n            }\n\n            $link_column = array_reverse($visible_columns);\n            $link_column = end($link_column);\n            reset($visible_columns);\n\n            foreach ($entries['records'] as $entry) {\n                $tableData = array();\n\n                // Setup each cell\n                if (!is_array($visible_columns) || empty($visible_columns)) {\n                    $tableData[] = Widget::TableData(Widget::Anchor($entry->get('id'), Administration::instance()->getCurrentPageURL() . 'edit/' . $entry->get('id') . '/'));\n                } else {\n                    $link = Widget::Anchor(\n                        '',\n                        Administration::instance()->getCurrentPageURL() . 'edit/' . $entry->get('id') . '/'.($filter_querystring ? '?' . $prepopulate_querystring : ''),\n                        $entry->get('id'),\n                        'content'\n                    );\n\n                    foreach ($visible_columns as $position => $column) {\n                        $data = $entry->getData($column->get('id'));\n                        $field = $field_pool[$column->get('id')];\n\n                        $value = $field->prepareTableValue($data, ($column == $link_column) ? $link : null, $entry->get('id'));\n\n                        if (!is_object($value) && (strlen(trim($value)) == 0 || $value == __('None'))) {\n                            $value = ($position == 0 ? $link->generate() : __('None'));\n                        }\n\n                        if ($value == __('None')) {\n                            $tableData[] = Widget::TableData($value, 'inactive field-' . $column->get('type') . ' field-' . $column->get('id'));\n                        } else {\n                            $tableData[] = Widget::TableData($value, 'field-' . $column->get('type') . ' field-' . $column->get('id'));\n                        }\n\n                        unset($field);\n                    }\n                }\n\n                if (is_array($child_sections) && !empty($child_sections)) {\n                    foreach ($child_sections as $key => $as) {\n                        $field = FieldManager::fetch((int)$associated_sections[$key]['child_section_field_id']);\n                        $parent_section_field_id = (int)$associated_sections[$key]['parent_section_field_id'];\n\n                        if (!is_null($parent_section_field_id)) {\n                            $search_value = $field->fetchAssociatedEntrySearchValue(\n                                $entry->getData($parent_section_field_id),\n                                $parent_section_field_id,\n                                $entry->get('id')\n                            );\n                        } else {\n                            $search_value = $entry->get('id');\n                        }\n\n                        if (!is_array($search_value)) {\n                            $associated_entry_count = $field->fetchAssociatedEntryCount($search_value);\n\n                            $tableData[] = Widget::TableData(\n                                Widget::Anchor(\n                                    sprintf('%d &rarr;', max(0, intval($associated_entry_count))),\n                                    sprintf(\n                                        '%s/publish/%s/?filter[%s]=%s',\n                                        SYMPHONY_URL,\n                                        $as->get('handle'),\n                                        $field->get('element_name'),\n                                        rawurlencode($search_value)\n                                    ),\n                                    $entry->get('id'),\n                                    'content'\n                                )\n                            );\n                        }\n                    }\n                }\n\n                /**\n                 * Allows Extensions to inject custom table data for each Entry\n                 * into the Publish Index\n                 *\n                 * @delegate AddCustomPublishColumnData\n                 * @since Symphony 2.2\n                 * @param string $context\n                 * '/publish/'\n                 * @param array $tableData\n                 *  An array of `Widget::TableData`, passed by reference\n                 * @param integer $section_id\n                 *  The current Section ID\n                 * @param Entry $entry_id\n                 *  The entry object, please note that this is by error and this will\n                 *  be removed in Symphony 2.4. The entry object is available in\n                 *  the 'entry' key as of Symphony 2.3.1.\n                 * @param Entry $entry\n                 *  The entry object for this row\n                 */\n                Symphony::ExtensionManager()->notifyMembers('AddCustomPublishColumnData', '/publish/', array(\n                    'tableData' => &$tableData,\n                    'section_id' => $section->get('id'),\n                    'entry_id' => $entry,\n                    'entry' => $entry\n                ));\n\n                $tableData[count($tableData) - 1]->appendChild(Widget::Label(__('Select Entry %d', array($entry->get('id'))), null, 'accessible', null, array(\n                    'for' => 'entry-' . $entry->get('id')\n                )));\n                $tableData[count($tableData) - 1]->appendChild(Widget::Input('items['.$entry->get('id').']', null, 'checkbox', array(\n                    'id' => 'entry-' . $entry->get('id')\n                )));\n\n                // Add a row to the body array, assigning each cell to the row\n                $aTableBody[] = Widget::TableRow($tableData, null, 'id-' . $entry->get('id'));\n            }\n        }\n\n        $table = Widget::Table(\n            Widget::TableHead($aTableHead),\n            null,\n            Widget::TableBody($aTableBody),\n            'selectable',\n            null,\n            array('role' => 'directory', 'aria-labelledby' => 'symphony-subheading', 'data-interactive' => 'data-interactive')\n        );\n\n        $this->Form->appendChild($table);\n\n        $tableActions = new XMLElement('div');\n        $tableActions->setAttribute('class', 'actions');\n\n        $options = array(\n            array(null, false, __('With Selected...')),\n            array('delete', false, __('Delete'), 'confirm', null, array(\n                'data-message' => __('Are you sure you want to delete the selected entries?')\n            ))\n        );\n\n        $toggable_fields = $section->fetchToggleableFields();\n\n        if (is_array($toggable_fields) && !empty($toggable_fields)) {\n            $index = 2;\n\n            foreach ($toggable_fields as $field) {\n                $toggle_states = $field->getToggleStates();\n\n                if (is_array($toggle_states)) {\n                    $options[$index] = array('label' => __('Set %s', array($field->get('label'))), 'options' => array());\n\n                    foreach ($toggle_states as $value => $state) {\n                        $options[$index]['options'][] = array('toggle-' . $field->get('id') . '-' . $value, false, $state);\n                    }\n                }\n\n                $index++;\n            }\n        }\n\n        /**\n         * Allows an extension to modify the existing options for this page's\n         * With Selected menu. If the `$options` parameter is an empty array,\n         * the 'With Selected' menu will not be rendered.\n         *\n         * @delegate AddCustomActions\n         * @since Symphony 2.3.2\n         * @param string $context\n         * '/publish/'\n         * @param array $options\n         *  An array of arrays, where each child array represents an option\n         *  in the With Selected menu. Options should follow the same format\n         *  expected by `Widget::__SelectBuildOption`. Passed by reference.\n         */\n        Symphony::ExtensionManager()->notifyMembers('AddCustomActions', '/publish/', array(\n            'options' => &$options\n        ));\n\n        if (!empty($options)) {\n            $tableActions->appendChild(Widget::Apply($options));\n            $this->Form->appendChild($tableActions);\n        }\n\n        if ($entries['total-pages'] > 1) {\n            $ul = new XMLElement('ul');\n            $ul->setAttribute('class', 'page');\n\n            // First\n            $li = new XMLElement('li');\n\n            if ($current_page > 1) {\n                $li->appendChild(Widget::Anchor(__('First'), Administration::instance()->getCurrentPageURL(). '?pg=1'.($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('First'));\n            }\n\n            $ul->appendChild($li);\n\n            // Previous\n            $li = new XMLElement('li');\n\n            if ($current_page > 1) {\n                $li->appendChild(Widget::Anchor(__('&larr; Previous'), Administration::instance()->getCurrentPageURL(). '?pg=' . ($current_page - 1).($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('&larr; Previous'));\n            }\n\n            $ul->appendChild($li);\n\n            // Summary\n            $li = new XMLElement('li');\n\n            $li->setAttribute('title', __('Viewing %1$s - %2$s of %3$s entries', array(\n                $entries['start'],\n                ($current_page != $entries['total-pages']) ? $current_page * Symphony::Configuration()->get('pagination_maximum_rows', 'symphony') : $entries['total-entries'],\n                $entries['total-entries']\n            )));\n\n            $pgform = Widget::Form(Administration::instance()->getCurrentPageURL(), 'get', 'paginationform');\n\n            $pgmax = max($current_page, $entries['total-pages']);\n            $pgform->appendChild(Widget::Input('pg', null, 'text', array(\n                'data-active' => __('Go to page \u2026'),\n                'data-inactive' => __('Page %1$s of %2$s', array((string)$current_page, $pgmax)),\n                'data-max' => $pgmax\n            )));\n\n            $li->appendChild($pgform);\n            $ul->appendChild($li);\n\n            // Next\n            $li = new XMLElement('li');\n\n            if ($current_page < $entries['total-pages']) {\n                $li->appendChild(Widget::Anchor(__('Next &rarr;'), Administration::instance()->getCurrentPageURL(). '?pg=' . ($current_page + 1).($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('Next &rarr;'));\n            }\n\n            $ul->appendChild($li);\n\n            // Last\n            $li = new XMLElement('li');\n\n            if ($current_page < $entries['total-pages']) {\n                $li->appendChild(Widget::Anchor(__('Last'), Administration::instance()->getCurrentPageURL(). '?pg=' . $entries['total-pages'].($filter_querystring ? \"&amp;\" . $filter_querystring : '')));\n            } else {\n                $li->setValue(__('Last'));\n            }\n\n            $ul->appendChild($li);\n\n            $this->Contents->appendChild($ul);\n        }\n    }\n\n    public function __actionIndex()\n    {\n        $checked = (is_array($_POST['items'])) ? array_keys($_POST['items']) : null;\n\n        if (is_array($checked) && !empty($checked)) {\n            /**\n             * Extensions can listen for any custom actions that were added\n             * through `AddCustomPreferenceFieldsets` or `AddCustomActions`\n             * delegates.\n             *\n             * @delegate CustomActions\n             * @since Symphony 2.3.2\n             * @param string $context\n             *  '/publish/'\n             * @param array $checked\n             *  An array of the selected rows. The value is usually the ID of the\n             *  the associated object.\n             */\n            Symphony::ExtensionManager()->notifyMembers('CustomActions', '/publish/', array(\n                'checked' => $checked\n            ));\n\n            switch ($_POST['with-selected']) {\n                case 'delete':\n                    /**\n                     * Prior to deletion of entries. An array of Entry ID's is provided which\n                     * can be manipulated. This delegate was renamed from `Delete` to `EntryPreDelete`\n                     * in Symphony 2.3.\n                     *\n                     * @delegate EntryPreDelete\n                     * @param string $context\n                     * '/publish/'\n                     * @param array $entry_id\n                     *  An array of Entry ID's passed by reference\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPreDelete', '/publish/', array('entry_id' => &$checked));\n\n                    EntryManager::delete($checked);\n\n                    /**\n                     * After the deletion of entries, this delegate provides an array of Entry ID's\n                     * that were deleted.\n                     *\n                     * @since Symphony 2.3\n                     * @delegate EntryPostDelete\n                     * @param string $context\n                     * '/publish/'\n                     * @param array $entry_id\n                     *  An array of Entry ID's that were deleted.\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPostDelete', '/publish/', array('entry_id' => $checked));\n\n                    redirect(server_safe('REQUEST_URI'));\n                    break;\n                default:\n                    list($option, $field_id, $value) = explode('-', $_POST['with-selected'], 3);\n\n                    if ($option == 'toggle') {\n                        $field = FieldManager::fetch($field_id);\n                        $fields = array($field->get('element_name') => $value);\n\n                        $section = SectionManager::fetch($field->get('parent_section'));\n\n                        foreach ($checked as $entry_id) {\n                            $entry = EntryManager::fetch($entry_id);\n                            $existing_data = $entry[0]->getData($field_id);\n                            $entry[0]->setData($field_id, $field->toggleFieldData(is_array($existing_data) ? $existing_data : array(), $value, $entry_id));\n\n                            /**\n                             * Just prior to editing of an Entry\n                             *\n                             * @delegate EntryPreEdit\n                             * @param string $context\n                             * '/publish/edit/'\n                             * @param Section $section\n                             * @param Entry $entry\n                             * @param array $fields\n                             */\n                            Symphony::ExtensionManager()->notifyMembers('EntryPreEdit', '/publish/edit/', array(\n                                'section' => $section,\n                                'entry' => &$entry[0],\n                                'fields' => $fields\n                            ));\n\n                            $entry[0]->commit();\n\n                            /**\n                             * Editing an entry. Entry object is provided.\n                             *\n                             * @delegate EntryPostEdit\n                             * @param string $context\n                             * '/publish/edit/'\n                             * @param Section $section\n                             * @param Entry $entry\n                             * @param array $fields\n                             */\n                            Symphony::ExtensionManager()->notifyMembers('EntryPostEdit', '/publish/edit/', array(\n                                'section' => $section,\n                                'entry' => $entry[0],\n                                'fields' => $fields\n                            ));\n                        }\n\n                        redirect(server_safe('REQUEST_URI'));\n                    }\n            }\n        }\n    }\n\n    public function __viewNew()\n    {\n        if (!$section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle'])) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n\n        $section = SectionManager::fetch($section_id);\n\n        $this->setPageType('form');\n        $this->setTitle(__('%1$s &ndash; %2$s', array(General::sanitize($section->get('name')), __('Symphony'))));\n\n        // Ensure errored entries still maintain any prepopulated values [#2211]\n        $this->Form->setAttribute('action', $this->Form->getAttribute('action') . $this->getPrepopulateString());\n        $this->Form->setAttribute('enctype', 'multipart/form-data');\n\n        $sidebar_fields = $section->fetchFields(null, 'sidebar');\n        $main_fields = $section->fetchFields(null, 'main');\n\n        if (!empty($sidebar_fields) && !empty($main_fields)) {\n            $this->Form->setAttribute('class', 'two columns');\n        } else {\n            $this->Form->setAttribute('class', 'columns');\n        }\n\n        // Only show the Edit Section button if the Author is a developer. #938 ^BA\n        if (Symphony::Author()->isDeveloper()) {\n            $this->appendSubheading(__('Untitled'),\n                Widget::Anchor(__('Edit Section'), SYMPHONY_URL . '/blueprints/sections/edit/' . $section_id . '/', __('Edit Section Configuration'), 'button')\n            );\n        } else {\n            $this->appendSubheading(__('Untitled'));\n        }\n\n        // Build filtered breadcrumb [#1378}\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor(General::sanitize($section->get('name')), SYMPHONY_URL . '/publish/' . $this->_context['section_handle'] . '/' . $this->getFilterString()),\n        ));\n\n        $this->Form->appendChild(Widget::Input('MAX_FILE_SIZE', Symphony::Configuration()->get('max_upload_size', 'admin'), 'hidden'));\n\n        // If there is post data floating around, due to errors, create an entry object\n        if (isset($_POST['fields'])) {\n            $entry = EntryManager::create();\n            $entry->set('section_id', $section_id);\n            $entry->setDataFromPost($_POST['fields'], $error, true);\n\n            // Brand new entry, so need to create some various objects\n        } else {\n            $entry = EntryManager::create();\n            $entry->set('section_id', $section_id);\n        }\n\n        // Check if there is a field to prepopulate\n        if (isset($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                $this->Form->prependChild(Widget::Input(\n                    \"prepopulate[{$field_id}]\",\n                    rawurlencode($value),\n                    'hidden'\n                ));\n\n                // The actual pre-populating should only happen if there is not existing fields post data\n                if (!isset($_POST['fields']) && $field = FieldManager::fetch($field_id)) {\n                    $entry->setData(\n                        $field->get('id'),\n                        $field->processRawFieldData($value, $error, $message, true)\n                    );\n                }\n            }\n        }\n\n        $primary = new XMLElement('fieldset');\n        $primary->setAttribute('class', 'primary column');\n\n        if ((!is_array($main_fields) || empty($main_fields)) && (!is_array($sidebar_fields) || empty($sidebar_fields))) {\n            $message = __('Fields must be added to this section before an entry can be created.');\n\n            if (Symphony::Author()->isDeveloper()) {\n                $message .= ' <a href=\"' . SYMPHONY_URL . '/blueprints/sections/edit/' . $section->get('id') . '/\" accesskey=\"c\">'\n                . __('Add fields')\n                . '</a>';\n            }\n\n            $this->pageAlert($message, Alert::ERROR);\n        } else {\n            if (is_array($main_fields) && !empty($main_fields)) {\n                foreach ($main_fields as $field) {\n                    $primary->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($primary);\n            }\n\n            if (is_array($sidebar_fields) && !empty($sidebar_fields)) {\n                $sidebar = new XMLElement('fieldset');\n                $sidebar->setAttribute('class', 'secondary column');\n\n                foreach ($sidebar_fields as $field) {\n                    $sidebar->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($sidebar);\n            }\n\n            $div = new XMLElement('div');\n            $div->setAttribute('class', 'actions');\n            $div->appendChild(Widget::Input('action[save]', __('Create Entry'), 'submit', array('accesskey' => 's')));\n\n            $this->Form->appendChild($div);\n\n            // Create a Drawer for Associated Sections\n            $this->prepareAssociationsDrawer($section);\n        }\n    }\n\n    public function __actionNew()\n    {\n        if (is_array($_POST['action']) && (array_key_exists('save', $_POST['action']) || array_key_exists('done', $_POST['action']))) {\n            $section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle']);\n\n            if (!$section = SectionManager::fetch($section_id)) {\n                Administration::instance()->throwCustomError(\n                    __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                    __('Unknown Section'),\n                    Page::HTTP_STATUS_NOT_FOUND\n                );\n            }\n\n            $entry = EntryManager::create();\n            $entry->set('author_id', Symphony::Author()->get('id'));\n            $entry->set('section_id', $section_id);\n            $entry->set('creation_date', DateTimeObj::get('c'));\n            $entry->set('modification_date', DateTimeObj::get('c'));\n\n            $fields = $_POST['fields'];\n\n            // Combine FILES and POST arrays, indexed by their custom field handles\n            if (isset($_FILES['fields'])) {\n                $filedata = General::processFilePostData($_FILES['fields']);\n\n                foreach ($filedata as $handle => $data) {\n                    if (!isset($fields[$handle])) {\n                        $fields[$handle] = $data;\n                    } elseif (isset($data['error']) && $data['error'] == UPLOAD_ERR_NO_FILE) {\n                        $fields[$handle] = null;\n                    } else {\n                        foreach ($data as $ii => $d) {\n                            if (isset($d['error']) && $d['error'] == UPLOAD_ERR_NO_FILE) {\n                                $fields[$handle][$ii] = null;\n                            } elseif (is_array($d) && !empty($d)) {\n                                foreach ($d as $key => $val) {\n                                    $fields[$handle][$ii][$key] = $val;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Initial checks to see if the Entry is ok\n            if (Entry::__ENTRY_FIELD_ERROR__ == $entry->checkPostData($fields, $this->_errors)) {\n                $this->pageAlert(__('Some errors were encountered while attempting to save.'), Alert::ERROR);\n\n                // Secondary checks, this will actually process the data and attempt to save\n            } elseif (Entry::__ENTRY_OK__ != $entry->setDataFromPost($fields, $errors)) {\n                foreach ($errors as $field_id => $message) {\n                    $this->pageAlert($message, Alert::ERROR);\n                }\n\n                // Everything is awesome. Dance.\n            } else {\n                /**\n                 * Just prior to creation of an Entry\n                 *\n                 * @delegate EntryPreCreate\n                 * @param string $context\n                 * '/publish/new/'\n                 * @param Section $section\n                 * @param Entry $entry\n                 * @param array $fields\n                 */\n                Symphony::ExtensionManager()->notifyMembers('EntryPreCreate', '/publish/new/', array('section' => $section, 'entry' => &$entry, 'fields' => &$fields));\n\n                // Check to see if the dancing was premature\n                if (!$entry->commit()) {\n                    $this->pageAlert(null, Alert::ERROR);\n                } else {\n                    /**\n                     * Creation of an Entry. New Entry object is provided.\n                     *\n                     * @delegate EntryPostCreate\n                     * @param string $context\n                     * '/publish/new/'\n                     * @param Section $section\n                     * @param Entry $entry\n                     * @param array $fields\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPostCreate', '/publish/new/', array('section' => $section, 'entry' => $entry, 'fields' => $fields));\n\n                    $prepopulate_querystring = $this->getPrepopulateString();\n                    redirect(sprintf(\n                        '%s/publish/%s/edit/%d/created/%s',\n                        SYMPHONY_URL,\n                        $this->_context['section_handle'],\n                        $entry->get('id'),\n                        (!empty($prepopulate_querystring) ? $prepopulate_querystring : null)\n                    ));\n                }\n            }\n        }\n    }\n\n    public function __viewEdit()\n    {\n        if (!$section_id = SectionManager::fetchIDFromHandle($this->_context['section_handle'])) {\n            Administration::instance()->throwCustomError(\n                __('The Section, %s, could not be found.', array('<code>' . $this->_context['section_handle'] . '</code>')),\n                __('Unknown Section'),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n\n        $section = SectionManager::fetch($section_id);\n        $entry_id = intval($this->_context['entry_id']);\n        $base = '/publish/'.$this->_context['section_handle'] . '/';\n        $new_link = $base . 'new/';\n        $filter_link = $base;\n\n        EntryManager::setFetchSorting('id', 'DESC');\n\n        if (!$existingEntry = EntryManager::fetch($entry_id)) {\n            Administration::instance()->throwCustomError(\n                __('Unknown Entry'),\n                __('The Entry, %s, could not be found.', array($entry_id)),\n                Page::HTTP_STATUS_NOT_FOUND\n            );\n        }\n        $existingEntry = $existingEntry[0];\n\n        // If there is post data floating around, due to errors, create an entry object\n        if (isset($_POST['fields'])) {\n            $fields = $_POST['fields'];\n\n            $entry = EntryManager::create();\n            $entry->set('id', $entry_id);\n            $entry->set('author_id', $existingEntry->get('author_id'));\n            $entry->set('section_id', $existingEntry->get('section_id'));\n            $entry->set('creation_date', $existingEntry->get('creation_date'));\n            $entry->set('modification_date', $existingEntry->get('modification_date'));\n            $entry->setDataFromPost($fields, $errors, true);\n\n            // Editing an entry, so need to create some various objects\n        } else {\n            $entry = $existingEntry;\n            $fields = array();\n\n            if (!$section) {\n                $section = SectionManager::fetch($entry->get('section_id'));\n            }\n        }\n\n        /**\n         * Just prior to rendering of an Entry edit form.\n         *\n         * @delegate EntryPreRender\n         * @param string $context\n         * '/publish/edit/'\n         * @param Section $section\n         * @param Entry $entry\n         * @param array $fields\n         */\n        Symphony::ExtensionManager()->notifyMembers('EntryPreRender', '/publish/edit/', array(\n            'section' => $section,\n            'entry' => &$entry,\n            'fields' => $fields\n        ));\n\n        // Iterate over the `prepopulate` parameters to build a URL\n        // to remember this state for Create New, View all Entries and\n        // Breadcrumb links. If `prepopulate` doesn't exist, this will\n        // just use the standard pages (ie. no filtering)\n        if (isset($_REQUEST['prepopulate'])) {\n            $new_link .= $this->getPrepopulateString();\n            $filter_link .= $this->getFilterString();\n        }\n\n        if (isset($this->_context['flag'])) {\n            // These flags are only relevant if there are no errors\n            if (empty($this->_errors)) {\n                $time = Widget::Time();\n\n                switch ($this->_context['flag']) {\n                    case 'saved':\n                        $message = __('Entry updated at %s.', array($time->generate()));\n                        break;\n                    case 'created':\n                        $message = __('Entry created at %s.', array($time->generate()));\n                }\n\n                $this->pageAlert(\n                    $message\n                    . ' <a href=\"' . SYMPHONY_URL . $new_link . '\" accesskey=\"c\">'\n                    . __('Create another?')\n                    . '</a> <a href=\"' . SYMPHONY_URL . $filter_link . '\" accesskey=\"a\">'\n                    . __('View all Entries')\n                    . '</a>',\n                    Alert::SUCCESS\n                );\n            }\n        }\n\n        // Determine the page title\n        $field_id = Symphony::Database()->fetchVar('id', 0, sprintf(\"\n            SELECT `id`\n            FROM `tbl_fields`\n            WHERE `parent_section` = %d\n            ORDER BY `sortorder` LIMIT 1\",\n            $section->get('id')\n        ));\n        if (!is_null($field_id)) {\n            $field = FieldManager::fetch($field_id);\n        }\n\n        if ($field) {\n            $title = $field->prepareReadableValue($existingEntry->getData($field->get('id')), $entry_id, true);\n        } else {\n            $title = '';\n        }\n\n        if (trim($title) == '') {\n            $title = __('Untitled');\n        }\n\n        // Check if there is a field to prepopulate\n        if (isset($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                $this->Form->prependChild(Widget::Input(\n                    \"prepopulate[{$field_id}]\",\n                    rawurlencode($value),\n                    'hidden'\n                ));\n            }\n        }\n\n        $this->setPageType('form');\n        $this->Form->setAttribute('enctype', 'multipart/form-data');\n        $this->setTitle(__('%1$s &ndash; %2$s &ndash; %3$s', array($title, General::sanitize($section->get('name')), __('Symphony'))));\n\n        $sidebar_fields = $section->fetchFields(null, 'sidebar');\n        $main_fields = $section->fetchFields(null, 'main');\n\n        if (!empty($sidebar_fields) && !empty($main_fields)) {\n            $this->Form->setAttribute('class', 'two columns');\n        } else {\n            $this->Form->setAttribute('class', 'columns');\n        }\n\n        // Only show the Edit Section button if the Author is a developer. #938 ^BA\n        if (Symphony::Author()->isDeveloper()) {\n            $this->appendSubheading($title, Widget::Anchor(__('Edit Section'), SYMPHONY_URL . '/blueprints/sections/edit/' . $section_id . '/', __('Edit Section Configuration'), 'button'));\n        } else {\n            $this->appendSubheading($title);\n        }\n\n        $this->insertBreadcrumbs(array(\n            Widget::Anchor(General::sanitize($section->get('name')), SYMPHONY_URL . (isset($filter_link) ? $filter_link : $base)),\n        ));\n\n        $this->Form->appendChild(Widget::Input('MAX_FILE_SIZE', Symphony::Configuration()->get('max_upload_size', 'admin'), 'hidden'));\n\n        $primary = new XMLElement('fieldset');\n        $primary->setAttribute('class', 'primary column');\n\n        if ((!is_array($main_fields) || empty($main_fields)) && (!is_array($sidebar_fields) || empty($sidebar_fields))) {\n            $message = __('Fields must be added to this section before an entry can be created.');\n\n            if (Symphony::Author()->isDeveloper()) {\n                $message .= ' <a href=\"' . SYMPHONY_URL . '/blueprints/sections/edit/' . $section->get('id') . '/\" accesskey=\"c\">'\n                . __('Add fields')\n                . '</a>';\n            }\n\n            $this->pageAlert($message, Alert::ERROR);\n        } else {\n            if (is_array($main_fields) && !empty($main_fields)) {\n                foreach ($main_fields as $field) {\n                    $primary->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($primary);\n            }\n\n            if (is_array($sidebar_fields) && !empty($sidebar_fields)) {\n                $sidebar = new XMLElement('fieldset');\n                $sidebar->setAttribute('class', 'secondary column');\n\n                foreach ($sidebar_fields as $field) {\n                    $sidebar->appendChild($this->__wrapFieldWithDiv($field, $entry));\n                }\n\n                $this->Form->appendChild($sidebar);\n            }\n\n            $div = new XMLElement('div');\n            $div->setAttribute('class', 'actions');\n            $div->appendChild(Widget::Input('action[save]', __('Save Changes'), 'submit', array('accesskey' => 's')));\n\n            $button = new XMLElement('button', __('Delete'));\n            $button->setAttributeArray(array('name' => 'action[delete]', 'class' => 'button confirm delete', 'title' => __('Delete this entry'), 'type' => 'submit', 'accesskey' => 'd', 'data-message' => __('Are you sure you want to delete this entry?')));\n            $div->appendChild($button);\n\n            $this->Form->appendChild($div);\n\n            // Create a Drawer for Associated Sections\n            $this->prepareAssociationsDrawer($section);\n        }\n    }\n\n    public function __actionEdit()\n    {\n        $entry_id = intval($this->_context['entry_id']);\n\n        if (is_array($_POST['action']) && (array_key_exists('save', $_POST['action']) || array_key_exists(\"done\", $_POST['action']))) {\n            if (!$ret = EntryManager::fetch($entry_id)) {\n                Administration::instance()->throwCustomError(\n                    __('The Entry, %s, could not be found.', array($entry_id)),\n                    __('Unknown Entry'),\n                    Page::HTTP_STATUS_NOT_FOUND\n                );\n            }\n\n            $entry = $ret[0];\n\n            $section = SectionManager::fetch($entry->get('section_id'));\n\n            $post = General::getPostData();\n            $fields = $post['fields'];\n\n            // Initial checks to see if the Entry is ok\n            if (Entry::__ENTRY_FIELD_ERROR__ == $entry->checkPostData($fields, $this->_errors)) {\n                $this->pageAlert(__('Some errors were encountered while attempting to save.'), Alert::ERROR);\n\n                // Secondary checks, this will actually process the data and attempt to save\n            } elseif (Entry::__ENTRY_OK__ != $entry->setDataFromPost($fields, $errors)) {\n                foreach ($errors as $field_id => $message) {\n                    $this->pageAlert($message, Alert::ERROR);\n                }\n\n                // Everything is awesome. Dance.\n            } else {\n                /**\n                 * Just prior to editing of an Entry.\n                 *\n                 * @delegate EntryPreEdit\n                 * @param string $context\n                 * '/publish/edit/'\n                 * @param Section $section\n                 * @param Entry $entry\n                 * @param array $fields\n                 */\n                Symphony::ExtensionManager()->notifyMembers('EntryPreEdit', '/publish/edit/', array('section' => $section, 'entry' => &$entry, 'fields' => $fields));\n\n                // Check to see if the dancing was premature\n                if (!$entry->commit()) {\n                    $this->pageAlert(null, Alert::ERROR);\n                } else {\n                    /**\n                     * Just after the editing of an Entry\n                     *\n                     * @delegate EntryPostEdit\n                     * @param string $context\n                     * '/publish/edit/'\n                     * @param Section $section\n                     * @param Entry $entry\n                     * @param array $fields\n                     */\n                    Symphony::ExtensionManager()->notifyMembers('EntryPostEdit', '/publish/edit/', array('section' => $section, 'entry' => $entry, 'fields' => $fields));\n\n                    redirect(sprintf(\n                        '%s/publish/%s/edit/%d/saved/%s',\n                        SYMPHONY_URL,\n                        $this->_context['section_handle'],\n                        $entry->get('id'),\n                        $this->getPrepopulateString()\n                    ));\n                }\n            }\n        } elseif (is_array($_POST['action']) && array_key_exists('delete', $_POST['action']) && is_numeric($entry_id)) {\n            /**\n             * Prior to deletion of entries. An array of Entry ID's is provided which\n             * can be manipulated. This delegate was renamed from `Delete` to `EntryPreDelete`\n             * in Symphony 2.3.\n             *\n             * @delegate EntryPreDelete\n             * @param string $context\n             * '/publish/'\n             * @param array $entry_id\n             *    An array of Entry ID's passed by reference\n             */\n            $checked = array($entry_id);\n            Symphony::ExtensionManager()->notifyMembers('EntryPreDelete', '/publish/', array('entry_id' => &$checked));\n\n            EntryManager::delete($checked);\n\n            /**\n             * After the deletion of entries, this delegate provides an array of Entry ID's\n             * that were deleted.\n             *\n             * @since Symphony 2.3\n             * @delegate EntryPostDelete\n             * @param string $context\n             * '/publish/'\n             * @param array $entry_id\n             *  An array of Entry ID's that were deleted.\n             */\n            Symphony::ExtensionManager()->notifyMembers('EntryPostDelete', '/publish/', array('entry_id' => $checked));\n\n            redirect(SYMPHONY_URL . '/publish/'.$this->_context['section_handle'].'/');\n        }\n    }\n\n    /**\n     * Given a Field and Entry object, this function will wrap\n     * the Field's displayPublishPanel result with a div that\n     * contains some contextual information such as the Field ID,\n     * the Field handle and whether it is required or not.\n     *\n     * @param Field $field\n     * @param Entry $entry\n     * @return XMLElement\n     */\n    private function __wrapFieldWithDiv(Field $field, Entry $entry)\n    {\n        $is_hidden = $this->isFieldHidden($field);\n        $div = new XMLElement('div', null, array('id' => 'field-' . $field->get('id'), 'class' => 'field field-'.$field->handle().($field->get('required') == 'yes' ? ' required' : '').($is_hidden === true ? ' irrelevant' : '')));\n\n        $field->setAssociationContext($div);\n\n        $field->displayPublishPanel(\n            $div, $entry->getData($field->get('id')),\n            (isset($this->_errors[$field->get('id')]) ? $this->_errors[$field->get('id')] : null),\n            null, null, (is_numeric($entry->get('id')) ? $entry->get('id') : null)\n        );\n\n        /**\n         * Allows developers modify the field before it is rendered in the publish\n         * form. Passes the `Field` object, `Entry` object, the `XMLElement` div and\n         * any errors for the entire `Entry`. Only the `$div` element\n         * will be altered before appending to the page, the rest are read only.\n         *\n         * @since Symphony 2.5.0\n         * @delegate ModifyFieldPublishWidget\n         * @param string $context\n         * '/backend/'\n         * @param Field $field\n         * @param Entry $entry\n         * @param array $errors\n         * @param Widget $widget\n         */\n        Symphony::ExtensionManager()->notifyMembers('ModifyFieldPublishWidget', '/backend/', array(\n            'field' => $field,\n            'entry' => $entry,\n            'errors' => $this->_errors,\n            'widget' => &$div\n        ));\n\n        return $div;\n    }\n\n    /**\n     * Check whether the given `$field` will be hidden because it's been\n     * prepopulated.\n     *\n     * @param  Field  $field\n     * @return boolean\n     */\n    public function isFieldHidden(Field $field)\n    {\n        if ($field->get('hide_when_prepopulated') == 'yes') {\n            if (isset($_REQUEST['prepopulate'])) {\n                foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                    if ($field_id == $field->get('id')) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Prepare a Drawer to visualize section associations\n     *\n     * @param  Section $section The current Section object\n     * @throws InvalidArgumentException\n     * @throws Exception\n     */\n    private function prepareAssociationsDrawer($section)\n    {\n        $entry_id = (!is_null($this->_context['entry_id'])) ? $this->_context['entry_id'] : null;\n        $show_entries = Symphony::Configuration()->get('association_maximum_rows', 'symphony');\n\n        if (is_null($entry_id) && !isset($_GET['prepopulate']) || is_null($show_entries) || $show_entries == 0) {\n            return;\n        }\n\n        $parent_associations = SectionManager::fetchParentAssociations($section->get('id'), true);\n        $child_associations = SectionManager::fetchChildAssociations($section->get('id'), true);\n        $content = null;\n        $drawer_position = 'vertical-right';\n\n        /**\n         * Prepare Associations Drawer from an Extension\n         *\n         * @since Symphony 2.3.3\n         * @delegate PrepareAssociationsDrawer\n         * @param string $context\n         * '/publish/'\n         * @param integer $entry_id\n         *  The entry ID or null\n         * @param array $parent_associations\n         *  Array of Sections\n         * @param array $child_associations\n         *  Array of Sections\n         * @param string $drawer_position\n         *  The position of the Drawer, defaults to `vertical-right`. Available\n         *  values of `vertical-left, `vertical-right` and `horizontal`\n         */\n        Symphony::ExtensionManager()->notifyMembers('PrepareAssociationsDrawer', '/publish/', array(\n            'entry_id' => $entry_id,\n            'parent_associations' => &$parent_associations,\n            'child_associations' => &$child_associations,\n            'content' => &$content,\n            'drawer-position' => &$drawer_position\n        ));\n\n        // If there are no associations, return now.\n        if (\n            (is_null($parent_associations) || empty($parent_associations))\n            &&\n            (is_null($child_associations) || empty($child_associations))\n        ) {\n            return;\n        }\n\n        if (!($content instanceof XMLElement)) {\n            $content = new XMLElement('div', null, array('class' => 'content'));\n            $content->setSelfClosingTag(false);\n\n            // backup global sorting\n            $sorting = EntryManager::getFetchSorting();\n\n            // Process Parent Associations\n            if (!is_null($parent_associations) && !empty($parent_associations)) {\n                foreach ($parent_associations as $as) {\n                    if (empty($as['parent_section_field_id'])) {\n                        continue; \n                    }\n                    if ($field = FieldManager::fetch($as['parent_section_field_id'])) {\n\n                        // Get the related section\n                        $parent_section = SectionManager::fetch($as['child_parent_id']);\n\n                        if (!($parent_section instanceof Section)) {\n                            continue;\n                        }\n\n                        // set global sorting for associated section\n                        EntryManager::setFetchSorting(\n                            $parent_section->getSortingField(),\n                            $parent_section->getSortingOrder()\n                        );\n\n                        if (isset($_GET['prepopulate'])) {\n                            $prepopulate_field = key($_GET['prepopulate']);\n                        }\n\n                        // get associated entries if entry exists,\n                        if ($entry_id) {\n                            $entry_ids = $field->findParentRelatedEntries($as['child_section_field_id'], $entry_id);\n\n                            // get prepopulated entry otherwise\n                        } elseif (isset($_GET['prepopulate'])) {\n                            $entry_ids = array(intval(current($_GET['prepopulate'])));\n                        } else {\n                            $entry_ids = array();\n                        }\n\n                        // Use $schema for perf reasons\n                        $schema = array($field->get('element_name'));\n                        $where = (!empty($entry_ids)) ? sprintf(' AND `e`.`id` IN (%s)', implode(', ', $entry_ids)) : null;\n                        $entries = (!empty($entry_ids) || isset($_GET['prepopulate']) && $field->get('id') === $prepopulate_field)\n                            ? EntryManager::fetchByPage(1, $as['parent_section_id'], $show_entries, $where, null, false, false, true, $schema)\n                            : array();\n                        $has_entries = !empty($entries) && $entries['total-entries'] != 0;\n\n                        if ($has_entries) {\n                            $element = new XMLElement('section', null, array('class' => 'association parent'));\n                            $header = new XMLElement('header');\n                            $header->appendChild(new XMLElement('p', __('Linked to %s in', array('<a class=\"association-section\" href=\"' . SYMPHONY_URL . '/publish/' . $as['handle'] . '/\">' . $as['name'] . '</a>'))));\n                            $element->appendChild($header);\n\n                            $ul = new XMLElement('ul', null, array(\n                                'class' => 'association-links',\n                                'data-section-id' => $as['child_section_id'],\n                                'data-association-ids' => implode(', ', $entry_ids)\n                            ));\n\n                            foreach ($entries['records'] as $e) {\n                                // let the field create the mark up\n                                $li = $field->prepareAssociationsDrawerXMLElement($e, $as);\n                                // add it to the unordered list\n                                $ul->appendChild($li);\n                            }\n\n                            $element->appendChild($ul);\n                            $content->appendChild($element);\n                        }\n                    }\n                }\n            }\n\n            // Process Child Associations\n            if (!is_null($child_associations) && !empty($child_associations)) {\n                foreach ($child_associations as $as) {\n                    // Get the related section\n                    $child_section = SectionManager::fetch($as['child_section_id']);\n\n                    if (!($child_section instanceof Section)) {\n                        continue;\n                    }\n\n                    // set global sorting for associated section\n                    EntryManager::setFetchSorting(\n                        $child_section->getSortingField(),\n                        $child_section->getSortingOrder()\n                    );\n\n                    // Get the visible field instance (using the sorting field, this is more flexible than visibleColumns())\n                    // Get the link field instance\n                    $visible_field   = current($child_section->fetchVisibleColumns());\n                    $relation_field  = FieldManager::fetch($as['child_section_field_id']);\n\n                    // Get entries, using $schema for performance reasons.\n                    if (!is_null($parent_section_field_id)) {\n                        $entry_ids = $relation_field->findRelatedEntries($entry_id, $as['parent_section_field_id']);\n                    } else {\n                        $entry_ids = $relation_field->findRelatedEntries($entry_id, $as['child_section_field_id']);\n                    }\n                    $schema = $visible_field ? array($visible_field->get('element_name')) : array();\n                    $where = sprintf(' AND `e`.`id` IN (%s)', implode(', ', $entry_ids));\n\n                    $entries = (!empty($entry_ids)) ? EntryManager::fetchByPage(1, $as['child_section_id'], $show_entries, $where, null, false, false, true, $schema) : array();\n                    $has_entries = !empty($entries) && $entries['total-entries'] != 0;\n\n                    // Build the HTML of the relationship\n                    $element = new XMLElement('section', null, array('class' => 'association child'));\n                    $header = new XMLElement('header');\n                    $filter = '?filter[' . $relation_field->get('element_name') . ']=' . $entry_id;\n                    $prepopulate = '?prepopulate[' . $as['child_section_field_id'] . ']=' . $entry_id;\n\n                    // Create link with filter or prepopulate\n                    $link = SYMPHONY_URL . '/publish/' . $as['handle'] . '/' . $filter;\n                    $a = new XMLElement('a', $as['name'], array(\n                        'class' => 'association-section',\n                        'href' => $link\n                    ));\n\n                    // Create new entries\n                    $create = new XMLElement('a', __('Create New'), array(\n                        'class' => 'button association-new',\n                        'href' => SYMPHONY_URL . '/publish/' . $as['handle'] . '/new/' . $prepopulate\n                    ));\n\n                    // Display existing entries\n                    if ($has_entries) {\n                        $header->appendChild(new XMLElement('p', __('Links in %s', array($a->generate()))));\n\n                        $ul = new XMLElement('ul', null, array(\n                            'class' => 'association-links',\n                            'data-section-id' => $as['child_section_id'],\n                            'data-association-ids' => implode(', ', $entry_ids)\n                        ));\n\n                        foreach ($entries['records'] as $key => $e) {\n                            // let the first visible field create the mark up\n                            if ($visible_field) {\n                                $li = $visible_field->prepareAssociationsDrawerXMLElement($e, $as, $prepopulate);\n                            }\n                            // or use the system:id if no visible field exists.\n                            else {\n                                $li = Field::createAssociationsDrawerXMLElement($e->get('id'), $e, $as, $prepopulate);\n                            }\n\n                            // add it to the unordered list\n                            $ul->appendChild($li);\n                        }\n\n                        $element->appendChild($ul);\n\n                        // If we are only showing 'some' of the entries, then show this on the UI\n                        if ($entries['total-entries'] > $show_entries) {\n                            $pagination = new XMLElement('li', null, array(\n                                'class' => 'association-more',\n                                'data-current-page' => '1',\n                                'data-total-pages' => ceil($entries['total-entries'] / $show_entries),\n                                'data-total-entries' => $entries['total-entries']\n                            ));\n                            $counts = new XMLElement('a', __('Show more entries'), array(\n                                'href' => $link\n                            ));\n\n                            $pagination->appendChild($counts);\n                            $ul->appendChild($pagination);\n                        }\n\n                        // No entries\n                    } else {\n                        $element->setAttribute('class', 'association child empty');\n                        $header->appendChild(new XMLElement('p', __('No links in %s', array($a->generate()))));\n                    }\n\n                    $header->appendChild($create);\n                    $element->prependChild($header);\n                    $content->appendChild($element);\n                }\n            }\n\n            // reset global sorting\n            EntryManager::setFetchSorting(\n                $sorting->field,\n                $sorting->direction\n            );\n        }\n\n        $drawer = Widget::Drawer('section-associations', __('Show Associations'), $content);\n        $this->insertDrawer($drawer, $drawer_position, 'prepend');\n    }\n\n    /**\n     * If this entry is being prepopulated, this function will return the prepopulated\n     * fields and values as a query string.\n     *\n     * @since Symphony 2.5.2\n     * @return string\n     */\n    public function getPrepopulateString()\n    {\n        $prepopulate_querystring = '';\n\n        if (isset($_REQUEST['prepopulate']) && is_array($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                // Properly decode and re-encode value for output\n                $value = rawurlencode(rawurldecode($value));\n                $prepopulate_querystring .= sprintf(\"prepopulate[%s]=%s&\", $field_id, $value);\n            }\n            $prepopulate_querystring = trim($prepopulate_querystring, '&');\n        }\n\n        // This is to prevent the value being interpreted as an additional GET\n        // parameter. eg. prepopulate[cat]=Minx&June, would come through as:\n        // $_GET['cat'] = Minx\n        // $_GET['June'] = ''\n        $prepopulate_querystring = preg_replace(\"/&amp;$/\", '', $prepopulate_querystring);\n\n        return $prepopulate_querystring ? '?' . $prepopulate_querystring : null;\n    }\n\n    /**\n     * If the entry is being prepopulated, we may want to filter other views by this entry's\n     * value. This function will create that filter query string.\n     *\n     * @since Symphony 2.5.2\n     * @return string\n     */\n    public function getFilterString()\n    {\n        $filter_querystring = '';\n\n        if (isset($_REQUEST['prepopulate']) && is_array($_REQUEST['prepopulate'])) {\n            foreach ($_REQUEST['prepopulate'] as $field_id => $value) {\n                $handle = FieldManager::fetchHandleFromID($field_id);\n                // Properly decode and re-encode value for output\n                $value = rawurlencode(rawurldecode($value));\n                $filter_querystring .= sprintf('filter[%s]=%s&', $handle, $value);\n            }\n            $filter_querystring = trim($filter_querystring, '&');\n        }\n\n        // This is to prevent the value being interpreted as an additional GET\n        // parameter. eg. filter[cat]=Minx&June, would come through as:\n        // $_GET['cat'] = Minx\n        // $_GET['June'] = ''\n        $filter_querystring = preg_replace(\"/&amp;$/\", '', $filter_querystring);\n\n        return $filter_querystring ? '?' . $filter_querystring : null;\n    }\n}\n", "<?php\n\n/**\n * @package toolkit\n */\n/**\n * The AdministrationPage class represents a Symphony backend page.\n * It extends the HTMLPage class and unlike the Frontend, is generated\n * using a number XMLElement objects. Instances of this class override\n * the view, switchboard and action functions to construct the page. These\n * functions act as pseudo MVC, with the switchboard being controller,\n * and the view/action being the view.\n */\n\nclass AdministrationPage extends HTMLPage\n{\n    /**\n     * An array of `Alert` objects used to display page level\n     * messages to Symphony backend users one by one. Prior to Symphony 2.3\n     * this variable only held a single `Alert` object.\n     * @var array\n     */\n    public $Alert = array();\n\n    /**\n     * As the name suggests, a `<div>` that holds the following `$Header`,\n     * `$Contents` and `$Footer`.\n     * @var XMLElement\n     */\n    public $Wrapper = null;\n\n    /**\n     * A `<div>` that contains the header of a Symphony backend page, which\n     * typically contains the Site title and the navigation.\n     * @var XMLElement\n     */\n    public $Header = null;\n\n    /**\n     * A `<div>` that contains the breadcrumbs, the page title and some contextual\n     * actions (e.g. \"Create new\").\n     * @since Symphony 2.3\n     * @var XMLElement\n     */\n    public $Context = null;\n\n    /**\n     * An object that stores the markup for the breadcrumbs and is only used\n     * internally.\n     * @since Symphony 2.3\n     * @var XMLElement\n     */\n    public $Breadcrumbs = null;\n\n    /**\n     * An array of Drawer widgets for the current page\n     * @since Symphony 2.3\n     * @var array\n     */\n    public $Drawer = array();\n\n    /**\n     * A `<div>` that contains the content of a Symphony backend page.\n     * @var XMLElement\n     */\n    public $Contents = null;\n\n    /**\n     * An associative array of the navigation where the key is the group\n     * index, and the value is an associative array of 'name', 'index' and\n     * 'children'. Name is the name of the this group, index is the same as\n     * the key and children is an associative array of navigation items containing\n     * the keys 'link', 'name' and 'visible'. In Symphony, all navigation items\n     * are contained within a group, and the group has no 'default' link, therefore\n     * it is up to the children to provide the link to pages. This link should be\n     * relative to the Symphony path, although it is possible to provide an\n     * absolute link by providing a key, 'relative' with the value false.\n     * @var array\n     */\n    public $_navigation = array();\n\n    /**\n     *  An associative array describing this pages context. This\n     *  can include the section handle, the current entry_id, the page\n     *  name and any flags such as 'saved' or 'created'. This variable\n     *  often provided in delegates so extensions can manipulate based\n     *  off the current context or add new keys.\n     * @var array\n     */\n    public $_context = null;\n\n    /**\n     * The class attribute of the `<body>` element for this page. Defaults\n     * to an empty string\n     * @var string\n     */\n    private $_body_class = '';\n\n    /**\n     * Constructor calls the parent constructor to set up\n     * the basic HTML, Head and Body `XMLElement`'s. This function\n     * also sets the `XMLElement` element style to be HTML, instead of XML\n     */\n    public function __construct()\n    {\n        parent::__construct();\n\n        $this->Html->setElementStyle('html');\n    }\n\n    /**\n     * Specifies the type of page that being created. This is used to\n     * trigger various styling hooks. If your page is mainly a form,\n     * pass 'form' as the parameter, if it's displaying a single entry,\n     * pass 'single'. If any other parameter is passed, the 'index'\n     * styling will be applied.\n     *\n     * @param string $type\n     *  Accepts 'form' or 'single', any other `$type` will trigger 'index'\n     *  styling.\n     */\n    public function setPageType($type = 'form')\n    {\n        $this->setBodyClass($type == 'form' || $type == 'single' ? 'single' : 'index');\n    }\n\n    /**\n     * Setter function to set the class attribute on the `<body>` element.\n     * This function will respect any previous classes that have been added\n     * to this `<body>`\n     *\n     * @param string $class\n     *  The string of the classname, multiple classes can be specified by\n     *  uses a space separator\n     */\n    public function setBodyClass($class)\n    {\n        // Prevents duplicate \"index\" classes\n        if (!isset($this->_context['page']) || $this->_context['page'] !== 'index' || $class !== 'index') {\n            $this->_body_class .= $class;\n        }\n    }\n\n    /**\n     * Accessor for `$this->_context` which includes contextual information\n     * about the current page such as the class, file location or page root.\n     * This information varies depending on if the page is provided by an\n     * extension, is for the publish area, is the login page or any other page\n     *\n     * @since Symphony 2.3\n     * @return array\n     */\n    public function getContext()\n    {\n        return $this->_context;\n    }\n\n    /**\n     * Given a `$message` and an optional `$type`, this function will\n     * add an Alert instance into this page's `$this->Alert` property.\n     * Since Symphony 2.3, there may be more than one `Alert` per page.\n     * Unless the Alert is an Error, it is required the `$message` be\n     * passed to this function.\n     *\n     * @param string $message\n     *  The message to display to users\n     * @param string $type\n     *  An Alert constant, being `Alert::NOTICE`, `Alert::ERROR` or\n     *  `Alert::SUCCESS`. The differing types will show the error\n     *  in a different style in the backend. If omitted, this defaults\n     *  to `Alert::NOTICE`.\n     * @throws Exception\n     */\n    public function pageAlert($message = null, $type = Alert::NOTICE)\n    {\n        if (is_null($message) && $type == Alert::ERROR) {\n            $message = __('There was a problem rendering this page. Please check the activity log for more details.');\n        } else {\n            $message = __($message);\n        }\n\n        if (strlen(trim($message)) == 0) {\n            throw new Exception(__('A message must be supplied unless the alert is of type Alert::ERROR'));\n        }\n\n        $this->Alert[] = new Alert($message, $type);\n    }\n\n    /**\n     * Appends the heading of this Symphony page to the Context element.\n     * Action buttons can be provided (e.g. \"Create new\") as second parameter.\n     *\n     * @since Symphony 2.3\n     * @param string $value\n     *  The heading text\n     * @param array|XMLElement|string $actions\n     *  Some contextual actions to append to the heading, they can be provided as\n     *  an array of XMLElements or strings. Traditionally Symphony uses this to append\n     *  a \"Create new\" link to the Context div.\n     */\n    public function appendSubheading($value, $actions = null)\n    {\n        if (!is_array($actions) && $actions) { // Backward compatibility\n            $actions = array($actions);\n        }\n\n        if (!empty($actions)) {\n            foreach ($actions as $a) {\n                $this->insertAction($a);\n            }\n        }\n\n        $this->Breadcrumbs->appendChild(new XMLElement('h2', $value, array('role' => 'heading', 'id' => 'symphony-subheading')));\n    }\n\n    /**\n     * This function allows a user to insert an Action button to the page.\n     * It accepts an `XMLElement` (which should be of the `Anchor` type),\n     * an optional parameter `$prepend`, which when `true` will add this\n     * action before any existing actions.\n     *\n     * @since Symphony 2.3\n     * @see core.Widget#Anchor\n     * @param XMLElement $action\n     *  An Anchor element to add to the top of the page.\n     * @param boolean $append\n     *  If true, this will add the `$action` after existing actions, otherwise\n     *  it will be added before existing actions. By default this is `true`,\n     *  which will add the `$action` after current actions.\n     */\n    public function insertAction(XMLElement $action, $append = true)\n    {\n        $actions = $this->Context->getChildrenByName('ul');\n\n        // Actions haven't be added yet, create the element\n        if (empty($actions)) {\n            $ul = new XMLElement('ul', null, array('class' => 'actions'));\n            $this->Context->appendChild($ul);\n        } else {\n            $ul = current($actions);\n            $this->Context->replaceChildAt(1, $ul);\n        }\n\n        $li = new XMLElement('li', $action);\n\n        if ($append) {\n            $ul->prependChild($li);\n        } else {\n            $ul->appendChild($li);\n        }\n    }\n\n    /**\n     * Allows developers to specify a list of nav items that build the\n     * path to the current page or, in jargon, \"breadcrumbs\".\n     *\n     * @since Symphony 2.3\n     * @param array $values\n     *  An array of `XMLElement`'s or strings that compose the path. If breadcrumbs\n     *  already exist, any new item will be appended to the rightmost part of the\n     *  path.\n     */\n    public function insertBreadcrumbs(array $values)\n    {\n        if (empty($values)) {\n            return;\n        }\n\n        if ($this->Breadcrumbs instanceof XMLELement && count($this->Breadcrumbs->getChildrenByName('nav')) === 1) {\n            $nav = $this->Breadcrumbs->getChildrenByName('nav');\n            $nav = $nav[0];\n\n            $p = $nav->getChild(0);\n        } else {\n            $p = new XMLElement('p');\n            $nav = new XMLElement('nav');\n            $nav->appendChild($p);\n\n            $this->Breadcrumbs->prependChild($nav);\n        }\n\n        foreach ($values as $v) {\n            $p->appendChild($v);\n            $p->appendChild(new XMLElement('span', '&#8250;', array('class' => 'sep')));\n        }\n    }\n\n    /**\n     * Allows a Drawer element to added to the backend page in one of three\n     * positions, `horizontal`, `vertical-left` or `vertical-right`. The button\n     * to trigger the visibility of the drawer will be added after existing\n     * actions by default.\n     *\n     * @since Symphony 2.3\n     * @see core.Widget#Drawer\n     * @param XMLElement $drawer\n     *  An XMLElement representing the drawer, use `Widget::Drawer` to construct\n     * @param string $position\n     *  Where `$position` can be `horizontal`, `vertical-left` or\n     *  `vertical-right`. Defaults to `horizontal`.\n     * @param string $button\n     *  If not passed, a button to open/close the drawer will not be added\n     *  to the interface. Accepts 'prepend' or 'append' values, which will\n     *  add the button before or after existing buttons. Defaults to `prepend`.\n     *  If any other value is passed, no button will be added.\n     * @throws InvalidArgumentException\n     */\n    public function insertDrawer(XMLElement $drawer, $position = 'horizontal', $button = 'append')\n    {\n        $drawer->addClass($position);\n        $drawer->setAttribute('data-position', $position);\n        $drawer->setAttribute('role', 'complementary');\n        $this->Drawer[$position][] = $drawer;\n\n        if (in_array($button, array('prepend', 'append'))) {\n            $this->insertAction(\n                Widget::Anchor(\n                    $drawer->getAttribute('data-label'),\n                    '#' . $drawer->getAttribute('id'),\n                    null,\n                    'button drawer ' . $position\n                ),\n                ($button === 'append' ? true : false)\n            );\n        }\n    }\n\n    /**\n     * This function initialises a lot of the basic elements that make up a Symphony\n     * backend page such as the default stylesheets and scripts, the navigation and\n     * the footer. Any alerts are also appended by this function. `view()` is called to\n     * build the actual content of the page. The `InitialiseAdminPageHead` delegate\n     * allows extensions to add elements to the `<head>`.\n     *\n     * @see view()\n     * @uses InitialiseAdminPageHead\n     * @param array $context\n     *  An associative array describing this pages context. This\n     *  can include the section handle, the current entry_id, the page\n     *  name and any flags such as 'saved' or 'created'. This list is not exhaustive\n     *  and extensions can add their own keys to the array.\n     * @throws InvalidArgumentException\n     * @throws SymphonyErrorPage\n     */\n    public function build(array $context = array())\n    {\n        $this->_context = $context;\n\n        if (!$this->canAccessPage()) {\n            Administration::instance()->throwCustomError(\n                __('You are not authorised to access this page.'),\n                __('Access Denied'),\n                Page::HTTP_STATUS_UNAUTHORIZED\n            );\n        }\n\n        $this->Html->setDTD('<!DOCTYPE html>');\n        $this->Html->setAttribute('lang', Lang::get());\n        $this->addElementToHead(new XMLElement('meta', null, array('charset' => 'UTF-8')), 0);\n        $this->addElementToHead(new XMLElement('meta', null, array('http-equiv' => 'X-UA-Compatible', 'content' => 'IE=edge,chrome=1')), 1);\n        $this->addElementToHead(new XMLElement('meta', null, array('name' => 'viewport', 'content' => 'width=device-width, initial-scale=1')), 2);\n\n        // Add styles\n        $this->addStylesheetToHead(ASSETS_URL . '/css/symphony.min.css', 'screen', 2, false);\n\n        // Calculate timezone offset from UTC\n        $timezone = new DateTimeZone(Symphony::Configuration()->get('timezone', 'region'));\n        $datetime = new DateTime('now', $timezone);\n        $timezoneOffset = intval($timezone->getOffset($datetime)) / 60;\n\n        // Add scripts\n        $environment = array(\n\n            'root'     => URL,\n            'symphony' => SYMPHONY_URL,\n            'path'     => '/' . Symphony::Configuration()->get('admin-path', 'symphony'),\n            'route'    => getCurrentPage(),\n            'version'  => Symphony::Configuration()->get('version', 'symphony'),\n            'lang'     => Lang::get(),\n            'user'     => array(\n\n                'fullname' => Symphony::Author()->getFullName(),\n                'name'     => Symphony::Author()->get('first_name'),\n                'type'     => Symphony::Author()->get('user_type'),\n                'id'       => Symphony::Author()->get('id')\n            ),\n            'datetime' => array(\n\n                'formats'         => DateTimeObj::getDateFormatMappings(),\n                'timezone-offset' => $timezoneOffset\n            ),\n            'env' => array_merge(\n\n                array('page-namespace' => Symphony::getPageNamespace()),\n                $this->_context\n            )\n        );\n\n        $this->addElementToHead(\n            new XMLElement('script', json_encode($environment), array(\n                'type' => 'application/json',\n                'id' => 'environment'\n            )),\n            4\n        );\n\n        $this->addScriptToHead(ASSETS_URL . '/js/symphony.min.js', 6, false);\n\n        // Initialise page containers\n        $this->Wrapper = new XMLElement('div', null, array('id' => 'wrapper'));\n        $this->Header = new XMLElement('header', null, array('id' => 'header'));\n        $this->Context = new XMLElement('div', null, array('id' => 'context'));\n        $this->Breadcrumbs = new XMLElement('div', null, array('id' => 'breadcrumbs'));\n        $this->Contents = new XMLElement('div', null, array('id' => 'contents', 'role' => 'main'));\n        $this->Form = Widget::Form(Administration::instance()->getCurrentPageURL(), 'post', null, null, array('role' => 'form'));\n\n        /**\n         * Allows developers to insert items into the page HEAD. Use\n         * `Administration::instance()->Page` for access to the page object.\n         *\n         * @since In Symphony 2.3.2 this delegate was renamed from\n         *  `InitaliseAdminPageHead` to the correct spelling of\n         *  `InitialiseAdminPageHead`. The old delegate is supported\n         *  until Symphony 3.0\n         *\n         * @delegate InitialiseAdminPageHead\n         * @param string $context\n         *  '/backend/'\n         */\n        Symphony::ExtensionManager()->notifyMembers('InitialiseAdminPageHead', '/backend/');\n        Symphony::ExtensionManager()->notifyMembers('InitaliseAdminPageHead', '/backend/');\n\n        $this->addHeaderToPage('Content-Type', 'text/html; charset=UTF-8');\n        $this->addHeaderToPage('Cache-Control', 'no-cache, must-revalidate, max-age=0');\n        $this->addHeaderToPage('Expires', 'Mon, 12 Dec 1982 06:14:00 GMT');\n        $this->addHeaderToPage('Last-Modified', gmdate('D, d M Y H:i:s') . ' GMT');\n        $this->addHeaderToPage('Pragma', 'no-cache');\n\n        // If not set by another extension, lock down the backend\n        if (!array_key_exists('x-frame-options', $this->headers())) {\n            $this->addHeaderToPage('X-Frame-Options', 'SAMEORIGIN');\n        }\n\n        if (!array_key_exists('access-control-allow-origin', $this->headers())) {\n            $this->addHeaderToPage('Access-Control-Allow-Origin', URL);\n        }\n\n        if (isset($_REQUEST['action'])) {\n            $this->action();\n            Symphony::Profiler()->sample('Page action run', PROFILE_LAP);\n        }\n\n        $h1 = new XMLElement('h1');\n        $h1->appendChild(Widget::Anchor(Symphony::Configuration()->get('sitename', 'general'), rtrim(URL, '/') . '/'));\n        $this->Header->appendChild($h1);\n\n        $this->appendUserLinks();\n        $this->appendNavigation();\n\n        // Add Breadcrumbs\n        $this->Context->prependChild($this->Breadcrumbs);\n        $this->Contents->appendChild($this->Form);\n\n        $this->view();\n\n        $this->appendAlert();\n\n        Symphony::Profiler()->sample('Page content created', PROFILE_LAP);\n    }\n\n    /**\n     * Checks the current Symphony Author can access the current page.\n     * This check uses the `ASSETS . /xml/navigation.xml` file to determine\n     * if the current page (or the current page namespace) can be viewed\n     * by the currently logged in Author.\n     *\n     * @link http://github.com/symphonycms/symphony-2/blob/master/symphony/assets/xml/navigation.xml\n     * @return boolean\n     *  True if the Author can access the current page, false otherwise\n     */\n    public function canAccessPage()\n    {\n        $nav = $this->getNavigationArray();\n        $page = '/' . trim(getCurrentPage(), '/') . '/';\n\n        $page_limit = 'author';\n\n        foreach ($nav as $item) {\n            if (\n                // If page directly matches one of the children\n                General::in_array_multi($page, $item['children'])\n                // If the page namespace matches one of the children (this will usually drop query\n                // string parameters such as /edit/1/)\n                || General::in_array_multi(Symphony::getPageNamespace() . '/', $item['children'])\n            ) {\n                if (is_array($item['children'])) {\n                    foreach ($item['children'] as $c) {\n                        if ($c['link'] === $page && isset($c['limit'])) {\n                            $page_limit = $c['limit'];\n                        }\n                    }\n                }\n\n                if (isset($item['limit']) && $page_limit !== 'primary') {\n                    if ($page_limit === 'author' && $item['limit'] === 'developer') {\n                        $page_limit = 'developer';\n                    }\n                }\n            } elseif (isset($item['link']) && $page === $item['link'] && isset($item['limit'])) {\n                $page_limit = $item['limit'];\n            }\n        }\n\n        return $this->doesAuthorHaveAccess($page_limit);\n    }\n\n    /**\n     * Given the limit of the current navigation item or page, this function\n     * returns if the current Author can access that item or not.\n     *\n     * @since Symphony 2.5.1\n     * @param string $item_limit\n     * @return boolean\n     */\n    public function doesAuthorHaveAccess($item_limit = null)\n    {\n        $can_access = false;\n\n        if (!isset($item_limit) || $item_limit === 'author') {\n            $can_access = true;\n        } elseif ($item_limit === 'developer' && Symphony::Author()->isDeveloper()) {\n            $can_access = true;\n        } elseif ($item_limit === 'manager' && (Symphony::Author()->isManager() || Symphony::Author()->isDeveloper())) {\n            $can_access = true;\n        } elseif ($item_limit === 'primary' && Symphony::Author()->isPrimaryAccount()) {\n            $can_access = true;\n        }\n\n        return $can_access;\n    }\n\n    /**\n     * Appends the `$this->Header`, `$this->Context` and `$this->Contents`\n     * to `$this->Wrapper` before adding the ID and class attributes for\n     * the `<body>` element. This function will also place any Drawer elements\n     * in their relevant positions in the page. After this has completed the\n     * parent `generate()` is called which will convert the `XMLElement`'s\n     * into strings ready for output.\n     *\n     * @see core.HTMLPage#generate()\n     * @param null $page\n     * @return string\n     */\n    public function generate($page = null)\n    {\n        $this->Wrapper->appendChild($this->Header);\n\n        // Add horizontal drawers (inside #context)\n        if (isset($this->Drawer['horizontal'])) {\n            $this->Context->appendChildArray($this->Drawer['horizontal']);\n        }\n\n        $this->Wrapper->appendChild($this->Context);\n\n        // Add vertical-left drawers (between #context and #contents)\n        if (isset($this->Drawer['vertical-left'])) {\n            $this->Contents->appendChildArray($this->Drawer['vertical-left']);\n        }\n\n        // Add vertical-right drawers (after #contents)\n        if (isset($this->Drawer['vertical-right'])) {\n            $this->Contents->appendChildArray($this->Drawer['vertical-right']);\n        }\n\n        $this->Wrapper->appendChild($this->Contents);\n\n        $this->Body->appendChild($this->Wrapper);\n\n        $this->__appendBodyId();\n        $this->__appendBodyClass($this->_context);\n\n        return parent::generate($page);\n    }\n\n    /**\n     * Uses this pages PHP classname as the `<body>` ID attribute.\n     * This function removes 'content' from the start of the classname\n     * and converts all uppercase letters to lowercase and prefixes them\n     * with a hyphen.\n     */\n    private function __appendBodyId()\n    {\n        // trim \"content\" from beginning of class name\n        $body_id = preg_replace(\"/^content/\", '', get_class($this));\n\n        // lowercase any uppercase letters and prefix with a hyphen\n        $body_id = trim(\n            preg_replace_callback(\n                \"/([A-Z])/\",\n                function($id) {\n                    return \"-\" . strtolower($id[0]);\n                },\n                $body_id\n            ),\n            '-'\n        );\n\n        if (!empty($body_id)) {\n            $this->Body->setAttribute('id', trim($body_id));\n        }\n    }\n\n    /**\n     * Given the context of the current page, which is an associative\n     * array, this function will append the values to the page's body as\n     * classes. If an context value is numeric it will be prepended by 'id-',\n     * otherwise all classes will be prefixed by the context key.\n     *\n     * @param array $context\n     */\n    private function __appendBodyClass(array $context = array())\n    {\n        $body_class = '';\n\n        foreach ($context as $key => $value) {\n            if (is_numeric($value)) {\n                $value = 'id-' . $value;\n\n                // Add prefixes to all context values by making the\n                // class be {key}-{value}. #1397 ^BA\n            } else if (!is_numeric($key) && isset($value)) {\n                // Skip arrays\n                if (is_array($value)) {\n                    $value = null;\n                } else {\n                    $value = str_replace('_', '-', $key) . '-'. $value;\n                }\n            }\n\n            if ($value !== null) {\n                $body_class .= trim($value) . ' ';\n            }\n        }\n\n        $classes = array_merge(explode(' ', trim($body_class)), explode(' ', trim($this->_body_class)));\n        $body_class = trim(implode(' ', $classes));\n\n        if (!empty($body_class)) {\n            $this->Body->setAttribute('class', $body_class);\n        }\n    }\n\n    /**\n     * Called to build the content for the page. This function immediately calls\n     * `__switchboard()` which acts a bit of a controller to show content based on\n     * off a type, such as 'view' or 'action'. `AdministrationPages` can override this\n     * function to just display content if they do not need the switchboard functionality\n     *\n     * @see __switchboard()\n     */\n    public function view()\n    {\n        $this->__switchboard();\n    }\n\n    /**\n     * This function is called when `$_REQUEST` contains a key of 'action'.\n     * Any logic that needs to occur immediately for the action to complete\n     * should be contained within this function. By default this calls the\n     * `__switchboard` with the type set to 'action'.\n     *\n     * @see __switchboard()\n     */\n    public function action()\n    {\n        $this->__switchboard('action');\n    }\n\n    /**\n     * The `__switchboard` function acts as a controller to display content\n     * based off the $type. By default, the `$type` is 'view' but it can be set\n     * also set to 'action'. The `$type` is prepended by __ and the context is\n     * append to the $type to create the name of the function that will provide\n     * that logic. For example, if the $type was action and the context of the\n     * current page was new, the resulting function to be called would be named\n     * `__actionNew()`. If an action function is not provided by the Page, this function\n     * returns nothing, however if a view function is not provided, a 404 page\n     * will be returned.\n     *\n     * @param string $type\n     *  Either 'view' or 'action', by default this will be 'view'\n     * @throws SymphonyErrorPage\n     */\n    public function __switchboard($type = 'view')\n    {\n        if (!isset($this->_context[0]) || trim($this->_context[0]) === '') {\n            $context = 'index';\n        } else {\n            $context = $this->_context[0];\n        }\n\n        $function = ($type == 'action' ? '__action' : '__view') . ucfirst($context);\n\n        if (!method_exists($this, $function)) {\n            // If there is no action function, just return without doing anything\n            if ($type == 'action') {\n                return;\n            }\n\n            Administration::instance()->errorPageNotFound();\n        }\n\n        $this->$function(null);\n    }\n\n    /**\n     * If `$this->Alert` is set, it will be added to this page. The\n     * `AppendPageAlert` delegate is fired to allow extensions to provide their\n     * their own Alert messages for this page. Since Symphony 2.3, there may be\n     * more than one `Alert` per page. Alerts are displayed in the order of\n     * severity, with Errors first, then Success alerts followed by Notices.\n     *\n     * @uses AppendPageAlert\n     */\n    public function appendAlert()\n    {\n        /**\n         * Allows for appending of alerts. Administration::instance()->Page->Alert is way to tell what\n         * is currently in the system\n         *\n         * @delegate AppendPageAlert\n         * @param string $context\n         *  '/backend/'\n         */\n        Symphony::ExtensionManager()->notifyMembers('AppendPageAlert', '/backend/');\n\n\n        if (!is_array($this->Alert) || empty($this->Alert)) {\n            return;\n        }\n\n        usort($this->Alert, array($this, 'sortAlerts'));\n\n        // Using prependChild ruins our order (it's backwards, but with most\n        // recent notices coming after oldest notices), so reversing the array\n        // fixes this. We need to prepend so that without Javascript the notices\n        // are at the top of the markup. See #1312\n        $this->Alert = array_reverse($this->Alert);\n\n        foreach ($this->Alert as $alert) {\n            $this->Header->prependChild($alert->asXML());\n        }\n    }\n\n    // Errors first, success next, then notices.\n    public function sortAlerts($a, $b)\n    {\n        if ($a->{'type'} === $b->{'type'}) {\n            return 0;\n        }\n\n        if (\n            ($a->{'type'} === Alert::ERROR && $a->{'type'} !== $b->{'type'})\n            || ($a->{'type'} === Alert::SUCCESS && $b->{'type'} === Alert::NOTICE)\n        ) {\n            return -1;\n        }\n\n        return 1;\n    }\n\n    /**\n     * This function will append the Navigation to the AdministrationPage.\n     * It fires a delegate, NavigationPreRender, to allow extensions to manipulate\n     * the navigation. Extensions should not use this to add their own navigation,\n     * they should provide the navigation through their fetchNavigation function.\n     * Note with the Section navigation groups, if there is only one section in a group\n     * and that section is set to visible, the group will not appear in the navigation.\n     *\n     * @uses NavigationPreRender\n     * @see getNavigationArray()\n     * @see toolkit.Extension#fetchNavigation()\n     */\n    public function appendNavigation()\n    {\n        $nav = $this->getNavigationArray();\n\n        /**\n         * Immediately before displaying the admin navigation. Provided with the\n         * navigation array. Manipulating it will alter the navigation for all pages.\n         *\n         * @delegate NavigationPreRender\n         * @param string $context\n         *  '/backend/'\n         * @param array $nav\n         *  An associative array of the current navigation, passed by reference\n         */\n        Symphony::ExtensionManager()->notifyMembers('NavigationPreRender', '/backend/', array('navigation' => &$nav));\n\n        $navElement = new XMLElement('nav', null, array('id' => 'nav', 'role' => 'navigation'));\n        $contentNav = new XMLElement('ul', null, array('class' => 'content', 'role' => 'menubar'));\n        $structureNav = new XMLElement('ul', null, array('class' => 'structure', 'role' => 'menubar'));\n\n        foreach ($nav as $n) {\n            if (isset($n['visible']) && $n['visible'] === 'no') {\n                continue;\n            }\n\n            if ($this->doesAuthorHaveAccess($n['limit'])) {\n                $xGroup = new XMLElement('li', General::sanitize($n['name']), array('role' => 'presentation'));\n\n                if (isset($n['class']) && trim($n['name']) !== '') {\n                    $xGroup->setAttribute('class', $n['class']);\n                }\n\n                $hasChildren = false;\n                $xChildren = new XMLElement('ul', null, array('role' => 'menu'));\n\n                if (is_array($n['children']) && !empty($n['children'])) {\n                    foreach ($n['children'] as $c) {\n                        // adapt for Yes and yes\n                        if (strtolower($c['visible']) !== 'yes') {\n                            continue;\n                        }\n\n                        if ($this->doesAuthorHaveAccess($c['limit'])) {\n                            $xChild = new XMLElement('li');\n                            $xChild->setAttribute('role', 'menuitem');\n                            $linkChild = Widget::Anchor(General::sanitize($c['name']), SYMPHONY_URL . $c['link']);\n                            if (isset($c['target'])) {\n                                $linkChild->setAttribute('target', $c['target']);\n                            }\n                            $xChild->appendChild($linkChild);\n                            $xChildren->appendChild($xChild);\n                            $hasChildren = true;\n                        }\n                    }\n\n                    if ($hasChildren) {\n                        $xGroup->setAttribute('aria-haspopup', 'true');\n                        $xGroup->appendChild($xChildren);\n\n                        if ($n['type'] === 'content') {\n                            $contentNav->appendChild($xGroup);\n                        } elseif ($n['type'] === 'structure') {\n                            $structureNav->prependChild($xGroup);\n                        }\n                    }\n                }\n            }\n        }\n\n        $navElement->appendChild($contentNav);\n        $navElement->appendChild($structureNav);\n        $this->Header->appendChild($navElement);\n        Symphony::Profiler()->sample('Navigation Built', PROFILE_LAP);\n    }\n\n    /**\n     * Returns the `$_navigation` variable of this Page. If it is empty,\n     * it will be built by `__buildNavigation`\n     *\n     * @see __buildNavigation()\n     * @return array\n     */\n    public function getNavigationArray()\n    {\n        if (empty($this->_navigation)) {\n            $this->__buildNavigation();\n        }\n\n        return $this->_navigation;\n    }\n\n    /**\n     * This method fills the `$nav` array with value\n     * from the `ASSETS/xml/navigation.xml` file\n     *\n     * @link http://github.com/symphonycms/symphony-2/blob/master/symphony/assets/xml/navigation.xml\n     *\n     * @since Symphony 2.3.2\n     *\n     * @param array $nav\n     *  The navigation array that will receive nav nodes\n     */\n    private function buildXmlNavigation(&$nav)\n    {\n        $xml = simplexml_load_file(ASSETS . '/xml/navigation.xml');\n\n        // Loop over the default Symphony navigation file, converting\n        // it into an associative array representation\n        foreach ($xml->xpath('/navigation/group') as $n) {\n            $index = (string)$n->attributes()->index;\n            $children = $n->xpath('children/item');\n            $content = $n->attributes();\n\n            // If the index is already set, increment the index and check again.\n            // Rinse and repeat until the index is not set.\n            if (isset($nav[$index])) {\n                do {\n                    $index++;\n                } while (isset($nav[$index]));\n            }\n\n            $nav[$index] = array(\n                'name' => __(strval($content->name)),\n                'type' => 'structure',\n                'index' => $index,\n                'children' => array()\n            );\n\n            if (strlen(trim((string)$content->limit)) > 0) {\n                $nav[$index]['limit'] = (string)$content->limit;\n            }\n\n            if (count($children) > 0) {\n                foreach ($children as $child) {\n                    $item = array(\n                        'link' => (string)$child->attributes()->link,\n                        'name' => __(strval($child->attributes()->name)),\n                        'visible' => ((string)$child->attributes()->visible == 'no' ? 'no' : 'yes'),\n                    );\n\n                    $limit = (string)$child->attributes()->limit;\n\n                    if (strlen(trim($limit)) > 0) {\n                        $item['limit'] = $limit;\n                    }\n\n                    $nav[$index]['children'][] = $item;\n                }\n            }\n        }\n    }\n\n    /**\n     * This method fills the `$nav` array with value\n     * from each Section\n     *\n     * @since Symphony 2.3.2\n     *\n     * @param array $nav\n     *  The navigation array that will receive nav nodes\n     */\n    private function buildSectionNavigation(&$nav)\n    {\n        // Build the section navigation, grouped by their navigation groups\n        $sections = SectionManager::fetch(null, 'asc', 'sortorder');\n\n        if (is_array($sections) && !empty($sections)) {\n            foreach ($sections as $s) {\n                $group_index = self::__navigationFindGroupIndex($nav, $s->get('navigation_group'));\n\n                if ($group_index === false) {\n                    $group_index = General::array_find_available_index($nav, 0);\n\n                    $nav[$group_index] = array(\n                        'name' => $s->get('navigation_group'),\n                        'type' => 'content',\n                        'index' => $group_index,\n                        'children' => array()\n                    );\n                }\n\n                $nav[$group_index]['children'][] = array(\n                    'link' => '/publish/' . $s->get('handle') . '/',\n                    'name' => $s->get('name'),\n                    'type' => 'section',\n                    'section' => array('id' => $s->get('id'), 'handle' => $s->get('handle')),\n                    'visible' => ($s->get('hidden') == 'no' ? 'yes' : 'no')\n                );\n            }\n        }\n    }\n\n    /**\n     * This method fills the `$nav` array with value\n     * from each Extension's `fetchNavigation` method\n     *\n     * @since Symphony 2.3.2\n     *\n     * @param array $nav\n     *  The navigation array that will receive nav nodes\n     * @throws Exception\n     * @throws SymphonyErrorPage\n     */\n    private function buildExtensionsNavigation(&$nav)\n    {\n        // Loop over all the installed extensions to add in other navigation items\n        $extensions = Symphony::ExtensionManager()->listInstalledHandles();\n\n        foreach ($extensions as $e) {\n            $extension = Symphony::ExtensionManager()->getInstance($e);\n            $extension_navigation = $extension->fetchNavigation();\n\n            if (is_array($extension_navigation) && !empty($extension_navigation)) {\n                foreach ($extension_navigation as $item) {\n                    $type = isset($item['children']) ? Extension::NAV_GROUP : Extension::NAV_CHILD;\n\n                    switch ($type) {\n                        case Extension::NAV_GROUP:\n                            $index = General::array_find_available_index($nav, $item['location']);\n\n                            // Actual group\n                            $nav[$index] = self::createParentNavItem($index, $item);\n\n                            // Render its children\n                            foreach ($item['children'] as $child) {\n                                $nav[$index]['children'][] = self::createChildNavItem($child, $e);\n                            }\n\n                            break;\n\n                        case Extension::NAV_CHILD:\n                            if (!is_numeric($item['location'])) {\n                                // is a navigation group\n                                $group_name = $item['location'];\n                                $group_index = self::__navigationFindGroupIndex($nav, $item['location']);\n                            } else {\n                                // is a legacy numeric index\n                                $group_index = $item['location'];\n                            }\n\n                            $child = self::createChildNavItem($item, $e);\n\n                            if ($group_index === false) {\n                                $group_index = General::array_find_available_index($nav, 0);\n\n                                $nav_parent = self::createParentNavItem($group_index, $item);\n                                $nav_parent['name'] = $group_name;\n                                $nav_parent['children'] = array($child);\n\n                                // add new navigation group\n                                $nav[$group_index] = $nav_parent;\n                            } else {\n                                // add new location by index\n                                $nav[$group_index]['children'][] = $child;\n                            }\n\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * This function builds out a navigation menu item for parents. Parents display\n     * in the top level navigation of the backend and may have children (dropdown menus)\n     *\n     * @since Symphony 2.5.1\n     * @param integer $index\n     * @param array $item\n     * @return array\n     */\n    private static function createParentNavItem($index, $item)\n    {\n        $nav_item = array(\n            'name' => $item['name'],\n            'type' => isset($item['type']) ? $item['type'] : 'structure',\n            'index' => $index,\n            'children' => array(),\n            'limit' => isset($item['limit']) ? $item['limit'] : null\n        );\n\n        return $nav_item;\n    }\n\n    /**\n     * This function builds out a navigation menu item for children. Children\n     * live under a parent navigation item and are shown on hover.\n     *\n     * @since Symphony 2.5.1\n     * @param array $item\n     * @param string $extension_handle\n     * @return array\n     */\n    private static function createChildNavItem($item, $extension_handle)\n    {\n        if (!isset($item['relative']) || $item['relative'] === true) {\n            $link = '/extension/' . $extension_handle . '/' . ltrim($item['link'], '/');\n        } else {\n            $link = '/' . ltrim($item['link'], '/');\n        }\n\n        $nav_item = array(\n            'link' => $link,\n            'name' => $item['name'],\n            'visible' => (isset($item['visible']) && $item['visible'] == 'no') ? 'no' : 'yes',\n            'limit' => isset($item['limit']) ? $item['limit'] : null,\n            'target' => isset($item['target']) ? $item['target'] : null\n        );\n\n        return $nav_item;\n    }\n\n    /**\n     * This function populates the `$_navigation` array with an associative array\n     * of all the navigation groups and their links. Symphony only supports one\n     * level of navigation, so children links cannot have children links. The default\n     * Symphony navigation is found in the `ASSETS/xml/navigation.xml` folder. This is\n     * loaded first, and then the Section navigation is built, followed by the Extension\n     * navigation. Additionally, this function will set the active group of the navigation\n     * by checking the current page against the array of links.\n     *\n     * @link https://github.com/symphonycms/symphony-2/blob/master/symphony/assets/xml/navigation.xml\n     * @link https://github.com/symphonycms/symphony-2/blob/master/symphony/lib/toolkit/class.extension.php\n     */\n    public function __buildNavigation()\n    {\n        $nav = array();\n\n        $this->buildXmlNavigation($nav);\n        $this->buildSectionNavigation($nav);\n        $this->buildExtensionsNavigation($nav);\n\n        $pageCallback = Administration::instance()->getPageCallback();\n\n        $pageRoot = $pageCallback['pageroot'] . (isset($pageCallback['context'][0]) ? $pageCallback['context'][0] . '/' : '');\n        $found = self::__findActiveNavigationGroup($nav, $pageRoot);\n\n        // Normal searches failed. Use a regular expression using the page root. This is less\n        // efficient and should never really get invoked unless something weird is going on\n        if (!$found) {\n            self::__findActiveNavigationGroup($nav, '/^' . str_replace('/', '\\/', $pageCallback['pageroot']) . '/i', true);\n        }\n\n        ksort($nav);\n        $this->_navigation = $nav;\n    }\n\n    /**\n     * Given an associative array representing the navigation, and a group,\n     * this function will attempt to return the index of the group in the navigation\n     * array. If it is found, it will return the index, otherwise it will return false.\n     *\n     * @param array $nav\n     *  An associative array of the navigation where the key is the group\n     *  index, and the value is an associative array of 'name', 'index' and\n     *  'children'. Name is the name of the this group, index is the same as\n     *  the key and children is an associative array of navigation items containing\n     *  the keys 'link', 'name' and 'visible'. The 'haystack'.\n     * @param string $group\n     *  The group name to find, the 'needle'.\n     * @return integer|boolean\n     *  If the group is found, the index will be returned, otherwise false.\n     */\n    private static function __navigationFindGroupIndex(array $nav, $group)\n    {\n        foreach ($nav as $index => $item) {\n            if ($item['name'] === $group) {\n                return $index;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Given the navigation array, this function will loop over all the items\n     * to determine which is the 'active' navigation group, or in other words,\n     * what group best represents the current page `$this->Author` is viewing.\n     * This is done by checking the current page's link against all the links\n     * provided in the `$nav`, and then flagging the group of the found link\n     * with an 'active' CSS class. The current page's link omits any flags or\n     * URL parameters and just uses the root page URL.\n     *\n     * @param array $nav\n     *  An associative array of the navigation where the key is the group\n     *  index, and the value is an associative array of 'name', 'index' and\n     *  'children'. Name is the name of the this group, index is the same as\n     *  the key and children is an associative array of navigation items containing\n     *  the keys 'link', 'name' and 'visible'. The 'haystack'. This parameter is passed\n     *  by reference to this function.\n     * @param string $pageroot\n     *  The current page the Author is the viewing, minus any flags or URL\n     *  parameters such as a Symphony object ID. eg. Section ID, Entry ID. This\n     *  parameter is also be a regular expression, but this is highly unlikely.\n     * @param boolean $pattern\n     *  If set to true, the `$pageroot` represents a regular expression which will\n     *  determine if the active navigation item\n     * @return boolean\n     *  Returns true if an active link was found, false otherwise. If true, the\n     *  navigation group of the active link will be given the CSS class 'active'\n     */\n    private static function __findActiveNavigationGroup(array &$nav, $pageroot, $pattern = false)\n    {\n        foreach ($nav as $index => $contents) {\n            if (is_array($contents['children']) && !empty($contents['children'])) {\n                foreach ($contents['children'] as $item) {\n                    if ($pattern && preg_match($pageroot, $item['link'])) {\n                        $nav[$index]['class'] = 'active';\n                        return true;\n                    } elseif ($item['link'] == $pageroot) {\n                        $nav[$index]['class'] = 'active';\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates the Symphony footer for an Administration page. By default\n     * this includes the installed Symphony version and the currently logged\n     * in Author. A delegate is provided to allow extensions to manipulate the\n     * footer HTML, which is an XMLElement of a `<ul>` element.\n     * Since Symphony 2.3, it no longer uses the `AddElementToFooter` delegate.\n     */\n    public function appendUserLinks()\n    {\n        $ul = new XMLElement('ul', null, array('id' => 'session'));\n\n        $li = new XMLElement('li');\n        $li->appendChild(\n            Widget::Anchor(\n                Symphony::Author()->getFullName(),\n                SYMPHONY_URL . '/system/authors/edit/' . Symphony::Author()->get('id') . '/'\n            )\n        );\n        $ul->appendChild($li);\n\n        $li = new XMLElement('li');\n        $li->appendChild(Widget::Anchor(__('Log out'), SYMPHONY_URL . '/logout/', null, null, null, array('accesskey' => 'l')));\n        $ul->appendChild($li);\n\n        $this->Header->appendChild($ul);\n    }\n}\n"], "filenames": ["symphony/content/content.blueprintssections.php", "symphony/content/content.publish.php", "symphony/lib/toolkit/class.administrationpage.php"], "buggy_code_start_loc": [218, 382, 810], "buggy_code_end_loc": [446, 1320, 830], "fixing_code_start_loc": [218, 382, 810], "fixing_code_end_loc": [446, 1320, 830], "type": "CWE-79", "message": "Symphony 2 2.6.11 has XSS in the meta[navigation_group] parameter to content/content.blueprintssections.php.", "other": {"cve": {"id": "CVE-2017-8876", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-10T05:29:00.410", "lastModified": "2020-08-25T15:59:45.450", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symphony 2 2.6.11 has XSS in the meta[navigation_group] parameter to content/content.blueprintssections.php."}, {"lang": "es", "value": "Symphony 2 2.6.11 tiene XSS en el par\u00e1metro meta [navigation_group] a content/content.blueprintssections.php."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:getsymphony:symphony:2.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "89A66A3F-7AE2-4C5C-A94F-80F056835B61"}]}]}], "references": [{"url": "https://github.com/DeuxHuitHuit/symphony-2/commit/cd69a2a516e6503c1a1c7e097ee90d255ec3d6b7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DeuxHuitHuit/symphony-2/commit/cd69a2a516e6503c1a1c7e097ee90d255ec3d6b7"}}