{"buggy_code": ["/* State machine for IKEv1\n *\n * Copyright (C) 1997 Angelos D. Keromytis.\n * Copyright (C) 1998-2010,2013-2016 D. Hugh Redelmeier <hugh@mimosa.com>\n * Copyright (C) 2003-2008 Michael Richardson <mcr@xelerance.com>\n * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>\n * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>\n * Copyright (C) 2011 Avesh Agarwal <avagarwa@redhat.com>\n * Copyright (C) 2008 Hiren Joshi <joshihirenn@gmail.com>\n * Copyright (C) 2009 Anthony Tong <atong@TrustedCS.com>\n * Copyright (C) 2012-2019 Paul Wouters <pwouters@redhat.com>\n * Copyright (C) 2013 Wolfgang Nothdurft <wolfgang@linogate.de>\n * Copyright (C) 2019-2019 Andrew Cagney <cagney@gnu.org>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.  See <https://www.gnu.org/licenses/gpl2.txt>.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * for more details.\n *\n */\n\n/* Ordering Constraints on Payloads\n *\n * rfc2409: The Internet Key Exchange (IKE)\n *\n * 5 Exchanges:\n *   \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n *\n *   \"Except where otherwise noted, there are no requirements for ISAKMP\n *    payloads in any message to be in any particular order.\"\n *\n * 5.3 Phase 1 Authenticated With a Revised Mode of Public Key Encryption:\n *\n *   \"If the HASH payload is sent it MUST be the first payload of the\n *    second message exchange and MUST be followed by the encrypted\n *    nonce. If the HASH payload is not sent, the first payload of the\n *    second message exchange MUST be the encrypted nonce.\"\n *\n *   \"Save the requirements on the location of the optional HASH payload\n *    and the mandatory nonce payload there are no further payload\n *    requirements. All payloads-- in whatever order-- following the\n *    encrypted nonce MUST be encrypted with Ke_i or Ke_r depending on the\n *    direction.\"\n *\n * 5.5 Phase 2 - Quick Mode\n *\n *   \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n *    header and a SA payload MUST immediately follow the HASH.\"\n *   [NOTE: there may be more than one SA payload, so this is not\n *    totally reasonable.  Probably all SAs should be so constrained.]\n *\n *   \"If ISAKMP is acting as a client negotiator on behalf of another\n *    party, the identities of the parties MUST be passed as IDci and\n *    then IDcr.\"\n *\n *   \"With the exception of the HASH, SA, and the optional ID payloads,\n *    there are no payload ordering restrictions on Quick Mode.\"\n */\n\n/* Unfolding of Identity -- a central mystery\n *\n * This concerns Phase 1 identities, those of the IKE hosts.\n * These are the only ones that are authenticated.  Phase 2\n * identities are for IPsec SAs.\n *\n * There are three case of interest:\n *\n * (1) We initiate, based on a whack command specifying a Connection.\n *     We know the identity of the peer from the Connection.\n *\n * (2) (to be implemented) we initiate based on a flow from our client\n *     to some IP address.\n *     We immediately know one of the peer's client IP addresses from\n *     the flow.  We must use this to figure out the peer's IP address\n *     and Id.  To be solved.\n *\n * (3) We respond to an IKE negotiation.\n *     We immediately know the peer's IP address.\n *     We get an ID Payload in Main I2.\n *\n *     Unfortunately, this is too late for a number of things:\n *     - the ISAKMP SA proposals have already been made (Main I1)\n *       AND one accepted (Main R1)\n *     - the SA includes a specification of the type of ID\n *       authentication so this is negotiated without being told the ID.\n *     - with Preshared Key authentication, Main I2 is encrypted\n *       using the key, so it cannot be decoded to reveal the ID\n *       without knowing (or guessing) which key to use.\n *\n *     There are three reasonable choices here for the responder:\n *     + assume that the initiator is making wise offers since it\n *       knows the IDs involved.  We can balk later (but not gracefully)\n *       when we find the actual initiator ID\n *     + attempt to infer identity by IP address.  Again, we can balk\n *       when the true identity is revealed.  Actually, it is enough\n *       to infer properties of the identity (eg. SA properties and\n *       PSK, if needed).\n *     + make all properties universal so discrimination based on\n *       identity isn't required.  For example, always accept the same\n *       kinds of encryption.  Accept Public Key Id authentication\n *       since the Initiator presumably has our public key and thinks\n *       we must have / can find his.  This approach is weakest\n *       for preshared key since the actual key must be known to\n *       decrypt the Initiator's ID Payload.\n *     These choices can be blended.  For example, a class of Identities\n *     can be inferred, sufficient to select a preshared key but not\n *     sufficient to infer a unique identity.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n\n#include \"sysdep.h\"\n#include \"constants.h\"\n#include \"lswlog.h\"\n\n#include \"defs.h\"\n#include \"ike_spi.h\"\n#include \"id.h\"\n#include \"x509.h\"\n#include \"pluto_x509.h\"\n#include \"certs.h\"\n#include \"connections.h\"        /* needs id.h */\n#include \"state.h\"\n#include \"ikev1_msgid.h\"\n#include \"packet.h\"\n#include \"crypto.h\"\n#include \"ike_alg.h\"\n#include \"log.h\"\n#include \"demux.h\"      /* needs packet.h */\n#include \"ikev1.h\"\n#include \"ipsec_doi.h\"  /* needs demux.h and state.h */\n#include \"ikev1_quick.h\"\n#include \"timer.h\"\n#include \"whack.h\"      /* requires connections.h */\n#include \"server.h\"\n#include \"send.h\"\n#include \"ikev1_send.h\"\n#include \"ikev1_xauth.h\"\n#include \"retransmit.h\"\n#include \"nat_traversal.h\"\n#include \"vendor.h\"\n#include \"ikev1_dpd.h\"\n#include \"hostpair.h\"\n#include \"ip_address.h\"\n#include \"ikev1_hash.h\"\n#include \"ike_alg_encrypt_ops.h\"\t/* XXX: oops */\n#include \"ikev1_states.h\"\n#include \"initiate.h\"\n#include \"iface.h\"\n#include \"ip_selector.h\"\n\n#ifdef HAVE_NM\n#include \"kernel.h\"\n#endif\n\n#include \"pluto_stats.h\"\n\n/*\n * state_v1_microcode is a tuple of information parameterizing certain\n * centralized processing of a packet.  For example, it roughly\n * specifies what payloads are expected in this message.  The\n * microcode is selected primarily based on the state.  In Phase 1,\n * the payload structure often depends on the authentication\n * technique, so that too plays a part in selecting the\n * state_v1_microcode to use.\n */\n\nstruct state_v1_microcode {\n\tenum state_kind state, next_state;\n\tlset_t flags;\n\tlset_t req_payloads;    /* required payloads (allows just one) */\n\tlset_t opt_payloads;    /* optional payloads (any mumber) */\n\tenum event_type timeout_event;\n\tikev1_state_transition_fn *processor;\n\tconst char *message;\n\tenum v1_hash_type hash_type;\n};\n\nvoid jam_v1_transition(jambuf_t *buf, const struct state_v1_microcode *transition)\n{\n\tif (transition == NULL) {\n\t\tjam(buf, \"NULL\");\n\t} else {\n\t\tjam(buf, \"%s->%s\",\n\t\t    finite_states[transition->state]->short_name,\n\t\t    finite_states[transition->next_state]->short_name);\n\t}\n}\n\n/* State Microcode Flags, in several groups */\n\n/* Oakley Auth values: to which auth values does this entry apply?\n * Most entries will use SMF_ALL_AUTH because they apply to all.\n * Note: SMF_ALL_AUTH matches 0 for those circumstances when no auth\n * has been set.\n *\n * The IKEv1 state machine then uses the auth type (SMF_*_AUTH flags)\n * to select the exact state transition.  For states where auth\n * (SMF_*_AUTH flags) don't apply (.e.g, child states)\n * flags|=SMF_ALL_AUTH so the first transition always matches.\n *\n * Once a transition is selected, the containing payloads are checked\n * against what is allowed.  For instance, in STATE_MAIN_R2 ->\n * STATE_MAIN_R3 with SMF_DS_AUTH requires P(SIG).\n *\n * In IKEv2, it is the message header and payload types that select\n * the state.  As for how the IKEv1 'from state' is slected, look for\n * a big nasty magic switch.\n *\n * XXX: the state transition table is littered with STATE_UNDEFINED /\n * SMF_ALL_AUTH / unexpected() entries.  These are to catch things\n * like unimplemented auth cases, and unexpected packets.  For the\n * latter, they seem to be place holders so that the table contains at\n * least one entry for the state.\n *\n * XXX: Some of the SMF flags specify attributes of the current state\n * (e.g., SMF_RETRANSMIT_ON_DUPLICATE), some apply to the state\n * transition (e.g., SMF_REPLY), and some can be interpreted as either\n * (.e.g., SMF_INPUT_ENCRYPTED).\n */\n#define SMF_ALL_AUTH    LRANGE(0, OAKLEY_AUTH_ROOF - 1)\n#define SMF_PSK_AUTH    LELEM(OAKLEY_PRESHARED_KEY)\n#define SMF_DS_AUTH     (LELEM(OAKLEY_DSS_SIG) | LELEM(OAKLEY_RSA_SIG))\n#define SMF_PKE_AUTH    LELEM(OAKLEY_RSA_ENC)\n#define SMF_RPKE_AUTH   LELEM(OAKLEY_RSA_REVISED_MODE)\n\n/* misc flags */\n#define SMF_INITIATOR   LELEM(OAKLEY_AUTH_ROOF + 0)\n#define SMF_FIRST_ENCRYPTED_INPUT       LELEM(OAKLEY_AUTH_ROOF + 1)\n#define SMF_INPUT_ENCRYPTED     LELEM(OAKLEY_AUTH_ROOF + 2)\n#define SMF_OUTPUT_ENCRYPTED    LELEM(OAKLEY_AUTH_ROOF + 3)\n#define SMF_RETRANSMIT_ON_DUPLICATE     LELEM(OAKLEY_AUTH_ROOF + 4)\n\n#define SMF_ENCRYPTED (SMF_INPUT_ENCRYPTED | SMF_OUTPUT_ENCRYPTED)\n\n/* this state generates a reply message */\n#define SMF_REPLY   LELEM(OAKLEY_AUTH_ROOF + 5)\n\n/* this state completes P1, so any pending P2 negotiations should start */\n#define SMF_RELEASE_PENDING_P2  LELEM(OAKLEY_AUTH_ROOF + 6)\n\n/* if we have canoncalized the authentication from XAUTH mode */\n#define SMF_XAUTH_AUTH  LELEM(OAKLEY_AUTH_ROOF + 7)\n\n/* end of flags */\n\nstatic ikev1_state_transition_fn unexpected;      /* forward declaration */\nstatic ikev1_state_transition_fn informational;      /* forward declaration */\n\n/*\n * v1_state_microcode_table is a table of all state_v1_microcode\n * tuples.  It must be in order of state (the first element).  After\n * initialization, ike_microcode_index[s] points to the first entry in\n * v1_state_microcode_table for state s.  Remember that each state\n * name in Main or Quick Mode describes what has happened in the past,\n * not what this message is.\n */\n\nstatic const struct state_v1_microcode v1_state_microcode_table[] = {\n\n#define P(n) LELEM(ISAKMP_NEXT_ ##n)\n#define FM(F) .processor = F, .message = #F\n\n\t/***** Phase 1 Main Mode *****/\n\n\t/* No state for main_outI1: --> HDR, SA */\n\n\t/* STATE_MAIN_R0: I1 --> R1\n\t * HDR, SA --> HDR, SA\n\t */\n\t{ STATE_MAIN_R0, STATE_MAIN_R1,\n\t  SMF_ALL_AUTH | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR),\n\t  EVENT_SO_DISCARD,\n\t  FM(main_inI1_outR1),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_I1: R1 --> I2\n\t * HDR, SA --> auth dependent\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: --> HDR, KE, Ni\n\t * SMF_PKE_AUTH:\n\t *\t--> HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t * SMF_RPKE_AUTH:\n\t *\t--> HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t * Note: since we don't know auth at start, we cannot differentiate\n\t * microcode entries based on it.\n\t */\n\t{ STATE_MAIN_I1, STATE_MAIN_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR),\n\t  EVENT_RETRANSMIT,\n\t  FM(main_inR1_outI2),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_R1: I2 --> R2\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: HDR, KE, Ni --> HDR, KE, Nr\n\t * SMF_PKE_AUTH: HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t *\t    --> HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t * SMF_RPKE_AUTH:\n\t *\t    HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t *\t    --> HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t */\n\t{ STATE_MAIN_R1, STATE_MAIN_R2,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC),\n\t  EVENT_RETRANSMIT,\n\t  FM(main_inI2_outR2),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR) | P(HASH),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_RPKE_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR) | P(HASH) | P(CERT),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* for states from here on, output message must be encrypted */\n\n\t/* STATE_MAIN_I2: R2 --> I3\n\t * SMF_PSK_AUTH: HDR, KE, Nr --> HDR*, IDi1, HASH_I\n\t * SMF_DS_AUTH: HDR, KE, Nr --> HDR*, IDi1, [ CERT, ] SIG_I\n\t * SMF_PKE_AUTH: HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t *\t    --> HDR*, HASH_I\n\t * SMF_RPKE_AUTH: HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t *\t    --> HDR*, HASH_I\n\t */\n\t{ STATE_MAIN_I2, STATE_MAIN_I3,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC),\n\t  EVENT_RETRANSMIT,\n\t  FM(main_inR2_outI3),\n\t  /* calls main_mode_hash() after DH */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* for states from here on, input message must be encrypted */\n\n\t/* STATE_MAIN_R2: I3 --> R3\n\t * SMF_PSK_AUTH: HDR*, IDi1, HASH_I --> HDR*, IDr1, HASH_R\n\t * SMF_DS_AUTH: HDR*, IDi1, [ CERT, ] SIG_I --> HDR*, IDr1, [ CERT, ] SIG_R\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_I --> HDR*, HASH_R\n\t */\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inI3_outR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inI3_outR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b )\n\t     SIG_I = SIGN(HASH_I) *\",\n\t     SIG_I = SIGN(HASH_I) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_I3: R3 --> done\n\t * SMF_PSK_AUTH: HDR*, IDr1, HASH_R --> done\n\t * SMF_DS_AUTH: HDR*, IDr1, [ CERT, ] SIG_R --> done\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_R --> done\n\t * May initiate quick mode by calling quick_outI1\n\t */\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_PSK_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_DS_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b )\n\t     SIG_R = SIGN(HASH_R) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I3, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_R3: can only get here due to packet loss */\n\t{ STATE_MAIN_R3, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_I4: can only get here due to packet loss */\n\t{ STATE_MAIN_I4, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/***** Phase 1 Aggressive Mode *****/\n\n\t/* No initial state for aggr_outI1:\n\t * SMF_DS_AUTH (RFC 2409 5.1) and SMF_PSK_AUTH (RFC 2409 5.4):\n\t * -->HDR, SA, KE, Ni, IDii\n\t *\n\t * Not implemented:\n\t * RFC 2409 5.2: --> HDR, SA, [ HASH(1),] KE, <IDii_b>Pubkey_r, <Ni_b>Pubkey_r\n\t * RFC 2409 5.3: --> HDR, SA, [ HASH(1),] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDii_b>Ke_i [, <Cert-I_b>Ke_i ]\n\t */\n\n\t/* STATE_AGGR_R0:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Ni, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, HASH_R\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t */\n\t{ STATE_AGGR_R0, STATE_AGGR_R1,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC),\n\t  EVENT_SO_DISCARD,\n\t  FM(aggr_inI1_outR1),\n\t  /* N/A */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_I1:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Nr, IDir, HASH_R\n\t *           --> HDR*, HASH_I\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t *           --> HDR*, [CERT,] SIG_I\n\t */\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_PSK_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(HASH), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inR1_outI2),\n\t  /* after DH calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(SIG), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inR1_outI2),\n\t  /* after DH calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b )\n\t     SIG_R = SIGN(HASH_R) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_R1:\n\t * SMF_PSK_AUTH: HDR*, HASH_I --> done\n\t * SMF_DS_AUTH:  HDR*, SIG_I  --> done\n\t */\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_OUTPUT_ENCRYPTED | SMF_RELEASE_PENDING_P2 |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(HASH), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inI2),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_OUTPUT_ENCRYPTED | SMF_RELEASE_PENDING_P2 |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(SIG), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inI2),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b )\n\t     SIG_I = SIGN(HASH_I) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_I2: can only get here due to packet loss */\n\t{ STATE_AGGR_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY, EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_R2: can only get here due to packet loss */\n\t{ STATE_AGGR_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY, EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/***** Phase 2 Quick Mode *****/\n\n\t/* No state for quick_outI1:\n\t * --> HDR*, HASH(1), SA, Nr [, KE ] [, IDci, IDcr ]\n\t */\n\n\t/* STATE_QUICK_R0:\n\t * HDR*, HASH(1), SA, Ni [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ]\n\t * Installs inbound IPsec SAs.\n\t * Because it may suspend for asynchronous DNS, first_out_payload\n\t * is set to NONE to suppress early emission of HDR*.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_R0, STATE_QUICK_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(NATOA_RFC),\n\t  EVENT_RETRANSMIT,\n\t  FM(quick_inI1_outR1),\n\t  /* RFC 2409: 5.5 Phase 2 - Quick Mode:\n\t     HASH(1) = prf(SKEYID_a, M-ID | <rest>) */\n\t  .hash_type = V1_HASH_1, },\n\n\t/* STATE_QUICK_I1:\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(3)\n\t * Installs inbound and outbound IPsec SAs, routing, etc.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_I1, STATE_QUICK_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(NATOA_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(quick_inR1_outI2),\n\t  /* RFC 2409: 5.5 Phase 2 - Quick Mode:\n\t     HASH(2) = prf(SKEYID_a, M-ID | Ni_b | <rest>) */\n\t  .hash_type = V1_HASH_2, },\n\n\t/* STATE_QUICK_R1: HDR*, HASH(3) --> done\n\t * Installs outbound IPsec SAs, routing, etc.\n\t */\n\t{ STATE_QUICK_R1, STATE_QUICK_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY,\n\t  EVENT_SA_REPLACE,\n\t  FM(quick_inI2),\n\t  /* RFC 2409: 5.5 Phase 2 - Quick Mode:\n\t     HASH(3) = prf(SKEYID_a, 0 | M-ID | Ni_b | Nr_b) */\n\t  .hash_type = V1_HASH_3, },\n\n\t/* STATE_QUICK_I2: can only happen due to lost packet */\n\t{ STATE_QUICK_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_QUICK_R2: can only happen due to lost packet */\n\t{ STATE_QUICK_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/***** informational messages *****/\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR N/D\n\t * Unencrypted: must not occur after ISAKMP Phase 1 exchange of keying material.\n\t */\n\t/* STATE_INFO: */\n\t{ STATE_INFO, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(informational),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR* N/D\n\t */\n\t/* STATE_INFO_PROTECTED: */\n\t{ STATE_INFO_PROTECTED, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY,\n\t  EVENT_NULL,\n\t  FM(informational),\n\t  /* RFC 2409: 5.7 ISAKMP Informational Exchanges:\n\t     HASH(1) = prf(SKEYID_a, M-ID | N/D) */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_XAUTH_R0, STATE_XAUTH_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_NULL,\n\t  FM(xauth_inR0),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, }, /* Re-transmit may be done by previous state */\n\n\t{ STATE_XAUTH_R1, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(xauth_inR1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n#if 0\n\t/* for situation where there is XAUTH + ModeCFG */\n\t{ STATE_XAUTH_R2, STATE_XAUTH_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(xauth_inR2), },\n\n\t{ STATE_XAUTH_R3, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(xauth_inR3), },\n#endif\n\n/* MODE_CFG_x:\n * Case R0:  Responder\t->\tInitiator\n *\t\t\t<-\tReq(addr=0)\n *\t    Reply(ad=x)\t->\n *\n * Case R1: Set(addr=x)\t->\n *\t\t\t<-\tAck(ok)\n */\n\n\t{ STATE_MODE_CFG_R0, STATE_MODE_CFG_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(modecfg_inR0),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_MODE_CFG_R1, STATE_MODE_CFG_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(modecfg_inR1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_MODE_CFG_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MODE_CFG_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(modecfg_inR1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_XAUTH_I0, STATE_XAUTH_I1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_RETRANSMIT,\n\t  FM(xauth_inI0),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_XAUTH_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_RETRANSMIT,\n\t  FM(xauth_inI1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_IKEv1_ROOF, STATE_IKEv1_ROOF,\n\t  LEMPTY,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL, NULL,\n\t  .hash_type = V1_HASH_NONE, },\n\n#undef FM\n#undef P\n};\n\nvoid init_ikev1(void)\n{\n\tDBGF(DBG_CONTROL, \"checking IKEv1 state table\");\n\n\t/*\n\t * Fill in FINITE_STATES[].\n\t *\n\t * This is a hack until each finite-state is a separate object\n\t * with corresponding edges (aka microcodes).\n\t *\n\t * XXX: Long term goal is to have a constant FINITE_STATES[]\n\t * contain constant pointers and this static writeable array\n\t * to just go away.\n\t */\n\tfor (enum state_kind kind = STATE_IKEv1_FLOOR; kind < STATE_IKEv1_ROOF; kind++) {\n\t\t/* fill in using static struct */\n\t\tconst struct finite_state *fs = &v1_states[kind - STATE_IKEv1_FLOOR];\n\t\tpassert(fs->kind == kind);\n\t\tpassert(finite_states[kind] == NULL);\n\t\tfinite_states[kind] = fs;\n\t}\n\n\t/*\n\t * Go through the state transition table filling in details\n\t * and checking for inconsistencies.\n\t */\n\tfor (const struct state_v1_microcode *t = v1_state_microcode_table;\n\t     t->state < STATE_IKEv1_ROOF; t++) {\n\n\t\tpassert(t->state >= STATE_IKEv1_FLOOR);\n\t\tpassert(t->state < STATE_IKEv1_ROOF);\n\t\tstruct finite_state *from = &v1_states[t->state - STATE_IKEv1_FLOOR];\n\n\t\t/*\n\t\t * Deal with next_state == STATE_UNDEFINED.\n\t\t *\n\t\t * XXX: STATE_UNDEFINED is used when a state\n\t\t * transitions back to the same state; such\n\t\t * transitions should instead explicitly specify that\n\t\t * same state.\n\t\t */\n\t\tenum state_kind next_state = (t->next_state == STATE_UNDEFINED ?\n\t\t\t\t\t      t->state : t->next_state);\n\t\tpassert(STATE_IKEv1_FLOOR <= next_state &&\n\t\t\tnext_state < STATE_IKEv1_ROOF);\n\t\tconst struct finite_state *to = finite_states[next_state];\n\t\tpassert(to != NULL);\n\n\t\tif (DBGP(DBG_BASE)) {\n\t\t\tif (from->nr_transitions == 0) {\n\t\t\t\tLSWLOG_DEBUG(buf) {\n\t\t\t\t\tlswlogs(buf, \"  \");\n\t\t\t\t\tlswlog_finite_state(buf, from);\n\t\t\t\t\tlswlogs(buf, \":\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_log(\"    -> %s %s (%s)\", to->short_name,\n\t\t\t\tenum_short_name(&timer_event_names,\n\t\t\t\t\t\tt->timeout_event),\n\t\t\t\tt->message);\n\t\t}\n\n\t\t/*\n\t\t * Point .fs_v1_transitions at to the first entry in\n\t\t * v1_state_microcode_table for that state.  All other\n\t\t * transitions for that state should follow\n\t\t * immediately after (or to put it another way, the\n\t\t * previous transition's state should be the same as\n\t\t * this).\n\t\t */\n\t\tif (from->v1_transitions == NULL) {\n\t\t\tfrom->v1_transitions = t;\n\t\t} else {\n\t\t\tpassert(t[-1].state == t->state);\n\t\t}\n\t\tfrom->nr_transitions++;\n\n\t\tif (t->message == NULL) {\n\t\t\tPEXPECT_LOG(\"transition %s -> %s missing .message\",\n\t\t\t\t    from->short_name, to->short_name);\n\t\t}\n\n\t\t/*\n\t\t * Copy (actually merge) the flags that apply to the\n\t\t * state; and not the state transition.\n\t\t *\n\t\t * The original code used something like state\n\t\t * .microcode .flags after the state transition had\n\t\t * completed.  I.e., use the flags from a\n\t\t * not-yet-taken potential future state transition and\n\t\t * not the previous one.\n\t\t *\n\t\t * This is just trying to extact extract them and\n\t\t * check they are consistent.\n\t\t *\n\t\t * XXX: this is confusing\n\t\t *\n\t\t * Should fs_flags and SMF_RETRANSMIT_ON_DUPLICATE\n\t\t * should be replaced by SMF_RESPONDING in the\n\t\t * transition flags?\n\t\t *\n\t\t * Or is this more like .fs_timeout_event which is\n\t\t * always true of a state?\n\t\t */\n\t\tif ((t->flags & from->flags) != from->flags) {\n\t\t\tDBGF(DBG_BASE, \"transition %s -> %s (%s) missing flags 0x%\"PRIxLSET,\n\t\t\t     from->short_name, to->short_name,\n\t\t\t     t->message, from->flags);\n\t\t}\n\t\tfrom->flags |= t->flags & SMF_RETRANSMIT_ON_DUPLICATE;\n\n\t\tif (!(t->flags & SMF_FIRST_ENCRYPTED_INPUT) &&\n\t\t    (t->flags & SMF_INPUT_ENCRYPTED) &&\n\t\t    t->processor != unexpected) {\n\t\t\t/*\n\t\t\t * The first encrypted message carries\n\t\t\t * authentication information so isn't\n\t\t\t * applicable.  Other encrypted messages\n\t\t\t * require integrity via the HASH payload.\n\t\t\t */\n\t\t\tif (!(t->req_payloads & LELEM(ISAKMP_NEXT_HASH))) {\n\t\t\t\tPEXPECT_LOG(\"transition %s -> %s (%s) missing HASH payload\",\n\t\t\t\t\t    from->short_name, to->short_name,\n\t\t\t\t\t    t->message);\n\t\t\t}\n\t\t\tif (t->hash_type == V1_HASH_NONE) {\n\t\t\t\tPEXPECT_LOG(\"transition %s -> %s (%s) missing HASH protection\",\n\t\t\t\t\t    from->short_name, to->short_name,\n\t\t\t\t\t    t->message);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic stf_status unexpected(struct state *st, struct msg_digest *md UNUSED)\n{\n\tloglog(RC_LOG_SERIOUS, \"unexpected message received in state %s\",\n\t       st->st_state->name);\n\treturn STF_IGNORE;\n}\n\n/*\n * RFC 2408 Section 4.6\n *\n *  #   Initiator  Direction Responder  NOTE\n * (1)  HDR*; N/D     =>                Error Notification or Deletion\n */\nstatic stf_status informational(struct state *st, struct msg_digest *md)\n{\n\t/*\n\t * XXX: Danger: ST is deleted midway through this function.\n\t */\n\tpexpect(st == md->st);\n\tst = md->st;    /* may be NULL */\n\n\tstruct payload_digest *const n_pld = md->chain[ISAKMP_NEXT_N];\n\n\t/* If the Notification Payload is not null... */\n\tif (n_pld != NULL) {\n\t\tpb_stream *const n_pbs = &n_pld->pbs;\n\t\tstruct isakmp_notification *const n =\n\t\t\t&n_pld->payload.notification;\n\n\t\t/* Switch on Notification Type (enum) */\n\t\t/* note that we _can_ get notification payloads unencrypted\n\t\t * once we are at least in R3/I4.\n\t\t * and that the handler is expected to treat them suspiciously.\n\t\t */\n\t\tdbg(\"processing informational %s (%d)\",\n\t\t    enum_name(&ikev1_notify_names, n->isan_type),\n\t\t    n->isan_type);\n\n\t\tpstats(ikev1_recv_notifies_e, n->isan_type);\n\n\t\tswitch (n->isan_type) {\n\t\t/*\n\t\t * We answer DPD probes even if they claimed not to support\n\t\t * Dead Peer Detection.\n\t\t * We would have to send some kind of reply anyway to prevent\n\t\t * a retransmit, so rather then send an error, we might as\n\t\t * well just send a DPD reply\n\t\t */\n\t\tcase R_U_THERE:\n\t\t\tif (st == NULL) {\n\t\t\t\tplog_md(md, \"received bogus  R_U_THERE informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inI_outR(st, n, n_pbs);\n\n\t\tcase R_U_THERE_ACK:\n\t\t\tif (st == NULL) {\n\t\t\t\tplog_md(md, \"received bogus R_U_THERE_ACK informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inR(st, n, n_pbs);\n\n\t\tcase PAYLOAD_MALFORMED:\n\t\t\tif (st != NULL) {\n\t\t\t\tst->hidden_variables.st_malformed_received++;\n\n\t\t\t\tlog_state(RC_LOG, st, \"received %u malformed payload notifies\",\n\t\t\t\t\t  st->hidden_variables.st_malformed_received);\n\n\t\t\t\tif (st->hidden_variables.st_malformed_sent >\n\t\t\t\t    MAXIMUM_MALFORMED_NOTIFY / 2 &&\n\t\t\t\t    ((st->hidden_variables.st_malformed_sent +\n\t\t\t\t      st->hidden_variables.\n\t\t\t\t      st_malformed_received) >\n\t\t\t\t     MAXIMUM_MALFORMED_NOTIFY)) {\n\t\t\t\t\tlog_state(RC_LOG, st, \"too many malformed payloads (we sent %u and received %u\",\n\t\t\t\t\t\t  st->hidden_variables.st_malformed_sent,\n\t\t\t\t\t\t  st->hidden_variables.st_malformed_received);\n\t\t\t\t\tdelete_state(st);\n\t\t\t\t\tmd->st = st = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn STF_IGNORE;\n\n\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\t/*\n\t\t\t * ??? what the heck is in the payload?\n\t\t\t * We take the peer's new IP address from the last 4 octets.\n\t\t\t * Is anything else possible?  Expected?  Documented?\n\t\t\t */\n\t\t\tif (st == NULL || !IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tplog_md(md, \"ignoring ISAKMP_N_CISCO_LOAD_BALANCE Informational Message with for unestablished state.\");\n\t\t\t} else if (pbs_left(n_pbs) < 4) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"ignoring ISAKMP_N_CISCO_LOAD_BALANCE Informational Message without IPv4 address\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Copy (not cast) the last 4 bytes\n\t\t\t\t * (size of an IPv4) address from the\n\t\t\t\t * end of the notification into IN\n\t\t\t\t * (can't cast as can't assume that\n\t\t\t\t * ->roof-4 is correctly aligned).\n\t\t\t\t */\n\t\t\t\tstruct in_addr in;\n\t\t\t\tmemcpy(&in, n_pbs->roof - sizeof(in), sizeof(in));\n\t\t\t\tip_address new_peer = address_from_in_addr(&in);\n\n\t\t\t\t/* is all zeros? */\n\t\t\t\tif (address_is_any(&new_peer)) {\n\t\t\t\t\tipstr_buf b;\n\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"ignoring ISAKMP_N_CISCO_LOAD_BALANCE Informational Message with invalid IPv4 address %s\",\n\t\t\t\t\t\t  ipstr(&new_peer, &b));\n\t\t\t\t\treturn FALSE; /* XXX: STF_*? */\n\t\t\t\t}\n\n\t\t\t\t/* Saving connection name and whack sock id */\n\t\t\t\tconst char *tmp_name = st->st_connection->name;\n\t\t\t\tstruct fd *tmp_whack_sock = dup_any(st->st_whack_sock);\n\n\t\t\t\t/* deleting ISAKMP SA with the current remote peer */\n\t\t\t\tdelete_state(st);\n\t\t\t\tmd->st = st = NULL;\n\n\t\t\t\t/* to find and store the connection associated with tmp_name */\n\t\t\t\t/* ??? how do we know that tmp_name hasn't been freed? */\n\t\t\t\tstruct connection *tmp_c = conn_by_name(tmp_name, false/*!strict*/);\n\n\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\taddress_buf npb;\n\t\t\t\t\tDBG_log(\"new peer address: %s\",\n\t\t\t\t\t\tstr_address(&new_peer, &npb));\n\n\t\t\t\t\t/* Current remote peer info */\n\t\t\t\t\tint count_spd = 1;\n\t\t\t\t\tfor (const struct spd_route *tmp_spd = &tmp_c->spd;\n\t\t\t\t\t     tmp_spd != NULL; tmp_spd = tmp_spd->spd_next) {\n\t\t\t\t\t\taddress_buf b;\n\t\t\t\t\t\tendpoint_buf e;\n\n\t\t\t\t\t\tDBG_log(\"spd route number: %d\",\n\t\t\t\t\t\t\tcount_spd++);\n\n\t\t\t\t\t\t/**that info**/\n\t\t\t\t\t\tDBG_log(\"that id kind: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.id.kind);\n\t\t\t\t\t\tDBG_log(\"that id ipaddr: %s\",\n\t\t\t\t\t\t\tstr_address(&tmp_spd->that.id.ip_addr, &b));\n\t\t\t\t\t\tif (tmp_spd->that.id.name.ptr != NULL) {\n\t\t\t\t\t\t\tDBG_dump_hunk(\"that id name\",\n\t\t\t\t\t\t\t\t      tmp_spd->that.id. name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDBG_log(\"that host_addr: %s\",\n\t\t\t\t\t\t\tstr_endpoint(&tmp_spd->that.host_addr, &e));\n\t\t\t\t\t\tDBG_log(\"that nexthop: %s\",\n\t\t\t\t\t\t\tstr_address(&tmp_spd->that.host_nexthop, &b));\n\t\t\t\t\t\tDBG_log(\"that srcip: %s\",\n\t\t\t\t\t\t\tstr_address(&tmp_spd->that.host_srcip, &b));\n\t\t\t\t\t\tselector_buf sb;\n\t\t\t\t\t\tDBG_log(\"that client: %s\",\n\t\t\t\t\t\t\tstr_selector(&tmp_spd->that.client, &sb));\n\t\t\t\t\t\tDBG_log(\"that has_client: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_client);\n\t\t\t\t\t\tDBG_log(\"that has_client_wildcard: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_client_wildcard);\n\t\t\t\t\t\tDBG_log(\"that has_port_wildcard: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_port_wildcard);\n\t\t\t\t\t\tDBG_log(\"that has_id_wildcards: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_id_wildcards);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp_c->interface != NULL) {\n\t\t\t\t\t\tendpoint_buf b;\n\t\t\t\t\t\tDBG_log(\"Current interface_addr: %s\",\n\t\t\t\t\t\t\tstr_endpoint(&tmp_c->interface->local_endpoint, &b));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* save peer's old address for comparison purposes */\n\t\t\t\tip_address old_addr = tmp_c->spd.that.host_addr;\n\n\t\t\t\t/* update peer's address */\n\t\t\t\ttmp_c->spd.that.host_addr = new_peer;\n\n\t\t\t\t/* Modifying connection info to store the redirected remote peer info */\n\t\t\t\tdbg(\"Old host_addr_name : %s\", tmp_c->spd.that.host_addr_name);\n\t\t\t\ttmp_c->spd.that.host_addr_name = NULL;\n\n\t\t\t\t/* ??? do we know the id.kind has an ip_addr? */\n\t\t\t\ttmp_c->spd.that.id.ip_addr = new_peer;\n\n\t\t\t\t/* update things that were the old peer */\n\t\t\t\tipstr_buf b;\n\t\t\t\tif (sameaddr(&tmp_c->spd.this.host_nexthop,\n\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\t\tDBG_log(\"this host's next hop %s was the same as the old remote addr\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"changing this host's next hop to %s\",\n\t\t\t\t\t\t\tipstr(&new_peer, &b));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_c->spd.this.host_nexthop = new_peer;\n\t\t\t\t}\n\n\t\t\t\tif (sameaddr(&tmp_c->spd.that.host_srcip,\n\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\t\tDBG_log(\"Old that host's srcip %s was the same as the old remote addr\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"changing that host's srcip to %s\",\n\t\t\t\t\t\t\tipstr(&new_peer, &b));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_c->spd.that.host_srcip = new_peer;\n\t\t\t\t}\n\n\t\t\t\tif (sameaddr(&tmp_c->spd.that.client.addr,\n\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\t\tDBG_log(\"Old that client ip %s was the same as the old remote address\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"changing that client's ip to %s\",\n\t\t\t\t\t\t\tipstr(&new_peer, &b));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_c->spd.that.client.addr = new_peer;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * ??? is this wise?  This may changes\n\t\t\t\t * a lot of other connections.\n\t\t\t\t *\n\t\t\t\t * XXX:\n\t\t\t\t *\n\t\t\t\t * As for the old code, preserve the\n\t\t\t\t * existing port.  NEW_PEER, an\n\t\t\t\t * address, doesn't have a port and\n\t\t\t\t * presumably the port wasn't\n\t\t\t\t * updated(?).\n\t\t\t\t */\n\t\t\t\ttmp_c->host_pair->remote = endpoint(&new_peer,\n\t\t\t\t\t\t\t\t    endpoint_hport(&tmp_c->host_pair->remote));\n\n\t\t\t\t/* Initiating connection to the redirected peer */\n\t\t\t\tinitiate_connections_by_name(tmp_name, NULL,\n\t\t\t\t\t\t\t     tmp_whack_sock,\n\t\t\t\t\t\t\t     tmp_whack_sock == NULL/*guess*/);\n\t\t\t\tclose_any(&tmp_whack_sock);\n\t\t\t}\n\t\t\treturn STF_IGNORE;\n\t\tdefault:\n\t\t{\n\t\t\tstruct logger logger = st != NULL ? *(st->st_logger) : MESSAGE_LOGGER(md);\n\t\t\tlog_message(RC_LOG_SERIOUS, &logger,\n\t\t\t\t    \"received and ignored notification payload: %s\",\n\t\t\t\t    enum_name(&ikev1_notify_names, n->isan_type));\n\t\t\treturn STF_IGNORE;\n\t\t}\n\t\t}\n\t} else {\n\t\t/* warn if we didn't find any Delete or Notify payload in packet */\n\t\tif (md->chain[ISAKMP_NEXT_D] == NULL) {\n\t\t\tstruct logger logger = st != NULL ? *(st->st_logger) : MESSAGE_LOGGER(md);\n\t\t\tlog_message(RC_LOG_SERIOUS, &logger,\n\t\t\t\t    \"received and ignored empty informational notification payload\");\n\t\t}\n\t\treturn STF_IGNORE;\n\t}\n}\n\n/*\n * create output HDR as replica of input HDR - IKEv1 only; return the body\n */\nvoid ikev1_init_out_pbs_echo_hdr(struct msg_digest *md, bool enc,\n\t\t\t\t pb_stream *output_stream, uint8_t *output_buffer,\n\t\t\t\t size_t sizeof_output_buffer,\n\t\t\t\t pb_stream *rbody)\n{\n\tstruct isakmp_hdr hdr = md->hdr; /* mostly same as incoming header */\n\n\t/* make sure we start with a clean buffer */\n\tinit_out_pbs(output_stream, output_buffer, sizeof_output_buffer,\n\t\t     \"reply packet\");\n\n\thdr.isa_flags = 0; /* zero all flags */\n\tif (enc)\n\t\thdr.isa_flags |= ISAKMP_FLAGS_v1_ENCRYPTION;\n\n\tif (impair.send_bogus_isakmp_flag) {\n\t\thdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;\n\t}\n\n\t/* there is only one IKEv1 version, and no new one will ever come - no need to set version */\n\thdr.isa_np = 0;\n\t/* surely must have room and be well-formed */\n\tpassert(out_struct(&hdr, &isakmp_hdr_desc, output_stream, rbody));\n}\n\n/*\n * Recognise and, if necesssary, respond to an IKEv1 duplicate.\n *\n * Use .st_state, which is the true current state, and not MD\n * .FROM_STATE (which is derived from some convoluted magic) when\n * determining if the duplicate should or should not get a response.\n */\nstatic bool ikev1_duplicate(struct state *st, struct msg_digest *md)\n{\n\tpassert(st != NULL);\n\tif (st->st_v1_rpacket.ptr != NULL &&\n\t    st->st_v1_rpacket.len == pbs_room(&md->packet_pbs) &&\n\t    memeq(st->st_v1_rpacket.ptr, md->packet_pbs.start,\n\t\t  st->st_v1_rpacket.len)) {\n\t\t/*\n\t\t * Duplicate.  Drop or retransmit?\n\t\t *\n\t\t * Only re-transmit when the last state transition\n\t\t * (triggered by this packet the first time) included\n\t\t * a reply.\n\t\t *\n\t\t * XXX: is SMF_RETRANSMIT_ON_DUPLICATE useful or\n\t\t * correct?\n\t\t */\n\t\tbool replied = (st->st_v1_last_transition != NULL &&\n\t\t\t\t(st->st_v1_last_transition->flags & SMF_REPLY));\n\t\tbool retransmit_on_duplicate =\n\t\t\t(st->st_state->flags & SMF_RETRANSMIT_ON_DUPLICATE);\n\t\tif (replied && retransmit_on_duplicate) {\n\t\t\t/*\n\t\t\t * Transitions with EVENT_SO_DISCARD should\n\t\t\t * always respond to re-transmits (why?); else\n\t\t\t * cap.\n\t\t\t */\n\t\t\tif (st->st_v1_last_transition->timeout_event == EVENT_SO_DISCARD ||\n\t\t\t    count_duplicate(st, MAXIMUM_v1_ACCEPTED_DUPLICATES)) {\n\t\t\t\tloglog(RC_RETRANSMISSION,\n\t\t\t\t       \"retransmitting in response to duplicate packet; already %s\",\n\t\t\t\t       st->st_state->name);\n\t\t\t\tresend_recorded_v1_ike_msg(st, \"retransmit in response to duplicate\");\n\t\t\t} else {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"discarding duplicate packet -- exhausted retransmission; already %s\",\n\t\t\t\t       st->st_state->name);\n\t\t\t}\n\t\t} else {\n\t\t\tdbg(\"#%lu discarding duplicate packet; already %s; replied=%s retransmit_on_duplicate=%s\",\n\t\t\t    st->st_serialno, st->st_state->name,\n\t\t\t    bool_str(replied), bool_str(retransmit_on_duplicate));\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* process an input packet, possibly generating a reply.\n *\n * If all goes well, this routine eventually calls a state-specific\n * transition function.\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_v1_packet(struct msg_digest *md)\n{\n\tconst struct state_v1_microcode *smc;\n\tbool new_iv_set = FALSE;\n\tstruct state *st = NULL;\n\tenum state_kind from_state = STATE_UNDEFINED;   /* state we started in */\n\n#define SEND_NOTIFICATION(t) { \\\n\t\tpstats(ikev1_sent_notifies_e, t); \\\n\t\tif (st != NULL) \\\n\t\t\tsend_notification_from_state(st, from_state, t); \\\n\t\telse \\\n\t\t\tsend_notification_from_md(md, t); }\n\n\tswitch (md->hdr.isa_xchg) {\n\tcase ISAKMP_XCHG_AGGR:\n\tcase ISAKMP_XCHG_IDPROT: /* part of a Main Mode exchange */\n\t\tif (md->hdr.isa_msgid != v1_MAINMODE_MSGID) {\n\t\t\tplog_md(md, \"Message ID was 0x%08\" PRIx32 \" but should be zero in phase 1\",\n\t\t\t\tmd->hdr.isa_msgid);\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {\n\t\t\tplog_md(md, \"Initiator Cookie must not be zero in phase 1 message\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {\n\t\t\t/*\n\t\t\t * initial message from initiator\n\t\t\t */\n\t\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\t\tplog_md(md, \"initial phase 1 message is invalid: its Encrypted Flag is on\");\n\t\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there is already an existing state with\n\t\t\t * this ICOOKIE, asssume it is some sort of\n\t\t\t * re-transmit.\n\t\t\t */\n\t\t\tst = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi,\n\t\t\t\t\t\t   md->hdr.isa_msgid);\n\t\t\tif (st != NULL) {\n\t\t\t\tso_serial_t old_state = push_cur_state(st);\n\t\t\t\tif (!ikev1_duplicate(st, md)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not a duplicate for the\n\t\t\t\t\t * current state; assume that\n\t\t\t\t\t * this a really old\n\t\t\t\t\t * re-transmit for an earlier\n\t\t\t\t\t * state that should be\n\t\t\t\t\t * discarded.\n\t\t\t\t\t */\n\t\t\t\t\tlog_state(RC_LOG, st, \"discarding initial packet; already %s\",\n\t\t\t\t\t\t  st->st_state->name);\n\t\t\t\t}\n\t\t\t\tpop_cur_state(old_state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpassert(st == NULL); /* new state needed */\n\t\t\t/* don't build a state until the message looks tasty */\n\t\t\tfrom_state = (md->hdr.isa_xchg == ISAKMP_XCHG_IDPROT ?\n\t\t\t\t      STATE_MAIN_R0 : STATE_AGGR_R0);\n\t\t} else {\n\t\t\t/* not an initial message */\n\n\t\t\tst = find_state_ikev1(&md->hdr.isa_ike_spis,\n\t\t\t\t\t      md->hdr.isa_msgid);\n\n\t\t\tif (st == NULL) {\n\t\t\t\t/*\n\t\t\t\t * perhaps this is a first message\n\t\t\t\t * from the responder and contains a\n\t\t\t\t * responder cookie that we've not yet\n\t\t\t\t * seen.\n\t\t\t\t */\n\t\t\t\tst = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi,\n\t\t\t\t\t\t\t   md->hdr.isa_msgid);\n\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tplog_md(md, \"phase 1 message is part of an unknown exchange\");\n\t\t\t\t\t/* XXX Could send notification back */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state->kind;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_INFO:  /* an informational exchange */\n\t\tst = find_v1_info_state(&md->hdr.isa_ike_spis,\n\t\t\t\t\tv1_MAINMODE_MSGID);\n\n\t\tif (st == NULL) {\n\t\t\t/*\n\t\t\t * might be an informational response to our\n\t\t\t * first message, in which case, we don't know\n\t\t\t * the rcookie yet.\n\t\t\t */\n\t\t\tst = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi,\n\t\t\t\t\t\t   v1_MAINMODE_MSGID);\n\t\t}\n\n\t\tif (st != NULL)\n\t\t\tset_cur_state(st);\n\n\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\tbool quiet = (st == NULL);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\tDBG_log(\"Informational Exchange is for an unknown (expired?) SA with MSGID:0x%08\" PRIx32,\n\t\t\t\t\t\tmd->hdr.isa_msgid);\n\t\t\t\t\tDBG_dump_thing(\"- unknown SA's md->hdr.isa_ike_initiator_spi.bytes:\",\n\t\t\t\t\t\t       md->hdr.isa_ike_initiator_spi);\n\t\t\t\t\tDBG_dump_thing(\"- unknown SA's md->hdr.isa_ike_responder_spi.bytes:\",\n\t\t\t\t\t\t       md->hdr.isa_ike_responder_spi);\n\t\t\t\t}\n\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IS_ISAKMP_ENCRYPTED(st->st_state->kind)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"encrypted Informational Exchange message is invalid because no key is known\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"Informational Exchange message is invalid because it has a Message ID of 0\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"Informational Exchange message is invalid because it has a previously used Message ID (0x%08\" PRIx32 \" )\",\n\t\t\t\t\t\t  md->hdr.isa_msgid);\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_v1_msgid.reserved = FALSE;\n\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_INFO_PROTECTED;\n\t\t} else {\n\t\t\tif (st != NULL &&\n\t\t\t    IS_ISAKMP_AUTHENTICATED(st->st_state)) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"Informational Exchange message must be encrypted\");\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfrom_state = STATE_INFO;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_QUICK: /* part of a Quick Mode exchange */\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {\n\t\t\tdbg(\"Quick Mode message is invalid because it has an Initiator Cookie of 0\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {\n\t\t\tdbg(\"Quick Mode message is invalid because it has a Responder Cookie of 0\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\tdbg(\"Quick Mode message is invalid because it has a Message ID of 0\");\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tst = find_state_ikev1(&md->hdr.isa_ike_spis,\n\t\t\t\t      md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\t/* No appropriate Quick Mode state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tst = find_state_ikev1(&md->hdr.isa_ike_spis,\n\t\t\t\t\t      v1_MAINMODE_MSGID);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tdbg(\"Quick Mode message is for a non-existent (expired?) ISAKMP SA\");\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tdbg(\"Cannot do Quick Mode until XAUTH done.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Have we just given an IP address to peer? */\n\t\t\tif (st->st_state->kind == STATE_MODE_CFG_R2) {\n\t\t\t\t/* ISAKMP is up... */\n\t\t\t\tchange_state(st, STATE_MAIN_R3);\n\t\t\t}\n\n#ifdef SOFTREMOTE_CLIENT_WORKAROUND\n\t\t\t/* See: http://popoludnica.pl/?id=10100110 */\n\t\t\tif (st->st_state->kind == STATE_MODE_CFG_R1) {\n\t\t\t\tlog_state(RC_LOG, st,\n\t\t\t\t\t  \"SoftRemote workaround: Cannot do Quick Mode until MODECFG done.\");\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\tset_cur_state(st);\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"Quick Mode message is unacceptable because it is for an incomplete ISAKMP SA\");\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED /* XXX ? */);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"Quick Mode I1 message is unacceptable because it uses a previously used Message ID 0x%08\" PRIx32 \" (perhaps this is a duplicated packet)\",\n\t\t\t\t\t  md->hdr.isa_msgid);\n\t\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_v1_msgid.reserved = FALSE;\n\n\t\t\t/* Quick Mode Initial IV */\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_QUICK_R0;\n\t\t} else {\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tlog_state(RC_LOG, st, \"Cannot do Quick Mode until XAUTH done.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state->kind;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_MODE_CFG:\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {\n\t\t\tdbg(\"Mode Config message is invalid because it has an Initiator Cookie of 0\");\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {\n\t\t\tdbg(\"Mode Config message is invalid because it has a Responder Cookie of 0\");\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == 0) {\n\t\t\tdbg(\"Mode Config message is invalid because it has a Message ID of 0\");\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tst = find_v1_info_state(&md->hdr.isa_ike_spis, md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\t/* No appropriate Mode Config state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tdbg(\"No appropriate Mode Config state yet. See if we have a Main Mode state\");\n\n\t\t\tst = find_v1_info_state(&md->hdr.isa_ike_spis, 0);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tdbg(\"Mode Config message is for a non-existent (expired?) ISAKMP SA\");\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\t/* ??? ought to log something (not just DBG)? */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tset_cur_state(st);\n\n\t\t\tconst struct end *this = &st->st_connection->spd.this;\n\t\t\tdbg(\" processing received isakmp_xchg_type %s; this is a%s%s%s%s\",\n\t\t\t    enum_show(&ikev1_exchange_names, md->hdr.isa_xchg),\n\t\t\t    this->xauth_server ? \" xauthserver\" : \"\",\n\t\t\t    this->xauth_client ? \" xauthclient\" : \"\",\n\t\t\t    this->modecfg_server ? \" modecfgserver\" : \"\",\n\t\t\t    this->modecfg_client ? \" modecfgclient\" : \"\");\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tdbg(\"Mode Config message is unacceptable because it is for an incomplete ISAKMP SA (state=%s)\",\n\t\t\t\t    st->st_state->name);\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdbg(\" call  init_phase2_iv\");\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\t/*\n\t\t\t * okay, now we have to figure out if we are receiving a bogus\n\t\t\t * new message in an outstanding XAUTH server conversation\n\t\t\t * (i.e. a reply to our challenge)\n\t\t\t * (this occurs with some broken other implementations).\n\t\t\t *\n\t\t\t * or if receiving for the first time, an XAUTH challenge.\n\t\t\t *\n\t\t\t * or if we are getting a MODECFG request.\n\t\t\t *\n\t\t\t * we distinguish these states because we cannot both be an\n\t\t\t * XAUTH server and client, and our policy tells us which\n\t\t\t * one we are.\n\t\t\t *\n\t\t\t * to complicate further, it is normal to start a new msgid\n\t\t\t * when going from one state to another, or when restarting\n\t\t\t * the challenge.\n\t\t\t *\n\t\t\t */\n\n\t\t\tif (this->xauth_server &&\n\t\t\t    st->st_state->kind == STATE_XAUTH_R1 &&\n\t\t\t    st->quirks.xauth_ack_msgid) {\n\t\t\t\tfrom_state = STATE_XAUTH_R1;\n\t\t\t\tdbg(\" set from_state to %s state is STATE_XAUTH_R1 and quirks.xauth_ack_msgid is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->xauth_client &&\n\t\t\t\t   IS_PHASE1(st->st_state->kind)) {\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tdbg(\" set from_state to %s this is xauthclient and IS_PHASE1() is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->xauth_client &&\n\t\t\t\t   st->st_state->kind == STATE_XAUTH_I1) {\n\t\t\t\t/*\n\t\t\t\t * in this case, we got a new MODECFG message after I0, maybe\n\t\t\t\t * because it wants to start over again.\n\t\t\t\t */\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tdbg(\" set from_state to %s this is xauthclient and state == STATE_XAUTH_I1\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->modecfg_server &&\n\t\t\t\t   IS_PHASE1(st->st_state->kind)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R0;\n\t\t\t\tdbg(\" set from_state to %s this is modecfgserver and IS_PHASE1() is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->modecfg_client &&\n\t\t\t\t   IS_PHASE1(st->st_state->kind)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R1;\n\t\t\t\tdbg(\" set from_state to %s this is modecfgclient and IS_PHASE1() is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else {\n\t\t\t\tdbg(\"received isakmp_xchg_type %s; this is a%s%s%s%s in state %s. Reply with UNSUPPORTED_EXCHANGE_TYPE\",\n\t\t\t\t    enum_show(&ikev1_exchange_names, md->hdr.isa_xchg),\n\t\t\t\t    st->st_connection ->spd.this.xauth_server ? \" xauthserver\" : \"\",\n\t\t\t\t    st->st_connection->spd.this.xauth_client ? \" xauthclient\" : \"\",\n\t\t\t\t    st->st_connection->spd.this.modecfg_server ? \" modecfgserver\" : \"\",\n\t\t\t\t    st->st_connection->spd.this.modecfg_client  ? \" modecfgclient\" : \"\",\n\t\t\t\t    st->st_state->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (st->st_connection->spd.this.xauth_server &&\n\t\t\t    IS_PHASE1(st->st_state->kind)) {\n\t\t\t\t/* Switch from Phase1 to Mode Config */\n\t\t\t\tdbg(\"We were in phase 1, with no state, so we went to XAUTH_R0\");\n\t\t\t\tchange_state(st, STATE_XAUTH_R0);\n\t\t\t}\n\n\t\t\t/* otherwise, this is fine, we continue in the state we are in */\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state->kind;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_NONE:\n\tcase ISAKMP_XCHG_BASE:\n\tcase ISAKMP_XCHG_AO:\n\tcase ISAKMP_XCHG_NGRP:\n\tdefault:\n\t\tdbg(\"unsupported exchange type %s in message\",\n\t\t    enum_show(&ikev1_exchange_names, md->hdr.isa_xchg));\n\t\tSEND_NOTIFICATION(UNSUPPORTED_EXCHANGE_TYPE);\n\t\treturn;\n\t}\n\n\t/* We have found a from_state, and perhaps a state object.\n\t * If we need to build a new state object,\n\t * we wait until the packet has been sanity checked.\n\t */\n\n\t/* We don't support the Commit Flag.  It is such a bad feature.\n\t * It isn't protected -- neither encrypted nor authenticated.\n\t * A man in the middle turns it on, leading to DoS.\n\t * We just ignore it, with a warning.\n\t */\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_COMMIT)\n\t\tdbg(\"IKE message has the Commit Flag set but Pluto doesn't implement this feature due to security concerns; ignoring flag\");\n\n\t/* Handle IKE fragmentation payloads */\n\tif (md->hdr.isa_np == ISAKMP_NEXT_IKE_FRAGMENTATION) {\n\t\tstruct isakmp_ikefrag fraghdr;\n\t\tint last_frag_index = 0;  /* index of the last fragment */\n\t\tpb_stream frag_pbs;\n\n\t\tif (st == NULL) {\n\t\t\tdbg(\"received IKE fragment, but have no state. Ignoring packet.\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((st->st_connection->policy & POLICY_IKE_FRAG_ALLOW) == 0) {\n\t\t\tdbg(\"discarding IKE fragment packet - fragmentation not allowed by local policy (ike_frag=no)\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!in_struct(&fraghdr, &isakmp_ikefrag_desc,\n\t\t\t       &md->message_pbs, &frag_pbs) ||\n\t\t    pbs_room(&frag_pbs) != fraghdr.isafrag_length ||\n\t\t    fraghdr.isafrag_np != ISAKMP_NEXT_NONE ||\n\t\t    fraghdr.isafrag_number == 0 ||\n\t\t    fraghdr.isafrag_number > 16) {\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\n\t\tdbg(\"received IKE fragment id '%d', number '%u'%s\",\n\t\t    fraghdr.isafrag_id,\n\t\t    fraghdr.isafrag_number,\n\t\t    (fraghdr.isafrag_flags == 1) ? \"(last)\" : \"\");\n\n\t\tstruct v1_ike_rfrag *ike_frag = alloc_thing(struct v1_ike_rfrag, \"ike_frag\");\n\t\tike_frag->md = md_addref(md, HERE);\n\t\tike_frag->index = fraghdr.isafrag_number;\n\t\tike_frag->last = (fraghdr.isafrag_flags & 1);\n\t\tike_frag->size = pbs_left(&frag_pbs);\n\t\tike_frag->data = frag_pbs.cur;\n\n\t\t/* Add the fragment to the state */\n\t\tstruct v1_ike_rfrag **i = &st->st_v1_rfrags;\n\t\tfor (;;) {\n\t\t\tif (ike_frag != NULL) {\n\t\t\t\t/* Still looking for a place to insert ike_frag */\n\t\t\t\tif (*i == NULL ||\n\t\t\t\t    (*i)->index > ike_frag->index) {\n\t\t\t\t\tike_frag->next = *i;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t} else if ((*i)->index == ike_frag->index) {\n\t\t\t\t\t/* Replace fragment with same index */\n\t\t\t\t\tstruct v1_ike_rfrag *old = *i;\n\n\t\t\t\t\tike_frag->next = old->next;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\tpexpect(old->md != NULL);\n\t\t\t\t\trelease_any_md(&old->md);\n\t\t\t\t\tpfree(old);\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*i == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif ((*i)->last)\n\t\t\t\tlast_frag_index = (*i)->index;\n\n\t\t\ti = &(*i)->next;\n\t\t}\n\n\t\t/* We have the last fragment, reassemble if complete */\n\t\tif (last_frag_index != 0) {\n\t\t\tsize_t size = 0;\n\t\t\tint prev_index = 0;\n\n\t\t\tfor (struct v1_ike_rfrag *frag = st->st_v1_rfrags; frag; frag = frag->next) {\n\t\t\t\tsize += frag->size;\n\t\t\t\tif (frag->index != ++prev_index) {\n\t\t\t\t\tbreak; /* fragment list incomplete */\n\t\t\t\t} else if (frag->index == last_frag_index) {\n\t\t\t\t\tstruct msg_digest *whole_md = alloc_md(\"msg_digest by ikev1 fragment handler\");\n\t\t\t\t\tuint8_t *buffer = alloc_bytes(size,\n\t\t\t\t\t\t\t\t       \"IKE fragments buffer\");\n\t\t\t\t\tsize_t offset = 0;\n\n\t\t\t\t\twhole_md->iface = frag->md->iface;\n\t\t\t\t\twhole_md->sender = frag->md->sender;\n\n\t\t\t\t\t/* Reassemble fragments in buffer */\n\t\t\t\t\tfrag = st->st_v1_rfrags;\n\t\t\t\t\twhile (frag != NULL &&\n\t\t\t\t\t       frag->index <= last_frag_index)\n\t\t\t\t\t{\n\t\t\t\t\t\tpassert(offset + frag->size <=\n\t\t\t\t\t\t\tsize);\n\t\t\t\t\t\tmemcpy(buffer + offset,\n\t\t\t\t\t\t       frag->data, frag->size);\n\t\t\t\t\t\toffset += frag->size;\n\t\t\t\t\t\tfrag = frag->next;\n\t\t\t\t\t}\n\n\t\t\t\t\tinit_pbs(&whole_md->packet_pbs, buffer, size,\n\t\t\t\t\t\t \"packet\");\n\n\t\t\t\t\tprocess_packet(&whole_md);\n\t\t\t\t\trelease_any_md(&whole_md);\n\t\t\t\t\tfree_v1_message_queues(st);\n\t\t\t\t\t/* optimize: if receiving fragments, immediately respond with fragments too */\n\t\t\t\t\tst->st_seen_fragments = TRUE;\n\t\t\t\t\tdbg(\" updated IKE fragment state to respond using fragments without waiting for re-transmits\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Set smc to describe this state's properties.\n\t * Look up the appropriate microcode based on state and\n\t * possibly Oakley Auth type.\n\t */\n\tpassert(STATE_IKEv1_FLOOR <= from_state && from_state < STATE_IKEv1_ROOF);\n\tconst struct finite_state *fs = finite_states[from_state];\n\tpassert(fs != NULL);\n\tsmc = fs->v1_transitions;\n\tpassert(smc != NULL);\n\n\t/*\n\t * Find the state's the state transitions that has matching\n\t * authentication.\n\t *\n\t * For states where this makes no sense (eg, quick states\n\t * creating a CHILD_SA), .flags|=SMF_ALL_AUTH so the first\n\t * (only) one always matches.\n\t *\n\t * XXX: The code assums that when there is always a match (if\n\t * there isn't the passert() triggers.  If needed, bogus\n\t * transitions that log/drop the packet are added to the\n\t * table?  Would simply dropping the packets be easier.\n\t */\n\tif (st != NULL) {\n\t\toakley_auth_t baseauth =\n\t\t\txauth_calcbaseauth(st->st_oakley.auth);\n\n\t\twhile (!LHAS(smc->flags, baseauth)) {\n\t\t\tsmc++;\n\t\t\tpassert(smc->state == from_state);\n\t\t}\n\t}\n\n\t/*\n\t * XXX: do this earlier? */\n\tif (verbose_state_busy(st))\n\t\treturn;\n\n\t/*\n\t * Detect and handle duplicated packets.  This won't work for\n\t * the initial packet of an exchange because we won't have a\n\t * state object to remember it.  If we are in a non-receiving\n\t * state (terminal), and the preceding state did transmit,\n\t * then the duplicate may indicate that that transmission\n\t * wasn't received -- retransmit it.  Otherwise, just discard\n\t * it.  ??? Notification packets are like exchanges -- I hope\n\t * that they are idempotent!\n\t *\n\t * XXX: do this earlier?\n\t */\n\tif (st != NULL && ikev1_duplicate(st, md)) {\n\t\treturn;\n\t}\n\n\t/* save values for use in resumption of processing below.\n\t * (may be suspended due to crypto operation not yet complete)\n\t */\n\tmd->st = st;\n\tmd->v1_from_state = from_state;\n\tmd->smc = smc;\n\tmd->new_iv_set = new_iv_set;\n\n\t/*\n\t * look for encrypt packets. We cannot handle them if we have not\n\t * yet calculated the skeyids. We will just store the packet in\n\t * the suspended state, since the calculation is likely underway.\n\t *\n\t * note that this differs from above, because skeyid is calculated\n\t * in between states. (or will be, once DH is async)\n\t *\n\t */\n\tif ((md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) &&\n\t    st != NULL &&\n\t    !st->hidden_variables.st_skeyid_calculated) {\n\t\tendpoint_buf b;\n\t\tdbg(\"received encrypted packet from %s but exponentiation still in progress\",\n\t\t    str_endpoint(&md->sender, &b));\n\n\t\t/*\n\t\t * if there was a previous packet, let it go, and go\n\t\t * with most recent one.\n\t\t */\n\t\tif (st->st_suspended_md != NULL) {\n\t\t\tdbg(\"releasing suspended operation before completion: %p\",\n\t\t\t    st->st_suspended_md);\n\t\t\trelease_any_md(&st->st_suspended_md);\n\t\t}\n\t\tsuspend_any_md(st, md);\n\t\treturn;\n\t}\n\n\tprocess_packet_tail(md);\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_packet_tail(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tenum state_kind from_state = md->v1_from_state;\n\tconst struct state_v1_microcode *smc = md->smc;\n\tbool new_iv_set = md->new_iv_set;\n\tbool self_delete = FALSE;\n\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\tendpoint_buf b;\n\t\tdbg(\"received encrypted packet from %s\", str_endpoint(&md->sender, &b));\n\n\t\tif (st == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"discarding encrypted message for an unknown ISAKMP SA\");\n\t\t\treturn;\n\t\t}\n\t\tif (st->st_skeyid_e_nss == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\"discarding encrypted message because we haven't yet negotiated keying material\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Mark as encrypted */\n\t\tmd->encrypted = TRUE;\n\n\t\t/* do the specified decryption\n\t\t *\n\t\t * IV is from st->st_iv or (if new_iv_set) st->st_new_iv.\n\t\t * The new IV is placed in st->st_new_iv\n\t\t *\n\t\t * See RFC 2409 \"IKE\" Appendix B\n\t\t *\n\t\t * XXX The IV should only be updated really if the packet\n\t\t * is successfully processed.\n\t\t * We should keep this value, check for a success return\n\t\t * value from the parsing routines and then replace.\n\t\t *\n\t\t * Each post phase 1 exchange generates IVs from\n\t\t * the last phase 1 block, not the last block sent.\n\t\t */\n\t\tconst struct encrypt_desc *e = st->st_oakley.ta_encrypt;\n\n\t\tif (pbs_left(&md->message_pbs) % e->enc_blocksize != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"malformed message: not a multiple of encryption blocksize\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* XXX Detect weak keys */\n\n\t\t/* grab a copy of raw packet (for duplicate packet detection) */\n\t\tmd->raw_packet = clone_bytes_as_chunk(md->packet_pbs.start,\n\t\t\t\t\t\t      pbs_room(&md->packet_pbs),\n\t\t\t\t\t\t      \"raw packet\");\n\n\t\t/* Decrypt everything after header */\n\t\tif (!new_iv_set) {\n\t\t\tif (st->st_v1_iv.len == 0) {\n\t\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\t} else {\n\t\t\t\t/* use old IV */\n\t\t\t\trestore_new_iv(st, st->st_v1_iv);\n\t\t\t}\n\t\t}\n\n\t\tpassert(st->st_v1_new_iv.len >= e->enc_blocksize);\n\t\tst->st_v1_new_iv.len = e->enc_blocksize;   /* truncate */\n\n\t\tif (DBGP(DBG_CRYPT)) {\n\t\t\tDBG_log(\"decrypting %u bytes using algorithm %s\",\n\t\t\t\t(unsigned) pbs_left(&md->message_pbs),\n\t\t\t\tst->st_oakley.ta_encrypt->common.fqn);\n\t\t\tDBG_dump_hunk(\"IV before:\", st->st_v1_new_iv);\n\t\t}\n\t\te->encrypt_ops->do_crypt(e, md->message_pbs.cur,\n\t\t\t\t\t pbs_left(&md->message_pbs),\n\t\t\t\t\t st->st_enc_key_nss,\n\t\t\t\t\t st->st_v1_new_iv.ptr, FALSE);\n\t\tif (DBGP(DBG_CRYPT)) {\n\t\t\tDBG_dump_hunk(\"IV after:\", st->st_v1_new_iv);\n\t\t\tDBG_log(\"decrypted payload (starts at offset %td):\",\n\t\t\t\tmd->message_pbs.cur - md->message_pbs.roof);\n\t\t\tDBG_dump(NULL, md->message_pbs.start,\n\t\t\t\t md->message_pbs.roof - md->message_pbs.start);\n\t\t}\n\t} else {\n\t\t/* packet was not encryped -- should it have been? */\n\n\t\tif (smc->flags & SMF_INPUT_ENCRYPTED) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"packet rejected: should have been encrypted\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Digest the message.\n\t * Padding must be removed to make hashing work.\n\t * Padding comes from encryption (so this code must be after decryption).\n\t * Padding rules are described before the definition of\n\t * struct isakmp_hdr in packet.h.\n\t */\n\t{\n\t\tenum next_payload_types_ikev1 np = md->hdr.isa_np;\n\t\tlset_t needed = smc->req_payloads;\n\t\tconst char *excuse =\n\t\t\tLIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,\n\t\t\t    smc->flags) ?\n\t\t\t\"probable authentication failure (mismatch of preshared secrets?): \"\n\t\t\t:\n\t\t\t\"\";\n\n\t\twhile (np != ISAKMP_NEXT_NONE) {\n\t\t\tstruct_desc *sd = v1_payload_desc(np);\n\n\t\t\tif (md->digest_roof >= elemsof(md->digest)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"more than %zu payloads in message; ignored\",\n\t\t\t\t       elemsof(md->digest));\n\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstruct payload_digest *const pd = md->digest + md->digest_roof;\n\n\t\t\t/*\n\t\t\t * only do this in main mode. In aggressive mode, there\n\t\t\t * is no negotiation of NAT-T method. Get it right.\n\t\t\t */\n\t\t\tif (st != NULL && st->st_connection != NULL &&\n\t\t\t    (st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)\n\t\t\t{\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_NATD_RFC:\n\t\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t\tif ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t\t\t\t\t * unless we're using NAT-T RFC\n\t\t\t\t\t\t */\n\t\t\t\t\t\tDBG(DBG_NATT,\n\t\t\t\t\t\t    DBG_log(\"st_nat_traversal was: %s\",\n\t\t\t\t\t\t\t    bitnamesof(natt_bit_names,\n\t\t\t\t\t\t\t\t       st->hidden_variables.st_nat_traversal)));\n\t\t\t\t\t\tsd = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd == NULL) {\n\t\t\t\t/* payload type is out of range or requires special handling */\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\t\t\t/* ??? two kinds of ID payloads */\n\t\t\t\t\tsd = (IS_PHASE1(from_state) ||\n\t\t\t\t\t      IS_PHASE15(from_state)) ?\n\t\t\t\t\t\t&isakmp_identification_desc :\n\t\t\t\t\t\t&isakmp_ipsec_identification_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATD_DRAFTS: /* out of range */\n\t\t\t\t\t/*\n\t\t\t\t\t * ISAKMP_NEXT_NATD_DRAFTS was a private use type before RFC-3947.\n\t\t\t\t\t * Since it has the same format as ISAKMP_NEXT_NATD_RFC,\n\t\t\t\t\t * just rewrite np and sd, and carry on.\n\t\t\t\t\t */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATD_RFC;\n\t\t\t\t\tsd = &isakmp_nat_d_drafts;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATOA_DRAFTS: /* out of range */\n\t\t\t\t\t/* NAT-OA was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATOA_RFC;\n\t\t\t\t\tsd = &isakmp_nat_oa_drafts;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_SAK: /* or ISAKMP_NEXT_NATD_BADDRAFTS */\n\t\t\t\t\t/*\n\t\t\t\t\t * Official standards say that this is ISAKMP_NEXT_SAK,\n\t\t\t\t\t * a part of Group DOI, something we don't implement.\n\t\t\t\t\t * Old non-updated Cisco gear abused this number in ancient NAT drafts.\n\t\t\t\t\t * We ignore (rather than reject) this in support of people\n\t\t\t\t\t * with crufty Cisco machines.\n\t\t\t\t\t */\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored\",\n\t\t\t\t\t\texcuse);\n\t\t\t\t\t/*\n\t\t\t\t\t * Hack to discard payload, whatever it was.\n\t\t\t\t\t * Since we are skipping the rest of the loop\n\t\t\t\t\t * body we must do some things ourself:\n\t\t\t\t\t * - demarshall the payload\n\t\t\t\t\t * - grab the next payload number (np)\n\t\t\t\t\t * - don't keep payload (don't increment pd)\n\t\t\t\t\t * - skip rest of loop body\n\t\t\t\t\t */\n\t\t\t\t\tif (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,\n\t\t\t\t\t\t       &pd->pbs)) {\n\t\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t\t\t       excuse);\n\t\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\t\t\t/* NOTE: we do not increment pd! */\n\t\t\t\t\tcontinue;  /* skip rest of the loop */\n\n\t\t\t\tdefault:\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpassert(sd != NULL);\n\t\t\t}\n\n\t\t\tpassert(np < LELEM_ROOF);\n\n\t\t\t{\n\t\t\t\tlset_t s = LELEM(np);\n\n\t\t\t\tif (LDISJOINT(s,\n\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tst->st_state->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));\n\t\t\t\tneeded &= ~s;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Read in the payload recording what type it\n\t\t\t * should be\n\t\t\t */\n\t\t\tpd->payload_type = np;\n\t\t\tif (!in_struct(&pd->payload, sd, &md->message_pbs,\n\t\t\t\t       &pd->pbs)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t       excuse);\n\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* do payload-type specific debugging */\n\t\t\tswitch (np) {\n\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t/* dump ID section */\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_dump(\"     obj: \", pd->pbs.cur,\n\t\t\t\t\t     pbs_left(&pd->pbs)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * Place payload at the end of the chain for this type.\n\t\t\t * This code appears in ikev1.c and ikev2.c.\n\t\t\t */\n\t\t\t{\n\t\t\t\t/* np is a proper subscript for chain[] */\n\t\t\t\tpassert(np < elemsof(md->chain));\n\t\t\t\tstruct payload_digest **p = &md->chain[np];\n\n\t\t\t\twhile (*p != NULL)\n\t\t\t\t\tp = &(*p)->next;\n\t\t\t\t*p = pd;\n\t\t\t\tpd->next = NULL;\n\t\t\t}\n\n\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\tmd->digest_roof++;\n\n\t\t\t/* since we've digested one payload happily, it is probably\n\t\t\t * the case that any decryption worked.  So we will not suggest\n\t\t\t * encryption failure as an excuse for subsequent payload\n\t\t\t * problems.\n\t\t\t */\n\t\t\texcuse = \"\";\n\t\t}\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    if (pbs_left(&md->message_pbs) != 0)\n\t\t\t\t    DBG_log(\"removing %d bytes of padding\",\n\t\t\t\t\t    (int) pbs_left(&md->message_pbs));\n\t\t    });\n\n\t\tmd->message_pbs.roof = md->message_pbs.cur;\n\n\t\t/* check that all mandatory payloads appeared */\n\n\t\tif (needed != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"message for %s is missing payloads %s\",\n\t\t\t       finite_states[from_state]->name,\n\t\t\t       bitnamesof(payload_name_ikev1, needed));\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!check_v1_HASH(smc->hash_type, smc->message, st, md)) {\n\t\t/*SEND_NOTIFICATION(INVALID_HASH_INFORMATION);*/\n\t\treturn;\n\t}\n\n\t/* more sanity checking: enforce most ordering constraints */\n\n\tif (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5 Exchanges:\n\t\t * \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n\t\t */\n\t\tif (md->chain[ISAKMP_NEXT_SA] != NULL &&\n\t\t    md->hdr.isa_np != ISAKMP_NEXT_SA) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Phase 1 message: does not start with an SA payload\");\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t} else if (IS_QUICK(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode\n\t\t *\n\t\t * \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n\t\t *  header and a SA payload MUST immediately follow the HASH.\"\n\t\t * [NOTE: there may be more than one SA payload, so this is not\n\t\t *  totally reasonable.  Probably all SAs should be so constrained.]\n\t\t *\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t *\n\t\t * \"With the exception of the HASH, SA, and the optional ID payloads,\n\t\t *  there are no payload ordering restrictions on Quick Mode.\"\n\t\t */\n\n\t\tif (md->hdr.isa_np != ISAKMP_NEXT_HASH) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Quick Mode message: does not start with a HASH payload\");\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t{\n\t\t\tstruct payload_digest *p;\n\t\t\tint i;\n\n\t\t\tp = md->chain[ISAKMP_NEXT_SA];\n\t\t\ti = 1;\n\t\t\twhile (p != NULL) {\n\t\t\t\tif (p != &md->digest[i]) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"malformed Quick Mode message: SA payload is in wrong position\");\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tp = p->next;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode:\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t */\n\t\t{\n\t\t\tstruct payload_digest *id = md->chain[ISAKMP_NEXT_ID];\n\n\t\t\tif (id != NULL) {\n\t\t\t\tif (id->next == NULL ||\n\t\t\t\t    id->next->next != NULL) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"malformed Quick Mode message: if any ID payload is present, there must be exactly two\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (id + 1 != id->next) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"malformed Quick Mode message: the ID payloads are not adjacent\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Ignore payloads that we don't handle:\n\t */\n\t/* XXX Handle Notifications */\n\t{\n\t\tstruct payload_digest *p = md->chain[ISAKMP_NEXT_N];\n\n\t\twhile (p != NULL) {\n\t\t\tswitch (p->payload.notification.isan_type) {\n\t\t\tcase R_U_THERE:\n\t\t\tcase R_U_THERE_ACK:\n\t\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tcase PAYLOAD_MALFORMED:\n\t\t\tcase INVALID_MESSAGE_ID:\n\t\t\tcase IPSEC_RESPONDER_LIFETIME:\n\t\t\t\tif (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {\n\t\t\t\t\t/* these are handled later on in informational() */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tdefault:\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t       \"ignoring informational payload %s, no corresponding state\",\n\t\t\t\t\t       enum_show(& ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.notification.isan_type)));\n\t\t\t\t} else {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"ignoring informational payload %s, msgid=%08\" PRIx32 \", length=%d\",\n\t\t\t\t\t       enum_show(&ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.notification.isan_type),\n\t\t\t\t\t       st->st_v1_msgid.id,\n\t\t\t\t\t       p->payload.notification.isan_length);\n\t\t\t\t\tDBG_dump_pbs(&p->pbs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\tDBG_dump(\"info:\", p->pbs.cur,\n\t\t\t\t\t pbs_left(&p->pbs));\n\t\t\t}\n\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_D];\n\t\twhile (p != NULL) {\n\t\t\tself_delete |= accept_delete(md, p);\n\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\tDBG_dump(\"del:\", p->pbs.cur,\n\t\t\t\t\t pbs_left(&p->pbs));\n\t\t\t}\n\t\t\tif (md->st != st) {\n\t\t\t\tpexpect(md->st == NULL);\n\t\t\t\tdbg(\"zapping ST as accept_delete() zapped MD.ST\");\n\t\t\t\tst = md->st;\n\t\t\t}\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_VID];\n\t\twhile (p != NULL) {\n\t\t\thandle_vendorid(md, (char *)p->pbs.cur,\n\t\t\t\t\tpbs_left(&p->pbs), FALSE);\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (self_delete) {\n\t\taccept_self_delete(md);\n\t\tst = md->st;\n\t\t/* note: st ought to be NULL from here on */\n\t}\n\n\tpexpect(st == md->st);\n\tstatetime_t start = statetime_start(md->st);\n\t/*\n\t * XXX: danger - the .informational() processor deletes ST;\n\t * and then tunnels this loss through MD.ST.\n\t */\n\tcomplete_v1_state_transition(md, smc->processor(st, md));\n\tstatetime_stop(&start, \"%s()\", __func__);\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * replace previous receive packet with latest, to update\n * our notion of a retransmitted packet. This is important\n * to do, even for failing transitions, and suspended transitions\n * because the sender may well retransmit their request.\n * We had better be idempotent since we can be called\n * multiple times in handling a packet due to crypto helper logic.\n */\nstatic void remember_received_packet(struct state *st, struct msg_digest *md)\n{\n\tif (md->encrypted) {\n\t\t/* if encrypted, duplication already done */\n\t\tif (md->raw_packet.ptr != NULL) {\n\t\t\tpfreeany(st->st_v1_rpacket.ptr);\n\t\t\tst->st_v1_rpacket = md->raw_packet;\n\t\t\tmd->raw_packet = EMPTY_CHUNK;\n\t\t}\n\t} else {\n\t\t/* this may be a repeat, but it will work */\n\t\tfree_chunk_content(&st->st_v1_rpacket);\n\t\tst->st_v1_rpacket = clone_bytes_as_chunk(md->packet_pbs.start,\n\t\t\t\t\t\t      pbs_room(&md->packet_pbs),\n\t\t\t\t\t\t      \"raw packet\");\n\t}\n}\n\n/* complete job started by the state-specific state transition function\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n *\n * md is used to:\n * - find st\n * - find from_state (st might be gone)\n * - find note for STF_FAIL (might not be part of result (STF_FAIL+note))\n * - find note for STF_INTERNAL_ERROR\n * - record md->event_already_set\n * - remember_received_packet(st, md);\n * - nat_traversal_change_port_lookup(md, st);\n * - smc for smc->next_state\n * - smc for smc->flags & SMF_REPLY to trigger a reply\n * - smc for smc->timeout_event\n * - smc for !(smc->flags & SMF_INITIATOR) for Contivity mode\n * - smc for smc->flags & SMF_RELEASE_PENDING_P2 to trigger unpend call\n * - smc for smc->flags & SMF_INITIATOR to adjust retransmission\n * - fragvid, dpd, nortel\n */\nvoid complete_v1_state_transition(struct msg_digest *md, stf_status result)\n{\n\tpassert(md != NULL);\n\n\t/* handle oddball/meta results now */\n\n\t/*\n\t * statistics; lump all FAILs together\n\t *\n\t * Fun fact: using min() stupidly fails (at least in GCC 8.1.1 with -Werror=sign-compare)\n\t * error: comparison of integer expressions of different signedness: `stf_status' {aka `enum <anonymous>'} and `int'\n\t */\n\tpstats(ike_stf, PMIN(result, STF_FAIL));\n\n\tDBG(DBG_CONTROL,\n\t    DBG_log(\"complete v1 state transition with %s\",\n\t\t    result > STF_FAIL ?\n\t\t    enum_name(&ikev1_notify_names, result - STF_FAIL) :\n\t\t    enum_name(&stf_status_names, result)));\n\n\tswitch (result) {\n\tcase STF_SUSPEND:\n\t\tset_cur_state(md->st);\t/* might have changed */\n\t\t/*\n\t\t * If this transition was triggered by an incoming\n\t\t * packet, save it.\n\t\t *\n\t\t * XXX: some initiator code creates a fake MD (there\n\t\t * isn't a real one); save that as well.\n\t\t */\n\t\tsuspend_any_md(md->st, md);\n\t\treturn;\n\tcase STF_IGNORE:\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* safe to refer to *md */\n\n\tenum state_kind from_state = md->v1_from_state;\n\n\tstruct state *st = md->st;\n\tset_cur_state(st); /* might have changed */\n\n\tpassert(st != NULL);\n\tpexpect(!state_is_busy(st));\n\n\tif (result > STF_OK) {\n\t\tlinux_audit_conn(md->st, IS_IKE_SA_ESTABLISHED(md->st) ? LAK_CHILD_FAIL : LAK_PARENT_FAIL);\n\t}\n\n\tswitch (result) {\n\tcase STF_OK:\n\t{\n\t\t/* advance the state */\n\t\tconst struct state_v1_microcode *smc = md->smc;\n\n\t\tDBG(DBG_CONTROL, DBG_log(\"doing_xauth:%s, t_xauth_client_done:%s\",\n\t\t\tbool_str(st->st_oakley.doing_xauth),\n\t\t\tbool_str(st->hidden_variables.st_xauth_client_done)));\n\n\t\t/* accept info from VID because we accept this message */\n\n\t\t/*\n\t\t * Most of below VIDs only appear Main/Aggr mode, not Quick mode,\n\t\t * so why are we checking them for each state transition?\n\t\t */\n\n\t\tif (md->fragvid) {\n\t\t\tdbg(\"peer supports fragmentation\");\n\t\t\tst->st_seen_fragvid = TRUE;\n\t\t}\n\n\t\tif (md->dpd) {\n\t\t\tdbg(\"peer supports DPD\");\n\t\t\tst->hidden_variables.st_peer_supports_dpd = TRUE;\n\t\t\tif (dpd_active_locally(st)) {\n\t\t\t\tdbg(\"DPD is configured locally\");\n\t\t\t}\n\t\t}\n\n\t\t/* If state has VID_NORTEL, import it to activate workaround */\n\t\tif (md->nortel) {\n\t\t\tdbg(\"peer requires Nortel Contivity workaround\");\n\t\t\tst->st_seen_nortel_vid = TRUE;\n\t\t}\n\n\t\tif (!st->st_v1_msgid.reserved &&\n\t\t    IS_CHILD_SA(st) &&\n\t\t    st->st_v1_msgid.id != v1_MAINMODE_MSGID) {\n\t\t\tstruct state *p1st = state_with_serialno(\n\t\t\t\tst->st_clonedfrom);\n\n\t\t\tif (p1st != NULL) {\n\t\t\t\t/* do message ID reservation */\n\t\t\t\treserve_msgid(p1st, st->st_v1_msgid.id);\n\t\t\t}\n\n\t\t\tst->st_v1_msgid.reserved = TRUE;\n\t\t}\n\n\t\tdbg(\"IKEv1: transition from state %s to state %s\",\n\t\t    finite_states[from_state]->name,\n\t\t    finite_states[smc->next_state]->name);\n\n\t\tchange_state(st, smc->next_state);\n\n\t\t/*\n\t\t * XAUTH negotiation without ModeCFG cannot follow the regular\n\t\t * state machine change as it cannot be determined if the CFG\n\t\t * payload is \"XAUTH OK, no ModeCFG\" or \"XAUTH OK, expect\n\t\t * ModeCFG\". To the smc, these two cases look identical. So we\n\t\t * have an ad hoc state change here for the case where\n\t\t * we have XAUTH but not ModeCFG. We move it to the established\n\t\t * state, so the regular state machine picks up the Quick Mode.\n\t\t */\n\t\tif (st->st_connection->spd.this.xauth_client &&\n\t\t    st->hidden_variables.st_xauth_client_done &&\n\t\t    !st->st_connection->spd.this.modecfg_client &&\n\t\t    st->st_state->kind == STATE_XAUTH_I1)\n\t\t{\n\t\t\tbool aggrmode = LHAS(st->st_connection->policy, POLICY_AGGRESSIVE_IX);\n\n\t\t\tlibreswan_log(\"XAUTH completed; ModeCFG skipped as per configuration\");\n\t\t\tchange_state(st, aggrmode ? STATE_AGGR_I2 : STATE_MAIN_I4);\n\t\t\tst->st_v1_msgid.phase15 = v1_MAINMODE_MSGID;\n\t\t}\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\t/*\n\t\t\t * This md variable is hardly ever set.\n\t\t\t * Only deals with v1 <-> v2 switching\n\t\t\t * which will be removed in the near future anyway\n\t\t\t * (PW 2017 Oct 8)\n\t\t\t */\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"event_already_set, deleting event\"));\n\t\t\t/*\n\t\t\t * Delete previous retransmission event.\n\t\t\t * New event will be scheduled below.\n\t\t\t */\n\t\t\tdelete_event(st);\n\t\t\tclear_retransmits(st);\n\t\t}\n\n\t\t/* Delete IKE fragments */\n\t\tfree_v1_message_queues(st);\n\n\t\t/* scrub the previous packet exchange */\n\t\tfree_chunk_content(&st->st_v1_rpacket);\n\t\tfree_chunk_content(&st->st_v1_tpacket);\n\n\t\t/* in aggressive mode, there will be no reply packet in transition\n\t\t * from STATE_AGGR_R1 to STATE_AGGR_R2\n\t\t */\n\t\tif (nat_traversal_enabled && st->st_connection->ikev1_natt != NATT_NONE) {\n\t\t\t/* adjust our destination port if necessary */\n\t\t\tnat_traversal_change_port_lookup(md, st);\n\t\t\tv1_maybe_natify_initiator_endpoints(st, HERE);\n\t\t}\n\n\t\t/*\n\t\t * Save both the received packet, and this\n\t\t * state-transition.\n\t\t *\n\t\t * Only when the (last) state transition was a \"reply\"\n\t\t * should a duplicate packet trigger a retransmit\n\t\t * (else they get discarded).\n\t\t *\n\t\t * XXX: .st_state .fs_flags & SMF_REPLY can't\n\t\t * be used because it contains flags for the new state\n\t\t * not the old-to-new state transition.\n\t\t */\n\t\tremember_received_packet(st, md);\n\t\tst->st_v1_last_transition = md->smc;\n\n\t\t/* if requested, send the new reply packet */\n\t\tif (smc->flags & SMF_REPLY) {\n\t\t\tendpoint_buf b;\n\t\t\tendpoint_buf b2;\n\t\t\tpexpect_st_local_endpoint(st);\n\t\t\tdbg(\"sending reply packet to %s (from %s)\",\n\t\t\t    str_endpoint(&st->st_remote_endpoint, &b),\n\t\t\t    str_endpoint(&st->st_interface->local_endpoint, &b2));\n\n\t\t\tclose_output_pbs(&reply_stream); /* good form, but actually a no-op */\n\n\t\t\tif (st->st_state->kind == STATE_MAIN_R2 &&\n\t\t\t\timpair.send_no_main_r2) {\n\t\t\t\t/* record-only so we propely emulate packet drop */\n\t\t\t\trecord_outbound_v1_ike_msg(st, &reply_stream,\n\t\t\t\t\t\t\t   finite_states[from_state]->name);\n\t\t\t\tlibreswan_log(\"IMPAIR: Skipped sending STATE_MAIN_R2 response packet\");\n\t\t\t} else {\n\t\t\t\trecord_and_send_v1_ike_msg(st, &reply_stream,\n\t\t\t\t\t\t\t   finite_states[from_state]->name);\n\t\t\t}\n\t\t}\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"!event_already_set at reschedule\"));\n\t\t\tintmax_t delay_ms; /* delay is in milliseconds here */\n\t\t\tenum event_type kind = smc->timeout_event;\n\t\t\tbool agreed_time = FALSE;\n\t\t\tstruct connection *c = st->st_connection;\n\n\t\t\t/* fixup in case of state machine jump for xauth without modecfg */\n\t\t\tif (c->spd.this.xauth_client &&\n\t\t\t    st->hidden_variables.st_xauth_client_done &&\n\t\t\t    !c->spd.this.modecfg_client &&\n\t\t\t    (st->st_state->kind == STATE_MAIN_I4 || st->st_state->kind == STATE_AGGR_I2))\n\t\t\t{\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\"fixup XAUTH without ModeCFG event from EVENT_RETRANSMIT to EVENT_SA_REPLACE\"));\n\t\t\t\tkind = EVENT_SA_REPLACE;\n\t\t\t}\n\n\t\t\tswitch (kind) {\n\t\t\tcase EVENT_RETRANSMIT: /* Retransmit packet */\n\t\t\t\tstart_retransmits(st);\n\t\t\t\tbreak;\n\n\t\t\tcase EVENT_SA_REPLACE: /* SA replacement event */\n\t\t\t\tif (IS_PHASE1(st->st_state->kind) ||\n\t\t\t\t    IS_PHASE15(st->st_state->kind)) {\n\t\t\t\t\t/* Note: we will defer to the \"negotiated\" (dictated)\n\t\t\t\t\t * lifetime if we are POLICY_DONT_REKEY.\n\t\t\t\t\t * This allows the other side to dictate\n\t\t\t\t\t * a time we would not otherwise accept\n\t\t\t\t\t * but it prevents us from having to initiate\n\t\t\t\t\t * rekeying.  The negative consequences seem\n\t\t\t\t\t * minor.\n\t\t\t\t\t */\n\t\t\t\t\tdelay_ms = deltamillisecs(c->sa_ike_life_seconds);\n\t\t\t\t\tif ((c->policy & POLICY_DONT_REKEY) ||\n\t\t\t\t\t    delay_ms >= deltamillisecs(st->st_oakley.life_seconds))\n\t\t\t\t\t{\n\t\t\t\t\t\tagreed_time = TRUE;\n\t\t\t\t\t\tdelay_ms = deltamillisecs(st->st_oakley.life_seconds);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Delay is min of up to four things:\n\t\t\t\t\t * each can limit the lifetime.\n\t\t\t\t\t */\n\t\t\t\t\ttime_t delay = deltasecs(c->sa_ipsec_life_seconds);\n\n#define clamp_delay(trans) { \\\n\t\tif (st->trans.present && \\\n\t\t    delay >= deltasecs(st->trans.attrs.life_seconds)) { \\\n\t\t\tagreed_time = TRUE; \\\n\t\t\tdelay = deltasecs(st->trans.attrs.life_seconds); \\\n\t\t} \\\n\t}\n\t\t\t\t\tclamp_delay(st_ah);\n\t\t\t\t\tclamp_delay(st_esp);\n\t\t\t\t\tclamp_delay(st_ipcomp);\n\t\t\t\t\tdelay_ms = delay * 1000;\n#undef clamp_delay\n\t\t\t\t}\n\n\t\t\t\t/* By default, we plan to rekey.\n\t\t\t\t *\n\t\t\t\t * If there isn't enough time to rekey, plan to\n\t\t\t\t * expire.\n\t\t\t\t *\n\t\t\t\t * If we are --dontrekey, a lot more rules apply.\n\t\t\t\t * If we are the Initiator, use REPLACE_IF_USED.\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * was unacceptable (too large), plan to REPLACE\n\t\t\t\t * (the only way to ratchet down the time).\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * is acceptable, plan to EXPIRE.\n\t\t\t\t *\n\t\t\t\t * Important policy lies buried here.\n\t\t\t\t * For example, we favour the initiator over the\n\t\t\t\t * responder by making the initiator start rekeying\n\t\t\t\t * sooner.  Also, fuzz is only added to the\n\t\t\t\t * initiator's margin.\n\t\t\t\t *\n\t\t\t\t * Note: for ISAKMP SA, we let the negotiated\n\t\t\t\t * time stand (implemented by earlier logic).\n\t\t\t\t */\n\t\t\t\tif (agreed_time &&\n\t\t\t\t    (c->policy & POLICY_DONT_REKEY)) {\n\t\t\t\t\tkind = (smc->flags & SMF_INITIATOR) ?\n\t\t\t\t\t       EVENT_v1_SA_REPLACE_IF_USED :\n\t\t\t\t\t       EVENT_SA_EXPIRE;\n\t\t\t\t}\n\t\t\t\tif (kind != EVENT_SA_EXPIRE) {\n\t\t\t\t\ttime_t marg =\n\t\t\t\t\t\tdeltasecs(c->sa_rekey_margin);\n\n\t\t\t\t\tif (smc->flags & SMF_INITIATOR) {\n\t\t\t\t\t\tmarg += marg *\n\t\t\t\t\t\t\tc->sa_rekey_fuzz /\n\t\t\t\t\t\t\t100.E0 *\n\t\t\t\t\t\t\t(rand() /\n\t\t\t\t\t\t\t (RAND_MAX + 1.E0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarg /= 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (delay_ms > marg * 1000) {\n\t\t\t\t\t\tdelay_ms -= marg * 1000;\n\t\t\t\t\t\tst->st_replace_margin = deltatime(marg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkind = EVENT_SA_EXPIRE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* XXX: DELAY_MS should be a deltatime_t */\n\t\t\t\tevent_schedule(kind, deltatime_ms(delay_ms), st);\n\t\t\t\tbreak;\n\n\t\t\tcase EVENT_SO_DISCARD:\n\t\t\t\tevent_schedule(EVENT_SO_DISCARD, c->r_timeout, st);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbad_case(kind);\n\t\t\t}\n\t\t}\n\n\t\t/* tell whack and log of progress */\n\t\t{\n\t\t\tenum rc_type w;\n\t\t\tvoid (*log_details)(struct lswlog *buf, struct state *st);\n\n\t\t\tif (IS_IPSEC_SA_ESTABLISHED(st)) {\n\t\t\t\tpstat_sa_established(st);\n\t\t\t\tlog_details = lswlog_child_sa_established;\n\t\t\t\tw = RC_SUCCESS; /* log our success */\n\t\t\t} else if (IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tpstat_sa_established(st);\n\t\t\t\tlog_details = lswlog_ike_sa_established;\n\t\t\t\tw = RC_SUCCESS; /* log our success */\n\t\t\t} else {\n\t\t\t\tlog_details = NULL;\n\t\t\t\tw = RC_NEW_V1_STATE + st->st_state->kind;\n\t\t\t}\n\n\t\t\tpassert(st->st_state->kind < STATE_IKEv1_ROOF);\n\n\t\t\t/* tell whack and logs our progress */\n\t\t\tLSWLOG_RC(w, buf) {\n\t\t\t\tlswlogf(buf, \"%s: %s\", st->st_state->name,\n\t\t\t\t\tst->st_state->story);\n\t\t\t\t/* document SA details for admin's pleasure */\n\t\t\t\tif (log_details != NULL) {\n\t\t\t\t\tlog_details(buf, st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * make sure that a DPD event gets created for a new phase 1\n\t\t * SA.\n\t\t * Why do we need a DPD event on an IKE SA???\n\t\t */\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\tif (dpd_init(st) != STF_OK) {\n\t\t\t\tloglog(RC_LOG_SERIOUS, \"DPD initialization failed - continuing without DPD\");\n\t\t\t}\n\t\t}\n\n\t\t/* Special case for XAUTH server */\n\t\tif (st->st_connection->spd.this.xauth_server) {\n\t\t\tif (st->st_oakley.doing_xauth &&\n\t\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tDBG(DBG_CONTROLMORE|DBG_XAUTH,\n\t\t\t\t    DBG_log(\"XAUTH: Sending XAUTH Login/Password Request\"));\n\t\t\t\tevent_schedule(EVENT_v1_SEND_XAUTH,\n\t\t\t\t\t       deltatime_ms(EVENT_v1_SEND_XAUTH_DELAY_MS),\n\t\t\t\t\t       st);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * for XAUTH client, we are also done, because we need to\n\t\t * stay in this state, and let the server query us\n\t\t */\n\t\tif (!IS_QUICK(st->st_state->kind) &&\n\t\t    st->st_connection->spd.this.xauth_client &&\n\t\t    !st->hidden_variables.st_xauth_client_done) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"XAUTH client is not yet authenticated\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * when talking to some vendors, we need to initiate a mode\n\t\t * cfg request to get challenged, but there is also an\n\t\t * override in the form of a policy bit.\n\t\t */\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"modecfg pull: %s policy:%s %s\",\n\t\t\t    (st->quirks.modecfg_pull_mode ?\n\t\t\t     \"quirk-poll\" : \"noquirk\"),\n\t\t\t    (st->st_connection->policy & POLICY_MODECFG_PULL) ?\n\t\t\t    \"pull\" : \"push\",\n\t\t\t    (st->st_connection->spd.this.modecfg_client ?\n\t\t\t     \"modecfg-client\" : \"not-client\")));\n\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    (st->quirks.modecfg_pull_mode ||\n\t\t     st->st_connection->policy & POLICY_MODECFG_PULL) &&\n\t\t    !st->hidden_variables.st_modecfg_started) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"modecfg client is starting due to %s\",\n\t\t\t\t    st->quirks.modecfg_pull_mode ? \"quirk\" :\n\t\t\t\t    \"policy\"));\n\t\t\tmodecfg_send_request(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Should we set the peer's IP address regardless? */\n\t\tif (st->st_connection->spd.this.modecfg_server &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set &&\n\t\t    !(st->st_connection->policy & POLICY_MODECFG_PULL)) {\n\t\t\tchange_state(st, STATE_MODE_CFG_R1);\n\t\t\tset_cur_state(st);\n\t\t\tlibreswan_log(\"Sending MODE CONFIG set\");\n\t\t\t/*\n\t\t\t * ??? we ignore the result of modecfg.\n\t\t\t * But surely, if it fails, we ought to terminate this exchange.\n\t\t\t * What do the RFCs say?\n\t\t\t */\n\t\t\tmodecfg_start_set(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we are the responder and the client is in \"Contivity mode\",\n\t\t * we need to initiate Quick mode\n\t\t */\n\t\tif (!(smc->flags & SMF_INITIATOR) &&\n\t\t    IS_MODE_CFG_ESTABLISHED(st->st_state) &&\n\t\t    (st->st_seen_nortel_vid)) {\n\t\t\tlibreswan_log(\"Nortel 'Contivity Mode' detected, starting Quick Mode\");\n\t\t\tchange_state(st, STATE_MAIN_R3); /* ISAKMP is up... */\n\t\t\tset_cur_state(st);\n\t\t\tquick_outI1(st->st_whack_sock, st, st->st_connection,\n\t\t\t\t    st->st_connection->policy, 1, SOS_NOBODY,\n\t\t\t\t    NULL /* Setting NULL as this is responder and will not have sec ctx from a flow*/\n\t\t\t\t    );\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wait for modecfg_set */\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"waiting for modecfg set from server\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"phase 1 is done, looking for phase 2 to unpend\"));\n\n\t\tif (smc->flags & SMF_RELEASE_PENDING_P2) {\n\t\t\t/* Initiate any Quick Mode negotiations that\n\t\t\t * were waiting to piggyback on this Keying Channel.\n\t\t\t *\n\t\t\t * ??? there is a potential race condition\n\t\t\t * if we are the responder: the initial Phase 2\n\t\t\t * message might outrun the final Phase 1 message.\n\t\t\t *\n\t\t\t * so, instead of actually sending the traffic now,\n\t\t\t * we schedule an event to do so.\n\t\t\t *\n\t\t\t * but, in fact, quick_mode will enqueue a cryptographic operation\n\t\t\t * anyway, which will get done \"later\" anyway, so maybe it is just fine\n\t\t\t * as it is.\n\t\t\t *\n\t\t\t */\n\t\t\tunpend(pexpect_ike_sa(st), NULL);\n\t\t}\n\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||\n\t\t    IS_IPSEC_SA_ESTABLISHED(st))\n\t\t\trelease_any_whack(st, HERE, \"IKEv1 transitions finished\");\n\n\t\tif (IS_QUICK(st->st_state->kind))\n\t\t\tbreak;\n\n\t\tbreak;\n\t}\n\n\tcase STF_INTERNAL_ERROR:\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\t\tlog_state(RC_INTERNALERR + md->v1_note, st,\n\t\t\t  \"state transition function for %s had internal error\",\n\t\t\t  st->st_state->name);\n\t\trelease_pending_whacks(st, \"internal error\");\n\t\tbreak;\n\n\tcase STF_FATAL:\n\t\tpassert(st != NULL);\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\t\tlog_state(RC_FATAL, st, \"encountered fatal error in state %s\",\n\t\t\t  st->st_state->name);\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\trelease_pending_whacks(st, \"fatal error\");\n\t\tdelete_state(st);\n\t\tmd->st = st = NULL;\n\t\tbreak;\n\n\tdefault:        /* a shortcut to STF_FAIL, setting md->note */\n\t\tpassert(result > STF_FAIL);\n\t\tmd->v1_note = result - STF_FAIL;\n\t\t/* FALL THROUGH */\n\tcase STF_FAIL:\n\t{\n\t\t/* As it is, we act as if this message never happened:\n\t\t * whatever retrying was in place, remains in place.\n\t\t */\n\t\t/*\n\t\t * Try to convert the notification into a non-NULL\n\t\t * string.  For NOTHING_WRONG, be vague (at the time\n\t\t * of writing the enum_names didn't contain\n\t\t * NOTHING_WRONG, and even if it did \"nothing wrong\"\n\t\t * wouldn't exactly help here :-).\n\t\t */\n\t\tconst char *notify_name = (md->v1_note == NOTHING_WRONG ? \"failed\" :\n\t\t\t\t\t   enum_name(&ikev1_notify_names, md->v1_note));\n\t\tif (notify_name == NULL) {\n\t\t\tnotify_name = \"internal error\";\n\t\t}\n\t\t/*\n\t\t * ??? why no call of remember_received_packet?\n\t\t * Perhaps because the message hasn't been authenticated?\n\t\t * But then then any duplicate would lose too, I would think.\n\t\t */\n\n\t\tif (md->v1_note != NOTHING_WRONG) {\n\t\t\t/* this will log */\n\t\t\tSEND_NOTIFICATION(md->v1_note);\n\t\t} else {\n\t\t\t/* XXX: why whack only? */\n\t\t\tlog_state(WHACK_STREAM | (RC_NOTIFICATION + md->v1_note), st,\n\t\t\t\t  \"state transition failed: %s\", notify_name);\n\t\t}\n\n\t\tdbg(\"state transition function for %s failed: %s\",\n\t\t    st->st_state->name, notify_name);\n\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\tif (IS_QUICK(st->st_state->kind)) {\n\t\t\tdelete_state(st);\n\t\t\t/* wipe out dangling pointer to st */\n\t\t\tmd->st = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n}\n\n/*\n * note: may change which connection is referenced by md->st->st_connection.\n * But only if we are a Main Mode Responder.\n */\nbool ikev1_decode_peer_id(struct msg_digest *md, bool initiator, bool aggrmode)\n{\n\tstruct state *const st = md->st;\n\tstruct connection *c = st->st_connection;\n\tconst struct payload_digest *const id_pld = md->chain[ISAKMP_NEXT_ID];\n\tconst struct isakmp_id *const id = &id_pld->payload.id;\n\n\t/*\n\t * I think that RFC2407 (IPSEC DOI) 4.6.2 is confused.\n\t * It talks about the protocol ID and Port fields of the ID\n\t * Payload, but they don't exist as such in Phase 1.\n\t * We use more appropriate names.\n\t * isaid_doi_specific_a is in place of Protocol ID.\n\t * isaid_doi_specific_b is in place of Port.\n\t * Besides, there is no good reason for allowing these to be\n\t * other than 0 in Phase 1.\n\t */\n\tif (st->hidden_variables.st_nat_traversal != LEMPTY &&\n\t    id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t    (id->isaid_doi_specific_b == 0 ||\n\t     id->isaid_doi_specific_b == pluto_nat_port)) {\n\t\tDBG_log(\"protocol/port in Phase 1 ID Payload is %d/%d. accepted with port_floating NAT-T\",\n\t\t\tid->isaid_doi_specific_a, id->isaid_doi_specific_b);\n\t} else if (!(id->isaid_doi_specific_a == 0 &&\n\t\t     id->isaid_doi_specific_b == 0) &&\n\t\t   !(id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t\t     id->isaid_doi_specific_b == pluto_port))\n\t{\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\"protocol/port in Phase 1 ID Payload MUST be 0/0 or %d/%d but are %d/%d (attempting to continue)\",\n\t\t\tIPPROTO_UDP, pluto_port,\n\t\t\tid->isaid_doi_specific_a,\n\t\t\tid->isaid_doi_specific_b);\n\t\t/*\n\t\t * We have turned this into a warning because of bugs in other\n\t\t * vendors' products. Specifically CISCO VPN3000.\n\t\t */\n\t\t/* return FALSE; */\n\t}\n\n\tstruct id peer;\n\n\tif (!extract_peer_id(id->isaid_idtype, &peer, &id_pld->pbs))\n\t\treturn FALSE;\n\n\tif (c->spd.that.id.kind == ID_FROMCERT) {\n\t\t/* breaks API, connection modified by %fromcert */\n\t\tduplicate_id(&c->spd.that.id, &peer);\n\t}\n\n\t/*\n\t * For interop with SoftRemote/aggressive mode we need to remember some\n\t * things for checking the hash\n\t */\n\tst->st_peeridentity_protocol = id->isaid_doi_specific_a;\n\tst->st_peeridentity_port = ntohs(id->isaid_doi_specific_b);\n\n\t{\n\t\tid_buf buf;\n\n\t\tlibreswan_log(\"Peer ID is %s: '%s'\",\n\t\t\tenum_show(&ike_idtype_names, id->isaid_idtype),\n\t\t\tstr_id(&peer, &buf));\n\t}\n\n\t/* check for certificates */\n\tif (!v1_verify_certs(md)) {\n\t\tlibreswan_log(\"X509: CERT payload does not match connection ID\");\n\t\tif (initiator || aggrmode) {\n\t\t\t/* cannot switch connection so fail */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* check for certificate requests */\n\tikev1_decode_cr(md);\n\n\t/*\n\t * Now that we've decoded the ID payload, let's see if we\n\t * need to switch connections.\n\t * Aggressive mode cannot switch connections.\n\t * We must not switch horses if we initiated:\n\t * - if the initiation was explicit, we'd be ignoring user's intent\n\t * - if opportunistic, we'll lose our HOLD info\n\t */\n\n\tif (initiator) {\n\t\tif (!st->st_peer_alt_id &&\n\t\t    !same_id(&c->spd.that.id, &peer) &&\n\t\t    c->spd.that.id.kind != ID_FROMCERT) {\n\t\t\tid_buf expect;\n\t\t\tid_buf found;\n\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"we require IKEv1 peer to have ID '%s', but peer declares '%s'\",\n\t\t\t       str_id(&c->spd.that.id, &expect),\n\t\t\t       str_id(&peer, &found));\n\t\t\treturn FALSE;\n\t\t} else if (c->spd.that.id.kind == ID_FROMCERT) {\n\t\t\tif (peer.kind != ID_DER_ASN1_DN) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"peer ID is not a certificate type\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tduplicate_id(&c->spd.that.id, &peer);\n\t\t}\n\t} else if (!aggrmode) {\n\t\t/* Main Mode Responder */\n\t\tuint16_t auth = xauth_calcbaseauth(st->st_oakley.auth);\n\t\tlset_t auth_policy;\n\n\t\tswitch (auth) {\n\t\tcase OAKLEY_PRESHARED_KEY:\n\t\t\tauth_policy = POLICY_PSK;\n\t\t\tbreak;\n\t\tcase OAKLEY_RSA_SIG:\n\t\t\tauth_policy = POLICY_RSASIG;\n\t\t\tbreak;\n\t\t/* Not implemented */\n\t\tcase OAKLEY_DSS_SIG:\n\t\tcase OAKLEY_RSA_ENC:\n\t\tcase OAKLEY_RSA_REVISED_MODE:\n\t\tcase OAKLEY_ECDSA_P256:\n\t\tcase OAKLEY_ECDSA_P384:\n\t\tcase OAKLEY_ECDSA_P521:\n\t\tdefault:\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"ikev1 ike_decode_peer_id bad_case due to not supported policy\"));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tbool fromcert;\n\t\tstruct connection *r =\n\t\t\trefine_host_connection(st, &peer,\n\t\t\t\tNULL, /* IKEv1 does not support 'you Tarzan, me Jane' */\n\t\t\t\tFALSE,\t/* we are responder */\n\t\t\t\tauth_policy,\n\t\t\t\tAUTHBY_UNSET,\t/* ikev2 only */\n\t\t\t\t&fromcert);\n\n\t\tif (r == NULL) {\n\t\t\tDBG(DBG_CONTROL, {\n\t\t\t\tid_buf buf;\n\n\t\t\t\tDBG_log(\"no more suitable connection for peer '%s'\",\n\t\t\t\t\tstr_id(&peer, &buf));\n\t\t\t});\n\t\t\t/* can we continue with what we had? */\n\t\t\tif (!md->st->st_peer_alt_id &&\n\t\t\t    !same_id(&c->spd.that.id, &peer) &&\n\t\t\t    c->spd.that.id.kind != ID_FROMCERT) {\n\t\t\t\t\tlibreswan_log(\"Peer mismatch on first found connection and no better connection found\");\n\t\t\t\t\treturn FALSE;\n\t\t\t} else {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\"Peer ID matches and no better connection found - continuing with existing connection\"));\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\n\t\tif (DBGP(DBG_BASE)) {\n\t\t\tdn_buf buf;\n\t\t\tDBG_log(\"offered CA: '%s'\",\n\t\t\t\tstr_dn_or_null(r->spd.this.ca, \"%none\", &buf));\n\t\t}\n\n\t\tif (r != c) {\n\t\t\t/*\n\t\t\t * We are changing st->st_connection!\n\t\t\t * Our caller might be surprised!\n\t\t\t */\n\t\t\tchar b1[CONN_INST_BUF];\n\t\t\tchar b2[CONN_INST_BUF];\n\n\t\t\t/* apparently, r is an improvement on c -- replace */\n\t\t\tlibreswan_log(\"switched from \\\"%s\\\"%s to \\\"%s\\\"%s\",\n\t\t\t\tc->name,\n\t\t\t\tfmt_conn_instance(c, b1),\n\t\t\t\tr->name,\n\t\t\t\tfmt_conn_instance(r, b2));\n\n\t\t\tif (r->kind == CK_TEMPLATE || r->kind == CK_GROUP) {\n\t\t\t\t/* instantiate it, filling in peer's ID */\n\t\t\t\tr = rw_instantiate(r, &c->spd.that.host_addr,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   &peer);\n\t\t\t}\n\n\t\t\tupdate_state_connection(st, r);\n\t\t\tc = r;\t/* c not subsequently used */\n\t\t\t/* redo from scratch so we read and check CERT payload */\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"retrying ike_decode_peer_id() with new conn\"));\n\t\t\tpassert(!initiator && !aggrmode);\n\t\t\treturn ikev1_decode_peer_id(md, FALSE, FALSE);\n\t\t} else if (c->spd.that.has_id_wildcards) {\n\t\t\tduplicate_id(&c->spd.that.id, &peer);\n\t\t\tc->spd.that.has_id_wildcards = FALSE;\n\t\t} else if (fromcert) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"copying ID for fromcert\"));\n\t\t\tduplicate_id(&c->spd.that.id, &peer);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nbool ikev1_ship_chain(chunk_t *chain, int n, pb_stream *outs,\n\t\t      uint8_t type)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ikev1_ship_CERT(type, chain[i], outs))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid doi_log_cert_thinking(uint16_t auth,\n\t\t\t\tenum ike_cert_type certtype,\n\t\t\t\tenum certpolicy policy,\n\t\t\t\tbool gotcertrequest,\n\t\t\t\tbool send_cert,\n\t\t\t\tbool send_chain)\n{\n\tDBG(DBG_CONTROL, {\n\t\tDBG_log(\"thinking about whether to send my certificate:\");\n\n\t\tstruct esb_buf oan;\n\t\tstruct esb_buf ictn;\n\n\t\tDBG_log(\"  I have RSA key: %s cert.type: %s \",\n\t\t\tenum_showb(&oakley_auth_names, auth, &oan),\n\t\t\tenum_showb(&ike_cert_type_names, certtype, &ictn));\n\n\t\tstruct esb_buf cptn;\n\n\t\tDBG_log(\"  sendcert: %s and I did%s get a certificate request \",\n\t\t\tenum_showb(&certpolicy_type_names, policy, &cptn),\n\t\t\tgotcertrequest ? \"\" : \" not\");\n\n\t\tDBG_log(\"  so %ssend cert.\", send_cert ? \"\" : \"do not \");\n\n\t\tif (!send_cert) {\n\t\t\tif (auth == OAKLEY_PRESHARED_KEY) {\n\t\t\t\tDBG_log(\"I did not send a certificate because digital signatures are not being used. (PSK)\");\n\t\t\t} else if (certtype == CERT_NONE) {\n\t\t\t\tDBG_log(\"I did not send a certificate because I do not have one.\");\n\t\t\t} else if (policy == CERT_SENDIFASKED) {\n\t\t\t\tDBG_log(\"I did not send my certificate because I was not asked to.\");\n\t\t\t} else {\n\t\t\t\tDBG_log(\"INVALID AUTH SETTING: %d\", auth);\n\t\t\t}\n\t\t}\n\t\tif (send_chain)\n\t\t\tDBG_log(\"Sending one or more authcerts\");\n\t});\n}\n"], "fixing_code": ["/* State machine for IKEv1\n *\n * Copyright (C) 1997 Angelos D. Keromytis.\n * Copyright (C) 1998-2010,2013-2016 D. Hugh Redelmeier <hugh@mimosa.com>\n * Copyright (C) 2003-2008 Michael Richardson <mcr@xelerance.com>\n * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>\n * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>\n * Copyright (C) 2011 Avesh Agarwal <avagarwa@redhat.com>\n * Copyright (C) 2008 Hiren Joshi <joshihirenn@gmail.com>\n * Copyright (C) 2009 Anthony Tong <atong@TrustedCS.com>\n * Copyright (C) 2012-2019 Paul Wouters <pwouters@redhat.com>\n * Copyright (C) 2013 Wolfgang Nothdurft <wolfgang@linogate.de>\n * Copyright (C) 2019-2019 Andrew Cagney <cagney@gnu.org>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.  See <https://www.gnu.org/licenses/gpl2.txt>.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * for more details.\n *\n */\n\n/* Ordering Constraints on Payloads\n *\n * rfc2409: The Internet Key Exchange (IKE)\n *\n * 5 Exchanges:\n *   \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n *\n *   \"Except where otherwise noted, there are no requirements for ISAKMP\n *    payloads in any message to be in any particular order.\"\n *\n * 5.3 Phase 1 Authenticated With a Revised Mode of Public Key Encryption:\n *\n *   \"If the HASH payload is sent it MUST be the first payload of the\n *    second message exchange and MUST be followed by the encrypted\n *    nonce. If the HASH payload is not sent, the first payload of the\n *    second message exchange MUST be the encrypted nonce.\"\n *\n *   \"Save the requirements on the location of the optional HASH payload\n *    and the mandatory nonce payload there are no further payload\n *    requirements. All payloads-- in whatever order-- following the\n *    encrypted nonce MUST be encrypted with Ke_i or Ke_r depending on the\n *    direction.\"\n *\n * 5.5 Phase 2 - Quick Mode\n *\n *   \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n *    header and a SA payload MUST immediately follow the HASH.\"\n *   [NOTE: there may be more than one SA payload, so this is not\n *    totally reasonable.  Probably all SAs should be so constrained.]\n *\n *   \"If ISAKMP is acting as a client negotiator on behalf of another\n *    party, the identities of the parties MUST be passed as IDci and\n *    then IDcr.\"\n *\n *   \"With the exception of the HASH, SA, and the optional ID payloads,\n *    there are no payload ordering restrictions on Quick Mode.\"\n */\n\n/* Unfolding of Identity -- a central mystery\n *\n * This concerns Phase 1 identities, those of the IKE hosts.\n * These are the only ones that are authenticated.  Phase 2\n * identities are for IPsec SAs.\n *\n * There are three case of interest:\n *\n * (1) We initiate, based on a whack command specifying a Connection.\n *     We know the identity of the peer from the Connection.\n *\n * (2) (to be implemented) we initiate based on a flow from our client\n *     to some IP address.\n *     We immediately know one of the peer's client IP addresses from\n *     the flow.  We must use this to figure out the peer's IP address\n *     and Id.  To be solved.\n *\n * (3) We respond to an IKE negotiation.\n *     We immediately know the peer's IP address.\n *     We get an ID Payload in Main I2.\n *\n *     Unfortunately, this is too late for a number of things:\n *     - the ISAKMP SA proposals have already been made (Main I1)\n *       AND one accepted (Main R1)\n *     - the SA includes a specification of the type of ID\n *       authentication so this is negotiated without being told the ID.\n *     - with Preshared Key authentication, Main I2 is encrypted\n *       using the key, so it cannot be decoded to reveal the ID\n *       without knowing (or guessing) which key to use.\n *\n *     There are three reasonable choices here for the responder:\n *     + assume that the initiator is making wise offers since it\n *       knows the IDs involved.  We can balk later (but not gracefully)\n *       when we find the actual initiator ID\n *     + attempt to infer identity by IP address.  Again, we can balk\n *       when the true identity is revealed.  Actually, it is enough\n *       to infer properties of the identity (eg. SA properties and\n *       PSK, if needed).\n *     + make all properties universal so discrimination based on\n *       identity isn't required.  For example, always accept the same\n *       kinds of encryption.  Accept Public Key Id authentication\n *       since the Initiator presumably has our public key and thinks\n *       we must have / can find his.  This approach is weakest\n *       for preshared key since the actual key must be known to\n *       decrypt the Initiator's ID Payload.\n *     These choices can be blended.  For example, a class of Identities\n *     can be inferred, sufficient to select a preshared key but not\n *     sufficient to infer a unique identity.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n\n#include \"sysdep.h\"\n#include \"constants.h\"\n#include \"lswlog.h\"\n\n#include \"defs.h\"\n#include \"ike_spi.h\"\n#include \"id.h\"\n#include \"x509.h\"\n#include \"pluto_x509.h\"\n#include \"certs.h\"\n#include \"connections.h\"        /* needs id.h */\n#include \"state.h\"\n#include \"ikev1_msgid.h\"\n#include \"packet.h\"\n#include \"crypto.h\"\n#include \"ike_alg.h\"\n#include \"log.h\"\n#include \"demux.h\"      /* needs packet.h */\n#include \"ikev1.h\"\n#include \"ipsec_doi.h\"  /* needs demux.h and state.h */\n#include \"ikev1_quick.h\"\n#include \"timer.h\"\n#include \"whack.h\"      /* requires connections.h */\n#include \"server.h\"\n#include \"send.h\"\n#include \"ikev1_send.h\"\n#include \"ikev1_xauth.h\"\n#include \"retransmit.h\"\n#include \"nat_traversal.h\"\n#include \"vendor.h\"\n#include \"ikev1_dpd.h\"\n#include \"hostpair.h\"\n#include \"ip_address.h\"\n#include \"ikev1_hash.h\"\n#include \"ike_alg_encrypt_ops.h\"\t/* XXX: oops */\n#include \"ikev1_states.h\"\n#include \"initiate.h\"\n#include \"iface.h\"\n#include \"ip_selector.h\"\n\n#ifdef HAVE_NM\n#include \"kernel.h\"\n#endif\n\n#include \"pluto_stats.h\"\n\n/*\n * state_v1_microcode is a tuple of information parameterizing certain\n * centralized processing of a packet.  For example, it roughly\n * specifies what payloads are expected in this message.  The\n * microcode is selected primarily based on the state.  In Phase 1,\n * the payload structure often depends on the authentication\n * technique, so that too plays a part in selecting the\n * state_v1_microcode to use.\n */\n\nstruct state_v1_microcode {\n\tenum state_kind state, next_state;\n\tlset_t flags;\n\tlset_t req_payloads;    /* required payloads (allows just one) */\n\tlset_t opt_payloads;    /* optional payloads (any mumber) */\n\tenum event_type timeout_event;\n\tikev1_state_transition_fn *processor;\n\tconst char *message;\n\tenum v1_hash_type hash_type;\n};\n\nvoid jam_v1_transition(jambuf_t *buf, const struct state_v1_microcode *transition)\n{\n\tif (transition == NULL) {\n\t\tjam(buf, \"NULL\");\n\t} else {\n\t\tjam(buf, \"%s->%s\",\n\t\t    finite_states[transition->state]->short_name,\n\t\t    finite_states[transition->next_state]->short_name);\n\t}\n}\n\n/* State Microcode Flags, in several groups */\n\n/* Oakley Auth values: to which auth values does this entry apply?\n * Most entries will use SMF_ALL_AUTH because they apply to all.\n * Note: SMF_ALL_AUTH matches 0 for those circumstances when no auth\n * has been set.\n *\n * The IKEv1 state machine then uses the auth type (SMF_*_AUTH flags)\n * to select the exact state transition.  For states where auth\n * (SMF_*_AUTH flags) don't apply (.e.g, child states)\n * flags|=SMF_ALL_AUTH so the first transition always matches.\n *\n * Once a transition is selected, the containing payloads are checked\n * against what is allowed.  For instance, in STATE_MAIN_R2 ->\n * STATE_MAIN_R3 with SMF_DS_AUTH requires P(SIG).\n *\n * In IKEv2, it is the message header and payload types that select\n * the state.  As for how the IKEv1 'from state' is slected, look for\n * a big nasty magic switch.\n *\n * XXX: the state transition table is littered with STATE_UNDEFINED /\n * SMF_ALL_AUTH / unexpected() entries.  These are to catch things\n * like unimplemented auth cases, and unexpected packets.  For the\n * latter, they seem to be place holders so that the table contains at\n * least one entry for the state.\n *\n * XXX: Some of the SMF flags specify attributes of the current state\n * (e.g., SMF_RETRANSMIT_ON_DUPLICATE), some apply to the state\n * transition (e.g., SMF_REPLY), and some can be interpreted as either\n * (.e.g., SMF_INPUT_ENCRYPTED).\n */\n#define SMF_ALL_AUTH    LRANGE(0, OAKLEY_AUTH_ROOF - 1)\n#define SMF_PSK_AUTH    LELEM(OAKLEY_PRESHARED_KEY)\n#define SMF_DS_AUTH     (LELEM(OAKLEY_DSS_SIG) | LELEM(OAKLEY_RSA_SIG))\n#define SMF_PKE_AUTH    LELEM(OAKLEY_RSA_ENC)\n#define SMF_RPKE_AUTH   LELEM(OAKLEY_RSA_REVISED_MODE)\n\n/* misc flags */\n#define SMF_INITIATOR   LELEM(OAKLEY_AUTH_ROOF + 0)\n#define SMF_FIRST_ENCRYPTED_INPUT       LELEM(OAKLEY_AUTH_ROOF + 1)\n#define SMF_INPUT_ENCRYPTED     LELEM(OAKLEY_AUTH_ROOF + 2)\n#define SMF_OUTPUT_ENCRYPTED    LELEM(OAKLEY_AUTH_ROOF + 3)\n#define SMF_RETRANSMIT_ON_DUPLICATE     LELEM(OAKLEY_AUTH_ROOF + 4)\n\n#define SMF_ENCRYPTED (SMF_INPUT_ENCRYPTED | SMF_OUTPUT_ENCRYPTED)\n\n/* this state generates a reply message */\n#define SMF_REPLY   LELEM(OAKLEY_AUTH_ROOF + 5)\n\n/* this state completes P1, so any pending P2 negotiations should start */\n#define SMF_RELEASE_PENDING_P2  LELEM(OAKLEY_AUTH_ROOF + 6)\n\n/* if we have canoncalized the authentication from XAUTH mode */\n#define SMF_XAUTH_AUTH  LELEM(OAKLEY_AUTH_ROOF + 7)\n\n/* end of flags */\n\nstatic ikev1_state_transition_fn unexpected;      /* forward declaration */\nstatic ikev1_state_transition_fn informational;      /* forward declaration */\n\n/*\n * v1_state_microcode_table is a table of all state_v1_microcode\n * tuples.  It must be in order of state (the first element).  After\n * initialization, ike_microcode_index[s] points to the first entry in\n * v1_state_microcode_table for state s.  Remember that each state\n * name in Main or Quick Mode describes what has happened in the past,\n * not what this message is.\n */\n\nstatic const struct state_v1_microcode v1_state_microcode_table[] = {\n\n#define P(n) LELEM(ISAKMP_NEXT_ ##n)\n#define FM(F) .processor = F, .message = #F\n\n\t/***** Phase 1 Main Mode *****/\n\n\t/* No state for main_outI1: --> HDR, SA */\n\n\t/* STATE_MAIN_R0: I1 --> R1\n\t * HDR, SA --> HDR, SA\n\t */\n\t{ STATE_MAIN_R0, STATE_MAIN_R1,\n\t  SMF_ALL_AUTH | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR),\n\t  EVENT_SO_DISCARD,\n\t  FM(main_inI1_outR1),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_I1: R1 --> I2\n\t * HDR, SA --> auth dependent\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: --> HDR, KE, Ni\n\t * SMF_PKE_AUTH:\n\t *\t--> HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t * SMF_RPKE_AUTH:\n\t *\t--> HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t * Note: since we don't know auth at start, we cannot differentiate\n\t * microcode entries based on it.\n\t */\n\t{ STATE_MAIN_I1, STATE_MAIN_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_REPLY,\n\t  P(SA), P(VID) | P(CR),\n\t  EVENT_RETRANSMIT,\n\t  FM(main_inR1_outI2),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_R1: I2 --> R2\n\t * SMF_PSK_AUTH, SMF_DS_AUTH: HDR, KE, Ni --> HDR, KE, Nr\n\t * SMF_PKE_AUTH: HDR, KE, [ HASH(1), ] <IDi1_b>PubKey_r, <Ni_b>PubKey_r\n\t *\t    --> HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t * SMF_RPKE_AUTH:\n\t *\t    HDR, [ HASH(1), ] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDi1_b>Ke_i [,<<Cert-I_b>Ke_i]\n\t *\t    --> HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t */\n\t{ STATE_MAIN_R1, STATE_MAIN_R2,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC),\n\t  EVENT_RETRANSMIT,\n\t  FM(main_inI2_outR2),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR) | P(HASH),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R1, STATE_UNDEFINED,\n\t  SMF_RPKE_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR) | P(HASH) | P(CERT),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* for states from here on, output message must be encrypted */\n\n\t/* STATE_MAIN_I2: R2 --> I3\n\t * SMF_PSK_AUTH: HDR, KE, Nr --> HDR*, IDi1, HASH_I\n\t * SMF_DS_AUTH: HDR, KE, Nr --> HDR*, IDi1, [ CERT, ] SIG_I\n\t * SMF_PKE_AUTH: HDR, KE, <IDr1_b>PubKey_i, <Nr_b>PubKey_i\n\t *\t    --> HDR*, HASH_I\n\t * SMF_RPKE_AUTH: HDR, <Nr_b>PubKey_i, <KE_b>Ke_r, <IDr1_b>Ke_r\n\t *\t    --> HDR*, HASH_I\n\t */\n\t{ STATE_MAIN_I2, STATE_MAIN_I3,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC),\n\t  EVENT_RETRANSMIT,\n\t  FM(main_inR2_outI3),\n\t  /* calls main_mode_hash() after DH */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(KE) | P(ID) | P(NONCE), P(VID) | P(CR),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY,\n\t  P(NONCE) | P(KE) | P(ID), P(VID) | P(CR),\n\t  EVENT_RETRANSMIT,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* for states from here on, input message must be encrypted */\n\n\t/* STATE_MAIN_R2: I3 --> R3\n\t * SMF_PSK_AUTH: HDR*, IDi1, HASH_I --> HDR*, IDr1, HASH_R\n\t * SMF_DS_AUTH: HDR*, IDi1, [ CERT, ] SIG_I --> HDR*, IDr1, [ CERT, ] SIG_R\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_I --> HDR*, HASH_R\n\t */\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inI3_outR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R2, STATE_MAIN_R3,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inI3_outR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b )\n\t     SIG_I = SIGN(HASH_I) *\",\n\t     SIG_I = SIGN(HASH_I) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_R2, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_ENCRYPTED |\n\t\tSMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_I3: R3 --> done\n\t * SMF_PSK_AUTH: HDR*, IDr1, HASH_R --> done\n\t * SMF_DS_AUTH: HDR*, IDr1, [ CERT, ] SIG_R --> done\n\t * SMF_PKE_AUTH, SMF_RPKE_AUTH: HDR*, HASH_R --> done\n\t * May initiate quick mode by calling quick_outI1\n\t */\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_PSK_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I3, STATE_MAIN_I4,\n\t  SMF_DS_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(ID) | P(SIG), P(VID) | P(CR) | P(CERT),\n\t  EVENT_SA_REPLACE,\n\t  FM(main_inR3),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b )\n\t     SIG_R = SIGN(HASH_R) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MAIN_I3, STATE_UNDEFINED,\n\t  SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_INITIATOR |\n\t\tSMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(HASH), P(VID) | P(CR),\n\t  EVENT_SA_REPLACE,\n\t  FM(unexpected) /* ??? not yet implemented */,\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_R3: can only get here due to packet loss */\n\t{ STATE_MAIN_R3, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_MAIN_I4: can only get here due to packet loss */\n\t{ STATE_MAIN_I4, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/***** Phase 1 Aggressive Mode *****/\n\n\t/* No initial state for aggr_outI1:\n\t * SMF_DS_AUTH (RFC 2409 5.1) and SMF_PSK_AUTH (RFC 2409 5.4):\n\t * -->HDR, SA, KE, Ni, IDii\n\t *\n\t * Not implemented:\n\t * RFC 2409 5.2: --> HDR, SA, [ HASH(1),] KE, <IDii_b>Pubkey_r, <Ni_b>Pubkey_r\n\t * RFC 2409 5.3: --> HDR, SA, [ HASH(1),] <Ni_b>Pubkey_r, <KE_b>Ke_i, <IDii_b>Ke_i [, <Cert-I_b>Ke_i ]\n\t */\n\n\t/* STATE_AGGR_R0:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Ni, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, HASH_R\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDii\n\t *           --> HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t */\n\t{ STATE_AGGR_R0, STATE_AGGR_R1,\n\t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC),\n\t  EVENT_SO_DISCARD,\n\t  FM(aggr_inI1_outR1),\n\t  /* N/A */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_I1:\n\t * SMF_PSK_AUTH: HDR, SA, KE, Nr, IDir, HASH_R\n\t *           --> HDR*, HASH_I\n\t * SMF_DS_AUTH:  HDR, SA, KE, Nr, IDir, [CERT,] SIG_R\n\t *           --> HDR*, [CERT,] SIG_I\n\t */\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_PSK_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(HASH), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inR1_outI2),\n\t  /* after DH calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_AGGR_I1, STATE_AGGR_I2,\n\t  SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY |\n\t\tSMF_RELEASE_PENDING_P2,\n\t  P(SA) | P(KE) | P(NONCE) | P(ID) | P(SIG), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inR1_outI2),\n\t  /* after DH calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_R = prf(SKEYID, g^xr | g^xi | CKY-R | CKY-I | SAi_b | IDir_b )\n\t     SIG_R = SIGN(HASH_R) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_R1:\n\t * SMF_PSK_AUTH: HDR*, HASH_I --> done\n\t * SMF_DS_AUTH:  HDR*, SIG_I  --> done\n\t */\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_OUTPUT_ENCRYPTED | SMF_RELEASE_PENDING_P2 |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(HASH), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inI2),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.2 Phase 1 Authenticated With Public Key Encryption\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b ) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_AGGR_R1, STATE_AGGR_R2,\n\t  SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT |\n\t\tSMF_OUTPUT_ENCRYPTED | SMF_RELEASE_PENDING_P2 |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  P(SIG), P(VID) | P(NATD_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(aggr_inI2),\n\t  /* calls oakley_id_and_auth() which calls main_mode_hash() */\n\t  /* RFC 2409: 5. Exchanges & 5.1 IKE Phase 1 Authenticated With Signatures\n\t     HASH_I = prf(SKEYID, g^xi | g^xr | CKY-I | CKY-R | SAi_b | IDii_b )\n\t     SIG_I = SIGN(HASH_I) */\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_I2: can only get here due to packet loss */\n\t{ STATE_AGGR_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY, EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_AGGR_R2: can only get here due to packet loss */\n\t{ STATE_AGGR_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY, EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/***** Phase 2 Quick Mode *****/\n\n\t/* No state for quick_outI1:\n\t * --> HDR*, HASH(1), SA, Nr [, KE ] [, IDci, IDcr ]\n\t */\n\n\t/* STATE_QUICK_R0:\n\t * HDR*, HASH(1), SA, Ni [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ]\n\t * Installs inbound IPsec SAs.\n\t * Because it may suspend for asynchronous DNS, first_out_payload\n\t * is set to NONE to suppress early emission of HDR*.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_R0, STATE_QUICK_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(NATOA_RFC),\n\t  EVENT_RETRANSMIT,\n\t  FM(quick_inI1_outR1),\n\t  /* RFC 2409: 5.5 Phase 2 - Quick Mode:\n\t     HASH(1) = prf(SKEYID_a, M-ID | <rest>) */\n\t  .hash_type = V1_HASH_1, },\n\n\t/* STATE_QUICK_I1:\n\t * HDR*, HASH(2), SA, Nr [, KE ] [, IDci, IDcr ] -->\n\t * HDR*, HASH(3)\n\t * Installs inbound and outbound IPsec SAs, routing, etc.\n\t * ??? it is legal to have multiple SAs, but we don't support it yet.\n\t */\n\t{ STATE_QUICK_I1, STATE_QUICK_I2,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(HASH) | P(SA) | P(NONCE), /* P(SA) | */ P(KE) | P(ID) | P(NATOA_RFC),\n\t  EVENT_SA_REPLACE,\n\t  FM(quick_inR1_outI2),\n\t  /* RFC 2409: 5.5 Phase 2 - Quick Mode:\n\t     HASH(2) = prf(SKEYID_a, M-ID | Ni_b | <rest>) */\n\t  .hash_type = V1_HASH_2, },\n\n\t/* STATE_QUICK_R1: HDR*, HASH(3) --> done\n\t * Installs outbound IPsec SAs, routing, etc.\n\t */\n\t{ STATE_QUICK_R1, STATE_QUICK_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY,\n\t  EVENT_SA_REPLACE,\n\t  FM(quick_inI2),\n\t  /* RFC 2409: 5.5 Phase 2 - Quick Mode:\n\t     HASH(3) = prf(SKEYID_a, 0 | M-ID | Ni_b | Nr_b) */\n\t  .hash_type = V1_HASH_3, },\n\n\t/* STATE_QUICK_I2: can only happen due to lost packet */\n\t{ STATE_QUICK_I2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED |\n\t\tSMF_RETRANSMIT_ON_DUPLICATE,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* STATE_QUICK_R2: can only happen due to lost packet */\n\t{ STATE_QUICK_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/***** informational messages *****/\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR N/D\n\t * Unencrypted: must not occur after ISAKMP Phase 1 exchange of keying material.\n\t */\n\t/* STATE_INFO: */\n\t{ STATE_INFO, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(informational),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t/* Informational Exchange (RFC 2408 4.8):\n\t * HDR* N/D\n\t */\n\t/* STATE_INFO_PROTECTED: */\n\t{ STATE_INFO_PROTECTED, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(HASH), LEMPTY,\n\t  EVENT_NULL,\n\t  FM(informational),\n\t  /* RFC 2409: 5.7 ISAKMP Informational Exchanges:\n\t     HASH(1) = prf(SKEYID_a, M-ID | N/D) */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_XAUTH_R0, STATE_XAUTH_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_NULL,\n\t  FM(xauth_inR0),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, }, /* Re-transmit may be done by previous state */\n\n\t{ STATE_XAUTH_R1, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(xauth_inR1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n#if 0\n\t/* for situation where there is XAUTH + ModeCFG */\n\t{ STATE_XAUTH_R2, STATE_XAUTH_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(xauth_inR2), },\n\n\t{ STATE_XAUTH_R3, STATE_MAIN_R3,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(xauth_inR3), },\n#endif\n\n/* MODE_CFG_x:\n * Case R0:  Responder\t->\tInitiator\n *\t\t\t<-\tReq(addr=0)\n *\t    Reply(ad=x)\t->\n *\n * Case R1: Set(addr=x)\t->\n *\t\t\t<-\tAck(ok)\n */\n\n\t{ STATE_MODE_CFG_R0, STATE_MODE_CFG_R1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(modecfg_inR0),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_MODE_CFG_R1, STATE_MODE_CFG_R2,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(modecfg_inR1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_MODE_CFG_R2, STATE_UNDEFINED,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL,\n\t  FM(unexpected),\n\t  .hash_type = V1_HASH_NONE, },\n\n\t{ STATE_MODE_CFG_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_SA_REPLACE,\n\t  FM(modecfg_inR1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_XAUTH_I0, STATE_XAUTH_I1,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_RETRANSMIT,\n\t  FM(xauth_inI0),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_XAUTH_I1, STATE_MAIN_I4,\n\t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n\t  P(MCFG_ATTR) | P(HASH), P(VID),\n\t  EVENT_RETRANSMIT,\n\t  FM(xauth_inI1),\n\t  /* RFC ????: */\n\t  .hash_type = V1_HASH_1, },\n\n\t{ STATE_IKEv1_ROOF, STATE_IKEv1_ROOF,\n\t  LEMPTY,\n\t  LEMPTY, LEMPTY,\n\t  EVENT_NULL, NULL,\n\t  .hash_type = V1_HASH_NONE, },\n\n#undef FM\n#undef P\n};\n\nvoid init_ikev1(void)\n{\n\tDBGF(DBG_CONTROL, \"checking IKEv1 state table\");\n\n\t/*\n\t * Fill in FINITE_STATES[].\n\t *\n\t * This is a hack until each finite-state is a separate object\n\t * with corresponding edges (aka microcodes).\n\t *\n\t * XXX: Long term goal is to have a constant FINITE_STATES[]\n\t * contain constant pointers and this static writeable array\n\t * to just go away.\n\t */\n\tfor (enum state_kind kind = STATE_IKEv1_FLOOR; kind < STATE_IKEv1_ROOF; kind++) {\n\t\t/* fill in using static struct */\n\t\tconst struct finite_state *fs = &v1_states[kind - STATE_IKEv1_FLOOR];\n\t\tpassert(fs->kind == kind);\n\t\tpassert(finite_states[kind] == NULL);\n\t\tfinite_states[kind] = fs;\n\t}\n\n\t/*\n\t * Go through the state transition table filling in details\n\t * and checking for inconsistencies.\n\t */\n\tfor (const struct state_v1_microcode *t = v1_state_microcode_table;\n\t     t->state < STATE_IKEv1_ROOF; t++) {\n\n\t\tpassert(t->state >= STATE_IKEv1_FLOOR);\n\t\tpassert(t->state < STATE_IKEv1_ROOF);\n\t\tstruct finite_state *from = &v1_states[t->state - STATE_IKEv1_FLOOR];\n\n\t\t/*\n\t\t * Deal with next_state == STATE_UNDEFINED.\n\t\t *\n\t\t * XXX: STATE_UNDEFINED is used when a state\n\t\t * transitions back to the same state; such\n\t\t * transitions should instead explicitly specify that\n\t\t * same state.\n\t\t */\n\t\tenum state_kind next_state = (t->next_state == STATE_UNDEFINED ?\n\t\t\t\t\t      t->state : t->next_state);\n\t\tpassert(STATE_IKEv1_FLOOR <= next_state &&\n\t\t\tnext_state < STATE_IKEv1_ROOF);\n\t\tconst struct finite_state *to = finite_states[next_state];\n\t\tpassert(to != NULL);\n\n\t\tif (DBGP(DBG_BASE)) {\n\t\t\tif (from->nr_transitions == 0) {\n\t\t\t\tLSWLOG_DEBUG(buf) {\n\t\t\t\t\tlswlogs(buf, \"  \");\n\t\t\t\t\tlswlog_finite_state(buf, from);\n\t\t\t\t\tlswlogs(buf, \":\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_log(\"    -> %s %s (%s)\", to->short_name,\n\t\t\t\tenum_short_name(&timer_event_names,\n\t\t\t\t\t\tt->timeout_event),\n\t\t\t\tt->message);\n\t\t}\n\n\t\t/*\n\t\t * Point .fs_v1_transitions at to the first entry in\n\t\t * v1_state_microcode_table for that state.  All other\n\t\t * transitions for that state should follow\n\t\t * immediately after (or to put it another way, the\n\t\t * previous transition's state should be the same as\n\t\t * this).\n\t\t */\n\t\tif (from->v1_transitions == NULL) {\n\t\t\tfrom->v1_transitions = t;\n\t\t} else {\n\t\t\tpassert(t[-1].state == t->state);\n\t\t}\n\t\tfrom->nr_transitions++;\n\n\t\tif (t->message == NULL) {\n\t\t\tPEXPECT_LOG(\"transition %s -> %s missing .message\",\n\t\t\t\t    from->short_name, to->short_name);\n\t\t}\n\n\t\t/*\n\t\t * Copy (actually merge) the flags that apply to the\n\t\t * state; and not the state transition.\n\t\t *\n\t\t * The original code used something like state\n\t\t * .microcode .flags after the state transition had\n\t\t * completed.  I.e., use the flags from a\n\t\t * not-yet-taken potential future state transition and\n\t\t * not the previous one.\n\t\t *\n\t\t * This is just trying to extact extract them and\n\t\t * check they are consistent.\n\t\t *\n\t\t * XXX: this is confusing\n\t\t *\n\t\t * Should fs_flags and SMF_RETRANSMIT_ON_DUPLICATE\n\t\t * should be replaced by SMF_RESPONDING in the\n\t\t * transition flags?\n\t\t *\n\t\t * Or is this more like .fs_timeout_event which is\n\t\t * always true of a state?\n\t\t */\n\t\tif ((t->flags & from->flags) != from->flags) {\n\t\t\tDBGF(DBG_BASE, \"transition %s -> %s (%s) missing flags 0x%\"PRIxLSET,\n\t\t\t     from->short_name, to->short_name,\n\t\t\t     t->message, from->flags);\n\t\t}\n\t\tfrom->flags |= t->flags & SMF_RETRANSMIT_ON_DUPLICATE;\n\n\t\tif (!(t->flags & SMF_FIRST_ENCRYPTED_INPUT) &&\n\t\t    (t->flags & SMF_INPUT_ENCRYPTED) &&\n\t\t    t->processor != unexpected) {\n\t\t\t/*\n\t\t\t * The first encrypted message carries\n\t\t\t * authentication information so isn't\n\t\t\t * applicable.  Other encrypted messages\n\t\t\t * require integrity via the HASH payload.\n\t\t\t */\n\t\t\tif (!(t->req_payloads & LELEM(ISAKMP_NEXT_HASH))) {\n\t\t\t\tPEXPECT_LOG(\"transition %s -> %s (%s) missing HASH payload\",\n\t\t\t\t\t    from->short_name, to->short_name,\n\t\t\t\t\t    t->message);\n\t\t\t}\n\t\t\tif (t->hash_type == V1_HASH_NONE) {\n\t\t\t\tPEXPECT_LOG(\"transition %s -> %s (%s) missing HASH protection\",\n\t\t\t\t\t    from->short_name, to->short_name,\n\t\t\t\t\t    t->message);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic stf_status unexpected(struct state *st, struct msg_digest *md UNUSED)\n{\n\tloglog(RC_LOG_SERIOUS, \"unexpected message received in state %s\",\n\t       st->st_state->name);\n\treturn STF_IGNORE;\n}\n\n/*\n * RFC 2408 Section 4.6\n *\n *  #   Initiator  Direction Responder  NOTE\n * (1)  HDR*; N/D     =>                Error Notification or Deletion\n */\nstatic stf_status informational(struct state *st, struct msg_digest *md)\n{\n\t/*\n\t * XXX: Danger: ST is deleted midway through this function.\n\t */\n\tpexpect(st == md->st);\n\tst = md->st;    /* may be NULL */\n\n\tstruct payload_digest *const n_pld = md->chain[ISAKMP_NEXT_N];\n\n\t/* If the Notification Payload is not null... */\n\tif (n_pld != NULL) {\n\t\tpb_stream *const n_pbs = &n_pld->pbs;\n\t\tstruct isakmp_notification *const n =\n\t\t\t&n_pld->payload.notification;\n\n\t\t/* Switch on Notification Type (enum) */\n\t\t/* note that we _can_ get notification payloads unencrypted\n\t\t * once we are at least in R3/I4.\n\t\t * and that the handler is expected to treat them suspiciously.\n\t\t */\n\t\tdbg(\"processing informational %s (%d)\",\n\t\t    enum_name(&ikev1_notify_names, n->isan_type),\n\t\t    n->isan_type);\n\n\t\tpstats(ikev1_recv_notifies_e, n->isan_type);\n\n\t\tswitch (n->isan_type) {\n\t\t/*\n\t\t * We answer DPD probes even if they claimed not to support\n\t\t * Dead Peer Detection.\n\t\t * We would have to send some kind of reply anyway to prevent\n\t\t * a retransmit, so rather then send an error, we might as\n\t\t * well just send a DPD reply\n\t\t */\n\t\tcase R_U_THERE:\n\t\t\tif (st == NULL) {\n\t\t\t\tplog_md(md, \"received bogus  R_U_THERE informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inI_outR(st, n, n_pbs);\n\n\t\tcase R_U_THERE_ACK:\n\t\t\tif (st == NULL) {\n\t\t\t\tplog_md(md, \"received bogus R_U_THERE_ACK informational message\");\n\t\t\t\treturn STF_IGNORE;\n\t\t\t}\n\t\t\treturn dpd_inR(st, n, n_pbs);\n\n\t\tcase PAYLOAD_MALFORMED:\n\t\t\tif (st != NULL) {\n\t\t\t\tst->hidden_variables.st_malformed_received++;\n\n\t\t\t\tlog_state(RC_LOG, st, \"received %u malformed payload notifies\",\n\t\t\t\t\t  st->hidden_variables.st_malformed_received);\n\n\t\t\t\tif (st->hidden_variables.st_malformed_sent >\n\t\t\t\t    MAXIMUM_MALFORMED_NOTIFY / 2 &&\n\t\t\t\t    ((st->hidden_variables.st_malformed_sent +\n\t\t\t\t      st->hidden_variables.\n\t\t\t\t      st_malformed_received) >\n\t\t\t\t     MAXIMUM_MALFORMED_NOTIFY)) {\n\t\t\t\t\tlog_state(RC_LOG, st, \"too many malformed payloads (we sent %u and received %u\",\n\t\t\t\t\t\t  st->hidden_variables.st_malformed_sent,\n\t\t\t\t\t\t  st->hidden_variables.st_malformed_received);\n\t\t\t\t\tdelete_state(st);\n\t\t\t\t\tmd->st = st = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn STF_IGNORE;\n\n\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\t/*\n\t\t\t * ??? what the heck is in the payload?\n\t\t\t * We take the peer's new IP address from the last 4 octets.\n\t\t\t * Is anything else possible?  Expected?  Documented?\n\t\t\t */\n\t\t\tif (st == NULL || !IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tplog_md(md, \"ignoring ISAKMP_N_CISCO_LOAD_BALANCE Informational Message with for unestablished state.\");\n\t\t\t} else if (pbs_left(n_pbs) < 4) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"ignoring ISAKMP_N_CISCO_LOAD_BALANCE Informational Message without IPv4 address\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Copy (not cast) the last 4 bytes\n\t\t\t\t * (size of an IPv4) address from the\n\t\t\t\t * end of the notification into IN\n\t\t\t\t * (can't cast as can't assume that\n\t\t\t\t * ->roof-4 is correctly aligned).\n\t\t\t\t */\n\t\t\t\tstruct in_addr in;\n\t\t\t\tmemcpy(&in, n_pbs->roof - sizeof(in), sizeof(in));\n\t\t\t\tip_address new_peer = address_from_in_addr(&in);\n\n\t\t\t\t/* is all zeros? */\n\t\t\t\tif (address_is_any(&new_peer)) {\n\t\t\t\t\tipstr_buf b;\n\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"ignoring ISAKMP_N_CISCO_LOAD_BALANCE Informational Message with invalid IPv4 address %s\",\n\t\t\t\t\t\t  ipstr(&new_peer, &b));\n\t\t\t\t\treturn FALSE; /* XXX: STF_*? */\n\t\t\t\t}\n\n\t\t\t\t/* Saving connection name and whack sock id */\n\t\t\t\tconst char *tmp_name = st->st_connection->name;\n\t\t\t\tstruct fd *tmp_whack_sock = dup_any(st->st_whack_sock);\n\n\t\t\t\t/* deleting ISAKMP SA with the current remote peer */\n\t\t\t\tdelete_state(st);\n\t\t\t\tmd->st = st = NULL;\n\n\t\t\t\t/* to find and store the connection associated with tmp_name */\n\t\t\t\t/* ??? how do we know that tmp_name hasn't been freed? */\n\t\t\t\tstruct connection *tmp_c = conn_by_name(tmp_name, false/*!strict*/);\n\n\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\taddress_buf npb;\n\t\t\t\t\tDBG_log(\"new peer address: %s\",\n\t\t\t\t\t\tstr_address(&new_peer, &npb));\n\n\t\t\t\t\t/* Current remote peer info */\n\t\t\t\t\tint count_spd = 1;\n\t\t\t\t\tfor (const struct spd_route *tmp_spd = &tmp_c->spd;\n\t\t\t\t\t     tmp_spd != NULL; tmp_spd = tmp_spd->spd_next) {\n\t\t\t\t\t\taddress_buf b;\n\t\t\t\t\t\tendpoint_buf e;\n\n\t\t\t\t\t\tDBG_log(\"spd route number: %d\",\n\t\t\t\t\t\t\tcount_spd++);\n\n\t\t\t\t\t\t/**that info**/\n\t\t\t\t\t\tDBG_log(\"that id kind: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.id.kind);\n\t\t\t\t\t\tDBG_log(\"that id ipaddr: %s\",\n\t\t\t\t\t\t\tstr_address(&tmp_spd->that.id.ip_addr, &b));\n\t\t\t\t\t\tif (tmp_spd->that.id.name.ptr != NULL) {\n\t\t\t\t\t\t\tDBG_dump_hunk(\"that id name\",\n\t\t\t\t\t\t\t\t      tmp_spd->that.id. name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDBG_log(\"that host_addr: %s\",\n\t\t\t\t\t\t\tstr_endpoint(&tmp_spd->that.host_addr, &e));\n\t\t\t\t\t\tDBG_log(\"that nexthop: %s\",\n\t\t\t\t\t\t\tstr_address(&tmp_spd->that.host_nexthop, &b));\n\t\t\t\t\t\tDBG_log(\"that srcip: %s\",\n\t\t\t\t\t\t\tstr_address(&tmp_spd->that.host_srcip, &b));\n\t\t\t\t\t\tselector_buf sb;\n\t\t\t\t\t\tDBG_log(\"that client: %s\",\n\t\t\t\t\t\t\tstr_selector(&tmp_spd->that.client, &sb));\n\t\t\t\t\t\tDBG_log(\"that has_client: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_client);\n\t\t\t\t\t\tDBG_log(\"that has_client_wildcard: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_client_wildcard);\n\t\t\t\t\t\tDBG_log(\"that has_port_wildcard: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_port_wildcard);\n\t\t\t\t\t\tDBG_log(\"that has_id_wildcards: %d\",\n\t\t\t\t\t\t\ttmp_spd->that.has_id_wildcards);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp_c->interface != NULL) {\n\t\t\t\t\t\tendpoint_buf b;\n\t\t\t\t\t\tDBG_log(\"Current interface_addr: %s\",\n\t\t\t\t\t\t\tstr_endpoint(&tmp_c->interface->local_endpoint, &b));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* save peer's old address for comparison purposes */\n\t\t\t\tip_address old_addr = tmp_c->spd.that.host_addr;\n\n\t\t\t\t/* update peer's address */\n\t\t\t\ttmp_c->spd.that.host_addr = new_peer;\n\n\t\t\t\t/* Modifying connection info to store the redirected remote peer info */\n\t\t\t\tdbg(\"Old host_addr_name : %s\", tmp_c->spd.that.host_addr_name);\n\t\t\t\ttmp_c->spd.that.host_addr_name = NULL;\n\n\t\t\t\t/* ??? do we know the id.kind has an ip_addr? */\n\t\t\t\ttmp_c->spd.that.id.ip_addr = new_peer;\n\n\t\t\t\t/* update things that were the old peer */\n\t\t\t\tipstr_buf b;\n\t\t\t\tif (sameaddr(&tmp_c->spd.this.host_nexthop,\n\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\t\tDBG_log(\"this host's next hop %s was the same as the old remote addr\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"changing this host's next hop to %s\",\n\t\t\t\t\t\t\tipstr(&new_peer, &b));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_c->spd.this.host_nexthop = new_peer;\n\t\t\t\t}\n\n\t\t\t\tif (sameaddr(&tmp_c->spd.that.host_srcip,\n\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\t\tDBG_log(\"Old that host's srcip %s was the same as the old remote addr\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"changing that host's srcip to %s\",\n\t\t\t\t\t\t\tipstr(&new_peer, &b));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_c->spd.that.host_srcip = new_peer;\n\t\t\t\t}\n\n\t\t\t\tif (sameaddr(&tmp_c->spd.that.client.addr,\n\t\t\t\t\t     &old_addr)) {\n\t\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\t\tDBG_log(\"Old that client ip %s was the same as the old remote address\",\n\t\t\t\t\t\t\tipstr(&old_addr, &b));\n\t\t\t\t\t\tDBG_log(\"changing that client's ip to %s\",\n\t\t\t\t\t\t\tipstr(&new_peer, &b));\n\t\t\t\t\t}\n\t\t\t\t\ttmp_c->spd.that.client.addr = new_peer;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * ??? is this wise?  This may changes\n\t\t\t\t * a lot of other connections.\n\t\t\t\t *\n\t\t\t\t * XXX:\n\t\t\t\t *\n\t\t\t\t * As for the old code, preserve the\n\t\t\t\t * existing port.  NEW_PEER, an\n\t\t\t\t * address, doesn't have a port and\n\t\t\t\t * presumably the port wasn't\n\t\t\t\t * updated(?).\n\t\t\t\t */\n\t\t\t\ttmp_c->host_pair->remote = endpoint(&new_peer,\n\t\t\t\t\t\t\t\t    endpoint_hport(&tmp_c->host_pair->remote));\n\n\t\t\t\t/* Initiating connection to the redirected peer */\n\t\t\t\tinitiate_connections_by_name(tmp_name, NULL,\n\t\t\t\t\t\t\t     tmp_whack_sock,\n\t\t\t\t\t\t\t     tmp_whack_sock == NULL/*guess*/);\n\t\t\t\tclose_any(&tmp_whack_sock);\n\t\t\t}\n\t\t\treturn STF_IGNORE;\n\t\tdefault:\n\t\t{\n\t\t\tstruct logger logger = st != NULL ? *(st->st_logger) : MESSAGE_LOGGER(md);\n\t\t\tlog_message(RC_LOG_SERIOUS, &logger,\n\t\t\t\t    \"received and ignored notification payload: %s\",\n\t\t\t\t    enum_name(&ikev1_notify_names, n->isan_type));\n\t\t\treturn STF_IGNORE;\n\t\t}\n\t\t}\n\t} else {\n\t\t/* warn if we didn't find any Delete or Notify payload in packet */\n\t\tif (md->chain[ISAKMP_NEXT_D] == NULL) {\n\t\t\tstruct logger logger = st != NULL ? *(st->st_logger) : MESSAGE_LOGGER(md);\n\t\t\tlog_message(RC_LOG_SERIOUS, &logger,\n\t\t\t\t    \"received and ignored empty informational notification payload\");\n\t\t}\n\t\treturn STF_IGNORE;\n\t}\n}\n\n/*\n * create output HDR as replica of input HDR - IKEv1 only; return the body\n */\nvoid ikev1_init_out_pbs_echo_hdr(struct msg_digest *md, bool enc,\n\t\t\t\t pb_stream *output_stream, uint8_t *output_buffer,\n\t\t\t\t size_t sizeof_output_buffer,\n\t\t\t\t pb_stream *rbody)\n{\n\tstruct isakmp_hdr hdr = md->hdr; /* mostly same as incoming header */\n\n\t/* make sure we start with a clean buffer */\n\tinit_out_pbs(output_stream, output_buffer, sizeof_output_buffer,\n\t\t     \"reply packet\");\n\n\thdr.isa_flags = 0; /* zero all flags */\n\tif (enc)\n\t\thdr.isa_flags |= ISAKMP_FLAGS_v1_ENCRYPTION;\n\n\tif (impair.send_bogus_isakmp_flag) {\n\t\thdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;\n\t}\n\n\t/* there is only one IKEv1 version, and no new one will ever come - no need to set version */\n\thdr.isa_np = 0;\n\t/* surely must have room and be well-formed */\n\tpassert(out_struct(&hdr, &isakmp_hdr_desc, output_stream, rbody));\n}\n\n/*\n * Recognise and, if necesssary, respond to an IKEv1 duplicate.\n *\n * Use .st_state, which is the true current state, and not MD\n * .FROM_STATE (which is derived from some convoluted magic) when\n * determining if the duplicate should or should not get a response.\n */\nstatic bool ikev1_duplicate(struct state *st, struct msg_digest *md)\n{\n\tpassert(st != NULL);\n\tif (st->st_v1_rpacket.ptr != NULL &&\n\t    st->st_v1_rpacket.len == pbs_room(&md->packet_pbs) &&\n\t    memeq(st->st_v1_rpacket.ptr, md->packet_pbs.start,\n\t\t  st->st_v1_rpacket.len)) {\n\t\t/*\n\t\t * Duplicate.  Drop or retransmit?\n\t\t *\n\t\t * Only re-transmit when the last state transition\n\t\t * (triggered by this packet the first time) included\n\t\t * a reply.\n\t\t *\n\t\t * XXX: is SMF_RETRANSMIT_ON_DUPLICATE useful or\n\t\t * correct?\n\t\t */\n\t\tbool replied = (st->st_v1_last_transition != NULL &&\n\t\t\t\t(st->st_v1_last_transition->flags & SMF_REPLY));\n\t\tbool retransmit_on_duplicate =\n\t\t\t(st->st_state->flags & SMF_RETRANSMIT_ON_DUPLICATE);\n\t\tif (replied && retransmit_on_duplicate) {\n\t\t\t/*\n\t\t\t * Transitions with EVENT_SO_DISCARD should\n\t\t\t * always respond to re-transmits (why?); else\n\t\t\t * cap.\n\t\t\t */\n\t\t\tif (st->st_v1_last_transition->timeout_event == EVENT_SO_DISCARD ||\n\t\t\t    count_duplicate(st, MAXIMUM_v1_ACCEPTED_DUPLICATES)) {\n\t\t\t\tloglog(RC_RETRANSMISSION,\n\t\t\t\t       \"retransmitting in response to duplicate packet; already %s\",\n\t\t\t\t       st->st_state->name);\n\t\t\t\tresend_recorded_v1_ike_msg(st, \"retransmit in response to duplicate\");\n\t\t\t} else {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"discarding duplicate packet -- exhausted retransmission; already %s\",\n\t\t\t\t       st->st_state->name);\n\t\t\t}\n\t\t} else {\n\t\t\tdbg(\"#%lu discarding duplicate packet; already %s; replied=%s retransmit_on_duplicate=%s\",\n\t\t\t    st->st_serialno, st->st_state->name,\n\t\t\t    bool_str(replied), bool_str(retransmit_on_duplicate));\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* process an input packet, possibly generating a reply.\n *\n * If all goes well, this routine eventually calls a state-specific\n * transition function.\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_v1_packet(struct msg_digest *md)\n{\n\tconst struct state_v1_microcode *smc;\n\tbool new_iv_set = FALSE;\n\tstruct state *st = NULL;\n\tenum state_kind from_state = STATE_UNDEFINED;   /* state we started in */\n\n#define SEND_NOTIFICATION(t) { \\\n\t\tpstats(ikev1_sent_notifies_e, t); \\\n\t\tif (st != NULL) \\\n\t\t\tsend_notification_from_state(st, from_state, t); \\\n\t\telse \\\n\t\t\tsend_notification_from_md(md, t); }\n\n\tswitch (md->hdr.isa_xchg) {\n\tcase ISAKMP_XCHG_AGGR:\n\tcase ISAKMP_XCHG_IDPROT: /* part of a Main Mode exchange */\n\t\tif (md->hdr.isa_msgid != v1_MAINMODE_MSGID) {\n\t\t\tplog_md(md, \"Message ID was 0x%08\" PRIx32 \" but should be zero in phase 1\",\n\t\t\t\tmd->hdr.isa_msgid);\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {\n\t\t\tplog_md(md, \"Initiator Cookie must not be zero in phase 1 message\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {\n\t\t\t/*\n\t\t\t * initial message from initiator\n\t\t\t */\n\t\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\t\tplog_md(md, \"initial phase 1 message is invalid: its Encrypted Flag is on\");\n\t\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there is already an existing state with\n\t\t\t * this ICOOKIE, asssume it is some sort of\n\t\t\t * re-transmit.\n\t\t\t */\n\t\t\tst = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi,\n\t\t\t\t\t\t   md->hdr.isa_msgid);\n\t\t\tif (st != NULL) {\n\t\t\t\tso_serial_t old_state = push_cur_state(st);\n\t\t\t\tif (!ikev1_duplicate(st, md)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not a duplicate for the\n\t\t\t\t\t * current state; assume that\n\t\t\t\t\t * this a really old\n\t\t\t\t\t * re-transmit for an earlier\n\t\t\t\t\t * state that should be\n\t\t\t\t\t * discarded.\n\t\t\t\t\t */\n\t\t\t\t\tlog_state(RC_LOG, st, \"discarding initial packet; already %s\",\n\t\t\t\t\t\t  st->st_state->name);\n\t\t\t\t}\n\t\t\t\tpop_cur_state(old_state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpassert(st == NULL); /* new state needed */\n\t\t\t/* don't build a state until the message looks tasty */\n\t\t\tfrom_state = (md->hdr.isa_xchg == ISAKMP_XCHG_IDPROT ?\n\t\t\t\t      STATE_MAIN_R0 : STATE_AGGR_R0);\n\t\t} else {\n\t\t\t/* not an initial message */\n\n\t\t\tst = find_state_ikev1(&md->hdr.isa_ike_spis,\n\t\t\t\t\t      md->hdr.isa_msgid);\n\n\t\t\tif (st == NULL) {\n\t\t\t\t/*\n\t\t\t\t * perhaps this is a first message\n\t\t\t\t * from the responder and contains a\n\t\t\t\t * responder cookie that we've not yet\n\t\t\t\t * seen.\n\t\t\t\t */\n\t\t\t\tst = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi,\n\t\t\t\t\t\t\t   md->hdr.isa_msgid);\n\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tplog_md(md, \"phase 1 message is part of an unknown exchange\");\n\t\t\t\t\t/* XXX Could send notification back */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state->kind;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_INFO:  /* an informational exchange */\n\t\tst = find_v1_info_state(&md->hdr.isa_ike_spis,\n\t\t\t\t\tv1_MAINMODE_MSGID);\n\n\t\tif (st == NULL) {\n\t\t\t/*\n\t\t\t * might be an informational response to our\n\t\t\t * first message, in which case, we don't know\n\t\t\t * the rcookie yet.\n\t\t\t */\n\t\t\tst = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi,\n\t\t\t\t\t\t   v1_MAINMODE_MSGID);\n\t\t}\n\n\t\tif (st != NULL)\n\t\t\tset_cur_state(st);\n\n\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\t\tbool quiet = (st == NULL);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\t\tDBG_log(\"Informational Exchange is for an unknown (expired?) SA with MSGID:0x%08\" PRIx32,\n\t\t\t\t\t\tmd->hdr.isa_msgid);\n\t\t\t\t\tDBG_dump_thing(\"- unknown SA's md->hdr.isa_ike_initiator_spi.bytes:\",\n\t\t\t\t\t\t       md->hdr.isa_ike_initiator_spi);\n\t\t\t\t\tDBG_dump_thing(\"- unknown SA's md->hdr.isa_ike_responder_spi.bytes:\",\n\t\t\t\t\t\t       md->hdr.isa_ike_responder_spi);\n\t\t\t\t}\n\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IS_ISAKMP_ENCRYPTED(st->st_state->kind)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"encrypted Informational Exchange message is invalid because no key is known\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"Informational Exchange message is invalid because it has a Message ID of 0\");\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t\t  \"Informational Exchange message is invalid because it has a previously used Message ID (0x%08\" PRIx32 \" )\",\n\t\t\t\t\t\t  md->hdr.isa_msgid);\n\t\t\t\t}\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_v1_msgid.reserved = FALSE;\n\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_INFO_PROTECTED;\n\t\t} else {\n\t\t\tif (st != NULL &&\n\t\t\t    IS_ISAKMP_AUTHENTICATED(st->st_state)) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"Informational Exchange message must be encrypted\");\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfrom_state = STATE_INFO;\n\t\t}\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_QUICK: /* part of a Quick Mode exchange */\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {\n\t\t\tdbg(\"Quick Mode message is invalid because it has an Initiator Cookie of 0\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {\n\t\t\tdbg(\"Quick Mode message is invalid because it has a Responder Cookie of 0\");\n\t\t\tSEND_NOTIFICATION(INVALID_COOKIE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {\n\t\t\tdbg(\"Quick Mode message is invalid because it has a Message ID of 0\");\n\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\treturn;\n\t\t}\n\n\t\tst = find_state_ikev1(&md->hdr.isa_ike_spis,\n\t\t\t\t      md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\t/* No appropriate Quick Mode state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tst = find_state_ikev1(&md->hdr.isa_ike_spis,\n\t\t\t\t\t      v1_MAINMODE_MSGID);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tdbg(\"Quick Mode message is for a non-existent (expired?) ISAKMP SA\");\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tdbg(\"Cannot do Quick Mode until XAUTH done.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* Have we just given an IP address to peer? */\n\t\t\tif (st->st_state->kind == STATE_MODE_CFG_R2) {\n\t\t\t\t/* ISAKMP is up... */\n\t\t\t\tchange_state(st, STATE_MAIN_R3);\n\t\t\t}\n\n#ifdef SOFTREMOTE_CLIENT_WORKAROUND\n\t\t\t/* See: http://popoludnica.pl/?id=10100110 */\n\t\t\tif (st->st_state->kind == STATE_MODE_CFG_R1) {\n\t\t\t\tlog_state(RC_LOG, st,\n\t\t\t\t\t  \"SoftRemote workaround: Cannot do Quick Mode until MODECFG done.\");\n\t\t\t\treturn;\n\t\t\t}\n#endif\n\n\t\t\tset_cur_state(st);\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"Quick Mode message is unacceptable because it is for an incomplete ISAKMP SA\");\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED /* XXX ? */);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!unique_msgid(st, md->hdr.isa_msgid)) {\n\t\t\t\tlog_state(RC_LOG_SERIOUS, st,\n\t\t\t\t\t  \"Quick Mode I1 message is unacceptable because it uses a previously used Message ID 0x%08\" PRIx32 \" (perhaps this is a duplicated packet)\",\n\t\t\t\t\t  md->hdr.isa_msgid);\n\t\t\t\tSEND_NOTIFICATION(INVALID_MESSAGE_ID);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst->st_v1_msgid.reserved = FALSE;\n\n\t\t\t/* Quick Mode Initial IV */\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\tfrom_state = STATE_QUICK_R0;\n\t\t} else {\n\t\t\tif (st->st_oakley.doing_xauth) {\n\t\t\t\tlog_state(RC_LOG, st, \"Cannot do Quick Mode until XAUTH done.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state->kind;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_MODE_CFG:\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {\n\t\t\tdbg(\"Mode Config message is invalid because it has an Initiator Cookie of 0\");\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {\n\t\t\tdbg(\"Mode Config message is invalid because it has a Responder Cookie of 0\");\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tif (md->hdr.isa_msgid == 0) {\n\t\t\tdbg(\"Mode Config message is invalid because it has a Message ID of 0\");\n\t\t\t/* XXX Could send notification back */\n\t\t\treturn;\n\t\t}\n\n\t\tst = find_v1_info_state(&md->hdr.isa_ike_spis, md->hdr.isa_msgid);\n\n\t\tif (st == NULL) {\n\t\t\t/* No appropriate Mode Config state.\n\t\t\t * See if we have a Main Mode state.\n\t\t\t * ??? what if this is a duplicate of another message?\n\t\t\t */\n\t\t\tdbg(\"No appropriate Mode Config state yet. See if we have a Main Mode state\");\n\n\t\t\tst = find_v1_info_state(&md->hdr.isa_ike_spis, 0);\n\n\t\t\tif (st == NULL) {\n\t\t\t\tdbg(\"Mode Config message is for a non-existent (expired?) ISAKMP SA\");\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\t/* ??? ought to log something (not just DBG)? */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tset_cur_state(st);\n\n\t\t\tconst struct end *this = &st->st_connection->spd.this;\n\t\t\tdbg(\" processing received isakmp_xchg_type %s; this is a%s%s%s%s\",\n\t\t\t    enum_show(&ikev1_exchange_names, md->hdr.isa_xchg),\n\t\t\t    this->xauth_server ? \" xauthserver\" : \"\",\n\t\t\t    this->xauth_client ? \" xauthclient\" : \"\",\n\t\t\t    this->modecfg_server ? \" modecfgserver\" : \"\",\n\t\t\t    this->modecfg_client ? \" modecfgclient\" : \"\");\n\n\t\t\tif (!IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tdbg(\"Mode Config message is unacceptable because it is for an incomplete ISAKMP SA (state=%s)\",\n\t\t\t\t    st->st_state->name);\n\t\t\t\t/* XXX Could send notification back */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdbg(\" call  init_phase2_iv\");\n\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\tnew_iv_set = TRUE;\n\n\t\t\t/*\n\t\t\t * okay, now we have to figure out if we are receiving a bogus\n\t\t\t * new message in an outstanding XAUTH server conversation\n\t\t\t * (i.e. a reply to our challenge)\n\t\t\t * (this occurs with some broken other implementations).\n\t\t\t *\n\t\t\t * or if receiving for the first time, an XAUTH challenge.\n\t\t\t *\n\t\t\t * or if we are getting a MODECFG request.\n\t\t\t *\n\t\t\t * we distinguish these states because we cannot both be an\n\t\t\t * XAUTH server and client, and our policy tells us which\n\t\t\t * one we are.\n\t\t\t *\n\t\t\t * to complicate further, it is normal to start a new msgid\n\t\t\t * when going from one state to another, or when restarting\n\t\t\t * the challenge.\n\t\t\t *\n\t\t\t */\n\n\t\t\tif (this->xauth_server &&\n\t\t\t    st->st_state->kind == STATE_XAUTH_R1 &&\n\t\t\t    st->quirks.xauth_ack_msgid) {\n\t\t\t\tfrom_state = STATE_XAUTH_R1;\n\t\t\t\tdbg(\" set from_state to %s state is STATE_XAUTH_R1 and quirks.xauth_ack_msgid is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->xauth_client &&\n\t\t\t\t   IS_PHASE1(st->st_state->kind)) {\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tdbg(\" set from_state to %s this is xauthclient and IS_PHASE1() is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->xauth_client &&\n\t\t\t\t   st->st_state->kind == STATE_XAUTH_I1) {\n\t\t\t\t/*\n\t\t\t\t * in this case, we got a new MODECFG message after I0, maybe\n\t\t\t\t * because it wants to start over again.\n\t\t\t\t */\n\t\t\t\tfrom_state = STATE_XAUTH_I0;\n\t\t\t\tdbg(\" set from_state to %s this is xauthclient and state == STATE_XAUTH_I1\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->modecfg_server &&\n\t\t\t\t   IS_PHASE1(st->st_state->kind)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R0;\n\t\t\t\tdbg(\" set from_state to %s this is modecfgserver and IS_PHASE1() is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else if (this->modecfg_client &&\n\t\t\t\t   IS_PHASE1(st->st_state->kind)) {\n\t\t\t\tfrom_state = STATE_MODE_CFG_R1;\n\t\t\t\tdbg(\" set from_state to %s this is modecfgclient and IS_PHASE1() is TRUE\",\n\t\t\t\t    st->st_state->name);\n\t\t\t} else {\n\t\t\t\tdbg(\"received isakmp_xchg_type %s; this is a%s%s%s%s in state %s. Reply with UNSUPPORTED_EXCHANGE_TYPE\",\n\t\t\t\t    enum_show(&ikev1_exchange_names, md->hdr.isa_xchg),\n\t\t\t\t    st->st_connection ->spd.this.xauth_server ? \" xauthserver\" : \"\",\n\t\t\t\t    st->st_connection->spd.this.xauth_client ? \" xauthclient\" : \"\",\n\t\t\t\t    st->st_connection->spd.this.modecfg_server ? \" modecfgserver\" : \"\",\n\t\t\t\t    st->st_connection->spd.this.modecfg_client  ? \" modecfgclient\" : \"\",\n\t\t\t\t    st->st_state->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (st->st_connection->spd.this.xauth_server &&\n\t\t\t    IS_PHASE1(st->st_state->kind)) {\n\t\t\t\t/* Switch from Phase1 to Mode Config */\n\t\t\t\tdbg(\"We were in phase 1, with no state, so we went to XAUTH_R0\");\n\t\t\t\tchange_state(st, STATE_XAUTH_R0);\n\t\t\t}\n\n\t\t\t/* otherwise, this is fine, we continue in the state we are in */\n\t\t\tset_cur_state(st);\n\t\t\tfrom_state = st->st_state->kind;\n\t\t}\n\n\t\tbreak;\n\n\tcase ISAKMP_XCHG_NONE:\n\tcase ISAKMP_XCHG_BASE:\n\tcase ISAKMP_XCHG_AO:\n\tcase ISAKMP_XCHG_NGRP:\n\tdefault:\n\t\tdbg(\"unsupported exchange type %s in message\",\n\t\t    enum_show(&ikev1_exchange_names, md->hdr.isa_xchg));\n\t\tSEND_NOTIFICATION(UNSUPPORTED_EXCHANGE_TYPE);\n\t\treturn;\n\t}\n\n\t/* We have found a from_state, and perhaps a state object.\n\t * If we need to build a new state object,\n\t * we wait until the packet has been sanity checked.\n\t */\n\n\t/* We don't support the Commit Flag.  It is such a bad feature.\n\t * It isn't protected -- neither encrypted nor authenticated.\n\t * A man in the middle turns it on, leading to DoS.\n\t * We just ignore it, with a warning.\n\t */\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_COMMIT)\n\t\tdbg(\"IKE message has the Commit Flag set but Pluto doesn't implement this feature due to security concerns; ignoring flag\");\n\n\t/* Handle IKE fragmentation payloads */\n\tif (md->hdr.isa_np == ISAKMP_NEXT_IKE_FRAGMENTATION) {\n\t\tstruct isakmp_ikefrag fraghdr;\n\t\tint last_frag_index = 0;  /* index of the last fragment */\n\t\tpb_stream frag_pbs;\n\n\t\tif (st == NULL) {\n\t\t\tdbg(\"received IKE fragment, but have no state. Ignoring packet.\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((st->st_connection->policy & POLICY_IKE_FRAG_ALLOW) == 0) {\n\t\t\tdbg(\"discarding IKE fragment packet - fragmentation not allowed by local policy (ike_frag=no)\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!in_struct(&fraghdr, &isakmp_ikefrag_desc,\n\t\t\t       &md->message_pbs, &frag_pbs) ||\n\t\t    pbs_room(&frag_pbs) != fraghdr.isafrag_length ||\n\t\t    fraghdr.isafrag_np != ISAKMP_NEXT_NONE ||\n\t\t    fraghdr.isafrag_number == 0 ||\n\t\t    fraghdr.isafrag_number > 16) {\n\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\treturn;\n\t\t}\n\n\t\tdbg(\"received IKE fragment id '%d', number '%u'%s\",\n\t\t    fraghdr.isafrag_id,\n\t\t    fraghdr.isafrag_number,\n\t\t    (fraghdr.isafrag_flags == 1) ? \"(last)\" : \"\");\n\n\t\tstruct v1_ike_rfrag *ike_frag = alloc_thing(struct v1_ike_rfrag, \"ike_frag\");\n\t\tike_frag->md = md_addref(md, HERE);\n\t\tike_frag->index = fraghdr.isafrag_number;\n\t\tike_frag->last = (fraghdr.isafrag_flags & 1);\n\t\tike_frag->size = pbs_left(&frag_pbs);\n\t\tike_frag->data = frag_pbs.cur;\n\n\t\t/* Add the fragment to the state */\n\t\tstruct v1_ike_rfrag **i = &st->st_v1_rfrags;\n\t\tfor (;;) {\n\t\t\tif (ike_frag != NULL) {\n\t\t\t\t/* Still looking for a place to insert ike_frag */\n\t\t\t\tif (*i == NULL ||\n\t\t\t\t    (*i)->index > ike_frag->index) {\n\t\t\t\t\tike_frag->next = *i;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t} else if ((*i)->index == ike_frag->index) {\n\t\t\t\t\t/* Replace fragment with same index */\n\t\t\t\t\tstruct v1_ike_rfrag *old = *i;\n\n\t\t\t\t\tike_frag->next = old->next;\n\t\t\t\t\t*i = ike_frag;\n\t\t\t\t\tpexpect(old->md != NULL);\n\t\t\t\t\trelease_any_md(&old->md);\n\t\t\t\t\tpfree(old);\n\t\t\t\t\tike_frag = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*i == NULL)\n\t\t\t\tbreak;\n\n\t\t\tif ((*i)->last)\n\t\t\t\tlast_frag_index = (*i)->index;\n\n\t\t\ti = &(*i)->next;\n\t\t}\n\n\t\t/* We have the last fragment, reassemble if complete */\n\t\tif (last_frag_index != 0) {\n\t\t\tsize_t size = 0;\n\t\t\tint prev_index = 0;\n\n\t\t\tfor (struct v1_ike_rfrag *frag = st->st_v1_rfrags; frag; frag = frag->next) {\n\t\t\t\tsize += frag->size;\n\t\t\t\tif (frag->index != ++prev_index) {\n\t\t\t\t\tbreak; /* fragment list incomplete */\n\t\t\t\t} else if (frag->index == last_frag_index) {\n\t\t\t\t\tstruct msg_digest *whole_md = alloc_md(\"msg_digest by ikev1 fragment handler\");\n\t\t\t\t\tuint8_t *buffer = alloc_bytes(size,\n\t\t\t\t\t\t\t\t       \"IKE fragments buffer\");\n\t\t\t\t\tsize_t offset = 0;\n\n\t\t\t\t\twhole_md->iface = frag->md->iface;\n\t\t\t\t\twhole_md->sender = frag->md->sender;\n\n\t\t\t\t\t/* Reassemble fragments in buffer */\n\t\t\t\t\tfrag = st->st_v1_rfrags;\n\t\t\t\t\twhile (frag != NULL &&\n\t\t\t\t\t       frag->index <= last_frag_index)\n\t\t\t\t\t{\n\t\t\t\t\t\tpassert(offset + frag->size <=\n\t\t\t\t\t\t\tsize);\n\t\t\t\t\t\tmemcpy(buffer + offset,\n\t\t\t\t\t\t       frag->data, frag->size);\n\t\t\t\t\t\toffset += frag->size;\n\t\t\t\t\t\tfrag = frag->next;\n\t\t\t\t\t}\n\n\t\t\t\t\tinit_pbs(&whole_md->packet_pbs, buffer, size,\n\t\t\t\t\t\t \"packet\");\n\n\t\t\t\t\tprocess_packet(&whole_md);\n\t\t\t\t\trelease_any_md(&whole_md);\n\t\t\t\t\tfree_v1_message_queues(st);\n\t\t\t\t\t/* optimize: if receiving fragments, immediately respond with fragments too */\n\t\t\t\t\tst->st_seen_fragments = TRUE;\n\t\t\t\t\tdbg(\" updated IKE fragment state to respond using fragments without waiting for re-transmits\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Set smc to describe this state's properties.\n\t * Look up the appropriate microcode based on state and\n\t * possibly Oakley Auth type.\n\t */\n\tpassert(STATE_IKEv1_FLOOR <= from_state && from_state < STATE_IKEv1_ROOF);\n\tconst struct finite_state *fs = finite_states[from_state];\n\tpassert(fs != NULL);\n\tsmc = fs->v1_transitions;\n\tpassert(smc != NULL);\n\n\t/*\n\t * Find the state's the state transitions that has matching\n\t * authentication.\n\t *\n\t * For states where this makes no sense (eg, quick states\n\t * creating a CHILD_SA), .flags|=SMF_ALL_AUTH so the first\n\t * (only) one always matches.\n\t *\n\t * XXX: The code assums that when there is always a match (if\n\t * there isn't the passert() triggers.  If needed, bogus\n\t * transitions that log/drop the packet are added to the\n\t * table?  Would simply dropping the packets be easier.\n\t */\n\tif (st != NULL) {\n\t\toakley_auth_t baseauth =\n\t\t\txauth_calcbaseauth(st->st_oakley.auth);\n\n\t\twhile (!LHAS(smc->flags, baseauth)) {\n\t\t\tsmc++;\n\t\t\tpassert(smc->state == from_state);\n\t\t}\n\t}\n\n\t/*\n\t * XXX: do this earlier? */\n\tif (verbose_state_busy(st))\n\t\treturn;\n\n\t/*\n\t * Detect and handle duplicated packets.  This won't work for\n\t * the initial packet of an exchange because we won't have a\n\t * state object to remember it.  If we are in a non-receiving\n\t * state (terminal), and the preceding state did transmit,\n\t * then the duplicate may indicate that that transmission\n\t * wasn't received -- retransmit it.  Otherwise, just discard\n\t * it.  ??? Notification packets are like exchanges -- I hope\n\t * that they are idempotent!\n\t *\n\t * XXX: do this earlier?\n\t */\n\tif (st != NULL && ikev1_duplicate(st, md)) {\n\t\treturn;\n\t}\n\n\t/* save values for use in resumption of processing below.\n\t * (may be suspended due to crypto operation not yet complete)\n\t */\n\tmd->st = st;\n\tmd->v1_from_state = from_state;\n\tmd->smc = smc;\n\tmd->new_iv_set = new_iv_set;\n\n\t/*\n\t * look for encrypt packets. We cannot handle them if we have not\n\t * yet calculated the skeyids. We will just store the packet in\n\t * the suspended state, since the calculation is likely underway.\n\t *\n\t * note that this differs from above, because skeyid is calculated\n\t * in between states. (or will be, once DH is async)\n\t *\n\t */\n\tif ((md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) &&\n\t    st != NULL &&\n\t    !st->hidden_variables.st_skeyid_calculated) {\n\t\tendpoint_buf b;\n\t\tdbg(\"received encrypted packet from %s but exponentiation still in progress\",\n\t\t    str_endpoint(&md->sender, &b));\n\n\t\t/*\n\t\t * if there was a previous packet, let it go, and go\n\t\t * with most recent one.\n\t\t */\n\t\tif (st->st_suspended_md != NULL) {\n\t\t\tdbg(\"releasing suspended operation before completion: %p\",\n\t\t\t    st->st_suspended_md);\n\t\t\trelease_any_md(&st->st_suspended_md);\n\t\t}\n\t\tsuspend_any_md(st, md);\n\t\treturn;\n\t}\n\n\tprocess_packet_tail(md);\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n */\nvoid process_packet_tail(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tenum state_kind from_state = md->v1_from_state;\n\tconst struct state_v1_microcode *smc = md->smc;\n\tbool new_iv_set = md->new_iv_set;\n\tbool self_delete = FALSE;\n\n\tif (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {\n\t\tendpoint_buf b;\n\t\tdbg(\"received encrypted packet from %s\", str_endpoint(&md->sender, &b));\n\n\t\tif (st == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"discarding encrypted message for an unknown ISAKMP SA\");\n\t\t\treturn;\n\t\t}\n\t\tif (st->st_skeyid_e_nss == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\"discarding encrypted message because we haven't yet negotiated keying material\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Mark as encrypted */\n\t\tmd->encrypted = TRUE;\n\n\t\t/* do the specified decryption\n\t\t *\n\t\t * IV is from st->st_iv or (if new_iv_set) st->st_new_iv.\n\t\t * The new IV is placed in st->st_new_iv\n\t\t *\n\t\t * See RFC 2409 \"IKE\" Appendix B\n\t\t *\n\t\t * XXX The IV should only be updated really if the packet\n\t\t * is successfully processed.\n\t\t * We should keep this value, check for a success return\n\t\t * value from the parsing routines and then replace.\n\t\t *\n\t\t * Each post phase 1 exchange generates IVs from\n\t\t * the last phase 1 block, not the last block sent.\n\t\t */\n\t\tconst struct encrypt_desc *e = st->st_oakley.ta_encrypt;\n\n\t\tif (pbs_left(&md->message_pbs) % e->enc_blocksize != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"malformed message: not a multiple of encryption blocksize\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* XXX Detect weak keys */\n\n\t\t/* grab a copy of raw packet (for duplicate packet detection) */\n\t\tmd->raw_packet = clone_bytes_as_chunk(md->packet_pbs.start,\n\t\t\t\t\t\t      pbs_room(&md->packet_pbs),\n\t\t\t\t\t\t      \"raw packet\");\n\n\t\t/* Decrypt everything after header */\n\t\tif (!new_iv_set) {\n\t\t\tif (st->st_v1_iv.len == 0) {\n\t\t\t\tinit_phase2_iv(st, &md->hdr.isa_msgid);\n\t\t\t} else {\n\t\t\t\t/* use old IV */\n\t\t\t\trestore_new_iv(st, st->st_v1_iv);\n\t\t\t}\n\t\t}\n\n\t\tpassert(st->st_v1_new_iv.len >= e->enc_blocksize);\n\t\tst->st_v1_new_iv.len = e->enc_blocksize;   /* truncate */\n\n\t\tif (DBGP(DBG_CRYPT)) {\n\t\t\tDBG_log(\"decrypting %u bytes using algorithm %s\",\n\t\t\t\t(unsigned) pbs_left(&md->message_pbs),\n\t\t\t\tst->st_oakley.ta_encrypt->common.fqn);\n\t\t\tDBG_dump_hunk(\"IV before:\", st->st_v1_new_iv);\n\t\t}\n\t\te->encrypt_ops->do_crypt(e, md->message_pbs.cur,\n\t\t\t\t\t pbs_left(&md->message_pbs),\n\t\t\t\t\t st->st_enc_key_nss,\n\t\t\t\t\t st->st_v1_new_iv.ptr, FALSE);\n\t\tif (DBGP(DBG_CRYPT)) {\n\t\t\tDBG_dump_hunk(\"IV after:\", st->st_v1_new_iv);\n\t\t\tDBG_log(\"decrypted payload (starts at offset %td):\",\n\t\t\t\tmd->message_pbs.cur - md->message_pbs.roof);\n\t\t\tDBG_dump(NULL, md->message_pbs.start,\n\t\t\t\t md->message_pbs.roof - md->message_pbs.start);\n\t\t}\n\t} else {\n\t\t/* packet was not encryped -- should it have been? */\n\n\t\tif (smc->flags & SMF_INPUT_ENCRYPTED) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"packet rejected: should have been encrypted\");\n\t\t\tSEND_NOTIFICATION(INVALID_FLAGS);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Digest the message.\n\t * Padding must be removed to make hashing work.\n\t * Padding comes from encryption (so this code must be after decryption).\n\t * Padding rules are described before the definition of\n\t * struct isakmp_hdr in packet.h.\n\t */\n\t{\n\t\tenum next_payload_types_ikev1 np = md->hdr.isa_np;\n\t\tlset_t needed = smc->req_payloads;\n\t\tconst char *excuse =\n\t\t\tLIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT,\n\t\t\t    smc->flags) ?\n\t\t\t\"probable authentication failure (mismatch of preshared secrets?): \"\n\t\t\t:\n\t\t\t\"\";\n\n\t\twhile (np != ISAKMP_NEXT_NONE) {\n\t\t\tstruct_desc *sd = v1_payload_desc(np);\n\n\t\t\tif (md->digest_roof >= elemsof(md->digest)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"more than %zu payloads in message; ignored\",\n\t\t\t\t       elemsof(md->digest));\n\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstruct payload_digest *const pd = md->digest + md->digest_roof;\n\n\t\t\t/*\n\t\t\t * only do this in main mode. In aggressive mode, there\n\t\t\t * is no negotiation of NAT-T method. Get it right.\n\t\t\t */\n\t\t\tif (st != NULL && st->st_connection != NULL &&\n\t\t\t    (st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)\n\t\t\t{\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_NATD_RFC:\n\t\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t\tif ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * don't accept NAT-D/NAT-OA reloc directly in message,\n\t\t\t\t\t\t * unless we're using NAT-T RFC\n\t\t\t\t\t\t */\n\t\t\t\t\t\tDBG(DBG_NATT,\n\t\t\t\t\t\t    DBG_log(\"st_nat_traversal was: %s\",\n\t\t\t\t\t\t\t    bitnamesof(natt_bit_names,\n\t\t\t\t\t\t\t\t       st->hidden_variables.st_nat_traversal)));\n\t\t\t\t\t\tsd = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sd == NULL) {\n\t\t\t\t/* payload type is out of range or requires special handling */\n\t\t\t\tswitch (np) {\n\t\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\t\t\t/* ??? two kinds of ID payloads */\n\t\t\t\t\tsd = (IS_PHASE1(from_state) ||\n\t\t\t\t\t      IS_PHASE15(from_state)) ?\n\t\t\t\t\t\t&isakmp_identification_desc :\n\t\t\t\t\t\t&isakmp_ipsec_identification_desc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATD_DRAFTS: /* out of range */\n\t\t\t\t\t/*\n\t\t\t\t\t * ISAKMP_NEXT_NATD_DRAFTS was a private use type before RFC-3947.\n\t\t\t\t\t * Since it has the same format as ISAKMP_NEXT_NATD_RFC,\n\t\t\t\t\t * just rewrite np and sd, and carry on.\n\t\t\t\t\t */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATD_RFC;\n\t\t\t\t\tsd = &isakmp_nat_d_drafts;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_NATOA_DRAFTS: /* out of range */\n\t\t\t\t\t/* NAT-OA was a private use type before RFC-3947 -- same format */\n\t\t\t\t\tnp = ISAKMP_NEXT_NATOA_RFC;\n\t\t\t\t\tsd = &isakmp_nat_oa_drafts;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ISAKMP_NEXT_SAK: /* or ISAKMP_NEXT_NATD_BADDRAFTS */\n\t\t\t\t\t/*\n\t\t\t\t\t * Official standards say that this is ISAKMP_NEXT_SAK,\n\t\t\t\t\t * a part of Group DOI, something we don't implement.\n\t\t\t\t\t * Old non-updated Cisco gear abused this number in ancient NAT drafts.\n\t\t\t\t\t * We ignore (rather than reject) this in support of people\n\t\t\t\t\t * with crufty Cisco machines.\n\t\t\t\t\t */\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored\",\n\t\t\t\t\t\texcuse);\n\t\t\t\t\t/*\n\t\t\t\t\t * Hack to discard payload, whatever it was.\n\t\t\t\t\t * Since we are skipping the rest of the loop\n\t\t\t\t\t * body we must do some things ourself:\n\t\t\t\t\t * - demarshall the payload\n\t\t\t\t\t * - grab the next payload number (np)\n\t\t\t\t\t * - don't keep payload (don't increment pd)\n\t\t\t\t\t * - skip rest of loop body\n\t\t\t\t\t */\n\t\t\t\t\tif (!in_struct(&pd->payload, &isakmp_ignore_desc, &md->message_pbs,\n\t\t\t\t\t\t       &pd->pbs)) {\n\t\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t\t\t       excuse);\n\t\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\t\t\t/* NOTE: we do not increment pd! */\n\t\t\t\t\tcontinue;  /* skip rest of the loop */\n\n\t\t\t\tdefault:\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level\",\n\t\t\t\t\t       excuse,\n\t\t\t\t\t       enum_show(&ikev1_payload_names, np));\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpassert(sd != NULL);\n\t\t\t}\n\n\t\t\tpassert(np < LELEM_ROOF);\n\n\t\t\t{\n\t\t\t\tlset_t s = LELEM(np);\n\n\t\t\t\tif (LDISJOINT(s,\n\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tfinite_states[smc->state]->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));\n\t\t\t\tneeded &= ~s;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Read in the payload recording what type it\n\t\t\t * should be\n\t\t\t */\n\t\t\tpd->payload_type = np;\n\t\t\tif (!in_struct(&pd->payload, sd, &md->message_pbs,\n\t\t\t\t       &pd->pbs)) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"%smalformed payload in packet\",\n\t\t\t\t       excuse);\n\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* do payload-type specific debugging */\n\t\t\tswitch (np) {\n\t\t\tcase ISAKMP_NEXT_ID:\n\t\t\tcase ISAKMP_NEXT_NATOA_RFC:\n\t\t\t\t/* dump ID section */\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_dump(\"     obj: \", pd->pbs.cur,\n\t\t\t\t\t     pbs_left(&pd->pbs)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * Place payload at the end of the chain for this type.\n\t\t\t * This code appears in ikev1.c and ikev2.c.\n\t\t\t */\n\t\t\t{\n\t\t\t\t/* np is a proper subscript for chain[] */\n\t\t\t\tpassert(np < elemsof(md->chain));\n\t\t\t\tstruct payload_digest **p = &md->chain[np];\n\n\t\t\t\twhile (*p != NULL)\n\t\t\t\t\tp = &(*p)->next;\n\t\t\t\t*p = pd;\n\t\t\t\tpd->next = NULL;\n\t\t\t}\n\n\t\t\tnp = pd->payload.generic.isag_np;\n\t\t\tmd->digest_roof++;\n\n\t\t\t/* since we've digested one payload happily, it is probably\n\t\t\t * the case that any decryption worked.  So we will not suggest\n\t\t\t * encryption failure as an excuse for subsequent payload\n\t\t\t * problems.\n\t\t\t */\n\t\t\texcuse = \"\";\n\t\t}\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    if (pbs_left(&md->message_pbs) != 0)\n\t\t\t\t    DBG_log(\"removing %d bytes of padding\",\n\t\t\t\t\t    (int) pbs_left(&md->message_pbs));\n\t\t    });\n\n\t\tmd->message_pbs.roof = md->message_pbs.cur;\n\n\t\t/* check that all mandatory payloads appeared */\n\n\t\tif (needed != 0) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"message for %s is missing payloads %s\",\n\t\t\t       finite_states[from_state]->name,\n\t\t\t       bitnamesof(payload_name_ikev1, needed));\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!check_v1_HASH(smc->hash_type, smc->message, st, md)) {\n\t\t/*SEND_NOTIFICATION(INVALID_HASH_INFORMATION);*/\n\t\treturn;\n\t}\n\n\t/* more sanity checking: enforce most ordering constraints */\n\n\tif (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5 Exchanges:\n\t\t * \"The SA payload MUST precede all other payloads in a phase 1 exchange.\"\n\t\t */\n\t\tif (md->chain[ISAKMP_NEXT_SA] != NULL &&\n\t\t    md->hdr.isa_np != ISAKMP_NEXT_SA) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Phase 1 message: does not start with an SA payload\");\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t} else if (IS_QUICK(from_state)) {\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode\n\t\t *\n\t\t * \"In Quick Mode, a HASH payload MUST immediately follow the ISAKMP\n\t\t *  header and a SA payload MUST immediately follow the HASH.\"\n\t\t * [NOTE: there may be more than one SA payload, so this is not\n\t\t *  totally reasonable.  Probably all SAs should be so constrained.]\n\t\t *\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t *\n\t\t * \"With the exception of the HASH, SA, and the optional ID payloads,\n\t\t *  there are no payload ordering restrictions on Quick Mode.\"\n\t\t */\n\n\t\tif (md->hdr.isa_np != ISAKMP_NEXT_HASH) {\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"malformed Quick Mode message: does not start with a HASH payload\");\n\t\t\tif (!md->encrypted) {\n\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t{\n\t\t\tstruct payload_digest *p;\n\t\t\tint i;\n\n\t\t\tp = md->chain[ISAKMP_NEXT_SA];\n\t\t\ti = 1;\n\t\t\twhile (p != NULL) {\n\t\t\t\tif (p != &md->digest[i]) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"malformed Quick Mode message: SA payload is in wrong position\");\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tp = p->next;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* rfc2409: The Internet Key Exchange (IKE), 5.5 Phase 2 - Quick Mode:\n\t\t * \"If ISAKMP is acting as a client negotiator on behalf of another\n\t\t *  party, the identities of the parties MUST be passed as IDci and\n\t\t *  then IDcr.\"\n\t\t */\n\t\t{\n\t\t\tstruct payload_digest *id = md->chain[ISAKMP_NEXT_ID];\n\n\t\t\tif (id != NULL) {\n\t\t\t\tif (id->next == NULL ||\n\t\t\t\t    id->next->next != NULL) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"malformed Quick Mode message: if any ID payload is present, there must be exactly two\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (id + 1 != id->next) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"malformed Quick Mode message: the ID payloads are not adjacent\");\n\t\t\t\t\tSEND_NOTIFICATION(PAYLOAD_MALFORMED);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Ignore payloads that we don't handle:\n\t */\n\t/* XXX Handle Notifications */\n\t{\n\t\tstruct payload_digest *p = md->chain[ISAKMP_NEXT_N];\n\n\t\twhile (p != NULL) {\n\t\t\tswitch (p->payload.notification.isan_type) {\n\t\t\tcase R_U_THERE:\n\t\t\tcase R_U_THERE_ACK:\n\t\t\tcase ISAKMP_N_CISCO_LOAD_BALANCE:\n\t\t\tcase PAYLOAD_MALFORMED:\n\t\t\tcase INVALID_MESSAGE_ID:\n\t\t\tcase IPSEC_RESPONDER_LIFETIME:\n\t\t\t\tif (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {\n\t\t\t\t\t/* these are handled later on in informational() */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALL THROUGH */\n\t\t\tdefault:\n\t\t\t\tif (st == NULL) {\n\t\t\t\t\tDBG(DBG_CONTROL, DBG_log(\n\t\t\t\t\t       \"ignoring informational payload %s, no corresponding state\",\n\t\t\t\t\t       enum_show(& ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.notification.isan_type)));\n\t\t\t\t} else {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t       \"ignoring informational payload %s, msgid=%08\" PRIx32 \", length=%d\",\n\t\t\t\t\t       enum_show(&ikev1_notify_names,\n\t\t\t\t\t\t\t p->payload.notification.isan_type),\n\t\t\t\t\t       st->st_v1_msgid.id,\n\t\t\t\t\t       p->payload.notification.isan_length);\n\t\t\t\t\tDBG_dump_pbs(&p->pbs);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\tDBG_dump(\"info:\", p->pbs.cur,\n\t\t\t\t\t pbs_left(&p->pbs));\n\t\t\t}\n\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_D];\n\t\twhile (p != NULL) {\n\t\t\tself_delete |= accept_delete(md, p);\n\t\t\tif (DBGP(DBG_BASE)) {\n\t\t\t\tDBG_dump(\"del:\", p->pbs.cur,\n\t\t\t\t\t pbs_left(&p->pbs));\n\t\t\t}\n\t\t\tif (md->st != st) {\n\t\t\t\tpexpect(md->st == NULL);\n\t\t\t\tdbg(\"zapping ST as accept_delete() zapped MD.ST\");\n\t\t\t\tst = md->st;\n\t\t\t}\n\t\t\tp = p->next;\n\t\t}\n\n\t\tp = md->chain[ISAKMP_NEXT_VID];\n\t\twhile (p != NULL) {\n\t\t\thandle_vendorid(md, (char *)p->pbs.cur,\n\t\t\t\t\tpbs_left(&p->pbs), FALSE);\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (self_delete) {\n\t\taccept_self_delete(md);\n\t\tst = md->st;\n\t\t/* note: st ought to be NULL from here on */\n\t}\n\n\tpexpect(st == md->st);\n\tstatetime_t start = statetime_start(md->st);\n\t/*\n\t * XXX: danger - the .informational() processor deletes ST;\n\t * and then tunnels this loss through MD.ST.\n\t */\n\tcomplete_v1_state_transition(md, smc->processor(st, md));\n\tstatetime_stop(&start, \"%s()\", __func__);\n\t/* our caller will release_any_md(mdp); */\n}\n\n/*\n * replace previous receive packet with latest, to update\n * our notion of a retransmitted packet. This is important\n * to do, even for failing transitions, and suspended transitions\n * because the sender may well retransmit their request.\n * We had better be idempotent since we can be called\n * multiple times in handling a packet due to crypto helper logic.\n */\nstatic void remember_received_packet(struct state *st, struct msg_digest *md)\n{\n\tif (md->encrypted) {\n\t\t/* if encrypted, duplication already done */\n\t\tif (md->raw_packet.ptr != NULL) {\n\t\t\tpfreeany(st->st_v1_rpacket.ptr);\n\t\t\tst->st_v1_rpacket = md->raw_packet;\n\t\t\tmd->raw_packet = EMPTY_CHUNK;\n\t\t}\n\t} else {\n\t\t/* this may be a repeat, but it will work */\n\t\tfree_chunk_content(&st->st_v1_rpacket);\n\t\tst->st_v1_rpacket = clone_bytes_as_chunk(md->packet_pbs.start,\n\t\t\t\t\t\t      pbs_room(&md->packet_pbs),\n\t\t\t\t\t\t      \"raw packet\");\n\t}\n}\n\n/* complete job started by the state-specific state transition function\n *\n * This routine will not release_any_md(mdp).  It is expected that its\n * caller will do this.  In fact, it will zap *mdp to NULL if it thinks\n * **mdp should not be freed.  So the caller should be prepared for\n * *mdp being set to NULL.\n *\n * md is used to:\n * - find st\n * - find from_state (st might be gone)\n * - find note for STF_FAIL (might not be part of result (STF_FAIL+note))\n * - find note for STF_INTERNAL_ERROR\n * - record md->event_already_set\n * - remember_received_packet(st, md);\n * - nat_traversal_change_port_lookup(md, st);\n * - smc for smc->next_state\n * - smc for smc->flags & SMF_REPLY to trigger a reply\n * - smc for smc->timeout_event\n * - smc for !(smc->flags & SMF_INITIATOR) for Contivity mode\n * - smc for smc->flags & SMF_RELEASE_PENDING_P2 to trigger unpend call\n * - smc for smc->flags & SMF_INITIATOR to adjust retransmission\n * - fragvid, dpd, nortel\n */\nvoid complete_v1_state_transition(struct msg_digest *md, stf_status result)\n{\n\tpassert(md != NULL);\n\n\t/* handle oddball/meta results now */\n\n\t/*\n\t * statistics; lump all FAILs together\n\t *\n\t * Fun fact: using min() stupidly fails (at least in GCC 8.1.1 with -Werror=sign-compare)\n\t * error: comparison of integer expressions of different signedness: `stf_status' {aka `enum <anonymous>'} and `int'\n\t */\n\tpstats(ike_stf, PMIN(result, STF_FAIL));\n\n\tDBG(DBG_CONTROL,\n\t    DBG_log(\"complete v1 state transition with %s\",\n\t\t    result > STF_FAIL ?\n\t\t    enum_name(&ikev1_notify_names, result - STF_FAIL) :\n\t\t    enum_name(&stf_status_names, result)));\n\n\tswitch (result) {\n\tcase STF_SUSPEND:\n\t\tset_cur_state(md->st);\t/* might have changed */\n\t\t/*\n\t\t * If this transition was triggered by an incoming\n\t\t * packet, save it.\n\t\t *\n\t\t * XXX: some initiator code creates a fake MD (there\n\t\t * isn't a real one); save that as well.\n\t\t */\n\t\tsuspend_any_md(md->st, md);\n\t\treturn;\n\tcase STF_IGNORE:\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* safe to refer to *md */\n\n\tenum state_kind from_state = md->v1_from_state;\n\n\tstruct state *st = md->st;\n\tset_cur_state(st); /* might have changed */\n\n\tpassert(st != NULL);\n\tpexpect(!state_is_busy(st));\n\n\tif (result > STF_OK) {\n\t\tlinux_audit_conn(md->st, IS_IKE_SA_ESTABLISHED(md->st) ? LAK_CHILD_FAIL : LAK_PARENT_FAIL);\n\t}\n\n\tswitch (result) {\n\tcase STF_OK:\n\t{\n\t\t/* advance the state */\n\t\tconst struct state_v1_microcode *smc = md->smc;\n\n\t\tDBG(DBG_CONTROL, DBG_log(\"doing_xauth:%s, t_xauth_client_done:%s\",\n\t\t\tbool_str(st->st_oakley.doing_xauth),\n\t\t\tbool_str(st->hidden_variables.st_xauth_client_done)));\n\n\t\t/* accept info from VID because we accept this message */\n\n\t\t/*\n\t\t * Most of below VIDs only appear Main/Aggr mode, not Quick mode,\n\t\t * so why are we checking them for each state transition?\n\t\t */\n\n\t\tif (md->fragvid) {\n\t\t\tdbg(\"peer supports fragmentation\");\n\t\t\tst->st_seen_fragvid = TRUE;\n\t\t}\n\n\t\tif (md->dpd) {\n\t\t\tdbg(\"peer supports DPD\");\n\t\t\tst->hidden_variables.st_peer_supports_dpd = TRUE;\n\t\t\tif (dpd_active_locally(st)) {\n\t\t\t\tdbg(\"DPD is configured locally\");\n\t\t\t}\n\t\t}\n\n\t\t/* If state has VID_NORTEL, import it to activate workaround */\n\t\tif (md->nortel) {\n\t\t\tdbg(\"peer requires Nortel Contivity workaround\");\n\t\t\tst->st_seen_nortel_vid = TRUE;\n\t\t}\n\n\t\tif (!st->st_v1_msgid.reserved &&\n\t\t    IS_CHILD_SA(st) &&\n\t\t    st->st_v1_msgid.id != v1_MAINMODE_MSGID) {\n\t\t\tstruct state *p1st = state_with_serialno(\n\t\t\t\tst->st_clonedfrom);\n\n\t\t\tif (p1st != NULL) {\n\t\t\t\t/* do message ID reservation */\n\t\t\t\treserve_msgid(p1st, st->st_v1_msgid.id);\n\t\t\t}\n\n\t\t\tst->st_v1_msgid.reserved = TRUE;\n\t\t}\n\n\t\tdbg(\"IKEv1: transition from state %s to state %s\",\n\t\t    finite_states[from_state]->name,\n\t\t    finite_states[smc->next_state]->name);\n\n\t\tchange_state(st, smc->next_state);\n\n\t\t/*\n\t\t * XAUTH negotiation without ModeCFG cannot follow the regular\n\t\t * state machine change as it cannot be determined if the CFG\n\t\t * payload is \"XAUTH OK, no ModeCFG\" or \"XAUTH OK, expect\n\t\t * ModeCFG\". To the smc, these two cases look identical. So we\n\t\t * have an ad hoc state change here for the case where\n\t\t * we have XAUTH but not ModeCFG. We move it to the established\n\t\t * state, so the regular state machine picks up the Quick Mode.\n\t\t */\n\t\tif (st->st_connection->spd.this.xauth_client &&\n\t\t    st->hidden_variables.st_xauth_client_done &&\n\t\t    !st->st_connection->spd.this.modecfg_client &&\n\t\t    st->st_state->kind == STATE_XAUTH_I1)\n\t\t{\n\t\t\tbool aggrmode = LHAS(st->st_connection->policy, POLICY_AGGRESSIVE_IX);\n\n\t\t\tlibreswan_log(\"XAUTH completed; ModeCFG skipped as per configuration\");\n\t\t\tchange_state(st, aggrmode ? STATE_AGGR_I2 : STATE_MAIN_I4);\n\t\t\tst->st_v1_msgid.phase15 = v1_MAINMODE_MSGID;\n\t\t}\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\t/*\n\t\t\t * This md variable is hardly ever set.\n\t\t\t * Only deals with v1 <-> v2 switching\n\t\t\t * which will be removed in the near future anyway\n\t\t\t * (PW 2017 Oct 8)\n\t\t\t */\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"event_already_set, deleting event\"));\n\t\t\t/*\n\t\t\t * Delete previous retransmission event.\n\t\t\t * New event will be scheduled below.\n\t\t\t */\n\t\t\tdelete_event(st);\n\t\t\tclear_retransmits(st);\n\t\t}\n\n\t\t/* Delete IKE fragments */\n\t\tfree_v1_message_queues(st);\n\n\t\t/* scrub the previous packet exchange */\n\t\tfree_chunk_content(&st->st_v1_rpacket);\n\t\tfree_chunk_content(&st->st_v1_tpacket);\n\n\t\t/* in aggressive mode, there will be no reply packet in transition\n\t\t * from STATE_AGGR_R1 to STATE_AGGR_R2\n\t\t */\n\t\tif (nat_traversal_enabled && st->st_connection->ikev1_natt != NATT_NONE) {\n\t\t\t/* adjust our destination port if necessary */\n\t\t\tnat_traversal_change_port_lookup(md, st);\n\t\t\tv1_maybe_natify_initiator_endpoints(st, HERE);\n\t\t}\n\n\t\t/*\n\t\t * Save both the received packet, and this\n\t\t * state-transition.\n\t\t *\n\t\t * Only when the (last) state transition was a \"reply\"\n\t\t * should a duplicate packet trigger a retransmit\n\t\t * (else they get discarded).\n\t\t *\n\t\t * XXX: .st_state .fs_flags & SMF_REPLY can't\n\t\t * be used because it contains flags for the new state\n\t\t * not the old-to-new state transition.\n\t\t */\n\t\tremember_received_packet(st, md);\n\t\tst->st_v1_last_transition = md->smc;\n\n\t\t/* if requested, send the new reply packet */\n\t\tif (smc->flags & SMF_REPLY) {\n\t\t\tendpoint_buf b;\n\t\t\tendpoint_buf b2;\n\t\t\tpexpect_st_local_endpoint(st);\n\t\t\tdbg(\"sending reply packet to %s (from %s)\",\n\t\t\t    str_endpoint(&st->st_remote_endpoint, &b),\n\t\t\t    str_endpoint(&st->st_interface->local_endpoint, &b2));\n\n\t\t\tclose_output_pbs(&reply_stream); /* good form, but actually a no-op */\n\n\t\t\tif (st->st_state->kind == STATE_MAIN_R2 &&\n\t\t\t\timpair.send_no_main_r2) {\n\t\t\t\t/* record-only so we propely emulate packet drop */\n\t\t\t\trecord_outbound_v1_ike_msg(st, &reply_stream,\n\t\t\t\t\t\t\t   finite_states[from_state]->name);\n\t\t\t\tlibreswan_log(\"IMPAIR: Skipped sending STATE_MAIN_R2 response packet\");\n\t\t\t} else {\n\t\t\t\trecord_and_send_v1_ike_msg(st, &reply_stream,\n\t\t\t\t\t\t\t   finite_states[from_state]->name);\n\t\t\t}\n\t\t}\n\n\t\t/* Schedule for whatever timeout is specified */\n\t\tif (!md->event_already_set) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"!event_already_set at reschedule\"));\n\t\t\tintmax_t delay_ms; /* delay is in milliseconds here */\n\t\t\tenum event_type kind = smc->timeout_event;\n\t\t\tbool agreed_time = FALSE;\n\t\t\tstruct connection *c = st->st_connection;\n\n\t\t\t/* fixup in case of state machine jump for xauth without modecfg */\n\t\t\tif (c->spd.this.xauth_client &&\n\t\t\t    st->hidden_variables.st_xauth_client_done &&\n\t\t\t    !c->spd.this.modecfg_client &&\n\t\t\t    (st->st_state->kind == STATE_MAIN_I4 || st->st_state->kind == STATE_AGGR_I2))\n\t\t\t{\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\"fixup XAUTH without ModeCFG event from EVENT_RETRANSMIT to EVENT_SA_REPLACE\"));\n\t\t\t\tkind = EVENT_SA_REPLACE;\n\t\t\t}\n\n\t\t\tswitch (kind) {\n\t\t\tcase EVENT_RETRANSMIT: /* Retransmit packet */\n\t\t\t\tstart_retransmits(st);\n\t\t\t\tbreak;\n\n\t\t\tcase EVENT_SA_REPLACE: /* SA replacement event */\n\t\t\t\tif (IS_PHASE1(st->st_state->kind) ||\n\t\t\t\t    IS_PHASE15(st->st_state->kind)) {\n\t\t\t\t\t/* Note: we will defer to the \"negotiated\" (dictated)\n\t\t\t\t\t * lifetime if we are POLICY_DONT_REKEY.\n\t\t\t\t\t * This allows the other side to dictate\n\t\t\t\t\t * a time we would not otherwise accept\n\t\t\t\t\t * but it prevents us from having to initiate\n\t\t\t\t\t * rekeying.  The negative consequences seem\n\t\t\t\t\t * minor.\n\t\t\t\t\t */\n\t\t\t\t\tdelay_ms = deltamillisecs(c->sa_ike_life_seconds);\n\t\t\t\t\tif ((c->policy & POLICY_DONT_REKEY) ||\n\t\t\t\t\t    delay_ms >= deltamillisecs(st->st_oakley.life_seconds))\n\t\t\t\t\t{\n\t\t\t\t\t\tagreed_time = TRUE;\n\t\t\t\t\t\tdelay_ms = deltamillisecs(st->st_oakley.life_seconds);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Delay is min of up to four things:\n\t\t\t\t\t * each can limit the lifetime.\n\t\t\t\t\t */\n\t\t\t\t\ttime_t delay = deltasecs(c->sa_ipsec_life_seconds);\n\n#define clamp_delay(trans) { \\\n\t\tif (st->trans.present && \\\n\t\t    delay >= deltasecs(st->trans.attrs.life_seconds)) { \\\n\t\t\tagreed_time = TRUE; \\\n\t\t\tdelay = deltasecs(st->trans.attrs.life_seconds); \\\n\t\t} \\\n\t}\n\t\t\t\t\tclamp_delay(st_ah);\n\t\t\t\t\tclamp_delay(st_esp);\n\t\t\t\t\tclamp_delay(st_ipcomp);\n\t\t\t\t\tdelay_ms = delay * 1000;\n#undef clamp_delay\n\t\t\t\t}\n\n\t\t\t\t/* By default, we plan to rekey.\n\t\t\t\t *\n\t\t\t\t * If there isn't enough time to rekey, plan to\n\t\t\t\t * expire.\n\t\t\t\t *\n\t\t\t\t * If we are --dontrekey, a lot more rules apply.\n\t\t\t\t * If we are the Initiator, use REPLACE_IF_USED.\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * was unacceptable (too large), plan to REPLACE\n\t\t\t\t * (the only way to ratchet down the time).\n\t\t\t\t * If we are the Responder, and the dictated time\n\t\t\t\t * is acceptable, plan to EXPIRE.\n\t\t\t\t *\n\t\t\t\t * Important policy lies buried here.\n\t\t\t\t * For example, we favour the initiator over the\n\t\t\t\t * responder by making the initiator start rekeying\n\t\t\t\t * sooner.  Also, fuzz is only added to the\n\t\t\t\t * initiator's margin.\n\t\t\t\t *\n\t\t\t\t * Note: for ISAKMP SA, we let the negotiated\n\t\t\t\t * time stand (implemented by earlier logic).\n\t\t\t\t */\n\t\t\t\tif (agreed_time &&\n\t\t\t\t    (c->policy & POLICY_DONT_REKEY)) {\n\t\t\t\t\tkind = (smc->flags & SMF_INITIATOR) ?\n\t\t\t\t\t       EVENT_v1_SA_REPLACE_IF_USED :\n\t\t\t\t\t       EVENT_SA_EXPIRE;\n\t\t\t\t}\n\t\t\t\tif (kind != EVENT_SA_EXPIRE) {\n\t\t\t\t\ttime_t marg =\n\t\t\t\t\t\tdeltasecs(c->sa_rekey_margin);\n\n\t\t\t\t\tif (smc->flags & SMF_INITIATOR) {\n\t\t\t\t\t\tmarg += marg *\n\t\t\t\t\t\t\tc->sa_rekey_fuzz /\n\t\t\t\t\t\t\t100.E0 *\n\t\t\t\t\t\t\t(rand() /\n\t\t\t\t\t\t\t (RAND_MAX + 1.E0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarg /= 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (delay_ms > marg * 1000) {\n\t\t\t\t\t\tdelay_ms -= marg * 1000;\n\t\t\t\t\t\tst->st_replace_margin = deltatime(marg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkind = EVENT_SA_EXPIRE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* XXX: DELAY_MS should be a deltatime_t */\n\t\t\t\tevent_schedule(kind, deltatime_ms(delay_ms), st);\n\t\t\t\tbreak;\n\n\t\t\tcase EVENT_SO_DISCARD:\n\t\t\t\tevent_schedule(EVENT_SO_DISCARD, c->r_timeout, st);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbad_case(kind);\n\t\t\t}\n\t\t}\n\n\t\t/* tell whack and log of progress */\n\t\t{\n\t\t\tenum rc_type w;\n\t\t\tvoid (*log_details)(struct lswlog *buf, struct state *st);\n\n\t\t\tif (IS_IPSEC_SA_ESTABLISHED(st)) {\n\t\t\t\tpstat_sa_established(st);\n\t\t\t\tlog_details = lswlog_child_sa_established;\n\t\t\t\tw = RC_SUCCESS; /* log our success */\n\t\t\t} else if (IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tpstat_sa_established(st);\n\t\t\t\tlog_details = lswlog_ike_sa_established;\n\t\t\t\tw = RC_SUCCESS; /* log our success */\n\t\t\t} else {\n\t\t\t\tlog_details = NULL;\n\t\t\t\tw = RC_NEW_V1_STATE + st->st_state->kind;\n\t\t\t}\n\n\t\t\tpassert(st->st_state->kind < STATE_IKEv1_ROOF);\n\n\t\t\t/* tell whack and logs our progress */\n\t\t\tLSWLOG_RC(w, buf) {\n\t\t\t\tlswlogf(buf, \"%s: %s\", st->st_state->name,\n\t\t\t\t\tst->st_state->story);\n\t\t\t\t/* document SA details for admin's pleasure */\n\t\t\t\tif (log_details != NULL) {\n\t\t\t\t\tlog_details(buf, st);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * make sure that a DPD event gets created for a new phase 1\n\t\t * SA.\n\t\t * Why do we need a DPD event on an IKE SA???\n\t\t */\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\tif (dpd_init(st) != STF_OK) {\n\t\t\t\tloglog(RC_LOG_SERIOUS, \"DPD initialization failed - continuing without DPD\");\n\t\t\t}\n\t\t}\n\n\t\t/* Special case for XAUTH server */\n\t\tif (st->st_connection->spd.this.xauth_server) {\n\t\t\tif (st->st_oakley.doing_xauth &&\n\t\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state)) {\n\t\t\t\tDBG(DBG_CONTROLMORE|DBG_XAUTH,\n\t\t\t\t    DBG_log(\"XAUTH: Sending XAUTH Login/Password Request\"));\n\t\t\t\tevent_schedule(EVENT_v1_SEND_XAUTH,\n\t\t\t\t\t       deltatime_ms(EVENT_v1_SEND_XAUTH_DELAY_MS),\n\t\t\t\t\t       st);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * for XAUTH client, we are also done, because we need to\n\t\t * stay in this state, and let the server query us\n\t\t */\n\t\tif (!IS_QUICK(st->st_state->kind) &&\n\t\t    st->st_connection->spd.this.xauth_client &&\n\t\t    !st->hidden_variables.st_xauth_client_done) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"XAUTH client is not yet authenticated\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * when talking to some vendors, we need to initiate a mode\n\t\t * cfg request to get challenged, but there is also an\n\t\t * override in the form of a policy bit.\n\t\t */\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"modecfg pull: %s policy:%s %s\",\n\t\t\t    (st->quirks.modecfg_pull_mode ?\n\t\t\t     \"quirk-poll\" : \"noquirk\"),\n\t\t\t    (st->st_connection->policy & POLICY_MODECFG_PULL) ?\n\t\t\t    \"pull\" : \"push\",\n\t\t\t    (st->st_connection->spd.this.modecfg_client ?\n\t\t\t     \"modecfg-client\" : \"not-client\")));\n\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    (st->quirks.modecfg_pull_mode ||\n\t\t     st->st_connection->policy & POLICY_MODECFG_PULL) &&\n\t\t    !st->hidden_variables.st_modecfg_started) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"modecfg client is starting due to %s\",\n\t\t\t\t    st->quirks.modecfg_pull_mode ? \"quirk\" :\n\t\t\t\t    \"policy\"));\n\t\t\tmodecfg_send_request(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Should we set the peer's IP address regardless? */\n\t\tif (st->st_connection->spd.this.modecfg_server &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set &&\n\t\t    !(st->st_connection->policy & POLICY_MODECFG_PULL)) {\n\t\t\tchange_state(st, STATE_MODE_CFG_R1);\n\t\t\tset_cur_state(st);\n\t\t\tlibreswan_log(\"Sending MODE CONFIG set\");\n\t\t\t/*\n\t\t\t * ??? we ignore the result of modecfg.\n\t\t\t * But surely, if it fails, we ought to terminate this exchange.\n\t\t\t * What do the RFCs say?\n\t\t\t */\n\t\t\tmodecfg_start_set(st);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we are the responder and the client is in \"Contivity mode\",\n\t\t * we need to initiate Quick mode\n\t\t */\n\t\tif (!(smc->flags & SMF_INITIATOR) &&\n\t\t    IS_MODE_CFG_ESTABLISHED(st->st_state) &&\n\t\t    (st->st_seen_nortel_vid)) {\n\t\t\tlibreswan_log(\"Nortel 'Contivity Mode' detected, starting Quick Mode\");\n\t\t\tchange_state(st, STATE_MAIN_R3); /* ISAKMP is up... */\n\t\t\tset_cur_state(st);\n\t\t\tquick_outI1(st->st_whack_sock, st, st->st_connection,\n\t\t\t\t    st->st_connection->policy, 1, SOS_NOBODY,\n\t\t\t\t    NULL /* Setting NULL as this is responder and will not have sec ctx from a flow*/\n\t\t\t\t    );\n\t\t\tbreak;\n\t\t}\n\n\t\t/* wait for modecfg_set */\n\t\tif (st->st_connection->spd.this.modecfg_client &&\n\t\t    IS_ISAKMP_SA_ESTABLISHED(st->st_state) &&\n\t\t    !st->hidden_variables.st_modecfg_vars_set) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"waiting for modecfg set from server\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\"phase 1 is done, looking for phase 2 to unpend\"));\n\n\t\tif (smc->flags & SMF_RELEASE_PENDING_P2) {\n\t\t\t/* Initiate any Quick Mode negotiations that\n\t\t\t * were waiting to piggyback on this Keying Channel.\n\t\t\t *\n\t\t\t * ??? there is a potential race condition\n\t\t\t * if we are the responder: the initial Phase 2\n\t\t\t * message might outrun the final Phase 1 message.\n\t\t\t *\n\t\t\t * so, instead of actually sending the traffic now,\n\t\t\t * we schedule an event to do so.\n\t\t\t *\n\t\t\t * but, in fact, quick_mode will enqueue a cryptographic operation\n\t\t\t * anyway, which will get done \"later\" anyway, so maybe it is just fine\n\t\t\t * as it is.\n\t\t\t *\n\t\t\t */\n\t\t\tunpend(pexpect_ike_sa(st), NULL);\n\t\t}\n\n\t\tif (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||\n\t\t    IS_IPSEC_SA_ESTABLISHED(st))\n\t\t\trelease_any_whack(st, HERE, \"IKEv1 transitions finished\");\n\n\t\tif (IS_QUICK(st->st_state->kind))\n\t\t\tbreak;\n\n\t\tbreak;\n\t}\n\n\tcase STF_INTERNAL_ERROR:\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\t\tlog_state(RC_INTERNALERR + md->v1_note, st,\n\t\t\t  \"state transition function for %s had internal error\",\n\t\t\t  st->st_state->name);\n\t\trelease_pending_whacks(st, \"internal error\");\n\t\tbreak;\n\n\tcase STF_FATAL:\n\t\tpassert(st != NULL);\n\t\t/* update the previous packet history */\n\t\tremember_received_packet(st, md);\n\t\tlog_state(RC_FATAL, st, \"encountered fatal error in state %s\",\n\t\t\t  st->st_state->name);\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\trelease_pending_whacks(st, \"fatal error\");\n\t\tdelete_state(st);\n\t\tmd->st = st = NULL;\n\t\tbreak;\n\n\tdefault:        /* a shortcut to STF_FAIL, setting md->note */\n\t\tpassert(result > STF_FAIL);\n\t\tmd->v1_note = result - STF_FAIL;\n\t\t/* FALL THROUGH */\n\tcase STF_FAIL:\n\t{\n\t\t/* As it is, we act as if this message never happened:\n\t\t * whatever retrying was in place, remains in place.\n\t\t */\n\t\t/*\n\t\t * Try to convert the notification into a non-NULL\n\t\t * string.  For NOTHING_WRONG, be vague (at the time\n\t\t * of writing the enum_names didn't contain\n\t\t * NOTHING_WRONG, and even if it did \"nothing wrong\"\n\t\t * wouldn't exactly help here :-).\n\t\t */\n\t\tconst char *notify_name = (md->v1_note == NOTHING_WRONG ? \"failed\" :\n\t\t\t\t\t   enum_name(&ikev1_notify_names, md->v1_note));\n\t\tif (notify_name == NULL) {\n\t\t\tnotify_name = \"internal error\";\n\t\t}\n\t\t/*\n\t\t * ??? why no call of remember_received_packet?\n\t\t * Perhaps because the message hasn't been authenticated?\n\t\t * But then then any duplicate would lose too, I would think.\n\t\t */\n\n\t\tif (md->v1_note != NOTHING_WRONG) {\n\t\t\t/* this will log */\n\t\t\tSEND_NOTIFICATION(md->v1_note);\n\t\t} else {\n\t\t\t/* XXX: why whack only? */\n\t\t\tlog_state(WHACK_STREAM | (RC_NOTIFICATION + md->v1_note), st,\n\t\t\t\t  \"state transition failed: %s\", notify_name);\n\t\t}\n\n\t\tdbg(\"state transition function for %s failed: %s\",\n\t\t    st->st_state->name, notify_name);\n\n#ifdef HAVE_NM\n\t\tif (st->st_connection->remotepeertype == CISCO &&\n\t\t    st->st_connection->nmconfigured) {\n\t\t\tif (!do_command(st->st_connection,\n\t\t\t\t\t&st->st_connection->spd,\n\t\t\t\t\t\"disconnectNM\", st))\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\"sending disconnect to NM failed, you may need to do it manually\"));\n\t\t}\n#endif\n\t\tif (IS_QUICK(st->st_state->kind)) {\n\t\t\tdelete_state(st);\n\t\t\t/* wipe out dangling pointer to st */\n\t\t\tmd->st = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n}\n\n/*\n * note: may change which connection is referenced by md->st->st_connection.\n * But only if we are a Main Mode Responder.\n */\nbool ikev1_decode_peer_id(struct msg_digest *md, bool initiator, bool aggrmode)\n{\n\tstruct state *const st = md->st;\n\tstruct connection *c = st->st_connection;\n\tconst struct payload_digest *const id_pld = md->chain[ISAKMP_NEXT_ID];\n\tconst struct isakmp_id *const id = &id_pld->payload.id;\n\n\t/*\n\t * I think that RFC2407 (IPSEC DOI) 4.6.2 is confused.\n\t * It talks about the protocol ID and Port fields of the ID\n\t * Payload, but they don't exist as such in Phase 1.\n\t * We use more appropriate names.\n\t * isaid_doi_specific_a is in place of Protocol ID.\n\t * isaid_doi_specific_b is in place of Port.\n\t * Besides, there is no good reason for allowing these to be\n\t * other than 0 in Phase 1.\n\t */\n\tif (st->hidden_variables.st_nat_traversal != LEMPTY &&\n\t    id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t    (id->isaid_doi_specific_b == 0 ||\n\t     id->isaid_doi_specific_b == pluto_nat_port)) {\n\t\tDBG_log(\"protocol/port in Phase 1 ID Payload is %d/%d. accepted with port_floating NAT-T\",\n\t\t\tid->isaid_doi_specific_a, id->isaid_doi_specific_b);\n\t} else if (!(id->isaid_doi_specific_a == 0 &&\n\t\t     id->isaid_doi_specific_b == 0) &&\n\t\t   !(id->isaid_doi_specific_a == IPPROTO_UDP &&\n\t\t     id->isaid_doi_specific_b == pluto_port))\n\t{\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\"protocol/port in Phase 1 ID Payload MUST be 0/0 or %d/%d but are %d/%d (attempting to continue)\",\n\t\t\tIPPROTO_UDP, pluto_port,\n\t\t\tid->isaid_doi_specific_a,\n\t\t\tid->isaid_doi_specific_b);\n\t\t/*\n\t\t * We have turned this into a warning because of bugs in other\n\t\t * vendors' products. Specifically CISCO VPN3000.\n\t\t */\n\t\t/* return FALSE; */\n\t}\n\n\tstruct id peer;\n\n\tif (!extract_peer_id(id->isaid_idtype, &peer, &id_pld->pbs))\n\t\treturn FALSE;\n\n\tif (c->spd.that.id.kind == ID_FROMCERT) {\n\t\t/* breaks API, connection modified by %fromcert */\n\t\tduplicate_id(&c->spd.that.id, &peer);\n\t}\n\n\t/*\n\t * For interop with SoftRemote/aggressive mode we need to remember some\n\t * things for checking the hash\n\t */\n\tst->st_peeridentity_protocol = id->isaid_doi_specific_a;\n\tst->st_peeridentity_port = ntohs(id->isaid_doi_specific_b);\n\n\t{\n\t\tid_buf buf;\n\n\t\tlibreswan_log(\"Peer ID is %s: '%s'\",\n\t\t\tenum_show(&ike_idtype_names, id->isaid_idtype),\n\t\t\tstr_id(&peer, &buf));\n\t}\n\n\t/* check for certificates */\n\tif (!v1_verify_certs(md)) {\n\t\tlibreswan_log(\"X509: CERT payload does not match connection ID\");\n\t\tif (initiator || aggrmode) {\n\t\t\t/* cannot switch connection so fail */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* check for certificate requests */\n\tikev1_decode_cr(md);\n\n\t/*\n\t * Now that we've decoded the ID payload, let's see if we\n\t * need to switch connections.\n\t * Aggressive mode cannot switch connections.\n\t * We must not switch horses if we initiated:\n\t * - if the initiation was explicit, we'd be ignoring user's intent\n\t * - if opportunistic, we'll lose our HOLD info\n\t */\n\n\tif (initiator) {\n\t\tif (!st->st_peer_alt_id &&\n\t\t    !same_id(&c->spd.that.id, &peer) &&\n\t\t    c->spd.that.id.kind != ID_FROMCERT) {\n\t\t\tid_buf expect;\n\t\t\tid_buf found;\n\n\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t       \"we require IKEv1 peer to have ID '%s', but peer declares '%s'\",\n\t\t\t       str_id(&c->spd.that.id, &expect),\n\t\t\t       str_id(&peer, &found));\n\t\t\treturn FALSE;\n\t\t} else if (c->spd.that.id.kind == ID_FROMCERT) {\n\t\t\tif (peer.kind != ID_DER_ASN1_DN) {\n\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t       \"peer ID is not a certificate type\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tduplicate_id(&c->spd.that.id, &peer);\n\t\t}\n\t} else if (!aggrmode) {\n\t\t/* Main Mode Responder */\n\t\tuint16_t auth = xauth_calcbaseauth(st->st_oakley.auth);\n\t\tlset_t auth_policy;\n\n\t\tswitch (auth) {\n\t\tcase OAKLEY_PRESHARED_KEY:\n\t\t\tauth_policy = POLICY_PSK;\n\t\t\tbreak;\n\t\tcase OAKLEY_RSA_SIG:\n\t\t\tauth_policy = POLICY_RSASIG;\n\t\t\tbreak;\n\t\t/* Not implemented */\n\t\tcase OAKLEY_DSS_SIG:\n\t\tcase OAKLEY_RSA_ENC:\n\t\tcase OAKLEY_RSA_REVISED_MODE:\n\t\tcase OAKLEY_ECDSA_P256:\n\t\tcase OAKLEY_ECDSA_P384:\n\t\tcase OAKLEY_ECDSA_P521:\n\t\tdefault:\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"ikev1 ike_decode_peer_id bad_case due to not supported policy\"));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tbool fromcert;\n\t\tstruct connection *r =\n\t\t\trefine_host_connection(st, &peer,\n\t\t\t\tNULL, /* IKEv1 does not support 'you Tarzan, me Jane' */\n\t\t\t\tFALSE,\t/* we are responder */\n\t\t\t\tauth_policy,\n\t\t\t\tAUTHBY_UNSET,\t/* ikev2 only */\n\t\t\t\t&fromcert);\n\n\t\tif (r == NULL) {\n\t\t\tDBG(DBG_CONTROL, {\n\t\t\t\tid_buf buf;\n\n\t\t\t\tDBG_log(\"no more suitable connection for peer '%s'\",\n\t\t\t\t\tstr_id(&peer, &buf));\n\t\t\t});\n\t\t\t/* can we continue with what we had? */\n\t\t\tif (!md->st->st_peer_alt_id &&\n\t\t\t    !same_id(&c->spd.that.id, &peer) &&\n\t\t\t    c->spd.that.id.kind != ID_FROMCERT) {\n\t\t\t\t\tlibreswan_log(\"Peer mismatch on first found connection and no better connection found\");\n\t\t\t\t\treturn FALSE;\n\t\t\t} else {\n\t\t\t\tDBG(DBG_CONTROL, DBG_log(\"Peer ID matches and no better connection found - continuing with existing connection\"));\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\n\t\tif (DBGP(DBG_BASE)) {\n\t\t\tdn_buf buf;\n\t\t\tDBG_log(\"offered CA: '%s'\",\n\t\t\t\tstr_dn_or_null(r->spd.this.ca, \"%none\", &buf));\n\t\t}\n\n\t\tif (r != c) {\n\t\t\t/*\n\t\t\t * We are changing st->st_connection!\n\t\t\t * Our caller might be surprised!\n\t\t\t */\n\t\t\tchar b1[CONN_INST_BUF];\n\t\t\tchar b2[CONN_INST_BUF];\n\n\t\t\t/* apparently, r is an improvement on c -- replace */\n\t\t\tlibreswan_log(\"switched from \\\"%s\\\"%s to \\\"%s\\\"%s\",\n\t\t\t\tc->name,\n\t\t\t\tfmt_conn_instance(c, b1),\n\t\t\t\tr->name,\n\t\t\t\tfmt_conn_instance(r, b2));\n\n\t\t\tif (r->kind == CK_TEMPLATE || r->kind == CK_GROUP) {\n\t\t\t\t/* instantiate it, filling in peer's ID */\n\t\t\t\tr = rw_instantiate(r, &c->spd.that.host_addr,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   &peer);\n\t\t\t}\n\n\t\t\tupdate_state_connection(st, r);\n\t\t\tc = r;\t/* c not subsequently used */\n\t\t\t/* redo from scratch so we read and check CERT payload */\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"retrying ike_decode_peer_id() with new conn\"));\n\t\t\tpassert(!initiator && !aggrmode);\n\t\t\treturn ikev1_decode_peer_id(md, FALSE, FALSE);\n\t\t} else if (c->spd.that.has_id_wildcards) {\n\t\t\tduplicate_id(&c->spd.that.id, &peer);\n\t\t\tc->spd.that.has_id_wildcards = FALSE;\n\t\t} else if (fromcert) {\n\t\t\tDBG(DBG_CONTROL, DBG_log(\"copying ID for fromcert\"));\n\t\t\tduplicate_id(&c->spd.that.id, &peer);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nbool ikev1_ship_chain(chunk_t *chain, int n, pb_stream *outs,\n\t\t      uint8_t type)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ikev1_ship_CERT(type, chain[i], outs))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid doi_log_cert_thinking(uint16_t auth,\n\t\t\t\tenum ike_cert_type certtype,\n\t\t\t\tenum certpolicy policy,\n\t\t\t\tbool gotcertrequest,\n\t\t\t\tbool send_cert,\n\t\t\t\tbool send_chain)\n{\n\tDBG(DBG_CONTROL, {\n\t\tDBG_log(\"thinking about whether to send my certificate:\");\n\n\t\tstruct esb_buf oan;\n\t\tstruct esb_buf ictn;\n\n\t\tDBG_log(\"  I have RSA key: %s cert.type: %s \",\n\t\t\tenum_showb(&oakley_auth_names, auth, &oan),\n\t\t\tenum_showb(&ike_cert_type_names, certtype, &ictn));\n\n\t\tstruct esb_buf cptn;\n\n\t\tDBG_log(\"  sendcert: %s and I did%s get a certificate request \",\n\t\t\tenum_showb(&certpolicy_type_names, policy, &cptn),\n\t\t\tgotcertrequest ? \"\" : \" not\");\n\n\t\tDBG_log(\"  so %ssend cert.\", send_cert ? \"\" : \"do not \");\n\n\t\tif (!send_cert) {\n\t\t\tif (auth == OAKLEY_PRESHARED_KEY) {\n\t\t\t\tDBG_log(\"I did not send a certificate because digital signatures are not being used. (PSK)\");\n\t\t\t} else if (certtype == CERT_NONE) {\n\t\t\t\tDBG_log(\"I did not send a certificate because I do not have one.\");\n\t\t\t} else if (policy == CERT_SENDIFASKED) {\n\t\t\t\tDBG_log(\"I did not send my certificate because I was not asked to.\");\n\t\t\t} else {\n\t\t\t\tDBG_log(\"INVALID AUTH SETTING: %d\", auth);\n\t\t\t}\n\t\t}\n\t\tif (send_chain)\n\t\t\tDBG_log(\"Sending one or more authcerts\");\n\t});\n}\n"], "filenames": ["programs/pluto/ikev1.c"], "buggy_code_start_loc": [2132], "buggy_code_end_loc": [2133], "fixing_code_start_loc": [2132], "fixing_code_end_loc": [2133], "type": "CWE-125", "message": "An out-of-bounds buffer read flaw was found in the pluto daemon of libreswan from versions 3.27 till 3.31 where, an unauthenticated attacker could use this flaw to crash libreswan by sending specially-crafted IKEv1 Informational Exchange packets. The daemon respawns after the crash.", "other": {"cve": {"id": "CVE-2020-1763", "sourceIdentifier": "secalert@redhat.com", "published": "2020-05-12T14:15:12.580", "lastModified": "2021-05-05T13:41:57.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out-of-bounds buffer read flaw was found in the pluto daemon of libreswan from versions 3.27 till 3.31 where, an unauthenticated attacker could use this flaw to crash libreswan by sending specially-crafted IKEv1 Informational Exchange packets. The daemon respawns after the crash."}, {"lang": "es", "value": "Un fallo de lectura de b\u00fafer fuera de l\u00edmites fue detectado en el demonio pluto de libreswan versiones 3.27 hasta 3.31 donde, un atacante no autenticado podr\u00eda usar este fallo para bloquear a libreswan mediante el env\u00edo de paquetes IKEv1 Informational Exchange especialmente dise\u00f1ados. El demonio reaparece despu\u00e9s del bloqueo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.27", "versionEndIncluding": "3.31", "matchCriteriaId": "F4D70ED5-291D-47AE-A6CB-0ED5AAB14329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E018CD7-6E5B-421E-BF06-AEE4EE0CA4BD"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1813329", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-1763", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-379803.pdf", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/libreswan/libreswan/commit/471a3e41a449d7c753bc4edbba4239501bb62ba8", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://libreswan.org/security/CVE-2020-1763/CVE-2020-1763.txt", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-21", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://us-cert.cisa.gov/ics/advisories/icsa-21-040-04", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "US Government Resource"]}, {"url": "https://www.debian.org/security/2020/dsa-4684", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libreswan/libreswan/commit/471a3e41a449d7c753bc4edbba4239501bb62ba8"}}