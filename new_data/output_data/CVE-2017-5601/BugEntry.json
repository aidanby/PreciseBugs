{"buggy_code": ["/*-\n * Copyright (c) 2008-2014 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_endian.h\"\n\n\n#define MAXMATCH\t\t256\t/* Maximum match length. */\n#define MINMATCH\t\t3\t/* Minimum match length. */\n/*\n * Literal table format:\n * +0              +256                      +510\n * +---------------+-------------------------+\n * | literal code  |       match length      |\n * |   0 ... 255   |  MINMATCH ... MAXMATCH  |\n * +---------------+-------------------------+\n *  <---          LT_BITLEN_SIZE         --->\n */\n/* Literal table size. */\n#define LT_BITLEN_SIZE\t\t(UCHAR_MAX + 1 + MAXMATCH - MINMATCH + 1)\n/* Position table size.\n * Note: this used for both position table and pre literal table.*/\n#define PT_BITLEN_SIZE\t\t(3 + 16)\n\nstruct lzh_dec {\n\t/* Decoding status. */\n\tint     \t\t state;\n\n\t/*\n\t * Window to see last 8Ki(lh5),32Ki(lh6),64Ki(lh7) bytes of decoded\n\t * data.\n\t */\n\tint\t\t\t w_size;\n\tint\t\t\t w_mask;\n\t/* Window buffer, which is a loop buffer. */\n\tunsigned char\t\t*w_buff;\n\t/* The insert position to the window. */\n\tint\t\t\t w_pos;\n\t/* The position where we can copy decoded code from the window. */\n\tint     \t\t copy_pos;\n\t/* The length how many bytes we can copy decoded code from\n\t * the window. */\n\tint     \t\t copy_len;\n\n\t/*\n\t * Bit stream reader.\n\t */\n\tstruct lzh_br {\n#define CACHE_TYPE\t\tuint64_t\n#define CACHE_BITS\t\t(8 * sizeof(CACHE_TYPE))\n\t \t/* Cache buffer. */\n\t\tCACHE_TYPE\t cache_buffer;\n\t\t/* Indicates how many bits avail in cache_buffer. */\n\t\tint\t\t cache_avail;\n\t} br;\n\n\t/*\n\t * Huffman coding.\n\t */\n\tstruct huffman {\n\t\tint\t\t len_size;\n\t\tint\t\t len_avail;\n\t\tint\t\t len_bits;\n\t\tint\t\t freq[17];\n\t\tunsigned char\t*bitlen;\n\n\t\t/*\n\t\t * Use a index table. It's faster than searching a huffman\n\t\t * coding tree, which is a binary tree. But a use of a large\n\t\t * index table causes L1 cache read miss many times.\n\t\t */\n#define HTBL_BITS\t10\n\t\tint\t\t max_bits;\n\t\tint\t\t shift_bits;\n\t\tint\t\t tbl_bits;\n\t\tint\t\t tree_used;\n\t\tint\t\t tree_avail;\n\t\t/* Direct access table. */\n\t\tuint16_t\t*tbl;\n\t\t/* Binary tree table for extra bits over the direct access. */\n\t\tstruct htree_t {\n\t\t\tuint16_t left;\n\t\t\tuint16_t right;\n\t\t}\t\t*tree;\n\t}\t\t\t lt, pt;\n\n\tint\t\t\t blocks_avail;\n\tint\t\t\t pos_pt_len_size;\n\tint\t\t\t pos_pt_len_bits;\n\tint\t\t\t literal_pt_len_size;\n\tint\t\t\t literal_pt_len_bits;\n\tint\t\t\t reading_position;\n\tint\t\t\t loop;\n\tint\t\t\t error;\n};\n\nstruct lzh_stream {\n\tconst unsigned char\t*next_in;\n\tint\t\t\t avail_in;\n\tint64_t\t\t\t total_in;\n\tconst unsigned char\t*ref_ptr;\n\tint\t\t\t avail_out;\n\tint64_t\t\t\t total_out;\n\tstruct lzh_dec\t\t*ds;\n};\n\nstruct lha {\n\t/* entry_bytes_remaining is the number of bytes we expect.\t    */\n\tint64_t                  entry_offset;\n\tint64_t                  entry_bytes_remaining;\n\tint64_t\t\t\t entry_unconsumed;\n\tuint16_t\t\t entry_crc_calculated;\n \n\tsize_t\t\t\t header_size;\t/* header size\t\t    */\n\tunsigned char\t\t level;\t\t/* header level\t\t    */\n\tchar\t\t\t method[3];\t/* compress type\t    */\n\tint64_t\t\t\t compsize;\t/* compressed data size\t    */\n\tint64_t\t\t\t origsize;\t/* original file size\t    */\n\tint\t\t\t setflag;\n#define BIRTHTIME_IS_SET\t1\n#define ATIME_IS_SET\t\t2\n#define UNIX_MODE_IS_SET\t4\n#define CRC_IS_SET\t\t8\n\ttime_t\t\t\t birthtime;\n\tlong\t\t\t birthtime_tv_nsec;\n\ttime_t\t\t\t mtime;\n\tlong\t\t\t mtime_tv_nsec;\n\ttime_t\t\t\t atime;\n\tlong\t\t\t atime_tv_nsec;\n\tmode_t\t\t\t mode;\n\tint64_t\t\t\t uid;\n\tint64_t\t\t\t gid;\n\tstruct archive_string \t uname;\n\tstruct archive_string \t gname;\n\tuint16_t\t\t header_crc;\n\tuint16_t\t\t crc;\n\tstruct archive_string_conv *sconv;\n\tstruct archive_string_conv *opt_sconv;\n\n\tstruct archive_string \t dirname;\n\tstruct archive_string \t filename;\n\tstruct archive_wstring\t ws;\n\n\tunsigned char\t\t dos_attr;\n\n\t/* Flag to mark progress that an archive was read their first header.*/\n\tchar\t\t\t found_first_header;\n\t/* Flag to mark that indicates an empty directory. */\n\tchar\t\t\t directory;\n\n\t/* Flags to mark progress of decompression. */\n\tchar\t\t\t decompress_init;\n\tchar\t\t\t end_of_entry;\n\tchar\t\t\t end_of_entry_cleanup;\n\tchar\t\t\t entry_is_compressed;\n\n\tchar\t\t\t format_name[64];\n\n\tstruct lzh_stream\t strm;\n};\n\n/*\n * LHA header common member offset.\n */\n#define H_METHOD_OFFSET\t2\t/* Compress type. */\n#define H_ATTR_OFFSET\t19\t/* DOS attribute. */\n#define H_LEVEL_OFFSET\t20\t/* Header Level.  */\n#define H_SIZE\t\t22\t/* Minimum header size. */\n\nstatic int      archive_read_format_lha_bid(struct archive_read *, int);\nstatic int      archive_read_format_lha_options(struct archive_read *,\n\t\t    const char *, const char *);\nstatic int\tarchive_read_format_lha_read_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int\tarchive_read_format_lha_read_data(struct archive_read *,\n\t\t    const void **, size_t *, int64_t *);\nstatic int\tarchive_read_format_lha_read_data_skip(struct archive_read *);\nstatic int\tarchive_read_format_lha_cleanup(struct archive_read *);\n\nstatic void\tlha_replace_path_separator(struct lha *,\n\t\t    struct archive_entry *);\nstatic int\tlha_read_file_header_0(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_header_1(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_header_2(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_header_3(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_extended_header(struct archive_read *,\n\t\t    struct lha *, uint16_t *, int, size_t, size_t *);\nstatic size_t\tlha_check_header_format(const void *);\nstatic int\tlha_skip_sfx(struct archive_read *);\nstatic time_t\tlha_dos_time(const unsigned char *);\nstatic time_t\tlha_win_time(uint64_t, long *);\nstatic unsigned char\tlha_calcsum(unsigned char, const void *,\n\t\t    int, size_t);\nstatic int\tlha_parse_linkname(struct archive_string *,\n\t\t    struct archive_string *);\nstatic int\tlha_read_data_none(struct archive_read *, const void **,\n\t\t    size_t *, int64_t *);\nstatic int\tlha_read_data_lzh(struct archive_read *, const void **,\n\t\t    size_t *, int64_t *);\nstatic void\tlha_crc16_init(void);\nstatic uint16_t lha_crc16(uint16_t, const void *, size_t);\nstatic int\tlzh_decode_init(struct lzh_stream *, const char *);\nstatic void\tlzh_decode_free(struct lzh_stream *);\nstatic int\tlzh_decode(struct lzh_stream *, int);\nstatic int\tlzh_br_fillup(struct lzh_stream *, struct lzh_br *);\nstatic int\tlzh_huffman_init(struct huffman *, size_t, int);\nstatic void\tlzh_huffman_free(struct huffman *);\nstatic int\tlzh_read_pt_bitlen(struct lzh_stream *, int start, int end);\nstatic int\tlzh_make_fake_table(struct huffman *, uint16_t);\nstatic int\tlzh_make_huffman_table(struct huffman *);\nstatic inline int lzh_decode_huffman(struct huffman *, unsigned);\nstatic int\tlzh_decode_huffman_tree(struct huffman *, unsigned, int);\n\n\nint\narchive_read_support_format_lha(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct lha *lha;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_lha\");\n\n\tlha = (struct lha *)calloc(1, sizeof(*lha));\n\tif (lha == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate lha data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tarchive_string_init(&lha->ws);\n\n\tr = __archive_read_register_format(a,\n\t    lha,\n\t    \"lha\",\n\t    archive_read_format_lha_bid,\n\t    archive_read_format_lha_options,\n\t    archive_read_format_lha_read_header,\n\t    archive_read_format_lha_read_data,\n\t    archive_read_format_lha_read_data_skip,\n\t    NULL,\n\t    archive_read_format_lha_cleanup,\n\t    NULL,\n\t    NULL);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(lha);\n\treturn (ARCHIVE_OK);\n}\n\nstatic size_t\nlha_check_header_format(const void *h)\n{\n\tconst unsigned char *p = h;\n\tsize_t next_skip_bytes;\n\n\tswitch (p[H_METHOD_OFFSET+3]) {\n\t/*\n\t * \"-lh0-\" ... \"-lh7-\" \"-lhd-\"\n\t * \"-lzs-\" \"-lz5-\"\n\t */\n\tcase '0': case '1': case '2': case '3':\n\tcase '4': case '5': case '6': case '7':\n\tcase 'd':\n\tcase 's':\n\t\tnext_skip_bytes = 4;\n\n\t\t/* b0 == 0 means the end of an LHa archive file.\t*/\n\t\tif (p[0] == 0)\n\t\t\tbreak;\n\t\tif (p[H_METHOD_OFFSET] != '-' || p[H_METHOD_OFFSET+1] != 'l'\n\t\t    ||  p[H_METHOD_OFFSET+4] != '-')\n\t\t\tbreak;\n\n\t\tif (p[H_METHOD_OFFSET+2] == 'h') {\n\t\t\t/* \"-lh?-\" */\n\t\t\tif (p[H_METHOD_OFFSET+3] == 's')\n\t\t\t\tbreak;\n\t\t\tif (p[H_LEVEL_OFFSET] == 0)\n\t\t\t\treturn (0);\n\t\t\tif (p[H_LEVEL_OFFSET] <= 3 && p[H_ATTR_OFFSET] == 0x20)\n\t\t\t\treturn (0);\n\t\t}\n\t\tif (p[H_METHOD_OFFSET+2] == 'z') {\n\t\t\t/* LArc extensions: -lzs-,-lz4- and -lz5- */\n\t\t\tif (p[H_LEVEL_OFFSET] != 0)\n\t\t\t\tbreak;\n\t\t\tif (p[H_METHOD_OFFSET+3] == 's'\n\t\t\t    || p[H_METHOD_OFFSET+3] == '4'\n\t\t\t    || p[H_METHOD_OFFSET+3] == '5')\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 'h': next_skip_bytes = 1; break;\n\tcase 'z': next_skip_bytes = 1; break;\n\tcase 'l': next_skip_bytes = 2; break;\n\tcase '-': next_skip_bytes = 3; break;\n\tdefault : next_skip_bytes = 4; break;\n\t}\n\n\treturn (next_skip_bytes);\n}\n\nstatic int\narchive_read_format_lha_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\tconst void *buff;\n\tssize_t bytes_avail, offset, window;\n\tsize_t next;\n\n\t/* If there's already a better bid than we can ever\n\t   make, don't bother testing. */\n\tif (best_bid > 30)\n\t\treturn (-1);\n\n\tif ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)\n\t\treturn (-1);\n\n\tif (lha_check_header_format(p) == 0)\n\t\treturn (30);\n\n\tif (p[0] == 'M' && p[1] == 'Z') {\n\t\t/* PE file */\n\t\toffset = 0;\n\t\twindow = 4096;\n\t\twhile (offset < (1024 * 20)) {\n\t\t\tbuff = __archive_read_ahead(a, offset + window,\n\t\t\t    &bytes_avail);\n\t\t\tif (buff == NULL) {\n\t\t\t\t/* Remaining bytes are less than window. */\n\t\t\t\twindow >>= 1;\n\t\t\t\tif (window < (H_SIZE + 3))\n\t\t\t\t\treturn (0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = (const char *)buff + offset;\n\t\t\twhile (p + H_SIZE < (const char *)buff + bytes_avail) {\n\t\t\t\tif ((next = lha_check_header_format(p)) == 0)\n\t\t\t\t\treturn (30);\n\t\t\t\tp += next;\n\t\t\t}\n\t\t\toffset = p - (const char *)buff;\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\narchive_read_format_lha_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n\tstruct lha *lha;\n\tint ret = ARCHIVE_FAILED;\n\n\tlha = (struct lha *)(a->format->data);\n\tif (strcmp(key, \"hdrcharset\")  == 0) {\n\t\tif (val == NULL || val[0] == 0)\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"lha: hdrcharset option needs a character-set name\");\n\t\telse {\n\t\t\tlha->opt_sconv =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&a->archive, val, 0);\n\t\t\tif (lha->opt_sconv != NULL)\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\telse\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t}\n\t\treturn (ret);\n\t}\n\n\t/* Note: The \"warn\" return is just to inform the options\n\t * supervisor that we didn't handle it.  It will generate\n\t * a suitable error if no one used this option. */\n\treturn (ARCHIVE_WARN);\n}\n\nstatic int\nlha_skip_sfx(struct archive_read *a)\n{\n\tconst void *h;\n\tconst char *p, *q;\n\tsize_t next, skip;\n\tssize_t bytes, window;\n\n\twindow = 4096;\n\tfor (;;) {\n\t\th = __archive_read_ahead(a, window, &bytes);\n\t\tif (h == NULL) {\n\t\t\t/* Remaining bytes are less than window. */\n\t\t\twindow >>= 1;\n\t\t\tif (window < (H_SIZE + 3))\n\t\t\t\tgoto fatal;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bytes < H_SIZE)\n\t\t\tgoto fatal;\n\t\tp = h;\n\t\tq = p + bytes;\n\n\t\t/*\n\t\t * Scan ahead until we find something that looks\n\t\t * like the lha header.\n\t\t */\n\t\twhile (p + H_SIZE < q) {\n\t\t\tif ((next = lha_check_header_format(p)) == 0) {\n\t\t\t\tskip = p - (const char *)h;\n\t\t\t\t__archive_read_consume(a, skip);\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tp += next;\n\t\t}\n\t\tskip = p - (const char *)h;\n\t\t__archive_read_consume(a, skip);\n\t}\nfatal:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Couldn't find out LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\ntruncated_error(struct archive_read *a)\n{\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Truncated LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_lha_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct archive_string linkname;\n\tstruct archive_string pathname;\n\tstruct lha *lha;\n\tconst unsigned char *p;\n\tconst char *signature;\n\tint err;\n\t\n\tlha_crc16_init();\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_LHA;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"lha\";\n\n\tlha = (struct lha *)(a->format->data);\n\tlha->decompress_init = 0;\n\tlha->end_of_entry = 0;\n\tlha->end_of_entry_cleanup = 0;\n\tlha->entry_unconsumed = 0;\n\n\tif ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL) {\n\t\t/*\n\t\t * LHa archiver added 0 to the tail of its archive file as\n\t\t * the mark of the end of the archive.\n\t\t */\n\t\tsignature = __archive_read_ahead(a, sizeof(signature[0]), NULL);\n\t\tif (signature == NULL || signature[0] == 0)\n\t\t\treturn (ARCHIVE_EOF);\n\t\treturn (truncated_error(a));\n\t}\n\n\tsignature = (const char *)p;\n\tif (lha->found_first_header == 0 &&\n\t    signature[0] == 'M' && signature[1] == 'Z') {\n                /* This is an executable?  Must be self-extracting... \t*/\n\t\terr = lha_skip_sfx(a);\n\t\tif (err < ARCHIVE_WARN)\n\t\t\treturn (err);\n\n\t\tif ((p = __archive_read_ahead(a, sizeof(*p), NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\tsignature = (const char *)p;\n\t}\n\t/* signature[0] == 0 means the end of an LHa archive file. */\n\tif (signature[0] == 0)\n\t\treturn (ARCHIVE_EOF);\n\n\t/*\n\t * Check the header format and method type.\n\t */\n\tif (lha_check_header_format(p) != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Bad LHa file\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* We've found the first header. */\n\tlha->found_first_header = 1;\n\t/* Set a default value and common data */\n\tlha->header_size = 0;\n\tlha->level = p[H_LEVEL_OFFSET];\n\tlha->method[0] = p[H_METHOD_OFFSET+1];\n\tlha->method[1] = p[H_METHOD_OFFSET+2];\n\tlha->method[2] = p[H_METHOD_OFFSET+3];\n\tif (memcmp(lha->method, \"lhd\", 3) == 0)\n\t\tlha->directory = 1;\n\telse\n\t\tlha->directory = 0;\n\tif (memcmp(lha->method, \"lh0\", 3) == 0 ||\n\t    memcmp(lha->method, \"lz4\", 3) == 0)\n\t\tlha->entry_is_compressed = 0;\n\telse\n\t\tlha->entry_is_compressed = 1;\n\n\tlha->compsize = 0;\n\tlha->origsize = 0;\n\tlha->setflag = 0;\n\tlha->birthtime = 0;\n\tlha->birthtime_tv_nsec = 0;\n\tlha->mtime = 0;\n\tlha->mtime_tv_nsec = 0;\n\tlha->atime = 0;\n\tlha->atime_tv_nsec = 0;\n\tlha->mode = (lha->directory)? 0777 : 0666;\n\tlha->uid = 0;\n\tlha->gid = 0;\n\tarchive_string_empty(&lha->dirname);\n\tarchive_string_empty(&lha->filename);\n\tlha->dos_attr = 0;\n\tif (lha->opt_sconv != NULL)\n\t\tlha->sconv = lha->opt_sconv;\n\telse\n\t\tlha->sconv = NULL;\n\n\tswitch (p[H_LEVEL_OFFSET]) {\n\tcase 0:\n\t\terr = lha_read_file_header_0(a, lha);\n\t\tbreak;\n\tcase 1:\n\t\terr = lha_read_file_header_1(a, lha);\n\t\tbreak;\n\tcase 2:\n\t\terr = lha_read_file_header_2(a, lha);\n\t\tbreak;\n\tcase 3:\n\t\terr = lha_read_file_header_3(a, lha);\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported LHa header level %d\", p[H_LEVEL_OFFSET]);\n\t\terr = ARCHIVE_FATAL;\n\t\tbreak;\n\t}\n\tif (err < ARCHIVE_WARN)\n\t\treturn (err);\n\n\n\tif (!lha->directory && archive_strlen(&lha->filename) == 0)\n\t\t/* The filename has not been set */\n\t\treturn (truncated_error(a));\n\n\t/*\n\t * Make a pathname from a dirname and a filename.\n\t */\n\tarchive_string_concat(&lha->dirname, &lha->filename);\n\tarchive_string_init(&pathname);\n\tarchive_string_init(&linkname);\n\tarchive_string_copy(&pathname, &lha->dirname);\n\n\tif ((lha->mode & AE_IFMT) == AE_IFLNK) {\n\t\t/*\n\t \t * Extract the symlink-name if it's included in the pathname.\n\t \t */\n\t\tif (!lha_parse_linkname(&linkname, &pathname)) {\n\t\t\t/* We couldn't get the symlink-name. */\n\t\t\tarchive_set_error(&a->archive,\n\t\t    \t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown symlink-name\");\n\t\t\tarchive_string_free(&pathname);\n\t\t\tarchive_string_free(&linkname);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Make sure a file-type is set.\n\t\t * The mode has been overridden if it is in the extended data.\n\t\t */\n\t\tlha->mode = (lha->mode & ~AE_IFMT) |\n\t\t    ((lha->directory)? AE_IFDIR: AE_IFREG);\n\t}\n\tif ((lha->setflag & UNIX_MODE_IS_SET) == 0 &&\n\t    (lha->dos_attr & 1) != 0)\n\t\tlha->mode &= ~(0222);/* read only. */\n\n\t/*\n\t * Set basic file parameters.\n\t */\n\tif (archive_entry_copy_pathname_l(entry, pathname.s,\n\t    pathname.length, lha->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted \"\n\t\t    \"from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(lha->sconv));\n\t\terr = ARCHIVE_WARN;\n\t}\n\tarchive_string_free(&pathname);\n\tif (archive_strlen(&linkname) > 0) {\n\t\tif (archive_entry_copy_symlink_l(entry, linkname.s,\n\t\t    linkname.length, lha->sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Linkname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(lha->sconv));\n\t\t\terr = ARCHIVE_WARN;\n\t\t}\n\t} else\n\t\tarchive_entry_set_symlink(entry, NULL);\n\tarchive_string_free(&linkname);\n\t/*\n\t * When a header level is 0, there is a possibility that\n\t * a pathname and a symlink has '\\' character, a directory\n\t * separator in DOS/Windows. So we should convert it to '/'.\n\t */\n\tif (p[H_LEVEL_OFFSET] == 0)\n\t\tlha_replace_path_separator(lha, entry);\n\n\tarchive_entry_set_mode(entry, lha->mode);\n\tarchive_entry_set_uid(entry, lha->uid);\n\tarchive_entry_set_gid(entry, lha->gid);\n\tif (archive_strlen(&lha->uname) > 0)\n\t\tarchive_entry_set_uname(entry, lha->uname.s);\n\tif (archive_strlen(&lha->gname) > 0)\n\t\tarchive_entry_set_gname(entry, lha->gname.s);\n\tif (lha->setflag & BIRTHTIME_IS_SET) {\n\t\tarchive_entry_set_birthtime(entry, lha->birthtime,\n\t\t    lha->birthtime_tv_nsec);\n\t\tarchive_entry_set_ctime(entry, lha->birthtime,\n\t\t    lha->birthtime_tv_nsec);\n\t} else {\n\t\tarchive_entry_unset_birthtime(entry);\n\t\tarchive_entry_unset_ctime(entry);\n\t}\n\tarchive_entry_set_mtime(entry, lha->mtime, lha->mtime_tv_nsec);\n\tif (lha->setflag & ATIME_IS_SET)\n\t\tarchive_entry_set_atime(entry, lha->atime,\n\t\t    lha->atime_tv_nsec);\n\telse\n\t\tarchive_entry_unset_atime(entry);\n\tif (lha->directory || archive_entry_symlink(entry) != NULL)\n\t\tarchive_entry_unset_size(entry);\n\telse\n\t\tarchive_entry_set_size(entry, lha->origsize);\n\n\t/*\n\t * Prepare variables used to read a file content.\n\t */\n\tlha->entry_bytes_remaining = lha->compsize;\n\tlha->entry_offset = 0;\n\tlha->entry_crc_calculated = 0;\n\n\t/*\n\t * This file does not have a content.\n\t */\n\tif (lha->directory || lha->compsize == 0)\n\t\tlha->end_of_entry = 1;\n\n\tsprintf(lha->format_name, \"lha -%c%c%c-\",\n\t    lha->method[0], lha->method[1], lha->method[2]);\n\ta->archive.archive_format_name = lha->format_name;\n\n\treturn (err);\n}\n\n/*\n * Replace a DOS path separator '\\' by a character '/'.\n * Some multi-byte character set have  a character '\\' in its second byte.\n */\nstatic void\nlha_replace_path_separator(struct lha *lha, struct archive_entry *entry)\n{\n\tconst wchar_t *wp;\n\tsize_t i;\n\n\tif ((wp = archive_entry_pathname_w(entry)) != NULL) {\n\t\tarchive_wstrcpy(&(lha->ws), wp);\n\t\tfor (i = 0; i < archive_strlen(&(lha->ws)); i++) {\n\t\t\tif (lha->ws.s[i] == L'\\\\')\n\t\t\t\tlha->ws.s[i] = L'/';\n\t\t}\n\t\tarchive_entry_copy_pathname_w(entry, lha->ws.s);\n\t}\n\n\tif ((wp = archive_entry_symlink_w(entry)) != NULL) {\n\t\tarchive_wstrcpy(&(lha->ws), wp);\n\t\tfor (i = 0; i < archive_strlen(&(lha->ws)); i++) {\n\t\t\tif (lha->ws.s[i] == L'\\\\')\n\t\t\t\tlha->ws.s[i] = L'/';\n\t\t}\n\t\tarchive_entry_copy_symlink_w(entry, lha->ws.s);\n\t}\n}\n\n/*\n * Header 0 format\n *\n * +0              +1         +2               +7                  +11\n * +---------------+----------+----------------+-------------------+\n * |header size(*1)|header sum|compression type|compressed size(*2)|\n * +---------------+----------+----------------+-------------------+\n *                             <---------------------(*1)----------*\n *\n * +11               +15       +17       +19            +20              +21\n * +-----------------+---------+---------+--------------+----------------+\n * |uncompressed size|time(DOS)|date(DOS)|attribute(DOS)|header level(=0)|\n * +-----------------+---------+---------+--------------+----------------+\n * *--------------------------------(*1)---------------------------------*\n *\n * +21             +22       +22+(*3)   +22+(*3)+2       +22+(*3)+2+(*4)\n * +---------------+---------+----------+----------------+------------------+\n * |name length(*3)|file name|file CRC16|extra header(*4)|  compressed data |\n * +---------------+---------+----------+----------------+------------------+\n *                  <--(*3)->                             <------(*2)------>\n * *----------------------(*1)-------------------------->\n *\n */\n#define H0_HEADER_SIZE_OFFSET\t0\n#define H0_HEADER_SUM_OFFSET\t1\n#define H0_COMP_SIZE_OFFSET\t7\n#define H0_ORIG_SIZE_OFFSET\t11\n#define H0_DOS_TIME_OFFSET\t15\n#define H0_NAME_LEN_OFFSET\t21\n#define H0_FILE_NAME_OFFSET\t22\n#define H0_FIXED_SIZE\t\t24\nstatic int\nlha_read_file_header_0(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tint extdsize, namelen;\n\tunsigned char headersum, sum_calculated;\n\n\tif ((p = __archive_read_ahead(a, H0_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H0_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H0_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H0_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H0_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H0_DOS_TIME_OFFSET);\n\tnamelen = p[H0_NAME_LEN_OFFSET];\n\textdsize = (int)lha->header_size - H0_FIXED_SIZE - namelen;\n\tif ((namelen > 221 || extdsize < 0) && extdsize != -2) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid LHa header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tarchive_strncpy(&lha->filename, p + H0_FILE_NAME_OFFSET, namelen);\n\t/* When extdsize == -2, A CRC16 value is not present in the header. */\n\tif (extdsize >= 0) {\n\t\tlha->crc = archive_le16dec(p + H0_FILE_NAME_OFFSET + namelen);\n\t\tlha->setflag |= CRC_IS_SET;\n\t}\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\n\t/* Read an extended header */\n\tif (extdsize > 0) {\n\t\t/* This extended data is set by 'LHa for UNIX' only.\n\t\t * Maybe fixed size.\n\t\t */\n\t\tp += H0_FILE_NAME_OFFSET + namelen + 2;\n\t\tif (p[0] == 'U' && extdsize == 12) {\n\t\t\t/* p[1] is a minor version. */\n\t\t\tlha->mtime = archive_le32dec(&p[2]);\n\t\t\tlha->mode = archive_le16dec(&p[6]);\n\t\t\tlha->uid = archive_le16dec(&p[8]);\n\t\t\tlha->gid = archive_le16dec(&p[10]);\n\t\t\tlha->setflag |= UNIX_MODE_IS_SET;\n\t\t}\n\t}\n\t__archive_read_consume(a, lha->header_size);\n\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Header 1 format\n *\n * +0              +1         +2               +7            +11\n * +---------------+----------+----------------+-------------+\n * |header size(*1)|header sum|compression type|skip size(*2)|\n * +---------------+----------+----------------+-------------+\n *                             <---------------(*1)----------*\n *\n * +11               +15       +17       +19            +20              +21\n * +-----------------+---------+---------+--------------+----------------+\n * |uncompressed size|time(DOS)|date(DOS)|attribute(DOS)|header level(=1)|\n * +-----------------+---------+---------+--------------+----------------+\n * *-------------------------------(*1)----------------------------------*\n *\n * +21             +22       +22+(*3)   +22+(*3)+2  +22+(*3)+3  +22+(*3)+3+(*4)\n * +---------------+---------+----------+-----------+-----------+\n * |name length(*3)|file name|file CRC16|  creator  |padding(*4)|\n * +---------------+---------+----------+-----------+-----------+\n *                  <--(*3)->\n * *----------------------------(*1)----------------------------*\n *\n * +22+(*3)+3+(*4)  +22+(*3)+3+(*4)+2     +22+(*3)+3+(*4)+2+(*5)\n * +----------------+---------------------+------------------------+\n * |next header size| extended header(*5) |     compressed data    |\n * +----------------+---------------------+------------------------+\n * *------(*1)-----> <--------------------(*2)-------------------->\n */\n#define H1_HEADER_SIZE_OFFSET\t0\n#define H1_HEADER_SUM_OFFSET\t1\n#define H1_COMP_SIZE_OFFSET\t7\n#define H1_ORIG_SIZE_OFFSET\t11\n#define H1_DOS_TIME_OFFSET\t15\n#define H1_NAME_LEN_OFFSET\t21\n#define H1_FILE_NAME_OFFSET\t22\n#define H1_FIXED_SIZE\t\t27\nstatic int\nlha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\n\terr = ARCHIVE_OK;\n\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\t/* Note: An extended header size is included in a compsize. */\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\t/* Calculate a padding size. The result will be normally 0 only(?) */\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;/* Invalid filename. */\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t/* Consume used bytes but not include `next header size' data\n\t * since it will be consumed in lha_read_file_extended_header(). */\n\t__archive_read_consume(a, lha->header_size - 2);\n\n\t/* Read extended headers */\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n\t/* Get a real compressed file size. */\n\tlha->compsize -= extdsize - 2;\n\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\n/*\n * Header 2 format\n *\n * +0              +2               +7                  +11               +15\n * +---------------+----------------+-------------------+-----------------+\n * |header size(*1)|compression type|compressed size(*2)|uncompressed size|\n * +---------------+----------------+-------------------+-----------------+\n *  <--------------------------------(*1)---------------------------------*\n *\n * +15               +19          +20              +21        +23         +24\n * +-----------------+------------+----------------+----------+-----------+\n * |data/time(time_t)| 0x20 fixed |header level(=2)|file CRC16|  creator  |\n * +-----------------+------------+----------------+----------+-----------+\n * *---------------------------------(*1)---------------------------------*\n *\n * +24              +26                 +26+(*3)      +26+(*3)+(*4)\n * +----------------+-------------------+-------------+-------------------+\n * |next header size|extended header(*3)| padding(*4) |  compressed data  |\n * +----------------+-------------------+-------------+-------------------+\n * *--------------------------(*1)-------------------> <------(*2)------->\n *\n */\n#define H2_HEADER_SIZE_OFFSET\t0\n#define H2_COMP_SIZE_OFFSET\t7\n#define H2_ORIG_SIZE_OFFSET\t11\n#define H2_TIME_OFFSET\t\t15\n#define H2_CRC_OFFSET\t\t21\n#define H2_FIXED_SIZE\t\t24\nstatic int\nlha_read_file_header_2(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint err, padding;\n\tuint16_t header_crc;\n\n\tif ((p = __archive_read_ahead(a, H2_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tlha->header_size =archive_le16dec(p + H2_HEADER_SIZE_OFFSET);\n\tlha->compsize = archive_le32dec(p + H2_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H2_ORIG_SIZE_OFFSET);\n\tlha->mtime = archive_le32dec(p + H2_TIME_OFFSET);\n\tlha->crc = archive_le16dec(p + H2_CRC_OFFSET);\n\tlha->setflag |= CRC_IS_SET;\n\n\tif (lha->header_size < H2_FIXED_SIZE) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid LHa header size\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\theader_crc = lha_crc16(0, p, H2_FIXED_SIZE);\n\t__archive_read_consume(a, H2_FIXED_SIZE);\n\n\t/* Read extended headers */\n\terr = lha_read_file_extended_header(a, lha, &header_crc, 2,\n\t\t  lha->header_size - H2_FIXED_SIZE, &extdsize);\n\tif (err < ARCHIVE_WARN)\n\t\treturn (err);\n\n\t/* Calculate a padding size. The result will be normally 0 or 1. */\n\tpadding = (int)lha->header_size - (int)(H2_FIXED_SIZE + extdsize);\n\tif (padding > 0) {\n\t\tif ((p = __archive_read_ahead(a, padding, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\theader_crc = lha_crc16(header_crc, p, padding);\n\t\t__archive_read_consume(a, padding);\n\t}\n\n\tif (header_crc != lha->header_crc) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"LHa header CRC error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\n}\n\n/*\n * Header 3 format\n *\n * +0           +2               +7                  +11               +15\n * +------------+----------------+-------------------+-----------------+\n * | 0x04 fixed |compression type|compressed size(*2)|uncompressed size|\n * +------------+----------------+-------------------+-----------------+\n *  <-------------------------------(*1)-------------------------------*\n *\n * +15               +19          +20              +21        +23         +24\n * +-----------------+------------+----------------+----------+-----------+\n * |date/time(time_t)| 0x20 fixed |header level(=3)|file CRC16|  creator  |\n * +-----------------+------------+----------------+----------+-----------+\n * *--------------------------------(*1)----------------------------------*\n *\n * +24             +28              +32                 +32+(*3)\n * +---------------+----------------+-------------------+-----------------+\n * |header size(*1)|next header size|extended header(*3)| compressed data |\n * +---------------+----------------+-------------------+-----------------+\n * *------------------------(*1)-----------------------> <------(*2)----->\n *\n */\n#define H3_FIELD_LEN_OFFSET\t0\n#define H3_COMP_SIZE_OFFSET\t7\n#define H3_ORIG_SIZE_OFFSET\t11\n#define H3_TIME_OFFSET\t\t15\n#define H3_CRC_OFFSET\t\t21\n#define H3_HEADER_SIZE_OFFSET\t24\n#define H3_FIXED_SIZE\t\t28\nstatic int\nlha_read_file_header_3(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint err;\n\tuint16_t header_crc;\n\n\tif ((p = __archive_read_ahead(a, H3_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tif (archive_le16dec(p + H3_FIELD_LEN_OFFSET) != 4)\n\t\tgoto invalid;\n\tlha->header_size =archive_le32dec(p + H3_HEADER_SIZE_OFFSET);\n\tlha->compsize = archive_le32dec(p + H3_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H3_ORIG_SIZE_OFFSET);\n\tlha->mtime = archive_le32dec(p + H3_TIME_OFFSET);\n\tlha->crc = archive_le16dec(p + H3_CRC_OFFSET);\n\tlha->setflag |= CRC_IS_SET;\n\n\tif (lha->header_size < H3_FIXED_SIZE + 4)\n\t\tgoto invalid;\n\theader_crc = lha_crc16(0, p, H3_FIXED_SIZE);\n\t__archive_read_consume(a, H3_FIXED_SIZE);\n\n\t/* Read extended headers */\n\terr = lha_read_file_extended_header(a, lha, &header_crc, 4,\n\t\t  lha->header_size - H3_FIXED_SIZE, &extdsize);\n\tif (err < ARCHIVE_WARN)\n\t\treturn (err);\n\n\tif (header_crc != lha->header_crc) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"LHa header CRC error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\n/*\n * Extended header format\n *\n * +0             +2        +3  -- used in header 1 and 2\n * +0             +4        +5  -- used in header 3\n * +--------------+---------+-------------------+--------------+--\n * |ex-header size|header id|        data       |ex-header size| .......\n * +--------------+---------+-------------------+--------------+--\n *  <-------------( ex-header size)------------> <-- next extended header --*\n *\n * If the ex-header size is zero, it is the make of the end of extended\n * headers.\n *\n */\nstatic int\nlha_read_file_extended_header(struct archive_read *a, struct lha *lha,\n    uint16_t *crc, int sizefield_length, size_t limitsize, size_t *total_size)\n{\n\tconst void *h;\n\tconst unsigned char *extdheader;\n\tsize_t\textdsize;\n\tsize_t\tdatasize;\n\tunsigned int i;\n\tunsigned char extdtype;\n\n#define EXT_HEADER_CRC\t\t0x00\t\t/* Header CRC and information*/\n#define EXT_FILENAME\t\t0x01\t\t/* Filename \t\t    */\n#define EXT_DIRECTORY\t\t0x02\t\t/* Directory name\t    */\n#define EXT_DOS_ATTR\t\t0x40\t\t/* MS-DOS attribute\t    */\n#define EXT_TIMESTAMP\t\t0x41\t\t/* Windows time stamp\t    */\n#define EXT_FILESIZE\t\t0x42\t\t/* Large file size\t    */\n#define EXT_TIMEZONE\t\t0x43\t\t/* Time zone\t\t    */\n#define EXT_UTF16_FILENAME\t0x44\t\t/* UTF-16 filename \t    */\n#define EXT_UTF16_DIRECTORY\t0x45\t\t/* UTF-16 directory name    */\n#define EXT_CODEPAGE\t\t0x46\t\t/* Codepage\t\t    */\n#define EXT_UNIX_MODE\t\t0x50\t\t/* File permission\t    */\n#define EXT_UNIX_GID_UID\t0x51\t\t/* gid,uid\t\t    */\n#define EXT_UNIX_GNAME\t\t0x52\t\t/* Group name\t\t    */\n#define EXT_UNIX_UNAME\t\t0x53\t\t/* User name\t\t    */\n#define EXT_UNIX_MTIME\t\t0x54\t\t/* Modified time\t    */\n#define EXT_OS2_NEW_ATTR\t0x7f\t\t/* new attribute(OS/2 only) */\n#define EXT_NEW_ATTR\t\t0xff\t\t/* new attribute\t    */\n\n\t*total_size = sizefield_length;\n\n\tfor (;;) {\n\t\t/* Read an extended header size. */\n\t\tif ((h =\n\t\t    __archive_read_ahead(a, sizefield_length, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\t/* Check if the size is the zero indicates the end of the\n\t\t * extended header. */\n\t\tif (sizefield_length == sizeof(uint16_t))\n\t\t\textdsize = archive_le16dec(h);\n\t\telse\n\t\t\textdsize = archive_le32dec(h);\n\t\tif (extdsize == 0) {\n\t\t\t/* End of extended header */\n\t\t\tif (crc != NULL)\n\t\t\t\t*crc = lha_crc16(*crc, h, sizefield_length);\n\t\t\t__archive_read_consume(a, sizefield_length);\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\t/* Sanity check to the extended header size. */\n\t\tif (((uint64_t)*total_size + extdsize) >\n\t\t\t\t    (uint64_t)limitsize ||\n\t\t    extdsize <= (size_t)sizefield_length)\n\t\t\tgoto invalid;\n\n\t\t/* Read the extended header. */\n\t\tif ((h = __archive_read_ahead(a, extdsize, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\t*total_size += extdsize;\n\n\t\textdheader = (const unsigned char *)h;\n\t\t/* Get the extended header type. */\n\t\textdtype = extdheader[sizefield_length];\n\t\t/* Calculate an extended data size. */\n\t\tdatasize = extdsize - (1 + sizefield_length);\n\t\t/* Skip an extended header size field and type field. */\n\t\textdheader += sizefield_length + 1;\n\n\t\tif (crc != NULL && extdtype != EXT_HEADER_CRC)\n\t\t\t*crc = lha_crc16(*crc, h, extdsize);\n\t\tswitch (extdtype) {\n\t\tcase EXT_HEADER_CRC:\n\t\t\t/* We only use a header CRC. Following data will not\n\t\t\t * be used. */\n\t\t\tif (datasize >= 2) {\n\t\t\t\tlha->header_crc = archive_le16dec(extdheader);\n\t\t\t\tif (crc != NULL) {\n\t\t\t\t\tstatic const char zeros[2] = {0, 0};\n\t\t\t\t\t*crc = lha_crc16(*crc, h,\n\t\t\t\t\t    extdsize - datasize);\n\t\t\t\t\t/* CRC value itself as zero */\n\t\t\t\t\t*crc = lha_crc16(*crc, zeros, 2);\n\t\t\t\t\t*crc = lha_crc16(*crc,\n\t\t\t\t\t    extdheader+2, datasize - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_FILENAME:\n\t\t\tif (datasize == 0) {\n\t\t\t\t/* maybe directory header */\n\t\t\t\tarchive_string_empty(&lha->filename);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (extdheader[0] == '\\0')\n\t\t\t\tgoto invalid;\n\t\t\tarchive_strncpy(&lha->filename,\n\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_DIRECTORY:\n\t\t\tif (datasize == 0 || extdheader[0] == '\\0')\n\t\t\t\t/* no directory name data. exit this case. */\n\t\t\t\tgoto invalid;\n\n\t\t\tarchive_strncpy(&lha->dirname,\n\t\t  \t    (const char *)extdheader, datasize);\n\t\t\t/*\n\t\t\t * Convert directory delimiter from 0xFF\n\t\t\t * to '/' for local system.\n\t \t\t */\n\t\t\tfor (i = 0; i < lha->dirname.length; i++) {\n\t\t\t\tif ((unsigned char)lha->dirname.s[i] == 0xFF)\n\t\t\t\t\tlha->dirname.s[i] = '/';\n\t\t\t}\n\t\t\t/* Is last character directory separator? */\n\t\t\tif (lha->dirname.s[lha->dirname.length-1] != '/')\n\t\t\t\t/* invalid directory data */\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase EXT_DOS_ATTR:\n\t\t\tif (datasize == 2)\n\t\t\t\tlha->dos_attr = (unsigned char)\n\t\t\t\t    (archive_le16dec(extdheader) & 0xff);\n\t\t\tbreak;\n\t\tcase EXT_TIMESTAMP:\n\t\t\tif (datasize == (sizeof(uint64_t) * 3)) {\n\t\t\t\tlha->birthtime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->birthtime_tv_nsec);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->mtime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->mtime_tv_nsec);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->atime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->atime_tv_nsec);\n\t\t\t\tlha->setflag |= BIRTHTIME_IS_SET |\n\t\t\t\t    ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_FILESIZE:\n\t\t\tif (datasize == sizeof(uint64_t) * 2) {\n\t\t\t\tlha->compsize = archive_le64dec(extdheader);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->origsize = archive_le64dec(extdheader);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_CODEPAGE:\n\t\t\t/* Get an archived filename charset from codepage.\n\t\t\t * This overwrites the charset specified by\n\t\t\t * hdrcharset option. */\n\t\t\tif (datasize == sizeof(uint32_t)) {\n\t\t\t\tstruct archive_string cp;\n\t\t\t\tconst char *charset;\n\n\t\t\t\tarchive_string_init(&cp);\n\t\t\t\tswitch (archive_le32dec(extdheader)) {\n\t\t\t\tcase 65001: /* UTF-8 */\n\t\t\t\t\tcharset = \"UTF-8\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tarchive_string_sprintf(&cp, \"CP%d\",\n\t\t\t\t\t    (int)archive_le32dec(extdheader));\n\t\t\t\t\tcharset = cp.s;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlha->sconv =\n\t\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t\t&(a->archive), charset, 1);\n\t\t\t\tarchive_string_free(&cp);\n\t\t\t\tif (lha->sconv == NULL)\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_MODE:\n\t\t\tif (datasize == sizeof(uint16_t)) {\n\t\t\t\tlha->mode = archive_le16dec(extdheader);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_GID_UID:\n\t\t\tif (datasize == (sizeof(uint16_t) * 2)) {\n\t\t\t\tlha->gid = archive_le16dec(extdheader);\n\t\t\t\tlha->uid = archive_le16dec(extdheader+2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_GNAME:\n\t\t\tif (datasize > 0)\n\t\t\t\tarchive_strncpy(&lha->gname,\n\t\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_UNIX_UNAME:\n\t\t\tif (datasize > 0)\n\t\t\t\tarchive_strncpy(&lha->uname,\n\t\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_UNIX_MTIME:\n\t\t\tif (datasize == sizeof(uint32_t))\n\t\t\t\tlha->mtime = archive_le32dec(extdheader);\n\t\t\tbreak;\n\t\tcase EXT_OS2_NEW_ATTR:\n\t\t\t/* This extended header is OS/2 depend. */\n\t\t\tif (datasize == 16) {\n\t\t\t\tlha->dos_attr = (unsigned char)\n\t\t\t\t    (archive_le16dec(extdheader) & 0xff);\n\t\t\t\tlha->mode = archive_le16dec(extdheader+2);\n\t\t\t\tlha->gid = archive_le16dec(extdheader+4);\n\t\t\t\tlha->uid = archive_le16dec(extdheader+6);\n\t\t\t\tlha->birthtime = archive_le32dec(extdheader+8);\n\t\t\t\tlha->atime = archive_le32dec(extdheader+12);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET\n\t\t\t\t    | BIRTHTIME_IS_SET | ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_NEW_ATTR:\n\t\t\tif (datasize == 20) {\n\t\t\t\tlha->mode = (mode_t)archive_le32dec(extdheader);\n\t\t\t\tlha->gid = archive_le32dec(extdheader+4);\n\t\t\t\tlha->uid = archive_le32dec(extdheader+8);\n\t\t\t\tlha->birthtime = archive_le32dec(extdheader+12);\n\t\t\t\tlha->atime = archive_le32dec(extdheader+16);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET\n\t\t\t\t    | BIRTHTIME_IS_SET | ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_TIMEZONE:\t\t/* Not supported */\n\t\tcase EXT_UTF16_FILENAME:\t/* Not supported */\n\t\tcase EXT_UTF16_DIRECTORY:\t/* Not supported */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t__archive_read_consume(a, extdsize);\n\t}\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid extended LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\nlha_end_of_entry(struct archive_read *a)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tint r = ARCHIVE_EOF;\n\n\tif (!lha->end_of_entry_cleanup) {\n\t\tif ((lha->setflag & CRC_IS_SET) &&\n\t\t    lha->crc != lha->entry_crc_calculated) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"LHa data CRC error\");\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\n\t\t/* End-of-entry cleanup done. */\n\t\tlha->end_of_entry_cleanup = 1;\n\t}\n\treturn (r);\n}\n\nstatic int\narchive_read_format_lha_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tint r;\n\n\tif (lha->entry_unconsumed) {\n\t\t/* Consume as much as the decompressor actually used. */\n\t\t__archive_read_consume(a, lha->entry_unconsumed);\n\t\tlha->entry_unconsumed = 0;\n\t}\n\tif (lha->end_of_entry) {\n\t\t*offset = lha->entry_offset;\n\t\t*size = 0;\n\t\t*buff = NULL;\n\t\treturn (lha_end_of_entry(a));\n\t}\n\n\tif (lha->entry_is_compressed)\n\t\tr =  lha_read_data_lzh(a, buff, size, offset);\n\telse\n\t\t/* No compression. */\n\t\tr =  lha_read_data_none(a, buff, size, offset);\n\treturn (r);\n}\n\n/*\n * Read a file content in no compression.\n *\n * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets\n * lha->end_of_entry if it consumes all of the data.\n */\nstatic int\nlha_read_data_none(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tssize_t bytes_avail;\n\n\tif (lha->entry_bytes_remaining == 0) {\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = lha->entry_offset;\n\t\tlha->end_of_entry = 1;\n\t\treturn (ARCHIVE_OK);\n\t}\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail <= 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated LHa file data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (bytes_avail > lha->entry_bytes_remaining)\n\t\tbytes_avail = (ssize_t)lha->entry_bytes_remaining;\n\tlha->entry_crc_calculated =\n\t    lha_crc16(lha->entry_crc_calculated, *buff, bytes_avail);\n\t*size = bytes_avail;\n\t*offset = lha->entry_offset;\n\tlha->entry_offset += bytes_avail;\n\tlha->entry_bytes_remaining -= bytes_avail;\n\tif (lha->entry_bytes_remaining == 0)\n\t\tlha->end_of_entry = 1;\n\tlha->entry_unconsumed = bytes_avail;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Read a file content in LZHUFF encoding.\n *\n * Returns ARCHIVE_OK if successful, returns ARCHIVE_WARN if compression is\n * unsupported, ARCHIVE_FATAL otherwise, sets lha->end_of_entry if it consumes\n * all of the data.\n */\nstatic int\nlha_read_data_lzh(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tssize_t bytes_avail;\n\tint r;\n\n\t/* If we haven't yet read any data, initialize the decompressor. */\n\tif (!lha->decompress_init) {\n\t\tr = lzh_decode_init(&(lha->strm), lha->method);\n\t\tswitch (r) {\n\t\tcase ARCHIVE_OK:\n\t\t\tbreak;\n\t\tcase ARCHIVE_FAILED:\n        \t\t/* Unsupported compression. */\n\t\t\t*buff = NULL;\n\t\t\t*size = 0;\n\t\t\t*offset = 0;\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unsupported lzh compression method -%c%c%c-\",\n\t\t\t    lha->method[0], lha->method[1], lha->method[2]);\n\t\t\t/* We know compressed size; just skip it. */\n\t\t\tarchive_read_format_lha_read_data_skip(a);\n\t\t\treturn (ARCHIVE_WARN);\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Couldn't allocate memory \"\n\t\t\t    \"for lzh decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* We've initialized decompression for this stream. */\n\t\tlha->decompress_init = 1;\n\t\tlha->strm.avail_out = 0;\n\t\tlha->strm.total_out = 0;\n\t}\n\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\tlha->strm.next_in = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail <= 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated LHa file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (bytes_avail > lha->entry_bytes_remaining)\n\t\tbytes_avail = (ssize_t)lha->entry_bytes_remaining;\n\n\tlha->strm.avail_in = (int)bytes_avail;\n\tlha->strm.total_in = 0;\n\tlha->strm.avail_out = 0;\n\n\tr = lzh_decode(&(lha->strm), bytes_avail == lha->entry_bytes_remaining);\n\tswitch (r) {\n\tcase ARCHIVE_OK:\n\t\tbreak;\n\tcase ARCHIVE_EOF:\n\t\tlha->end_of_entry = 1;\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Bad lzh data\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tlha->entry_unconsumed = lha->strm.total_in;\n\tlha->entry_bytes_remaining -= lha->strm.total_in;\n\n\tif (lha->strm.avail_out) {\n\t\t*offset = lha->entry_offset;\n\t\t*size = lha->strm.avail_out;\n\t\t*buff = lha->strm.ref_ptr;\n\t\tlha->entry_crc_calculated =\n\t\t    lha_crc16(lha->entry_crc_calculated, *buff, *size);\n\t\tlha->entry_offset += *size;\n\t} else {\n\t\t*offset = lha->entry_offset;\n\t\t*size = 0;\n\t\t*buff = NULL;\n\t\tif (lha->end_of_entry)\n\t\t\treturn (lha_end_of_entry(a));\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Skip a file content.\n */\nstatic int\narchive_read_format_lha_read_data_skip(struct archive_read *a)\n{\n\tstruct lha *lha;\n\tint64_t bytes_skipped;\n\n\tlha = (struct lha *)(a->format->data);\n\n\tif (lha->entry_unconsumed) {\n\t\t/* Consume as much as the decompressor actually used. */\n\t\t__archive_read_consume(a, lha->entry_unconsumed);\n\t\tlha->entry_unconsumed = 0;\n\t}\n\n\t/* if we've already read to end of data, we're done. */\n\tif (lha->end_of_entry_cleanup)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * If the length is at the beginning, we can skip the\n\t * compressed data much more quickly.\n\t */\n\tbytes_skipped = __archive_read_consume(a, lha->entry_bytes_remaining);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/* This entry is finished and done. */\n\tlha->end_of_entry_cleanup = lha->end_of_entry = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_lha_cleanup(struct archive_read *a)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\n\tlzh_decode_free(&(lha->strm));\n\tarchive_string_free(&(lha->dirname));\n\tarchive_string_free(&(lha->filename));\n\tarchive_string_free(&(lha->uname));\n\tarchive_string_free(&(lha->gname));\n\tarchive_wstring_free(&(lha->ws));\n\tfree(lha);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * 'LHa for UNIX' utility has archived a symbolic-link name after\n * a pathname with '|' character.\n * This function extracts the symbolic-link name from the pathname.\n *\n * example.\n *   1. a symbolic-name is 'aaa/bb/cc'\n *   2. a filename is 'xxx/bbb'\n *  then a archived pathname is 'xxx/bbb|aaa/bb/cc'\n */\nstatic int\nlha_parse_linkname(struct archive_string *linkname,\n    struct archive_string *pathname)\n{\n\tchar *\tlinkptr;\n\tsize_t \tsymlen;\n\n\tlinkptr = strchr(pathname->s, '|');\n\tif (linkptr != NULL) {\n\t\tsymlen = strlen(linkptr + 1);\n\t\tarchive_strncpy(linkname, linkptr+1, symlen);\n\n\t\t*linkptr = 0;\n\t\tpathname->length = strlen(pathname->s);\n\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Convert an MSDOS-style date/time into Unix-style time. */\nstatic time_t\nlha_dos_time(const unsigned char *p)\n{\n\tint msTime, msDate;\n\tstruct tm ts;\n\n\tmsTime = archive_le16dec(p);\n\tmsDate = archive_le16dec(p+2);\n\n\tmemset(&ts, 0, sizeof(ts));\n\tts.tm_year = ((msDate >> 9) & 0x7f) + 80;   /* Years since 1900. */\n\tts.tm_mon = ((msDate >> 5) & 0x0f) - 1;     /* Month number.     */\n\tts.tm_mday = msDate & 0x1f;\t\t    /* Day of month.     */\n\tts.tm_hour = (msTime >> 11) & 0x1f;\n\tts.tm_min = (msTime >> 5) & 0x3f;\n\tts.tm_sec = (msTime << 1) & 0x3e;\n\tts.tm_isdst = -1;\n\treturn (mktime(&ts));\n}\n\n/* Convert an MS-Windows-style date/time into Unix-style time. */\nstatic time_t\nlha_win_time(uint64_t wintime, long *ns)\n{\n#define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)\n\n\tif (wintime >= EPOC_TIME) {\n\t\twintime -= EPOC_TIME;\t/* 1970-01-01 00:00:00 (UTC) */\n\t\tif (ns != NULL)\n\t\t\t*ns = (long)(wintime % 10000000) * 100;\n\t\treturn (wintime / 10000000);\n\t} else {\n\t\tif (ns != NULL)\n\t\t\t*ns = 0;\n\t\treturn (0);\n\t}\n}\n\nstatic unsigned char\nlha_calcsum(unsigned char sum, const void *pp, int offset, size_t size)\n{\n\tunsigned char const *p = (unsigned char const *)pp;\n\n\tp += offset;\n\tfor (;size > 0; --size)\n\t\tsum += *p++;\n\treturn (sum);\n}\n\nstatic uint16_t crc16tbl[2][256];\nstatic void\nlha_crc16_init(void)\n{\n\tunsigned int i;\n\tstatic int crc16init = 0;\n\n\tif (crc16init)\n\t\treturn;\n\tcrc16init = 1;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tunsigned int j;\n\t\tuint16_t crc = (uint16_t)i;\n\t\tfor (j = 8; j; j--)\n\t\t\tcrc = (crc >> 1) ^ ((crc & 1) * 0xA001);\n\t\tcrc16tbl[0][i] = crc;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tcrc16tbl[1][i] = (crc16tbl[0][i] >> 8)\n\t\t\t^ crc16tbl[0][crc16tbl[0][i] & 0xff];\n\t}\n}\n\nstatic uint16_t\nlha_crc16(uint16_t crc, const void *pp, size_t len)\n{\n\tconst unsigned char *p = (const unsigned char *)pp;\n\tconst uint16_t *buff;\n\tconst union {\n\t\tuint32_t i;\n\t\tchar c[4];\n\t} u = { 0x01020304 };\n\n\tif (len == 0)\n\t\treturn crc;\n\n\t/* Process unaligned address. */\n\tif (((uintptr_t)p) & (uintptr_t)0x1) {\n\t\tcrc = (crc >> 8) ^ crc16tbl[0][(crc ^ *p++) & 0xff];\n\t\tlen--;\n\t}\n\tbuff = (const uint16_t *)p;\n\t/*\n\t * Modern C compiler such as GCC does not unroll automatically yet\n\t * without unrolling pragma, and Clang is so. So we should\n\t * unroll this loop for its performance.\n\t */\n\tfor (;len >= 8; len -= 8) {\n\t\t/* This if statement expects compiler optimization will\n\t\t * remove the statement which will not be executed. */\n#undef bswap16\n#if defined(_MSC_VER) && _MSC_VER >= 1400  /* Visual Studio */\n#  define bswap16(x) _byteswap_ushort(x)\n#elif defined(__GNUC__) && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || __GNUC__ > 4)\n/* GCC 4.8 and later has __builtin_bswap16() */\n#  define bswap16(x) __builtin_bswap16(x)\n#elif defined(__clang__)\n/* All clang versions have __builtin_bswap16() */\n#  define bswap16(x) __builtin_bswap16(x)\n#else\n#  define bswap16(x) ((((x) >> 8) & 0xff) | ((x) << 8))\n#endif\n#define CRC16W\tdo { \t\\\n\t\tif(u.c[0] == 1) { /* Big endian */\t\t\\\n\t\t\tcrc ^= bswap16(*buff); buff++;\t\t\\\n\t\t} else\t\t\t\t\t\t\\\n\t\t\tcrc ^= *buff++;\t\t\t\t\\\n\t\tcrc = crc16tbl[1][crc & 0xff] ^ crc16tbl[0][crc >> 8];\\\n} while (0)\n\t\tCRC16W;\n\t\tCRC16W;\n\t\tCRC16W;\n\t\tCRC16W;\n#undef CRC16W\n#undef bswap16\n\t}\n\n\tp = (const unsigned char *)buff;\n\tfor (;len; len--) {\n\t\tcrc = (crc >> 8) ^ crc16tbl[0][(crc ^ *p++) & 0xff];\n\t}\n\treturn crc;\n}\n\n/*\n * Initialize LZHUF decoder.\n *\n * Returns ARCHIVE_OK if initialization was successful.\n * Returns ARCHIVE_FAILED if method is unsupported.\n * Returns ARCHIVE_FATAL if initialization failed; memory allocation\n * error occurred.\n */\nstatic int\nlzh_decode_init(struct lzh_stream *strm, const char *method)\n{\n\tstruct lzh_dec *ds;\n\tint w_bits, w_size;\n\n\tif (strm->ds == NULL) {\n\t\tstrm->ds = calloc(1, sizeof(*strm->ds));\n\t\tif (strm->ds == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tds = strm->ds;\n\tds->error = ARCHIVE_FAILED;\n\tif (method == NULL || method[0] != 'l' || method[1] != 'h')\n\t\treturn (ARCHIVE_FAILED);\n\tswitch (method[2]) {\n\tcase '5':\n\t\tw_bits = 13;/* 8KiB for window */\n\t\tbreak;\n\tcase '6':\n\t\tw_bits = 15;/* 32KiB for window */\n\t\tbreak;\n\tcase '7':\n\t\tw_bits = 16;/* 64KiB for window */\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FAILED);/* Not supported. */\n\t}\n\tds->error = ARCHIVE_FATAL;\n\t/* Expand a window size up to 128 KiB for decompressing process\n\t * performance whatever its original window size is. */\n\tds->w_size = 1U << 17;\n\tds->w_mask = ds->w_size -1;\n\tif (ds->w_buff == NULL) {\n\t\tds->w_buff = malloc(ds->w_size);\n\t\tif (ds->w_buff == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tw_size = 1U << w_bits;\n\tmemset(ds->w_buff + ds->w_size - w_size, 0x20, w_size);\n\tds->w_pos = 0;\n\tds->state = 0;\n\tds->pos_pt_len_size = w_bits + 1;\n\tds->pos_pt_len_bits = (w_bits == 15 || w_bits == 16)? 5: 4;\n\tds->literal_pt_len_size = PT_BITLEN_SIZE;\n\tds->literal_pt_len_bits = 5;\n\tds->br.cache_buffer = 0;\n\tds->br.cache_avail = 0;\n\n\tif (lzh_huffman_init(&(ds->lt), LT_BITLEN_SIZE, 16)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tds->lt.len_bits = 9;\n\tif (lzh_huffman_init(&(ds->pt), PT_BITLEN_SIZE, 16)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tds->error = 0;\n\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Release LZHUF decoder.\n */\nstatic void\nlzh_decode_free(struct lzh_stream *strm)\n{\n\n\tif (strm->ds == NULL)\n\t\treturn;\n\tfree(strm->ds->w_buff);\n\tlzh_huffman_free(&(strm->ds->lt));\n\tlzh_huffman_free(&(strm->ds->pt));\n\tfree(strm->ds);\n\tstrm->ds = NULL;\n}\n\n/*\n * Bit stream reader.\n */\n/* Check that the cache buffer has enough bits. */\n#define lzh_br_has(br, n)\t((br)->cache_avail >= n)\n/* Get compressed data by bit. */\n#define lzh_br_bits(br, n)\t\t\t\t\\\n\t(((uint16_t)((br)->cache_buffer >>\t\t\\\n\t\t((br)->cache_avail - (n)))) & cache_masks[n])\n#define lzh_br_bits_forced(br, n)\t\t\t\\\n\t(((uint16_t)((br)->cache_buffer <<\t\t\\\n\t\t((n) - (br)->cache_avail))) & cache_masks[n])\n/* Read ahead to make sure the cache buffer has enough compressed data we\n * will use.\n *  True  : completed, there is enough data in the cache buffer.\n *  False : we met that strm->next_in is empty, we have to get following\n *          bytes. */\n#define lzh_br_read_ahead_0(strm, br, n)\t\\\n\t(lzh_br_has(br, (n)) || lzh_br_fillup(strm, br))\n/*  True  : the cache buffer has some bits as much as we need.\n *  False : there are no enough bits in the cache buffer to be used,\n *          we have to get following bytes if we could. */\n#define lzh_br_read_ahead(strm, br, n)\t\\\n\t(lzh_br_read_ahead_0((strm), (br), (n)) || lzh_br_has((br), (n)))\n\n/* Notify how many bits we consumed. */\n#define lzh_br_consume(br, n)\t((br)->cache_avail -= (n))\n#define lzh_br_unconsume(br, n)\t((br)->cache_avail += (n))\n\nstatic const uint16_t cache_masks[] = {\n\t0x0000, 0x0001, 0x0003, 0x0007,\n\t0x000F, 0x001F, 0x003F, 0x007F,\n\t0x00FF, 0x01FF, 0x03FF, 0x07FF,\n\t0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF,\n\t0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF\n};\n\n/*\n * Shift away used bits in the cache data and fill it up with following bits.\n * Call this when cache buffer does not have enough bits you need.\n *\n * Returns 1 if the cache buffer is full.\n * Returns 0 if the cache buffer is not full; input buffer is empty.\n */\nstatic int\nlzh_br_fillup(struct lzh_stream *strm, struct lzh_br *br)\n{\n\tint n = CACHE_BITS - br->cache_avail;\n\n\tfor (;;) {\n\t\tconst int x = n >> 3;\n\t\tif (strm->avail_in >= x) {\n\t\t\tswitch (x) {\n\t\t\tcase 8:\n\t\t\t\tbr->cache_buffer =\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 56 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 48 |\n\t\t\t\t    ((uint64_t)strm->next_in[2]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[3]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[5]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[6]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[7];\n\t\t\t\tstrm->next_in += 8;\n\t\t\t\tstrm->avail_in -= 8;\n\t\t\t\tbr->cache_avail += 8 * 8;\n\t\t\t\treturn (1);\n\t\t\tcase 7:\n\t\t\t\tbr->cache_buffer =\n\t\t \t\t   (br->cache_buffer << 56) |\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 48 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[2]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[3]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[5]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[6];\n\t\t\t\tstrm->next_in += 7;\n\t\t\t\tstrm->avail_in -= 7;\n\t\t\t\tbr->cache_avail += 7 * 8;\n\t\t\t\treturn (1);\n\t\t\tcase 6:\n\t\t\t\tbr->cache_buffer =\n\t\t \t\t   (br->cache_buffer << 48) |\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[2]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[3]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[5];\n\t\t\t\tstrm->next_in += 6;\n\t\t\t\tstrm->avail_in -= 6;\n\t\t\t\tbr->cache_avail += 6 * 8;\n\t\t\t\treturn (1);\n\t\t\tcase 0:\n\t\t\t\t/* We have enough compressed data in\n\t\t\t\t * the cache buffer.*/\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (strm->avail_in == 0) {\n\t\t\t/* There is not enough compressed data to fill up the\n\t\t\t * cache buffer. */\n\t\t\treturn (0);\n\t\t}\n\t\tbr->cache_buffer =\n\t\t   (br->cache_buffer << 8) | *strm->next_in++;\n\t\tstrm->avail_in--;\n\t\tbr->cache_avail += 8;\n\t\tn -= 8;\n\t}\n}\n\n/*\n * Decode LZHUF.\n *\n * 1. Returns ARCHIVE_OK if output buffer or input buffer are empty.\n *    Please set available buffer and call this function again.\n * 2. Returns ARCHIVE_EOF if decompression has been completed.\n * 3. Returns ARCHIVE_FAILED if an error occurred; compressed data\n *    is broken or you do not set 'last' flag properly.\n * 4. 'last' flag is very important, you must set 1 to the flag if there\n *    is no input data. The lha compressed data format does not provide how\n *    to know the compressed data is really finished.\n *    Note: lha command utility check if the total size of output bytes is\n *    reached the uncompressed size recorded in its header. it does not mind\n *    that the decoding process is properly finished.\n *    GNU ZIP can decompress another compressed file made by SCO LZH compress.\n *    it handles EOF as null to fill read buffer with zero until the decoding\n *    process meet 2 bytes of zeros at reading a size of a next chunk, so the\n *    zeros are treated as the mark of the end of the data although the zeros\n *    is dummy, not the file data.\n */\nstatic int\tlzh_read_blocks(struct lzh_stream *, int);\nstatic int\tlzh_decode_blocks(struct lzh_stream *, int);\n#define ST_RD_BLOCK\t\t0\n#define ST_RD_PT_1\t\t1\n#define ST_RD_PT_2\t\t2\n#define ST_RD_PT_3\t\t3\n#define ST_RD_PT_4\t\t4\n#define ST_RD_LITERAL_1\t\t5\n#define ST_RD_LITERAL_2\t\t6\n#define ST_RD_LITERAL_3\t\t7\n#define ST_RD_POS_DATA_1\t8\n#define ST_GET_LITERAL\t\t9\n#define ST_GET_POS_1\t\t10\n#define ST_GET_POS_2\t\t11\n#define ST_COPY_DATA\t\t12\n\nstatic int\nlzh_decode(struct lzh_stream *strm, int last)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tint avail_in;\n\tint r;\n\n\tif (ds->error)\n\t\treturn (ds->error);\n\n\tavail_in = strm->avail_in;\n\tdo {\n\t\tif (ds->state < ST_GET_LITERAL)\n\t\t\tr = lzh_read_blocks(strm, last);\n\t\telse\n\t\t\tr = lzh_decode_blocks(strm, last);\n\t} while (r == 100);\n\tstrm->total_in += avail_in - strm->avail_in;\n\treturn (r);\n}\n\nstatic void\nlzh_emit_window(struct lzh_stream *strm, size_t s)\n{\n\tstrm->ref_ptr = strm->ds->w_buff;\n\tstrm->avail_out = (int)s;\n\tstrm->total_out += s;\n}\n\nstatic int\nlzh_read_blocks(struct lzh_stream *strm, int last)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tstruct lzh_br *br = &(ds->br);\n\tint c = 0, i;\n\tunsigned rbits;\n\n\tfor (;;) {\n\t\tswitch (ds->state) {\n\t\tcase ST_RD_BLOCK:\n\t\t\t/*\n\t\t\t * Read a block number indicates how many blocks\n\t\t\t * we will handle. The block is composed of a\n\t\t\t * literal and a match, sometimes a literal only\n\t\t\t * in particular, there are no reference data at\n\t\t\t * the beginning of the decompression.\n\t\t\t */\n\t\t\tif (!lzh_br_read_ahead_0(strm, br, 16)) {\n\t\t\t\tif (!last)\n\t\t\t\t\t/* We need following data. */\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\tif (lzh_br_has(br, 8)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * It seems there are extra bits.\n\t\t\t\t\t *  1. Compressed data is broken.\n\t\t\t\t\t *  2. `last' flag does not properly\n\t\t\t\t\t *     set.\n\t\t\t\t\t */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tif (ds->w_pos > 0) {\n\t\t\t\t\tlzh_emit_window(strm, ds->w_pos);\n\t\t\t\t\tds->w_pos = 0;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\t/* End of compressed data; we have completely\n\t\t\t\t * handled all compressed data. */\n\t\t\t\treturn (ARCHIVE_EOF);\n\t\t\t}\n\t\t\tds->blocks_avail = lzh_br_bits(br, 16);\n\t\t\tif (ds->blocks_avail == 0)\n\t\t\t\tgoto failed;\n\t\t\tlzh_br_consume(br, 16);\n\t\t\t/*\n\t\t\t * Read a literal table compressed in huffman\n\t\t\t * coding.\n\t\t\t */\n\t\t\tds->pt.len_size = ds->literal_pt_len_size;\n\t\t\tds->pt.len_bits = ds->literal_pt_len_bits;\n\t\t\tds->reading_position = 0;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_1:\n\t\t\t/* Note: ST_RD_PT_1, ST_RD_PT_2 and ST_RD_PT_4 are\n\t\t\t * used in reading both a literal table and a\n\t\t\t * position table. */\n\t\t\tif (!lzh_br_read_ahead(strm, br, ds->pt.len_bits)) {\n\t\t\t\tif (last)\n\t\t\t\t\tgoto failed;/* Truncated data. */\n\t\t\t\tds->state = ST_RD_PT_1;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tds->pt.len_avail = lzh_br_bits(br, ds->pt.len_bits);\n\t\t\tlzh_br_consume(br, ds->pt.len_bits);\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_2:\n\t\t\tif (ds->pt.len_avail == 0) {\n\t\t\t\t/* There is no bitlen. */\n\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t    ds->pt.len_bits)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tds->state = ST_RD_PT_2;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\tif (!lzh_make_fake_table(&(ds->pt),\n\t\t\t\t    lzh_br_bits(br, ds->pt.len_bits)))\n\t\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\t\tlzh_br_consume(br, ds->pt.len_bits);\n\t\t\t\tif (ds->reading_position)\n\t\t\t\t\tds->state = ST_GET_LITERAL;\n\t\t\t\telse\n\t\t\t\t\tds->state = ST_RD_LITERAL_1;\n\t\t\t\tbreak;\n\t\t\t} else if (ds->pt.len_avail > ds->pt.len_size)\n\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\tds->loop = 0;\n\t\t\tmemset(ds->pt.freq, 0, sizeof(ds->pt.freq));\n\t\t\tif (ds->pt.len_avail < 3 ||\n\t\t\t    ds->pt.len_size == ds->pos_pt_len_size) {\n\t\t\t\tds->state = ST_RD_PT_4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_3:\n\t\t\tds->loop = lzh_read_pt_bitlen(strm, ds->loop, 3);\n\t\t\tif (ds->loop < 3) {\n\t\t\t\tif (ds->loop < 0 || last)\n\t\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\t\t/* Not completed, get following data. */\n\t\t\t\tds->state = ST_RD_PT_3;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\t/* There are some null in bitlen of the literal. */\n\t\t\tif (!lzh_br_read_ahead(strm, br, 2)) {\n\t\t\t\tif (last)\n\t\t\t\t\tgoto failed;/* Truncated data. */\n\t\t\t\tds->state = ST_RD_PT_3;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tc = lzh_br_bits(br, 2);\n\t\t\tlzh_br_consume(br, 2);\n\t\t\tif (c > ds->pt.len_avail - 3)\n\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\tfor (i = 3; c-- > 0 ;)\n\t\t\t\tds->pt.bitlen[i++] = 0;\n\t\t\tds->loop = i;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_4:\n\t\t\tds->loop = lzh_read_pt_bitlen(strm, ds->loop,\n\t\t\t    ds->pt.len_avail);\n\t\t\tif (ds->loop < ds->pt.len_avail) {\n\t\t\t\tif (ds->loop < 0 || last)\n\t\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\t\t/* Not completed, get following data. */\n\t\t\t\tds->state = ST_RD_PT_4;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tif (!lzh_make_huffman_table(&(ds->pt)))\n\t\t\t\tgoto failed;/* Invalid data */\n\t\t\tif (ds->reading_position) {\n\t\t\t\tds->state = ST_GET_LITERAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_LITERAL_1:\n\t\t\tif (!lzh_br_read_ahead(strm, br, ds->lt.len_bits)) {\n\t\t\t\tif (last)\n\t\t\t\t\tgoto failed;/* Truncated data. */\n\t\t\t\tds->state = ST_RD_LITERAL_1;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tds->lt.len_avail = lzh_br_bits(br, ds->lt.len_bits);\n\t\t\tlzh_br_consume(br, ds->lt.len_bits);\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_LITERAL_2:\n\t\t\tif (ds->lt.len_avail == 0) {\n\t\t\t\t/* There is no bitlen. */\n\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t    ds->lt.len_bits)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tds->state = ST_RD_LITERAL_2;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\tif (!lzh_make_fake_table(&(ds->lt),\n\t\t\t\t    lzh_br_bits(br, ds->lt.len_bits)))\n\t\t\t\t\tgoto failed;/* Invalid data */\n\t\t\t\tlzh_br_consume(br, ds->lt.len_bits);\n\t\t\t\tds->state = ST_RD_POS_DATA_1;\n\t\t\t\tbreak;\n\t\t\t} else if (ds->lt.len_avail > ds->lt.len_size)\n\t\t\t\tgoto failed;/* Invalid data */\n\t\t\tds->loop = 0;\n\t\t\tmemset(ds->lt.freq, 0, sizeof(ds->lt.freq));\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_LITERAL_3:\n\t\t\ti = ds->loop;\n\t\t\twhile (i < ds->lt.len_avail) {\n\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t    ds->pt.max_bits)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tds->loop = i;\n\t\t\t\t\tds->state = ST_RD_LITERAL_3;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\trbits = lzh_br_bits(br, ds->pt.max_bits);\n\t\t\t\tc = lzh_decode_huffman(&(ds->pt), rbits);\n\t\t\t\tif (c > 2) {\n\t\t\t\t\t/* Note: 'c' will never be more than\n\t\t\t\t\t * eighteen since it's limited by\n\t\t\t\t\t * PT_BITLEN_SIZE, which is being set\n\t\t\t\t\t * to ds->pt.len_size through\n\t\t\t\t\t * ds->literal_pt_len_size. */\n\t\t\t\t\tlzh_br_consume(br, ds->pt.bitlen[c]);\n\t\t\t\t\tc -= 2;\n\t\t\t\t\tds->lt.freq[c]++;\n\t\t\t\t\tds->lt.bitlen[i++] = c;\n\t\t\t\t} else if (c == 0) {\n\t\t\t\t\tlzh_br_consume(br, ds->pt.bitlen[c]);\n\t\t\t\t\tds->lt.bitlen[i++] = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* c == 1 or c == 2 */\n\t\t\t\t\tint n = (c == 1)?4:9;\n\t\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t\t     ds->pt.bitlen[c] + n)) {\n\t\t\t\t\t\tif (last) /* Truncated data. */\n\t\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\tds->loop = i;\n\t\t\t\t\t\tds->state = ST_RD_LITERAL_3;\n\t\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t\t}\n\t\t\t\t\tlzh_br_consume(br, ds->pt.bitlen[c]);\n\t\t\t\t\tc = lzh_br_bits(br, n);\n\t\t\t\t\tlzh_br_consume(br, n);\n\t\t\t\t\tc += (n == 4)?3:20;\n\t\t\t\t\tif (i + c > ds->lt.len_avail)\n\t\t\t\t\t\tgoto failed;/* Invalid data */\n\t\t\t\t\tmemset(&(ds->lt.bitlen[i]), 0, c);\n\t\t\t\t\ti += c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > ds->lt.len_avail ||\n\t\t\t    !lzh_make_huffman_table(&(ds->lt)))\n\t\t\t\tgoto failed;/* Invalid data */\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_POS_DATA_1:\n\t\t\t/*\n\t\t\t * Read a position table compressed in huffman\n\t\t\t * coding.\n\t\t\t */\n\t\t\tds->pt.len_size = ds->pos_pt_len_size;\n\t\t\tds->pt.len_bits = ds->pos_pt_len_bits;\n\t\t\tds->reading_position = 1;\n\t\t\tds->state = ST_RD_PT_1;\n\t\t\tbreak;\n\t\tcase ST_GET_LITERAL:\n\t\t\treturn (100);\n\t\t}\n\t}\nfailed:\n\treturn (ds->error = ARCHIVE_FAILED);\n}\n\nstatic int\nlzh_decode_blocks(struct lzh_stream *strm, int last)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tstruct lzh_br bre = ds->br;\n\tstruct huffman *lt = &(ds->lt);\n\tstruct huffman *pt = &(ds->pt);\n\tunsigned char *w_buff = ds->w_buff;\n\tunsigned char *lt_bitlen = lt->bitlen;\n\tunsigned char *pt_bitlen = pt->bitlen;\n\tint blocks_avail = ds->blocks_avail, c = 0;\n\tint copy_len = ds->copy_len, copy_pos = ds->copy_pos;\n\tint w_pos = ds->w_pos, w_mask = ds->w_mask, w_size = ds->w_size;\n\tint lt_max_bits = lt->max_bits, pt_max_bits = pt->max_bits;\n\tint state = ds->state;\n\n\tfor (;;) {\n\t\tswitch (state) {\n\t\tcase ST_GET_LITERAL:\n\t\t\tfor (;;) {\n\t\t\t\tif (blocks_avail == 0) {\n\t\t\t\t\t/* We have decoded all blocks.\n\t\t\t\t\t * Let's handle next blocks. */\n\t\t\t\t\tds->state = ST_RD_BLOCK;\n\t\t\t\t\tds->br = bre;\n\t\t\t\t\tds->blocks_avail = 0;\n\t\t\t\t\tds->w_pos = w_pos;\n\t\t\t\t\tds->copy_pos = 0;\n\t\t\t\t\treturn (100);\n\t\t\t\t}\n\n\t\t\t\t/* lzh_br_read_ahead() always try to fill the\n\t\t\t\t * cache buffer up. In specific situation we\n\t\t\t\t * are close to the end of the data, the cache\n\t\t\t\t * buffer will not be full and thus we have to\n\t\t\t\t * determine if the cache buffer has some bits\n\t\t\t\t * as much as we need after lzh_br_read_ahead()\n\t\t\t\t * failed. */\n\t\t\t\tif (!lzh_br_read_ahead(strm, &bre,\n\t\t\t\t    lt_max_bits)) {\n\t\t\t\t\tif (!last)\n\t\t\t\t\t\tgoto next_data;\n\t\t\t\t\t/* Remaining bits are less than\n\t\t\t\t\t * maximum bits(lt.max_bits) but maybe\n\t\t\t\t\t * it still remains as much as we need,\n\t\t\t\t\t * so we should try to use it with\n\t\t\t\t\t * dummy bits. */\n\t\t\t\t\tc = lzh_decode_huffman(lt,\n\t\t\t\t\t      lzh_br_bits_forced(&bre,\n\t\t\t\t\t        lt_max_bits));\n\t\t\t\t\tlzh_br_consume(&bre, lt_bitlen[c]);\n\t\t\t\t\tif (!lzh_br_has(&bre, 0))\n\t\t\t\t\t\tgoto failed;/* Over read. */\n\t\t\t\t} else {\n\t\t\t\t\tc = lzh_decode_huffman(lt,\n\t\t\t\t\t      lzh_br_bits(&bre, lt_max_bits));\n\t\t\t\t\tlzh_br_consume(&bre, lt_bitlen[c]);\n\t\t\t\t}\n\t\t\t\tblocks_avail--;\n\t\t\t\tif (c > UCHAR_MAX)\n\t\t\t\t\t/* Current block is a match data. */\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * 'c' is exactly a literal code.\n\t\t\t\t */\n\t\t\t\t/* Save a decoded code to reference it\n\t\t\t\t * afterward. */\n\t\t\t\tw_buff[w_pos] = c;\n\t\t\t\tif (++w_pos >= w_size) {\n\t\t\t\t\tw_pos = 0;\n\t\t\t\t\tlzh_emit_window(strm, w_size);\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 'c' is the length of a match pattern we have\n\t\t\t * already extracted, which has be stored in\n\t\t\t * window(ds->w_buff). */\n\t\t\tcopy_len = c - (UCHAR_MAX + 1) + MINMATCH;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_GET_POS_1:\n\t\t\t/*\n\t\t\t * Get a reference position. \n\t\t\t */\n\t\t\tif (!lzh_br_read_ahead(strm, &bre, pt_max_bits)) {\n\t\t\t\tif (!last) {\n\t\t\t\t\tstate = ST_GET_POS_1;\n\t\t\t\t\tds->copy_len = copy_len;\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t\tcopy_pos = lzh_decode_huffman(pt,\n\t\t\t\t    lzh_br_bits_forced(&bre, pt_max_bits));\n\t\t\t\tlzh_br_consume(&bre, pt_bitlen[copy_pos]);\n\t\t\t\tif (!lzh_br_has(&bre, 0))\n\t\t\t\t\tgoto failed;/* Over read. */\n\t\t\t} else {\n\t\t\t\tcopy_pos = lzh_decode_huffman(pt,\n\t\t\t\t    lzh_br_bits(&bre, pt_max_bits));\n\t\t\t\tlzh_br_consume(&bre, pt_bitlen[copy_pos]);\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_GET_POS_2:\n\t\t\tif (copy_pos > 1) {\n\t\t\t\t/* We need an additional adjustment number to\n\t\t\t\t * the position. */\n\t\t\t\tint p = copy_pos - 1;\n\t\t\t\tif (!lzh_br_read_ahead(strm, &bre, p)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tstate = ST_GET_POS_2;\n\t\t\t\t\tds->copy_len = copy_len;\n\t\t\t\t\tds->copy_pos = copy_pos;\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t\tcopy_pos = (1 << p) + lzh_br_bits(&bre, p);\n\t\t\t\tlzh_br_consume(&bre, p);\n\t\t\t}\n\t\t\t/* The position is actually a distance from the last\n\t\t\t * code we had extracted and thus we have to convert\n\t\t\t * it to a position of the window. */\n\t\t\tcopy_pos = (w_pos - copy_pos - 1) & w_mask;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_COPY_DATA:\n\t\t\t/*\n\t\t\t * Copy `copy_len' bytes as extracted data from\n\t\t\t * the window into the output buffer.\n\t\t\t */\n\t\t\tfor (;;) {\n\t\t\t\tint l;\n\n\t\t\t\tl = copy_len;\n\t\t\t\tif (copy_pos > w_pos) {\n\t\t\t\t\tif (l > w_size - copy_pos)\n\t\t\t\t\t\tl = w_size - copy_pos;\n\t\t\t\t} else {\n\t\t\t\t\tif (l > w_size - w_pos)\n\t\t\t\t\t\tl = w_size - w_pos;\n\t\t\t\t}\n\t\t\t\tif ((copy_pos + l < w_pos)\n\t\t\t\t    || (w_pos + l < copy_pos)) {\n\t\t\t\t\t/* No overlap. */\n\t\t\t\t\tmemcpy(w_buff + w_pos,\n\t\t\t\t\t    w_buff + copy_pos, l);\n\t\t\t\t} else {\n\t\t\t\t\tconst unsigned char *s;\n\t\t\t\t\tunsigned char *d;\n\t\t\t\t\tint li;\n\n\t\t\t\t\td = w_buff + w_pos;\n\t\t\t\t\ts = w_buff + copy_pos;\n\t\t\t\t\tfor (li = 0; li < l-1;) {\n\t\t\t\t\t\td[li] = s[li];li++;\n\t\t\t\t\t\td[li] = s[li];li++;\n\t\t\t\t\t}\n\t\t\t\t\tif (li < l)\n\t\t\t\t\t\td[li] = s[li];\n\t\t\t\t}\n\t\t\t\tw_pos += l;\n\t\t\t\tif (w_pos == w_size) {\n\t\t\t\t\tw_pos = 0;\n\t\t\t\t\tlzh_emit_window(strm, w_size);\n\t\t\t\t\tif (copy_len <= l)\n\t\t\t\t\t\tstate = ST_GET_LITERAL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tstate = ST_COPY_DATA;\n\t\t\t\t\t\tds->copy_len = copy_len - l;\n\t\t\t\t\t\tds->copy_pos =\n\t\t\t\t\t\t    (copy_pos + l) & w_mask;\n\t\t\t\t\t}\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t\tif (copy_len <= l)\n\t\t\t\t\t/* A copy of current pattern ended. */\n\t\t\t\t\tbreak;\n\t\t\t\tcopy_len -= l;\n\t\t\t\tcopy_pos = (copy_pos + l) & w_mask;\n\t\t\t}\n\t\t\tstate = ST_GET_LITERAL;\n\t\t\tbreak;\n\t\t}\n\t}\nfailed:\n\treturn (ds->error = ARCHIVE_FAILED);\nnext_data:\n\tds->br = bre;\n\tds->blocks_avail = blocks_avail;\n\tds->state = state;\n\tds->w_pos = w_pos;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nlzh_huffman_init(struct huffman *hf, size_t len_size, int tbl_bits)\n{\n\tint bits;\n\n\tif (hf->bitlen == NULL) {\n\t\thf->bitlen = malloc(len_size * sizeof(hf->bitlen[0]));\n\t\tif (hf->bitlen == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (hf->tbl == NULL) {\n\t\tif (tbl_bits < HTBL_BITS)\n\t\t\tbits = tbl_bits;\n\t\telse\n\t\t\tbits = HTBL_BITS;\n\t\thf->tbl = malloc(((size_t)1 << bits) * sizeof(hf->tbl[0]));\n\t\tif (hf->tbl == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (hf->tree == NULL && tbl_bits > HTBL_BITS) {\n\t\thf->tree_avail = 1 << (tbl_bits - HTBL_BITS + 4);\n\t\thf->tree = malloc(hf->tree_avail * sizeof(hf->tree[0]));\n\t\tif (hf->tree == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\thf->len_size = (int)len_size;\n\thf->tbl_bits = tbl_bits;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nlzh_huffman_free(struct huffman *hf)\n{\n\tfree(hf->bitlen);\n\tfree(hf->tbl);\n\tfree(hf->tree);\n}\n\nstatic char bitlen_tbl[0x400] = {\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n\t11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n\t12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\t13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16,  0\n};\nstatic int\nlzh_read_pt_bitlen(struct lzh_stream *strm, int start, int end)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tstruct lzh_br *br = &(ds->br);\n\tint c, i;\n\n\tfor (i = start; i < end; ) {\n\t\t/*\n\t\t *  bit pattern     the number we need\n\t\t *     000           ->  0\n\t\t *     001           ->  1\n\t\t *     010           ->  2\n\t\t *     ...\n\t\t *     110           ->  6\n\t\t *     1110          ->  7\n\t\t *     11110         ->  8\n\t\t *     ...\n\t\t *     1111111111110 ->  16\n\t\t */\n\t\tif (!lzh_br_read_ahead(strm, br, 3))\n\t\t\treturn (i);\n\t\tif ((c = lzh_br_bits(br, 3)) == 7) {\n\t\t\tif (!lzh_br_read_ahead(strm, br, 13))\n\t\t\t\treturn (i);\n\t\t\tc = bitlen_tbl[lzh_br_bits(br, 13) & 0x3FF];\n\t\t\tif (c)\n\t\t\t\tlzh_br_consume(br, c - 3);\n\t\t\telse\n\t\t\t\treturn (-1);/* Invalid data. */\n\t\t} else\n\t\t\tlzh_br_consume(br, 3);\n\t\tds->pt.bitlen[i++] = c;\n\t\tds->pt.freq[c]++;\n\t}\n\treturn (i);\n}\n\nstatic int\nlzh_make_fake_table(struct huffman *hf, uint16_t c)\n{\n\tif (c >= hf->len_size)\n\t\treturn (0);\n\thf->tbl[0] = c;\n\thf->max_bits = 0;\n\thf->shift_bits = 0;\n\thf->bitlen[hf->tbl[0]] = 0;\n\treturn (1);\n}\n\n/*\n * Make a huffman coding table.\n */\nstatic int\nlzh_make_huffman_table(struct huffman *hf)\n{\n\tuint16_t *tbl;\n\tconst unsigned char *bitlen;\n\tint bitptn[17], weight[17];\n\tint i, maxbits = 0, ptn, tbl_size, w;\n\tint diffbits, len_avail;\n\n\t/*\n\t * Initialize bit patterns.\n\t */\n\tptn = 0;\n\tfor (i = 1, w = 1 << 15; i <= 16; i++, w >>= 1) {\n\t\tbitptn[i] = ptn;\n\t\tweight[i] = w;\n\t\tif (hf->freq[i]) {\n\t\t\tptn += hf->freq[i] * w;\n\t\t\tmaxbits = i;\n\t\t}\n\t}\n\tif (ptn != 0x10000 || maxbits > hf->tbl_bits)\n\t\treturn (0);/* Invalid */\n\n\thf->max_bits = maxbits;\n\n\t/*\n\t * Cut out extra bits which we won't house in the table.\n\t * This preparation reduces the same calculation in the for-loop\n\t * making the table.\n\t */\n\tif (maxbits < 16) {\n\t\tint ebits = 16 - maxbits;\n\t\tfor (i = 1; i <= maxbits; i++) {\n\t\t\tbitptn[i] >>= ebits;\n\t\t\tweight[i] >>= ebits;\n\t\t}\n\t}\n\tif (maxbits > HTBL_BITS) {\n\t\tunsigned htbl_max;\n\t\tuint16_t *p;\n\n\t\tdiffbits = maxbits - HTBL_BITS;\n\t\tfor (i = 1; i <= HTBL_BITS; i++) {\n\t\t\tbitptn[i] >>= diffbits;\n\t\t\tweight[i] >>= diffbits;\n\t\t}\n\t\thtbl_max = bitptn[HTBL_BITS] +\n\t\t    weight[HTBL_BITS] * hf->freq[HTBL_BITS];\n\t\tp = &(hf->tbl[htbl_max]);\n\t\twhile (p < &hf->tbl[1U<<HTBL_BITS])\n\t\t\t*p++ = 0;\n\t} else\n\t\tdiffbits = 0;\n\thf->shift_bits = diffbits;\n\n\t/*\n\t * Make the table.\n\t */\n\ttbl_size = 1 << HTBL_BITS;\n\ttbl = hf->tbl;\n\tbitlen = hf->bitlen;\n\tlen_avail = hf->len_avail;\n\thf->tree_used = 0;\n\tfor (i = 0; i < len_avail; i++) {\n\t\tuint16_t *p;\n\t\tint len, cnt;\n\t\tuint16_t bit;\n\t\tint extlen;\n\t\tstruct htree_t *ht;\n\n\t\tif (bitlen[i] == 0)\n\t\t\tcontinue;\n\t\t/* Get a bit pattern */\n\t\tlen = bitlen[i];\n\t\tptn = bitptn[len];\n\t\tcnt = weight[len];\n\t\tif (len <= HTBL_BITS) {\n\t\t\t/* Calculate next bit pattern */\n\t\t\tif ((bitptn[len] = ptn + cnt) > tbl_size)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\t/* Update the table */\n\t\t\tp = &(tbl[ptn]);\n\t\t\tif (cnt > 7) {\n\t\t\t\tuint16_t *pc;\n\n\t\t\t\tcnt -= 8;\n\t\t\t\tpc = &p[cnt];\n\t\t\t\tpc[0] = (uint16_t)i;\n\t\t\t\tpc[1] = (uint16_t)i;\n\t\t\t\tpc[2] = (uint16_t)i;\n\t\t\t\tpc[3] = (uint16_t)i;\n\t\t\t\tpc[4] = (uint16_t)i;\n\t\t\t\tpc[5] = (uint16_t)i;\n\t\t\t\tpc[6] = (uint16_t)i;\n\t\t\t\tpc[7] = (uint16_t)i;\n\t\t\t\tif (cnt > 7) {\n\t\t\t\t\tcnt -= 8;\n\t\t\t\t\tmemcpy(&p[cnt], pc,\n\t\t\t\t\t\t8 * sizeof(uint16_t));\n\t\t\t\t\tpc = &p[cnt];\n\t\t\t\t\twhile (cnt > 15) {\n\t\t\t\t\t\tcnt -= 16;\n\t\t\t\t\t\tmemcpy(&p[cnt], pc,\n\t\t\t\t\t\t\t16 * sizeof(uint16_t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt)\n\t\t\t\t\tmemcpy(p, pc, cnt * sizeof(uint16_t));\n\t\t\t} else {\n\t\t\t\twhile (cnt > 1) {\n\t\t\t\t\tp[--cnt] = (uint16_t)i;\n\t\t\t\t\tp[--cnt] = (uint16_t)i;\n\t\t\t\t}\n\t\t\t\tif (cnt)\n\t\t\t\t\tp[--cnt] = (uint16_t)i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * A bit length is too big to be housed to a direct table,\n\t\t * so we use a tree model for its extra bits.\n\t\t */\n\t\tbitptn[len] = ptn + cnt;\n\t\tbit = 1U << (diffbits -1);\n\t\textlen = len - HTBL_BITS;\n\t\t\n\t\tp = &(tbl[ptn >> diffbits]);\n\t\tif (*p == 0) {\n\t\t\t*p = len_avail + hf->tree_used;\n\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->left = 0;\n\t\t\tht->right = 0;\n\t\t} else {\n\t\t\tif (*p < len_avail ||\n\t\t\t    *p >= (len_avail + hf->tree_used))\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht = &(hf->tree[*p - len_avail]);\n\t\t}\n\t\twhile (--extlen > 0) {\n\t\t\tif (ptn & bit) {\n\t\t\t\tif (ht->left < len_avail) {\n\t\t\t\t\tht->left = len_avail + hf->tree_used;\n\t\t\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\t\t\treturn (0);/* Invalid */\n\t\t\t\t\tht->left = 0;\n\t\t\t\t\tht->right = 0;\n\t\t\t\t} else {\n\t\t\t\t\tht = &(hf->tree[ht->left - len_avail]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ht->right < len_avail) {\n\t\t\t\t\tht->right = len_avail + hf->tree_used;\n\t\t\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\t\t\treturn (0);/* Invalid */\n\t\t\t\t\tht->left = 0;\n\t\t\t\t\tht->right = 0;\n\t\t\t\t} else {\n\t\t\t\t\tht = &(hf->tree[ht->right - len_avail]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbit >>= 1;\n\t\t}\n\t\tif (ptn & bit) {\n\t\t\tif (ht->left != 0)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->left = (uint16_t)i;\n\t\t} else {\n\t\t\tif (ht->right != 0)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->right = (uint16_t)i;\n\t\t}\n\t}\n\treturn (1);\n}\n\nstatic int\nlzh_decode_huffman_tree(struct huffman *hf, unsigned rbits, int c)\n{\n\tstruct htree_t *ht;\n\tint extlen;\n\n\tht = hf->tree;\n\textlen = hf->shift_bits;\n\twhile (c >= hf->len_avail) {\n\t\tc -= hf->len_avail;\n\t\tif (extlen-- <= 0 || c >= hf->tree_used)\n\t\t\treturn (0);\n\t\tif (rbits & (1U << extlen))\n\t\t\tc = ht[c].left;\n\t\telse\n\t\t\tc = ht[c].right;\n\t}\n\treturn (c);\n}\n\nstatic inline int\nlzh_decode_huffman(struct huffman *hf, unsigned rbits)\n{\n\tint c;\n\t/*\n\t * At first search an index table for a bit pattern.\n\t * If it fails, search a huffman tree for.\n\t */\n\tc = hf->tbl[rbits >> hf->shift_bits];\n\tif (c < hf->len_avail || hf->len_avail == 0)\n\t\treturn (c);\n\t/* This bit pattern needs to be found out at a huffman tree. */\n\treturn (lzh_decode_huffman_tree(hf, rbits, c));\n}\n\n"], "fixing_code": ["/*-\n * Copyright (c) 2008-2014 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n#include \"archive_endian.h\"\n\n\n#define MAXMATCH\t\t256\t/* Maximum match length. */\n#define MINMATCH\t\t3\t/* Minimum match length. */\n/*\n * Literal table format:\n * +0              +256                      +510\n * +---------------+-------------------------+\n * | literal code  |       match length      |\n * |   0 ... 255   |  MINMATCH ... MAXMATCH  |\n * +---------------+-------------------------+\n *  <---          LT_BITLEN_SIZE         --->\n */\n/* Literal table size. */\n#define LT_BITLEN_SIZE\t\t(UCHAR_MAX + 1 + MAXMATCH - MINMATCH + 1)\n/* Position table size.\n * Note: this used for both position table and pre literal table.*/\n#define PT_BITLEN_SIZE\t\t(3 + 16)\n\nstruct lzh_dec {\n\t/* Decoding status. */\n\tint     \t\t state;\n\n\t/*\n\t * Window to see last 8Ki(lh5),32Ki(lh6),64Ki(lh7) bytes of decoded\n\t * data.\n\t */\n\tint\t\t\t w_size;\n\tint\t\t\t w_mask;\n\t/* Window buffer, which is a loop buffer. */\n\tunsigned char\t\t*w_buff;\n\t/* The insert position to the window. */\n\tint\t\t\t w_pos;\n\t/* The position where we can copy decoded code from the window. */\n\tint     \t\t copy_pos;\n\t/* The length how many bytes we can copy decoded code from\n\t * the window. */\n\tint     \t\t copy_len;\n\n\t/*\n\t * Bit stream reader.\n\t */\n\tstruct lzh_br {\n#define CACHE_TYPE\t\tuint64_t\n#define CACHE_BITS\t\t(8 * sizeof(CACHE_TYPE))\n\t \t/* Cache buffer. */\n\t\tCACHE_TYPE\t cache_buffer;\n\t\t/* Indicates how many bits avail in cache_buffer. */\n\t\tint\t\t cache_avail;\n\t} br;\n\n\t/*\n\t * Huffman coding.\n\t */\n\tstruct huffman {\n\t\tint\t\t len_size;\n\t\tint\t\t len_avail;\n\t\tint\t\t len_bits;\n\t\tint\t\t freq[17];\n\t\tunsigned char\t*bitlen;\n\n\t\t/*\n\t\t * Use a index table. It's faster than searching a huffman\n\t\t * coding tree, which is a binary tree. But a use of a large\n\t\t * index table causes L1 cache read miss many times.\n\t\t */\n#define HTBL_BITS\t10\n\t\tint\t\t max_bits;\n\t\tint\t\t shift_bits;\n\t\tint\t\t tbl_bits;\n\t\tint\t\t tree_used;\n\t\tint\t\t tree_avail;\n\t\t/* Direct access table. */\n\t\tuint16_t\t*tbl;\n\t\t/* Binary tree table for extra bits over the direct access. */\n\t\tstruct htree_t {\n\t\t\tuint16_t left;\n\t\t\tuint16_t right;\n\t\t}\t\t*tree;\n\t}\t\t\t lt, pt;\n\n\tint\t\t\t blocks_avail;\n\tint\t\t\t pos_pt_len_size;\n\tint\t\t\t pos_pt_len_bits;\n\tint\t\t\t literal_pt_len_size;\n\tint\t\t\t literal_pt_len_bits;\n\tint\t\t\t reading_position;\n\tint\t\t\t loop;\n\tint\t\t\t error;\n};\n\nstruct lzh_stream {\n\tconst unsigned char\t*next_in;\n\tint\t\t\t avail_in;\n\tint64_t\t\t\t total_in;\n\tconst unsigned char\t*ref_ptr;\n\tint\t\t\t avail_out;\n\tint64_t\t\t\t total_out;\n\tstruct lzh_dec\t\t*ds;\n};\n\nstruct lha {\n\t/* entry_bytes_remaining is the number of bytes we expect.\t    */\n\tint64_t                  entry_offset;\n\tint64_t                  entry_bytes_remaining;\n\tint64_t\t\t\t entry_unconsumed;\n\tuint16_t\t\t entry_crc_calculated;\n \n\tsize_t\t\t\t header_size;\t/* header size\t\t    */\n\tunsigned char\t\t level;\t\t/* header level\t\t    */\n\tchar\t\t\t method[3];\t/* compress type\t    */\n\tint64_t\t\t\t compsize;\t/* compressed data size\t    */\n\tint64_t\t\t\t origsize;\t/* original file size\t    */\n\tint\t\t\t setflag;\n#define BIRTHTIME_IS_SET\t1\n#define ATIME_IS_SET\t\t2\n#define UNIX_MODE_IS_SET\t4\n#define CRC_IS_SET\t\t8\n\ttime_t\t\t\t birthtime;\n\tlong\t\t\t birthtime_tv_nsec;\n\ttime_t\t\t\t mtime;\n\tlong\t\t\t mtime_tv_nsec;\n\ttime_t\t\t\t atime;\n\tlong\t\t\t atime_tv_nsec;\n\tmode_t\t\t\t mode;\n\tint64_t\t\t\t uid;\n\tint64_t\t\t\t gid;\n\tstruct archive_string \t uname;\n\tstruct archive_string \t gname;\n\tuint16_t\t\t header_crc;\n\tuint16_t\t\t crc;\n\tstruct archive_string_conv *sconv;\n\tstruct archive_string_conv *opt_sconv;\n\n\tstruct archive_string \t dirname;\n\tstruct archive_string \t filename;\n\tstruct archive_wstring\t ws;\n\n\tunsigned char\t\t dos_attr;\n\n\t/* Flag to mark progress that an archive was read their first header.*/\n\tchar\t\t\t found_first_header;\n\t/* Flag to mark that indicates an empty directory. */\n\tchar\t\t\t directory;\n\n\t/* Flags to mark progress of decompression. */\n\tchar\t\t\t decompress_init;\n\tchar\t\t\t end_of_entry;\n\tchar\t\t\t end_of_entry_cleanup;\n\tchar\t\t\t entry_is_compressed;\n\n\tchar\t\t\t format_name[64];\n\n\tstruct lzh_stream\t strm;\n};\n\n/*\n * LHA header common member offset.\n */\n#define H_METHOD_OFFSET\t2\t/* Compress type. */\n#define H_ATTR_OFFSET\t19\t/* DOS attribute. */\n#define H_LEVEL_OFFSET\t20\t/* Header Level.  */\n#define H_SIZE\t\t22\t/* Minimum header size. */\n\nstatic int      archive_read_format_lha_bid(struct archive_read *, int);\nstatic int      archive_read_format_lha_options(struct archive_read *,\n\t\t    const char *, const char *);\nstatic int\tarchive_read_format_lha_read_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int\tarchive_read_format_lha_read_data(struct archive_read *,\n\t\t    const void **, size_t *, int64_t *);\nstatic int\tarchive_read_format_lha_read_data_skip(struct archive_read *);\nstatic int\tarchive_read_format_lha_cleanup(struct archive_read *);\n\nstatic void\tlha_replace_path_separator(struct lha *,\n\t\t    struct archive_entry *);\nstatic int\tlha_read_file_header_0(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_header_1(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_header_2(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_header_3(struct archive_read *, struct lha *);\nstatic int\tlha_read_file_extended_header(struct archive_read *,\n\t\t    struct lha *, uint16_t *, int, size_t, size_t *);\nstatic size_t\tlha_check_header_format(const void *);\nstatic int\tlha_skip_sfx(struct archive_read *);\nstatic time_t\tlha_dos_time(const unsigned char *);\nstatic time_t\tlha_win_time(uint64_t, long *);\nstatic unsigned char\tlha_calcsum(unsigned char, const void *,\n\t\t    int, size_t);\nstatic int\tlha_parse_linkname(struct archive_string *,\n\t\t    struct archive_string *);\nstatic int\tlha_read_data_none(struct archive_read *, const void **,\n\t\t    size_t *, int64_t *);\nstatic int\tlha_read_data_lzh(struct archive_read *, const void **,\n\t\t    size_t *, int64_t *);\nstatic void\tlha_crc16_init(void);\nstatic uint16_t lha_crc16(uint16_t, const void *, size_t);\nstatic int\tlzh_decode_init(struct lzh_stream *, const char *);\nstatic void\tlzh_decode_free(struct lzh_stream *);\nstatic int\tlzh_decode(struct lzh_stream *, int);\nstatic int\tlzh_br_fillup(struct lzh_stream *, struct lzh_br *);\nstatic int\tlzh_huffman_init(struct huffman *, size_t, int);\nstatic void\tlzh_huffman_free(struct huffman *);\nstatic int\tlzh_read_pt_bitlen(struct lzh_stream *, int start, int end);\nstatic int\tlzh_make_fake_table(struct huffman *, uint16_t);\nstatic int\tlzh_make_huffman_table(struct huffman *);\nstatic inline int lzh_decode_huffman(struct huffman *, unsigned);\nstatic int\tlzh_decode_huffman_tree(struct huffman *, unsigned, int);\n\n\nint\narchive_read_support_format_lha(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct lha *lha;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_lha\");\n\n\tlha = (struct lha *)calloc(1, sizeof(*lha));\n\tif (lha == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate lha data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tarchive_string_init(&lha->ws);\n\n\tr = __archive_read_register_format(a,\n\t    lha,\n\t    \"lha\",\n\t    archive_read_format_lha_bid,\n\t    archive_read_format_lha_options,\n\t    archive_read_format_lha_read_header,\n\t    archive_read_format_lha_read_data,\n\t    archive_read_format_lha_read_data_skip,\n\t    NULL,\n\t    archive_read_format_lha_cleanup,\n\t    NULL,\n\t    NULL);\n\n\tif (r != ARCHIVE_OK)\n\t\tfree(lha);\n\treturn (ARCHIVE_OK);\n}\n\nstatic size_t\nlha_check_header_format(const void *h)\n{\n\tconst unsigned char *p = h;\n\tsize_t next_skip_bytes;\n\n\tswitch (p[H_METHOD_OFFSET+3]) {\n\t/*\n\t * \"-lh0-\" ... \"-lh7-\" \"-lhd-\"\n\t * \"-lzs-\" \"-lz5-\"\n\t */\n\tcase '0': case '1': case '2': case '3':\n\tcase '4': case '5': case '6': case '7':\n\tcase 'd':\n\tcase 's':\n\t\tnext_skip_bytes = 4;\n\n\t\t/* b0 == 0 means the end of an LHa archive file.\t*/\n\t\tif (p[0] == 0)\n\t\t\tbreak;\n\t\tif (p[H_METHOD_OFFSET] != '-' || p[H_METHOD_OFFSET+1] != 'l'\n\t\t    ||  p[H_METHOD_OFFSET+4] != '-')\n\t\t\tbreak;\n\n\t\tif (p[H_METHOD_OFFSET+2] == 'h') {\n\t\t\t/* \"-lh?-\" */\n\t\t\tif (p[H_METHOD_OFFSET+3] == 's')\n\t\t\t\tbreak;\n\t\t\tif (p[H_LEVEL_OFFSET] == 0)\n\t\t\t\treturn (0);\n\t\t\tif (p[H_LEVEL_OFFSET] <= 3 && p[H_ATTR_OFFSET] == 0x20)\n\t\t\t\treturn (0);\n\t\t}\n\t\tif (p[H_METHOD_OFFSET+2] == 'z') {\n\t\t\t/* LArc extensions: -lzs-,-lz4- and -lz5- */\n\t\t\tif (p[H_LEVEL_OFFSET] != 0)\n\t\t\t\tbreak;\n\t\t\tif (p[H_METHOD_OFFSET+3] == 's'\n\t\t\t    || p[H_METHOD_OFFSET+3] == '4'\n\t\t\t    || p[H_METHOD_OFFSET+3] == '5')\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase 'h': next_skip_bytes = 1; break;\n\tcase 'z': next_skip_bytes = 1; break;\n\tcase 'l': next_skip_bytes = 2; break;\n\tcase '-': next_skip_bytes = 3; break;\n\tdefault : next_skip_bytes = 4; break;\n\t}\n\n\treturn (next_skip_bytes);\n}\n\nstatic int\narchive_read_format_lha_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\tconst void *buff;\n\tssize_t bytes_avail, offset, window;\n\tsize_t next;\n\n\t/* If there's already a better bid than we can ever\n\t   make, don't bother testing. */\n\tif (best_bid > 30)\n\t\treturn (-1);\n\n\tif ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL)\n\t\treturn (-1);\n\n\tif (lha_check_header_format(p) == 0)\n\t\treturn (30);\n\n\tif (p[0] == 'M' && p[1] == 'Z') {\n\t\t/* PE file */\n\t\toffset = 0;\n\t\twindow = 4096;\n\t\twhile (offset < (1024 * 20)) {\n\t\t\tbuff = __archive_read_ahead(a, offset + window,\n\t\t\t    &bytes_avail);\n\t\t\tif (buff == NULL) {\n\t\t\t\t/* Remaining bytes are less than window. */\n\t\t\t\twindow >>= 1;\n\t\t\t\tif (window < (H_SIZE + 3))\n\t\t\t\t\treturn (0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp = (const char *)buff + offset;\n\t\t\twhile (p + H_SIZE < (const char *)buff + bytes_avail) {\n\t\t\t\tif ((next = lha_check_header_format(p)) == 0)\n\t\t\t\t\treturn (30);\n\t\t\t\tp += next;\n\t\t\t}\n\t\t\toffset = p - (const char *)buff;\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\narchive_read_format_lha_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n\tstruct lha *lha;\n\tint ret = ARCHIVE_FAILED;\n\n\tlha = (struct lha *)(a->format->data);\n\tif (strcmp(key, \"hdrcharset\")  == 0) {\n\t\tif (val == NULL || val[0] == 0)\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"lha: hdrcharset option needs a character-set name\");\n\t\telse {\n\t\t\tlha->opt_sconv =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&a->archive, val, 0);\n\t\t\tif (lha->opt_sconv != NULL)\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\telse\n\t\t\t\tret = ARCHIVE_FATAL;\n\t\t}\n\t\treturn (ret);\n\t}\n\n\t/* Note: The \"warn\" return is just to inform the options\n\t * supervisor that we didn't handle it.  It will generate\n\t * a suitable error if no one used this option. */\n\treturn (ARCHIVE_WARN);\n}\n\nstatic int\nlha_skip_sfx(struct archive_read *a)\n{\n\tconst void *h;\n\tconst char *p, *q;\n\tsize_t next, skip;\n\tssize_t bytes, window;\n\n\twindow = 4096;\n\tfor (;;) {\n\t\th = __archive_read_ahead(a, window, &bytes);\n\t\tif (h == NULL) {\n\t\t\t/* Remaining bytes are less than window. */\n\t\t\twindow >>= 1;\n\t\t\tif (window < (H_SIZE + 3))\n\t\t\t\tgoto fatal;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bytes < H_SIZE)\n\t\t\tgoto fatal;\n\t\tp = h;\n\t\tq = p + bytes;\n\n\t\t/*\n\t\t * Scan ahead until we find something that looks\n\t\t * like the lha header.\n\t\t */\n\t\twhile (p + H_SIZE < q) {\n\t\t\tif ((next = lha_check_header_format(p)) == 0) {\n\t\t\t\tskip = p - (const char *)h;\n\t\t\t\t__archive_read_consume(a, skip);\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tp += next;\n\t\t}\n\t\tskip = p - (const char *)h;\n\t\t__archive_read_consume(a, skip);\n\t}\nfatal:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Couldn't find out LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\ntruncated_error(struct archive_read *a)\n{\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Truncated LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\narchive_read_format_lha_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct archive_string linkname;\n\tstruct archive_string pathname;\n\tstruct lha *lha;\n\tconst unsigned char *p;\n\tconst char *signature;\n\tint err;\n\t\n\tlha_crc16_init();\n\n\ta->archive.archive_format = ARCHIVE_FORMAT_LHA;\n\tif (a->archive.archive_format_name == NULL)\n\t\ta->archive.archive_format_name = \"lha\";\n\n\tlha = (struct lha *)(a->format->data);\n\tlha->decompress_init = 0;\n\tlha->end_of_entry = 0;\n\tlha->end_of_entry_cleanup = 0;\n\tlha->entry_unconsumed = 0;\n\n\tif ((p = __archive_read_ahead(a, H_SIZE, NULL)) == NULL) {\n\t\t/*\n\t\t * LHa archiver added 0 to the tail of its archive file as\n\t\t * the mark of the end of the archive.\n\t\t */\n\t\tsignature = __archive_read_ahead(a, sizeof(signature[0]), NULL);\n\t\tif (signature == NULL || signature[0] == 0)\n\t\t\treturn (ARCHIVE_EOF);\n\t\treturn (truncated_error(a));\n\t}\n\n\tsignature = (const char *)p;\n\tif (lha->found_first_header == 0 &&\n\t    signature[0] == 'M' && signature[1] == 'Z') {\n                /* This is an executable?  Must be self-extracting... \t*/\n\t\terr = lha_skip_sfx(a);\n\t\tif (err < ARCHIVE_WARN)\n\t\t\treturn (err);\n\n\t\tif ((p = __archive_read_ahead(a, sizeof(*p), NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\tsignature = (const char *)p;\n\t}\n\t/* signature[0] == 0 means the end of an LHa archive file. */\n\tif (signature[0] == 0)\n\t\treturn (ARCHIVE_EOF);\n\n\t/*\n\t * Check the header format and method type.\n\t */\n\tif (lha_check_header_format(p) != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Bad LHa file\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/* We've found the first header. */\n\tlha->found_first_header = 1;\n\t/* Set a default value and common data */\n\tlha->header_size = 0;\n\tlha->level = p[H_LEVEL_OFFSET];\n\tlha->method[0] = p[H_METHOD_OFFSET+1];\n\tlha->method[1] = p[H_METHOD_OFFSET+2];\n\tlha->method[2] = p[H_METHOD_OFFSET+3];\n\tif (memcmp(lha->method, \"lhd\", 3) == 0)\n\t\tlha->directory = 1;\n\telse\n\t\tlha->directory = 0;\n\tif (memcmp(lha->method, \"lh0\", 3) == 0 ||\n\t    memcmp(lha->method, \"lz4\", 3) == 0)\n\t\tlha->entry_is_compressed = 0;\n\telse\n\t\tlha->entry_is_compressed = 1;\n\n\tlha->compsize = 0;\n\tlha->origsize = 0;\n\tlha->setflag = 0;\n\tlha->birthtime = 0;\n\tlha->birthtime_tv_nsec = 0;\n\tlha->mtime = 0;\n\tlha->mtime_tv_nsec = 0;\n\tlha->atime = 0;\n\tlha->atime_tv_nsec = 0;\n\tlha->mode = (lha->directory)? 0777 : 0666;\n\tlha->uid = 0;\n\tlha->gid = 0;\n\tarchive_string_empty(&lha->dirname);\n\tarchive_string_empty(&lha->filename);\n\tlha->dos_attr = 0;\n\tif (lha->opt_sconv != NULL)\n\t\tlha->sconv = lha->opt_sconv;\n\telse\n\t\tlha->sconv = NULL;\n\n\tswitch (p[H_LEVEL_OFFSET]) {\n\tcase 0:\n\t\terr = lha_read_file_header_0(a, lha);\n\t\tbreak;\n\tcase 1:\n\t\terr = lha_read_file_header_1(a, lha);\n\t\tbreak;\n\tcase 2:\n\t\terr = lha_read_file_header_2(a, lha);\n\t\tbreak;\n\tcase 3:\n\t\terr = lha_read_file_header_3(a, lha);\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported LHa header level %d\", p[H_LEVEL_OFFSET]);\n\t\terr = ARCHIVE_FATAL;\n\t\tbreak;\n\t}\n\tif (err < ARCHIVE_WARN)\n\t\treturn (err);\n\n\n\tif (!lha->directory && archive_strlen(&lha->filename) == 0)\n\t\t/* The filename has not been set */\n\t\treturn (truncated_error(a));\n\n\t/*\n\t * Make a pathname from a dirname and a filename.\n\t */\n\tarchive_string_concat(&lha->dirname, &lha->filename);\n\tarchive_string_init(&pathname);\n\tarchive_string_init(&linkname);\n\tarchive_string_copy(&pathname, &lha->dirname);\n\n\tif ((lha->mode & AE_IFMT) == AE_IFLNK) {\n\t\t/*\n\t \t * Extract the symlink-name if it's included in the pathname.\n\t \t */\n\t\tif (!lha_parse_linkname(&linkname, &pathname)) {\n\t\t\t/* We couldn't get the symlink-name. */\n\t\t\tarchive_set_error(&a->archive,\n\t\t    \t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown symlink-name\");\n\t\t\tarchive_string_free(&pathname);\n\t\t\tarchive_string_free(&linkname);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Make sure a file-type is set.\n\t\t * The mode has been overridden if it is in the extended data.\n\t\t */\n\t\tlha->mode = (lha->mode & ~AE_IFMT) |\n\t\t    ((lha->directory)? AE_IFDIR: AE_IFREG);\n\t}\n\tif ((lha->setflag & UNIX_MODE_IS_SET) == 0 &&\n\t    (lha->dos_attr & 1) != 0)\n\t\tlha->mode &= ~(0222);/* read only. */\n\n\t/*\n\t * Set basic file parameters.\n\t */\n\tif (archive_entry_copy_pathname_l(entry, pathname.s,\n\t    pathname.length, lha->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted \"\n\t\t    \"from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(lha->sconv));\n\t\terr = ARCHIVE_WARN;\n\t}\n\tarchive_string_free(&pathname);\n\tif (archive_strlen(&linkname) > 0) {\n\t\tif (archive_entry_copy_symlink_l(entry, linkname.s,\n\t\t    linkname.length, lha->sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Linkname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(lha->sconv));\n\t\t\terr = ARCHIVE_WARN;\n\t\t}\n\t} else\n\t\tarchive_entry_set_symlink(entry, NULL);\n\tarchive_string_free(&linkname);\n\t/*\n\t * When a header level is 0, there is a possibility that\n\t * a pathname and a symlink has '\\' character, a directory\n\t * separator in DOS/Windows. So we should convert it to '/'.\n\t */\n\tif (p[H_LEVEL_OFFSET] == 0)\n\t\tlha_replace_path_separator(lha, entry);\n\n\tarchive_entry_set_mode(entry, lha->mode);\n\tarchive_entry_set_uid(entry, lha->uid);\n\tarchive_entry_set_gid(entry, lha->gid);\n\tif (archive_strlen(&lha->uname) > 0)\n\t\tarchive_entry_set_uname(entry, lha->uname.s);\n\tif (archive_strlen(&lha->gname) > 0)\n\t\tarchive_entry_set_gname(entry, lha->gname.s);\n\tif (lha->setflag & BIRTHTIME_IS_SET) {\n\t\tarchive_entry_set_birthtime(entry, lha->birthtime,\n\t\t    lha->birthtime_tv_nsec);\n\t\tarchive_entry_set_ctime(entry, lha->birthtime,\n\t\t    lha->birthtime_tv_nsec);\n\t} else {\n\t\tarchive_entry_unset_birthtime(entry);\n\t\tarchive_entry_unset_ctime(entry);\n\t}\n\tarchive_entry_set_mtime(entry, lha->mtime, lha->mtime_tv_nsec);\n\tif (lha->setflag & ATIME_IS_SET)\n\t\tarchive_entry_set_atime(entry, lha->atime,\n\t\t    lha->atime_tv_nsec);\n\telse\n\t\tarchive_entry_unset_atime(entry);\n\tif (lha->directory || archive_entry_symlink(entry) != NULL)\n\t\tarchive_entry_unset_size(entry);\n\telse\n\t\tarchive_entry_set_size(entry, lha->origsize);\n\n\t/*\n\t * Prepare variables used to read a file content.\n\t */\n\tlha->entry_bytes_remaining = lha->compsize;\n\tlha->entry_offset = 0;\n\tlha->entry_crc_calculated = 0;\n\n\t/*\n\t * This file does not have a content.\n\t */\n\tif (lha->directory || lha->compsize == 0)\n\t\tlha->end_of_entry = 1;\n\n\tsprintf(lha->format_name, \"lha -%c%c%c-\",\n\t    lha->method[0], lha->method[1], lha->method[2]);\n\ta->archive.archive_format_name = lha->format_name;\n\n\treturn (err);\n}\n\n/*\n * Replace a DOS path separator '\\' by a character '/'.\n * Some multi-byte character set have  a character '\\' in its second byte.\n */\nstatic void\nlha_replace_path_separator(struct lha *lha, struct archive_entry *entry)\n{\n\tconst wchar_t *wp;\n\tsize_t i;\n\n\tif ((wp = archive_entry_pathname_w(entry)) != NULL) {\n\t\tarchive_wstrcpy(&(lha->ws), wp);\n\t\tfor (i = 0; i < archive_strlen(&(lha->ws)); i++) {\n\t\t\tif (lha->ws.s[i] == L'\\\\')\n\t\t\t\tlha->ws.s[i] = L'/';\n\t\t}\n\t\tarchive_entry_copy_pathname_w(entry, lha->ws.s);\n\t}\n\n\tif ((wp = archive_entry_symlink_w(entry)) != NULL) {\n\t\tarchive_wstrcpy(&(lha->ws), wp);\n\t\tfor (i = 0; i < archive_strlen(&(lha->ws)); i++) {\n\t\t\tif (lha->ws.s[i] == L'\\\\')\n\t\t\t\tlha->ws.s[i] = L'/';\n\t\t}\n\t\tarchive_entry_copy_symlink_w(entry, lha->ws.s);\n\t}\n}\n\n/*\n * Header 0 format\n *\n * +0              +1         +2               +7                  +11\n * +---------------+----------+----------------+-------------------+\n * |header size(*1)|header sum|compression type|compressed size(*2)|\n * +---------------+----------+----------------+-------------------+\n *                             <---------------------(*1)----------*\n *\n * +11               +15       +17       +19            +20              +21\n * +-----------------+---------+---------+--------------+----------------+\n * |uncompressed size|time(DOS)|date(DOS)|attribute(DOS)|header level(=0)|\n * +-----------------+---------+---------+--------------+----------------+\n * *--------------------------------(*1)---------------------------------*\n *\n * +21             +22       +22+(*3)   +22+(*3)+2       +22+(*3)+2+(*4)\n * +---------------+---------+----------+----------------+------------------+\n * |name length(*3)|file name|file CRC16|extra header(*4)|  compressed data |\n * +---------------+---------+----------+----------------+------------------+\n *                  <--(*3)->                             <------(*2)------>\n * *----------------------(*1)-------------------------->\n *\n */\n#define H0_HEADER_SIZE_OFFSET\t0\n#define H0_HEADER_SUM_OFFSET\t1\n#define H0_COMP_SIZE_OFFSET\t7\n#define H0_ORIG_SIZE_OFFSET\t11\n#define H0_DOS_TIME_OFFSET\t15\n#define H0_NAME_LEN_OFFSET\t21\n#define H0_FILE_NAME_OFFSET\t22\n#define H0_FIXED_SIZE\t\t24\nstatic int\nlha_read_file_header_0(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tint extdsize, namelen;\n\tunsigned char headersum, sum_calculated;\n\n\tif ((p = __archive_read_ahead(a, H0_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H0_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H0_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H0_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H0_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H0_DOS_TIME_OFFSET);\n\tnamelen = p[H0_NAME_LEN_OFFSET];\n\textdsize = (int)lha->header_size - H0_FIXED_SIZE - namelen;\n\tif ((namelen > 221 || extdsize < 0) && extdsize != -2) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid LHa header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tarchive_strncpy(&lha->filename, p + H0_FILE_NAME_OFFSET, namelen);\n\t/* When extdsize == -2, A CRC16 value is not present in the header. */\n\tif (extdsize >= 0) {\n\t\tlha->crc = archive_le16dec(p + H0_FILE_NAME_OFFSET + namelen);\n\t\tlha->setflag |= CRC_IS_SET;\n\t}\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\n\t/* Read an extended header */\n\tif (extdsize > 0) {\n\t\t/* This extended data is set by 'LHa for UNIX' only.\n\t\t * Maybe fixed size.\n\t\t */\n\t\tp += H0_FILE_NAME_OFFSET + namelen + 2;\n\t\tif (p[0] == 'U' && extdsize == 12) {\n\t\t\t/* p[1] is a minor version. */\n\t\t\tlha->mtime = archive_le32dec(&p[2]);\n\t\t\tlha->mode = archive_le16dec(&p[6]);\n\t\t\tlha->uid = archive_le16dec(&p[8]);\n\t\t\tlha->gid = archive_le16dec(&p[10]);\n\t\t\tlha->setflag |= UNIX_MODE_IS_SET;\n\t\t}\n\t}\n\t__archive_read_consume(a, lha->header_size);\n\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Header 1 format\n *\n * +0              +1         +2               +7            +11\n * +---------------+----------+----------------+-------------+\n * |header size(*1)|header sum|compression type|skip size(*2)|\n * +---------------+----------+----------------+-------------+\n *                             <---------------(*1)----------*\n *\n * +11               +15       +17       +19            +20              +21\n * +-----------------+---------+---------+--------------+----------------+\n * |uncompressed size|time(DOS)|date(DOS)|attribute(DOS)|header level(=1)|\n * +-----------------+---------+---------+--------------+----------------+\n * *-------------------------------(*1)----------------------------------*\n *\n * +21             +22       +22+(*3)   +22+(*3)+2  +22+(*3)+3  +22+(*3)+3+(*4)\n * +---------------+---------+----------+-----------+-----------+\n * |name length(*3)|file name|file CRC16|  creator  |padding(*4)|\n * +---------------+---------+----------+-----------+-----------+\n *                  <--(*3)->\n * *----------------------------(*1)----------------------------*\n *\n * +22+(*3)+3+(*4)  +22+(*3)+3+(*4)+2     +22+(*3)+3+(*4)+2+(*5)\n * +----------------+---------------------+------------------------+\n * |next header size| extended header(*5) |     compressed data    |\n * +----------------+---------------------+------------------------+\n * *------(*1)-----> <--------------------(*2)-------------------->\n */\n#define H1_HEADER_SIZE_OFFSET\t0\n#define H1_HEADER_SUM_OFFSET\t1\n#define H1_COMP_SIZE_OFFSET\t7\n#define H1_ORIG_SIZE_OFFSET\t11\n#define H1_DOS_TIME_OFFSET\t15\n#define H1_NAME_LEN_OFFSET\t21\n#define H1_FILE_NAME_OFFSET\t22\n#define H1_FIXED_SIZE\t\t27\nstatic int\nlha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\n\terr = ARCHIVE_OK;\n\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\t/* Note: An extended header size is included in a compsize. */\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\t/* Calculate a padding size. The result will be normally 0 only(?) */\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;/* Invalid filename. */\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t/* Consume used bytes but not include `next header size' data\n\t * since it will be consumed in lha_read_file_extended_header(). */\n\t__archive_read_consume(a, lha->header_size - 2);\n\n\t/* Read extended headers */\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n\t/* Get a real compressed file size. */\n\tlha->compsize -= extdsize - 2;\n\n\tif (lha->compsize < 0)\n\t\tgoto invalid;\t/* Invalid compressed file size */\n\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\n/*\n * Header 2 format\n *\n * +0              +2               +7                  +11               +15\n * +---------------+----------------+-------------------+-----------------+\n * |header size(*1)|compression type|compressed size(*2)|uncompressed size|\n * +---------------+----------------+-------------------+-----------------+\n *  <--------------------------------(*1)---------------------------------*\n *\n * +15               +19          +20              +21        +23         +24\n * +-----------------+------------+----------------+----------+-----------+\n * |data/time(time_t)| 0x20 fixed |header level(=2)|file CRC16|  creator  |\n * +-----------------+------------+----------------+----------+-----------+\n * *---------------------------------(*1)---------------------------------*\n *\n * +24              +26                 +26+(*3)      +26+(*3)+(*4)\n * +----------------+-------------------+-------------+-------------------+\n * |next header size|extended header(*3)| padding(*4) |  compressed data  |\n * +----------------+-------------------+-------------+-------------------+\n * *--------------------------(*1)-------------------> <------(*2)------->\n *\n */\n#define H2_HEADER_SIZE_OFFSET\t0\n#define H2_COMP_SIZE_OFFSET\t7\n#define H2_ORIG_SIZE_OFFSET\t11\n#define H2_TIME_OFFSET\t\t15\n#define H2_CRC_OFFSET\t\t21\n#define H2_FIXED_SIZE\t\t24\nstatic int\nlha_read_file_header_2(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint err, padding;\n\tuint16_t header_crc;\n\n\tif ((p = __archive_read_ahead(a, H2_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tlha->header_size =archive_le16dec(p + H2_HEADER_SIZE_OFFSET);\n\tlha->compsize = archive_le32dec(p + H2_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H2_ORIG_SIZE_OFFSET);\n\tlha->mtime = archive_le32dec(p + H2_TIME_OFFSET);\n\tlha->crc = archive_le16dec(p + H2_CRC_OFFSET);\n\tlha->setflag |= CRC_IS_SET;\n\n\tif (lha->header_size < H2_FIXED_SIZE) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid LHa header size\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\theader_crc = lha_crc16(0, p, H2_FIXED_SIZE);\n\t__archive_read_consume(a, H2_FIXED_SIZE);\n\n\t/* Read extended headers */\n\terr = lha_read_file_extended_header(a, lha, &header_crc, 2,\n\t\t  lha->header_size - H2_FIXED_SIZE, &extdsize);\n\tif (err < ARCHIVE_WARN)\n\t\treturn (err);\n\n\t/* Calculate a padding size. The result will be normally 0 or 1. */\n\tpadding = (int)lha->header_size - (int)(H2_FIXED_SIZE + extdsize);\n\tif (padding > 0) {\n\t\tif ((p = __archive_read_ahead(a, padding, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\theader_crc = lha_crc16(header_crc, p, padding);\n\t\t__archive_read_consume(a, padding);\n\t}\n\n\tif (header_crc != lha->header_crc) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"LHa header CRC error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\n}\n\n/*\n * Header 3 format\n *\n * +0           +2               +7                  +11               +15\n * +------------+----------------+-------------------+-----------------+\n * | 0x04 fixed |compression type|compressed size(*2)|uncompressed size|\n * +------------+----------------+-------------------+-----------------+\n *  <-------------------------------(*1)-------------------------------*\n *\n * +15               +19          +20              +21        +23         +24\n * +-----------------+------------+----------------+----------+-----------+\n * |date/time(time_t)| 0x20 fixed |header level(=3)|file CRC16|  creator  |\n * +-----------------+------------+----------------+----------+-----------+\n * *--------------------------------(*1)----------------------------------*\n *\n * +24             +28              +32                 +32+(*3)\n * +---------------+----------------+-------------------+-----------------+\n * |header size(*1)|next header size|extended header(*3)| compressed data |\n * +---------------+----------------+-------------------+-----------------+\n * *------------------------(*1)-----------------------> <------(*2)----->\n *\n */\n#define H3_FIELD_LEN_OFFSET\t0\n#define H3_COMP_SIZE_OFFSET\t7\n#define H3_ORIG_SIZE_OFFSET\t11\n#define H3_TIME_OFFSET\t\t15\n#define H3_CRC_OFFSET\t\t21\n#define H3_HEADER_SIZE_OFFSET\t24\n#define H3_FIXED_SIZE\t\t28\nstatic int\nlha_read_file_header_3(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint err;\n\tuint16_t header_crc;\n\n\tif ((p = __archive_read_ahead(a, H3_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\n\tif (archive_le16dec(p + H3_FIELD_LEN_OFFSET) != 4)\n\t\tgoto invalid;\n\tlha->header_size =archive_le32dec(p + H3_HEADER_SIZE_OFFSET);\n\tlha->compsize = archive_le32dec(p + H3_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H3_ORIG_SIZE_OFFSET);\n\tlha->mtime = archive_le32dec(p + H3_TIME_OFFSET);\n\tlha->crc = archive_le16dec(p + H3_CRC_OFFSET);\n\tlha->setflag |= CRC_IS_SET;\n\n\tif (lha->header_size < H3_FIXED_SIZE + 4)\n\t\tgoto invalid;\n\theader_crc = lha_crc16(0, p, H3_FIXED_SIZE);\n\t__archive_read_consume(a, H3_FIXED_SIZE);\n\n\t/* Read extended headers */\n\terr = lha_read_file_extended_header(a, lha, &header_crc, 4,\n\t\t  lha->header_size - H3_FIXED_SIZE, &extdsize);\n\tif (err < ARCHIVE_WARN)\n\t\treturn (err);\n\n\tif (header_crc != lha->header_crc) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"LHa header CRC error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\n/*\n * Extended header format\n *\n * +0             +2        +3  -- used in header 1 and 2\n * +0             +4        +5  -- used in header 3\n * +--------------+---------+-------------------+--------------+--\n * |ex-header size|header id|        data       |ex-header size| .......\n * +--------------+---------+-------------------+--------------+--\n *  <-------------( ex-header size)------------> <-- next extended header --*\n *\n * If the ex-header size is zero, it is the make of the end of extended\n * headers.\n *\n */\nstatic int\nlha_read_file_extended_header(struct archive_read *a, struct lha *lha,\n    uint16_t *crc, int sizefield_length, size_t limitsize, size_t *total_size)\n{\n\tconst void *h;\n\tconst unsigned char *extdheader;\n\tsize_t\textdsize;\n\tsize_t\tdatasize;\n\tunsigned int i;\n\tunsigned char extdtype;\n\n#define EXT_HEADER_CRC\t\t0x00\t\t/* Header CRC and information*/\n#define EXT_FILENAME\t\t0x01\t\t/* Filename \t\t    */\n#define EXT_DIRECTORY\t\t0x02\t\t/* Directory name\t    */\n#define EXT_DOS_ATTR\t\t0x40\t\t/* MS-DOS attribute\t    */\n#define EXT_TIMESTAMP\t\t0x41\t\t/* Windows time stamp\t    */\n#define EXT_FILESIZE\t\t0x42\t\t/* Large file size\t    */\n#define EXT_TIMEZONE\t\t0x43\t\t/* Time zone\t\t    */\n#define EXT_UTF16_FILENAME\t0x44\t\t/* UTF-16 filename \t    */\n#define EXT_UTF16_DIRECTORY\t0x45\t\t/* UTF-16 directory name    */\n#define EXT_CODEPAGE\t\t0x46\t\t/* Codepage\t\t    */\n#define EXT_UNIX_MODE\t\t0x50\t\t/* File permission\t    */\n#define EXT_UNIX_GID_UID\t0x51\t\t/* gid,uid\t\t    */\n#define EXT_UNIX_GNAME\t\t0x52\t\t/* Group name\t\t    */\n#define EXT_UNIX_UNAME\t\t0x53\t\t/* User name\t\t    */\n#define EXT_UNIX_MTIME\t\t0x54\t\t/* Modified time\t    */\n#define EXT_OS2_NEW_ATTR\t0x7f\t\t/* new attribute(OS/2 only) */\n#define EXT_NEW_ATTR\t\t0xff\t\t/* new attribute\t    */\n\n\t*total_size = sizefield_length;\n\n\tfor (;;) {\n\t\t/* Read an extended header size. */\n\t\tif ((h =\n\t\t    __archive_read_ahead(a, sizefield_length, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\t/* Check if the size is the zero indicates the end of the\n\t\t * extended header. */\n\t\tif (sizefield_length == sizeof(uint16_t))\n\t\t\textdsize = archive_le16dec(h);\n\t\telse\n\t\t\textdsize = archive_le32dec(h);\n\t\tif (extdsize == 0) {\n\t\t\t/* End of extended header */\n\t\t\tif (crc != NULL)\n\t\t\t\t*crc = lha_crc16(*crc, h, sizefield_length);\n\t\t\t__archive_read_consume(a, sizefield_length);\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\n\t\t/* Sanity check to the extended header size. */\n\t\tif (((uint64_t)*total_size + extdsize) >\n\t\t\t\t    (uint64_t)limitsize ||\n\t\t    extdsize <= (size_t)sizefield_length)\n\t\t\tgoto invalid;\n\n\t\t/* Read the extended header. */\n\t\tif ((h = __archive_read_ahead(a, extdsize, NULL)) == NULL)\n\t\t\treturn (truncated_error(a));\n\t\t*total_size += extdsize;\n\n\t\textdheader = (const unsigned char *)h;\n\t\t/* Get the extended header type. */\n\t\textdtype = extdheader[sizefield_length];\n\t\t/* Calculate an extended data size. */\n\t\tdatasize = extdsize - (1 + sizefield_length);\n\t\t/* Skip an extended header size field and type field. */\n\t\textdheader += sizefield_length + 1;\n\n\t\tif (crc != NULL && extdtype != EXT_HEADER_CRC)\n\t\t\t*crc = lha_crc16(*crc, h, extdsize);\n\t\tswitch (extdtype) {\n\t\tcase EXT_HEADER_CRC:\n\t\t\t/* We only use a header CRC. Following data will not\n\t\t\t * be used. */\n\t\t\tif (datasize >= 2) {\n\t\t\t\tlha->header_crc = archive_le16dec(extdheader);\n\t\t\t\tif (crc != NULL) {\n\t\t\t\t\tstatic const char zeros[2] = {0, 0};\n\t\t\t\t\t*crc = lha_crc16(*crc, h,\n\t\t\t\t\t    extdsize - datasize);\n\t\t\t\t\t/* CRC value itself as zero */\n\t\t\t\t\t*crc = lha_crc16(*crc, zeros, 2);\n\t\t\t\t\t*crc = lha_crc16(*crc,\n\t\t\t\t\t    extdheader+2, datasize - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_FILENAME:\n\t\t\tif (datasize == 0) {\n\t\t\t\t/* maybe directory header */\n\t\t\t\tarchive_string_empty(&lha->filename);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (extdheader[0] == '\\0')\n\t\t\t\tgoto invalid;\n\t\t\tarchive_strncpy(&lha->filename,\n\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_DIRECTORY:\n\t\t\tif (datasize == 0 || extdheader[0] == '\\0')\n\t\t\t\t/* no directory name data. exit this case. */\n\t\t\t\tgoto invalid;\n\n\t\t\tarchive_strncpy(&lha->dirname,\n\t\t  \t    (const char *)extdheader, datasize);\n\t\t\t/*\n\t\t\t * Convert directory delimiter from 0xFF\n\t\t\t * to '/' for local system.\n\t \t\t */\n\t\t\tfor (i = 0; i < lha->dirname.length; i++) {\n\t\t\t\tif ((unsigned char)lha->dirname.s[i] == 0xFF)\n\t\t\t\t\tlha->dirname.s[i] = '/';\n\t\t\t}\n\t\t\t/* Is last character directory separator? */\n\t\t\tif (lha->dirname.s[lha->dirname.length-1] != '/')\n\t\t\t\t/* invalid directory data */\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase EXT_DOS_ATTR:\n\t\t\tif (datasize == 2)\n\t\t\t\tlha->dos_attr = (unsigned char)\n\t\t\t\t    (archive_le16dec(extdheader) & 0xff);\n\t\t\tbreak;\n\t\tcase EXT_TIMESTAMP:\n\t\t\tif (datasize == (sizeof(uint64_t) * 3)) {\n\t\t\t\tlha->birthtime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->birthtime_tv_nsec);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->mtime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->mtime_tv_nsec);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->atime = lha_win_time(\n\t\t\t\t    archive_le64dec(extdheader),\n\t\t\t\t    &lha->atime_tv_nsec);\n\t\t\t\tlha->setflag |= BIRTHTIME_IS_SET |\n\t\t\t\t    ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_FILESIZE:\n\t\t\tif (datasize == sizeof(uint64_t) * 2) {\n\t\t\t\tlha->compsize = archive_le64dec(extdheader);\n\t\t\t\textdheader += sizeof(uint64_t);\n\t\t\t\tlha->origsize = archive_le64dec(extdheader);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_CODEPAGE:\n\t\t\t/* Get an archived filename charset from codepage.\n\t\t\t * This overwrites the charset specified by\n\t\t\t * hdrcharset option. */\n\t\t\tif (datasize == sizeof(uint32_t)) {\n\t\t\t\tstruct archive_string cp;\n\t\t\t\tconst char *charset;\n\n\t\t\t\tarchive_string_init(&cp);\n\t\t\t\tswitch (archive_le32dec(extdheader)) {\n\t\t\t\tcase 65001: /* UTF-8 */\n\t\t\t\t\tcharset = \"UTF-8\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tarchive_string_sprintf(&cp, \"CP%d\",\n\t\t\t\t\t    (int)archive_le32dec(extdheader));\n\t\t\t\t\tcharset = cp.s;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlha->sconv =\n\t\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t\t&(a->archive), charset, 1);\n\t\t\t\tarchive_string_free(&cp);\n\t\t\t\tif (lha->sconv == NULL)\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_MODE:\n\t\t\tif (datasize == sizeof(uint16_t)) {\n\t\t\t\tlha->mode = archive_le16dec(extdheader);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_GID_UID:\n\t\t\tif (datasize == (sizeof(uint16_t) * 2)) {\n\t\t\t\tlha->gid = archive_le16dec(extdheader);\n\t\t\t\tlha->uid = archive_le16dec(extdheader+2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_UNIX_GNAME:\n\t\t\tif (datasize > 0)\n\t\t\t\tarchive_strncpy(&lha->gname,\n\t\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_UNIX_UNAME:\n\t\t\tif (datasize > 0)\n\t\t\t\tarchive_strncpy(&lha->uname,\n\t\t\t\t    (const char *)extdheader, datasize);\n\t\t\tbreak;\n\t\tcase EXT_UNIX_MTIME:\n\t\t\tif (datasize == sizeof(uint32_t))\n\t\t\t\tlha->mtime = archive_le32dec(extdheader);\n\t\t\tbreak;\n\t\tcase EXT_OS2_NEW_ATTR:\n\t\t\t/* This extended header is OS/2 depend. */\n\t\t\tif (datasize == 16) {\n\t\t\t\tlha->dos_attr = (unsigned char)\n\t\t\t\t    (archive_le16dec(extdheader) & 0xff);\n\t\t\t\tlha->mode = archive_le16dec(extdheader+2);\n\t\t\t\tlha->gid = archive_le16dec(extdheader+4);\n\t\t\t\tlha->uid = archive_le16dec(extdheader+6);\n\t\t\t\tlha->birthtime = archive_le32dec(extdheader+8);\n\t\t\t\tlha->atime = archive_le32dec(extdheader+12);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET\n\t\t\t\t    | BIRTHTIME_IS_SET | ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_NEW_ATTR:\n\t\t\tif (datasize == 20) {\n\t\t\t\tlha->mode = (mode_t)archive_le32dec(extdheader);\n\t\t\t\tlha->gid = archive_le32dec(extdheader+4);\n\t\t\t\tlha->uid = archive_le32dec(extdheader+8);\n\t\t\t\tlha->birthtime = archive_le32dec(extdheader+12);\n\t\t\t\tlha->atime = archive_le32dec(extdheader+16);\n\t\t\t\tlha->setflag |= UNIX_MODE_IS_SET\n\t\t\t\t    | BIRTHTIME_IS_SET | ATIME_IS_SET;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXT_TIMEZONE:\t\t/* Not supported */\n\t\tcase EXT_UTF16_FILENAME:\t/* Not supported */\n\t\tcase EXT_UTF16_DIRECTORY:\t/* Not supported */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t__archive_read_consume(a, extdsize);\n\t}\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid extended LHa header\");\n\treturn (ARCHIVE_FATAL);\n}\n\nstatic int\nlha_end_of_entry(struct archive_read *a)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tint r = ARCHIVE_EOF;\n\n\tif (!lha->end_of_entry_cleanup) {\n\t\tif ((lha->setflag & CRC_IS_SET) &&\n\t\t    lha->crc != lha->entry_crc_calculated) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"LHa data CRC error\");\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\n\t\t/* End-of-entry cleanup done. */\n\t\tlha->end_of_entry_cleanup = 1;\n\t}\n\treturn (r);\n}\n\nstatic int\narchive_read_format_lha_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tint r;\n\n\tif (lha->entry_unconsumed) {\n\t\t/* Consume as much as the decompressor actually used. */\n\t\t__archive_read_consume(a, lha->entry_unconsumed);\n\t\tlha->entry_unconsumed = 0;\n\t}\n\tif (lha->end_of_entry) {\n\t\t*offset = lha->entry_offset;\n\t\t*size = 0;\n\t\t*buff = NULL;\n\t\treturn (lha_end_of_entry(a));\n\t}\n\n\tif (lha->entry_is_compressed)\n\t\tr =  lha_read_data_lzh(a, buff, size, offset);\n\telse\n\t\t/* No compression. */\n\t\tr =  lha_read_data_none(a, buff, size, offset);\n\treturn (r);\n}\n\n/*\n * Read a file content in no compression.\n *\n * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets\n * lha->end_of_entry if it consumes all of the data.\n */\nstatic int\nlha_read_data_none(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tssize_t bytes_avail;\n\n\tif (lha->entry_bytes_remaining == 0) {\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = lha->entry_offset;\n\t\tlha->end_of_entry = 1;\n\t\treturn (ARCHIVE_OK);\n\t}\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail <= 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated LHa file data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (bytes_avail > lha->entry_bytes_remaining)\n\t\tbytes_avail = (ssize_t)lha->entry_bytes_remaining;\n\tlha->entry_crc_calculated =\n\t    lha_crc16(lha->entry_crc_calculated, *buff, bytes_avail);\n\t*size = bytes_avail;\n\t*offset = lha->entry_offset;\n\tlha->entry_offset += bytes_avail;\n\tlha->entry_bytes_remaining -= bytes_avail;\n\tif (lha->entry_bytes_remaining == 0)\n\t\tlha->end_of_entry = 1;\n\tlha->entry_unconsumed = bytes_avail;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Read a file content in LZHUFF encoding.\n *\n * Returns ARCHIVE_OK if successful, returns ARCHIVE_WARN if compression is\n * unsupported, ARCHIVE_FATAL otherwise, sets lha->end_of_entry if it consumes\n * all of the data.\n */\nstatic int\nlha_read_data_lzh(struct archive_read *a, const void **buff,\n    size_t *size, int64_t *offset)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\tssize_t bytes_avail;\n\tint r;\n\n\t/* If we haven't yet read any data, initialize the decompressor. */\n\tif (!lha->decompress_init) {\n\t\tr = lzh_decode_init(&(lha->strm), lha->method);\n\t\tswitch (r) {\n\t\tcase ARCHIVE_OK:\n\t\t\tbreak;\n\t\tcase ARCHIVE_FAILED:\n        \t\t/* Unsupported compression. */\n\t\t\t*buff = NULL;\n\t\t\t*size = 0;\n\t\t\t*offset = 0;\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unsupported lzh compression method -%c%c%c-\",\n\t\t\t    lha->method[0], lha->method[1], lha->method[2]);\n\t\t\t/* We know compressed size; just skip it. */\n\t\t\tarchive_read_format_lha_read_data_skip(a);\n\t\t\treturn (ARCHIVE_WARN);\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Couldn't allocate memory \"\n\t\t\t    \"for lzh decompression\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t/* We've initialized decompression for this stream. */\n\t\tlha->decompress_init = 1;\n\t\tlha->strm.avail_out = 0;\n\t\tlha->strm.total_out = 0;\n\t}\n\n\t/*\n\t * Note: '1' here is a performance optimization.\n\t * Recall that the decompression layer returns a count of\n\t * available bytes; asking for more than that forces the\n\t * decompressor to combine reads by copying data.\n\t */\n\tlha->strm.next_in = __archive_read_ahead(a, 1, &bytes_avail);\n\tif (bytes_avail <= 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated LHa file body\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (bytes_avail > lha->entry_bytes_remaining)\n\t\tbytes_avail = (ssize_t)lha->entry_bytes_remaining;\n\n\tlha->strm.avail_in = (int)bytes_avail;\n\tlha->strm.total_in = 0;\n\tlha->strm.avail_out = 0;\n\n\tr = lzh_decode(&(lha->strm), bytes_avail == lha->entry_bytes_remaining);\n\tswitch (r) {\n\tcase ARCHIVE_OK:\n\t\tbreak;\n\tcase ARCHIVE_EOF:\n\t\tlha->end_of_entry = 1;\n\t\tbreak;\n\tdefault:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Bad lzh data\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\tlha->entry_unconsumed = lha->strm.total_in;\n\tlha->entry_bytes_remaining -= lha->strm.total_in;\n\n\tif (lha->strm.avail_out) {\n\t\t*offset = lha->entry_offset;\n\t\t*size = lha->strm.avail_out;\n\t\t*buff = lha->strm.ref_ptr;\n\t\tlha->entry_crc_calculated =\n\t\t    lha_crc16(lha->entry_crc_calculated, *buff, *size);\n\t\tlha->entry_offset += *size;\n\t} else {\n\t\t*offset = lha->entry_offset;\n\t\t*size = 0;\n\t\t*buff = NULL;\n\t\tif (lha->end_of_entry)\n\t\t\treturn (lha_end_of_entry(a));\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Skip a file content.\n */\nstatic int\narchive_read_format_lha_read_data_skip(struct archive_read *a)\n{\n\tstruct lha *lha;\n\tint64_t bytes_skipped;\n\n\tlha = (struct lha *)(a->format->data);\n\n\tif (lha->entry_unconsumed) {\n\t\t/* Consume as much as the decompressor actually used. */\n\t\t__archive_read_consume(a, lha->entry_unconsumed);\n\t\tlha->entry_unconsumed = 0;\n\t}\n\n\t/* if we've already read to end of data, we're done. */\n\tif (lha->end_of_entry_cleanup)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * If the length is at the beginning, we can skip the\n\t * compressed data much more quickly.\n\t */\n\tbytes_skipped = __archive_read_consume(a, lha->entry_bytes_remaining);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/* This entry is finished and done. */\n\tlha->end_of_entry_cleanup = lha->end_of_entry = 1;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\narchive_read_format_lha_cleanup(struct archive_read *a)\n{\n\tstruct lha *lha = (struct lha *)(a->format->data);\n\n\tlzh_decode_free(&(lha->strm));\n\tarchive_string_free(&(lha->dirname));\n\tarchive_string_free(&(lha->filename));\n\tarchive_string_free(&(lha->uname));\n\tarchive_string_free(&(lha->gname));\n\tarchive_wstring_free(&(lha->ws));\n\tfree(lha);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * 'LHa for UNIX' utility has archived a symbolic-link name after\n * a pathname with '|' character.\n * This function extracts the symbolic-link name from the pathname.\n *\n * example.\n *   1. a symbolic-name is 'aaa/bb/cc'\n *   2. a filename is 'xxx/bbb'\n *  then a archived pathname is 'xxx/bbb|aaa/bb/cc'\n */\nstatic int\nlha_parse_linkname(struct archive_string *linkname,\n    struct archive_string *pathname)\n{\n\tchar *\tlinkptr;\n\tsize_t \tsymlen;\n\n\tlinkptr = strchr(pathname->s, '|');\n\tif (linkptr != NULL) {\n\t\tsymlen = strlen(linkptr + 1);\n\t\tarchive_strncpy(linkname, linkptr+1, symlen);\n\n\t\t*linkptr = 0;\n\t\tpathname->length = strlen(pathname->s);\n\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n/* Convert an MSDOS-style date/time into Unix-style time. */\nstatic time_t\nlha_dos_time(const unsigned char *p)\n{\n\tint msTime, msDate;\n\tstruct tm ts;\n\n\tmsTime = archive_le16dec(p);\n\tmsDate = archive_le16dec(p+2);\n\n\tmemset(&ts, 0, sizeof(ts));\n\tts.tm_year = ((msDate >> 9) & 0x7f) + 80;   /* Years since 1900. */\n\tts.tm_mon = ((msDate >> 5) & 0x0f) - 1;     /* Month number.     */\n\tts.tm_mday = msDate & 0x1f;\t\t    /* Day of month.     */\n\tts.tm_hour = (msTime >> 11) & 0x1f;\n\tts.tm_min = (msTime >> 5) & 0x3f;\n\tts.tm_sec = (msTime << 1) & 0x3e;\n\tts.tm_isdst = -1;\n\treturn (mktime(&ts));\n}\n\n/* Convert an MS-Windows-style date/time into Unix-style time. */\nstatic time_t\nlha_win_time(uint64_t wintime, long *ns)\n{\n#define EPOC_TIME ARCHIVE_LITERAL_ULL(116444736000000000)\n\n\tif (wintime >= EPOC_TIME) {\n\t\twintime -= EPOC_TIME;\t/* 1970-01-01 00:00:00 (UTC) */\n\t\tif (ns != NULL)\n\t\t\t*ns = (long)(wintime % 10000000) * 100;\n\t\treturn (wintime / 10000000);\n\t} else {\n\t\tif (ns != NULL)\n\t\t\t*ns = 0;\n\t\treturn (0);\n\t}\n}\n\nstatic unsigned char\nlha_calcsum(unsigned char sum, const void *pp, int offset, size_t size)\n{\n\tunsigned char const *p = (unsigned char const *)pp;\n\n\tp += offset;\n\tfor (;size > 0; --size)\n\t\tsum += *p++;\n\treturn (sum);\n}\n\nstatic uint16_t crc16tbl[2][256];\nstatic void\nlha_crc16_init(void)\n{\n\tunsigned int i;\n\tstatic int crc16init = 0;\n\n\tif (crc16init)\n\t\treturn;\n\tcrc16init = 1;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tunsigned int j;\n\t\tuint16_t crc = (uint16_t)i;\n\t\tfor (j = 8; j; j--)\n\t\t\tcrc = (crc >> 1) ^ ((crc & 1) * 0xA001);\n\t\tcrc16tbl[0][i] = crc;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tcrc16tbl[1][i] = (crc16tbl[0][i] >> 8)\n\t\t\t^ crc16tbl[0][crc16tbl[0][i] & 0xff];\n\t}\n}\n\nstatic uint16_t\nlha_crc16(uint16_t crc, const void *pp, size_t len)\n{\n\tconst unsigned char *p = (const unsigned char *)pp;\n\tconst uint16_t *buff;\n\tconst union {\n\t\tuint32_t i;\n\t\tchar c[4];\n\t} u = { 0x01020304 };\n\n\tif (len == 0)\n\t\treturn crc;\n\n\t/* Process unaligned address. */\n\tif (((uintptr_t)p) & (uintptr_t)0x1) {\n\t\tcrc = (crc >> 8) ^ crc16tbl[0][(crc ^ *p++) & 0xff];\n\t\tlen--;\n\t}\n\tbuff = (const uint16_t *)p;\n\t/*\n\t * Modern C compiler such as GCC does not unroll automatically yet\n\t * without unrolling pragma, and Clang is so. So we should\n\t * unroll this loop for its performance.\n\t */\n\tfor (;len >= 8; len -= 8) {\n\t\t/* This if statement expects compiler optimization will\n\t\t * remove the statement which will not be executed. */\n#undef bswap16\n#if defined(_MSC_VER) && _MSC_VER >= 1400  /* Visual Studio */\n#  define bswap16(x) _byteswap_ushort(x)\n#elif defined(__GNUC__) && ((__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || __GNUC__ > 4)\n/* GCC 4.8 and later has __builtin_bswap16() */\n#  define bswap16(x) __builtin_bswap16(x)\n#elif defined(__clang__)\n/* All clang versions have __builtin_bswap16() */\n#  define bswap16(x) __builtin_bswap16(x)\n#else\n#  define bswap16(x) ((((x) >> 8) & 0xff) | ((x) << 8))\n#endif\n#define CRC16W\tdo { \t\\\n\t\tif(u.c[0] == 1) { /* Big endian */\t\t\\\n\t\t\tcrc ^= bswap16(*buff); buff++;\t\t\\\n\t\t} else\t\t\t\t\t\t\\\n\t\t\tcrc ^= *buff++;\t\t\t\t\\\n\t\tcrc = crc16tbl[1][crc & 0xff] ^ crc16tbl[0][crc >> 8];\\\n} while (0)\n\t\tCRC16W;\n\t\tCRC16W;\n\t\tCRC16W;\n\t\tCRC16W;\n#undef CRC16W\n#undef bswap16\n\t}\n\n\tp = (const unsigned char *)buff;\n\tfor (;len; len--) {\n\t\tcrc = (crc >> 8) ^ crc16tbl[0][(crc ^ *p++) & 0xff];\n\t}\n\treturn crc;\n}\n\n/*\n * Initialize LZHUF decoder.\n *\n * Returns ARCHIVE_OK if initialization was successful.\n * Returns ARCHIVE_FAILED if method is unsupported.\n * Returns ARCHIVE_FATAL if initialization failed; memory allocation\n * error occurred.\n */\nstatic int\nlzh_decode_init(struct lzh_stream *strm, const char *method)\n{\n\tstruct lzh_dec *ds;\n\tint w_bits, w_size;\n\n\tif (strm->ds == NULL) {\n\t\tstrm->ds = calloc(1, sizeof(*strm->ds));\n\t\tif (strm->ds == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tds = strm->ds;\n\tds->error = ARCHIVE_FAILED;\n\tif (method == NULL || method[0] != 'l' || method[1] != 'h')\n\t\treturn (ARCHIVE_FAILED);\n\tswitch (method[2]) {\n\tcase '5':\n\t\tw_bits = 13;/* 8KiB for window */\n\t\tbreak;\n\tcase '6':\n\t\tw_bits = 15;/* 32KiB for window */\n\t\tbreak;\n\tcase '7':\n\t\tw_bits = 16;/* 64KiB for window */\n\t\tbreak;\n\tdefault:\n\t\treturn (ARCHIVE_FAILED);/* Not supported. */\n\t}\n\tds->error = ARCHIVE_FATAL;\n\t/* Expand a window size up to 128 KiB for decompressing process\n\t * performance whatever its original window size is. */\n\tds->w_size = 1U << 17;\n\tds->w_mask = ds->w_size -1;\n\tif (ds->w_buff == NULL) {\n\t\tds->w_buff = malloc(ds->w_size);\n\t\tif (ds->w_buff == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tw_size = 1U << w_bits;\n\tmemset(ds->w_buff + ds->w_size - w_size, 0x20, w_size);\n\tds->w_pos = 0;\n\tds->state = 0;\n\tds->pos_pt_len_size = w_bits + 1;\n\tds->pos_pt_len_bits = (w_bits == 15 || w_bits == 16)? 5: 4;\n\tds->literal_pt_len_size = PT_BITLEN_SIZE;\n\tds->literal_pt_len_bits = 5;\n\tds->br.cache_buffer = 0;\n\tds->br.cache_avail = 0;\n\n\tif (lzh_huffman_init(&(ds->lt), LT_BITLEN_SIZE, 16)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tds->lt.len_bits = 9;\n\tif (lzh_huffman_init(&(ds->pt), PT_BITLEN_SIZE, 16)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tds->error = 0;\n\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Release LZHUF decoder.\n */\nstatic void\nlzh_decode_free(struct lzh_stream *strm)\n{\n\n\tif (strm->ds == NULL)\n\t\treturn;\n\tfree(strm->ds->w_buff);\n\tlzh_huffman_free(&(strm->ds->lt));\n\tlzh_huffman_free(&(strm->ds->pt));\n\tfree(strm->ds);\n\tstrm->ds = NULL;\n}\n\n/*\n * Bit stream reader.\n */\n/* Check that the cache buffer has enough bits. */\n#define lzh_br_has(br, n)\t((br)->cache_avail >= n)\n/* Get compressed data by bit. */\n#define lzh_br_bits(br, n)\t\t\t\t\\\n\t(((uint16_t)((br)->cache_buffer >>\t\t\\\n\t\t((br)->cache_avail - (n)))) & cache_masks[n])\n#define lzh_br_bits_forced(br, n)\t\t\t\\\n\t(((uint16_t)((br)->cache_buffer <<\t\t\\\n\t\t((n) - (br)->cache_avail))) & cache_masks[n])\n/* Read ahead to make sure the cache buffer has enough compressed data we\n * will use.\n *  True  : completed, there is enough data in the cache buffer.\n *  False : we met that strm->next_in is empty, we have to get following\n *          bytes. */\n#define lzh_br_read_ahead_0(strm, br, n)\t\\\n\t(lzh_br_has(br, (n)) || lzh_br_fillup(strm, br))\n/*  True  : the cache buffer has some bits as much as we need.\n *  False : there are no enough bits in the cache buffer to be used,\n *          we have to get following bytes if we could. */\n#define lzh_br_read_ahead(strm, br, n)\t\\\n\t(lzh_br_read_ahead_0((strm), (br), (n)) || lzh_br_has((br), (n)))\n\n/* Notify how many bits we consumed. */\n#define lzh_br_consume(br, n)\t((br)->cache_avail -= (n))\n#define lzh_br_unconsume(br, n)\t((br)->cache_avail += (n))\n\nstatic const uint16_t cache_masks[] = {\n\t0x0000, 0x0001, 0x0003, 0x0007,\n\t0x000F, 0x001F, 0x003F, 0x007F,\n\t0x00FF, 0x01FF, 0x03FF, 0x07FF,\n\t0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF,\n\t0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF\n};\n\n/*\n * Shift away used bits in the cache data and fill it up with following bits.\n * Call this when cache buffer does not have enough bits you need.\n *\n * Returns 1 if the cache buffer is full.\n * Returns 0 if the cache buffer is not full; input buffer is empty.\n */\nstatic int\nlzh_br_fillup(struct lzh_stream *strm, struct lzh_br *br)\n{\n\tint n = CACHE_BITS - br->cache_avail;\n\n\tfor (;;) {\n\t\tconst int x = n >> 3;\n\t\tif (strm->avail_in >= x) {\n\t\t\tswitch (x) {\n\t\t\tcase 8:\n\t\t\t\tbr->cache_buffer =\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 56 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 48 |\n\t\t\t\t    ((uint64_t)strm->next_in[2]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[3]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[5]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[6]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[7];\n\t\t\t\tstrm->next_in += 8;\n\t\t\t\tstrm->avail_in -= 8;\n\t\t\t\tbr->cache_avail += 8 * 8;\n\t\t\t\treturn (1);\n\t\t\tcase 7:\n\t\t\t\tbr->cache_buffer =\n\t\t \t\t   (br->cache_buffer << 56) |\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 48 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[2]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[3]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[5]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[6];\n\t\t\t\tstrm->next_in += 7;\n\t\t\t\tstrm->avail_in -= 7;\n\t\t\t\tbr->cache_avail += 7 * 8;\n\t\t\t\treturn (1);\n\t\t\tcase 6:\n\t\t\t\tbr->cache_buffer =\n\t\t \t\t   (br->cache_buffer << 48) |\n\t\t\t\t    ((uint64_t)strm->next_in[0]) << 40 |\n\t\t\t\t    ((uint64_t)strm->next_in[1]) << 32 |\n\t\t\t\t    ((uint32_t)strm->next_in[2]) << 24 |\n\t\t\t\t    ((uint32_t)strm->next_in[3]) << 16 |\n\t\t\t\t    ((uint32_t)strm->next_in[4]) << 8 |\n\t\t\t\t     (uint32_t)strm->next_in[5];\n\t\t\t\tstrm->next_in += 6;\n\t\t\t\tstrm->avail_in -= 6;\n\t\t\t\tbr->cache_avail += 6 * 8;\n\t\t\t\treturn (1);\n\t\t\tcase 0:\n\t\t\t\t/* We have enough compressed data in\n\t\t\t\t * the cache buffer.*/\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (strm->avail_in == 0) {\n\t\t\t/* There is not enough compressed data to fill up the\n\t\t\t * cache buffer. */\n\t\t\treturn (0);\n\t\t}\n\t\tbr->cache_buffer =\n\t\t   (br->cache_buffer << 8) | *strm->next_in++;\n\t\tstrm->avail_in--;\n\t\tbr->cache_avail += 8;\n\t\tn -= 8;\n\t}\n}\n\n/*\n * Decode LZHUF.\n *\n * 1. Returns ARCHIVE_OK if output buffer or input buffer are empty.\n *    Please set available buffer and call this function again.\n * 2. Returns ARCHIVE_EOF if decompression has been completed.\n * 3. Returns ARCHIVE_FAILED if an error occurred; compressed data\n *    is broken or you do not set 'last' flag properly.\n * 4. 'last' flag is very important, you must set 1 to the flag if there\n *    is no input data. The lha compressed data format does not provide how\n *    to know the compressed data is really finished.\n *    Note: lha command utility check if the total size of output bytes is\n *    reached the uncompressed size recorded in its header. it does not mind\n *    that the decoding process is properly finished.\n *    GNU ZIP can decompress another compressed file made by SCO LZH compress.\n *    it handles EOF as null to fill read buffer with zero until the decoding\n *    process meet 2 bytes of zeros at reading a size of a next chunk, so the\n *    zeros are treated as the mark of the end of the data although the zeros\n *    is dummy, not the file data.\n */\nstatic int\tlzh_read_blocks(struct lzh_stream *, int);\nstatic int\tlzh_decode_blocks(struct lzh_stream *, int);\n#define ST_RD_BLOCK\t\t0\n#define ST_RD_PT_1\t\t1\n#define ST_RD_PT_2\t\t2\n#define ST_RD_PT_3\t\t3\n#define ST_RD_PT_4\t\t4\n#define ST_RD_LITERAL_1\t\t5\n#define ST_RD_LITERAL_2\t\t6\n#define ST_RD_LITERAL_3\t\t7\n#define ST_RD_POS_DATA_1\t8\n#define ST_GET_LITERAL\t\t9\n#define ST_GET_POS_1\t\t10\n#define ST_GET_POS_2\t\t11\n#define ST_COPY_DATA\t\t12\n\nstatic int\nlzh_decode(struct lzh_stream *strm, int last)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tint avail_in;\n\tint r;\n\n\tif (ds->error)\n\t\treturn (ds->error);\n\n\tavail_in = strm->avail_in;\n\tdo {\n\t\tif (ds->state < ST_GET_LITERAL)\n\t\t\tr = lzh_read_blocks(strm, last);\n\t\telse\n\t\t\tr = lzh_decode_blocks(strm, last);\n\t} while (r == 100);\n\tstrm->total_in += avail_in - strm->avail_in;\n\treturn (r);\n}\n\nstatic void\nlzh_emit_window(struct lzh_stream *strm, size_t s)\n{\n\tstrm->ref_ptr = strm->ds->w_buff;\n\tstrm->avail_out = (int)s;\n\tstrm->total_out += s;\n}\n\nstatic int\nlzh_read_blocks(struct lzh_stream *strm, int last)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tstruct lzh_br *br = &(ds->br);\n\tint c = 0, i;\n\tunsigned rbits;\n\n\tfor (;;) {\n\t\tswitch (ds->state) {\n\t\tcase ST_RD_BLOCK:\n\t\t\t/*\n\t\t\t * Read a block number indicates how many blocks\n\t\t\t * we will handle. The block is composed of a\n\t\t\t * literal and a match, sometimes a literal only\n\t\t\t * in particular, there are no reference data at\n\t\t\t * the beginning of the decompression.\n\t\t\t */\n\t\t\tif (!lzh_br_read_ahead_0(strm, br, 16)) {\n\t\t\t\tif (!last)\n\t\t\t\t\t/* We need following data. */\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\tif (lzh_br_has(br, 8)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * It seems there are extra bits.\n\t\t\t\t\t *  1. Compressed data is broken.\n\t\t\t\t\t *  2. `last' flag does not properly\n\t\t\t\t\t *     set.\n\t\t\t\t\t */\n\t\t\t\t\tgoto failed;\n\t\t\t\t}\n\t\t\t\tif (ds->w_pos > 0) {\n\t\t\t\t\tlzh_emit_window(strm, ds->w_pos);\n\t\t\t\t\tds->w_pos = 0;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\t/* End of compressed data; we have completely\n\t\t\t\t * handled all compressed data. */\n\t\t\t\treturn (ARCHIVE_EOF);\n\t\t\t}\n\t\t\tds->blocks_avail = lzh_br_bits(br, 16);\n\t\t\tif (ds->blocks_avail == 0)\n\t\t\t\tgoto failed;\n\t\t\tlzh_br_consume(br, 16);\n\t\t\t/*\n\t\t\t * Read a literal table compressed in huffman\n\t\t\t * coding.\n\t\t\t */\n\t\t\tds->pt.len_size = ds->literal_pt_len_size;\n\t\t\tds->pt.len_bits = ds->literal_pt_len_bits;\n\t\t\tds->reading_position = 0;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_1:\n\t\t\t/* Note: ST_RD_PT_1, ST_RD_PT_2 and ST_RD_PT_4 are\n\t\t\t * used in reading both a literal table and a\n\t\t\t * position table. */\n\t\t\tif (!lzh_br_read_ahead(strm, br, ds->pt.len_bits)) {\n\t\t\t\tif (last)\n\t\t\t\t\tgoto failed;/* Truncated data. */\n\t\t\t\tds->state = ST_RD_PT_1;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tds->pt.len_avail = lzh_br_bits(br, ds->pt.len_bits);\n\t\t\tlzh_br_consume(br, ds->pt.len_bits);\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_2:\n\t\t\tif (ds->pt.len_avail == 0) {\n\t\t\t\t/* There is no bitlen. */\n\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t    ds->pt.len_bits)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tds->state = ST_RD_PT_2;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\tif (!lzh_make_fake_table(&(ds->pt),\n\t\t\t\t    lzh_br_bits(br, ds->pt.len_bits)))\n\t\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\t\tlzh_br_consume(br, ds->pt.len_bits);\n\t\t\t\tif (ds->reading_position)\n\t\t\t\t\tds->state = ST_GET_LITERAL;\n\t\t\t\telse\n\t\t\t\t\tds->state = ST_RD_LITERAL_1;\n\t\t\t\tbreak;\n\t\t\t} else if (ds->pt.len_avail > ds->pt.len_size)\n\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\tds->loop = 0;\n\t\t\tmemset(ds->pt.freq, 0, sizeof(ds->pt.freq));\n\t\t\tif (ds->pt.len_avail < 3 ||\n\t\t\t    ds->pt.len_size == ds->pos_pt_len_size) {\n\t\t\t\tds->state = ST_RD_PT_4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_3:\n\t\t\tds->loop = lzh_read_pt_bitlen(strm, ds->loop, 3);\n\t\t\tif (ds->loop < 3) {\n\t\t\t\tif (ds->loop < 0 || last)\n\t\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\t\t/* Not completed, get following data. */\n\t\t\t\tds->state = ST_RD_PT_3;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\t/* There are some null in bitlen of the literal. */\n\t\t\tif (!lzh_br_read_ahead(strm, br, 2)) {\n\t\t\t\tif (last)\n\t\t\t\t\tgoto failed;/* Truncated data. */\n\t\t\t\tds->state = ST_RD_PT_3;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tc = lzh_br_bits(br, 2);\n\t\t\tlzh_br_consume(br, 2);\n\t\t\tif (c > ds->pt.len_avail - 3)\n\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\tfor (i = 3; c-- > 0 ;)\n\t\t\t\tds->pt.bitlen[i++] = 0;\n\t\t\tds->loop = i;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_PT_4:\n\t\t\tds->loop = lzh_read_pt_bitlen(strm, ds->loop,\n\t\t\t    ds->pt.len_avail);\n\t\t\tif (ds->loop < ds->pt.len_avail) {\n\t\t\t\tif (ds->loop < 0 || last)\n\t\t\t\t\tgoto failed;/* Invalid data. */\n\t\t\t\t/* Not completed, get following data. */\n\t\t\t\tds->state = ST_RD_PT_4;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tif (!lzh_make_huffman_table(&(ds->pt)))\n\t\t\t\tgoto failed;/* Invalid data */\n\t\t\tif (ds->reading_position) {\n\t\t\t\tds->state = ST_GET_LITERAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_LITERAL_1:\n\t\t\tif (!lzh_br_read_ahead(strm, br, ds->lt.len_bits)) {\n\t\t\t\tif (last)\n\t\t\t\t\tgoto failed;/* Truncated data. */\n\t\t\t\tds->state = ST_RD_LITERAL_1;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tds->lt.len_avail = lzh_br_bits(br, ds->lt.len_bits);\n\t\t\tlzh_br_consume(br, ds->lt.len_bits);\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_LITERAL_2:\n\t\t\tif (ds->lt.len_avail == 0) {\n\t\t\t\t/* There is no bitlen. */\n\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t    ds->lt.len_bits)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tds->state = ST_RD_LITERAL_2;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\tif (!lzh_make_fake_table(&(ds->lt),\n\t\t\t\t    lzh_br_bits(br, ds->lt.len_bits)))\n\t\t\t\t\tgoto failed;/* Invalid data */\n\t\t\t\tlzh_br_consume(br, ds->lt.len_bits);\n\t\t\t\tds->state = ST_RD_POS_DATA_1;\n\t\t\t\tbreak;\n\t\t\t} else if (ds->lt.len_avail > ds->lt.len_size)\n\t\t\t\tgoto failed;/* Invalid data */\n\t\t\tds->loop = 0;\n\t\t\tmemset(ds->lt.freq, 0, sizeof(ds->lt.freq));\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_LITERAL_3:\n\t\t\ti = ds->loop;\n\t\t\twhile (i < ds->lt.len_avail) {\n\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t    ds->pt.max_bits)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tds->loop = i;\n\t\t\t\t\tds->state = ST_RD_LITERAL_3;\n\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t}\n\t\t\t\trbits = lzh_br_bits(br, ds->pt.max_bits);\n\t\t\t\tc = lzh_decode_huffman(&(ds->pt), rbits);\n\t\t\t\tif (c > 2) {\n\t\t\t\t\t/* Note: 'c' will never be more than\n\t\t\t\t\t * eighteen since it's limited by\n\t\t\t\t\t * PT_BITLEN_SIZE, which is being set\n\t\t\t\t\t * to ds->pt.len_size through\n\t\t\t\t\t * ds->literal_pt_len_size. */\n\t\t\t\t\tlzh_br_consume(br, ds->pt.bitlen[c]);\n\t\t\t\t\tc -= 2;\n\t\t\t\t\tds->lt.freq[c]++;\n\t\t\t\t\tds->lt.bitlen[i++] = c;\n\t\t\t\t} else if (c == 0) {\n\t\t\t\t\tlzh_br_consume(br, ds->pt.bitlen[c]);\n\t\t\t\t\tds->lt.bitlen[i++] = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* c == 1 or c == 2 */\n\t\t\t\t\tint n = (c == 1)?4:9;\n\t\t\t\t\tif (!lzh_br_read_ahead(strm, br,\n\t\t\t\t\t     ds->pt.bitlen[c] + n)) {\n\t\t\t\t\t\tif (last) /* Truncated data. */\n\t\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\tds->loop = i;\n\t\t\t\t\t\tds->state = ST_RD_LITERAL_3;\n\t\t\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t\t\t}\n\t\t\t\t\tlzh_br_consume(br, ds->pt.bitlen[c]);\n\t\t\t\t\tc = lzh_br_bits(br, n);\n\t\t\t\t\tlzh_br_consume(br, n);\n\t\t\t\t\tc += (n == 4)?3:20;\n\t\t\t\t\tif (i + c > ds->lt.len_avail)\n\t\t\t\t\t\tgoto failed;/* Invalid data */\n\t\t\t\t\tmemset(&(ds->lt.bitlen[i]), 0, c);\n\t\t\t\t\ti += c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > ds->lt.len_avail ||\n\t\t\t    !lzh_make_huffman_table(&(ds->lt)))\n\t\t\t\tgoto failed;/* Invalid data */\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_RD_POS_DATA_1:\n\t\t\t/*\n\t\t\t * Read a position table compressed in huffman\n\t\t\t * coding.\n\t\t\t */\n\t\t\tds->pt.len_size = ds->pos_pt_len_size;\n\t\t\tds->pt.len_bits = ds->pos_pt_len_bits;\n\t\t\tds->reading_position = 1;\n\t\t\tds->state = ST_RD_PT_1;\n\t\t\tbreak;\n\t\tcase ST_GET_LITERAL:\n\t\t\treturn (100);\n\t\t}\n\t}\nfailed:\n\treturn (ds->error = ARCHIVE_FAILED);\n}\n\nstatic int\nlzh_decode_blocks(struct lzh_stream *strm, int last)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tstruct lzh_br bre = ds->br;\n\tstruct huffman *lt = &(ds->lt);\n\tstruct huffman *pt = &(ds->pt);\n\tunsigned char *w_buff = ds->w_buff;\n\tunsigned char *lt_bitlen = lt->bitlen;\n\tunsigned char *pt_bitlen = pt->bitlen;\n\tint blocks_avail = ds->blocks_avail, c = 0;\n\tint copy_len = ds->copy_len, copy_pos = ds->copy_pos;\n\tint w_pos = ds->w_pos, w_mask = ds->w_mask, w_size = ds->w_size;\n\tint lt_max_bits = lt->max_bits, pt_max_bits = pt->max_bits;\n\tint state = ds->state;\n\n\tfor (;;) {\n\t\tswitch (state) {\n\t\tcase ST_GET_LITERAL:\n\t\t\tfor (;;) {\n\t\t\t\tif (blocks_avail == 0) {\n\t\t\t\t\t/* We have decoded all blocks.\n\t\t\t\t\t * Let's handle next blocks. */\n\t\t\t\t\tds->state = ST_RD_BLOCK;\n\t\t\t\t\tds->br = bre;\n\t\t\t\t\tds->blocks_avail = 0;\n\t\t\t\t\tds->w_pos = w_pos;\n\t\t\t\t\tds->copy_pos = 0;\n\t\t\t\t\treturn (100);\n\t\t\t\t}\n\n\t\t\t\t/* lzh_br_read_ahead() always try to fill the\n\t\t\t\t * cache buffer up. In specific situation we\n\t\t\t\t * are close to the end of the data, the cache\n\t\t\t\t * buffer will not be full and thus we have to\n\t\t\t\t * determine if the cache buffer has some bits\n\t\t\t\t * as much as we need after lzh_br_read_ahead()\n\t\t\t\t * failed. */\n\t\t\t\tif (!lzh_br_read_ahead(strm, &bre,\n\t\t\t\t    lt_max_bits)) {\n\t\t\t\t\tif (!last)\n\t\t\t\t\t\tgoto next_data;\n\t\t\t\t\t/* Remaining bits are less than\n\t\t\t\t\t * maximum bits(lt.max_bits) but maybe\n\t\t\t\t\t * it still remains as much as we need,\n\t\t\t\t\t * so we should try to use it with\n\t\t\t\t\t * dummy bits. */\n\t\t\t\t\tc = lzh_decode_huffman(lt,\n\t\t\t\t\t      lzh_br_bits_forced(&bre,\n\t\t\t\t\t        lt_max_bits));\n\t\t\t\t\tlzh_br_consume(&bre, lt_bitlen[c]);\n\t\t\t\t\tif (!lzh_br_has(&bre, 0))\n\t\t\t\t\t\tgoto failed;/* Over read. */\n\t\t\t\t} else {\n\t\t\t\t\tc = lzh_decode_huffman(lt,\n\t\t\t\t\t      lzh_br_bits(&bre, lt_max_bits));\n\t\t\t\t\tlzh_br_consume(&bre, lt_bitlen[c]);\n\t\t\t\t}\n\t\t\t\tblocks_avail--;\n\t\t\t\tif (c > UCHAR_MAX)\n\t\t\t\t\t/* Current block is a match data. */\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * 'c' is exactly a literal code.\n\t\t\t\t */\n\t\t\t\t/* Save a decoded code to reference it\n\t\t\t\t * afterward. */\n\t\t\t\tw_buff[w_pos] = c;\n\t\t\t\tif (++w_pos >= w_size) {\n\t\t\t\t\tw_pos = 0;\n\t\t\t\t\tlzh_emit_window(strm, w_size);\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* 'c' is the length of a match pattern we have\n\t\t\t * already extracted, which has be stored in\n\t\t\t * window(ds->w_buff). */\n\t\t\tcopy_len = c - (UCHAR_MAX + 1) + MINMATCH;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_GET_POS_1:\n\t\t\t/*\n\t\t\t * Get a reference position. \n\t\t\t */\n\t\t\tif (!lzh_br_read_ahead(strm, &bre, pt_max_bits)) {\n\t\t\t\tif (!last) {\n\t\t\t\t\tstate = ST_GET_POS_1;\n\t\t\t\t\tds->copy_len = copy_len;\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t\tcopy_pos = lzh_decode_huffman(pt,\n\t\t\t\t    lzh_br_bits_forced(&bre, pt_max_bits));\n\t\t\t\tlzh_br_consume(&bre, pt_bitlen[copy_pos]);\n\t\t\t\tif (!lzh_br_has(&bre, 0))\n\t\t\t\t\tgoto failed;/* Over read. */\n\t\t\t} else {\n\t\t\t\tcopy_pos = lzh_decode_huffman(pt,\n\t\t\t\t    lzh_br_bits(&bre, pt_max_bits));\n\t\t\t\tlzh_br_consume(&bre, pt_bitlen[copy_pos]);\n\t\t\t}\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_GET_POS_2:\n\t\t\tif (copy_pos > 1) {\n\t\t\t\t/* We need an additional adjustment number to\n\t\t\t\t * the position. */\n\t\t\t\tint p = copy_pos - 1;\n\t\t\t\tif (!lzh_br_read_ahead(strm, &bre, p)) {\n\t\t\t\t\tif (last)\n\t\t\t\t\t\tgoto failed;/* Truncated data.*/\n\t\t\t\t\tstate = ST_GET_POS_2;\n\t\t\t\t\tds->copy_len = copy_len;\n\t\t\t\t\tds->copy_pos = copy_pos;\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t\tcopy_pos = (1 << p) + lzh_br_bits(&bre, p);\n\t\t\t\tlzh_br_consume(&bre, p);\n\t\t\t}\n\t\t\t/* The position is actually a distance from the last\n\t\t\t * code we had extracted and thus we have to convert\n\t\t\t * it to a position of the window. */\n\t\t\tcopy_pos = (w_pos - copy_pos - 1) & w_mask;\n\t\t\t/* FALL THROUGH */\n\t\tcase ST_COPY_DATA:\n\t\t\t/*\n\t\t\t * Copy `copy_len' bytes as extracted data from\n\t\t\t * the window into the output buffer.\n\t\t\t */\n\t\t\tfor (;;) {\n\t\t\t\tint l;\n\n\t\t\t\tl = copy_len;\n\t\t\t\tif (copy_pos > w_pos) {\n\t\t\t\t\tif (l > w_size - copy_pos)\n\t\t\t\t\t\tl = w_size - copy_pos;\n\t\t\t\t} else {\n\t\t\t\t\tif (l > w_size - w_pos)\n\t\t\t\t\t\tl = w_size - w_pos;\n\t\t\t\t}\n\t\t\t\tif ((copy_pos + l < w_pos)\n\t\t\t\t    || (w_pos + l < copy_pos)) {\n\t\t\t\t\t/* No overlap. */\n\t\t\t\t\tmemcpy(w_buff + w_pos,\n\t\t\t\t\t    w_buff + copy_pos, l);\n\t\t\t\t} else {\n\t\t\t\t\tconst unsigned char *s;\n\t\t\t\t\tunsigned char *d;\n\t\t\t\t\tint li;\n\n\t\t\t\t\td = w_buff + w_pos;\n\t\t\t\t\ts = w_buff + copy_pos;\n\t\t\t\t\tfor (li = 0; li < l-1;) {\n\t\t\t\t\t\td[li] = s[li];li++;\n\t\t\t\t\t\td[li] = s[li];li++;\n\t\t\t\t\t}\n\t\t\t\t\tif (li < l)\n\t\t\t\t\t\td[li] = s[li];\n\t\t\t\t}\n\t\t\t\tw_pos += l;\n\t\t\t\tif (w_pos == w_size) {\n\t\t\t\t\tw_pos = 0;\n\t\t\t\t\tlzh_emit_window(strm, w_size);\n\t\t\t\t\tif (copy_len <= l)\n\t\t\t\t\t\tstate = ST_GET_LITERAL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tstate = ST_COPY_DATA;\n\t\t\t\t\t\tds->copy_len = copy_len - l;\n\t\t\t\t\t\tds->copy_pos =\n\t\t\t\t\t\t    (copy_pos + l) & w_mask;\n\t\t\t\t\t}\n\t\t\t\t\tgoto next_data;\n\t\t\t\t}\n\t\t\t\tif (copy_len <= l)\n\t\t\t\t\t/* A copy of current pattern ended. */\n\t\t\t\t\tbreak;\n\t\t\t\tcopy_len -= l;\n\t\t\t\tcopy_pos = (copy_pos + l) & w_mask;\n\t\t\t}\n\t\t\tstate = ST_GET_LITERAL;\n\t\t\tbreak;\n\t\t}\n\t}\nfailed:\n\treturn (ds->error = ARCHIVE_FAILED);\nnext_data:\n\tds->br = bre;\n\tds->blocks_avail = blocks_avail;\n\tds->state = state;\n\tds->w_pos = w_pos;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nlzh_huffman_init(struct huffman *hf, size_t len_size, int tbl_bits)\n{\n\tint bits;\n\n\tif (hf->bitlen == NULL) {\n\t\thf->bitlen = malloc(len_size * sizeof(hf->bitlen[0]));\n\t\tif (hf->bitlen == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (hf->tbl == NULL) {\n\t\tif (tbl_bits < HTBL_BITS)\n\t\t\tbits = tbl_bits;\n\t\telse\n\t\t\tbits = HTBL_BITS;\n\t\thf->tbl = malloc(((size_t)1 << bits) * sizeof(hf->tbl[0]));\n\t\tif (hf->tbl == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (hf->tree == NULL && tbl_bits > HTBL_BITS) {\n\t\thf->tree_avail = 1 << (tbl_bits - HTBL_BITS + 4);\n\t\thf->tree = malloc(hf->tree_avail * sizeof(hf->tree[0]));\n\t\tif (hf->tree == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\thf->len_size = (int)len_size;\n\thf->tbl_bits = tbl_bits;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nlzh_huffman_free(struct huffman *hf)\n{\n\tfree(hf->bitlen);\n\tfree(hf->tbl);\n\tfree(hf->tree);\n}\n\nstatic char bitlen_tbl[0x400] = {\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n\t11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n\t11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n\t12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n\t13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16,  0\n};\nstatic int\nlzh_read_pt_bitlen(struct lzh_stream *strm, int start, int end)\n{\n\tstruct lzh_dec *ds = strm->ds;\n\tstruct lzh_br *br = &(ds->br);\n\tint c, i;\n\n\tfor (i = start; i < end; ) {\n\t\t/*\n\t\t *  bit pattern     the number we need\n\t\t *     000           ->  0\n\t\t *     001           ->  1\n\t\t *     010           ->  2\n\t\t *     ...\n\t\t *     110           ->  6\n\t\t *     1110          ->  7\n\t\t *     11110         ->  8\n\t\t *     ...\n\t\t *     1111111111110 ->  16\n\t\t */\n\t\tif (!lzh_br_read_ahead(strm, br, 3))\n\t\t\treturn (i);\n\t\tif ((c = lzh_br_bits(br, 3)) == 7) {\n\t\t\tif (!lzh_br_read_ahead(strm, br, 13))\n\t\t\t\treturn (i);\n\t\t\tc = bitlen_tbl[lzh_br_bits(br, 13) & 0x3FF];\n\t\t\tif (c)\n\t\t\t\tlzh_br_consume(br, c - 3);\n\t\t\telse\n\t\t\t\treturn (-1);/* Invalid data. */\n\t\t} else\n\t\t\tlzh_br_consume(br, 3);\n\t\tds->pt.bitlen[i++] = c;\n\t\tds->pt.freq[c]++;\n\t}\n\treturn (i);\n}\n\nstatic int\nlzh_make_fake_table(struct huffman *hf, uint16_t c)\n{\n\tif (c >= hf->len_size)\n\t\treturn (0);\n\thf->tbl[0] = c;\n\thf->max_bits = 0;\n\thf->shift_bits = 0;\n\thf->bitlen[hf->tbl[0]] = 0;\n\treturn (1);\n}\n\n/*\n * Make a huffman coding table.\n */\nstatic int\nlzh_make_huffman_table(struct huffman *hf)\n{\n\tuint16_t *tbl;\n\tconst unsigned char *bitlen;\n\tint bitptn[17], weight[17];\n\tint i, maxbits = 0, ptn, tbl_size, w;\n\tint diffbits, len_avail;\n\n\t/*\n\t * Initialize bit patterns.\n\t */\n\tptn = 0;\n\tfor (i = 1, w = 1 << 15; i <= 16; i++, w >>= 1) {\n\t\tbitptn[i] = ptn;\n\t\tweight[i] = w;\n\t\tif (hf->freq[i]) {\n\t\t\tptn += hf->freq[i] * w;\n\t\t\tmaxbits = i;\n\t\t}\n\t}\n\tif (ptn != 0x10000 || maxbits > hf->tbl_bits)\n\t\treturn (0);/* Invalid */\n\n\thf->max_bits = maxbits;\n\n\t/*\n\t * Cut out extra bits which we won't house in the table.\n\t * This preparation reduces the same calculation in the for-loop\n\t * making the table.\n\t */\n\tif (maxbits < 16) {\n\t\tint ebits = 16 - maxbits;\n\t\tfor (i = 1; i <= maxbits; i++) {\n\t\t\tbitptn[i] >>= ebits;\n\t\t\tweight[i] >>= ebits;\n\t\t}\n\t}\n\tif (maxbits > HTBL_BITS) {\n\t\tunsigned htbl_max;\n\t\tuint16_t *p;\n\n\t\tdiffbits = maxbits - HTBL_BITS;\n\t\tfor (i = 1; i <= HTBL_BITS; i++) {\n\t\t\tbitptn[i] >>= diffbits;\n\t\t\tweight[i] >>= diffbits;\n\t\t}\n\t\thtbl_max = bitptn[HTBL_BITS] +\n\t\t    weight[HTBL_BITS] * hf->freq[HTBL_BITS];\n\t\tp = &(hf->tbl[htbl_max]);\n\t\twhile (p < &hf->tbl[1U<<HTBL_BITS])\n\t\t\t*p++ = 0;\n\t} else\n\t\tdiffbits = 0;\n\thf->shift_bits = diffbits;\n\n\t/*\n\t * Make the table.\n\t */\n\ttbl_size = 1 << HTBL_BITS;\n\ttbl = hf->tbl;\n\tbitlen = hf->bitlen;\n\tlen_avail = hf->len_avail;\n\thf->tree_used = 0;\n\tfor (i = 0; i < len_avail; i++) {\n\t\tuint16_t *p;\n\t\tint len, cnt;\n\t\tuint16_t bit;\n\t\tint extlen;\n\t\tstruct htree_t *ht;\n\n\t\tif (bitlen[i] == 0)\n\t\t\tcontinue;\n\t\t/* Get a bit pattern */\n\t\tlen = bitlen[i];\n\t\tptn = bitptn[len];\n\t\tcnt = weight[len];\n\t\tif (len <= HTBL_BITS) {\n\t\t\t/* Calculate next bit pattern */\n\t\t\tif ((bitptn[len] = ptn + cnt) > tbl_size)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\t/* Update the table */\n\t\t\tp = &(tbl[ptn]);\n\t\t\tif (cnt > 7) {\n\t\t\t\tuint16_t *pc;\n\n\t\t\t\tcnt -= 8;\n\t\t\t\tpc = &p[cnt];\n\t\t\t\tpc[0] = (uint16_t)i;\n\t\t\t\tpc[1] = (uint16_t)i;\n\t\t\t\tpc[2] = (uint16_t)i;\n\t\t\t\tpc[3] = (uint16_t)i;\n\t\t\t\tpc[4] = (uint16_t)i;\n\t\t\t\tpc[5] = (uint16_t)i;\n\t\t\t\tpc[6] = (uint16_t)i;\n\t\t\t\tpc[7] = (uint16_t)i;\n\t\t\t\tif (cnt > 7) {\n\t\t\t\t\tcnt -= 8;\n\t\t\t\t\tmemcpy(&p[cnt], pc,\n\t\t\t\t\t\t8 * sizeof(uint16_t));\n\t\t\t\t\tpc = &p[cnt];\n\t\t\t\t\twhile (cnt > 15) {\n\t\t\t\t\t\tcnt -= 16;\n\t\t\t\t\t\tmemcpy(&p[cnt], pc,\n\t\t\t\t\t\t\t16 * sizeof(uint16_t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt)\n\t\t\t\t\tmemcpy(p, pc, cnt * sizeof(uint16_t));\n\t\t\t} else {\n\t\t\t\twhile (cnt > 1) {\n\t\t\t\t\tp[--cnt] = (uint16_t)i;\n\t\t\t\t\tp[--cnt] = (uint16_t)i;\n\t\t\t\t}\n\t\t\t\tif (cnt)\n\t\t\t\t\tp[--cnt] = (uint16_t)i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * A bit length is too big to be housed to a direct table,\n\t\t * so we use a tree model for its extra bits.\n\t\t */\n\t\tbitptn[len] = ptn + cnt;\n\t\tbit = 1U << (diffbits -1);\n\t\textlen = len - HTBL_BITS;\n\t\t\n\t\tp = &(tbl[ptn >> diffbits]);\n\t\tif (*p == 0) {\n\t\t\t*p = len_avail + hf->tree_used;\n\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->left = 0;\n\t\t\tht->right = 0;\n\t\t} else {\n\t\t\tif (*p < len_avail ||\n\t\t\t    *p >= (len_avail + hf->tree_used))\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht = &(hf->tree[*p - len_avail]);\n\t\t}\n\t\twhile (--extlen > 0) {\n\t\t\tif (ptn & bit) {\n\t\t\t\tif (ht->left < len_avail) {\n\t\t\t\t\tht->left = len_avail + hf->tree_used;\n\t\t\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\t\t\treturn (0);/* Invalid */\n\t\t\t\t\tht->left = 0;\n\t\t\t\t\tht->right = 0;\n\t\t\t\t} else {\n\t\t\t\t\tht = &(hf->tree[ht->left - len_avail]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ht->right < len_avail) {\n\t\t\t\t\tht->right = len_avail + hf->tree_used;\n\t\t\t\t\tht = &(hf->tree[hf->tree_used++]);\n\t\t\t\t\tif (hf->tree_used > hf->tree_avail)\n\t\t\t\t\t\treturn (0);/* Invalid */\n\t\t\t\t\tht->left = 0;\n\t\t\t\t\tht->right = 0;\n\t\t\t\t} else {\n\t\t\t\t\tht = &(hf->tree[ht->right - len_avail]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbit >>= 1;\n\t\t}\n\t\tif (ptn & bit) {\n\t\t\tif (ht->left != 0)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->left = (uint16_t)i;\n\t\t} else {\n\t\t\tif (ht->right != 0)\n\t\t\t\treturn (0);/* Invalid */\n\t\t\tht->right = (uint16_t)i;\n\t\t}\n\t}\n\treturn (1);\n}\n\nstatic int\nlzh_decode_huffman_tree(struct huffman *hf, unsigned rbits, int c)\n{\n\tstruct htree_t *ht;\n\tint extlen;\n\n\tht = hf->tree;\n\textlen = hf->shift_bits;\n\twhile (c >= hf->len_avail) {\n\t\tc -= hf->len_avail;\n\t\tif (extlen-- <= 0 || c >= hf->tree_used)\n\t\t\treturn (0);\n\t\tif (rbits & (1U << extlen))\n\t\t\tc = ht[c].left;\n\t\telse\n\t\t\tc = ht[c].right;\n\t}\n\treturn (c);\n}\n\nstatic inline int\nlzh_decode_huffman(struct huffman *hf, unsigned rbits)\n{\n\tint c;\n\t/*\n\t * At first search an index table for a bit pattern.\n\t * If it fails, search a huffman tree for.\n\t */\n\tc = hf->tbl[rbits >> hf->shift_bits];\n\tif (c < hf->len_avail || hf->len_avail == 0)\n\t\treturn (c);\n\t/* This bit pattern needs to be found out at a huffman tree. */\n\treturn (lzh_decode_huffman_tree(hf, rbits, c));\n}\n\n"], "filenames": ["libarchive/archive_read_support_format_lha.c"], "buggy_code_start_loc": [925], "buggy_code_end_loc": [925], "fixing_code_start_loc": [926], "fixing_code_end_loc": [929], "type": "CWE-125", "message": "An error in the lha_read_file_header_1() function (archive_read_support_format_lha.c) in libarchive 3.2.2 allows remote attackers to trigger an out-of-bounds read memory access and subsequently cause a crash via a specially crafted archive.", "other": {"cve": {"id": "CVE-2017-5601", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-27T22:59:08.413", "lastModified": "2018-11-30T11:29:02.957", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An error in the lha_read_file_header_1() function (archive_read_support_format_lha.c) in libarchive 3.2.2 allows remote attackers to trigger an out-of-bounds read memory access and subsequently cause a crash via a specially crafted archive."}, {"lang": "es", "value": "Un error en la funci\u00f3n lha_read_file_header_1() (archive_read_support_format_lha.c) en libarchive 3.2.2 permite a un atacantes desencadenar un acceso de lectura fuera de l\u00edmites de la memoria y posteriormente provocar una ca\u00edda a trav\u00e9s de un archivo especialmente manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "EE49FE66-2BDF-4237-8BF1-F9851B75B526"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95837", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037974", "source": "cve@mitre.org"}, {"url": "https://github.com/libarchive/libarchive/commit/98dcbbf0bf4854bf987557e55e55fff7abbf3ea9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00037.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/98dcbbf0bf4854bf987557e55e55fff7abbf3ea9"}}