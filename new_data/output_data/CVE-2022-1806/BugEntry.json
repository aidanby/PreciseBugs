{"buggy_code": ["import tornado.ioloop\nimport tornado.web\nimport os\n#import sqlite3\nimport json\nimport sys\nimport rtxcomplete\nimport traceback\n\n#class MainHandler(tornado.web.RequestHandler):\n#    def get(self):\n#        self.write(\"Hello, world\")\n#print __file__\n\nroot = os.path.dirname(os.path.abspath(__file__))\nrtxcomplete.load()\n#conn = sqlite3.connect('dict.db')\n#conn.enable_load_extension(True)\n#conn.load_extension(\"./spellfix\")\n#cursor = conn.cursor()\n\nclass autoSearch(tornado.web.RequestHandler):\n\n    def get(self, arg,word=None):\n        #print \"match auto\"\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = self.get_argument(\"callback\") #jsonp\n\n            result = rtxcomplete.prefix(word,limit)\n\n            result = callback+\"(\"+json.dumps(result)+\");\" #jsonp\n            #result = json.dumps(result) #typeahead\n            \n            self.write(result)\n            \n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            #print sys.exc_info()[2]\n            self.write(\"error\")\n\nclass fuzzySearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        #print \"matched fuzzy\"\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = self.get_argument(\"callback\")\n            #print word\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit)\n            result = rtxcomplete.fuzzy(word,limit);\n            #rows = cursor.fetchall()\n            #print type(rows)\n            result = callback+\"(\"+json.dumps(result)+\");\"\n            #print arg, result\n            #if (len(rows) > 0):\n            self.write(result)\n            #else:\n            #self.write(callback+\"(\"+json.dumps([[\"NO SUGGESTIONS\"]])+\");\")\n            #self.write(json.dumps(rows))\n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            #print sys.exc_info()[:]\n            self.write(\"error\")\n\nclass autofuzzySearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        #print \"matched autofuzzy\"\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = self.get_argument(\"callback\")\n            #print word\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit)\n            result = rtxcomplete.autofuzzy(word,limit);\n            #rows = cursor.fetchall()\n            #print type(rows)\n            result = callback+\"(\"+json.dumps(result)+\");\"\n            #print arg, result\n            #if (len(rows) > 0):\n            self.write(result)\n            #else:\n            #self.write(callback+\"(\"+json.dumps([[\"NO SUGGESTIONS\"]])+\");\")\n            #self.write(json.dumps(rows))\n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            #print sys.exc_info()[:]\n            self.write(\"error\")\n\n\nclass nodesLikeSearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        #try:\n        if 1 == 1:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = self.get_argument(\"callback\")\n            result = rtxcomplete.get_nodes_like(word,limit);\n            result = callback+\"(\"+json.dumps(result)+\");\"\n            self.write(result)\n        #except:\n        #    print(sys.exc_info()[:])\n        #    traceback.print_tb(sys.exc_info()[-1])\n        #    self.write(\"error\")\n\n\nclass defineSearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        print(\"matched define search: not implemented\")\n        self.write(\"\")\n            \ndef make_https_app():\n    return tornado.web.Application([\n        #(r\"/\", MainHandler),\n        (r\"/autofuzzy(.*)\", autofuzzySearch),\n        (r\"/auto(.*)\", autoSearch),\n        (r\"/fuzzy(.*)\", fuzzySearch),\n        (r\"/define(.*)\", defineSearch),\n        (r\"/nodeslike(.*)\", nodesLikeSearch),\n        (r\"/(.*)\", tornado.web.StaticFileHandler,\n         {\"path\": root, \"default_filename\": \"rtxcomplete.html\"}),\n    ],\n        compress_response= True)\n\nclass redirect_handler(tornado.web.RequestHandler):\n    def prepare(self):\n        if self.request.protocol == 'http':\n            if self.request.host == \"rtxcomplete.ixlab.org\":\n                self.redirect('https://'+self.request.host, permanent=False)\n                \n    def get(self):\n        self.write(\"Looks like you're trying to access rtxcomplete at the wrong host name.\")\n        self.write(\"<br>Please make sure the address is correct: 'rtxcomplete.ixlab.org'\")\n\ndef make_redirect_app():\n    return tornado.web.Application([\n        (r'/', redirect_handler)\n    ])\n\nif __name__ == \"__main__\":\n    print(\"root: \" + root)\n\n    if True: #FW/EWD: clean this up later\n        http_app = make_https_app()\n        http_server = tornado.httpserver.HTTPServer(http_app)\n        http_server.listen(4999)\n\n    else:\n        redirect_app = make_redirect_app()\n        redirect_app.listen(80)\n\n        https_app = make_https_app()\n        https_server = tornado.httpserver.HTTPServer(https_app, ssl_options={\n            \"certfile\": \"/etc/letsencrypt/live/rtxcomplete.ixlab.org/fullchain.pem\",\n            \"keyfile\" : \"/etc/letsencrypt/live/rtxcomplete.ixlab.org/privkey.pem\",\n            })\n        https_server.listen(443)\n\n    tornado.ioloop.IOLoop.current().start()\n"], "fixing_code": ["import tornado.ioloop\nimport tornado.web\nimport os\n#import sqlite3\nimport json\nimport sys\nimport rtxcomplete\nimport traceback\nimport re\n\nroot = os.path.dirname(os.path.abspath(__file__))\nrtxcomplete.load()\n\n\n#### Sanitize the client-provided callback function name\ndef sanitize_callback(callback):\n    if callback is None or not isinstance(callback,str):\n        return 'autocomplete_callback'\n    match = re.match(r'([a-zA-Z0-9_]+).*$', callback)\n    if match:\n         callback = match.group(1)\n    else:\n         callback = 'autocomplete_callback'\n    return callback\n\n\nclass autoSearch(tornado.web.RequestHandler):\n\n    def get(self, arg,word=None):\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = sanitize_callback(self.get_argument(\"callback\"))\n\n            result = rtxcomplete.prefix(word,limit)\n            \n            result = callback+\"(\"+json.dumps(result)+\");\"\n            \n            self.write(result)\n            \n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            #print sys.exc_info()[2]\n            self.write(\"error\")\n\nclass fuzzySearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        #print \"matched fuzzy\"\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = sanitize_callback(self.get_argument(\"callback\"))\n            #print word\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit)\n            result = rtxcomplete.fuzzy(word,limit);\n            #rows = cursor.fetchall()\n            #print type(rows)\n            result = callback+\"(\"+json.dumps(result)+\");\"\n            #print arg, result\n            #if (len(rows) > 0):\n            self.write(result)\n            #else:\n            #self.write(callback+\"(\"+json.dumps([[\"NO SUGGESTIONS\"]])+\");\")\n            #self.write(json.dumps(rows))\n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            #print sys.exc_info()[:]\n            self.write(\"error\")\n\nclass autofuzzySearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        #print \"matched autofuzzy\"\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = sanitize_callback(self.get_argument(\"callback\"))\n            #print word\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"\\\" LIMIT \" + limit)\n            #cursor.execute(\"SELECT word FROM spell WHERE word MATCH \\\"\" + word + \"*\\\" LIMIT \" + limit)\n            result = rtxcomplete.autofuzzy(word,limit);\n            #rows = cursor.fetchall()\n            #print type(rows)\n            result = callback+\"(\"+json.dumps(result)+\");\"\n            #print arg, result\n            #if (len(rows) > 0):\n            self.write(result)\n            #else:\n            #self.write(callback+\"(\"+json.dumps([[\"NO SUGGESTIONS\"]])+\");\")\n            #self.write(json.dumps(rows))\n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            #print sys.exc_info()[:]\n            self.write(\"error\")\n\n\nclass nodesLikeSearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        try:\n            limit = self.get_argument(\"limit\")\n            word = self.get_argument(\"word\")\n            callback = sanitize_callback(self.get_argument(\"callback\"))\n            result = rtxcomplete.get_nodes_like(word,limit);\n            result = callback+\"(\"+json.dumps(result)+\");\"\n            self.write(result)\n        except:\n            print(sys.exc_info()[:])\n            traceback.print_tb(sys.exc_info()[-1])\n            self.write(\"error\")\n\n\nclass defineSearch(tornado.web.RequestHandler):\n    def get(self, arg,word=None):\n        print(\"matched define search: not implemented\")\n        self.write(\"\")\n            \ndef make_https_app():\n    return tornado.web.Application([\n        #(r\"/\", MainHandler),\n        (r\"/autofuzzy(.*)\", autofuzzySearch),\n        (r\"/auto(.*)\", autoSearch),\n        (r\"/fuzzy(.*)\", fuzzySearch),\n        (r\"/define(.*)\", defineSearch),\n        (r\"/nodeslike(.*)\", nodesLikeSearch),\n        (r\"/(.*)\", tornado.web.StaticFileHandler,\n         {\"path\": root, \"default_filename\": \"rtxcomplete.html\"}),\n    ],\n        compress_response= True)\n\nclass redirect_handler(tornado.web.RequestHandler):\n    def prepare(self):\n        if self.request.protocol == 'http':\n            if self.request.host == \"rtxcomplete.ixlab.org\":\n                self.redirect('https://'+self.request.host, permanent=False)\n                \n    def get(self):\n        self.write(\"Looks like you're trying to access rtxcomplete at the wrong host name.\")\n        self.write(\"<br>Please make sure the address is correct: 'rtxcomplete.ixlab.org'\")\n\ndef make_redirect_app():\n    return tornado.web.Application([\n        (r'/', redirect_handler)\n    ])\n\nif __name__ == \"__main__\":\n    print(\"root: \" + root)\n\n    if True: #FW/EWD: clean this up later\n        http_app = make_https_app()\n        http_server = tornado.httpserver.HTTPServer(http_app)\n        http_server.listen(4999)\n\n    else:\n        redirect_app = make_redirect_app()\n        redirect_app.listen(80)\n\n        https_app = make_https_app()\n        https_server = tornado.httpserver.HTTPServer(https_app, ssl_options={\n            \"certfile\": \"/etc/letsencrypt/live/rtxcomplete.ixlab.org/fullchain.pem\",\n            \"keyfile\" : \"/etc/letsencrypt/live/rtxcomplete.ixlab.org/privkey.pem\",\n            })\n        https_server.listen(443)\n\n    tornado.ioloop.IOLoop.current().start()\n"], "filenames": ["code/autocomplete/server.py"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [111], "fixing_code_start_loc": [9], "fixing_code_end_loc": [113], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository rtxteam/rtx prior to checkpoint_2022-05-18.", "other": {"cve": {"id": "CVE-2022-1806", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-20T09:15:10.327", "lastModified": "2022-05-26T19:22:40.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository rtxteam/rtx prior to checkpoint_2022-05-18."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Reflejado en el repositorio GitHub rtxteam/rtx versiones anteriores al checkpoint_18-05-2022"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rtx_project:rtx:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-05-18", "matchCriteriaId": "AEF1B236-EDF0-43F7-BEB2-21FB17EA893F"}]}]}], "references": [{"url": "https://github.com/rtxteam/rtx/commit/9bb109b0014f952f315c7b89e0f29a9ba84ee04c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/101a2a31-0b27-433a-ad3a-a216238ca4d1", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rtxteam/rtx/commit/9bb109b0014f952f315c7b89e0f29a9ba84ee04c"}}