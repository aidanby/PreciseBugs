{"buggy_code": ["// Copyright 2012-2020 (c) Peter \u0160irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkUtils\n * @version 3.4.4\n */\n\n'use strict';\n\nconst Dns = require('dns');\nconst Url = require('url');\nconst Qs = require('querystring');\nconst Http = require('http');\nconst Https = require('https');\nconst Path = require('path');\nconst Fs = require('fs');\nconst Events = require('events');\nconst Crypto = require('crypto');\nconst Zlib = require('zlib');\nconst Tls = require('tls');\nconst KeepAlive = new Http.Agent({ keepAlive: true, timeout: 60000 });\n\nconst COMPRESS = { gzip: 1, deflate: 1 };\nconst CONCAT = [null, null];\nconst COMPARER = global.Intl ? global.Intl.Collator().compare : function(a, b) {\n\treturn a.removeDiacritics().localeCompare(b.removeDiacritics());\n};\n\nif (!global.framework_utils)\n\tglobal.framework_utils = exports;\n\nconst Internal = require('./internal');\nvar regexpSTATIC = /\\.\\w{2,8}($|\\?)+/;\nconst regexpTRIM = /^[\\s]+|[\\s]+$/g;\nconst regexpDATE = /(\\d{1,2}\\.\\d{1,2}\\.\\d{4})|(\\d{4}-\\d{1,2}-\\d{1,2})|(\\d{1,2}:\\d{1,2}(:\\d{1,2})?)/g;\nconst regexpDATEFORMAT = /YYYY|yyyy|YY|yy|MMMM|MMM|MM|M|dddd|DDDD|DDD|ddd|DD|dd|D|d|HH|H|hh|h|mm|m|ss|s|a|ww|w/g;\nconst regexpSTRINGFORMAT = /\\{\\d+\\}/g;\nconst regexpPATH = /\\\\/g;\nconst regexpTags = /<\\/?[^>]+(>|$)/g;\nconst regexpDiacritics = /[^\\u0000-\\u007e]/g;\nconst regexpUA = /[a-z]+/gi;\nconst regexpXML = /\\w+=\".*?\"/g;\nconst regexpDECODE = /&#?[a-z0-9]+;/g;\nconst regexpPARAM = /\\{{2}[^}\\n]*\\}{2}/g;\nconst regexpARG = /\\{{1,2}[a-z0-9_.-\\s]+\\}{1,2}/gi;\nconst regexpINTEGER = /(^-|\\s-)?[0-9]+/g;\nconst regexpFLOAT = /(^-|\\s-)?[0-9.,]+/g;\nconst regexpALPHA = /^[A-Za-z0-9]+$/;\nconst regexpSEARCH = /[^a-zA-Z\u00e1-\u017e\u00c1-\u017d\\d\\s:]/g;\nconst regexpTERMINAL = /[\\w\\S]+/g;\nconst regexpCONFIGURE = /\\[\\w+\\]/g;\nconst regexpY = /y/g;\nconst regexpN = /\\n/g;\nconst regexpCHARS = /\\W|_/g;\nconst regexpCHINA = /[\\u3400-\\u9FBF]/;\nconst regexpLINES = /\\n|\\r|\\r\\n/;\nconst regexpBASE64 = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst SOUNDEX = { a: '', e: '', i: '', o: '', u: '', b: 1, f: 1, p: 1, v: 1, c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2, d: 3, t: 3, l: 4, m: 5, n: 5, r: 6 };\nconst ENCODING = 'utf8';\nconst NEWLINE = '\\r\\n';\nconst isWindows = require('os').platform().substring(0, 3).toLowerCase() === 'win';\nconst DIACRITICSMAP = {};\nconst STREAM_READONLY = { flags: 'r' };\nconst STREAM_END = { end: false };\nconst ALPHA_INDEX = { '&lt': '<', '&gt': '>', '&quot': '\"', '&apos': '\\'', '&amp': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"', '&apos;': '\\'', '&amp;': '&' };\nconst NODEVERSION = parseFloat(process.version.toString().replace('v', '').replace(/\\./g, ''));\nconst STREAMPIPE = { end: false };\nconst CT = 'Content-Type';\nconst CRC32TABLE = '00000000,77073096,EE0E612C,990951BA,076DC419,706AF48F,E963A535,9E6495A3,0EDB8832,79DCB8A4,E0D5E91E,97D2D988,09B64C2B,7EB17CBD,E7B82D07,90BF1D91,1DB71064,6AB020F2,F3B97148,84BE41DE,1ADAD47D,6DDDE4EB,F4D4B551,83D385C7,136C9856,646BA8C0,FD62F97A,8A65C9EC,14015C4F,63066CD9,FA0F3D63,8D080DF5,3B6E20C8,4C69105E,D56041E4,A2677172,3C03E4D1,4B04D447,D20D85FD,A50AB56B,35B5A8FA,42B2986C,DBBBC9D6,ACBCF940,32D86CE3,45DF5C75,DCD60DCF,ABD13D59,26D930AC,51DE003A,C8D75180,BFD06116,21B4F4B5,56B3C423,CFBA9599,B8BDA50F,2802B89E,5F058808,C60CD9B2,B10BE924,2F6F7C87,58684C11,C1611DAB,B6662D3D,76DC4190,01DB7106,98D220BC,EFD5102A,71B18589,06B6B51F,9FBFE4A5,E8B8D433,7807C9A2,0F00F934,9609A88E,E10E9818,7F6A0DBB,086D3D2D,91646C97,E6635C01,6B6B51F4,1C6C6162,856530D8,F262004E,6C0695ED,1B01A57B,8208F4C1,F50FC457,65B0D9C6,12B7E950,8BBEB8EA,FCB9887C,62DD1DDF,15DA2D49,8CD37CF3,FBD44C65,4DB26158,3AB551CE,A3BC0074,D4BB30E2,4ADFA541,3DD895D7,A4D1C46D,D3D6F4FB,4369E96A,346ED9FC,AD678846,DA60B8D0,44042D73,33031DE5,AA0A4C5F,DD0D7CC9,5005713C,270241AA,BE0B1010,C90C2086,5768B525,206F85B3,B966D409,CE61E49F,5EDEF90E,29D9C998,B0D09822,C7D7A8B4,59B33D17,2EB40D81,B7BD5C3B,C0BA6CAD,EDB88320,9ABFB3B6,03B6E20C,74B1D29A,EAD54739,9DD277AF,04DB2615,73DC1683,E3630B12,94643B84,0D6D6A3E,7A6A5AA8,E40ECF0B,9309FF9D,0A00AE27,7D079EB1,F00F9344,8708A3D2,1E01F268,6906C2FE,F762575D,806567CB,196C3671,6E6B06E7,FED41B76,89D32BE0,10DA7A5A,67DD4ACC,F9B9DF6F,8EBEEFF9,17B7BE43,60B08ED5,D6D6A3E8,A1D1937E,38D8C2C4,4FDFF252,D1BB67F1,A6BC5767,3FB506DD,48B2364B,D80D2BDA,AF0A1B4C,36034AF6,41047A60,DF60EFC3,A867DF55,316E8EEF,4669BE79,CB61B38C,BC66831A,256FD2A0,5268E236,CC0C7795,BB0B4703,220216B9,5505262F,C5BA3BBE,B2BD0B28,2BB45A92,5CB36A04,C2D7FFA7,B5D0CF31,2CD99E8B,5BDEAE1D,9B64C2B0,EC63F226,756AA39C,026D930A,9C0906A9,EB0E363F,72076785,05005713,95BF4A82,E2B87A14,7BB12BAE,0CB61B38,92D28E9B,E5D5BE0D,7CDCEFB7,0BDBDF21,86D3D2D4,F1D4E242,68DDB3F8,1FDA836E,81BE16CD,F6B9265B,6FB077E1,18B74777,88085AE6,FF0F6A70,66063BCA,11010B5C,8F659EFF,F862AE69,616BFFD3,166CCF45,A00AE278,D70DD2EE,4E048354,3903B3C2,A7672661,D06016F7,4969474D,3E6E77DB,AED16A4A,D9D65ADC,40DF0B66,37D83BF0,A9BCAE53,DEBB9EC5,47B2CF7F,30B5FFE9,BDBDF21C,CABAC28A,53B39330,24B4A3A6,BAD03605,CDD70693,54DE5729,23D967BF,B3667A2E,C4614AB8,5D681B02,2A6F2B94,B40BBE37,C30C8EA1,5A05DF1B,2D02EF8D'.split(',').map(s => parseInt(s, 16));\nconst REGISARR = /\\[\\d+\\]|\\[\\]$/;\nconst REGREPLACEARR = /\\[\\]/g;\nconst PROXYBLACKLIST = { 'localhost': 1, '127.0.0.1': 1, '0.0.0.0': 1 };\nconst PROXYOPTIONS = { headers: {}, method: 'CONNECT', agent: false };\nconst PROXYTLS = { headers: {}};\nconst PROXYOPTIONSHTTP = {};\nconst REG_ROOT = /@\\{#\\}(\\/)?/g;\nconst REG_NOREMAP = /@\\{noremap\\}(\\n)?/g;\nconst REG_REMAP = /href=\".*?\"|src=\".*?\"/gi;\nconst REG_AJAX = /('|\")+(!)?(GET|POST|PUT|DELETE|PATCH)\\s(\\(.*?\\)\\s)?\\//g;\nconst REG_URLEXT = /(https|http|wss|ws|file):\\/\\/|\\/\\/[a-z0-9]|[a-z]:/i;\nconst REG_TEXTAPPLICATION = /text|application/i;\nconst REG_TIME = /am|pm/i;\nconst REG_XMLKEY = /\\[|\\]|:|\\.|_/g;\n\nexports.MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nexports.DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\nvar DIACRITICS=[{b:' ',c:'\\u00a0'},{b:'0',c:'\\u07c0'},{b:'A',c:'\\u24b6\\uff21\\u00c0\\u00c1\\u00c2\\u1ea6\\u1ea4\\u1eaa\\u1ea8\\u00c3\\u0100\\u0102\\u1eb0\\u1eae\\u1eb4\\u1eb2\\u0226\\u01e0\\u00c4\\u01de\\u1ea2\\u00c5\\u01fa\\u01cd\\u0200\\u0202\\u1ea0\\u1eac\\u1eb6\\u1e00\\u0104\\u023a\\u2c6f'},{b:'AA',c:'\\ua732'},{b:'AE',c:'\\u00c6\\u01fc\\u01e2'},{b:'AO',c:'\\ua734'},{b:'AU',c:'\\ua736'},{b:'AV',c:'\\ua738\\ua73a'},{b:'AY',c:'\\ua73c'},{b:'B',c:'\\u24b7\\uff22\\u1e02\\u1e04\\u1e06\\u0243\\u0181'},{b:'C',c:'\\u24b8\\uff23\\ua73e\\u1e08\\u0106C\\u0108\\u010a\\u010c\\u00c7\\u0187\\u023b'},{b:'D',c:'\\u24b9\\uff24\\u1e0a\\u010e\\u1e0c\\u1e10\\u1e12\\u1e0e\\u0110\\u018a\\u0189\\u1d05\\ua779'},{b:'Dh',c:'\\u00d0'},{b:'DZ',c:'\\u01f1\\u01c4'},{b:'Dz',c:'\\u01f2\\u01c5'},{b:'E',c:'\\u025b\\u24ba\\uff25\\u00c8\\u00c9\\u00ca\\u1ec0\\u1ebe\\u1ec4\\u1ec2\\u1ebc\\u0112\\u1e14\\u1e16\\u0114\\u0116\\u00cb\\u1eba\\u011a\\u0204\\u0206\\u1eb8\\u1ec6\\u0228\\u1e1c\\u0118\\u1e18\\u1e1a\\u0190\\u018e\\u1d07'},{b:'F',c:'\\ua77c\\u24bb\\uff26\\u1e1e\\u0191\\ua77b'}, {b:'G',c:'\\u24bc\\uff27\\u01f4\\u011c\\u1e20\\u011e\\u0120\\u01e6\\u0122\\u01e4\\u0193\\ua7a0\\ua77d\\ua77e\\u0262'},{b:'H',c:'\\u24bd\\uff28\\u0124\\u1e22\\u1e26\\u021e\\u1e24\\u1e28\\u1e2a\\u0126\\u2c67\\u2c75\\ua78d'},{b:'I',c:'\\u24be\\uff29\\u00cc\\u00cd\\u00ce\\u0128\\u012a\\u012c\\u0130\\u00cf\\u1e2e\\u1ec8\\u01cf\\u0208\\u020a\\u1eca\\u012e\\u1e2c\\u0197'},{b:'J',c:'\\u24bf\\uff2a\\u0134\\u0248\\u0237'},{b:'K',c:'\\u24c0\\uff2b\\u1e30\\u01e8\\u1e32\\u0136\\u1e34\\u0198\\u2c69\\ua740\\ua742\\ua744\\ua7a2'},{b:'L',c:'\\u24c1\\uff2c\\u013f\\u0139\\u013d\\u1e36\\u1e38\\u013b\\u1e3c\\u1e3a\\u0141\\u023d\\u2c62\\u2c60\\ua748\\ua746\\ua780'}, {b:'LJ',c:'\\u01c7'},{b:'Lj',c:'\\u01c8'},{b:'M',c:'\\u24c2\\uff2d\\u1e3e\\u1e40\\u1e42\\u2c6e\\u019c\\u03fb'},{b:'N',c:'\\ua7a4\\u0220\\u24c3\\uff2e\\u01f8\\u0143\\u00d1\\u1e44\\u0147\\u1e46\\u0145\\u1e4a\\u1e48\\u019d\\ua790\\u1d0e'},{b:'NJ',c:'\\u01ca'},{b:'Nj',c:'\\u01cb'},{b:'O',c:'\\u24c4\\uff2f\\u00d2\\u00d3\\u00d4\\u1ed2\\u1ed0\\u1ed6\\u1ed4\\u00d5\\u1e4c\\u022c\\u1e4e\\u014c\\u1e50\\u1e52\\u014e\\u022e\\u0230\\u00d6\\u022a\\u1ece\\u0150\\u01d1\\u020c\\u020e\\u01a0\\u1edc\\u1eda\\u1ee0\\u1ede\\u1ee2\\u1ecc\\u1ed8\\u01ea\\u01ec\\u00d8\\u01fe\\u0186\\u019f\\ua74a\\ua74c'}, {b:'OE',c:'\\u0152'},{b:'OI',c:'\\u01a2'},{b:'OO',c:'\\ua74e'},{b:'OU',c:'\\u0222'},{b:'P',c:'\\u24c5\\uff30\\u1e54\\u1e56\\u01a4\\u2c63\\ua750\\ua752\\ua754'},{b:'Q',c:'\\u24c6\\uff31\\ua756\\ua758\\u024a'},{b:'R',c:'\\u24c7\\uff32\\u0154\\u1e58\\u0158\\u0210\\u0212\\u1e5a\\u1e5c\\u0156\\u1e5e\\u024c\\u2c64\\ua75a\\ua7a6\\ua782'},{b:'S',c:'\\u24c8\\uff33\\u1e9e\\u015a\\u1e64\\u015c\\u1e60\\u0160\\u1e66\\u1e62\\u1e68\\u0218\\u015e\\u2c7e\\ua7a8\\ua784'},{b:'T',c:'\\u24c9\\uff34\\u1e6a\\u0164\\u1e6c\\u021a\\u0162\\u1e70\\u1e6e\\u0166\\u01ac\\u01ae\\u023e\\ua786'}, {b:'Th',c:'\\u00de'},{b:'TZ',c:'\\ua728'},{b:'U',c:'\\u24ca\\uff35\\u00d9\\u00da\\u00db\\u0168\\u1e78\\u016a\\u1e7a\\u016c\\u00dc\\u01db\\u01d7\\u01d5\\u01d9\\u1ee6\\u016e\\u0170\\u01d3\\u0214\\u0216\\u01af\\u1eea\\u1ee8\\u1eee\\u1eec\\u1ef0\\u1ee4\\u1e72\\u0172\\u1e76\\u1e74\\u0244'},{b:'V',c:'\\u24cb\\uff36\\u1e7c\\u1e7e\\u01b2\\ua75e\\u0245'},{b:'VY',c:'\\ua760'},{b:'W',c:'\\u24cc\\uff37\\u1e80\\u1e82\\u0174\\u1e86\\u1e84\\u1e88\\u2c72'},{b:'X',c:'\\u24cd\\uff38\\u1e8a\\u1e8c'},{b:'Y',c:'\\u24ce\\uff39\\u1ef2\\u00dd\\u0176\\u1ef8\\u0232\\u1e8e\\u0178\\u1ef6\\u1ef4\\u01b3\\u024e\\u1efe'}, {b:'Z',c:'\\u24cf\\uff3a\\u0179\\u1e90\\u017b\\u017d\\u1e92\\u1e94\\u01b5\\u0224\\u2c7f\\u2c6b\\ua762'},{b:'a',c:'\\u24d0\\uff41\\u1e9a\\u00e0\\u00e1\\u00e2\\u1ea7\\u1ea5\\u1eab\\u1ea9\\u00e3\\u0101\\u0103\\u1eb1\\u1eaf\\u1eb5\\u1eb3\\u0227\\u01e1\\u00e4\\u01df\\u1ea3\\u00e5\\u01fb\\u01ce\\u0201\\u0203\\u1ea1\\u1ead\\u1eb7\\u1e01\\u0105\\u2c65\\u0250\\u0251'},{b:'aa',c:'\\ua733'},{b:'ae',c:'\\u00e6\\u01fd\\u01e3'},{b:'ao',c:'\\ua735'},{b:'au',c:'\\ua737'},{b:'av',c:'\\ua739\\ua73b'},{b:'ay',c:'\\ua73d'}, {b:'b',c:'\\u24d1\\uff42\\u1e03\\u1e05\\u1e07\\u0180\\u0183\\u0253\\u0182'},{b:'c',c:'\\uff43\\u24d2\\u0107\\u0109\\u010b\\u010d\\u00e7\\u1e09\\u0188\\u023c\\ua73f\\u2184'},{b:'d',c:'\\u24d3\\uff44\\u1e0b\\u010f\\u1e0d\\u1e11\\u1e13\\u1e0f\\u0111\\u018c\\u0256\\u0257\\u018b\\u13e7\\u0501\\ua7aa'},{b:'dh',c:'\\u00f0'},{b:'dz',c:'\\u01f3\\u01c6'},{b:'e',c:'\\u24d4\\uff45\\u00e8\\u00e9\\u00ea\\u1ec1\\u1ebf\\u1ec5\\u1ec3\\u1ebd\\u0113\\u1e15\\u1e17\\u0115\\u0117\\u00eb\\u1ebb\\u011b\\u0205\\u0207\\u1eb9\\u1ec7\\u0229\\u1e1d\\u0119\\u1e19\\u1e1b\\u0247\\u01dd'}, {b:'f',c:'\\u24d5\\uff46\\u1e1f\\u0192'},{b:'ff',c:'\\ufb00'},{b:'fi',c:'\\ufb01'},{b:'fl',c:'\\ufb02'},{b:'ffi',c:'\\ufb03'},{b:'ffl',c:'\\ufb04'},{b:'g',c:'\\u24d6\\uff47\\u01f5\\u011d\\u1e21\\u011f\\u0121\\u01e7\\u0123\\u01e5\\u0260\\ua7a1\\ua77f\\u1d79'},{b:'h',c:'\\u24d7\\uff48\\u0125\\u1e23\\u1e27\\u021f\\u1e25\\u1e29\\u1e2b\\u1e96\\u0127\\u2c68\\u2c76\\u0265'},{b:'hv',c:'\\u0195'},{b:'i',c:'\\u24d8\\uff49\\u00ec\\u00ed\\u00ee\\u0129\\u012b\\u012d\\u00ef\\u1e2f\\u1ec9\\u01d0\\u0209\\u020b\\u1ecb\\u012f\\u1e2d\\u0268\\u0131'}, {b:'j',c:'\\u24d9\\uff4a\\u0135\\u01f0\\u0249'},{b:'k',c:'\\u24da\\uff4b\\u1e31\\u01e9\\u1e33\\u0137\\u1e35\\u0199\\u2c6a\\ua741\\ua743\\ua745\\ua7a3'},{b:'l',c:'\\u24db\\uff4c\\u0140\\u013a\\u013e\\u1e37\\u1e39\\u013c\\u1e3d\\u1e3b\\u017f\\u0142\\u019a\\u026b\\u2c61\\ua749\\ua781\\ua747\\u026d'},{b:'lj',c:'\\u01c9'},{b:'m',c:'\\u24dc\\uff4d\\u1e3f\\u1e41\\u1e43\\u0271\\u026f'},{b:'n',c:'\\u24dd\\uff4e\\u01f9\\u0144\\u00f1\\u1e45\\u0148\\u1e47\\u0146\\u1e4b\\u1e49\\u019e\\u0272\\u0149\\ua791\\ua7a5\\u043b\\u0509'},{b:'nj', c:'\\u01cc'},{b:'o',c:'\\u24de\\uff4f\\u00f2\\u00f3\\u00f4\\u1ed3\\u1ed1\\u1ed7\\u1ed5\\u00f5\\u1e4d\\u022d\\u1e4f\\u014d\\u1e51\\u1e53\\u014f\\u022f\\u0231\\u00f6\\u022b\\u1ecf\\u0151\\u01d2\\u020d\\u020f\\u01a1\\u1edd\\u1edb\\u1ee1\\u1edf\\u1ee3\\u1ecd\\u1ed9\\u01eb\\u01ed\\u00f8\\u01ff\\ua74b\\ua74d\\u0275\\u0254\\u1d11'},{b:'oe',c:'\\u0153'},{b:'oi',c:'\\u01a3'},{b:'oo',c:'\\ua74f'},{b:'ou',c:'\\u0223'},{b:'p',c:'\\u24df\\uff50\\u1e55\\u1e57\\u01a5\\u1d7d\\ua751\\ua753\\ua755\\u03c1'},{b:'q',c:'\\u24e0\\uff51\\u024b\\ua757\\ua759'}, {b:'r',c:'\\u24e1\\uff52\\u0155\\u1e59\\u0159\\u0211\\u0213\\u1e5b\\u1e5d\\u0157\\u1e5f\\u024d\\u027d\\ua75b\\ua7a7\\ua783'},{b:'s',c:'\\u24e2\\uff53\\u015b\\u1e65\\u015d\\u1e61\\u0161\\u1e67\\u1e63\\u1e69\\u0219\\u015f\\u023f\\ua7a9\\ua785\\u1e9b\\u0282'},{b:'ss',c:'\\u00df'},{b:'t',c:'\\u24e3\\uff54\\u1e6b\\u1e97\\u0165\\u1e6d\\u021b\\u0163\\u1e71\\u1e6f\\u0167\\u01ad\\u0288\\u2c66\\ua787'},{b:'th',c:'\\u00fe'},{b:'tz',c:'\\ua729'},{b:'u',c:'\\u24e4\\uff55\\u00f9\\u00fa\\u00fb\\u0169\\u1e79\\u016b\\u1e7b\\u016d\\u00fc\\u01dc\\u01d8\\u01d6\\u01da\\u1ee7\\u016f\\u0171\\u01d4\\u0215\\u0217\\u01b0\\u1eeb\\u1ee9\\u1eef\\u1eed\\u1ef1\\u1ee5\\u1e73\\u0173\\u1e77\\u1e75\\u0289'}, {b:'v',c:'\\u24e5\\uff56\\u1e7d\\u1e7f\\u028b\\ua75f\\u028c'},{b:'vy',c:'\\ua761'},{b:'w',c:'\\u24e6\\uff57\\u1e81\\u1e83\\u0175\\u1e87\\u1e85\\u1e98\\u1e89\\u2c73'},{b:'x',c:'\\u24e7\\uff58\\u1e8b\\u1e8d'},{b:'y',c:'\\u24e8\\uff59\\u1ef3\\u00fd\\u0177\\u1ef9\\u0233\\u1e8f\\u00ff\\u1ef7\\u1e99\\u1ef5\\u01b4\\u024f\\u1eff'},{b:'z',c:'\\u24e9\\uff5a\\u017a\\u1e91\\u017c\\u017e\\u1e93\\u1e95\\u01b6\\u0225\\u0240\\u2c6c\\ua763'}];\n\nfor (var i=0; i <DIACRITICS.length; i+=1)\n\tfor (var chars=DIACRITICS[i].c,j=0;j<chars.length;j+=1)\n\t\tDIACRITICSMAP[chars[j]]=DIACRITICS[i].b;\n\nconst DP = Date.prototype;\nconst SP = String.prototype;\nconst NP = Number.prototype;\n\nDIACRITICS = null;\n\nvar CONTENTTYPES = {\n\taac: 'audio/aac',\n\tai: 'application/postscript',\n\tappcache: 'text/cache-manifest',\n\tavi: 'video/avi',\n\tbin: 'application/octet-stream',\n\tbmp: 'image/bmp',\n\tcoffee: 'text/coffeescript',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdocx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\tdtd: 'application/xml-dtd',\n\teps: 'application/postscript',\n\texe: 'application/octet-stream',\n\tflac: 'audio/x-flac',\n\tgeojson: 'application/json',\n\tgif: 'image/gif',\n\tgzip: 'application/x-gzip',\n\theic: 'image/heic',\n\theif: 'image/heif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tifb: 'text/calendar',\n\tjpe: 'image/jpeg',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'text/javascript',\n\tjson: 'application/json',\n\tjsx: 'text/jsx',\n\tless: 'text/css',\n\tm4a: 'audio/mp4a-latm',\n\tm4v: 'video/x-m4v',\n\tmanifest: 'text/cache-manifest',\n\tmd: 'text/x-markdown',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmjs: 'text/javascript',\n\tmov: 'video/quicktime',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpg: 'video/mpeg',\n\tmpga: 'audio/mpeg',\n\tmtl: 'text/plain',\n\tmv4: 'video/mv4',\n\tobj: 'text/plain',\n\togg: 'application/ogg',\n\togv: 'video/ogg',\n\tpackage: 'text/plain',\n\tpdf: 'application/pdf',\n\tpng: 'image/png',\n\tppt: 'application/vnd.ms-powerpoint',\n\tpptx: 'application/vnd.ms-powerpoint',\n\tps: 'application/postscript',\n\trar: 'application/x-rar-compressed',\n\trtf: 'text/rtf',\n\tsass: 'text/css',\n\tscss: 'text/css',\n\tsh: 'application/x-sh',\n\tstl: 'application/sla',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\ttxt: 'text/plain',\n\tsql: 'text/plain',\n\twav: 'audio/x-wav',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'application/font-woff',\n\twoff2: 'application/font-woff2',\n\txht: 'application/xhtml+xml',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txpm: 'image/x-xpixmap',\n\txsl: 'application/xml',\n\txslt: 'application/xslt+xml',\n\tzip: 'application/zip'\n};\n\nvar dnscache = {};\nvar datetimeformat = {};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nglobal.DIFFARR = exports.diffarr = function(prop, db, form) {\n\n\tvar an = [];\n\tvar au = [];\n\tvar ar = [];\n\tvar is, oa, ob;\n\n\tfor (var i = 0; i < db.length; i++) {\n\t\toa = db[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < form.length; j++) {\n\t\t\tob = form[j];\n\t\t\tif (oa[prop] == ob[prop]) {\n\t\t\t\tau.push({ db: oa, form: ob });\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tar.push(oa[prop]);\n\t}\n\n\tfor (var i = 0; i < form.length; i++) {\n\t\tob = form[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < db.length; j++) {\n\t\t\toa = db[j];\n\t\t\tif (ob[prop] == oa[prop]) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tan.push(ob);\n\t}\n\n\tvar obj = {};\n\tobj.add = an;\n\tobj.upd = au;\n\tobj.rem = ar;\n\treturn obj;\n};\n\n/**\n * Checks if is object empty\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isEmpty = function(obj) {\n\n\tif (!obj || obj instanceof Array)\n\t\treturn true;\n\n\tfor (var key in obj) {\n\t\tif (hasOwnProperty.call(obj, key))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Compare objects\n * @param {Object} obj1\n * @param {Object} obj2\n * @return {Boolean}\n */\nexports.isEqual = function(obj1, obj2, properties) {\n\n\tvar keys = properties ? properties : Object.keys(obj1);\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tvar a = obj1[key];\n\t\tvar b = obj2[key];\n\t\tvar ta = typeof(a);\n\t\tvar tb = typeof(b);\n\n\t\tif (ta !== tb)\n\t\t\treturn false;\n\n\t\tif (a === b)\n\t\t\tcontinue;\n\n\t\tif (a instanceof Date && b instanceof Date) {\n\t\t\tif (a.getTime() === b.getTime())\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t} else if (a instanceof Array && b instanceof Array) {\n\t\t\tif (JSON.stringify(a) === JSON.stringify(b))\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (ta === 'object' && tb === 'object') {\n\t\t\tif (exports.isEqual(a, b))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Function checks a valid function and waits for it positive result\n * @param {Function} fnValid\n * @param {Function(err, success)} fnCallback\n * @param {Number} timeout  Timeout, optional (default: 5000)\n * @param {Number} interval Refresh interval, optional (default: 500)\n */\nexports.wait = function(fnValid, fnCallback, timeout, interval) {\n\n\tif (fnValid() === true)\n\t\treturn fnCallback(null, true);\n\n\tvar id_timeout = null;\n\tvar id_interval = setInterval(function() {\n\n\t\tif (fnValid() === true) {\n\t\t\tclearInterval(id_interval);\n\t\t\tclearTimeout(id_timeout);\n\t\t\tfnCallback && fnCallback(null, true);\n\t\t}\n\n\t}, interval || 500);\n\n\tid_timeout = setTimeout(function() {\n\t\tclearInterval(id_interval);\n\t\tfnCallback && fnCallback(new Error('Timeout.'), false);\n\t}, timeout || 5000);\n};\n\nexports.$$wait = function(fnValid, timeout, interval) {\n\treturn function(callback) {\n\t\texports.wait(fnValid, callback, timeout, interval);\n\t};\n};\n\n/**\n * Resolves an IP from the URL address\n * @param {String} url\n * @param {Function(err, uri)} callback\n */\nexports.resolve = function(url, callback, param) {\n\n\tvar uri = Url.parse(url);\n\n\n\tif (!callback)\n\t\treturn dnscache[uri.host];\n\n\tif (dnscache[uri.host]) {\n\t\turi.host = dnscache[uri.host];\n\t\tcallback(null, uri, param);\n\t\treturn;\n\t}\n\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (e)\n\t\t\tsetImmediate(dnsresolve_callback, uri, callback, param);\n\t\telse {\n\t\t\tdnscache[uri.host] = addresses[0];\n\t\t\turi.host = addresses[0];\n\t\t\tcallback(null, uri, param);\n\t\t}\n\t});\n};\n\nfunction dnsresolve_callback(uri, callback, param) {\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (addresses && addresses.length) {\n\t\t\tdnscache[uri.host] = addresses[0];\n\t\t\turi.host = addresses[0];\n\t\t}\n\t\tcallback(e, uri, param);\n\t});\n}\n\nexports.$$resolve = function(url) {\n\treturn function(callback) {\n\t\treturn exports.resolve(url, callback);\n\t};\n};\n\n/**\n * Clears DNS cache\n */\nexports.clearDNS = function() {\n\tOBSOLETE('U.clearDNS()', 'Use CMD(\\'clear_dnscache\\')');\n\tCMD('clear_dnscache');\n};\n\nsetImmediate(function() {\n\tif (global.F) {\n\t\tF.install('command', 'clear_dnscache', function() {\n\t\t\tdnscache = {};\n\t\t});\n\t}\n});\n\n\nexports.keywords = function(content, forSearch, alternative, max_count, max_length, min_length) {\n\n\tif (forSearch === undefined)\n\t\tforSearch = true;\n\n\tmin_length = min_length || 2;\n\tmax_count = max_count || 200;\n\tmax_length = max_length || 20;\n\n\tvar words = [];\n\tvar isSoundex = alternative === 'soundex';\n\n\tif (content instanceof Array) {\n\t\tfor (var i = 0, length = content.length; i < length; i++) {\n\t\t\tif (!content[i])\n\t\t\t\tcontinue;\n\t\t\tvar tmp = (forSearch ? content[i].removeDiacritics().toLowerCase().replace(regexpY, 'i') : content[i].toLowerCase()).replace(regexpN, ' ').split(' ');\n\t\t\tif (!tmp || !tmp.length)\n\t\t\t\tcontinue;\n\t\t\tfor (var j = 0, jl = tmp.length; j < jl; j++)\n\t\t\t\twords.push(tmp[j]);\n\t\t}\n\t} else\n\t\twords = (forSearch ? content.removeDiacritics().toLowerCase().replace(regexpY, 'i') : content.toLowerCase()).replace(regexpN, ' ').split(' ');\n\n\tif (!words)\n\t\twords = [];\n\n\tvar dic = {};\n\tvar counter = 0;\n\n\tfor (var i = 0, length = words.length; i < length; i++) {\n\n\t\tvar word = words[i].trim().replace(regexpCHARS, keywordscleaner);\n\n\t\tif (regexpCHINA.test(word)) {\n\n\t\t\tvar tmpw = word.split('', max_count);\n\n\t\t\tfor (var j = 0; j < tmpw.length; j++) {\n\t\t\t\tword = tmpw[j];\n\t\t\t\tif (dic[word])\n\t\t\t\t\tdic[word]++;\n\t\t\t\telse\n\t\t\t\t\tdic[word] = 1;\n\t\t\t\tcounter++;\n\t\t\t}\n\n\t\t\tif (counter >= max_count)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (word.length < min_length)\n\t\t\tcontinue;\n\n\t\tif (counter >= max_count)\n\t\t\tbreak;\n\n\t\t// Gets 80% length of word\n\t\tif (alternative) {\n\t\t\tif (isSoundex)\n\t\t\t\tword = word.soundex();\n\t\t\telse {\n\t\t\t\tvar size = (word.length / 100) * 80;\n\t\t\t\tif (size > min_length + 1)\n\t\t\t\t\tword = word.substring(0, size);\n\t\t\t}\n\t\t}\n\n\t\tif (word.length < min_length || word.length > max_length)\n\t\t\tcontinue;\n\n\t\tif (dic[word])\n\t\t\tdic[word]++;\n\t\telse\n\t\t\tdic[word] = 1;\n\n\t\tcounter++;\n\t}\n\n\tvar keys = Object.keys(dic);\n\n\tkeys.sort(function(a, b) {\n\t\tvar countA = dic[a];\n\t\tvar countB = dic[b];\n\t\treturn countA > countB ? -1 : countA < countB ? 1 : 0;\n\t});\n\n\treturn keys;\n};\n\nfunction keywordscleaner(c) {\n\treturn c.charCodeAt(0) < 200 ? '' : c;\n}\n\nfunction parseProxy(p) {\n\tvar key = 'proxy_' + p;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (p.indexOf('://') === -1)\n\t\tp = 'http://' + p;\n\n\tvar obj = Url.parse(p);\n\n\tif (obj.auth)\n\t\tobj._auth = 'Basic ' + Buffer.from(obj.auth).toString('base64');\n\n\tobj.port = +obj.port;\n\treturn F.temporary.other[key] = obj;\n}\n\n/**\n * Create a request to a specific URL\n * @param  {String} url URL address.\n * @param  {String Array} flags Request flags.\n * @param  {String or Object} data Request data (optional).\n * @param  {Function(error, content, statusCode, headers)} callback Callback.\n * @param  {Object} headers Custom cookies (optional, default: null).\n * @param  {Object} headers Custom headers (optional, default: null).\n * @param  {String} encoding Encoding (optional, default: UTF8)\n * @param  {Number} timeout Request timeout.\n * return {Boolean}\n */\n\nconst NOBODY = { GET: 1, OPTIONS: 1, HEAD: 1 };\n\nglobal.REQUEST = exports.request = function(url, flags, data, callback, cookies, headers, encoding, timeout, files, param) {\n\n\t// No data (data is optional argument)\n\tif (typeof(data) === 'function') {\n\t\tencoding = headers;\n\t\theaders = cookies;\n\t\tcookies = callback;\n\t\tcallback = data;\n\t\tdata = '';\n\t} else if (!data)\n\t\tdata = '';\n\n\tif (callback === NOOP)\n\t\tcallback = null;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tvar options = { length: 0, timeout: timeout || CONF.default_restbuilder_timeout, evt: new EventEmitter2(), encoding: typeof(encoding) !== 'string' ? ENCODING : encoding, callback: callback, post: false, redirect: 0 };\n\tvar method;\n\tvar type = 0;\n\tvar isCookies = false;\n\tvar def;\n\tvar proxy;\n\n\tif (headers) {\n\t\theaders = exports.extend({}, headers);\n\t\tdef = headers[CT];\n\t} else\n\t\theaders = {};\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\n\t\t\t// timeout\n\t\t\tif (flags[i] > 0) {\n\t\t\t\toptions.timeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === '<') {\n\t\t\t\toptions.max = flags[i].substring(1).trim().parseInt() * 1024; // kB\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === 'p' && flags[i][4] === 'y') {\n\t\t\t\tproxy = parseProxy(flags[i].substring(6));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flags[i].toLowerCase()) {\n\t\t\t\tcase 'utf8':\n\t\t\t\tcase 'ascii':\n\t\t\t\tcase 'base64':\n\t\t\t\tcase 'binary':\n\t\t\t\tcase 'hex':\n\t\t\t\t\toptions.encoding = flags[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xhr':\n\t\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'plain':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/plain';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/html';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'raw':\n\t\t\t\t\ttype = 3;\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'application/octet-stream';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'json':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'application/json';\n\t\t\t\t\t!method && (method = 'POST');\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xml':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/xml';\n\t\t\t\t\t!method && (method = 'POST');\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'head':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'noredirect':\n\t\t\t\t\toptions.noredirect = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'upload':\n\t\t\t\t\ttype = 4;\n\t\t\t\t\toptions.upload = true;\n\t\t\t\t\toptions.files = files || EMPTYARRAY;\n\t\t\t\t\toptions.boundary = '----totaljs' + Math.random().toString(16).substring(2);\n\t\t\t\t\theaders[CT] = 'multipart/form-data; boundary=' + options.boundary;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'patch':\n\t\t\t\t\tmethod = flags[i].toUpperCase();\n\t\t\t\t\t!def && !headers[CT] && (headers[CT] = 'application/x-www-form-urlencoded');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dnscache':\n\t\t\t\t\toptions.resolve = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'keepalive':\n\t\t\t\t\toptions.keepalive = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cookies':\n\t\t\t\t\tisCookies = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Fallback for methods (e.g. CalDAV)\n\t\t\t\t\tif (!method)\n\t\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (method)\n\t\toptions.post = !NOBODY[method];\n\telse\n\t\tmethod = 'GET';\n\n\tif (type < 3) {\n\n\t\tif (typeof(data) !== 'string')\n\t\t\tdata = type === 1 ? JSON.stringify(data) : Qs.stringify(data);\n\t\telse if (data[0] === '?')\n\t\t\tdata = data.substring(1);\n\n\t\tif (!options.post) {\n\t\t\tif (data.length) {\n\t\t\t\tif (url.indexOf('?') === -1)\n\t\t\t\t\turl += '?' + data;\n\t\t\t\telse\n\t\t\t\t\turl += '&' + data;\n\t\t\t}\n\t\t\tdata = '';\n\t\t}\n\n\t\t// \"null\" or \"empty string\" is valid JSON value too\n\t\tif (type === 1 && (data === EMPTYOBJECT || data === undefined) && options.post)\n\t\t\tdata = BUFEMPTYJSON;\n\t}\n\n\tif (data && type !== 4) {\n\t\toptions.data = data instanceof Buffer ? data : Buffer.from(data, ENCODING);\n\t\theaders['Content-Length'] = options.data.length;\n\t} else\n\t\toptions.data = data;\n\n\tif (cookies) {\n\t\tif (isCookies)\n\t\t\toptions.cookies = cookies;\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\theaders['Cookie'] = builder;\n\t}\n\n\tvar uri = Url.parse(url);\n\n\tif (!uri.hostname || !uri.host) {\n\t\tcallback && callback(new Error('URL doesn\\'t contain a hostname'), '', 0);\n\t\treturn;\n\t}\n\n\turi.method = method;\n\turi.headers = headers;\n\toptions.uri = uri;\n\n\tif (options.resolve && (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64))\n\t\toptions.resolve = null;\n\n\tif (CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\tif (proxy && (uri.hostname === 'localhost' || uri.hostname === '127.0.0.1'))\n\t\tproxy = null;\n\n\toptions.proxy = proxy;\n\toptions.param = param;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy && uri.protocol !== 'https:')\n\t\turi.agent = KeepAlive;\n\n\tif (proxy)\n\t\trequest_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(url, request_resolve, options);\n\telse\n\t\trequest_call(uri, options);\n\n\treturn options.evt;\n};\n\nfunction request_resolve(err, uri, options) {\n\tif (!err)\n\t\toptions.uri.host = uri.host;\n\trequest_call(options.uri, options);\n}\n\nfunction ProxyAgent(options) {\n\tvar self = this;\n\tself.options = options;\n\tself.maxSockets = Http.Agent.defaultMaxSockets;\n\tself.requests = [];\n}\n\nconst PAP = ProxyAgent.prototype;\n\nPAP.createConnection = function(pending) {\n\tvar self = this;\n\tself.createSocket(pending, function(socket) {\n\t\tpending.request.onSocket(socket);\n\t});\n};\n\nPAP.createSocket = function(options, callback) {\n\n\tvar self = this;\n\tvar proxy = self.options.proxy;\n\tvar uri = self.options.uri;\n\n\tPROXYOPTIONS.host = proxy.hostname;\n\tPROXYOPTIONS.port = proxy.port;\n\tPROXYOPTIONS.path = PROXYOPTIONS.headers.host = uri.hostname + ':' + (uri.port || '443');\n\n\tif (proxy._auth)\n\t\tPROXYOPTIONS.headers['Proxy-Authorization'] = proxy._auth;\n\n\tvar req = self.request(PROXYOPTIONS);\n\treq.setTimeout(10000);\n\treq.on('response', proxyagent_response);\n\treq.on('connect', function(res, socket) {\n\n\t\tif (res.statusCode === 200) {\n\t\t\tsocket.$req = req;\n\t\t\tcallback(socket);\n\t\t} else {\n\t\t\tvar err = new Error('Proxy could not be established (maybe a problem in auth), code: ' + res.statusCode);\n\t\t\terr.code = 'ECONNRESET';\n\t\t\toptions.request.emit('error', err);\n\t\t\treq.destroy && req.destroy();\n\t\t\treq = null;\n\t\t\tself.requests = null;\n\t\t\tself.options = null;\n\t\t}\n\t});\n\n\treq.on('error', function(err) {\n\t\tvar e = new Error('Request Proxy \"proxy {0} --> target {1}\": {2}'.format(PROXYOPTIONS.host + ':' + proxy.port, PROXYOPTIONS.path, err.toString()));\n\t\te.code = err.code;\n\t\toptions.request.emit('error', e);\n\t\treq.destroy && req.destroy();\n\t\treq = null;\n\t\tself.requests = null;\n\t\tself.options = null;\n\t});\n\n\treq.end();\n};\n\nfunction proxyagent_response(res) {\n\tres.upgrade = true;\n}\n\nPAP.addRequest = function(req, options) {\n\tthis.createConnection({ host: options.host, port: options.port, request: req });\n};\n\nfunction createSecureSocket(options, callback) {\n\tvar self = this;\n\tPAP.createSocket.call(self, options, function(socket) {\n\t\tPROXYTLS.servername = self.options.uri.hostname;\n\t\tPROXYTLS.headers = self.options.uri.headers;\n\t\tPROXYTLS.socket = socket;\n\t\tvar tls = Tls.connect(0, PROXYTLS);\n\t\tcallback(tls);\n\t});\n}\n\nfunction request_call(uri, options) {\n\n\tvar opt;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\topt.headers.host = uri.host;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = options.post ? connection.request(opt, request_response) : connection.get(opt, request_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', request_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(request_process_timeout, options.timeout, req);\n\n\t// req.on('response', (response) => response.req = req);\n\treq.on('response', request_assign_res);\n\n\tif (options.upload) {\n\t\toptions.first = true;\n\t\toptions.files.wait(function(file, next) {\n\t\t\trequest_writefile(req, options, file, next);\n\t\t}, function() {\n\t\t\tvar keys = Object.keys(options.data);\n\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tvar value = options.data[keys[i]];\n\t\t\t\tif (value != null) {\n\t\t\t\t\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + keys[i] + '\"' + NEWLINE + NEWLINE + value.toString());\n\t\t\t\t\tif (options.first)\n\t\t\t\t\t\toptions.first = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treq.end(NEWLINE + '--' + options.boundary + '--');\n\t\t});\n\t} else\n\t\treq.end(options.data);\n}\n\nfunction request_process_error(err) {\n\tvar options = this.$options;\n\tif (options.callback && !options.done) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\toptions.canceled = true;\n\t\toptions.callback(err, '', 0, undefined, this.$uri.host, EMPTYOBJECT, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n}\n\nfunction request_process_timeout(req) {\n\tvar options = req.$options;\n\tif (options.callback) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\treq.socket.destroy();\n\t\treq.socket.end();\n\t\treq.abort();\n\t\toptions.canceled = true;\n\t\toptions.callback(new Error(exports.httpStatus(408)), '', 0, undefined, req.$uri.host, EMPTYOBJECT, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n}\n\nfunction request_assign_res(response) {\n\tresponse.req = this;\n}\n\nfunction request_writefile(req, options, file, next) {\n\n\tvar type = typeof(file.buffer);\n\tvar filename = (type === 'string' ? file.buffer : exports.getName(file.filename));\n\n\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + file.name + '\"; filename=\"' + filename + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(filename)) + NEWLINE + NEWLINE);\n\n\tif (options.first)\n\t\toptions.first = false;\n\n\t// Is Buffer\n\tif (file.buffer && type === 'object') {\n\t\treq.write(file.buffer);\n\t\tnext();\n\t} else {\n\t\tvar stream = Fs.createReadStream(file.filename);\n\t\tstream.once('close', next);\n\t\tstream.pipe(req, STREAMPIPE);\n\t}\n}\n\nfunction request_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._buffer = null;\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.noredirect) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\n\t\t\tif (options.callback) {\n\t\t\t\toptions.callback(null, '', res.statusCode, res.headers, uri.host, EMPTYOBJECT, options.param);\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tif (options.evt) {\n\t\t\t\toptions.evt.removeAllListeners();\n\t\t\t\toptions.evt = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.redirect > 3) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\n\t\t\tif (options.callback) {\n\t\t\t\toptions.callback(new Error('Too many redirects.'), '', 0, undefined, uri.host, EMPTYOBJECT, options.param);\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tif (options.evt) {\n\t\t\t\toptions.evt.removeAllListeners();\n\t\t\t\toptions.evt = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers['location'];\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.proxy.tls = true;\n\t\t\toptions.uri = tmp;\n\t\t\toptions.uri.agent = new ProxyAgent(options);\n\t\t\toptions.uri.agent.request = Http.request;\n\t\t\toptions.uri.agent.createSocket = createSecureSocket;\n\t\t\toptions.uri.agent.defaultPort = 443;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn request_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(tmp, function(err, u) {\n\t\t\tif (!err)\n\t\t\t\ttmp.host = u.host;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\trequest_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\toptions.length = +res.headers['content-length'] || 0;\n\toptions.evt && options.evt.$events.begin && options.evt.emit('begin', options.length);\n\n\t// Shared cookies\n\tif (options.cookies) {\n\t\tvar arr = (res.headers['set-cookie'] || '');\n\n\t\t// Only the one value\n\t\tif (arr && !(arr instanceof Array))\n\t\t\tarr = [arr];\n\n\t\tif (arr instanceof Array) {\n\t\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\t\tvar line = arr[i];\n\t\t\t\tvar end = line.indexOf(';');\n\t\t\t\tif (end === -1)\n\t\t\t\t\tend = line.length;\n\t\t\t\tline = line.substring(0, end);\n\t\t\t\tvar index = line.indexOf('=');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\toptions.cookies[line.substring(0, index)] = decodeURIComponent(line.substring(index + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res.statusCode === 204) {\n\t\toptions.done = true;\n\t\trequest_process_end.call(res);\n\t\treturn;\n\t}\n\n\tvar encoding = res.headers['content-encoding'] || '';\n\tif (encoding)\n\t\tencoding = encoding.split(',')[0];\n\n\tif (COMPRESS[encoding]) {\n\t\tvar zlib = encoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate();\n\t\tzlib._buffer = res.buffer;\n\t\tzlib.headers = res.headers;\n\t\tzlib.statusCode = res.statusCode;\n\t\tzlib.res = res;\n\t\tzlib.on('data', request_process_data);\n\t\tzlib.on('end', request_process_end);\n\t\tres.pipe(zlib);\n\t} else {\n\t\tres.on('data', request_process_data);\n\t\tres.on('end', request_process_end);\n\t}\n\n\tres.resume();\n}\n\nfunction request_process_data(chunk) {\n\tvar self = this;\n\n\t// Is Zlib\n\tif (!self.req)\n\t\tself = self.res;\n\n\tvar options = self.req.$options;\n\tif (options.canceled || (options.max && self._bufferlength > options.max))\n\t\treturn;\n\tif (self._buffer) {\n\t\tCONCAT[0] = self._buffer;\n\t\tCONCAT[1] = chunk;\n\t\tself._buffer = Buffer.concat(CONCAT);\n\t} else\n\t\tself._buffer = chunk;\n\tself._bufferlength += chunk.length;\n\toptions.evt && options.evt.$events.data && options.evt.emit('data', chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n}\n\nfunction request_process_end() {\n\n\tvar res = this;\n\n\t// Is Zlib\n\tif (!res.req)\n\t\tres = res.res;\n\n\tvar self = res;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\tvar data;\n\n\toptions.socket && options.uri.agent.destroy();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\n\tif (options.canceled)\n\t\treturn;\n\n\tvar ct = self.headers['content-type'];\n\n\tif (!ct || REG_TEXTAPPLICATION.test(ct))\n\t\tdata = self._buffer ? (options.encoding === 'binary' ? self._buffer : self._buffer.toString(options.encoding)) : '';\n\telse\n\t\tdata = self._buffer;\n\n\toptions.canceled = true;\n\n\tself._buffer = undefined;\n\n\tif (options.evt) {\n\t\toptions.evt.$events.end && options.evt.emit('end', data, self.statusCode, self.headers, uri.host, options.cookies, options.param);\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n\n\tif (options.callback) {\n\t\toptions.callback(null, uri.method === 'HEAD' ? self.headers : data, self.statusCode, self.headers, uri.host, options.cookies, options.param);\n\t\toptions.callback = null;\n\t}\n\n\tif (res.statusCode !== 204) {\n\t\tres.req && res.req.removeAllListeners();\n\t\tres.removeAllListeners();\n\t}\n}\n\nexports.$$request = function(url, flags, data, cookies, headers, encoding, timeout) {\n\treturn function(callback) {\n\t\texports.request(url, flags, data, callback, cookies, headers, encoding, timeout);\n\t};\n};\n\nexports.btoa = function(str) {\n\treturn (str instanceof Buffer) ? str.toString('base64') : Buffer.from(str.toString(), 'utf8').toString('base64');\n};\n\nexports.atob = function(str) {\n\treturn Buffer.from(str, 'base64').toString('utf8');\n};\n\n/**\n * Create a request to a specific URL\n * @param {String} url URL address.\n * @param {String Array} flags Request flags.\n * @param {String or Object} data Request data (optional).\n * @param {Function(error, response)} callback Callback.\n * @param {Object} cookies Custom cookies (optional, default: null).\n * @param {Object} headers Custom headers (optional, default: null).\n * @param {String} encoding Encoding (optional, default: UTF8)\n * @param {Number} timeout Request timeout.\n * return {Boolean}\n */\nexports.download = function(url, flags, data, callback, cookies, headers, encoding, timeout, param) {\n\n\t// No data (data is optional argument)\n\tif (typeof(data) === 'function') {\n\t\ttimeout = encoding;\n\t\tencoding = headers;\n\t\theaders = cookies;\n\t\tcookies = callback;\n\t\tcallback = data;\n\t\tdata = '';\n\t}\n\n\tif (typeof(cookies) === 'number') {\n\t\tcookies = null;\n\t\ttimeout = cookies;\n\t}\n\n\tif (typeof(headers) === 'number') {\n\t\theaders = null;\n\t\ttimeout = headers;\n\t}\n\n\tif (typeof(encoding) === 'number') {\n\t\tencoding = null;\n\t\ttimeout = encoding;\n\t}\n\n\tif (typeof(encoding) !== 'string')\n\t\tencoding = ENCODING;\n\n\tvar proxy, type = 0;\n\tvar method = 'GET';\n\tvar options = { callback: callback, resolve: false, length: 0, evt: new EventEmitter2(), timeout: timeout || 60000, post: false, encoding: encoding };\n\n\tif (headers)\n\t\theaders = exports.extend({}, headers);\n\telse\n\t\theaders = {};\n\n\tif (data === null)\n\t\tdata = '';\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\n\t\t\t// timeout\n\t\t\tif (flags[i] > 0) {\n\t\t\t\toptions.timeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === '<') {\n\t\t\t\t// max length is not supported\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === 'p' && flags[i][4] === 'y') {\n\t\t\t\tproxy = parseProxy(flags[i].substring(6));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flags[i].toLowerCase()) {\n\n\t\t\t\tcase 'utf8':\n\t\t\t\tcase 'ascii':\n\t\t\t\tcase 'base64':\n\t\t\t\tcase 'binary':\n\t\t\t\tcase 'hex':\n\t\t\t\t\toptions.encoding = flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'xhr':\n\t\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'plain':\n\t\t\t\t\theaders['Content-Type'] = 'text/plain';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\theaders['Content-Type'] = 'text/html';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'json':\n\t\t\t\t\theaders['Content-Type'] = 'application/json';\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'xml':\n\t\t\t\t\theaders['Content-Type'] = 'text/xml';\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'options':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'upload':\n\t\t\t\t\theaders['Content-Type'] = 'multipart/form-data';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'put':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tif (!headers['Content-Type'])\n\t\t\t\t\t\theaders['Content-Type'] = 'application/x-www-form-urlencoded';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dnscache':\n\t\t\t\t\toptions.resolve = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'keepalive':\n\t\t\t\t\toptions.keepalive = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Fallback for methods (e.g. CalDAV)\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!method)\n\t\tmethod = 'GET';\n\n\toptions.post = !NOBODY[method];\n\n\tif (typeof(data) !== 'string')\n\t\tdata = type === 1 ? JSON.stringify(data) : Qs.stringify(data);\n\telse if (data[0] === '?')\n\t\tdata = data.substring(1);\n\n\tif (!options.post) {\n\t\tif (data.length && url.indexOf('?') === -1)\n\t\t\turl += '?' + data;\n\t\tdata = '';\n\t}\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\theaders['Cookie'] = builder;\n\t}\n\n\tvar uri = Url.parse(url);\n\turi.method = method;\n\t// uri.agent = false;\n\turi.headers = headers;\n\toptions.uri = uri;\n\toptions.param = param;\n\n\tif (options.resolve && (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64))\n\t\toptions.resolve = null;\n\n\tif (data.length) {\n\t\toptions.data = Buffer.from(data, ENCODING);\n\t\theaders['Content-Length'] = options.data.length;\n\t}\n\n\tif (CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\toptions.proxy = proxy;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy && uri.protocol !== 'https:')\n\t\turi.agent = KeepAlive;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tif (proxy)\n\t\tdownload_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(url, download_resolve, options);\n\telse\n\t\tdownload_call(uri, options);\n\n\treturn options.evt;\n};\n\nfunction download_resolve(err, uri, options) {\n\tif (!err)\n\t\toptions.uri.host = uri.host;\n\tdownload_call(options.uri, options);\n}\n\nfunction download_call(uri, options) {\n\n\tvar opt;\n\toptions.length = 0;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = options.post ? connection.request(opt, download_response) : connection.get(opt, download_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', download_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(download_process_timeout, options.timeout);\n\treq.on('response', download_assign_res);\n\treq.end(options.data);\n}\n\nfunction download_assign_res(response) {\n\tresponse.req = this;\n\tvar options = this.$options;\n\toptions.length = +response.headers['content-length'] || 0;\n\toptions.evt && options.evt.$events.begin && options.evt.emit('begin', options.length);\n}\n\nfunction download_process_timeout(req) {\n\tvar options = req.$options;\n\tif (options.callback) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t\treq.abort();\n\t\toptions.callback(new Error(exports.httpStatus(408)), null, null, null, null, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t\toptions.canceled = true;\n\t}\n}\n\nfunction download_process_error(err) {\n\tvar options = this.$options;\n\tif (options.callback && !options.done) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t\toptions.callback(err, null, null, null, null, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t\toptions.canceled = true;\n\t}\n}\n\nfunction download_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.redirect > 3) {\n\t\t\toptions.canceled = true;\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.callback && options.callback(new Error('Too many redirects.'), null, null, null, null, options.param);\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers['location'];\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.uri = tmp;\n\t\t\tdownload_call(options, request_call);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn download_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(loc, function(err, u) {\n\t\t\tif (!err)\n\t\t\t\ttmp.host = u.host;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\tdownload_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\tres.on('data', download_process_data);\n\tres.on('end', download_process_end);\n\n\tres.resume();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.callback && options.callback(null, res, res.statusCode, res.headers, uri.host, options.param);\n}\n\nexports.$$download = function(url, flags, data, cookies, headers, encoding, timeout) {\n\treturn function(callback) {\n\t\texports.download(url, flags, data, callback, cookies, headers, encoding, timeout);\n\t};\n};\n\nfunction download_process_end() {\n\n\tvar res = this;\n\tvar self = this;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\n\tif (!options.canceled) {\n\t\tvar str = self._buffer ? self._buffer.toString(options.encoding) : '';\n\t\tself._buffer = undefined;\n\t\toptions.evt && options.evt.$events.end && options.evt.emit('end', str, self.statusCode, self.headers, uri.host);\n\t}\n\n\tif (options.evt) {\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n\n\tres.req && res.req.removeAllListeners();\n\tres.removeAllListeners();\n}\n\nfunction download_process_data(chunk) {\n\tvar self = this;\n\tvar options = self.req.$options;\n\tif (!options.canceled) {\n\t\tself._bufferlength += chunk.length;\n\t\tif (options.evt) {\n\t\t\toptions.evt.$events.data && options.evt.emit('data', chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n\t\t\toptions.evt.$events.progress && options.evt.emit('progress', options.length ? (self._bufferlength / options.length) * 100 : 0);\n\t\t}\n\t}\n}\n\n/**\n * Upload a stream through HTTP\n * @param {String} name Filename with extension.\n * @param {Stream} stream Stream.\n * @param {String} url A valid URL address.\n * @param {Function} callback Callback.\n * @param {Object} headers Custom headers (optional).\n * @param {String} method HTTP method (optional, default POST).\n * @param {Number} timeout Request timeout, default: 60000 (1 minute)\n */\nexports.send = function(name, stream, url, callback, cookies, headers, method, timeout) {\n\n\tOBSOLETE('U.send()', 'Use U.upload() instead of U.send().');\n\n\tif (typeof(stream) === 'string')\n\t\tstream = Fs.createReadStream(stream, STREAM_READONLY);\n\n\tvar BOUNDARY = '----totaljs' + Math.random().toString(16).substring(2);\n\tvar h = {};\n\n\tif (headers)\n\t\texports.extend(h, headers);\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\th['Cookie'] = builder;\n\t}\n\n\tname = exports.getName(name);\n\n\th['Cache-Control'] = 'max-age=0';\n\th['Content-Type'] = 'multipart/form-data; boundary=' + BOUNDARY;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tvar e = new EventEmitter2();\n\tvar uri = Url.parse(url);\n\tvar options = { protocol: uri.protocol, auth: uri.auth, method: method || 'POST', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: h };\n\tvar responseLength = 0;\n\n\tvar response = function(res) {\n\n\t\tres.body = Buffer.alloc(0);\n\t\tres._bufferlength = 0;\n\n\t\tres.on('data', function(chunk) {\n\t\t\tCONCAT[0] = res.body;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tres.body = Buffer.concat(CONCAT);\n\t\t\tres._bufferlength += chunk.length;\n\t\t\te.$events.data && e.emit('data', chunk, responseLength ? (res._bufferlength / responseLength) * 100 : 0);\n\t\t});\n\n\t\tres.on('end', function() {\n\t\t\tvar self = this;\n\t\t\te.$events.end && e.emit('end', self.statusCode, self.headers);\n\t\t\te.removeAllListeners();\n\t\t\te = null;\n\t\t\tcallback && callback(null, self.body.toString('utf8'), self.statusCode, self.headers, uri.host);\n\t\t\tself.body = null;\n\t\t});\n\t};\n\n\tvar connection = options.protocol === 'https:' ? Https : Http;\n\tvar req = connection.request(options, response);\n\n\treq.on('response', function(response) {\n\t\tresponseLength = +response.headers['content-length'] || 0;\n\t\te.$events.begin && e.emit('begin', responseLength);\n\t});\n\n\treq.setTimeout(timeout || 60000, function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t\te.removeAllListeners();\n\t\te = null;\n\t\tcallback && callback(new Error(exports.httpStatus(408)), '', 408, undefined, uri.host);\n\t});\n\n\treq.on('error', function(err) {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t\te.removeAllListeners();\n\t\te = null;\n\t\tcallback && callback(err, '', 0, undefined, uri.host);\n\t});\n\n\treq.on('close', function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t});\n\n\tvar header = NEWLINE + NEWLINE + '--' + BOUNDARY + NEWLINE + 'Content-Disposition: form-data; name=\"File\"; filename=\"' + name + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(name)) + NEWLINE + NEWLINE;\n\treq.write(header);\n\n\t// Is Buffer\n\tif (stream.length) {\n\t\treq.write(stream);\n\t\treq.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--');\n\t\treturn e;\n\t}\n\n\tstream.on('end', () => req.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--'));\n\tstream.pipe(req, STREAM_END);\n\treturn e;\n};\n\nexports.$$send = function(name, stream, url, cookies, headers, method, timeout) {\n\treturn function(callback) {\n\t\texports.send(name, stream, url, callback, cookies, headers, method, timeout);\n\t};\n};\n\nexports.upload = function(files, url, callback, cookies, headers, method, timeout) {\n\n\tvar BOUNDARY = '----totaljs' + Math.random().toString(16).substring(2);\n\tvar h = {};\n\n\theaders && exports.extend_headers2(h, headers);\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tbuilder && (h['Cookie'] = builder);\n\t}\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\th['Cache-Control'] = 'max-age=0';\n\th['Content-Type'] = 'multipart/form-data; boundary=' + BOUNDARY;\n\n\tvar e = new EventEmitter2();\n\tvar uri = Url.parse(url);\n\tvar options = { protocol: uri.protocol, auth: uri.auth, method: method || 'POST', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: h };\n\tvar responseLength = 0;\n\tvar timeoutid;\n\tvar done = false;\n\n\tvar response = function(res) {\n\n\t\tres.body = Buffer.alloc(0);\n\t\tres._bufferlength = 0;\n\n\t\tres.on('data', function(chunk) {\n\t\t\tif (!done) {\n\t\t\t\tCONCAT[0] = res.body;\n\t\t\t\tCONCAT[1] = chunk;\n\t\t\t\tres.body = Buffer.concat(CONCAT);\n\t\t\t\tres._bufferlength += chunk.length;\n\t\t\t\te.$events.data && e.emit('data', chunk, responseLength ? (res._bufferlength / responseLength) * 100 : 0);\n\t\t\t}\n\t\t});\n\n\t\tres.on('end', function() {\n\t\t\tif (!done) {\n\t\t\t\tvar self = this;\n\t\t\t\te.$events.end && e.emit('end', self.statusCode, self.headers);\n\t\t\t\te.removeAllListeners();\n\t\t\t\tcallback && callback(null, self.body.toString('utf8'), self.statusCode, self.headers, uri.host);\n\t\t\t\ttimeoutid && clearTimeout(timeoutid);\n\t\t\t\tself.body = null;\n\t\t\t\te = null;\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t});\n\t};\n\n\tvar connection = options.protocol === 'https:' ? Https : Http;\n\tvar req = connection.request(options, response);\n\n\treq.on('response', function(response) {\n\t\tresponseLength = +response.headers['content-length'] || 0;\n\t\te.$events.begin && e.emit('begin', responseLength);\n\t});\n\n\tvar timeoutcallback = function() {\n\t\tif (!done) {\n\t\t\treq.removeAllListeners();\n\t\t\te.removeAllListeners();\n\t\t\tcallback && callback(new Error(exports.httpStatus(408)), '', 408, undefined, uri.host);\n\t\t\ttimeoutid && clearTimeout(timeoutid);\n\t\t\treq = null;\n\t\t\te = null;\n\t\t\tdone = true;\n\t\t}\n\t};\n\n\tif (timeout)\n\t\ttimeoutid = setTimeout(timeoutcallback, timeout);\n\n\treq.setTimeout(timeout || 60000, timeoutcallback);\n\n\treq.on('error', function(err) {\n\t\tdone = true;\n\t\treq.removeAllListeners();\n\t\te.removeAllListeners();\n\t\tcallback && callback(err, '', 0, undefined, uri.host);\n\t\ttimeoutid && clearTimeout(timeoutid);\n\t\treq = null;\n\t\te = null;\n\t});\n\n\treq.on('close', function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t});\n\n\tvar header = NEWLINE + NEWLINE + '--' + BOUNDARY + NEWLINE + 'Content-Disposition: form-data; name=\"{0}\"; filename=\"{1}\"' + NEWLINE + 'Content-Type: {2}' + NEWLINE + NEWLINE;\n\n\tfiles.wait(function(item, next) {\n\n\t\t// item.name;\n\t\t// item.filename;\n\t\t// item.stream (optional) or item.buffer (optional)\n\n\t\treq.write(header.format(item.name, U.getName(item.filename), exports.getContentType(exports.getExtension(item.filename))));\n\n\t\tif (item.buffer) {\n\t\t\treq.write(item.buffer);\n\t\t\treturn next();\n\t\t}\n\n\t\t!item.stream && (item.stream = Fs.createReadStream(item.filename));\n\t\titem.stream.pipe(req, STREAM_END);\n\t\titem.stream.on('error', next);\n\t\titem.stream.on('end', next);\n\n\t}, () => req.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--'));\n\treturn e;\n};\n\nexports.$$upload = function(files, url, cookies, headers, method, timeout) {\n\treturn function(callback) {\n\t\texports.upload(files, url, callback, cookies, headers, method, timeout);\n\t};\n};\n\n/**\n * Trim string properties\n * @param {Object} obj\n * @return {Object}\n */\nexports.trim = function(obj, clean) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type === 'string') {\n\t\tobj = obj.trim();\n\t\treturn clean && !obj ? undefined : obj;\n\t}\n\n\tif (obj instanceof Array) {\n\t\tfor (var i = 0, length = obj.length; i < length; i++) {\n\n\t\t\tvar item = obj[i];\n\t\t\ttype = typeof(item);\n\n\t\t\tif (type === 'object') {\n\t\t\t\texports.trim(item, clean);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type !== 'string')\n\t\t\t\tcontinue;\n\n\t\t\tobj[i] = item.trim();\n\t\t\tif (clean && !obj[i])\n\t\t\t\tobj[i] = undefined;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tif (type !== 'object')\n\t\treturn obj;\n\n\tvar keys = Object.keys(obj);\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar val = obj[keys[i]];\n\t\tvar type = typeof(val);\n\t\tif (type === 'object') {\n\t\t\texports.trim(val, clean);\n\t\t\tcontinue;\n\t\t} else if (type !== 'string')\n\t\t\tcontinue;\n\t\tobj[keys[i]] = val.trim();\n\t\tif (clean && !obj[keys[i]])\n\t\t\tobj[keys[i]] = undefined;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Noop function\n * @return {Function} Empty function.\n */\nexports.noop = global.noop = global.NOOP = function() {};\n\n/**\n * Read HTTP status\n * @param  {Number} code HTTP code status.\n * @param  {Boolean} addCode Add code number to HTTP status.\n * @return {String}\n */\nexports.httpStatus = function(code, addCode) {\n\tif (addCode === undefined)\n\t\taddCode = true;\n\treturn (addCode ? code + ': ' : '') + Http.STATUS_CODES[code];\n};\n\n/**\n * Extend object\n * @param {Object} target Target object.\n * @param {Object} source Source object.\n * @param {Boolean} rewrite Rewrite exists values (optional, default true).\n * @return {Object} Modified object.\n */\nexports.extend = function(target, source, rewrite) {\n\n\tif (!target || !source)\n\t\treturn target;\n\n\tif (typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tvar keys = Object.keys(source);\n\tvar i = keys.length;\n\n\twhile (i--) {\n\t\tvar key = keys[i];\n\t\tif (rewrite || target[key] === undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\nexports.extend_headers = function(first, second) {\n\tvar keys = Object.keys(first);\n\tvar headers = {};\n\n\tvar i = keys.length;\n\twhile (i--)\n\t\theaders[keys[i]] = first[keys[i]];\n\n\tkeys = Object.keys(second);\n\ti = keys.length;\n\n\twhile (i--)\n\t\theaders[keys[i]] = second[keys[i]];\n\n\treturn headers;\n};\n\nexports.extend_headers2 = function(first, second) {\n\tvar keys = Object.keys(second);\n\tvar i = keys.length;\n\twhile (i--)\n\t\tfirst[keys[i]] = second[keys[i]];\n\treturn first;\n};\n\n/**\n * Clones object\n * @param {Object} obj\n * @param {Object} skip Optional, can be only object e.g. { name: true, age: true }.\n * @param {Boolean} skipFunctions It doesn't clone functions, optional --> default false.\n * @return {Object}\n */\nglobal.CLONE = exports.clone = function(obj, skip, skipFunctions) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type !== 'object' || obj instanceof Date || obj instanceof Error)\n\t\treturn obj;\n\n\tvar length;\n\tvar o;\n\n\tif (obj instanceof Array) {\n\n\t\tlength = obj.length;\n\t\to = new Array(length);\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttype = typeof(obj[i]);\n\t\t\tif (type !== 'object' || obj[i] instanceof Date || obj[i] instanceof Error) {\n\t\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\t\tcontinue;\n\t\t\t\to[i] = obj[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\to[i] = exports.clone(obj[i], skip, skipFunctions);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\to = {};\n\n\tfor (var m in obj) {\n\n\t\tif (skip && skip[m])\n\t\t\tcontinue;\n\n\t\tvar val = obj[m];\n\n\t\tif (val instanceof Buffer) {\n\t\t\tvar copy = Buffer.alloc(val.length);\n\t\t\tval.copy(copy);\n\t\t\to[m] = copy;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = typeof(val);\n\t\tif (type !== 'object' || val instanceof Date || val instanceof Error) {\n\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\tcontinue;\n\t\t\to[m] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\to[m] = exports.clone(obj[m], skip, skipFunctions);\n\t}\n\n\treturn o;\n};\n\n/**\n * Copy values from object to object\n * @param {Object} source Object source\n * @param {Object} target Object target (optional)\n * @return {Object} Modified object.\n */\nexports.copy = function(source, target) {\n\n\tif (target === undefined)\n\t\treturn exports.extend({}, source, true);\n\n\tif (!target || !source || typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tvar keys = Object.keys(source);\n\tvar i = keys.length;\n\n\twhile (i--) {\n\t\tvar key = keys[i];\n\t\ttarget[key] !== undefined && (target[key] = exports.clone(source[key]));\n\t}\n\n\treturn target;\n};\n\n/**\n * Reduce an object\n * @param {Object} source Source object.\n * @param {String Array or Object} prop Other properties than these ones will be removed.\n * @param {Boolean} reverse Reverse reducing (prop will be removed), default: false.\n * @return {Object}\n */\nexports.reduce = function(source, prop, reverse) {\n\n\tif (!(prop instanceof Array)) {\n\t\tif (typeof(prop) === 'object')\n\t\t\treturn exports.reduce(source, Object.keys(prop), reverse);\n\t}\n\n\tif (source instanceof Array) {\n\t\tvar arr = [];\n\t\tfor (var i = 0, length = source.length; i < length; i++)\n\t\t\tarr.push(exports.reduce(source[i], prop, reverse));\n\t\treturn arr;\n\t}\n\n\tvar output = {};\n\n\tvar keys = Object.keys(source);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar o = keys[i];\n\t\tif (reverse) {\n\t\t\tif (prop.indexOf(o) === -1)\n\t\t\t\toutput[o] = source[o];\n\t\t} else {\n\t\t\tif (prop.indexOf(o) !== -1)\n\t\t\t\toutput[o] = source[o];\n\t\t}\n\t}\n\n\treturn output;\n};\n\n/**\n * Assign value to an object according to a path\n * @param {Object} obj Source object.\n * @param {String} path Path to the update.\n * @param {Object or Function} fn Value or Function to update.\n * @return {Object}\n */\n// @TODO: deprecated, it will be removed in v4\nexports.assign = function(obj, path, fn) {\n\n\tif (obj == null)\n\t\treturn obj;\n\n\tvar arr = path.split('.');\n\tvar model = obj[arr[0]];\n\n\tfor (var i = 1; i < arr.length - 1; i++)\n\t\tmodel = model[arr[i]];\n\n\tmodel[arr[arr.length - 1]] = typeof (fn) === 'function' ? fn(model[arr[arr.length - 1]]) : fn;\n\treturn obj;\n};\n\n/**\n * Checks if is relative url\n * @param {String} url\n * @return {Boolean}\n */\nexports.isRelative = function(url) {\n\treturn !(url.substring(0, 2) === '//' || url.indexOf('http://') !== -1 || url.indexOf('https://') !== -1);\n};\n\n/**\n * Streamer method\n * @param {String/Buffer} beg\n * @param {String/Buffer} end\n * @param {Function(value, index)} callback\n */\nexports.streamer = function(beg, end, callback, skip, stream, raw) {\n\n\tif (typeof(end) === 'function') {\n\t\tstream = skip;\n\t\tskip = callback;\n\t\tcallback = end;\n\t\tend = undefined;\n\t}\n\n\tif (typeof(skip) === 'object') {\n\t\tstream = skip;\n\t\tskip = 0;\n\t}\n\n\tvar indexer = 0;\n\tvar buffer = Buffer.alloc(0);\n\tvar canceled = false;\n\tvar fn;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\n\tif (!(beg instanceof Buffer))\n\t\tbeg = Buffer.from(beg, 'utf8');\n\n\tif (end && !(end instanceof Buffer))\n\t\tend = Buffer.from(end, 'utf8');\n\n\tif (!end) {\n\t\tvar length = beg.length;\n\t\tfn = function(chunk) {\n\n\t\t\tif (!chunk || canceled)\n\t\t\t\treturn;\n\n\t\t\tCONCAT[0] = buffer;\n\t\t\tCONCAT[1] = chunk;\n\n\t\t\tvar f = 0;\n\n\t\t\tif (buffer.length) {\n\t\t\t\tf = buffer.length - beg.length;\n\t\t\t\tif (f < 0)\n\t\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\t\tvar index = buffer.indexOf(beg, f);\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\twhile (index !== -1) {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tskip--;\n\t\t\t\telse {\n\t\t\t\t\tif (callback(raw ? buffer.slice(0, index + length) : buffer.toString('utf8', 0, index + length), indexer++) === false)\n\t\t\t\t\t\tcanceled = true;\n\t\t\t\t}\n\n\t\t\t\tif (canceled)\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = buffer.slice(index + length);\n\t\t\t\tindex = buffer.indexOf(beg);\n\t\t\t\tif (index === -1)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tstream && stream.on('end', () => fn(beg));\n\t\treturn fn;\n\t}\n\n\tvar blength = beg.length;\n\tvar elength = end.length;\n\tvar bi = -1;\n\tvar ei = -1;\n\tvar is = false;\n\n\tfn = function(chunk) {\n\n\t\tif (!chunk || canceled)\n\t\t\treturn;\n\n\t\tCONCAT[0] = buffer;\n\t\tCONCAT[1] = chunk;\n\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\tif (!is) {\n\t\t\tvar f = CONCAT[0].length - beg.length;\n\t\t\tif (f < 0)\n\t\t\t\tf = 0;\n\t\t\tbi = buffer.indexOf(beg, f);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t}\n\n\t\tif (is) {\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\n\t\twhile (bi !== -1) {\n\n\t\t\tif (skip)\n\t\t\t\tskip--;\n\t\t\telse {\n\t\t\t\tif (callback(raw ? buffer.slice(bi, ei + elength) : buffer.toString('utf8', bi, ei + elength), indexer++) === false)\n\t\t\t\t\tcanceled = true;\n\t\t\t}\n\n\t\t\tif (canceled)\n\t\t\t\treturn;\n\n\t\t\tbuffer = buffer.slice(ei + elength);\n\t\t\tis = false;\n\t\t\tbi = buffer.indexOf(beg);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\t};\n\n\tstream && stream.on('end', () => fn(end));\n\treturn fn;\n};\n\nexports.streamer2 = function(beg, end, callback, skip, stream) {\n\treturn exports.streamer(beg, end, callback, skip, stream, true);\n};\n\n/**\n * HTML encode string\n * @param {String} str\n * @return {String}\n */\nexports.encode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.encode();\n};\n\n/**\n * HTML decode string\n * @param {String} str\n * @return {String}\n */\nexports.decode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.decode();\n};\n\n/**\n * Checks if URL contains file extension.\n * @param {String} url\n * @return {Boolean}\n */\nexports.isStaticFile = function(url) {\n\treturn regexpSTATIC.test(url);\n};\n\n/**\n * Converts Value to number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseInt = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseInt(def);\n};\n\nexports.parseBool = exports.parseBoolean = function(obj, def) {\n\tif (obj == null)\n\t\treturn def === undefined ? false : def;\n\tvar type = typeof(obj);\n\treturn type === 'boolean' ? obj : type === 'number' ? obj > 0 : (type !== 'string' ? obj.toString() : obj).parseBool(def);\n};\n\n/**\n * Converts Value to float number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseFloat = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseFloat(def);\n};\n\n/**\n * Check if the object is Array.\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isArray = function(obj) {\n\treturn obj instanceof Array;\n};\n\n/**\n * Check if the object is RegExp\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isRegExp = function(obj) {\n\treturn obj && typeof(obj.test) === 'function' ? true : false;\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isDate = function(obj) {\n\treturn obj instanceof Date && !isNaN(obj.getTime()) ? true : false;\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isError = function(obj) {\n\treturn (obj && obj.stack) ? true : false;\n};\n\n/**\n * Check if the value is object\n * @param {Object} value\n * @return {Boolean}\n */\nexports.isObject = function(value) {\n\ttry {\n\t\treturn (value && Object.getPrototypeOf(value) === Object.prototype) ? true : false;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n/**\n * Get ContentType from file extension.\n * @param {String} ext File extension.\n * @return {String}\n */\nexports.getContentType = function(ext) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\treturn CONTENTTYPES[ext] || 'application/octet-stream';\n};\n\n/**\n * Get extension from filename\n * @param {String} filename\n * @return {String}\n */\nexports.getExtension = function(filename, raw) {\n\tvar end = filename.length;\n\tfor (var i = filename.length - 1; i > 0; i--) {\n\t\tvar c = filename[i];\n\t\tif (c === ' ' || c === '?')\n\t\t\tend = i;\n\t\telse if (c === '.') {\n\t\t\tc = filename.substring(i + 1, end);\n\t\t\treturn raw ? c : c.toLowerCase();\n\t\t}\n\t\telse if (c === '/' || c === '\\\\')\n\t\t\treturn '';\n\t}\n\treturn '';\n};\n\n/**\n * Get base name from path\n * @param {String} path\n * @return {String}\n */\nexports.getName = function(path) {\n\tvar l = path.length - 1;\n\tvar c = path[l];\n\tif (c === '/' || c === '\\\\')\n\t\tpath = path.substring(0, l);\n\tvar index = path.lastIndexOf('/');\n\tif (index !== -1)\n\t\treturn path.substring(index + 1);\n\tindex = path.lastIndexOf('\\\\');\n\treturn index === -1 ? path : path.substring(index + 1);\n};\n\n/**\n * Add a new content type to content types\n * @param {String} ext File extension.\n * @param {String} type Content type (example: application/json).\n */\nexports.setContentType = function(ext, type) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\n\tif (ext.length > 8) {\n\t\tvar tmp = regexpSTATIC.toString().replace(/,\\d+\\}/, ',' + ext.length + '}').substring(1);\n\t\tregexpSTATIC = new RegExp(tmp.substring(0, tmp.length - 1));\n\t}\n\n\tCONTENTTYPES[ext] = type;\n\treturn true;\n};\n\nexports.path = function(path, delimiter) {\n\tif (!path)\n\t\tpath = '';\n\tdelimiter = delimiter || '/';\n\treturn path[path.length - 1] === delimiter ? path : path + delimiter;\n};\n\nexports.join = function() {\n\tvar path = [''];\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar current = arguments[i];\n\t\tif (!current)\n\t\t\tcontinue;\n\t\tif (current[0] === '/')\n\t\t\tcurrent = current.substring(1);\n\t\tvar l = current.length - 1;\n\t\tif (current[l] === '/')\n\t\t\tcurrent = current.substring(0, l);\n\t\tpath.push(current);\n\t}\n\n\tpath = path.join('/');\n\treturn !isWindows ? path : path.indexOf(':') > -1 ? path.substring(1) : path;\n};\n\n/**\n * Prepares Windows path to UNIX like format\n * @internal\n * @param {String} path\n * @return {String}\n */\nexports.$normalize = function(path) {\n\treturn isWindows ? path.replace(regexpPATH, '/') : path;\n};\n\nexports.random = function(max, min) {\n\tmax = (max || 100000);\n\tmin = (min || 0);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction rnd() {\n\treturn Math.floor(Math.random() * 65536).toString(36);\n}\n\nglobal.GUID = exports.GUID = function(max) {\n\tmax = max || 40;\n\tvar str = '';\n\tfor (var i = 0; i < (max / 3) + 1; i++)\n\t\tstr += rnd();\n\treturn str.substring(0, max);\n};\n\nfunction validate_builder_default(name, value, entity) {\n\n\tvar type = typeof(value);\n\n\tif (entity.type === 12)\n\t\treturn value != null && type === 'object' && !(value instanceof Array);\n\n\tif (entity.type === 11)\n\t\treturn type === 'number';\n\n\t// Enum + KeyValue + Custom (8+9+10)\n\tif (entity.type > 7)\n\t\treturn value !== undefined;\n\n\tswitch (entity.subtype) {\n\t\tcase 'uid':\n\t\t\treturn value.isUID();\n\t\tcase 'zip':\n\t\t\treturn value.isZIP();\n\t\tcase 'email':\n\t\t\treturn value.isEmail();\n\t\tcase 'json':\n\t\t\treturn value.isJSON();\n\t\tcase 'url':\n\t\t\treturn value.isURL();\n\t\tcase 'phone':\n\t\t\treturn value.isPhone();\n\t\tcase 'base64':\n\t\t\treturn value.isBase64();\n\t}\n\n\tif (type === 'number')\n\t\treturn value > 0;\n\n\tif (type === 'string' || value instanceof Array)\n\t\treturn value.length > 0;\n\n\tif (type === 'boolean')\n\t\treturn value === true;\n\n\tif (value == null)\n\t\treturn false;\n\n\tif (value instanceof Date)\n\t\treturn value.toString()[0] !== 'I'; // Invalid Date\n\n\treturn true;\n}\n\nexports.validate_builder = function(model, error, schema, path, index, fields, pluspath) {\n\n\tvar prepare = schema.onValidate || F.onValidate || NOOP;\n\tvar current = path ? path + '.' : '';\n\tvar properties = model && model.$$keys ? model.$$keys : schema.properties;\n\tvar result;\n\n\tif (!pluspath)\n\t\tpluspath = '';\n\n\tif (model == null)\n\t\tmodel = {};\n\n\tfor (var i = 0; i < properties.length; i++) {\n\n\t\tvar name = properties[i];\n\n\t\tif (fields && fields.indexOf(name) === -1)\n\t\t\tcontinue;\n\n\t\tvar TYPE = schema.schema[name];\n\t\tif (!TYPE)\n\t\t\tcontinue;\n\n\t\tif (TYPE.can && !TYPE.can(model, model.$$workflow || EMPTYOBJECT))\n\t\t\tcontinue;\n\n\t\tvar value = model[name];\n\t\tvar type = typeof(value);\n\t\tvar prefix = schema.resourcePrefix ? (schema.resourcePrefix + name) : name;\n\n\t\tif (value === undefined) {\n\t\t\terror.push(pluspath + name, '@', current + name, undefined, prefix);\n\t\t\tcontinue;\n\t\t} else if (type === 'function')\n\t\t\tvalue = model[name]();\n\n\t\tif (TYPE.isArray) {\n\t\t\tif (TYPE.type === 7 && value instanceof Array && value.length) {\n\t\t\t\tvar nestedschema = schema.parent.collection[TYPE.raw] || GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema) {\n\t\t\t\t\tfor (var j = 0, jl = value.length; j < jl; j++)\n\t\t\t\t\t\texports.validate_builder(value[j], error, nestedschema, current + name + '[' + j + ']', j, undefined, pluspath);\n\t\t\t\t} else\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\n\t\t\t\tif (!TYPE.required)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : prepare(name, value, current + name, model, schema.name, TYPE);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = value instanceof Array ? value.length > 0 : false;\n\t\t\t\t\tif (result == null || result === true)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean') {\n\t\t\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t\t\t} else if (result.isValid === false)\n\t\t\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (TYPE.type === 7) {\n\n\t\t\tif (!value && !TYPE.required)\n\t\t\t\tcontinue;\n\n\t\t\t// Another schema\n\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\n\t\t\tif (result == null) {\n\t\t\t\tvar nestedschema = schema.parent.collection[TYPE.raw] || GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema)\n\t\t\t\t\texports.validate_builder(value, error, nestedschema, current + name, undefined, undefined, pluspath);\n\t\t\t\telse\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean') {\n\t\t\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t\t\t} else if (result.isValid === false)\n\t\t\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!TYPE.required)\n\t\t\tcontinue;\n\n\t\tresult = TYPE.validate ? TYPE.validate(value, model) : prepare(name, value, current + name, model, schema.name, TYPE);\n\t\tif (result == null) {\n\t\t\tresult = validate_builder_default(name, value, TYPE);\n\t\t\tif (result == null || result === true)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttype = typeof(result);\n\n\t\tif (type === 'string') {\n\t\t\tif (result[0] === '@')\n\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\telse\n\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t} else if (type === 'boolean') {\n\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t} else if (result.isValid === false)\n\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t}\n\n\treturn error;\n};\n\n/**\n * Combine paths\n * @return {String}\n */\nexports.combine = function() {\n\n\tvar p = F.directory;\n\n\tfor (var i = 0, length = arguments.length; i < length; i++) {\n\t\tvar v = arguments[i];\n\t\tif (!v)\n\t\t\tcontinue;\n\t\tif (v[0] === '/')\n\t\t\tv = v.substring(1);\n\n\t\tif (v[0] === '~')\n\t\t\tp = v.substring(1);\n\t\telse\n\t\t\tp += (p[p.length - 1] !== '/' ? '/' : '') + v;\n\t}\n\treturn exports.$normalize(p);\n};\n\n/**\n * Remove diacritics\n * @param {String} str\n * @return {String}\n */\nexports.removeDiacritics = function(str) {\n\treturn str.replace(regexpDiacritics, c => DIACRITICSMAP[c] || c);\n};\n\n/**\n * Simple XML parser\n * @param {String} xml\n * @return {Object}\n */\nexports.parseXML = function(xml, replace) {\n\n\tvar beg = -1;\n\tvar end = 0;\n\tvar tmp = 0;\n\tvar current = [];\n\tvar obj = {};\n\tvar from = -1;\n\n\twhile (true) {\n\t\tbeg = xml.indexOf('<![CDATA[', beg);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = xml.indexOf(']]>', beg + 9);\n\t\txml = xml.substring(0, beg) + xml.substring(beg + 9, end).trim().encode() + xml.substring(end + 3);\n\t\tbeg += 9;\n\t}\n\n\tbeg = -1;\n\tend = 0;\n\n\twhile (true) {\n\n\t\tbeg = xml.indexOf('<', beg + 1);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = xml.indexOf('>', beg + 1);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar el = xml.substring(beg, end + 1);\n\t\tvar c = el[1];\n\n\t\tif (c === '?' || c === '/') {\n\n\t\t\tvar o = current.pop();\n\n\t\t\tif (from === -1 || o !== el.substring(2, el.length - 1))\n\t\t\t\tcontinue;\n\n\t\t\tvar path = (current.length ? current.join('.') + '.' : '') + o;\n\t\t\tvar value = xml.substring(from, beg).decode();\n\n\t\t\tif (replace)\n\t\t\t\tpath = path.replace(REG_XMLKEY, '_');\n\n\t\t\tif (obj[path] === undefined)\n\t\t\t\tobj[path] = value;\n\t\t\telse if (obj[path] instanceof Array)\n\t\t\t\tobj[path].push(value);\n\t\t\telse\n\t\t\t\tobj[path] = [obj[path], value];\n\n\t\t\tfrom = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = el.indexOf(' ');\n\t\tvar hasAttributes = true;\n\n\t\tif (tmp === -1) {\n\t\t\ttmp = el.length - 1;\n\t\t\thasAttributes = false;\n\t\t}\n\n\t\tfrom = beg + el.length;\n\n\t\tvar isSingle = el[el.length - 2] === '/';\n\t\tvar name = el.substring(1, tmp);\n\n\t\tif (!isSingle)\n\t\t\tcurrent.push(name);\n\n\t\tif (!hasAttributes)\n\t\t\tcontinue;\n\n\t\tvar match = el.match(regexpXML);\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tvar attr = {};\n\t\tvar length = match.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar index = match[i].indexOf('\"');\n\t\t\tattr[match[i].substring(0, index - 1)] = match[i].substring(index + 1, match[i].length - 1).decode();\n\t\t}\n\n\t\tvar k = current.join('.') + (isSingle ? '.' + name : '') + '[]';\n\t\tif (replace)\n\t\t\tk = k.replace(REG_XMLKEY, '_');\n\t\tobj[k] = attr;\n\t}\n\n\treturn obj;\n};\n\nexports.parseJSON = function(value, date) {\n\ttry {\n\t\treturn JSON.parse(value, date ? jsonparser : undefined);\n\t} catch(e) {\n\t}\n};\n\nexports.parseQuery = function(value) {\n\treturn F.onParseQuery(value);\n};\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n\n/**\n * Get WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param {Number} code\n * @param {Buffer or String} message\n * @param {Hexa} type\n * @return {Buffer}\n */\nexports.getWebSocketFrame = function(code, message, type, compress) {\n\tvar messageBuffer = getWebSocketFrameMessageBytes(code, message);\n\tvar lengthBuffer = getWebSocketFrameLengthBytes(messageBuffer.length);\n\tvar frameBuffer = Buffer.alloc(1 + lengthBuffer.length + messageBuffer.length);\n\tframeBuffer[0] = 0x80 | type;\n\tcompress && (frameBuffer[0] |= 0x40);\n\tlengthBuffer.copy(frameBuffer, 1, 0, lengthBuffer.length);\n\tmessageBuffer.copy(frameBuffer, lengthBuffer.length + 1, 0, messageBuffer.length);\n\treturn frameBuffer;\n};\n\n/**\n * Get bytes of WebSocket frame message\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} code\n * @param  {Buffer or String} message\n * @return {Buffer}\n */\nfunction getWebSocketFrameMessageBytes(code, message) {\n\n\tvar index = code ? 2 : 0;\n\tvar binary = message instanceof Int8Array || message instanceof Buffer;\n\tvar length = message.length;\n\n\tvar messageBuffer = Buffer.alloc(length + index);\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (binary)\n\t\t\tmessageBuffer[i + index] = message[i];\n\t\telse\n\t\t\tmessageBuffer[i + index] = message.charCodeAt(i);\n\t}\n\n\tif (code) {\n\t\tmessageBuffer[0] = code >> 8;\n\t\tmessageBuffer[1] = code;\n\t}\n\n\treturn messageBuffer;\n}\n\n/**\n * Get length of WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} length\n * @return {Number}\n */\nfunction getWebSocketFrameLengthBytes(length) {\n\tvar lengthBuffer = null;\n\n\tif (length <= 125) {\n\t\tlengthBuffer = Buffer.alloc(1);\n\t\tlengthBuffer[0] = length;\n\t\treturn lengthBuffer;\n\t}\n\n\tif (length <= 65535) {\n\t\tlengthBuffer = Buffer.alloc(3);\n\t\tlengthBuffer[0] = 126;\n\t\tlengthBuffer[1] = (length >> 8) & 255;\n\t\tlengthBuffer[2] = (length) & 255;\n\t\treturn lengthBuffer;\n\t}\n\n\tlengthBuffer = Buffer.alloc(9);\n\n\tlengthBuffer[0] = 127;\n\tlengthBuffer[1] = 0x00;\n\tlengthBuffer[2] = 0x00;\n\tlengthBuffer[3] = 0x00;\n\tlengthBuffer[4] = 0x00;\n\tlengthBuffer[5] = (length >> 24) & 255;\n\tlengthBuffer[6] = (length >> 16) & 255;\n\tlengthBuffer[7] = (length >> 8) & 255;\n\tlengthBuffer[8] = (length) & 255;\n\n\treturn lengthBuffer;\n}\n\n/**\n * GPS distance in KM\n * @param  {Number} lat1\n * @param  {Number} lon1\n * @param  {Number} lat2\n * @param  {Number} lon2\n * @return {Number}\n */\nexports.distance = function(lat1, lon1, lat2, lon2) {\n\tvar R = 6371;\n\tvar dLat = (lat2 - lat1).toRad();\n\tvar dLon = (lon2 - lon1).toRad();\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn (R * c).floor(3);\n};\n\nfunction ls(path, callback, advanced, filter) {\n\tvar filelist = new FileList();\n\tvar tmp;\n\n\tfilelist.advanced = advanced;\n\tfilelist.onComplete = callback;\n\n\tif (typeof(filter) === 'string') {\n\t\ttmp = filter.toLowerCase();\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : filename.toLowerCase().indexOf(tmp) !== -1;\n\t\t};\n\t} else if (exports.isRegExp(filter)) {\n\t\ttmp = filter;\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : tmp.test(filename);\n\t\t};\n\t} else\n\t\tfilelist.onFilter = filter || null;\n\n\tfilelist.walk(path);\n}\n\n/**\n * Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename, isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls = function(path, callback, filter) {\n\tls(path, callback, false, filter);\n};\n\n/**\n * Advanced Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename ,isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls2 = function(path, callback, filter) {\n\tls(path, callback, true, filter);\n};\n\nDP.setTimeZone = function(timezone) {\n\tvar dt = this.toLocaleString('en-US', { timeZone: timezone, hour12: false, dateStyle: 'short', timeStyle: 'short' });\n\treturn new Date(Date.parse(dt));\n};\n\nDP.add = function(type, value) {\n\n\tvar self = this;\n\n\tif (type.constructor === Number)\n\t\treturn new Date(self.getTime() + (type - type % 1));\n\n\tif (value === undefined) {\n\t\tvar arr = type.split(' ');\n\t\ttype = arr[1];\n\t\tvalue = exports.parseInt(arr[0]);\n\t}\n\n\tvar dt = new Date(self.getTime());\n\n\tswitch(type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'sec':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\tdt.setUTCSeconds(dt.getUTCSeconds() + value);\n\t\t\treturn dt;\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'min':\n\t\tcase 'minutes':\n\t\t\tdt.setUTCMinutes(dt.getUTCMinutes() + value);\n\t\t\treturn dt;\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\tdt.setUTCHours(dt.getUTCHours() + value);\n\t\t\treturn dt;\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + value);\n\t\t\treturn dt;\n\t\tcase 'w':\n\t\tcase 'ww':\n\t\tcase 'week':\n\t\tcase 'weeks':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + (value * 7));\n\t\t\treturn dt;\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\tdt.setUTCMonth(dt.getUTCMonth() + value);\n\t\t\treturn dt;\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\tdt.setUTCFullYear(dt.getUTCFullYear() + value);\n\t\t\treturn dt;\n\t}\n\treturn dt;\n};\n\n/**\n * Date difference\n * @param  {Date/Number/String} date Optional.\n * @param  {String} type Date type: minutes, seconds, hours, days, months, years\n * @return {Number}\n */\nDP.diff = function(date, type) {\n\n\tif (arguments.length === 1) {\n\t\ttype = date;\n\t\tdate = Date.now();\n\t} else {\n\t\tvar to = typeof(date);\n\t\tif (to === 'string')\n\t\t\tdate = Date.parse(date);\n\t\telse if (exports.isDate(date))\n\t\t\tdate = date.getTime();\n\t}\n\n\tvar r = this.getTime() - date;\n\n\tswitch (type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\treturn Math.ceil(r / 1000);\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'minutes':\n\t\t\treturn Math.ceil((r / 1000) / 60);\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\treturn Math.ceil(((r / 1000) / 60) / 60);\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / 24);\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28));\n\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28 * 12));\n\t}\n\n\treturn NaN;\n};\n\nDP.extend = function(date) {\n\tvar dt = new Date(this);\n\tvar match = date.match(regexpDATE);\n\n\tif (!match)\n\t\treturn dt;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\t\tvar m = match[i];\n\t\tvar arr, tmp;\n\n\t\tif (m.indexOf(':') !== -1) {\n\n\t\t\tarr = m.split(':');\n\t\t\ttmp = +arr[0];\n\t\t\ttmp >= 0 && dt.setUTCHours(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMinutes(tmp);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCSeconds(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('-') !== -1) {\n\t\t\tarr = m.split('-');\n\n\t\t\ttmp = +arr[0];\n\t\t\ttmp && dt.setUTCFullYear(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCDate(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('.') !== -1) {\n\t\t\tarr = m.split('.');\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\t!isNaN(tmp) && dt.setUTCFullYear(tmp);\n\t\t\t}\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\t!isNaN(tmp) && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\ttmp = +arr[0];\n\t\t\t!isNaN(tmp) && dt.setUTCDate(tmp);\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn dt;\n};\n\n/**\n * Compare dates\n * @param {Date} date\n * @return {Number} Results: -1 = current date is earlier than @date, 0 = current date is same as @date, 1 = current date is later than @date\n */\nDP.compare = function(date) {\n\n\tvar self = this;\n\tvar r = self.getTime() - date.getTime();\n\n\tif (r === 0)\n\t\treturn 0;\n\n\tif (r < 0)\n\t\treturn -1;\n\n\treturn 1;\n};\n\n/**\n * Compare two dates\n * @param {String or Date} d1\n * @param {String or Date} d2\n * @return {Number} Results: -1 = @d1 is earlier than @d2, 0 = @d1 is same as @d2, 1 = @d1 is later than @d2\n */\nDate.compare = function(d1, d2) {\n\n\tif (typeof(d1) === 'string')\n\t\td1 = d1.parseDate();\n\n\tif (typeof(d2) === 'string')\n\t\td2 = d2.parseDate();\n\n\treturn d1.compare(d2);\n};\n\n/**\n * Format datetime\n * @param {String} format\n * @return {String}\n */\nDP.format = function(format, resource) {\n\n\tif (!format)\n\t\treturn this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).toString().padLeft(2, '0') + '-' + this.getUTCDate().toString().padLeft(2, '0') + 'T' + this.getUTCHours().toString().padLeft(2, '0') + ':' + this.getUTCMinutes().toString().padLeft(2, '0') + ':' + this.getUTCSeconds().toString().padLeft(2, '0') + '.' + this.getUTCMilliseconds().toString().padLeft(3, '0') + 'Z';\n\n\tif (datetimeformat[format])\n\t\treturn datetimeformat[format](this, resource);\n\n\tvar key = format;\n\tvar half = false;\n\n\tif (format && format[0] === '!') {\n\t\thalf = true;\n\t\tformat = format.substring(1);\n\t}\n\n\tvar beg = '\\'+';\n\tvar end = '+\\'';\n\tvar before = [];\n\n\tvar ismm = false;\n\tvar isdd = false;\n\tvar isww = false;\n\n\tformat = format.replace(regexpDATEFORMAT, function(key) {\n\t\tswitch (key) {\n\t\t\tcase 'yyyy':\n\t\t\tcase 'YYYY':\n\t\t\t\treturn beg + 'd.getFullYear()' + end;\n\t\t\tcase 'yy':\n\t\t\tcase 'YY':\n\t\t\t\treturn beg + 'd.getFullYear().toString().substring(2)' + end;\n\t\t\tcase 'MMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(F.resource(resource, mm) || mm).substring(0, 3)' + end;\n\t\t\tcase 'MMMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(F.resource(resource, mm) || mm)' + end;\n\t\t\tcase 'MM':\n\t\t\t\treturn beg + '(d.getMonth() + 1).toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'M':\n\t\t\t\treturn beg + '(d.getMonth() + 1)' + end;\n\t\t\tcase 'ddd':\n\t\t\tcase 'DDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(F.resource(resource, dd) || dd).substring(0, 2).toUpperCase()' + end;\n\t\t\tcase 'dddd':\n\t\t\tcase 'DDDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(F.resource(resource, dd) || dd)' + end;\n\t\t\tcase 'dd':\n\t\t\tcase 'DD':\n\t\t\t\treturn beg + 'd.getDate().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\treturn beg + 'd.getDate()' + end;\n\t\t\tcase 'HH':\n\t\t\tcase 'hh':\n\t\t\t\treturn beg + (half ? 'framework_utils.$pmam(d.getHours()).toString().padLeft(2, \\'0\\')' : 'd.getHours().toString().padLeft(2, \\'0\\')') + end;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\treturn beg + (half ? 'framework_utils(d.getHours())' : 'd.getHours()') + end;\n\t\t\tcase 'mm':\n\t\t\t\treturn beg + 'd.getMinutes().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'm':\n\t\t\t\treturn beg + 'd.getMinutes()' + end;\n\t\t\tcase 'ss':\n\t\t\t\treturn beg + 'd.getSeconds().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 's':\n\t\t\t\treturn beg + 'd.getSeconds()' + end;\n\t\t\tcase 'w':\n\t\t\tcase 'ww':\n\t\t\t\tisww = true;\n\t\t\t\treturn beg + (key === 'ww' ? 'ww.toString().padLeft(2, \\'0\\')' : 'ww') + end;\n\t\t\tcase 'a':\n\t\t\t\tvar b = \"'PM':'AM'\";\n\t\t\t\treturn beg + '(d.getHours() >= 12 ? ' + b + ')' + end;\n\t\t}\n\t});\n\n\tismm && before.push('var mm = framework_utils.MONTHS[d.getMonth()];');\n\tisdd && before.push('var dd = framework_utils.DAYS[d.getDay()];');\n\tisww && before.push('var ww = new Date(+d);ww.setHours(0, 0, 0);ww.setDate(ww.getDate() + 4 - (ww.getDay() || 7));ww = Math.ceil((((ww - new Date(ww.getFullYear(), 0, 1)) / 8.64e7) + 1) / 7);');\n\n\tdatetimeformat[key] = new Function('d', 'resource', before.join('\\n') + 'return \\'' + format + '\\';');\n\treturn datetimeformat[key](this, resource);\n};\n\nexports.$pmam = function(value) {\n\treturn value >= 12 ? value - 12 : value;\n};\n\nDP.toUTC = function(ticks) {\n\tvar dt = this.getTime() + this.getTimezoneOffset() * 60000;\n\treturn ticks ? dt : new Date(dt);\n};\n\n// +v2.2.0 parses JSON dates as dates and this is the fallback for backward compatibility\nDP.parseDate = function() {\n\treturn this;\n};\n\nSP.isJSONDate = function() {\n\tvar l = this.length - 1;\n\treturn l > 22 && l < 30 && this[l] === 'Z' && this[10] === 'T' && this[4] === '-' && this[13] === ':' && this[16] === ':';\n};\n\nSP.ROOT = function(noremap) {\n\n\tvar str = this;\n\n\tstr = str.replace(REG_NOREMAP, function() {\n\t\tnoremap = true;\n\t\treturn '';\n\t}).replace(REG_ROOT, $urlmaker);\n\n\tif (!noremap && CONF.default_root)\n\t\tstr = str.replace(REG_REMAP, $urlremap).replace(REG_AJAX, $urlajax);\n\n\treturn str;\n};\n\nfunction $urlremap(text) {\n\tvar pos = text[0] === 'h' ? 6 : 5;\n\treturn REG_URLEXT.test(text) ? text : ((text[0] === 'h' ? 'href' : 'src') + '=\"' + CONF.default_root + (text[pos] === '/' ? text.substring(pos + 1) : text));\n}\n\nfunction $urlajax(text) {\n\treturn text.substring(0, text.length - 1) + CONF.default_root;\n}\n\nfunction $urlmaker(text) {\n\tvar c = text[4];\n\treturn CONF.default_root ? CONF.default_root : (c || '');\n}\n\nif (!SP.trim) {\n\tSP.trim = function() {\n\t\treturn this.replace(regexpTRIM, '');\n\t};\n}\n\nif (!SP.replaceAt) {\n\tSP.replaceAt = function(index, character) {\n\t\treturn this.substr(0, index) + character + this.substr(index + character.length);\n\t};\n}\n\n/**\n * Checks if the string starts with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.startsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.startsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(0, length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr(ignoreCase, length);\n\telse\n\t\ttmp = self.substring(0, length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\n/**\n * Checks if the string ends with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.endsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.endsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(self.length - length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr((self.length - ignoreCase) - length, length);\n\telse\n\t\ttmp = self.substring(self.length - length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\nSP.replacer = function(find, text) {\n\tvar self = this;\n\tvar beg = self.indexOf(find);\n\treturn beg === -1 ? self : (self.substring(0, beg) + text + self.substring(beg + find.length));\n};\n\n/**\n * Hash string\n * @param {String} type Hash type.\n * @param {String} salt Optional, salt.\n * @return {String}\n */\nSP.hash = function(type, salt) {\n\tvar str = salt ? this + salt : this;\n\tswitch (type) {\n\t\tcase 'md5':\n\t\t\treturn str.md5();\n\t\tcase 'sha1':\n\t\t\treturn str.sha1();\n\t\tcase 'sha256':\n\t\t\treturn str.sha256();\n\t\tcase 'sha512':\n\t\t\treturn str.sha512();\n\t\tcase 'crc32':\n\t\t\treturn str.crc32();\n\t\tcase 'crc32unsigned':\n\t\t\treturn str.crc32(true);\n\t\tdefault:\n\t\t\tvar val = string_hash(str);\n\t\t\treturn type === true ? val >>> 0 : val;\n\t}\n};\n\nglobal.HASH = function(value, type) {\n\treturn value.hash(type ? type : true);\n};\n\nSP.makeid = function() {\n\treturn this.hash(true).toString(16);\n};\n\nSP.crc32 = function(unsigned) {\n\tvar crc = -1;\n\tfor (var i = 0, length = this.length; i < length; i++)\n\t\tcrc = (crc >>> 8) ^ CRC32TABLE[(crc ^ this.charCodeAt(i)) & 0xFF];\n\tvar val = crc ^ (-1);\n\treturn unsigned ? val >>> 0 : val;\n};\n\nfunction string_hash(s, convert) {\n\tvar hash = 0;\n\tif (s.length === 0)\n\t\treturn convert ? '' : hash;\n\tfor (var i = 0, l = s.length; i < l; i++) {\n\t\tvar char = s.charCodeAt(i);\n\t\thash = ((hash << 5) - hash) + char;\n\t\thash |= 0;\n\t}\n\treturn hash;\n}\n\nSP.count = function(text) {\n\tvar index = 0;\n\tvar count = 0;\n\tdo {\n\t\tindex = this.indexOf(text, index + text.length);\n\t\tif (index > 0)\n\t\t\tcount++;\n\t} while (index > 0);\n\treturn count;\n};\n\nSP.parseXML = function(replace) {\n\treturn F.onParseXML(this, replace);\n};\n\nSP.parseJSON = function(date) {\n\treturn exports.parseJSON(this, date);\n};\n\nSP.parseQuery = function() {\n\treturn exports.parseQuery(this);\n};\n\nSP.parseUA = function(structured) {\n\n\tvar ua = this;\n\n\tif (!ua)\n\t\treturn '';\n\n\tvar arr = ua.match(regexpUA);\n\tvar uid = '';\n\n\tif (arr) {\n\n\t\tvar data = {};\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\n\t\t\tif (arr[i] === 'like' && arr[i + 1] === 'Gecko') {\n\t\t\t\ti += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar key = arr[i].toLowerCase();\n\t\t\tif (key === 'like')\n\t\t\t\tbreak;\n\n\t\t\tswitch (key) {\n\t\t\t\tcase 'linux':\n\t\t\t\tcase 'windows':\n\t\t\t\tcase 'mac':\n\t\t\t\tcase 'symbian':\n\t\t\t\tcase 'symbos':\n\t\t\t\tcase 'tizen':\n\t\t\t\tcase 'android':\n\t\t\t\t\tdata[arr[i]] = 2;\n\t\t\t\t\tif (key === 'tizen' || key === 'android')\n\t\t\t\t\t\tdata.Mobile = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'webos':\n\t\t\t\t\tdata.WebOS = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'media':\n\t\t\t\tcase 'center':\n\t\t\t\tcase 'tv':\n\t\t\t\tcase 'smarttv':\n\t\t\t\tcase 'smart':\n\t\t\t\t\tdata[arr[i]] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'iemobile':\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipad':\n\t\t\t\tcase 'ipod':\n\t\t\t\tcase 'iphone':\n\t\t\t\t\tdata.iOS = 2;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tif (key === 'ipad')\n\t\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'phone':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tizenbrowser':\n\t\t\t\tcase 'blackberry':\n\t\t\t\tcase 'mini':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'samsungbrowser':\n\t\t\t\tcase 'chrome':\n\t\t\t\tcase 'firefox':\n\t\t\t\tcase 'msie':\n\t\t\t\tcase 'opera':\n\t\t\t\tcase 'brave':\n\t\t\t\tcase 'vivaldi':\n\t\t\t\tcase 'outlook':\n\t\t\t\tcase 'safari':\n\t\t\t\tcase 'mail':\n\t\t\t\tcase 'edge':\n\t\t\t\tcase 'maxthon':\n\t\t\t\tcase 'electron':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'trident':\n\t\t\t\t\tdata.MSIE = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opr':\n\t\t\t\t\tdata.Opera = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tablet':\n\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data.MSIE) {\n\t\t\tdata.IE = 1;\n\t\t\tdelete data.MSIE;\n\t\t}\n\n\t\tif (data.WebOS || data.Android)\n\t\t\tdelete data.Linux;\n\n\t\tif (data.IEMobile) {\n\t\t\tif (data.Android)\n\t\t\t\tdelete data.Android;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t} else if (data.MSIE) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Edge) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Opera || data.Electron) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Chrome) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.SamsungBrowser)\n\t\t\t\tdelete data.SamsungBrowser;\n\t\t} else if (data.SamsungBrowser) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t}\n\n\t\tif (structured) {\n\t\t\tvar keys = Object.keys(data);\n\t\t\tvar output = { os: '', browser: '', device: 'desktop' };\n\n\t\t\tif (data.Tablet)\n\t\t\t\toutput.device = 'tablet';\n\t\t\telse if (data.Mobile)\n\t\t\t\toutput.device = 'mobile';\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar val = data[keys[i]];\n\t\t\t\tswitch (val) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\toutput.browser += (output.browser ? ' ' : '') + keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutput.os += (output.os ? ' ' : '') + keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\toutput.device = 'tv';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tuid = Object.keys(data).join(' ');\n\t}\n\n\treturn uid;\n};\n\nSP.parseCSV = function(delimiter) {\n\n\tif (!delimiter)\n\t\tdelimiter = ',';\n\n\tvar delimiterstring = '\"';\n\tvar t = this;\n\tvar scope;\n\tvar tmp = {};\n\tvar index = 1;\n\tvar data = [];\n\tvar current = 'a';\n\n\tfor (var i = 0; i < t.length; i++) {\n\t\tvar c = t[i];\n\n\t\tif (!scope) {\n\n\t\t\tif (c === '\\n' || c === '\\r') {\n\t\t\t\ttmp && data.push(tmp);\n\t\t\t\tindex = 1;\n\t\t\t\tcurrent = 'a';\n\t\t\t\ttmp = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === delimiter) {\n\t\t\t\tcurrent = String.fromCharCode(97 + index);\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (c === delimiterstring) {\n\t\t\t// Check escaped quotes\n\t\t\tif (scope && t[i + 1] === delimiterstring) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tscope = c === scope ? '' : c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!tmp)\n\t\t\ttmp = {};\n\n\t\tif (tmp[current])\n\t\t\ttmp[current] += c;\n\t\telse\n\t\t\ttmp[current] = c;\n\t}\n\n\ttmp && data.push(tmp);\n\treturn data;\n};\n\nSP.parseTerminal = function(fields, fn, skip, take) {\n\n\tvar lines = this.split('\\n');\n\n\tif (typeof(fields) === 'function') {\n\t\ttake = skip;\n\t\tskip = fn;\n\t\tfn = fields;\n\t\tparseTerminal2(lines, fn, skip, take);\n\t\treturn this;\n\t}\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tvar headers = [];\n\tvar indexer = 0;\n\tvar line = lines[0];\n\n\tif (!line) {\n\t\tline = lines[1];\n\t\tskip++;\n\t}\n\n\tif (!line) {\n\t\tline = lines[2];\n\t\tskip++;\n\t}\n\n\tif (!line)\n\t\treturn this;\n\n\tvar fieldslength = fields.length;\n\tvar tmp;\n\n\tfor (var i = 0, length = fieldslength; i < length; i++) {\n\t\tvar field = fields[i];\n\n\t\tvar beg = -1;\n\t\tvar end = -1;\n\t\tvar type = typeof(field);\n\n\t\tif (type === 'object' && field.test) {\n\t\t\ttmp = line.match(field);\n\t\t\tif (tmp) {\n\t\t\t\tbeg = tmp.index;\n\t\t\t\tend = beg + tmp.toString().length;\n\t\t\t} else {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t}\n\t\t} else if (type === 'string') {\n\t\t\ttmp = line.indexOf(field);\n\t\t\tif (tmp === -1) {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t} else {\n\t\t\t\tbeg = tmp;\n\t\t\t\tend = line.indexOf(' ', beg + field.length);\n\t\t\t}\n\t\t}\n\n\t\theaders.push({ beg: beg, end: end });\n\t}\n\n\tfor (var i = skip + 1, length = skip + 1 + take; i < length; i++) {\n\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\n\t\tvar arr = [];\n\t\tvar is = false;\n\t\tvar beg;\n\n\t\tfor (var j = 0; j < fieldslength; j++) {\n\t\t\tvar header = headers[j];\n\t\t\tif (header.beg !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbeg = 0;\n\n\t\t\t\tfor (var k = header.beg; k > -1; k--) {\n\t\t\t\t\tif (line[k] === ' ') {\n\t\t\t\t\t\tbeg = k + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tarr.push(line.substring(beg, header.end === -1 ? undefined : header.end).trim());\n\t\t\t} else\n\t\t\t\tarr.push('');\n\t\t}\n\n\t\tis && fn(arr, indexer++, length, i);\n\t}\n\n\treturn this;\n};\n\nfunction parseTerminal2(lines, fn, skip, take) {\n\tvar indexer = 0;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tfor (var i = skip, length = skip + take; i < length; i++) {\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\t\tvar m = line.match(regexpTERMINAL);\n\t\tm && fn(m, indexer++, length, i);\n\t}\n}\n\nfunction parseDateFormat(format, val) {\n\n\tvar tmp = [];\n\tvar tmpformat = [];\n\tvar prev = '';\n\tvar prevformat = '';\n\tvar allowed = { y: 1, Y: 1, M: 1, m: 1, d: 1, D: 1, H: 1, s: 1, a: 1, w: 1 };\n\n\tfor (var i = 0; i < format.length; i++) {\n\n\t\tvar c = format[i];\n\n\t\tif (!allowed[c])\n\t\t\tcontinue;\n\n\t\tif (prev !== c) {\n\t\t\tprevformat && tmpformat.push(prevformat);\n\t\t\tprevformat = c;\n\t\t\tprev = c;\n\t\t} else\n\t\t\tprevformat += c;\n\t}\n\n\tprev = '';\n\n\tfor (var i = 0; i < val.length; i++) {\n\t\tvar code = val.charCodeAt(i);\n\t\tif (code >= 48 && code <= 57)\n\t\t\tprev += val[i];\n\t}\n\n\tprevformat && tmpformat.push(prevformat);\n\n\tvar f = 0;\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar l = tmpformat[i].length;\n\t\ttmp.push(prev.substring(f, f + l));\n\t\tf += l;\n\t}\n\n\tvar dt = {};\n\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar type = tmpformat[i];\n\t\tif (tmp[i])\n\t\t\tdt[type[0]] = +tmp[i];\n\t}\n\n\tvar h = dt.h || dt.H;\n\n\tif (h != null) {\n\t\tvar ampm = val.match(REG_TIME);\n\t\tif (ampm && ampm[0].toLowerCase() === 'pm')\n\t\t\th += 12;\n\t}\n\n\treturn new Date((dt.y || dt.Y) || 0, (dt.M || 1) - 1, dt.d || dt.D || 0, h || 0, dt.m || 0, dt.s || 0);\n}\n\nSP.parseDate = function(format) {\n\n\tif (format)\n\t\treturn parseDateFormat(format, this);\n\n\tvar self = this.trim();\n\tvar lc = self.charCodeAt(self.length - 1);\n\n\t// Classic date\n\tif (lc === 41)\n\t\treturn new Date(self);\n\n\t// JSON format\n\tif (lc === 90)\n\t\treturn new Date(Date.parse(self));\n\n\tvar arr = self.indexOf(' ') === -1 ? self.split('T') : self.split(' ');\n\tvar index = arr[0].indexOf(':');\n\tvar length = arr[0].length;\n\n\tif (index !== -1) {\n\t\tvar tmp = arr[1];\n\t\tarr[1] = arr[0];\n\t\tarr[0] = tmp;\n\t}\n\n\tif (arr[0] === undefined)\n\t\tarr[0] = '';\n\n\tvar noTime = arr[1] === undefined ? true : arr[1].length === 0;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = arr[0].charCodeAt(i);\n\t\tif (c === 45 || c === 46 || (c > 47 && c < 58))\n\t\t\tcontinue;\n\t\tif (noTime)\n\t\t\treturn new Date(self);\n\t}\n\n\tif (arr[1] === undefined)\n\t\tarr[1] = '00:00:00';\n\n\tvar firstDay = arr[0].indexOf('-') === -1;\n\n\tvar date = (arr[0] || '').split(firstDay ? '.' : '-');\n\tvar time = (arr[1] || '').split(':');\n\tvar parsed = [];\n\n\tif (date.length < 4 && time.length < 2)\n\t\treturn new Date(self);\n\n\tindex = (time[2] || '').indexOf('.');\n\n\t// milliseconds\n\tif (index !== -1) {\n\t\ttime[3] = time[2].substring(index + 1);\n\t\ttime[2] = time[2].substring(0, index);\n\t} else\n\t\ttime[3] = '0';\n\n\tparsed.push(+date[firstDay ? 2 : 0]); // year\n\tparsed.push(+date[1]); // month\n\tparsed.push(+date[firstDay ? 0 : 2]); // day\n\tparsed.push(+time[0]); // hours\n\tparsed.push(+time[1]); // minutes\n\tparsed.push(+time[2]); // seconds\n\tparsed.push(+time[3]); // miliseconds\n\n\tvar def = new Date();\n\n\tfor (var i = 0, length = parsed.length; i < length; i++) {\n\t\tif (isNaN(parsed[i]))\n\t\t\tparsed[i] = 0;\n\n\t\tvar value = parsed[i];\n\t\tif (value !== 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getFullYear();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getMonth() + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getDate();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new Date(parsed[0], parsed[1] - 1, parsed[2], parsed[3], parsed[4] - NOW.getTimezoneOffset(), parsed[5]);\n};\n\nSP.parseDateExpiration = function() {\n\tvar self = this;\n\n\tvar arr = self.split(' ');\n\tvar dt = new Date();\n\tvar length = arr.length;\n\n\tfor (var i = 0; i < length; i += 2) {\n\t\tvar num = arr[i].parseInt();\n\t\tif (num === 0)\n\t\t\tcontinue;\n\t\tvar type = arr[i + 1];\n\t\tif (type)\n\t\t\tdt = dt.add(type, num);\n\t}\n\n\treturn dt;\n};\n\nSP.contains = function(value, mustAll) {\n\tvar str = this;\n\n\tif (typeof(value) === 'string')\n\t\treturn str.indexOf(value, typeof(mustAll) === 'number' ? mustAll : 0) !== -1;\n\n\tfor (var i = 0, length = value.length; i < length; i++) {\n\t\tvar exists = str.indexOf(value[i]) !== -1;\n\t\tif (mustAll) {\n\t\t\tif (!exists)\n\t\t\t\treturn false;\n\t\t} else if (exists)\n\t\t\treturn true;\n\t}\n\n\treturn mustAll;\n};\n\n/**\n * Same functionality as as String.localeCompare() but this method works with latin.\n * @param {String} value\n * @return {Number}\n */\nSP.localeCompare2 = function(value) {\n\treturn COMPARER(this, value);\n};\n\nvar configurereplace = function(text) {\n\tvar val = CONF[text.substring(1, text.length - 1)];\n\treturn val == null ? '' : val;\n};\n\nSP.env = function() {\n\treturn this.replace(regexpCONFIGURE, configurereplace);\n};\n\n/**\n * Parse configuration from a string\n * @param {Object} def\n * @onerr {Function} error handling\n * @return {Object}\n */\nSP.parseConfig = function(def, onerr) {\n\n\tif (typeof(def) === 'function') {\n\t\tonerr = def;\n\t\tdef = null;\n\t}\n\n\tvar arr = this.split('\\n');\n\tvar length = arr.length;\n\tvar obj = def ? exports.extend({}, def) : {};\n\tvar subtype;\n\tvar name;\n\tvar index;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 2) === '//')\n\t\t\tcontinue;\n\n\t\tindex = str.indexOf(':');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tname = str.substring(0, index).trim();\n\t\tvalue = str.substring(index + 2).trim();\n\n\t\tindex = name.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (subtype) {\n\t\t\tcase 'string':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'float':\n\t\t\tcase 'double':\n\t\t\tcase 'currency':\n\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\t\tobj[name] = CONF[value];\n\t\t\t\tbreak;\n\t\t\tcase 'eval':\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\ttry {\n\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onerr)\n\t\t\t\t\t\tonerr(e, arr[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error('A value of \"{0}\" can\\'t be converted to \"{1}\": '.format(name, subtype) + e.toString());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tobj[name] = value.parseJSON(true);\n\t\t\t\tbreak;\n\t\t\tcase 'env':\n\t\t\tcase 'environment':\n\t\t\t\tobj[name] = process.env[value];\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\tcase 'time':\n\t\t\tcase 'datetime':\n\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\tbreak;\n\t\t\tcase 'random':\n\t\t\t\tobj[name] = GUID((value || '0').parseInt() || 10);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.format = function() {\n\tvar arg = arguments;\n\treturn this.replace(regexpSTRINGFORMAT, function(text) {\n\t\tvar value = arg[+text.substring(1, text.length - 1)];\n\t\treturn value == null ? '' : value;\n\t});\n};\n\nSP.encryptUID = function(key) {\n\treturn exports.encryptUID(this, key);\n};\n\nSP.decryptUID = function(key) {\n\treturn exports.decryptUID(this, key);\n};\n\nSP.encode = function() {\n\tvar output = '';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i];\n\t\tswitch (c) {\n\t\t\tcase '<':\n\t\t\t\toutput += '&lt;';\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\toutput += '&gt;';\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\toutput += '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\toutput += '&apos;';\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\toutput += '&amp;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutput += c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn output;\n};\n\nSP.decode = function() {\n\treturn this.replace(regexpDECODE, function(s) {\n\t\tif (s.charAt(1) !== '#')\n\t\t\treturn ALPHA_INDEX[s] || s;\n\t\tvar code = s[2].toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));\n\t\treturn !code || code < -32768 || code > 65535 ? '' : String.fromCharCode(code);\n\t});\n};\n\nSP.urlEncode = function() {\n\treturn encodeURIComponent(this);\n};\n\nSP.urlDecode = function() {\n\treturn decodeURIComponent(this);\n};\n\nSP.arg = function(obj, encode, def) {\n\tif (typeof(encode) === 'string')\n\t\tdef = encode;\n\treturn this.replace(regexpARG, function(text) {\n\t\t// Is double?\n\t\tvar l = text[1] === '{' ? 2 : 1;\n\t\tvar val = obj[text.substring(l, text.length - l).trim()];\n\t\tif (encode && encode === 'json')\n\t\t\treturn JSON.stringify(val);\n\t\treturn val == null ? (def == null ? text : def) : encode ? encode === 'html' ? (val + '').encode() : encodeURIComponent(val + '') : val;\n\t});\n};\n\nSP.params = function(obj) {\n\n\tOBSOLETE('String.params()', 'The method is deprecated instead of it use F.viewCompile() or String.format().');\n\n\tvar formatted = this;\n\tif (obj == null)\n\t\treturn formatted;\n\n\treturn formatted.replace(regexpPARAM, function(prop) {\n\n\t\tvar isEncode = false;\n\t\tvar name = prop.substring(2, prop.length - 2).trim();\n\n\t\tvar format = '';\n\t\tvar index = name.indexOf('|');\n\n\t\tif (index !== -1) {\n\t\t\tformat = name.substring(index + 1, name.length).trim();\n\t\t\tname = name.substring(0, index).trim();\n\t\t}\n\n\t\tif (name[0] === '!')\n\t\t\tname = name.substring(1);\n\t\telse\n\t\t\tisEncode = true;\n\n\t\tvar val;\n\n\t\tif (name.indexOf('.') !== -1) {\n\t\t\tvar arr = name.split('.');\n\t\t\tif (arr.length === 2) {\n\t\t\t\tif (obj[arr[0]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]];\n\t\t\t} else if (arr.length === 3) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]];\n\t\t\t} else if (arr.length === 4) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]] && obj[arr[0]][arr[1]][arr[2]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]][arr[3]];\n\t\t\t} else if (arr.length === 5) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]] && obj[arr[0]][arr[1]][arr[2]] && obj[arr[0]][arr[1]][arr[2]][arr[3]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]][arr[3]][arr[4]];\n\t\t\t}\n\t\t} else\n\t\t\tval = name.length ? obj[name] : obj;\n\n\t\tif (typeof(val) === 'function')\n\t\t\tval = val(index);\n\n\t\tif (val === undefined)\n\t\t\treturn prop;\n\n\t\tif (format.length) {\n\t\t\tvar type = typeof(val);\n\t\t\tif (type === 'string') {\n\t\t\t\tvar max = +format;\n\t\t\t\tif (!isNaN(max))\n\t\t\t\t\tval = val.max(max + 3, '...');\n\n\t\t\t} else if (type === 'number' || exports.isDate(val)) {\n\t\t\t\tif (format.isNumber())\n\t\t\t\t\tformat = +format;\n\t\t\t\tval = val.format(format);\n\t\t\t}\n\t\t}\n\n\t\tval = val.toString();\n\t\treturn isEncode ? exports.encode(val) : val;\n\t});\n};\n\nSP.max = function(length, chars) {\n\tvar str = this;\n\tif (typeof(chars) !== 'string')\n\t\tchars = '...';\n\treturn str.length > length ? str.substring(0, length - chars.length) + chars : str;\n};\n\nSP.isJSON = function() {\n\tvar self = this;\n\tif (self.length <= 1)\n\t\treturn false;\n\n\tvar l = self.length - 1;\n\tvar a;\n\tvar b;\n\tvar i = 0;\n\n\twhile (true) {\n\t\ta = self[i++];\n\t\tif (a === ' ' || a === '\\n' || a === '\\r' || a === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\twhile (true) {\n\t\tb = self[l--];\n\t\tif (b === ' ' || b === '\\n' || b === '\\r' || b === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn (a === '\"' && b === '\"') || (a === '[' && b === ']') || (a === '{' && b === '}') || (a.charCodeAt(0) > 47 && b.charCodeAt(0) < 57);\n};\n\nSP.isURL = function() {\n\treturn this.length <= 7 ? false : F.validators.url.test(this);\n};\n\nSP.isZIP = function() {\n\treturn F.validators.zip.test(this);\n};\n\nSP.isEmail = function() {\n\treturn this.length <= 4 ? false : F.validators.email.test(this);\n};\n\nSP.isPhone = function() {\n\treturn this.length < 6 ? false : F.validators.phone.test(this);\n};\n\nSP.isBase64 = function() {\n\tvar str = this;\n\treturn str.length % 4 === 0 && regexpBASE64.test(str);\n};\n\nSP.isUID = function() {\n\tvar str = this;\n\n\tif (str.length < 12)\n\t\treturn false;\n\n\tvar is = DEF.validators.uid.test(str);\n\tif (is) {\n\n\t\tvar sum;\n\t\tvar beg;\n\t\tvar end;\n\t\tvar e = str[str.length - 1];\n\n\t\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = +str[str.length - 3];\n\t\t\tend = str.length - 5;\n\t\t\tvar tmp = e === 'c' || e === 'd' ? (+str.substring(beg, end)) : parseInt(str.substring(beg, end), 16);\n\t\t\treturn sum === (tmp % 2 ? '1' : '0');\n\t\t} else if (e === 'a') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = 6;\n\t\t\tend = str.length - 4;\n\t\t} else {\n\t\t\tsum = str[str.length - 1];\n\t\t\tbeg = 10;\n\t\t\tend = str.length - 4;\n\t\t}\n\n\t\twhile (beg++ < end) {\n\t\t\tif (str[beg] !== '0') {\n\t\t\t\tif (((+str.substring(beg, end)) % 2 ? '1' : '0') === sum)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nSP.parseUID = function() {\n\tvar self = this;\n\tvar obj = {};\n\tvar hash;\n\tvar e = self[self.length - 1];\n\n\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\tend = +self[self.length - 3];\n\t\tvar ticks = ((e === 'b' ? (+self.substring(0, end)) : parseInt(self.substring(0, end), e=== 'd' ? 36 : 16)) * 1000 * 60) + 1580511600000; // 1.1.2020\n\t\tobj.date = new Date(ticks);\n\t\tbeg = end;\n\t\tend = self.length - 5;\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else if (e === 'a') {\n\t\tvar ticks = ((+self.substring(0, 6)) * 1000 * 60) + 1548975600000; // old 1.1.2019\n\t\tobj.date = new Date(ticks);\n\t\tbeg = 7;\n\t\tend = self.length - 4;\n\t\thash = +self.substring(end + 2, end + 3);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else {\n\t\tvar y = self.substring(0, 2);\n\t\tvar M = self.substring(2, 4);\n\t\tvar d = self.substring(4, 6);\n\t\tvar H = self.substring(6, 8);\n\t\tvar m = self.substring(8, 10);\n\n\t\tobj.date = new Date(+('20' + y), (+M) - 1, +d, +H, +m, 0);\n\n\t\tvar beg = 0;\n\t\tvar end = 0;\n\t\tvar index = 10;\n\n\t\twhile (true) {\n\n\t\t\tvar c = self[index];\n\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\n\t\t\tif (!beg && c !== '0')\n\t\t\t\tbeg = index;\n\n\t\t\tif (c.charCodeAt(0) > 96) {\n\t\t\t\tend = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\n\t\tobj.century = self.substring(end + 4);\n\n\t\tif (obj.century) {\n\t\t\tobj.century = 20 + (+obj.century);\n\t\t\tobj.date.setYear(obj.date.getFullYear() + 100);\n\t\t} else\n\t\t\tobj.century = 21;\n\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.hash = self.substring(end, end + 3);\n\t}\n\n\tobj.index = +self.substring(beg, end);\n\tobj.valid = (obj.index % 2 ? 1 : 0) === hash;\n\treturn obj;\n};\n\nSP.parseENV = function() {\n\n\tvar arr = this.split(regexpLINES);\n\tvar obj = {};\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar line = arr[i];\n\t\tif (!line || line.substring(0, 2) === '//' || line[0] === '#')\n\t\t\tcontinue;\n\n\t\tvar index = line.indexOf('=');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar key = line.substring(0, index);\n\t\tvar val = line.substring(index + 1).replace(/\\\\n/g, '\\n');\n\t\tvar end = val.length - 1;\n\n\t\tif ((val[0] === '\"' && val[end] === '\"') || (val[0] === '\\'' && val[end] === '\\''))\n\t\t\tval = val.substring(1, end);\n\t\telse\n\t\t\tval = val.trim();\n\n\t\tobj[key] = val;\n\t}\n\n\treturn obj;\n};\n\nSP.parseInt = function(def) {\n\tvar str = this.trim();\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.parseInt2 = function(def) {\n\tvar num = this.match(regexpINTEGER);\n\treturn num ? +num[0] : (def === undefined ? 0 : def);\n};\n\nSP.parseFloat2 = function(def) {\n\tvar num = this.match(regexpFLOAT);\n\treturn num ? +num[0].toString().replace(/,/g, '.') : (def === undefined ? 0 : def);\n};\n\nSP.parseBool = SP.parseBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn self === 'true' || self === '1' || self === 'on';\n};\n\nSP.parseFloat = function(def) {\n\tvar str = this.trim();\n\tif (str.indexOf(',') !== -1)\n\t\tstr = str.replace(',', '.');\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.capitalize = function(first) {\n\n\tif (first)\n\t\treturn (this[0] || '').toUpperCase() + this.substring(1);\n\n\tvar builder = '';\n\tvar c;\n\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i - 1];\n\t\tif (!c || (c === ' ' || c === '\\t' || c === '\\n'))\n\t\t\tc = this[i].toUpperCase();\n\t\telse\n\t\t\tc = this[i];\n\t\tbuilder += c;\n\t}\n\n\treturn builder;\n};\n\nSP.toUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tvar c = this[i].charCodeAt(0);\n\t\tif(c > 126 || c < 32)\n\t\t\toutput += '\\\\u' + ('000' + c.toString(16)).substr(-4);\n\t\telse\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.fromUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tif (this[i] === '\\\\' && this[i + 1] === 'u') {\n\t\t\toutput += String.fromCharCode(parseInt(this[i + 2] + this[i + 3] + this[i + 4] + this[i + 5], 16));\n\t\t\ti += 5;\n\t\t} else\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.sha1 = function(salt) {\n\tvar hash = Crypto.createHash('sha1');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha256 = function(salt) {\n\tvar hash = Crypto.createHash('sha256');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha512 = function(salt) {\n\tvar hash = Crypto.createHash('sha512');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.md5 = function(salt) {\n\tvar hash = Crypto.createHash('md5');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.toSearch = function() {\n\tvar str = this.replace(regexpSEARCH, '').trim().toLowerCase().removeDiacritics();\n\tvar buf = [];\n\tvar prev = '';\n\tfor (var i = 0, length = str.length; i < length; i++) {\n\t\tvar c = str[i];\n\t\tif (c === 'y')\n\t\t\tc = 'i';\n\t\tif (c === prev)\n\t\t\tcontinue;\n\t\tprev = c;\n\t\tbuf.push(c);\n\t}\n\n\treturn buf.join('');\n};\n\nSP.toKeywords = SP.keywords = function(forSearch, alternative, max_count, max_length, min_length) {\n\treturn exports.keywords(this, forSearch, alternative, max_count, max_length, min_length);\n};\n\nfunction checksum(val) {\n\tvar sum = 0;\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\treturn sum;\n}\n\nSP.encrypt = function(key, isUnique, secret) {\n\tvar str = '0' + this;\n\tvar data_count = str.length;\n\tvar key_count = key.length;\n\tvar random = isUnique ? exports.random(120) + 40 : 65;\n\tvar count = data_count + (random % key_count);\n\tvar values = [];\n\tvar index = 0;\n\n\tvalues[0] = String.fromCharCode(random);\n\n\tvar counter = this.length + key.length;\n\n\tfor (var i = count - 1; i > 0; i--) {\n\t\tindex = str.charCodeAt(i % data_count);\n\t\tvalues[i] = String.fromCharCode(index ^ (key.charCodeAt(i % key_count) ^ random));\n\t}\n\n\tstr = Buffer.from(counter + '=' + values.join(''), ENCODING).toString('hex');\n\tvar sum = 0;\n\n\tfor (var i = 0; i < str.length; i++)\n\t\tsum += str.charCodeAt(i);\n\n\treturn (sum + checksum((secret || CONF.secret) + key)) + '-' + str;\n};\n\nSP.decrypt = function(key, secret) {\n\n\tvar index = this.indexOf('-');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar cs = +this.substring(0, index);\n\tif (!cs || isNaN(cs))\n\t\treturn null;\n\n\tvar hash = this.substring(index + 1);\n\tvar sum = checksum((secret || CONF.secret) + key);\n\tfor (var i = 0; i < hash.length; i++)\n\t\tsum += hash.charCodeAt(i);\n\n\tif (sum !== cs)\n\t\treturn null;\n\n\tvar values = Buffer.from(hash, 'hex').toString(ENCODING);\n\tvar index = values.indexOf('=');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar counter = +values.substring(0, index);\n\tif (isNaN(counter))\n\t\treturn null;\n\n\tvalues = values.substring(index + 1);\n\n\tvar count = values.length;\n\tvar random = values.charCodeAt(0);\n\tvar key_count = key.length;\n\tvar data_count = count - (random % key_count);\n\tvar decrypt_data = [];\n\n\tfor (var i = data_count - 1; i > 0; i--) {\n\t\tindex = values.charCodeAt(i) ^ (random ^ key.charCodeAt(i % key_count));\n\t\tdecrypt_data[i] = String.fromCharCode(index);\n\t}\n\n\tvar val = decrypt_data.join('');\n\treturn counter !== (val.length + key.length) ? null : val;\n};\n\nexports.encryptUID = function(val, key) {\n\n\tvar num = typeof(val) === 'number';\n\tvar sum = 0;\n\n\tif (!key)\n\t\tkey = CONF.secret;\n\n\tval = val + '';\n\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\n\tfor (var i = 0; i < key.length; i++)\n\t\tsum += key.charCodeAt(i);\n\n\treturn (num ? 'n' : 'x') + (CONF.secret_uid + val + sum + key).crc32(true).toString(16) + 'x' + val;\n};\n\nexports.decryptUID = function(val, key) {\n\tvar num = val[0] === 'n';\n\tvar raw = val.substring(val.indexOf('x', 1) + 1);\n\n\tif (num)\n\t\traw = +raw;\n\n\treturn exports.encryptUID(raw, key) === val ? raw : null;\n};\n\nSP.base64ToFile = function(filename, callback) {\n\tvar self = this;\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\tFs.writeFile(filename, self.substring(index), 'base64', callback || exports.noop);\n\treturn this;\n};\n\nSP.base64ToBuffer = function() {\n\tvar self = this;\n\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\n\treturn Buffer.from(self.substring(index), 'base64');\n};\n\nSP.base64ContentType = function() {\n\tvar self = this;\n\tvar index = self.indexOf(';');\n\treturn index === -1 ? '' : self.substring(5, index);\n};\n\nSP.removeDiacritics = function() {\n\treturn exports.removeDiacritics(this);\n};\n\nSP.indent = function(max, c) {\n\tvar plus = '';\n\tif (c === undefined)\n\t\tc = ' ';\n\twhile (max--)\n\t\tplus += c;\n\treturn plus + this;\n};\n\nSP.isNumber = function(isDecimal) {\n\n\tvar self = this;\n\tvar length = self.length;\n\n\tif (!length)\n\t\treturn false;\n\n\tisDecimal = isDecimal || false;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar ascii = self.charCodeAt(i);\n\n\t\tif (isDecimal) {\n\t\t\tif (ascii === 44 || ascii === 46) {\n\t\t\t\tisDecimal = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ascii < 48 || ascii > 57)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nif (!SP.padLeft) {\n\tSP.padLeft = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself = c + self;\n\t\treturn self;\n\t};\n}\n\n\nif (!SP.padRight) {\n\tSP.padRight = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself += c;\n\t\treturn self;\n\t};\n}\n\nSP.insert = function(index, value) {\n\tvar str = this;\n\tvar a = str.substring(0, index);\n\tvar b = value.toString() + str.substring(index);\n\treturn a + b;\n};\n\n/**\n * Create a link from String\n * @param  {Number} max A maximum length, default: 60 and optional.\n * @return {String}\n */\nSP.slug = SP.toSlug = SP.toLinker = SP.linker = function(max) {\n\tmax = max || 60;\n\n\tvar self = this.trim().toLowerCase().removeDiacritics();\n\tvar builder = '';\n\tvar length = self.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = self[i];\n\t\tvar code = self.charCodeAt(i);\n\n\t\tif (code > 540){\n\t\t\tbuilder = '';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (builder.length >= max)\n\t\t\tbreak;\n\n\t\tif (code > 31 && code < 48) {\n\t\t\tif (builder[builder.length - 1] !== '-')\n\t\t\t\tbuilder += '-';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((code > 47 && code < 58) || (code > 94 && code < 123))\n\t\t\tbuilder += c;\n\t}\n\n\tif (builder.length > 1) {\n\t\tlength = builder.length - 1;\n\t\treturn builder[length] === '-' ? builder.substring(0, length) : builder;\n\t} else if (!length)\n\t\treturn '';\n\n\tlength = self.length;\n\tself = self.replace(/\\s/g, '');\n\tbuilder = self.crc32(true).toString(36) + '';\n\treturn self[0].charCodeAt(0).toString(32) + builder + self[self.length - 1].charCodeAt(0).toString(32) + length;\n};\n\nSP.pluralize = function(zero, one, few, other) {\n\treturn this.parseInt().pluralize(zero, one, few, other);\n};\n\nSP.isBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn (self === 'true' || self === 'false') ? true : false;\n};\n\n/**\n * Check if the string contains only letters and numbers.\n * @return {Boolean}\n */\nSP.isAlphaNumeric = function() {\n\treturn regexpALPHA.test(this);\n};\n\nSP.soundex = function() {\n\n\tvar arr = this.toLowerCase().split('');\n\tvar first = arr.shift();\n\tvar builder = first.toUpperCase();\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar v = SOUNDEX[arr[i]];\n\t\tif (v === undefined)\n\t\t\tcontinue;\n\t\tif (i) {\n\t\t\tif (v !== arr[i - 1])\n\t\t\t\tbuilder += v;\n\t\t} else if (v !== SOUNDEX[first])\n\t\t\tbuilder += v;\n\t}\n\n\treturn (builder + '000').substring(0, 4);\n};\n\n/**\n* Remove all Html Tags from a string\n* @return {string}\n*/\nSP.removeTags = function() {\n\treturn this.replace(regexpTags, '');\n};\n\nNP.floor = function(decimals) {\n\treturn Math.floor(this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n};\n\nNP.fixed = function(decimals) {\n\treturn +this.toFixed(decimals);\n};\n\nNP.padLeft = function(max, c) {\n\treturn this.toString().padLeft(max, c || '0');\n};\n\nNP.padRight = function(max, c) {\n\treturn this.toString().padRight(max, c || '0');\n};\n\nNP.round = function(precision) {\n\tvar m = Math.pow(10, precision) || 1;\n\treturn Math.round(this * m) / m;\n};\n\nNP.currency = function(currency, a, b, c) {\n\tvar curr = DEF.currencies[currency];\n\treturn curr ? curr(this, a, b, c) : this.format(2);\n};\n\n/**\n * Async decrements\n * @param {Function(index, next)} fn\n * @param {Function} callback\n * @return {Number}\n */\nNP.async = function(fn, callback) {\n\tvar number = this;\n\tif (number)\n\t\tfn(number--, () => setImmediate(() => number.async(fn, callback)));\n\telse\n\t\tcallback && callback();\n\treturn number;\n};\n\n/**\n * Format number\n * @param {Number} decimals Maximum decimal numbers\n * @param {String} separator Number separator, default ' '\n * @param {String} separatorDecimal Decimal separator, default '.' if number separator is ',' or ' '.\n * @return {String}\n */\nNP.format = function(decimals, separator, separatorDecimal) {\n\n\tvar self = this;\n\n\tif (typeof(decimals) === 'string')\n\t\treturn self.format2(decimals);\n\n\tvar num = self.toString();\n\tvar dec = '';\n\tvar output = '';\n\tvar minus = num[0] === '-' ? '-' : '';\n\tif (minus)\n\t\tnum = num.substring(1);\n\n\tvar index = num.indexOf('.');\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = separator;\n\t\tseparator = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tif (separator === undefined)\n\t\tseparator = ' ';\n\n\tif (index !== -1) {\n\t\tdec = num.substring(index + 1);\n\t\tnum = num.substring(0, index);\n\t}\n\n\tindex = -1;\n\tfor (var i = num.length - 1; i >= 0; i--) {\n\t\tindex++;\n\t\tif (index > 0 && index % 3 === 0)\n\t\t\toutput = separator + output;\n\t\toutput = num[i] + output;\n\t}\n\n\tif (decimals || dec.length) {\n\t\tif (dec.length > decimals)\n\t\t\tdec = dec.substring(0, decimals || 0);\n\t\telse\n\t\t\tdec = dec.padRight(decimals || 0, '0');\n\t}\n\n\tif (dec.length && separatorDecimal === undefined)\n\t\tseparatorDecimal = separator === '.' ? ',' : '.';\n\n\treturn minus + output + (dec.length ? separatorDecimal + dec : '');\n};\n\nNP.add = function(value, decimals) {\n\n\tif (value == null)\n\t\treturn this;\n\n\tif (typeof(value) === 'number')\n\t\treturn this + value;\n\n\tvar first = value.charCodeAt(0);\n\tvar is = false;\n\n\tif (first < 48 || first > 57) {\n\t\tis = true;\n\t\tvalue = value.substring(1);\n\t}\n\n\tvar length = value.length;\n\tvar num;\n\n\tif (value[length - 1] === '%') {\n\t\tvalue = value.substring(0, length - 1);\n\t\tif (is) {\n\t\t\tvar val = value.parseFloat();\n\t\t\tswitch (first) {\n\t\t\t\tcase 42:\n\t\t\t\t\tnum = this * ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 43:\n\t\t\t\t\tnum = this + ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 45:\n\t\t\t\t\tnum = this - ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 47:\n\t\t\t\t\tnum = this / ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t} else {\n\t\t\tnum = (this / 100) * value.parseFloat();\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t}\n\n\t} else\n\t\tnum = value.parseFloat();\n\n\tswitch (first) {\n\t\tcase 42:\n\t\t\tnum = this * num;\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tnum = this + num;\n\t\t\tbreak;\n\t\tcase 45:\n\t\t\tnum = this - num;\n\t\t\tbreak;\n\t\tcase 47:\n\t\t\tnum = this / num;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum = this;\n\t\t\tbreak;\n\t}\n\n\tif (decimals !== undefined)\n\t\treturn num.floor(decimals);\n\n\treturn num;\n};\n\nNP.format2 = function(format) {\n\tvar index = 0;\n\tvar num = this.toString();\n\tvar beg = 0;\n\tvar end = 0;\n\tvar max = 0;\n\tvar output = '';\n\tvar length = 0;\n\n\tif (typeof(format) === 'string') {\n\n\t\tvar d = false;\n\t\tlength = format.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar c = format[i];\n\t\t\tif (c === '#') {\n\t\t\t\tif (d)\n\t\t\t\t\tend++;\n\t\t\t\telse\n\t\t\t\t\tbeg++;\n\t\t\t}\n\n\t\t\tif (c === '.')\n\t\t\t\td = true;\n\t\t}\n\n\t\tvar strBeg = num;\n\t\tvar strEnd = '';\n\n\t\tindex = num.indexOf('.');\n\n\t\tif (index !== -1) {\n\t\t\tstrBeg = num.substring(0, index);\n\t\t\tstrEnd = num.substring(index + 1);\n\t\t}\n\n\t\tif (strBeg.length > beg) {\n\t\t\tmax = strBeg.length - beg;\n\t\t\tvar tmp = '';\n\t\t\tfor (var i = 0; i < max; i++)\n\t\t\t\ttmp += '#';\n\n\t\t\tformat = tmp + format;\n\t\t}\n\n\t\tif (strBeg.length < beg)\n\t\t\tstrBeg = strBeg.padLeft(beg, ' ');\n\n\t\tif (strEnd.length < end)\n\t\t\tstrEnd = strEnd.padRight(end, '0');\n\n\t\tif (strEnd.length > end)\n\t\t\tstrEnd = strEnd.substring(0, end);\n\n\t\td = false;\n\t\tindex = 0;\n\n\t\tvar skip = true;\n\t\tlength = format.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tvar c = format[i];\n\n\t\t\tif (c !== '#') {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (c === '.') {\n\t\t\t\t\td = true;\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\n\t\t\t\toutput += c;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar value = d ? strEnd[index] : strBeg[index];\n\n\t\t\tif (skip)\n\t\t\t\tskip = [',', ' '].indexOf(value) !== -1;\n\n\t\t\tif (!skip)\n\t\t\t\toutput += value;\n\n\t\t\tindex++;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\toutput = '### ### ###';\n\tbeg = num.indexOf('.');\n\tmax = format || 0;\n\n\tif (max === 0 && beg !== -1)\n\t\tmax = num.length - (beg + 1);\n\n\tif (max > 0) {\n\t\toutput += '.';\n\t\tfor (var i = 0; i < max; i++)\n\t\t\toutput += '#';\n\t}\n\n\treturn this.format(output);\n};\n\nNP.pluralize = function(zero, one, few, other) {\n\n\tvar num = this;\n\tvar value = '';\n\n\tif (num == 0)\n\t\tvalue = zero || '';\n\telse if (num == 1)\n\t\tvalue = one || '';\n\telse if (num > 1 && num < 5)\n\t\tvalue = few || '';\n\telse\n\t\tvalue = other;\n\n\tvar beg = value.indexOf('#');\n\tif (beg === -1)\n\t\treturn value;\n\n\tvar end = value.lastIndexOf('#');\n\tvar format = value.substring(beg, end + 1);\n\treturn num.format(format) + value.replace(format, '');\n};\n\nNP.hex = function(length) {\n\tvar str = this.toString(16).toUpperCase();\n\twhile(str.length < length)\n\t\tstr = '0' + str;\n\treturn str;\n};\n\nNP.VAT = function(percentage, decimals, includedVAT) {\n\tvar num = this;\n\tvar type = typeof(decimals);\n\n\tif (type === 'boolean') {\n\t\tvar tmp = includedVAT;\n\t\tincludedVAT = decimals;\n\t\tdecimals = tmp;\n\t\ttype = typeof(decimals);\n\t}\n\n\tif (type === 'undefined')\n\t\tdecimals = 2;\n\n\tif (includedVAT === undefined)\n\t\tincludedVAT = true;\n\n\tif (!percentage || !num)\n\t\treturn num;\n\treturn includedVAT ? (num / ((percentage / 100) + 1)).round(decimals) : (num * ((percentage / 100) + 1)).round(decimals);\n};\n\nNP.discount = function(percentage, decimals) {\n\tvar num = this;\n\tif (decimals === undefined)\n\t\tdecimals = 2;\n\treturn (num - (num / 100) * percentage).floor(decimals);\n};\n\nNP.parseDate = function(plus) {\n\treturn new Date(this + (plus || 0));\n};\n\nif (!NP.toRad) {\n\tNP.toRad = function () {\n\t\treturn this * Math.PI / 180;\n\t};\n}\n\n\nNP.filesize = function(decimals, type) {\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = type;\n\t\ttype = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tvar value;\n\n\t// this === bytes\n\tswitch (type) {\n\t\tcase 'bytes':\n\t\t\tvalue = this;\n\t\t\tbreak;\n\t\tcase 'KB':\n\t\t\tvalue = this / 1024;\n\t\t\tbreak;\n\t\tcase 'MB':\n\t\t\tvalue = filesizehelper(this, 2);\n\t\t\tbreak;\n\t\tcase 'GB':\n\t\t\tvalue = filesizehelper(this, 3);\n\t\t\tbreak;\n\t\tcase 'TB':\n\t\t\tvalue = filesizehelper(this, 4);\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\ttype = 'bytes';\n\t\t\tvalue = this;\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'KB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'MB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'GB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'TB';\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\ttype = ' ' + type;\n\treturn (decimals === undefined ? value.format(2).replace('.00', '') : value.format(decimals)) + type;\n};\n\nfunction filesizehelper(number, count) {\n\twhile (count--) {\n\t\tnumber = number / 1024;\n\t\tif (number.toFixed(3) === '0.000')\n\t\t\treturn 0;\n\t}\n\treturn number;\n}\n\nvar AP = Array.prototype;\n\n/**\n * Take items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.take = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tarr.push(self[i]);\n\t\tif (arr.length >= count)\n\t\t\treturn arr;\n\t}\n\treturn arr;\n};\n\n/**\n * Extend objects in Array\n * @param {Object} obj\n * @param {Boolean} rewrite Default: false.\n * @return {Array} Returns self\n */\nAP.extend = function(obj, rewrite) {\n\tvar isFn = typeof(obj) === 'function';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tif (isFn)\n\t\t\tthis[i] = obj(this[i], i);\n\t\telse\n\t\t\tthis[i] = exports.extend(this[i], obj, rewrite);\n\t}\n\treturn this;\n};\n\n/**\n * First item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.first = function(def) {\n\tvar item = this[0];\n\treturn item === undefined ? def : item;\n};\n\n/**\n * Create object from Array\n * @param {String} name Optional, property name.\n * @return {Object}\n */\nAP.toObject = function(name) {\n\n\tvar self = this;\n\tvar obj = {};\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tvar item = self[i];\n\t\tif (name)\n\t\t\tobj[item[name]] = item;\n\t\telse\n\t\t\tobj[item] = true;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Compare two arrays\n * @param {String} id An identificator.\n * @param {Array} b Second array.\n * @param {Function(itemA, itemB, indexA, indexB)} executor\n */\nAP.compare = function(id, b, executor) {\n\n\tvar a = this;\n\tvar ak = {};\n\tvar bk = {};\n\tvar al = a.length;\n\tvar bl = b.length;\n\tvar tl = Math.max(al, bl);\n\tvar processed = {};\n\n\tfor (var i = 0; i < tl; i++) {\n\t\tvar av = a[i];\n\t\tif (av)\n\t\t\tak[av[id]] = i;\n\t\tvar bv = b[i];\n\t\tif (bv)\n\t\t\tbk[bv[id]] = i;\n\t}\n\n\tvar index = -1;\n\n\tfor (var i = 0; i < tl; i++) {\n\n\t\tvar av = a[i];\n\t\tvar bv = b[i];\n\t\tvar akk;\n\t\tvar bkk;\n\n\t\tif (av) {\n\t\t\takk = av[id];\n\t\t\tif (processed[akk])\n\t\t\t\tcontinue;\n\t\t\tprocessed[akk] = true;\n\t\t\tindex = bk[akk];\n\t\t\tif (index === undefined)\n\t\t\t\texecutor(av, undefined, i, -1);\n\t\t\telse\n\t\t\t\texecutor(av, b[index], i, index);\n\t\t}\n\n\t\tif (bv) {\n\t\t\tbkk = bv[id];\n\t\t\tif (processed[bkk])\n\t\t\t\tcontinue;\n\t\t\tprocessed[bkk] = true;\n\t\t\tindex = ak[bkk];\n\t\t\tif (index === undefined)\n\t\t\t\texecutor(undefined, bv, -1, i);\n\t\t\telse\n\t\t\t\texecutor(a[index], bv, index, i);\n\t\t}\n\t}\n\n\tOBSOLETE('Array.compare()', 'Use U.diff() insteadof Array.compare()');\n};\n\n/**\n * Pair arrays\n * @param {Array} arr\n * @param {String} property\n * @param {Function(itemA, itemB)} fn Paired items (itemA == this, itemB == arr)\n * @param {Boolean} remove Optional, remove item from this array if the item doesn't exist int arr (default: false).\n * @return {Array}\n */\nAP.pair = function(property, arr, fn, remove) {\n\n\tif (property instanceof Array) {\n\t\tvar tmp = property;\n\t\tproperty = arr;\n\t\tarr = tmp;\n\t}\n\n\tif (!arr)\n\t\tarr = new Array(0);\n\n\tvar length = arr.length;\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar item = this[index++];\n\t\tif (!item)\n\t\t\tbreak;\n\n\t\tvar is = false;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (item[property] !== arr[i][property])\n\t\t\t\tcontinue;\n\t\t\tfn(item, arr[i]);\n\t\t\tis = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is || !remove)\n\t\t\tcontinue;\n\n\t\tindex--;\n\t\tthis.splice(index, 1);\n\t}\n\n\tOBSOLETE('Array.pair()', 'The method will be removed in Total.js v4');\n\treturn this;\n};\n\n/**\n * Last item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.last = function(def) {\n\tvar item = this[this.length - 1];\n\treturn item === undefined ? def : item;\n};\n\nAP.quicksort = AP.orderBy = function(name, asc) {\n\n\tvar length = this.length;\n\tif (!length || length === 1)\n\t\treturn this;\n\n\tif (typeof(name) === 'boolean') {\n\t\tasc = name;\n\t\tname = undefined;\n\t} else if (asc === undefined)\n\t\tasc = true;\n\telse {\n\t\tswitch (asc) {\n\t\t\tcase 'asc':\n\t\t\tcase 'ASC':\n\t\t\t\tasc = true;\n\t\t\t\tbreak;\n\t\t\tcase 'desc':\n\t\t\tcase 'DESC':\n\t\t\t\tasc = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar self = this;\n\tvar type = 0;\n\tvar field = name ? self[0][name] : self[0];\n\n\tswitch (typeof(field)) {\n\t\tcase 'string':\n\t\t\tif (field.isJSONDate())\n\t\t\t\ttype = 4;\n\t\t\telse\n\t\t\t\ttype = 1;\n\t\t\tbreak;\n\t\tcase 'number':\n\t\t\ttype = 2;\n\t\t\tbreak;\n\t\tcase 'boolean':\n\t\t\ttype = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!exports.isDate(field))\n\t\t\t\treturn self;\n\t\t\ttype = 4;\n\t\t\tbreak;\n\t}\n\n\tshellsort(self, function(a, b) {\n\n\t\tvar va = name ? a[name] : a;\n\t\tvar vb = name ? b[name] : b;\n\n\t\t// String\n\t\tif (type === 1) {\n\t\t\treturn va && vb ? (asc ? COMPARER(va, vb) : COMPARER(vb, va)) : 0;\n\t\t} else if (type === 2) {\n\t\t\treturn va > vb ? (asc ? 1 : -1) : va < vb ? (asc ? -1 : 1) : 0;\n\t\t} else if (type === 3) {\n\t\t\treturn va === true && vb === false ? (asc ? 1 : -1) : va === false && vb === true ? (asc ? -1 : 1) : 0;\n\t\t} else if (type === 4) {\n\t\t\tif (!va || !vb)\n\t\t\t\treturn 0;\n\t\t\tif (!va.getTime)\n\t\t\t\tva = new Date(va);\n\t\t\tif (!vb.getTime)\n\t\t\t\tvb = new Date(vb);\n\t\t\tvar at = va.getTime();\n\t\t\tvar bt = vb.getTime();\n\t\t\treturn at > bt ? (asc ? 1 : -1) : at < bt ? (asc ? -1 : 1) : 0;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn self;\n};\n\nAP.trim = function() {\n\tvar self = this;\n\tvar output = [];\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tif (typeof(self[i]) === 'string')\n\t\t\tself[i] = self[i].trim();\n\t\tself[i] && output.push(self[i]);\n\t}\n\treturn output;\n};\n\n/**\n * Skip items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.skip = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++)\n\t\ti >= count && arr.push(self[i]);\n\treturn arr;\n};\n\n/**\n * Find items in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.where = AP.findAll = function(cb, value) {\n\n\tvar self = this;\n\tvar selected = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tcb.call(self, self[i], i) && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] === value && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] === cb && selected.push(self[i]);\n\t}\n\n\treturn selected;\n};\n\n/**\n * Find item in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.findItem = function(cb, value) {\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nvar arrfindobsolete;\n\nAP.find = function(cb, value) {\n\n\tif (!arrfindobsolete) {\n\t\tarrfindobsolete = true;\n\t\tOBSOLETE('Array.prototype.find()', 'will be removed in v4, use alternative \"Array.prototype.findItem()\"');\n\t}\n\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nAP.findIndex = function(cb, value) {\n\n\tvar self = this;\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tif (cb.call(self, self[i], i))\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tif (self[i] && self[i][cb] === value)\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (self[i] === cb)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n};\n\n/**\n * Remove items from Array\n * @param {Function(item, index) or Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.remove = function(cb, value) {\n\n\tvar self = this;\n\tvar arr = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\t!cb.call(self, self[i], i) && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] !== value && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] !== cb && arr.push(self[i]);\n\t}\n\treturn arr;\n};\n\nAP.wait = AP.waitFor = function(onItem, callback, thread, tmp) {\n\n\tvar self = this;\n\tvar init = false;\n\n\t// INIT\n\tif (!tmp) {\n\n\t\tif (typeof(callback) !== 'function') {\n\t\t\tthread = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\ttmp = {};\n\t\ttmp.pending = 0;\n\t\ttmp.index = 0;\n\t\ttmp.thread = thread;\n\n\t\t// thread === Boolean then array has to be removed item by item\n\n\t\tinit = true;\n\t}\n\n\tvar item = thread === true ? self.shift() : self[tmp.index++];\n\tif (item === undefined) {\n\t\tif (!tmp.pending) {\n\t\t\tcallback && callback();\n\t\t\ttmp.cancel = true;\n\t\t}\n\t\treturn self;\n\t}\n\n\ttmp.pending++;\n\tonItem.call(self, item, () => setImmediate(next_wait, self, onItem, callback, thread, tmp), tmp.index);\n\n\tif (!init || tmp.thread === 1)\n\t\treturn self;\n\n\tfor (var i = 1; i < tmp.thread; i++)\n\t\tself.wait(onItem, callback, 1, tmp);\n\n\treturn self;\n};\n\nfunction next_wait(self, onItem, callback, thread, tmp) {\n\ttmp.pending--;\n\tself.wait(onItem, callback, thread, tmp);\n}\n\n/**\n * Creates a function async list\n * @param {Function} callback Optional\n * @return {Array}\n */\nAP.async = function(thread, callback, pending) {\n\n\tvar self = this;\n\n\tif (typeof(thread) === 'function') {\n\t\tcallback = thread;\n\t\tthread = 1;\n\t} else if (thread === undefined)\n\t\tthread = 1;\n\n\tif (pending === undefined)\n\t\tpending = 0;\n\n\tvar item = self.shift();\n\tif (item === undefined) {\n\t\tif (!pending) {\n\t\t\tpending = undefined;\n\t\t\tcallback && callback();\n\t\t}\n\t\treturn self;\n\t}\n\n\tfor (var i = 0; i < thread; i++) {\n\n\t\tif (i)\n\t\t\titem = self.shift();\n\n\t\tpending++;\n\t\titem(function() {\n\t\t\tsetImmediate(function() {\n\t\t\t\tpending--;\n\t\t\t\tself.async(1, callback, pending);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn self;\n};\n\nAP.randomize = function() {\n\tOBSOLETE('Array.randomize()', 'Use Array.random().');\n\treturn this.random();\n};\n\n// Fisher-Yates shuffle\nAP.random = function() {\n\tfor (var i = this.length - 1; i > 0; i--) {\n\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\tvar temp = this[i];\n\t\tthis[i] = this[j];\n\t\tthis[j] = temp;\n\t}\n\treturn this;\n};\n\nAP.limit = function(max, fn, callback, index) {\n\n\tif (index === undefined)\n\t\tindex = 0;\n\n\tvar current = [];\n\tvar self = this;\n\tvar length = index + max;\n\n\tfor (var i = index; i < length; i++) {\n\t\tvar item = self[i];\n\n\t\tif (item !== undefined) {\n\t\t\tcurrent.push(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!current.length) {\n\t\t\tcallback && callback();\n\t\t\treturn self;\n\t\t}\n\n\t\tfn(current, () => callback && callback(), index, index + max);\n\t\treturn self;\n\t}\n\n\tif (!current.length) {\n\t\tcallback && callback();\n\t\treturn self;\n\t}\n\n\tfn(current, function() {\n\t\tif (length < self.length)\n\t\t\tself.limit(max, fn, callback, length);\n\t\telse\n\t\t\tcallback && callback();\n\t}, index, index + max);\n\n\treturn self;\n};\n\n/**\n * Get unique elements from Array\n * @return {[type]} [description]\n */\nAP.unique = function(property) {\n\n\tvar self = this;\n\tvar result = [];\n\tvar sublength = 0;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tvar value = self[i];\n\n\t\tif (!property) {\n\t\t\tresult.indexOf(value) === -1 && result.push(value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sublength === 0) {\n\t\t\tresult.push(value);\n\t\t\tsublength++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar is = true;\n\t\tfor (var j = 0; j < sublength; j++) {\n\t\t\tif (result[j][property] === value[property]) {\n\t\t\t\tis = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is) {\n\t\t\tresult.push(value);\n\t\t\tsublength++;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nArrayBuffer.prototype.toBuffer = function() {\n\tvar buf = new Buffer(this.byteLength);\n\tvar view = new Uint8Array(this);\n\tfor (var i = 0, length = buf.length; i < length; ++i)\n\t\tbuf[i] = view[i];\n\treturn buf;\n};\n\nfunction AsyncTask(owner, name, fn, cb, waiting) {\n\tthis.isRunning = 0;\n\tthis.owner = owner;\n\tthis.name = name;\n\tthis.fn = fn;\n\tthis.cb = cb;\n\tthis.waiting = waiting;\n\tthis.interval = null;\n\tthis.isCanceled = false;\n}\n\nAsyncTask.prototype.run = function() {\n\tvar self = this;\n\ttry\n\t{\n\n\t\tif (self.isCanceled) {\n\t\t\tself.complete();\n\t\t\treturn self;\n\t\t}\n\n\t\tself.isRunning = 1;\n\t\tself.owner.tasksWaiting[self.name] = true;\n\t\tself.owner.emit('begin', self.name);\n\n\t\tvar timeout = self.owner.tasksTimeout[self.name];\n\t\tif (timeout > 0)\n\t\t\tself.interval = setTimeout(function() { self.timeout(); }, timeout);\n\n\t\tself.fn(function() {\n\t\t\tsetImmediate(() => self.complete());\n\t\t});\n\n\t} catch (ex) {\n\t\tself.owner.emit('error', self.name, ex);\n\t\tself.complete();\n\t}\n\treturn self;\n};\n\nAsyncTask.prototype.timeout = function(timeout) {\n\n\tvar self = this;\n\n\tif (timeout > 0) {\n\t\tclearTimeout(self.interval);\n\t\tsetTimeout(function() { self.timeout(); }, timeout);\n\t\treturn self;\n\t}\n\n\tif (timeout <= 0) {\n\t\tclearTimeout(self.interval);\n\t\tsetTimeout(function() { self.timeout(); }, timeout);\n\t\treturn self;\n\t}\n\n\tsetImmediate(() => self.cancel(true));\n\treturn self;\n};\n\nAsyncTask.prototype.cancel = function(isTimeout) {\n\tvar self = this;\n\n\tself.isCanceled = true;\n\n\tif (isTimeout)\n\t\tself.owner.emit('timeout', self.name);\n\telse\n\t\tself.owner.emit('cancel', self.name);\n\n\tself.fn = null;\n\tself.cb = null;\n\tself.complete();\n\treturn self;\n};\n\nAsyncTask.prototype.complete = function() {\n\n\tvar item = this;\n\tvar self = item.owner;\n\n\titem.isRunning = 2;\n\n\tdelete self.tasksPending[item.name];\n\tdelete self.tasksWaiting[item.name];\n\n\tif (!item.isCanceled) {\n\t\ttry\n\t\t{\n\t\t\tself.emit('end', item.name);\n\t\t\titem.cb && item.cb();\n\t\t} catch (ex) {\n\t\t\tself.emit('error', ex, item.name);\n\t\t}\n\t}\n\n\tsetImmediate(function() {\n\t\tself.reload();\n\t\tself.refresh();\n\t});\n\n\treturn self;\n};\n\nfunction Async(owner) {\n\n\tthis._max = 0;\n\tthis._count = 0;\n\tthis._isRunning = false;\n\tthis._isEnd = false;\n\n\tthis.owner = owner;\n\tthis.onComplete = [];\n\n\tthis.tasksPending = {};\n\tthis.tasksWaiting = {};\n\tthis.tasksAll = [];\n\tthis.tasksTimeout = {};\n\tthis.isCanceled = false;\n\n\tEvents.EventEmitter.call(this);\n}\n\nAsync.prototype = {\n\tget count() {\n\t\treturn this._count;\n\t},\n\n\tget percentage() {\n\t\tvar p = 100 - Math.floor((this._count * 100) / this._max);\n\t\treturn p ? p : 0;\n\t}\n};\n\nconst ACP = Async.prototype;\n\nACP.__proto__ = Object.create(Events.EventEmitter.prototype, {\n\tconstructor: {\n\t\tvalue: Async,\n\t\tenumberable: false\n\t}\n});\n\nACP.reload = function() {\n\tvar self = this;\n\tself.tasksAll = Object.keys(self.tasksPending);\n\tself.emit('percentage', self.percentage);\n\treturn self;\n};\n\nACP.cancel = function(name) {\n\n\tvar self = this;\n\n\tif (name === undefined) {\n\t\tself.isCanceled = true;\n\t\tfor (var i = 0; i < self._count; i++)\n\t\t\tself.cancel(self.tasksAll[i]);\n\t\treturn true;\n\t}\n\n\tvar task = self.tasksPending[name];\n\tif (!task)\n\t\treturn false;\n\n\tdelete self.tasksPending[name];\n\tdelete self.tasksWaiting[name];\n\n\ttask.cancel();\n\ttask = null;\n\tself.reload();\n\tself.refresh();\n\n\treturn true;\n};\n\nACP.await = function(name, fn, cb) {\n\n\tvar self = this;\n\n\tif (self.isCanceled)\n\t\treturn false;\n\n\tif (typeof(name) === 'function') {\n\t\tcb = fn;\n\t\tfn = name;\n\t\tname = exports.GUID(6);\n\t}\n\n\tif (self.tasksPending[name])\n\t\treturn false;\n\n\tself.tasksPending[name] = new AsyncTask(self, name, fn, cb, null);\n\tself._max++;\n\tself.reload();\n\tself.refresh();\n\treturn true;\n};\n\nACP.wait = function(name, waitingFor, fn, cb) {\n\n\tvar self = this;\n\n\tif (self.isCanceled)\n\t\treturn false;\n\n\tif (typeof(waitingFor) === 'function') {\n\t\tcb = fn;\n\t\tfn = waitingFor;\n\t\twaitingFor = null;\n\t}\n\n\tif (self.tasksPending[name])\n\t\treturn false;\n\n\tself.tasksPending[name] = new AsyncTask(self, name, fn, cb, waitingFor);\n\tself._max++;\n\tself.reload();\n\tself.refresh();\n\treturn true;\n};\n\nACP.complete = function(fn) {\n\treturn this.run(fn);\n};\n\nACP.run = function(fn) {\n\tthis._isRunning = true;\n\tfn && this.onComplete.push(fn);\n\tthis.refresh();\n\treturn this;\n};\n\nACP.isRunning = function(name) {\n\tif (!name)\n\t\treturn this._isRunning;\n\tvar task = this.tasksPending[name];\n\treturn task ? task.isRunning === 1 : false;\n};\n\nACP.isWaiting = function(name) {\n\tvar task = this.tasksPending[name];\n\treturn task ? task.isRunning === 0 : false;\n};\n\nACP.isPending = function(name) {\n\treturn this.tasksPending[name] ? true : false;\n};\n\nACP.timeout = function(name, timeout) {\n\tif (timeout)\n\t\tthis.tasksTimeout[name] = timeout;\n\telse\n\t\tthis.tasksTimeout[name] = undefined;\n\treturn this;\n};\n\nACP.refresh = function(name) {\n\n\tvar self = this;\n\n\tif (!self._isRunning || self._isEnd)\n\t\treturn self;\n\n\tself._count = self.tasksAll.length;\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar name = self.tasksAll[index++];\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tvar task = self.tasksPending[name];\n\t\tif (!task)\n\t\t\tbreak;\n\n\t\tif (self.isCanceled || task.isCanceled) {\n\t\t\tdelete self.tasksPending[name];\n\t\t\tdelete self.tasksWaiting[name];\n\t\t\tself.tasksAll.splice(index, 1);\n\t\t\tself._count = self.tasksAll.length;\n\t\t\tindex--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (task.isRunning !== 0 || (task.waiting && self.tasksPending[task.waiting]))\n\t\t\tcontinue;\n\n\t\ttask.run();\n\t}\n\n\tif (self._count === 0) {\n\t\tself._isRunning = false;\n\t\tself._isEnd = true;\n\t\tself.emit('complete');\n\t\tself.emit('percentage', 100);\n\t\tself._max = 0;\n\t\tvar complete = self.onComplete;\n\t\tvar length = complete.length;\n\t\tself.onComplete = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcomplete[i]();\n\t\t\t} catch (ex) {\n\t\t\t\tself.emit('error', ex);\n\t\t\t}\n\t\t}\n\t\tsetImmediate(() => self._isEnd = false);\n\t}\n\n\treturn self;\n};\n\nfunction FileList() {\n\tthis.pending = [];\n\tthis.pendingDirectory = [];\n\tthis.directory = [];\n\tthis.file = [];\n\tthis.onComplete = null;\n\tthis.onFilter = null;\n\tthis.advanced = false;\n}\n\nconst FLP = FileList.prototype;\n\nFLP.reset = function() {\n\tthis.file.length = 0;\n\tthis.directory.length = 0;\n\tthis.pendingDirectory.length = 0;\n\treturn this;\n};\n\nFLP.walk = function(directory) {\n\n\tvar self = this;\n\n\tif (directory instanceof Array) {\n\t\tvar length = directory.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pendingDirectory.push(directory[i]);\n\t\tself.next();\n\t\treturn;\n\t}\n\n\tFs.readdir(directory, function(err, arr) {\n\t\tif (err)\n\t\t\treturn self.next();\n\t\tvar length = arr.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pending.push(Path.join(directory, arr[i]));\n\t\tself.next();\n\t});\n};\n\nFLP.stat = function(path) {\n\tvar self = this;\n\n\tFs.stat(path, function(err, stats) {\n\n\t\tif (err)\n\t\t\treturn self.next();\n\n\t\tif (stats.isDirectory()) {\n\t\t\tpath = self.clean(path);\n\t\t\tif (!self.onFilter || self.onFilter(path, true)) {\n\t\t\t\tself.directory.push(path);\n\t\t\t\tself.pendingDirectory.push(path);\n\t\t\t}\n\t\t} else if (!self.onFilter || self.onFilter(path, false))\n\t\t\tself.file.push(self.advanced ? { filename: path, stats: stats } : path);\n\n\t\tself.next();\n\t});\n};\n\nFLP.clean = function(path) {\n\treturn path[path.length - 1] === Path.sep ? path : path + Path.sep;\n};\n\nFLP.next = function() {\n\tvar self = this;\n\n\tif (self.pending.length) {\n\t\tvar item = self.pending.shift();\n\t\tself.stat(item);\n\t\treturn;\n\t}\n\n\tif (self.pendingDirectory.length) {\n\t\tvar directory = self.pendingDirectory.shift();\n\t\tself.walk(directory);\n\t\treturn;\n\t}\n\n\tself.onComplete(self.file, self.directory);\n};\n\nexports.Async = Async;\n\nexports.sync = function(fn, owner) {\n\treturn function() {\n\n\t\tvar args = [].slice.call(arguments);\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t};\n};\n\nexports.sync2 = function(fn, owner) {\n\treturn (function() {\n\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\t\tvar args = [].slice.call(arguments);\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t})();\n};\n\nexports.async = function(fn, isApply) {\n\tvar context = this;\n\treturn function(complete) {\n\n\t\tvar self = this;\n\t\tvar argv;\n\n\t\tif (arguments.length) {\n\n\t\t\tif (isApply) {\n\t\t\t\t// index.js/Subscribe.prototype.doExecute\n\t\t\t\targv = arguments[1];\n\t\t\t} else {\n\t\t\t\targv = [];\n\t\t\t\tfor (var i = 1; i < arguments.length; i++)\n\t\t\t\t\targv.push(arguments[i]);\n\t\t\t}\n\t\t} else\n\t\t\targv = new Array(0);\n\n\t\tvar generator = fn.apply(context, argv);\n\t\tnext(null);\n\n\t\tfunction next(err, result) {\n\n\t\t\tvar g, type;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar can = err ? false : true;\n\t\t\t\tswitch (can) {\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tg = generator.next(result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tg = generator.throw(err);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\n\t\t\t\tif (!complete)\n\t\t\t\t\treturn;\n\n\t\t\t\ttype = typeof(complete);\n\n\t\t\t\tif (type === 'object' && complete.isController) {\n\t\t\t\t\tif (e instanceof ErrorBuilder)\n\t\t\t\t\t\tcomplete.content(e);\n\t\t\t\t\telse\n\t\t\t\t\t\tcomplete.view500(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttype === 'function' && setImmediate(() => complete(e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (g.done) {\n\t\t\t\ttypeof(complete) === 'function' && complete(null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar promise = g.value instanceof Promise;\n\n\t\t\tif (typeof(g.value) !== 'function' && !promise) {\n\t\t\t\tnext.call(self, null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (promise) {\n\t\t\t\t\tg.value.then((value) => next.call(self, null, value));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tg.value.call(self, function() {\n\t\t\t\t\tnext.apply(self, arguments);\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tsetImmediate(() => next.call(self, e));\n\t\t\t}\n\t\t}\n\n\t\treturn generator.value;\n\t};\n};\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nconst CACHE_GML1 = [null, null, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nconst CACHE_GML2 = [null, null, null, null, null, null, null, null];\nexports.getMessageLength = function(data, isLE) {\n\n\tvar length = data[1] & 0x7f;\n\n\tif (length === 126) {\n\t\tif (data.length < 4)\n\t\t\treturn -1;\n\t\tCACHE_GML1[0] = data[3];\n\t\tCACHE_GML1[1] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML1, 0, isLE);\n\t}\n\n\tif (length === 127) {\n\t\tif (data.Length < 10)\n\t\t\treturn -1;\n\t\tCACHE_GML2[0] = data[9];\n\t\tCACHE_GML2[1] = data[8];\n\t\tCACHE_GML2[2] = data[7];\n\t\tCACHE_GML2[3] = data[6];\n\t\tCACHE_GML2[4] = data[5];\n\t\tCACHE_GML2[5] = data[4];\n\t\tCACHE_GML2[6] = data[3];\n\t\tCACHE_GML2[7] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML2, 0, isLE);\n\t}\n\n\treturn length;\n};\n\n// MIT\n// Written by Jozef Gula\nfunction converBytesToInt64(data, startIndex, isLE) {\n\treturn isLE ? (data[startIndex] | (data[startIndex + 1] << 0x08) | (data[startIndex + 2] << 0x10) | (data[startIndex + 3] << 0x18) | (data[startIndex + 4] << 0x20) | (data[startIndex + 5] << 0x28) | (data[startIndex + 6] << 0x30) | (data[startIndex + 7] << 0x38)) : ((data[startIndex + 7] << 0x20) | (data[startIndex + 6] << 0x28) | (data[startIndex + 5] << 0x30) | (data[startIndex + 4] << 0x38) | (data[startIndex + 3]) | (data[startIndex + 2] << 0x08) | (data[startIndex + 1] << 0x10) | (data[startIndex] << 0x18));\n}\n\nexports.queuecache = {};\n\nfunction queue_next(name) {\n\n\tvar item = exports.queuecache[name];\n\tif (!item)\n\t\treturn;\n\n\titem.running--;\n\n\tif (item.running < 0)\n\t\titem.running = 0;\n\n\tif (item.pending.length) {\n\t\tvar fn = item.pending.shift();\n\t\tif (fn) {\n\t\t\titem.running++;\n\t\t\tsetImmediate(queue_next_callback, fn, name);\n\t\t} else\n\t\t\titem.running = 0;\n\t}\n}\n\nfunction queue_next_callback(fn, name) {\n\tfn(() => queue_next(name));\n}\n\n/**\n * Queue list\n * @param {String} name\n * @param {Number} max Maximum stack.\n * @param {Function(next)} fn\n */\nexports.queue = function(name, max, fn) {\n\n\tif (!fn)\n\t\treturn false;\n\n\tif (!max) {\n\t\tfn(NOOP);\n\t\treturn true;\n\t}\n\n\tif (!exports.queuecache[name])\n\t\texports.queuecache[name] = { limit: max, running: 0, pending: [] };\n\n\tvar item = exports.queuecache[name];\n\tif (item.running >= item.limit) {\n\t\titem.pending.push(fn);\n\t\treturn false;\n\t}\n\n\titem.running++;\n\tsetImmediate(queue_next_callback, fn, name);\n\treturn true;\n};\n\nexports.minifyStyle = function(val) {\n\treturn Internal.compile_css(val);\n};\n\nexports.minifyScript = function(val) {\n\treturn Internal.compile_javascript(val);\n};\n\nexports.minifyHTML = function(val) {\n\treturn Internal.compile_html(val);\n};\n\nexports.parseTheme = function(value) {\n\tif (value[0] !== '=')\n\t\treturn '';\n\tvar index = value.indexOf('/', 2);\n\tif (index === -1)\n\t\treturn '';\n\tvalue = value.substring(1, index);\n\treturn value === '?' ? CONF.default_theme : value;\n};\n\nexports.set = function(obj, path, value) {\n\tvar cachekey = 'S+' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj, value);\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0; i < arr.length - 1; i++) {\n\t\tvar type = arr[i + 1] ? (REGISARR.test(arr[i + 1]) ? '[]' : '{}') : '{}';\n\t\tvar p = 'w' + (arr[i][0] === '[' ? '' : '.') + arr[i];\n\t\tbuilder.push('if(typeof(' + p + ')!==\\'object\\'||' + p + '==null)' + p + '=' + type + ';');\n\t}\n\n\tvar v = arr[arr.length - 1];\n\tvar ispush = v.lastIndexOf('[]') !== -1;\n\tvar a = builder.join(';') + ';var v=typeof(a)===\\'function\\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';\n\tvar fn = new Function('w', 'a', 'b', a);\n\tF.temporary.other[cachekey] = fn;\n\tfn(obj, value, path);\n};\n\nexports.get = function(obj, path) {\n\n\tvar cachekey = 'G=' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj);\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0, length = arr.length - 1; i < length; i++)\n\t\tbuilder.push('if(!w' + (!arr[i] || arr[i][0] === '[' ? '' : '.') + arr[i] + ')return');\n\n\tvar v = arr[arr.length - 1];\n\tvar fn = (new Function('w', builder.join(';') + ';return w' + (v[0] === '[' ? '' : '.') + v));\n\tF.temporary.other[cachekey] = fn;\n\treturn fn(obj);\n};\n\nfunction parsepath(path) {\n\n\tvar arr = path.split('.');\n\tvar builder = [];\n\tvar all = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar p = arr[i];\n\t\tvar index = p.indexOf('[');\n\t\tif (index === -1) {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tvar a = all.splice(all.length - 1);\n\t\t\t\tall.push(a + '[\\'' + p + '\\']');\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t}\n\t\t} else {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p.substring(0, index));\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t\tall.splice(all.length - 1);\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tall.push('[\\'' + p.substring(0, index) + '\\']');\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t\tall.push(p.substring(index));\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn builder;\n}\n\nglobal.Async = global.async = exports.async;\nglobal.sync = global.SYNCHRONIZE = exports.sync;\nglobal.sync2 = exports.sync2;\n\n// =============================================\n// SHELL SORT IMPLEMENTATION OF ALGORITHM\n// =============================================\n\nfunction _shellInsertionSort(list, length, gapSize, fn) {\n\tvar temp, i, j;\n\tfor (i = gapSize; i < length; i += gapSize ) {\n\t\tj = i;\n\t\twhile(j > 0 && fn(list[j - gapSize], list[j]) === 1) {\n\t\t\ttemp = list[j];\n\t\t\tlist[j] = list[j - gapSize];\n\t\t\tlist[j - gapSize] = temp;\n\t\t\tj -= gapSize;\n\t\t}\n\t}\n}\n\nfunction shellsort(arr, fn) {\n\tvar length = arr.length;\n\tvar gapSize = Math.floor(length / 2);\n\twhile(gapSize) {\n\t\t_shellInsertionSort(arr, length, gapSize, fn);\n\t\tgapSize = Math.floor(gapSize / 2);\n\t}\n\treturn arr;\n}\n\nfunction EventEmitter2(obj) {\n\tif (obj) {\n\t\t!obj.emit && EventEmitter2.extend(obj);\n\t\treturn obj;\n\t} else\n\t\tthis.$events = {};\n}\n\nconst EE2P = EventEmitter2.prototype;\n\nEE2P.emit = function(name, a, b, c, d, e, f, g) {\n\n\tif (!this.$events)\n\t\treturn this;\n\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.on = function(name, fn) {\n\tif (!this.$events)\n\t\tthis.$events = {};\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nEE2P.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nEE2P.removeListener = function(name, fn) {\n\tif (this.$events) {\n\t\tvar evt = this.$events[name];\n\t\tif (evt) {\n\t\t\tevt = evt.remove(n => n === fn);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.removeAllListeners = function(name) {\n\tif (this.$events) {\n\t\tif (name === true)\n\t\t\tthis.$events = EMPTYOBJECT;\n\t\telse if (name)\n\t\t\tthis.$events[name] = undefined;\n\t\telse\n\t\t\tthis.$events = {};\n\t}\n\treturn this;\n};\n\nEventEmitter2.extend = function(obj) {\n\tobj.emit = EE2P.emit;\n\tobj.on = EE2P.on;\n\tobj.once = EE2P.once;\n\tobj.removeListener = EE2P.removeListener;\n\tobj.removeAllListeners = EE2P.removeAllListeners;\n};\n\nexports.EventEmitter2 = EventEmitter2;\n\nfunction Chunker(name, max) {\n\tthis.name = name;\n\tthis.max = max || 50;\n\tthis.index = 0;\n\tthis.filename = '{0}-'.format(name);\n\tthis.stack = [];\n\tthis.flushing = 0;\n\tthis.pages = 0;\n\tthis.count = 0;\n\tthis.percentage = 0;\n\tthis.autoremove = true;\n\tthis.compress = true;\n\tthis.filename = F.path.temp(this.filename);\n}\n\nconst CHP = Chunker.prototype;\n\nCHP.append = CHP.write = function(obj) {\n\tvar self = this;\n\n\tself.stack.push(obj);\n\n\tvar tmp = self.stack.length;\n\n\tif (tmp >= self.max) {\n\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.end = function() {\n\tvar self = this;\n\tvar tmp = self.stack.length;\n\tif (tmp) {\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.each = function(onItem, onEnd, indexer) {\n\n\tvar self = this;\n\n\tif (indexer == null) {\n\t\tself.percentage = 0;\n\t\tindexer = 0;\n\t}\n\n\tif (indexer >= self.index)\n\t\treturn onEnd && onEnd();\n\n\tself.read(indexer++, function(err, items) {\n\t\tself.percentage = Math.ceil((indexer / self.pages) * 100);\n\t\tonItem(items, () => self.each(onItem, onEnd, indexer), indexer - 1);\n\t});\n\n\treturn self;\n};\n\nCHP.read = function(index, callback) {\n\tvar self = this;\n\n\tif (self.flushing) {\n\t\tself.flushing_timeout = setTimeout(() => self.read(index, callback), 300);\n\t\treturn;\n\t}\n\n\tvar filename = self.filename + index + '.chunker';\n\n\tFs.readFile(filename, function(err, data) {\n\n\t\tif (err) {\n\t\t\tcallback(null, EMPTYARRAY);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.compress) {\n\t\t\tZlib.inflate(data, function(err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(null, EMPTYARRAY);\n\t\t\t\t} else {\n\t\t\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t}\n\t});\n\n\treturn self;\n};\n\nCHP.clear = function() {\n\tvar files = [];\n\tfor (var i = 0; i < this.index; i++)\n\t\tfiles.push(this.filename + i + '.chunker');\n\tfiles.wait((filename, next) => Fs.unlink(filename, next));\n\treturn this;\n};\n\nCHP.destroy = function() {\n\tthis.clear();\n\tthis.indexer = 0;\n\tthis.flushing = 0;\n\tclearTimeout(this.flushing_timeout);\n\tthis.stack = null;\n\treturn this;\n};\n\nexports.chunker = function(name, max) {\n\treturn new Chunker(name, max);\n};\n\nexports.Chunker = Chunker;\n\nexports.ObjectToArray = function(obj) {\n\tif (obj == null)\n\t\treturn EMPTYARRAY;\n\tvar keys = Object.keys(obj);\n\tvar output = [];\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toutput.push({ key: keys[i], value: obj[keys[i]]});\n\treturn output;\n};\n\nif (NODEVERSION > 699) {\n\texports.createBufferSize = (size) => Buffer.alloc(size || 0);\n\texports.createBuffer = (val, type) => Buffer.from(val || '', type);\n} else {\n\texports.createBufferSize = (size) => new Buffer(size || 0);\n\texports.createBuffer = (val, type) => new Buffer(val || '', type);\n}\n\nfunction Callback(count, callback) {\n\tthis.pending = count;\n\tthis.$callback = callback;\n}\nconst CP = Callback.prototype;\n\nCP.done = function(callback) {\n\tthis.$callback = callback;\n\treturn this;\n};\n\nCP.next = function() {\n\tvar self = this;\n\tself.pending--;\n\tif (!self.pending && self.$callback) {\n\t\tself.$callback();\n\t\tself.$callback = null;\n\t}\n\treturn self;\n};\n\nglobal.Callback = Callback;\n\nexports.Callback = function(count, callback) {\n\treturn new Callback(count, callback);\n};\n\nfunction Reader() {\n\tvar t = this;\n\tt.$add = function(builder) {\n\t\tif (t.reader)\n\t\t\tt.reader.add(builder);\n\t\telse\n\t\t\tt.reader = new framework_nosql.NoSQLReader(builder);\n\t};\n}\nconst RP = Reader.prototype;\n\nRP.done = function() {\n\tvar self = this;\n\tself.reader.done();\n\treturn self;\n};\n\nRP.reset = function() {\n\tvar self = this;\n\tself.reader.reset();\n\treturn self;\n};\n\nRP.push = function(data) {\n\tif (data == null)\n\t\tthis.reader.done();\n\telse\n\t\tthis.reader.compare(data instanceof Array ? data : [data]);\n\treturn this;\n};\n\nRP.find = function() {\n\tvar self = this;\n\tvar builder = new framework_nosql.DatabaseBuilder();\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.count = function() {\n\tvar builder = this.find();\n\tbuilder.$options.readertype = 1;\n\treturn builder;\n};\n\nRP.scalar = function(type, field) {\n\treturn this.find().scalar(type, field);\n};\n\nexports.reader = function() {\n\treturn new Reader();\n};\n\nconst BUFEMPTYJSON = Buffer.from('{}');\n\nglobal.WAIT = exports.wait;\n!global.F && require('./index');\n"], "fixing_code": ["// Copyright 2012-2020 (c) Peter \u0160irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkUtils\n * @version 3.4.4\n */\n\n'use strict';\n\nconst Dns = require('dns');\nconst Url = require('url');\nconst Qs = require('querystring');\nconst Http = require('http');\nconst Https = require('https');\nconst Path = require('path');\nconst Fs = require('fs');\nconst Events = require('events');\nconst Crypto = require('crypto');\nconst Zlib = require('zlib');\nconst Tls = require('tls');\nconst KeepAlive = new Http.Agent({ keepAlive: true, timeout: 60000 });\n\nconst COMPRESS = { gzip: 1, deflate: 1 };\nconst CONCAT = [null, null];\nconst COMPARER = global.Intl ? global.Intl.Collator().compare : function(a, b) {\n\treturn a.removeDiacritics().localeCompare(b.removeDiacritics());\n};\n\nif (!global.framework_utils)\n\tglobal.framework_utils = exports;\n\nconst Internal = require('./internal');\nvar regexpSTATIC = /\\.\\w{2,8}($|\\?)+/;\nconst regexpTRIM = /^[\\s]+|[\\s]+$/g;\nconst regexpDATE = /(\\d{1,2}\\.\\d{1,2}\\.\\d{4})|(\\d{4}-\\d{1,2}-\\d{1,2})|(\\d{1,2}:\\d{1,2}(:\\d{1,2})?)/g;\nconst regexpDATEFORMAT = /YYYY|yyyy|YY|yy|MMMM|MMM|MM|M|dddd|DDDD|DDD|ddd|DD|dd|D|d|HH|H|hh|h|mm|m|ss|s|a|ww|w/g;\nconst regexpSTRINGFORMAT = /\\{\\d+\\}/g;\nconst regexpPATH = /\\\\/g;\nconst regexpTags = /<\\/?[^>]+(>|$)/g;\nconst regexpDiacritics = /[^\\u0000-\\u007e]/g;\nconst regexpUA = /[a-z]+/gi;\nconst regexpXML = /\\w+=\".*?\"/g;\nconst regexpDECODE = /&#?[a-z0-9]+;/g;\nconst regexpPARAM = /\\{{2}[^}\\n]*\\}{2}/g;\nconst regexpARG = /\\{{1,2}[a-z0-9_.-\\s]+\\}{1,2}/gi;\nconst regexpINTEGER = /(^-|\\s-)?[0-9]+/g;\nconst regexpFLOAT = /(^-|\\s-)?[0-9.,]+/g;\nconst regexpALPHA = /^[A-Za-z0-9]+$/;\nconst regexpSEARCH = /[^a-zA-Z\u00e1-\u017e\u00c1-\u017d\\d\\s:]/g;\nconst regexpTERMINAL = /[\\w\\S]+/g;\nconst regexpCONFIGURE = /\\[\\w+\\]/g;\nconst regexpY = /y/g;\nconst regexpN = /\\n/g;\nconst regexpCHARS = /\\W|_/g;\nconst regexpCHINA = /[\\u3400-\\u9FBF]/;\nconst regexpLINES = /\\n|\\r|\\r\\n/;\nconst regexpBASE64 = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst SOUNDEX = { a: '', e: '', i: '', o: '', u: '', b: 1, f: 1, p: 1, v: 1, c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2, d: 3, t: 3, l: 4, m: 5, n: 5, r: 6 };\nconst ENCODING = 'utf8';\nconst NEWLINE = '\\r\\n';\nconst isWindows = require('os').platform().substring(0, 3).toLowerCase() === 'win';\nconst DIACRITICSMAP = {};\nconst STREAM_READONLY = { flags: 'r' };\nconst STREAM_END = { end: false };\nconst ALPHA_INDEX = { '&lt': '<', '&gt': '>', '&quot': '\"', '&apos': '\\'', '&amp': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"', '&apos;': '\\'', '&amp;': '&' };\nconst NODEVERSION = parseFloat(process.version.toString().replace('v', '').replace(/\\./g, ''));\nconst STREAMPIPE = { end: false };\nconst CT = 'Content-Type';\nconst CRC32TABLE = '00000000,77073096,EE0E612C,990951BA,076DC419,706AF48F,E963A535,9E6495A3,0EDB8832,79DCB8A4,E0D5E91E,97D2D988,09B64C2B,7EB17CBD,E7B82D07,90BF1D91,1DB71064,6AB020F2,F3B97148,84BE41DE,1ADAD47D,6DDDE4EB,F4D4B551,83D385C7,136C9856,646BA8C0,FD62F97A,8A65C9EC,14015C4F,63066CD9,FA0F3D63,8D080DF5,3B6E20C8,4C69105E,D56041E4,A2677172,3C03E4D1,4B04D447,D20D85FD,A50AB56B,35B5A8FA,42B2986C,DBBBC9D6,ACBCF940,32D86CE3,45DF5C75,DCD60DCF,ABD13D59,26D930AC,51DE003A,C8D75180,BFD06116,21B4F4B5,56B3C423,CFBA9599,B8BDA50F,2802B89E,5F058808,C60CD9B2,B10BE924,2F6F7C87,58684C11,C1611DAB,B6662D3D,76DC4190,01DB7106,98D220BC,EFD5102A,71B18589,06B6B51F,9FBFE4A5,E8B8D433,7807C9A2,0F00F934,9609A88E,E10E9818,7F6A0DBB,086D3D2D,91646C97,E6635C01,6B6B51F4,1C6C6162,856530D8,F262004E,6C0695ED,1B01A57B,8208F4C1,F50FC457,65B0D9C6,12B7E950,8BBEB8EA,FCB9887C,62DD1DDF,15DA2D49,8CD37CF3,FBD44C65,4DB26158,3AB551CE,A3BC0074,D4BB30E2,4ADFA541,3DD895D7,A4D1C46D,D3D6F4FB,4369E96A,346ED9FC,AD678846,DA60B8D0,44042D73,33031DE5,AA0A4C5F,DD0D7CC9,5005713C,270241AA,BE0B1010,C90C2086,5768B525,206F85B3,B966D409,CE61E49F,5EDEF90E,29D9C998,B0D09822,C7D7A8B4,59B33D17,2EB40D81,B7BD5C3B,C0BA6CAD,EDB88320,9ABFB3B6,03B6E20C,74B1D29A,EAD54739,9DD277AF,04DB2615,73DC1683,E3630B12,94643B84,0D6D6A3E,7A6A5AA8,E40ECF0B,9309FF9D,0A00AE27,7D079EB1,F00F9344,8708A3D2,1E01F268,6906C2FE,F762575D,806567CB,196C3671,6E6B06E7,FED41B76,89D32BE0,10DA7A5A,67DD4ACC,F9B9DF6F,8EBEEFF9,17B7BE43,60B08ED5,D6D6A3E8,A1D1937E,38D8C2C4,4FDFF252,D1BB67F1,A6BC5767,3FB506DD,48B2364B,D80D2BDA,AF0A1B4C,36034AF6,41047A60,DF60EFC3,A867DF55,316E8EEF,4669BE79,CB61B38C,BC66831A,256FD2A0,5268E236,CC0C7795,BB0B4703,220216B9,5505262F,C5BA3BBE,B2BD0B28,2BB45A92,5CB36A04,C2D7FFA7,B5D0CF31,2CD99E8B,5BDEAE1D,9B64C2B0,EC63F226,756AA39C,026D930A,9C0906A9,EB0E363F,72076785,05005713,95BF4A82,E2B87A14,7BB12BAE,0CB61B38,92D28E9B,E5D5BE0D,7CDCEFB7,0BDBDF21,86D3D2D4,F1D4E242,68DDB3F8,1FDA836E,81BE16CD,F6B9265B,6FB077E1,18B74777,88085AE6,FF0F6A70,66063BCA,11010B5C,8F659EFF,F862AE69,616BFFD3,166CCF45,A00AE278,D70DD2EE,4E048354,3903B3C2,A7672661,D06016F7,4969474D,3E6E77DB,AED16A4A,D9D65ADC,40DF0B66,37D83BF0,A9BCAE53,DEBB9EC5,47B2CF7F,30B5FFE9,BDBDF21C,CABAC28A,53B39330,24B4A3A6,BAD03605,CDD70693,54DE5729,23D967BF,B3667A2E,C4614AB8,5D681B02,2A6F2B94,B40BBE37,C30C8EA1,5A05DF1B,2D02EF8D'.split(',').map(s => parseInt(s, 16));\nconst REGISARR = /\\[\\d+\\]|\\[\\]$/;\nconst REGREPLACEARR = /\\[\\]/g;\nconst PROXYBLACKLIST = { 'localhost': 1, '127.0.0.1': 1, '0.0.0.0': 1 };\nconst PROXYOPTIONS = { headers: {}, method: 'CONNECT', agent: false };\nconst PROXYTLS = { headers: {}};\nconst PROXYOPTIONSHTTP = {};\nconst REG_ROOT = /@\\{#\\}(\\/)?/g;\nconst REG_NOREMAP = /@\\{noremap\\}(\\n)?/g;\nconst REG_REMAP = /href=\".*?\"|src=\".*?\"/gi;\nconst REG_AJAX = /('|\")+(!)?(GET|POST|PUT|DELETE|PATCH)\\s(\\(.*?\\)\\s)?\\//g;\nconst REG_URLEXT = /(https|http|wss|ws|file):\\/\\/|\\/\\/[a-z0-9]|[a-z]:/i;\nconst REG_TEXTAPPLICATION = /text|application/i;\nconst REG_TIME = /am|pm/i;\nconst REG_XMLKEY = /\\[|\\]|:|\\.|_/g;\n\nexports.MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nexports.DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\nvar DIACRITICS=[{b:' ',c:'\\u00a0'},{b:'0',c:'\\u07c0'},{b:'A',c:'\\u24b6\\uff21\\u00c0\\u00c1\\u00c2\\u1ea6\\u1ea4\\u1eaa\\u1ea8\\u00c3\\u0100\\u0102\\u1eb0\\u1eae\\u1eb4\\u1eb2\\u0226\\u01e0\\u00c4\\u01de\\u1ea2\\u00c5\\u01fa\\u01cd\\u0200\\u0202\\u1ea0\\u1eac\\u1eb6\\u1e00\\u0104\\u023a\\u2c6f'},{b:'AA',c:'\\ua732'},{b:'AE',c:'\\u00c6\\u01fc\\u01e2'},{b:'AO',c:'\\ua734'},{b:'AU',c:'\\ua736'},{b:'AV',c:'\\ua738\\ua73a'},{b:'AY',c:'\\ua73c'},{b:'B',c:'\\u24b7\\uff22\\u1e02\\u1e04\\u1e06\\u0243\\u0181'},{b:'C',c:'\\u24b8\\uff23\\ua73e\\u1e08\\u0106C\\u0108\\u010a\\u010c\\u00c7\\u0187\\u023b'},{b:'D',c:'\\u24b9\\uff24\\u1e0a\\u010e\\u1e0c\\u1e10\\u1e12\\u1e0e\\u0110\\u018a\\u0189\\u1d05\\ua779'},{b:'Dh',c:'\\u00d0'},{b:'DZ',c:'\\u01f1\\u01c4'},{b:'Dz',c:'\\u01f2\\u01c5'},{b:'E',c:'\\u025b\\u24ba\\uff25\\u00c8\\u00c9\\u00ca\\u1ec0\\u1ebe\\u1ec4\\u1ec2\\u1ebc\\u0112\\u1e14\\u1e16\\u0114\\u0116\\u00cb\\u1eba\\u011a\\u0204\\u0206\\u1eb8\\u1ec6\\u0228\\u1e1c\\u0118\\u1e18\\u1e1a\\u0190\\u018e\\u1d07'},{b:'F',c:'\\ua77c\\u24bb\\uff26\\u1e1e\\u0191\\ua77b'}, {b:'G',c:'\\u24bc\\uff27\\u01f4\\u011c\\u1e20\\u011e\\u0120\\u01e6\\u0122\\u01e4\\u0193\\ua7a0\\ua77d\\ua77e\\u0262'},{b:'H',c:'\\u24bd\\uff28\\u0124\\u1e22\\u1e26\\u021e\\u1e24\\u1e28\\u1e2a\\u0126\\u2c67\\u2c75\\ua78d'},{b:'I',c:'\\u24be\\uff29\\u00cc\\u00cd\\u00ce\\u0128\\u012a\\u012c\\u0130\\u00cf\\u1e2e\\u1ec8\\u01cf\\u0208\\u020a\\u1eca\\u012e\\u1e2c\\u0197'},{b:'J',c:'\\u24bf\\uff2a\\u0134\\u0248\\u0237'},{b:'K',c:'\\u24c0\\uff2b\\u1e30\\u01e8\\u1e32\\u0136\\u1e34\\u0198\\u2c69\\ua740\\ua742\\ua744\\ua7a2'},{b:'L',c:'\\u24c1\\uff2c\\u013f\\u0139\\u013d\\u1e36\\u1e38\\u013b\\u1e3c\\u1e3a\\u0141\\u023d\\u2c62\\u2c60\\ua748\\ua746\\ua780'}, {b:'LJ',c:'\\u01c7'},{b:'Lj',c:'\\u01c8'},{b:'M',c:'\\u24c2\\uff2d\\u1e3e\\u1e40\\u1e42\\u2c6e\\u019c\\u03fb'},{b:'N',c:'\\ua7a4\\u0220\\u24c3\\uff2e\\u01f8\\u0143\\u00d1\\u1e44\\u0147\\u1e46\\u0145\\u1e4a\\u1e48\\u019d\\ua790\\u1d0e'},{b:'NJ',c:'\\u01ca'},{b:'Nj',c:'\\u01cb'},{b:'O',c:'\\u24c4\\uff2f\\u00d2\\u00d3\\u00d4\\u1ed2\\u1ed0\\u1ed6\\u1ed4\\u00d5\\u1e4c\\u022c\\u1e4e\\u014c\\u1e50\\u1e52\\u014e\\u022e\\u0230\\u00d6\\u022a\\u1ece\\u0150\\u01d1\\u020c\\u020e\\u01a0\\u1edc\\u1eda\\u1ee0\\u1ede\\u1ee2\\u1ecc\\u1ed8\\u01ea\\u01ec\\u00d8\\u01fe\\u0186\\u019f\\ua74a\\ua74c'}, {b:'OE',c:'\\u0152'},{b:'OI',c:'\\u01a2'},{b:'OO',c:'\\ua74e'},{b:'OU',c:'\\u0222'},{b:'P',c:'\\u24c5\\uff30\\u1e54\\u1e56\\u01a4\\u2c63\\ua750\\ua752\\ua754'},{b:'Q',c:'\\u24c6\\uff31\\ua756\\ua758\\u024a'},{b:'R',c:'\\u24c7\\uff32\\u0154\\u1e58\\u0158\\u0210\\u0212\\u1e5a\\u1e5c\\u0156\\u1e5e\\u024c\\u2c64\\ua75a\\ua7a6\\ua782'},{b:'S',c:'\\u24c8\\uff33\\u1e9e\\u015a\\u1e64\\u015c\\u1e60\\u0160\\u1e66\\u1e62\\u1e68\\u0218\\u015e\\u2c7e\\ua7a8\\ua784'},{b:'T',c:'\\u24c9\\uff34\\u1e6a\\u0164\\u1e6c\\u021a\\u0162\\u1e70\\u1e6e\\u0166\\u01ac\\u01ae\\u023e\\ua786'}, {b:'Th',c:'\\u00de'},{b:'TZ',c:'\\ua728'},{b:'U',c:'\\u24ca\\uff35\\u00d9\\u00da\\u00db\\u0168\\u1e78\\u016a\\u1e7a\\u016c\\u00dc\\u01db\\u01d7\\u01d5\\u01d9\\u1ee6\\u016e\\u0170\\u01d3\\u0214\\u0216\\u01af\\u1eea\\u1ee8\\u1eee\\u1eec\\u1ef0\\u1ee4\\u1e72\\u0172\\u1e76\\u1e74\\u0244'},{b:'V',c:'\\u24cb\\uff36\\u1e7c\\u1e7e\\u01b2\\ua75e\\u0245'},{b:'VY',c:'\\ua760'},{b:'W',c:'\\u24cc\\uff37\\u1e80\\u1e82\\u0174\\u1e86\\u1e84\\u1e88\\u2c72'},{b:'X',c:'\\u24cd\\uff38\\u1e8a\\u1e8c'},{b:'Y',c:'\\u24ce\\uff39\\u1ef2\\u00dd\\u0176\\u1ef8\\u0232\\u1e8e\\u0178\\u1ef6\\u1ef4\\u01b3\\u024e\\u1efe'}, {b:'Z',c:'\\u24cf\\uff3a\\u0179\\u1e90\\u017b\\u017d\\u1e92\\u1e94\\u01b5\\u0224\\u2c7f\\u2c6b\\ua762'},{b:'a',c:'\\u24d0\\uff41\\u1e9a\\u00e0\\u00e1\\u00e2\\u1ea7\\u1ea5\\u1eab\\u1ea9\\u00e3\\u0101\\u0103\\u1eb1\\u1eaf\\u1eb5\\u1eb3\\u0227\\u01e1\\u00e4\\u01df\\u1ea3\\u00e5\\u01fb\\u01ce\\u0201\\u0203\\u1ea1\\u1ead\\u1eb7\\u1e01\\u0105\\u2c65\\u0250\\u0251'},{b:'aa',c:'\\ua733'},{b:'ae',c:'\\u00e6\\u01fd\\u01e3'},{b:'ao',c:'\\ua735'},{b:'au',c:'\\ua737'},{b:'av',c:'\\ua739\\ua73b'},{b:'ay',c:'\\ua73d'}, {b:'b',c:'\\u24d1\\uff42\\u1e03\\u1e05\\u1e07\\u0180\\u0183\\u0253\\u0182'},{b:'c',c:'\\uff43\\u24d2\\u0107\\u0109\\u010b\\u010d\\u00e7\\u1e09\\u0188\\u023c\\ua73f\\u2184'},{b:'d',c:'\\u24d3\\uff44\\u1e0b\\u010f\\u1e0d\\u1e11\\u1e13\\u1e0f\\u0111\\u018c\\u0256\\u0257\\u018b\\u13e7\\u0501\\ua7aa'},{b:'dh',c:'\\u00f0'},{b:'dz',c:'\\u01f3\\u01c6'},{b:'e',c:'\\u24d4\\uff45\\u00e8\\u00e9\\u00ea\\u1ec1\\u1ebf\\u1ec5\\u1ec3\\u1ebd\\u0113\\u1e15\\u1e17\\u0115\\u0117\\u00eb\\u1ebb\\u011b\\u0205\\u0207\\u1eb9\\u1ec7\\u0229\\u1e1d\\u0119\\u1e19\\u1e1b\\u0247\\u01dd'}, {b:'f',c:'\\u24d5\\uff46\\u1e1f\\u0192'},{b:'ff',c:'\\ufb00'},{b:'fi',c:'\\ufb01'},{b:'fl',c:'\\ufb02'},{b:'ffi',c:'\\ufb03'},{b:'ffl',c:'\\ufb04'},{b:'g',c:'\\u24d6\\uff47\\u01f5\\u011d\\u1e21\\u011f\\u0121\\u01e7\\u0123\\u01e5\\u0260\\ua7a1\\ua77f\\u1d79'},{b:'h',c:'\\u24d7\\uff48\\u0125\\u1e23\\u1e27\\u021f\\u1e25\\u1e29\\u1e2b\\u1e96\\u0127\\u2c68\\u2c76\\u0265'},{b:'hv',c:'\\u0195'},{b:'i',c:'\\u24d8\\uff49\\u00ec\\u00ed\\u00ee\\u0129\\u012b\\u012d\\u00ef\\u1e2f\\u1ec9\\u01d0\\u0209\\u020b\\u1ecb\\u012f\\u1e2d\\u0268\\u0131'}, {b:'j',c:'\\u24d9\\uff4a\\u0135\\u01f0\\u0249'},{b:'k',c:'\\u24da\\uff4b\\u1e31\\u01e9\\u1e33\\u0137\\u1e35\\u0199\\u2c6a\\ua741\\ua743\\ua745\\ua7a3'},{b:'l',c:'\\u24db\\uff4c\\u0140\\u013a\\u013e\\u1e37\\u1e39\\u013c\\u1e3d\\u1e3b\\u017f\\u0142\\u019a\\u026b\\u2c61\\ua749\\ua781\\ua747\\u026d'},{b:'lj',c:'\\u01c9'},{b:'m',c:'\\u24dc\\uff4d\\u1e3f\\u1e41\\u1e43\\u0271\\u026f'},{b:'n',c:'\\u24dd\\uff4e\\u01f9\\u0144\\u00f1\\u1e45\\u0148\\u1e47\\u0146\\u1e4b\\u1e49\\u019e\\u0272\\u0149\\ua791\\ua7a5\\u043b\\u0509'},{b:'nj', c:'\\u01cc'},{b:'o',c:'\\u24de\\uff4f\\u00f2\\u00f3\\u00f4\\u1ed3\\u1ed1\\u1ed7\\u1ed5\\u00f5\\u1e4d\\u022d\\u1e4f\\u014d\\u1e51\\u1e53\\u014f\\u022f\\u0231\\u00f6\\u022b\\u1ecf\\u0151\\u01d2\\u020d\\u020f\\u01a1\\u1edd\\u1edb\\u1ee1\\u1edf\\u1ee3\\u1ecd\\u1ed9\\u01eb\\u01ed\\u00f8\\u01ff\\ua74b\\ua74d\\u0275\\u0254\\u1d11'},{b:'oe',c:'\\u0153'},{b:'oi',c:'\\u01a3'},{b:'oo',c:'\\ua74f'},{b:'ou',c:'\\u0223'},{b:'p',c:'\\u24df\\uff50\\u1e55\\u1e57\\u01a5\\u1d7d\\ua751\\ua753\\ua755\\u03c1'},{b:'q',c:'\\u24e0\\uff51\\u024b\\ua757\\ua759'}, {b:'r',c:'\\u24e1\\uff52\\u0155\\u1e59\\u0159\\u0211\\u0213\\u1e5b\\u1e5d\\u0157\\u1e5f\\u024d\\u027d\\ua75b\\ua7a7\\ua783'},{b:'s',c:'\\u24e2\\uff53\\u015b\\u1e65\\u015d\\u1e61\\u0161\\u1e67\\u1e63\\u1e69\\u0219\\u015f\\u023f\\ua7a9\\ua785\\u1e9b\\u0282'},{b:'ss',c:'\\u00df'},{b:'t',c:'\\u24e3\\uff54\\u1e6b\\u1e97\\u0165\\u1e6d\\u021b\\u0163\\u1e71\\u1e6f\\u0167\\u01ad\\u0288\\u2c66\\ua787'},{b:'th',c:'\\u00fe'},{b:'tz',c:'\\ua729'},{b:'u',c:'\\u24e4\\uff55\\u00f9\\u00fa\\u00fb\\u0169\\u1e79\\u016b\\u1e7b\\u016d\\u00fc\\u01dc\\u01d8\\u01d6\\u01da\\u1ee7\\u016f\\u0171\\u01d4\\u0215\\u0217\\u01b0\\u1eeb\\u1ee9\\u1eef\\u1eed\\u1ef1\\u1ee5\\u1e73\\u0173\\u1e77\\u1e75\\u0289'}, {b:'v',c:'\\u24e5\\uff56\\u1e7d\\u1e7f\\u028b\\ua75f\\u028c'},{b:'vy',c:'\\ua761'},{b:'w',c:'\\u24e6\\uff57\\u1e81\\u1e83\\u0175\\u1e87\\u1e85\\u1e98\\u1e89\\u2c73'},{b:'x',c:'\\u24e7\\uff58\\u1e8b\\u1e8d'},{b:'y',c:'\\u24e8\\uff59\\u1ef3\\u00fd\\u0177\\u1ef9\\u0233\\u1e8f\\u00ff\\u1ef7\\u1e99\\u1ef5\\u01b4\\u024f\\u1eff'},{b:'z',c:'\\u24e9\\uff5a\\u017a\\u1e91\\u017c\\u017e\\u1e93\\u1e95\\u01b6\\u0225\\u0240\\u2c6c\\ua763'}];\n\nfor (var i=0; i <DIACRITICS.length; i+=1)\n\tfor (var chars=DIACRITICS[i].c,j=0;j<chars.length;j+=1)\n\t\tDIACRITICSMAP[chars[j]]=DIACRITICS[i].b;\n\nconst DP = Date.prototype;\nconst SP = String.prototype;\nconst NP = Number.prototype;\n\nDIACRITICS = null;\n\nvar CONTENTTYPES = {\n\taac: 'audio/aac',\n\tai: 'application/postscript',\n\tappcache: 'text/cache-manifest',\n\tavi: 'video/avi',\n\tbin: 'application/octet-stream',\n\tbmp: 'image/bmp',\n\tcoffee: 'text/coffeescript',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdocx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\tdtd: 'application/xml-dtd',\n\teps: 'application/postscript',\n\texe: 'application/octet-stream',\n\tflac: 'audio/x-flac',\n\tgeojson: 'application/json',\n\tgif: 'image/gif',\n\tgzip: 'application/x-gzip',\n\theic: 'image/heic',\n\theif: 'image/heif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tifb: 'text/calendar',\n\tjpe: 'image/jpeg',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'text/javascript',\n\tjson: 'application/json',\n\tjsx: 'text/jsx',\n\tless: 'text/css',\n\tm4a: 'audio/mp4a-latm',\n\tm4v: 'video/x-m4v',\n\tmanifest: 'text/cache-manifest',\n\tmd: 'text/x-markdown',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmjs: 'text/javascript',\n\tmov: 'video/quicktime',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpg: 'video/mpeg',\n\tmpga: 'audio/mpeg',\n\tmtl: 'text/plain',\n\tmv4: 'video/mv4',\n\tobj: 'text/plain',\n\togg: 'application/ogg',\n\togv: 'video/ogg',\n\tpackage: 'text/plain',\n\tpdf: 'application/pdf',\n\tpng: 'image/png',\n\tppt: 'application/vnd.ms-powerpoint',\n\tpptx: 'application/vnd.ms-powerpoint',\n\tps: 'application/postscript',\n\trar: 'application/x-rar-compressed',\n\trtf: 'text/rtf',\n\tsass: 'text/css',\n\tscss: 'text/css',\n\tsh: 'application/x-sh',\n\tstl: 'application/sla',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\ttxt: 'text/plain',\n\tsql: 'text/plain',\n\twav: 'audio/x-wav',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'application/font-woff',\n\twoff2: 'application/font-woff2',\n\txht: 'application/xhtml+xml',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txpm: 'image/x-xpixmap',\n\txsl: 'application/xml',\n\txslt: 'application/xslt+xml',\n\tzip: 'application/zip'\n};\n\nvar dnscache = {};\nvar datetimeformat = {};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nglobal.DIFFARR = exports.diffarr = function(prop, db, form) {\n\n\tvar an = [];\n\tvar au = [];\n\tvar ar = [];\n\tvar is, oa, ob;\n\n\tfor (var i = 0; i < db.length; i++) {\n\t\toa = db[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < form.length; j++) {\n\t\t\tob = form[j];\n\t\t\tif (oa[prop] == ob[prop]) {\n\t\t\t\tau.push({ db: oa, form: ob });\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tar.push(oa[prop]);\n\t}\n\n\tfor (var i = 0; i < form.length; i++) {\n\t\tob = form[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < db.length; j++) {\n\t\t\toa = db[j];\n\t\t\tif (ob[prop] == oa[prop]) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tan.push(ob);\n\t}\n\n\tvar obj = {};\n\tobj.add = an;\n\tobj.upd = au;\n\tobj.rem = ar;\n\treturn obj;\n};\n\n/**\n * Checks if is object empty\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isEmpty = function(obj) {\n\n\tif (!obj || obj instanceof Array)\n\t\treturn true;\n\n\tfor (var key in obj) {\n\t\tif (hasOwnProperty.call(obj, key))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Compare objects\n * @param {Object} obj1\n * @param {Object} obj2\n * @return {Boolean}\n */\nexports.isEqual = function(obj1, obj2, properties) {\n\n\tvar keys = properties ? properties : Object.keys(obj1);\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tvar a = obj1[key];\n\t\tvar b = obj2[key];\n\t\tvar ta = typeof(a);\n\t\tvar tb = typeof(b);\n\n\t\tif (ta !== tb)\n\t\t\treturn false;\n\n\t\tif (a === b)\n\t\t\tcontinue;\n\n\t\tif (a instanceof Date && b instanceof Date) {\n\t\t\tif (a.getTime() === b.getTime())\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t} else if (a instanceof Array && b instanceof Array) {\n\t\t\tif (JSON.stringify(a) === JSON.stringify(b))\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (ta === 'object' && tb === 'object') {\n\t\t\tif (exports.isEqual(a, b))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Function checks a valid function and waits for it positive result\n * @param {Function} fnValid\n * @param {Function(err, success)} fnCallback\n * @param {Number} timeout  Timeout, optional (default: 5000)\n * @param {Number} interval Refresh interval, optional (default: 500)\n */\nexports.wait = function(fnValid, fnCallback, timeout, interval) {\n\n\tif (fnValid() === true)\n\t\treturn fnCallback(null, true);\n\n\tvar id_timeout = null;\n\tvar id_interval = setInterval(function() {\n\n\t\tif (fnValid() === true) {\n\t\t\tclearInterval(id_interval);\n\t\t\tclearTimeout(id_timeout);\n\t\t\tfnCallback && fnCallback(null, true);\n\t\t}\n\n\t}, interval || 500);\n\n\tid_timeout = setTimeout(function() {\n\t\tclearInterval(id_interval);\n\t\tfnCallback && fnCallback(new Error('Timeout.'), false);\n\t}, timeout || 5000);\n};\n\nexports.$$wait = function(fnValid, timeout, interval) {\n\treturn function(callback) {\n\t\texports.wait(fnValid, callback, timeout, interval);\n\t};\n};\n\n/**\n * Resolves an IP from the URL address\n * @param {String} url\n * @param {Function(err, uri)} callback\n */\nexports.resolve = function(url, callback, param) {\n\n\tvar uri = Url.parse(url);\n\n\n\tif (!callback)\n\t\treturn dnscache[uri.host];\n\n\tif (dnscache[uri.host]) {\n\t\turi.host = dnscache[uri.host];\n\t\tcallback(null, uri, param);\n\t\treturn;\n\t}\n\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (e)\n\t\t\tsetImmediate(dnsresolve_callback, uri, callback, param);\n\t\telse {\n\t\t\tdnscache[uri.host] = addresses[0];\n\t\t\turi.host = addresses[0];\n\t\t\tcallback(null, uri, param);\n\t\t}\n\t});\n};\n\nfunction dnsresolve_callback(uri, callback, param) {\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (addresses && addresses.length) {\n\t\t\tdnscache[uri.host] = addresses[0];\n\t\t\turi.host = addresses[0];\n\t\t}\n\t\tcallback(e, uri, param);\n\t});\n}\n\nexports.$$resolve = function(url) {\n\treturn function(callback) {\n\t\treturn exports.resolve(url, callback);\n\t};\n};\n\n/**\n * Clears DNS cache\n */\nexports.clearDNS = function() {\n\tOBSOLETE('U.clearDNS()', 'Use CMD(\\'clear_dnscache\\')');\n\tCMD('clear_dnscache');\n};\n\nsetImmediate(function() {\n\tif (global.F) {\n\t\tF.install('command', 'clear_dnscache', function() {\n\t\t\tdnscache = {};\n\t\t});\n\t}\n});\n\n\nexports.keywords = function(content, forSearch, alternative, max_count, max_length, min_length) {\n\n\tif (forSearch === undefined)\n\t\tforSearch = true;\n\n\tmin_length = min_length || 2;\n\tmax_count = max_count || 200;\n\tmax_length = max_length || 20;\n\n\tvar words = [];\n\tvar isSoundex = alternative === 'soundex';\n\n\tif (content instanceof Array) {\n\t\tfor (var i = 0, length = content.length; i < length; i++) {\n\t\t\tif (!content[i])\n\t\t\t\tcontinue;\n\t\t\tvar tmp = (forSearch ? content[i].removeDiacritics().toLowerCase().replace(regexpY, 'i') : content[i].toLowerCase()).replace(regexpN, ' ').split(' ');\n\t\t\tif (!tmp || !tmp.length)\n\t\t\t\tcontinue;\n\t\t\tfor (var j = 0, jl = tmp.length; j < jl; j++)\n\t\t\t\twords.push(tmp[j]);\n\t\t}\n\t} else\n\t\twords = (forSearch ? content.removeDiacritics().toLowerCase().replace(regexpY, 'i') : content.toLowerCase()).replace(regexpN, ' ').split(' ');\n\n\tif (!words)\n\t\twords = [];\n\n\tvar dic = {};\n\tvar counter = 0;\n\n\tfor (var i = 0, length = words.length; i < length; i++) {\n\n\t\tvar word = words[i].trim().replace(regexpCHARS, keywordscleaner);\n\n\t\tif (regexpCHINA.test(word)) {\n\n\t\t\tvar tmpw = word.split('', max_count);\n\n\t\t\tfor (var j = 0; j < tmpw.length; j++) {\n\t\t\t\tword = tmpw[j];\n\t\t\t\tif (dic[word])\n\t\t\t\t\tdic[word]++;\n\t\t\t\telse\n\t\t\t\t\tdic[word] = 1;\n\t\t\t\tcounter++;\n\t\t\t}\n\n\t\t\tif (counter >= max_count)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (word.length < min_length)\n\t\t\tcontinue;\n\n\t\tif (counter >= max_count)\n\t\t\tbreak;\n\n\t\t// Gets 80% length of word\n\t\tif (alternative) {\n\t\t\tif (isSoundex)\n\t\t\t\tword = word.soundex();\n\t\t\telse {\n\t\t\t\tvar size = (word.length / 100) * 80;\n\t\t\t\tif (size > min_length + 1)\n\t\t\t\t\tword = word.substring(0, size);\n\t\t\t}\n\t\t}\n\n\t\tif (word.length < min_length || word.length > max_length)\n\t\t\tcontinue;\n\n\t\tif (dic[word])\n\t\t\tdic[word]++;\n\t\telse\n\t\t\tdic[word] = 1;\n\n\t\tcounter++;\n\t}\n\n\tvar keys = Object.keys(dic);\n\n\tkeys.sort(function(a, b) {\n\t\tvar countA = dic[a];\n\t\tvar countB = dic[b];\n\t\treturn countA > countB ? -1 : countA < countB ? 1 : 0;\n\t});\n\n\treturn keys;\n};\n\nfunction keywordscleaner(c) {\n\treturn c.charCodeAt(0) < 200 ? '' : c;\n}\n\nfunction parseProxy(p) {\n\tvar key = 'proxy_' + p;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (p.indexOf('://') === -1)\n\t\tp = 'http://' + p;\n\n\tvar obj = Url.parse(p);\n\n\tif (obj.auth)\n\t\tobj._auth = 'Basic ' + Buffer.from(obj.auth).toString('base64');\n\n\tobj.port = +obj.port;\n\treturn F.temporary.other[key] = obj;\n}\n\n/**\n * Create a request to a specific URL\n * @param  {String} url URL address.\n * @param  {String Array} flags Request flags.\n * @param  {String or Object} data Request data (optional).\n * @param  {Function(error, content, statusCode, headers)} callback Callback.\n * @param  {Object} headers Custom cookies (optional, default: null).\n * @param  {Object} headers Custom headers (optional, default: null).\n * @param  {String} encoding Encoding (optional, default: UTF8)\n * @param  {Number} timeout Request timeout.\n * return {Boolean}\n */\n\nconst NOBODY = { GET: 1, OPTIONS: 1, HEAD: 1 };\n\nglobal.REQUEST = exports.request = function(url, flags, data, callback, cookies, headers, encoding, timeout, files, param) {\n\n\t// No data (data is optional argument)\n\tif (typeof(data) === 'function') {\n\t\tencoding = headers;\n\t\theaders = cookies;\n\t\tcookies = callback;\n\t\tcallback = data;\n\t\tdata = '';\n\t} else if (!data)\n\t\tdata = '';\n\n\tif (callback === NOOP)\n\t\tcallback = null;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tvar options = { length: 0, timeout: timeout || CONF.default_restbuilder_timeout, evt: new EventEmitter2(), encoding: typeof(encoding) !== 'string' ? ENCODING : encoding, callback: callback, post: false, redirect: 0 };\n\tvar method;\n\tvar type = 0;\n\tvar isCookies = false;\n\tvar def;\n\tvar proxy;\n\n\tif (headers) {\n\t\theaders = exports.extend({}, headers);\n\t\tdef = headers[CT];\n\t} else\n\t\theaders = {};\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\n\t\t\t// timeout\n\t\t\tif (flags[i] > 0) {\n\t\t\t\toptions.timeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === '<') {\n\t\t\t\toptions.max = flags[i].substring(1).trim().parseInt() * 1024; // kB\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === 'p' && flags[i][4] === 'y') {\n\t\t\t\tproxy = parseProxy(flags[i].substring(6));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flags[i].toLowerCase()) {\n\t\t\t\tcase 'utf8':\n\t\t\t\tcase 'ascii':\n\t\t\t\tcase 'base64':\n\t\t\t\tcase 'binary':\n\t\t\t\tcase 'hex':\n\t\t\t\t\toptions.encoding = flags[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xhr':\n\t\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'plain':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/plain';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/html';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'raw':\n\t\t\t\t\ttype = 3;\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'application/octet-stream';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'json':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'application/json';\n\t\t\t\t\t!method && (method = 'POST');\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xml':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/xml';\n\t\t\t\t\t!method && (method = 'POST');\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'head':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'noredirect':\n\t\t\t\t\toptions.noredirect = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'upload':\n\t\t\t\t\ttype = 4;\n\t\t\t\t\toptions.upload = true;\n\t\t\t\t\toptions.files = files || EMPTYARRAY;\n\t\t\t\t\toptions.boundary = '----totaljs' + Math.random().toString(16).substring(2);\n\t\t\t\t\theaders[CT] = 'multipart/form-data; boundary=' + options.boundary;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'patch':\n\t\t\t\t\tmethod = flags[i].toUpperCase();\n\t\t\t\t\t!def && !headers[CT] && (headers[CT] = 'application/x-www-form-urlencoded');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dnscache':\n\t\t\t\t\toptions.resolve = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'keepalive':\n\t\t\t\t\toptions.keepalive = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cookies':\n\t\t\t\t\tisCookies = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Fallback for methods (e.g. CalDAV)\n\t\t\t\t\tif (!method)\n\t\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (method)\n\t\toptions.post = !NOBODY[method];\n\telse\n\t\tmethod = 'GET';\n\n\tif (type < 3) {\n\n\t\tif (typeof(data) !== 'string')\n\t\t\tdata = type === 1 ? JSON.stringify(data) : Qs.stringify(data);\n\t\telse if (data[0] === '?')\n\t\t\tdata = data.substring(1);\n\n\t\tif (!options.post) {\n\t\t\tif (data.length) {\n\t\t\t\tif (url.indexOf('?') === -1)\n\t\t\t\t\turl += '?' + data;\n\t\t\t\telse\n\t\t\t\t\turl += '&' + data;\n\t\t\t}\n\t\t\tdata = '';\n\t\t}\n\n\t\t// \"null\" or \"empty string\" is valid JSON value too\n\t\tif (type === 1 && (data === EMPTYOBJECT || data === undefined) && options.post)\n\t\t\tdata = BUFEMPTYJSON;\n\t}\n\n\tif (data && type !== 4) {\n\t\toptions.data = data instanceof Buffer ? data : Buffer.from(data, ENCODING);\n\t\theaders['Content-Length'] = options.data.length;\n\t} else\n\t\toptions.data = data;\n\n\tif (cookies) {\n\t\tif (isCookies)\n\t\t\toptions.cookies = cookies;\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\theaders['Cookie'] = builder;\n\t}\n\n\tvar uri = Url.parse(url);\n\n\tif (!uri.hostname || !uri.host) {\n\t\tcallback && callback(new Error('URL doesn\\'t contain a hostname'), '', 0);\n\t\treturn;\n\t}\n\n\turi.method = method;\n\turi.headers = headers;\n\toptions.uri = uri;\n\n\tif (options.resolve && (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64))\n\t\toptions.resolve = null;\n\n\tif (CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\tif (proxy && (uri.hostname === 'localhost' || uri.hostname === '127.0.0.1'))\n\t\tproxy = null;\n\n\toptions.proxy = proxy;\n\toptions.param = param;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy && uri.protocol !== 'https:')\n\t\turi.agent = KeepAlive;\n\n\tif (proxy)\n\t\trequest_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(url, request_resolve, options);\n\telse\n\t\trequest_call(uri, options);\n\n\treturn options.evt;\n};\n\nfunction request_resolve(err, uri, options) {\n\tif (!err)\n\t\toptions.uri.host = uri.host;\n\trequest_call(options.uri, options);\n}\n\nfunction ProxyAgent(options) {\n\tvar self = this;\n\tself.options = options;\n\tself.maxSockets = Http.Agent.defaultMaxSockets;\n\tself.requests = [];\n}\n\nconst PAP = ProxyAgent.prototype;\n\nPAP.createConnection = function(pending) {\n\tvar self = this;\n\tself.createSocket(pending, function(socket) {\n\t\tpending.request.onSocket(socket);\n\t});\n};\n\nPAP.createSocket = function(options, callback) {\n\n\tvar self = this;\n\tvar proxy = self.options.proxy;\n\tvar uri = self.options.uri;\n\n\tPROXYOPTIONS.host = proxy.hostname;\n\tPROXYOPTIONS.port = proxy.port;\n\tPROXYOPTIONS.path = PROXYOPTIONS.headers.host = uri.hostname + ':' + (uri.port || '443');\n\n\tif (proxy._auth)\n\t\tPROXYOPTIONS.headers['Proxy-Authorization'] = proxy._auth;\n\n\tvar req = self.request(PROXYOPTIONS);\n\treq.setTimeout(10000);\n\treq.on('response', proxyagent_response);\n\treq.on('connect', function(res, socket) {\n\n\t\tif (res.statusCode === 200) {\n\t\t\tsocket.$req = req;\n\t\t\tcallback(socket);\n\t\t} else {\n\t\t\tvar err = new Error('Proxy could not be established (maybe a problem in auth), code: ' + res.statusCode);\n\t\t\terr.code = 'ECONNRESET';\n\t\t\toptions.request.emit('error', err);\n\t\t\treq.destroy && req.destroy();\n\t\t\treq = null;\n\t\t\tself.requests = null;\n\t\t\tself.options = null;\n\t\t}\n\t});\n\n\treq.on('error', function(err) {\n\t\tvar e = new Error('Request Proxy \"proxy {0} --> target {1}\": {2}'.format(PROXYOPTIONS.host + ':' + proxy.port, PROXYOPTIONS.path, err.toString()));\n\t\te.code = err.code;\n\t\toptions.request.emit('error', e);\n\t\treq.destroy && req.destroy();\n\t\treq = null;\n\t\tself.requests = null;\n\t\tself.options = null;\n\t});\n\n\treq.end();\n};\n\nfunction proxyagent_response(res) {\n\tres.upgrade = true;\n}\n\nPAP.addRequest = function(req, options) {\n\tthis.createConnection({ host: options.host, port: options.port, request: req });\n};\n\nfunction createSecureSocket(options, callback) {\n\tvar self = this;\n\tPAP.createSocket.call(self, options, function(socket) {\n\t\tPROXYTLS.servername = self.options.uri.hostname;\n\t\tPROXYTLS.headers = self.options.uri.headers;\n\t\tPROXYTLS.socket = socket;\n\t\tvar tls = Tls.connect(0, PROXYTLS);\n\t\tcallback(tls);\n\t});\n}\n\nfunction request_call(uri, options) {\n\n\tvar opt;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\topt.headers.host = uri.host;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = options.post ? connection.request(opt, request_response) : connection.get(opt, request_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', request_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(request_process_timeout, options.timeout, req);\n\n\t// req.on('response', (response) => response.req = req);\n\treq.on('response', request_assign_res);\n\n\tif (options.upload) {\n\t\toptions.first = true;\n\t\toptions.files.wait(function(file, next) {\n\t\t\trequest_writefile(req, options, file, next);\n\t\t}, function() {\n\t\t\tvar keys = Object.keys(options.data);\n\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tvar value = options.data[keys[i]];\n\t\t\t\tif (value != null) {\n\t\t\t\t\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + keys[i] + '\"' + NEWLINE + NEWLINE + value.toString());\n\t\t\t\t\tif (options.first)\n\t\t\t\t\t\toptions.first = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treq.end(NEWLINE + '--' + options.boundary + '--');\n\t\t});\n\t} else\n\t\treq.end(options.data);\n}\n\nfunction request_process_error(err) {\n\tvar options = this.$options;\n\tif (options.callback && !options.done) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\toptions.canceled = true;\n\t\toptions.callback(err, '', 0, undefined, this.$uri.host, EMPTYOBJECT, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n}\n\nfunction request_process_timeout(req) {\n\tvar options = req.$options;\n\tif (options.callback) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\treq.socket.destroy();\n\t\treq.socket.end();\n\t\treq.abort();\n\t\toptions.canceled = true;\n\t\toptions.callback(new Error(exports.httpStatus(408)), '', 0, undefined, req.$uri.host, EMPTYOBJECT, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n}\n\nfunction request_assign_res(response) {\n\tresponse.req = this;\n}\n\nfunction request_writefile(req, options, file, next) {\n\n\tvar type = typeof(file.buffer);\n\tvar filename = (type === 'string' ? file.buffer : exports.getName(file.filename));\n\n\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + file.name + '\"; filename=\"' + filename + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(filename)) + NEWLINE + NEWLINE);\n\n\tif (options.first)\n\t\toptions.first = false;\n\n\t// Is Buffer\n\tif (file.buffer && type === 'object') {\n\t\treq.write(file.buffer);\n\t\tnext();\n\t} else {\n\t\tvar stream = Fs.createReadStream(file.filename);\n\t\tstream.once('close', next);\n\t\tstream.pipe(req, STREAMPIPE);\n\t}\n}\n\nfunction request_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._buffer = null;\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.noredirect) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\n\t\t\tif (options.callback) {\n\t\t\t\toptions.callback(null, '', res.statusCode, res.headers, uri.host, EMPTYOBJECT, options.param);\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tif (options.evt) {\n\t\t\t\toptions.evt.removeAllListeners();\n\t\t\t\toptions.evt = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.redirect > 3) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\n\t\t\tif (options.callback) {\n\t\t\t\toptions.callback(new Error('Too many redirects.'), '', 0, undefined, uri.host, EMPTYOBJECT, options.param);\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tif (options.evt) {\n\t\t\t\toptions.evt.removeAllListeners();\n\t\t\t\toptions.evt = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers['location'];\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.proxy.tls = true;\n\t\t\toptions.uri = tmp;\n\t\t\toptions.uri.agent = new ProxyAgent(options);\n\t\t\toptions.uri.agent.request = Http.request;\n\t\t\toptions.uri.agent.createSocket = createSecureSocket;\n\t\t\toptions.uri.agent.defaultPort = 443;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn request_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(tmp, function(err, u) {\n\t\t\tif (!err)\n\t\t\t\ttmp.host = u.host;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\trequest_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\toptions.length = +res.headers['content-length'] || 0;\n\toptions.evt && options.evt.$events.begin && options.evt.emit('begin', options.length);\n\n\t// Shared cookies\n\tif (options.cookies) {\n\t\tvar arr = (res.headers['set-cookie'] || '');\n\n\t\t// Only the one value\n\t\tif (arr && !(arr instanceof Array))\n\t\t\tarr = [arr];\n\n\t\tif (arr instanceof Array) {\n\t\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\t\tvar line = arr[i];\n\t\t\t\tvar end = line.indexOf(';');\n\t\t\t\tif (end === -1)\n\t\t\t\t\tend = line.length;\n\t\t\t\tline = line.substring(0, end);\n\t\t\t\tvar index = line.indexOf('=');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\toptions.cookies[line.substring(0, index)] = decodeURIComponent(line.substring(index + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res.statusCode === 204) {\n\t\toptions.done = true;\n\t\trequest_process_end.call(res);\n\t\treturn;\n\t}\n\n\tvar encoding = res.headers['content-encoding'] || '';\n\tif (encoding)\n\t\tencoding = encoding.split(',')[0];\n\n\tif (COMPRESS[encoding]) {\n\t\tvar zlib = encoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate();\n\t\tzlib._buffer = res.buffer;\n\t\tzlib.headers = res.headers;\n\t\tzlib.statusCode = res.statusCode;\n\t\tzlib.res = res;\n\t\tzlib.on('data', request_process_data);\n\t\tzlib.on('end', request_process_end);\n\t\tres.pipe(zlib);\n\t} else {\n\t\tres.on('data', request_process_data);\n\t\tres.on('end', request_process_end);\n\t}\n\n\tres.resume();\n}\n\nfunction request_process_data(chunk) {\n\tvar self = this;\n\n\t// Is Zlib\n\tif (!self.req)\n\t\tself = self.res;\n\n\tvar options = self.req.$options;\n\tif (options.canceled || (options.max && self._bufferlength > options.max))\n\t\treturn;\n\tif (self._buffer) {\n\t\tCONCAT[0] = self._buffer;\n\t\tCONCAT[1] = chunk;\n\t\tself._buffer = Buffer.concat(CONCAT);\n\t} else\n\t\tself._buffer = chunk;\n\tself._bufferlength += chunk.length;\n\toptions.evt && options.evt.$events.data && options.evt.emit('data', chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n}\n\nfunction request_process_end() {\n\n\tvar res = this;\n\n\t// Is Zlib\n\tif (!res.req)\n\t\tres = res.res;\n\n\tvar self = res;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\tvar data;\n\n\toptions.socket && options.uri.agent.destroy();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\n\tif (options.canceled)\n\t\treturn;\n\n\tvar ct = self.headers['content-type'];\n\n\tif (!ct || REG_TEXTAPPLICATION.test(ct))\n\t\tdata = self._buffer ? (options.encoding === 'binary' ? self._buffer : self._buffer.toString(options.encoding)) : '';\n\telse\n\t\tdata = self._buffer;\n\n\toptions.canceled = true;\n\n\tself._buffer = undefined;\n\n\tif (options.evt) {\n\t\toptions.evt.$events.end && options.evt.emit('end', data, self.statusCode, self.headers, uri.host, options.cookies, options.param);\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n\n\tif (options.callback) {\n\t\toptions.callback(null, uri.method === 'HEAD' ? self.headers : data, self.statusCode, self.headers, uri.host, options.cookies, options.param);\n\t\toptions.callback = null;\n\t}\n\n\tif (res.statusCode !== 204) {\n\t\tres.req && res.req.removeAllListeners();\n\t\tres.removeAllListeners();\n\t}\n}\n\nexports.$$request = function(url, flags, data, cookies, headers, encoding, timeout) {\n\treturn function(callback) {\n\t\texports.request(url, flags, data, callback, cookies, headers, encoding, timeout);\n\t};\n};\n\nexports.btoa = function(str) {\n\treturn (str instanceof Buffer) ? str.toString('base64') : Buffer.from(str.toString(), 'utf8').toString('base64');\n};\n\nexports.atob = function(str) {\n\treturn Buffer.from(str, 'base64').toString('utf8');\n};\n\n/**\n * Create a request to a specific URL\n * @param {String} url URL address.\n * @param {String Array} flags Request flags.\n * @param {String or Object} data Request data (optional).\n * @param {Function(error, response)} callback Callback.\n * @param {Object} cookies Custom cookies (optional, default: null).\n * @param {Object} headers Custom headers (optional, default: null).\n * @param {String} encoding Encoding (optional, default: UTF8)\n * @param {Number} timeout Request timeout.\n * return {Boolean}\n */\nexports.download = function(url, flags, data, callback, cookies, headers, encoding, timeout, param) {\n\n\t// No data (data is optional argument)\n\tif (typeof(data) === 'function') {\n\t\ttimeout = encoding;\n\t\tencoding = headers;\n\t\theaders = cookies;\n\t\tcookies = callback;\n\t\tcallback = data;\n\t\tdata = '';\n\t}\n\n\tif (typeof(cookies) === 'number') {\n\t\tcookies = null;\n\t\ttimeout = cookies;\n\t}\n\n\tif (typeof(headers) === 'number') {\n\t\theaders = null;\n\t\ttimeout = headers;\n\t}\n\n\tif (typeof(encoding) === 'number') {\n\t\tencoding = null;\n\t\ttimeout = encoding;\n\t}\n\n\tif (typeof(encoding) !== 'string')\n\t\tencoding = ENCODING;\n\n\tvar proxy, type = 0;\n\tvar method = 'GET';\n\tvar options = { callback: callback, resolve: false, length: 0, evt: new EventEmitter2(), timeout: timeout || 60000, post: false, encoding: encoding };\n\n\tif (headers)\n\t\theaders = exports.extend({}, headers);\n\telse\n\t\theaders = {};\n\n\tif (data === null)\n\t\tdata = '';\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\n\t\t\t// timeout\n\t\t\tif (flags[i] > 0) {\n\t\t\t\toptions.timeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === '<') {\n\t\t\t\t// max length is not supported\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === 'p' && flags[i][4] === 'y') {\n\t\t\t\tproxy = parseProxy(flags[i].substring(6));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flags[i].toLowerCase()) {\n\n\t\t\t\tcase 'utf8':\n\t\t\t\tcase 'ascii':\n\t\t\t\tcase 'base64':\n\t\t\t\tcase 'binary':\n\t\t\t\tcase 'hex':\n\t\t\t\t\toptions.encoding = flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'xhr':\n\t\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'plain':\n\t\t\t\t\theaders['Content-Type'] = 'text/plain';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\theaders['Content-Type'] = 'text/html';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'json':\n\t\t\t\t\theaders['Content-Type'] = 'application/json';\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'xml':\n\t\t\t\t\theaders['Content-Type'] = 'text/xml';\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'options':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'upload':\n\t\t\t\t\theaders['Content-Type'] = 'multipart/form-data';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'put':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tif (!headers['Content-Type'])\n\t\t\t\t\t\theaders['Content-Type'] = 'application/x-www-form-urlencoded';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dnscache':\n\t\t\t\t\toptions.resolve = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'keepalive':\n\t\t\t\t\toptions.keepalive = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Fallback for methods (e.g. CalDAV)\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!method)\n\t\tmethod = 'GET';\n\n\toptions.post = !NOBODY[method];\n\n\tif (typeof(data) !== 'string')\n\t\tdata = type === 1 ? JSON.stringify(data) : Qs.stringify(data);\n\telse if (data[0] === '?')\n\t\tdata = data.substring(1);\n\n\tif (!options.post) {\n\t\tif (data.length && url.indexOf('?') === -1)\n\t\t\turl += '?' + data;\n\t\tdata = '';\n\t}\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\theaders['Cookie'] = builder;\n\t}\n\n\tvar uri = Url.parse(url);\n\turi.method = method;\n\t// uri.agent = false;\n\turi.headers = headers;\n\toptions.uri = uri;\n\toptions.param = param;\n\n\tif (options.resolve && (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64))\n\t\toptions.resolve = null;\n\n\tif (data.length) {\n\t\toptions.data = Buffer.from(data, ENCODING);\n\t\theaders['Content-Length'] = options.data.length;\n\t}\n\n\tif (CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\toptions.proxy = proxy;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy && uri.protocol !== 'https:')\n\t\turi.agent = KeepAlive;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tif (proxy)\n\t\tdownload_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(url, download_resolve, options);\n\telse\n\t\tdownload_call(uri, options);\n\n\treturn options.evt;\n};\n\nfunction download_resolve(err, uri, options) {\n\tif (!err)\n\t\toptions.uri.host = uri.host;\n\tdownload_call(options.uri, options);\n}\n\nfunction download_call(uri, options) {\n\n\tvar opt;\n\toptions.length = 0;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = options.post ? connection.request(opt, download_response) : connection.get(opt, download_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', download_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(download_process_timeout, options.timeout);\n\treq.on('response', download_assign_res);\n\treq.end(options.data);\n}\n\nfunction download_assign_res(response) {\n\tresponse.req = this;\n\tvar options = this.$options;\n\toptions.length = +response.headers['content-length'] || 0;\n\toptions.evt && options.evt.$events.begin && options.evt.emit('begin', options.length);\n}\n\nfunction download_process_timeout(req) {\n\tvar options = req.$options;\n\tif (options.callback) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t\treq.abort();\n\t\toptions.callback(new Error(exports.httpStatus(408)), null, null, null, null, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t\toptions.canceled = true;\n\t}\n}\n\nfunction download_process_error(err) {\n\tvar options = this.$options;\n\tif (options.callback && !options.done) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t\toptions.callback(err, null, null, null, null, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t\toptions.canceled = true;\n\t}\n}\n\nfunction download_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.redirect > 3) {\n\t\t\toptions.canceled = true;\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.callback && options.callback(new Error('Too many redirects.'), null, null, null, null, options.param);\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers['location'];\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.uri = tmp;\n\t\t\tdownload_call(options, request_call);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn download_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(loc, function(err, u) {\n\t\t\tif (!err)\n\t\t\t\ttmp.host = u.host;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\tdownload_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\tres.on('data', download_process_data);\n\tres.on('end', download_process_end);\n\n\tres.resume();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.callback && options.callback(null, res, res.statusCode, res.headers, uri.host, options.param);\n}\n\nexports.$$download = function(url, flags, data, cookies, headers, encoding, timeout) {\n\treturn function(callback) {\n\t\texports.download(url, flags, data, callback, cookies, headers, encoding, timeout);\n\t};\n};\n\nfunction download_process_end() {\n\n\tvar res = this;\n\tvar self = this;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\n\tif (!options.canceled) {\n\t\tvar str = self._buffer ? self._buffer.toString(options.encoding) : '';\n\t\tself._buffer = undefined;\n\t\toptions.evt && options.evt.$events.end && options.evt.emit('end', str, self.statusCode, self.headers, uri.host);\n\t}\n\n\tif (options.evt) {\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n\n\tres.req && res.req.removeAllListeners();\n\tres.removeAllListeners();\n}\n\nfunction download_process_data(chunk) {\n\tvar self = this;\n\tvar options = self.req.$options;\n\tif (!options.canceled) {\n\t\tself._bufferlength += chunk.length;\n\t\tif (options.evt) {\n\t\t\toptions.evt.$events.data && options.evt.emit('data', chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n\t\t\toptions.evt.$events.progress && options.evt.emit('progress', options.length ? (self._bufferlength / options.length) * 100 : 0);\n\t\t}\n\t}\n}\n\n/**\n * Upload a stream through HTTP\n * @param {String} name Filename with extension.\n * @param {Stream} stream Stream.\n * @param {String} url A valid URL address.\n * @param {Function} callback Callback.\n * @param {Object} headers Custom headers (optional).\n * @param {String} method HTTP method (optional, default POST).\n * @param {Number} timeout Request timeout, default: 60000 (1 minute)\n */\nexports.send = function(name, stream, url, callback, cookies, headers, method, timeout) {\n\n\tOBSOLETE('U.send()', 'Use U.upload() instead of U.send().');\n\n\tif (typeof(stream) === 'string')\n\t\tstream = Fs.createReadStream(stream, STREAM_READONLY);\n\n\tvar BOUNDARY = '----totaljs' + Math.random().toString(16).substring(2);\n\tvar h = {};\n\n\tif (headers)\n\t\texports.extend(h, headers);\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\th['Cookie'] = builder;\n\t}\n\n\tname = exports.getName(name);\n\n\th['Cache-Control'] = 'max-age=0';\n\th['Content-Type'] = 'multipart/form-data; boundary=' + BOUNDARY;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tvar e = new EventEmitter2();\n\tvar uri = Url.parse(url);\n\tvar options = { protocol: uri.protocol, auth: uri.auth, method: method || 'POST', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: h };\n\tvar responseLength = 0;\n\n\tvar response = function(res) {\n\n\t\tres.body = Buffer.alloc(0);\n\t\tres._bufferlength = 0;\n\n\t\tres.on('data', function(chunk) {\n\t\t\tCONCAT[0] = res.body;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tres.body = Buffer.concat(CONCAT);\n\t\t\tres._bufferlength += chunk.length;\n\t\t\te.$events.data && e.emit('data', chunk, responseLength ? (res._bufferlength / responseLength) * 100 : 0);\n\t\t});\n\n\t\tres.on('end', function() {\n\t\t\tvar self = this;\n\t\t\te.$events.end && e.emit('end', self.statusCode, self.headers);\n\t\t\te.removeAllListeners();\n\t\t\te = null;\n\t\t\tcallback && callback(null, self.body.toString('utf8'), self.statusCode, self.headers, uri.host);\n\t\t\tself.body = null;\n\t\t});\n\t};\n\n\tvar connection = options.protocol === 'https:' ? Https : Http;\n\tvar req = connection.request(options, response);\n\n\treq.on('response', function(response) {\n\t\tresponseLength = +response.headers['content-length'] || 0;\n\t\te.$events.begin && e.emit('begin', responseLength);\n\t});\n\n\treq.setTimeout(timeout || 60000, function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t\te.removeAllListeners();\n\t\te = null;\n\t\tcallback && callback(new Error(exports.httpStatus(408)), '', 408, undefined, uri.host);\n\t});\n\n\treq.on('error', function(err) {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t\te.removeAllListeners();\n\t\te = null;\n\t\tcallback && callback(err, '', 0, undefined, uri.host);\n\t});\n\n\treq.on('close', function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t});\n\n\tvar header = NEWLINE + NEWLINE + '--' + BOUNDARY + NEWLINE + 'Content-Disposition: form-data; name=\"File\"; filename=\"' + name + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(name)) + NEWLINE + NEWLINE;\n\treq.write(header);\n\n\t// Is Buffer\n\tif (stream.length) {\n\t\treq.write(stream);\n\t\treq.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--');\n\t\treturn e;\n\t}\n\n\tstream.on('end', () => req.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--'));\n\tstream.pipe(req, STREAM_END);\n\treturn e;\n};\n\nexports.$$send = function(name, stream, url, cookies, headers, method, timeout) {\n\treturn function(callback) {\n\t\texports.send(name, stream, url, callback, cookies, headers, method, timeout);\n\t};\n};\n\nexports.upload = function(files, url, callback, cookies, headers, method, timeout) {\n\n\tvar BOUNDARY = '----totaljs' + Math.random().toString(16).substring(2);\n\tvar h = {};\n\n\theaders && exports.extend_headers2(h, headers);\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tbuilder && (h['Cookie'] = builder);\n\t}\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\th['Cache-Control'] = 'max-age=0';\n\th['Content-Type'] = 'multipart/form-data; boundary=' + BOUNDARY;\n\n\tvar e = new EventEmitter2();\n\tvar uri = Url.parse(url);\n\tvar options = { protocol: uri.protocol, auth: uri.auth, method: method || 'POST', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: h };\n\tvar responseLength = 0;\n\tvar timeoutid;\n\tvar done = false;\n\n\tvar response = function(res) {\n\n\t\tres.body = Buffer.alloc(0);\n\t\tres._bufferlength = 0;\n\n\t\tres.on('data', function(chunk) {\n\t\t\tif (!done) {\n\t\t\t\tCONCAT[0] = res.body;\n\t\t\t\tCONCAT[1] = chunk;\n\t\t\t\tres.body = Buffer.concat(CONCAT);\n\t\t\t\tres._bufferlength += chunk.length;\n\t\t\t\te.$events.data && e.emit('data', chunk, responseLength ? (res._bufferlength / responseLength) * 100 : 0);\n\t\t\t}\n\t\t});\n\n\t\tres.on('end', function() {\n\t\t\tif (!done) {\n\t\t\t\tvar self = this;\n\t\t\t\te.$events.end && e.emit('end', self.statusCode, self.headers);\n\t\t\t\te.removeAllListeners();\n\t\t\t\tcallback && callback(null, self.body.toString('utf8'), self.statusCode, self.headers, uri.host);\n\t\t\t\ttimeoutid && clearTimeout(timeoutid);\n\t\t\t\tself.body = null;\n\t\t\t\te = null;\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t});\n\t};\n\n\tvar connection = options.protocol === 'https:' ? Https : Http;\n\tvar req = connection.request(options, response);\n\n\treq.on('response', function(response) {\n\t\tresponseLength = +response.headers['content-length'] || 0;\n\t\te.$events.begin && e.emit('begin', responseLength);\n\t});\n\n\tvar timeoutcallback = function() {\n\t\tif (!done) {\n\t\t\treq.removeAllListeners();\n\t\t\te.removeAllListeners();\n\t\t\tcallback && callback(new Error(exports.httpStatus(408)), '', 408, undefined, uri.host);\n\t\t\ttimeoutid && clearTimeout(timeoutid);\n\t\t\treq = null;\n\t\t\te = null;\n\t\t\tdone = true;\n\t\t}\n\t};\n\n\tif (timeout)\n\t\ttimeoutid = setTimeout(timeoutcallback, timeout);\n\n\treq.setTimeout(timeout || 60000, timeoutcallback);\n\n\treq.on('error', function(err) {\n\t\tdone = true;\n\t\treq.removeAllListeners();\n\t\te.removeAllListeners();\n\t\tcallback && callback(err, '', 0, undefined, uri.host);\n\t\ttimeoutid && clearTimeout(timeoutid);\n\t\treq = null;\n\t\te = null;\n\t});\n\n\treq.on('close', function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t});\n\n\tvar header = NEWLINE + NEWLINE + '--' + BOUNDARY + NEWLINE + 'Content-Disposition: form-data; name=\"{0}\"; filename=\"{1}\"' + NEWLINE + 'Content-Type: {2}' + NEWLINE + NEWLINE;\n\n\tfiles.wait(function(item, next) {\n\n\t\t// item.name;\n\t\t// item.filename;\n\t\t// item.stream (optional) or item.buffer (optional)\n\n\t\treq.write(header.format(item.name, U.getName(item.filename), exports.getContentType(exports.getExtension(item.filename))));\n\n\t\tif (item.buffer) {\n\t\t\treq.write(item.buffer);\n\t\t\treturn next();\n\t\t}\n\n\t\t!item.stream && (item.stream = Fs.createReadStream(item.filename));\n\t\titem.stream.pipe(req, STREAM_END);\n\t\titem.stream.on('error', next);\n\t\titem.stream.on('end', next);\n\n\t}, () => req.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--'));\n\treturn e;\n};\n\nexports.$$upload = function(files, url, cookies, headers, method, timeout) {\n\treturn function(callback) {\n\t\texports.upload(files, url, callback, cookies, headers, method, timeout);\n\t};\n};\n\n/**\n * Trim string properties\n * @param {Object} obj\n * @return {Object}\n */\nexports.trim = function(obj, clean) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type === 'string') {\n\t\tobj = obj.trim();\n\t\treturn clean && !obj ? undefined : obj;\n\t}\n\n\tif (obj instanceof Array) {\n\t\tfor (var i = 0, length = obj.length; i < length; i++) {\n\n\t\t\tvar item = obj[i];\n\t\t\ttype = typeof(item);\n\n\t\t\tif (type === 'object') {\n\t\t\t\texports.trim(item, clean);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type !== 'string')\n\t\t\t\tcontinue;\n\n\t\t\tobj[i] = item.trim();\n\t\t\tif (clean && !obj[i])\n\t\t\t\tobj[i] = undefined;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tif (type !== 'object')\n\t\treturn obj;\n\n\tvar keys = Object.keys(obj);\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar val = obj[keys[i]];\n\t\tvar type = typeof(val);\n\t\tif (type === 'object') {\n\t\t\texports.trim(val, clean);\n\t\t\tcontinue;\n\t\t} else if (type !== 'string')\n\t\t\tcontinue;\n\t\tobj[keys[i]] = val.trim();\n\t\tif (clean && !obj[keys[i]])\n\t\t\tobj[keys[i]] = undefined;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Noop function\n * @return {Function} Empty function.\n */\nexports.noop = global.noop = global.NOOP = function() {};\n\n/**\n * Read HTTP status\n * @param  {Number} code HTTP code status.\n * @param  {Boolean} addCode Add code number to HTTP status.\n * @return {String}\n */\nexports.httpStatus = function(code, addCode) {\n\tif (addCode === undefined)\n\t\taddCode = true;\n\treturn (addCode ? code + ': ' : '') + Http.STATUS_CODES[code];\n};\n\n/**\n * Extend object\n * @param {Object} target Target object.\n * @param {Object} source Source object.\n * @param {Boolean} rewrite Rewrite exists values (optional, default true).\n * @return {Object} Modified object.\n */\nexports.extend = function(target, source, rewrite) {\n\n\tif (!target || !source)\n\t\treturn target;\n\n\tif (typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tvar keys = Object.keys(source);\n\tvar i = keys.length;\n\n\twhile (i--) {\n\t\tvar key = keys[i];\n\t\tif (rewrite || target[key] === undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\nexports.extend_headers = function(first, second) {\n\tvar keys = Object.keys(first);\n\tvar headers = {};\n\n\tvar i = keys.length;\n\twhile (i--)\n\t\theaders[keys[i]] = first[keys[i]];\n\n\tkeys = Object.keys(second);\n\ti = keys.length;\n\n\twhile (i--)\n\t\theaders[keys[i]] = second[keys[i]];\n\n\treturn headers;\n};\n\nexports.extend_headers2 = function(first, second) {\n\tvar keys = Object.keys(second);\n\tvar i = keys.length;\n\twhile (i--)\n\t\tfirst[keys[i]] = second[keys[i]];\n\treturn first;\n};\n\n/**\n * Clones object\n * @param {Object} obj\n * @param {Object} skip Optional, can be only object e.g. { name: true, age: true }.\n * @param {Boolean} skipFunctions It doesn't clone functions, optional --> default false.\n * @return {Object}\n */\nglobal.CLONE = exports.clone = function(obj, skip, skipFunctions) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type !== 'object' || obj instanceof Date || obj instanceof Error)\n\t\treturn obj;\n\n\tvar length;\n\tvar o;\n\n\tif (obj instanceof Array) {\n\n\t\tlength = obj.length;\n\t\to = new Array(length);\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttype = typeof(obj[i]);\n\t\t\tif (type !== 'object' || obj[i] instanceof Date || obj[i] instanceof Error) {\n\t\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\t\tcontinue;\n\t\t\t\to[i] = obj[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\to[i] = exports.clone(obj[i], skip, skipFunctions);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\to = {};\n\n\tfor (var m in obj) {\n\n\t\tif (skip && skip[m])\n\t\t\tcontinue;\n\n\t\tvar val = obj[m];\n\n\t\tif (val instanceof Buffer) {\n\t\t\tvar copy = Buffer.alloc(val.length);\n\t\t\tval.copy(copy);\n\t\t\to[m] = copy;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = typeof(val);\n\t\tif (type !== 'object' || val instanceof Date || val instanceof Error) {\n\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\tcontinue;\n\t\t\to[m] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\to[m] = exports.clone(obj[m], skip, skipFunctions);\n\t}\n\n\treturn o;\n};\n\n/**\n * Copy values from object to object\n * @param {Object} source Object source\n * @param {Object} target Object target (optional)\n * @return {Object} Modified object.\n */\nexports.copy = function(source, target) {\n\n\tif (target === undefined)\n\t\treturn exports.extend({}, source, true);\n\n\tif (!target || !source || typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tvar keys = Object.keys(source);\n\tvar i = keys.length;\n\n\twhile (i--) {\n\t\tvar key = keys[i];\n\t\ttarget[key] !== undefined && (target[key] = exports.clone(source[key]));\n\t}\n\n\treturn target;\n};\n\n/**\n * Reduce an object\n * @param {Object} source Source object.\n * @param {String Array or Object} prop Other properties than these ones will be removed.\n * @param {Boolean} reverse Reverse reducing (prop will be removed), default: false.\n * @return {Object}\n */\nexports.reduce = function(source, prop, reverse) {\n\n\tif (!(prop instanceof Array)) {\n\t\tif (typeof(prop) === 'object')\n\t\t\treturn exports.reduce(source, Object.keys(prop), reverse);\n\t}\n\n\tif (source instanceof Array) {\n\t\tvar arr = [];\n\t\tfor (var i = 0, length = source.length; i < length; i++)\n\t\t\tarr.push(exports.reduce(source[i], prop, reverse));\n\t\treturn arr;\n\t}\n\n\tvar output = {};\n\n\tvar keys = Object.keys(source);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar o = keys[i];\n\t\tif (reverse) {\n\t\t\tif (prop.indexOf(o) === -1)\n\t\t\t\toutput[o] = source[o];\n\t\t} else {\n\t\t\tif (prop.indexOf(o) !== -1)\n\t\t\t\toutput[o] = source[o];\n\t\t}\n\t}\n\n\treturn output;\n};\n\n/**\n * Assign value to an object according to a path\n * @param {Object} obj Source object.\n * @param {String} path Path to the update.\n * @param {Object or Function} fn Value or Function to update.\n * @return {Object}\n */\n// @TODO: deprecated, it will be removed in v4\nexports.assign = function(obj, path, fn) {\n\n\tif (obj == null)\n\t\treturn obj;\n\n\tvar arr = path.split('.');\n\tvar model = obj[arr[0]];\n\n\tfor (var i = 1; i < arr.length - 1; i++)\n\t\tmodel = model[arr[i]];\n\n\tmodel[arr[arr.length - 1]] = typeof (fn) === 'function' ? fn(model[arr[arr.length - 1]]) : fn;\n\treturn obj;\n};\n\n/**\n * Checks if is relative url\n * @param {String} url\n * @return {Boolean}\n */\nexports.isRelative = function(url) {\n\treturn !(url.substring(0, 2) === '//' || url.indexOf('http://') !== -1 || url.indexOf('https://') !== -1);\n};\n\n/**\n * Streamer method\n * @param {String/Buffer} beg\n * @param {String/Buffer} end\n * @param {Function(value, index)} callback\n */\nexports.streamer = function(beg, end, callback, skip, stream, raw) {\n\n\tif (typeof(end) === 'function') {\n\t\tstream = skip;\n\t\tskip = callback;\n\t\tcallback = end;\n\t\tend = undefined;\n\t}\n\n\tif (typeof(skip) === 'object') {\n\t\tstream = skip;\n\t\tskip = 0;\n\t}\n\n\tvar indexer = 0;\n\tvar buffer = Buffer.alloc(0);\n\tvar canceled = false;\n\tvar fn;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\n\tif (!(beg instanceof Buffer))\n\t\tbeg = Buffer.from(beg, 'utf8');\n\n\tif (end && !(end instanceof Buffer))\n\t\tend = Buffer.from(end, 'utf8');\n\n\tif (!end) {\n\t\tvar length = beg.length;\n\t\tfn = function(chunk) {\n\n\t\t\tif (!chunk || canceled)\n\t\t\t\treturn;\n\n\t\t\tCONCAT[0] = buffer;\n\t\t\tCONCAT[1] = chunk;\n\n\t\t\tvar f = 0;\n\n\t\t\tif (buffer.length) {\n\t\t\t\tf = buffer.length - beg.length;\n\t\t\t\tif (f < 0)\n\t\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\t\tvar index = buffer.indexOf(beg, f);\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\twhile (index !== -1) {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tskip--;\n\t\t\t\telse {\n\t\t\t\t\tif (callback(raw ? buffer.slice(0, index + length) : buffer.toString('utf8', 0, index + length), indexer++) === false)\n\t\t\t\t\t\tcanceled = true;\n\t\t\t\t}\n\n\t\t\t\tif (canceled)\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = buffer.slice(index + length);\n\t\t\t\tindex = buffer.indexOf(beg);\n\t\t\t\tif (index === -1)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tstream && stream.on('end', () => fn(beg));\n\t\treturn fn;\n\t}\n\n\tvar blength = beg.length;\n\tvar elength = end.length;\n\tvar bi = -1;\n\tvar ei = -1;\n\tvar is = false;\n\n\tfn = function(chunk) {\n\n\t\tif (!chunk || canceled)\n\t\t\treturn;\n\n\t\tCONCAT[0] = buffer;\n\t\tCONCAT[1] = chunk;\n\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\tif (!is) {\n\t\t\tvar f = CONCAT[0].length - beg.length;\n\t\t\tif (f < 0)\n\t\t\t\tf = 0;\n\t\t\tbi = buffer.indexOf(beg, f);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t}\n\n\t\tif (is) {\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\n\t\twhile (bi !== -1) {\n\n\t\t\tif (skip)\n\t\t\t\tskip--;\n\t\t\telse {\n\t\t\t\tif (callback(raw ? buffer.slice(bi, ei + elength) : buffer.toString('utf8', bi, ei + elength), indexer++) === false)\n\t\t\t\t\tcanceled = true;\n\t\t\t}\n\n\t\t\tif (canceled)\n\t\t\t\treturn;\n\n\t\t\tbuffer = buffer.slice(ei + elength);\n\t\t\tis = false;\n\t\t\tbi = buffer.indexOf(beg);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\t};\n\n\tstream && stream.on('end', () => fn(end));\n\treturn fn;\n};\n\nexports.streamer2 = function(beg, end, callback, skip, stream) {\n\treturn exports.streamer(beg, end, callback, skip, stream, true);\n};\n\n/**\n * HTML encode string\n * @param {String} str\n * @return {String}\n */\nexports.encode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.encode();\n};\n\n/**\n * HTML decode string\n * @param {String} str\n * @return {String}\n */\nexports.decode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.decode();\n};\n\n/**\n * Checks if URL contains file extension.\n * @param {String} url\n * @return {Boolean}\n */\nexports.isStaticFile = function(url) {\n\treturn regexpSTATIC.test(url);\n};\n\n/**\n * Converts Value to number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseInt = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseInt(def);\n};\n\nexports.parseBool = exports.parseBoolean = function(obj, def) {\n\tif (obj == null)\n\t\treturn def === undefined ? false : def;\n\tvar type = typeof(obj);\n\treturn type === 'boolean' ? obj : type === 'number' ? obj > 0 : (type !== 'string' ? obj.toString() : obj).parseBool(def);\n};\n\n/**\n * Converts Value to float number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseFloat = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseFloat(def);\n};\n\n/**\n * Check if the object is Array.\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isArray = function(obj) {\n\treturn obj instanceof Array;\n};\n\n/**\n * Check if the object is RegExp\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isRegExp = function(obj) {\n\treturn obj && typeof(obj.test) === 'function' ? true : false;\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isDate = function(obj) {\n\treturn obj instanceof Date && !isNaN(obj.getTime()) ? true : false;\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isError = function(obj) {\n\treturn (obj && obj.stack) ? true : false;\n};\n\n/**\n * Check if the value is object\n * @param {Object} value\n * @return {Boolean}\n */\nexports.isObject = function(value) {\n\ttry {\n\t\treturn (value && Object.getPrototypeOf(value) === Object.prototype) ? true : false;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n/**\n * Get ContentType from file extension.\n * @param {String} ext File extension.\n * @return {String}\n */\nexports.getContentType = function(ext) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\treturn CONTENTTYPES[ext] || 'application/octet-stream';\n};\n\n/**\n * Get extension from filename\n * @param {String} filename\n * @return {String}\n */\nexports.getExtension = function(filename, raw) {\n\tvar end = filename.length;\n\tfor (var i = filename.length - 1; i > 0; i--) {\n\t\tvar c = filename[i];\n\t\tif (c === ' ' || c === '?')\n\t\t\tend = i;\n\t\telse if (c === '.') {\n\t\t\tc = filename.substring(i + 1, end);\n\t\t\treturn raw ? c : c.toLowerCase();\n\t\t}\n\t\telse if (c === '/' || c === '\\\\')\n\t\t\treturn '';\n\t}\n\treturn '';\n};\n\n/**\n * Get base name from path\n * @param {String} path\n * @return {String}\n */\nexports.getName = function(path) {\n\tvar l = path.length - 1;\n\tvar c = path[l];\n\tif (c === '/' || c === '\\\\')\n\t\tpath = path.substring(0, l);\n\tvar index = path.lastIndexOf('/');\n\tif (index !== -1)\n\t\treturn path.substring(index + 1);\n\tindex = path.lastIndexOf('\\\\');\n\treturn index === -1 ? path : path.substring(index + 1);\n};\n\n/**\n * Add a new content type to content types\n * @param {String} ext File extension.\n * @param {String} type Content type (example: application/json).\n */\nexports.setContentType = function(ext, type) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\n\tif (ext.length > 8) {\n\t\tvar tmp = regexpSTATIC.toString().replace(/,\\d+\\}/, ',' + ext.length + '}').substring(1);\n\t\tregexpSTATIC = new RegExp(tmp.substring(0, tmp.length - 1));\n\t}\n\n\tCONTENTTYPES[ext] = type;\n\treturn true;\n};\n\nexports.path = function(path, delimiter) {\n\tif (!path)\n\t\tpath = '';\n\tdelimiter = delimiter || '/';\n\treturn path[path.length - 1] === delimiter ? path : path + delimiter;\n};\n\nexports.join = function() {\n\tvar path = [''];\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar current = arguments[i];\n\t\tif (!current)\n\t\t\tcontinue;\n\t\tif (current[0] === '/')\n\t\t\tcurrent = current.substring(1);\n\t\tvar l = current.length - 1;\n\t\tif (current[l] === '/')\n\t\t\tcurrent = current.substring(0, l);\n\t\tpath.push(current);\n\t}\n\n\tpath = path.join('/');\n\treturn !isWindows ? path : path.indexOf(':') > -1 ? path.substring(1) : path;\n};\n\n/**\n * Prepares Windows path to UNIX like format\n * @internal\n * @param {String} path\n * @return {String}\n */\nexports.$normalize = function(path) {\n\treturn isWindows ? path.replace(regexpPATH, '/') : path;\n};\n\nexports.random = function(max, min) {\n\tmax = (max || 100000);\n\tmin = (min || 0);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction rnd() {\n\treturn Math.floor(Math.random() * 65536).toString(36);\n}\n\nglobal.GUID = exports.GUID = function(max) {\n\tmax = max || 40;\n\tvar str = '';\n\tfor (var i = 0; i < (max / 3) + 1; i++)\n\t\tstr += rnd();\n\treturn str.substring(0, max);\n};\n\nfunction validate_builder_default(name, value, entity) {\n\n\tvar type = typeof(value);\n\n\tif (entity.type === 12)\n\t\treturn value != null && type === 'object' && !(value instanceof Array);\n\n\tif (entity.type === 11)\n\t\treturn type === 'number';\n\n\t// Enum + KeyValue + Custom (8+9+10)\n\tif (entity.type > 7)\n\t\treturn value !== undefined;\n\n\tswitch (entity.subtype) {\n\t\tcase 'uid':\n\t\t\treturn value.isUID();\n\t\tcase 'zip':\n\t\t\treturn value.isZIP();\n\t\tcase 'email':\n\t\t\treturn value.isEmail();\n\t\tcase 'json':\n\t\t\treturn value.isJSON();\n\t\tcase 'url':\n\t\t\treturn value.isURL();\n\t\tcase 'phone':\n\t\t\treturn value.isPhone();\n\t\tcase 'base64':\n\t\t\treturn value.isBase64();\n\t}\n\n\tif (type === 'number')\n\t\treturn value > 0;\n\n\tif (type === 'string' || value instanceof Array)\n\t\treturn value.length > 0;\n\n\tif (type === 'boolean')\n\t\treturn value === true;\n\n\tif (value == null)\n\t\treturn false;\n\n\tif (value instanceof Date)\n\t\treturn value.toString()[0] !== 'I'; // Invalid Date\n\n\treturn true;\n}\n\nexports.validate_builder = function(model, error, schema, path, index, fields, pluspath) {\n\n\tvar prepare = schema.onValidate || F.onValidate || NOOP;\n\tvar current = path ? path + '.' : '';\n\tvar properties = model && model.$$keys ? model.$$keys : schema.properties;\n\tvar result;\n\n\tif (!pluspath)\n\t\tpluspath = '';\n\n\tif (model == null)\n\t\tmodel = {};\n\n\tfor (var i = 0; i < properties.length; i++) {\n\n\t\tvar name = properties[i];\n\n\t\tif (fields && fields.indexOf(name) === -1)\n\t\t\tcontinue;\n\n\t\tvar TYPE = schema.schema[name];\n\t\tif (!TYPE)\n\t\t\tcontinue;\n\n\t\tif (TYPE.can && !TYPE.can(model, model.$$workflow || EMPTYOBJECT))\n\t\t\tcontinue;\n\n\t\tvar value = model[name];\n\t\tvar type = typeof(value);\n\t\tvar prefix = schema.resourcePrefix ? (schema.resourcePrefix + name) : name;\n\n\t\tif (value === undefined) {\n\t\t\terror.push(pluspath + name, '@', current + name, undefined, prefix);\n\t\t\tcontinue;\n\t\t} else if (type === 'function')\n\t\t\tvalue = model[name]();\n\n\t\tif (TYPE.isArray) {\n\t\t\tif (TYPE.type === 7 && value instanceof Array && value.length) {\n\t\t\t\tvar nestedschema = schema.parent.collection[TYPE.raw] || GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema) {\n\t\t\t\t\tfor (var j = 0, jl = value.length; j < jl; j++)\n\t\t\t\t\t\texports.validate_builder(value[j], error, nestedschema, current + name + '[' + j + ']', j, undefined, pluspath);\n\t\t\t\t} else\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\n\t\t\t\tif (!TYPE.required)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : prepare(name, value, current + name, model, schema.name, TYPE);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = value instanceof Array ? value.length > 0 : false;\n\t\t\t\t\tif (result == null || result === true)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean') {\n\t\t\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t\t\t} else if (result.isValid === false)\n\t\t\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (TYPE.type === 7) {\n\n\t\t\tif (!value && !TYPE.required)\n\t\t\t\tcontinue;\n\n\t\t\t// Another schema\n\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\n\t\t\tif (result == null) {\n\t\t\t\tvar nestedschema = schema.parent.collection[TYPE.raw] || GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema)\n\t\t\t\t\texports.validate_builder(value, error, nestedschema, current + name, undefined, undefined, pluspath);\n\t\t\t\telse\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean') {\n\t\t\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t\t\t} else if (result.isValid === false)\n\t\t\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!TYPE.required)\n\t\t\tcontinue;\n\n\t\tresult = TYPE.validate ? TYPE.validate(value, model) : prepare(name, value, current + name, model, schema.name, TYPE);\n\t\tif (result == null) {\n\t\t\tresult = validate_builder_default(name, value, TYPE);\n\t\t\tif (result == null || result === true)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttype = typeof(result);\n\n\t\tif (type === 'string') {\n\t\t\tif (result[0] === '@')\n\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\telse\n\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t} else if (type === 'boolean') {\n\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t} else if (result.isValid === false)\n\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t}\n\n\treturn error;\n};\n\n/**\n * Combine paths\n * @return {String}\n */\nexports.combine = function() {\n\n\tvar p = F.directory;\n\n\tfor (var i = 0, length = arguments.length; i < length; i++) {\n\t\tvar v = arguments[i];\n\t\tif (!v)\n\t\t\tcontinue;\n\t\tif (v[0] === '/')\n\t\t\tv = v.substring(1);\n\n\t\tif (v[0] === '~')\n\t\t\tp = v.substring(1);\n\t\telse\n\t\t\tp += (p[p.length - 1] !== '/' ? '/' : '') + v;\n\t}\n\treturn exports.$normalize(p);\n};\n\n/**\n * Remove diacritics\n * @param {String} str\n * @return {String}\n */\nexports.removeDiacritics = function(str) {\n\treturn str.replace(regexpDiacritics, c => DIACRITICSMAP[c] || c);\n};\n\n/**\n * Simple XML parser\n * @param {String} xml\n * @return {Object}\n */\nexports.parseXML = function(xml, replace) {\n\n\tvar beg = -1;\n\tvar end = 0;\n\tvar tmp = 0;\n\tvar current = [];\n\tvar obj = {};\n\tvar from = -1;\n\n\twhile (true) {\n\t\tbeg = xml.indexOf('<![CDATA[', beg);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = xml.indexOf(']]>', beg + 9);\n\t\txml = xml.substring(0, beg) + xml.substring(beg + 9, end).trim().encode() + xml.substring(end + 3);\n\t\tbeg += 9;\n\t}\n\n\tbeg = -1;\n\tend = 0;\n\n\twhile (true) {\n\n\t\tbeg = xml.indexOf('<', beg + 1);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = xml.indexOf('>', beg + 1);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar el = xml.substring(beg, end + 1);\n\t\tvar c = el[1];\n\n\t\tif (c === '?' || c === '/') {\n\n\t\t\tvar o = current.pop();\n\n\t\t\tif (from === -1 || o !== el.substring(2, el.length - 1))\n\t\t\t\tcontinue;\n\n\t\t\tvar path = (current.length ? current.join('.') + '.' : '') + o;\n\t\t\tvar value = xml.substring(from, beg).decode();\n\n\t\t\tif (replace)\n\t\t\t\tpath = path.replace(REG_XMLKEY, '_');\n\n\t\t\tif (obj[path] === undefined)\n\t\t\t\tobj[path] = value;\n\t\t\telse if (obj[path] instanceof Array)\n\t\t\t\tobj[path].push(value);\n\t\t\telse\n\t\t\t\tobj[path] = [obj[path], value];\n\n\t\t\tfrom = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = el.indexOf(' ');\n\t\tvar hasAttributes = true;\n\n\t\tif (tmp === -1) {\n\t\t\ttmp = el.length - 1;\n\t\t\thasAttributes = false;\n\t\t}\n\n\t\tfrom = beg + el.length;\n\n\t\tvar isSingle = el[el.length - 2] === '/';\n\t\tvar name = el.substring(1, tmp);\n\n\t\tif (!isSingle)\n\t\t\tcurrent.push(name);\n\n\t\tif (!hasAttributes)\n\t\t\tcontinue;\n\n\t\tvar match = el.match(regexpXML);\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tvar attr = {};\n\t\tvar length = match.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar index = match[i].indexOf('\"');\n\t\t\tattr[match[i].substring(0, index - 1)] = match[i].substring(index + 1, match[i].length - 1).decode();\n\t\t}\n\n\t\tvar k = current.join('.') + (isSingle ? '.' + name : '') + '[]';\n\t\tif (replace)\n\t\t\tk = k.replace(REG_XMLKEY, '_');\n\t\tobj[k] = attr;\n\t}\n\n\treturn obj;\n};\n\nexports.parseJSON = function(value, date) {\n\ttry {\n\t\treturn JSON.parse(value, date ? jsonparser : undefined);\n\t} catch(e) {\n\t}\n};\n\nexports.parseQuery = function(value) {\n\treturn F.onParseQuery(value);\n};\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n\n/**\n * Get WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param {Number} code\n * @param {Buffer or String} message\n * @param {Hexa} type\n * @return {Buffer}\n */\nexports.getWebSocketFrame = function(code, message, type, compress) {\n\tvar messageBuffer = getWebSocketFrameMessageBytes(code, message);\n\tvar lengthBuffer = getWebSocketFrameLengthBytes(messageBuffer.length);\n\tvar frameBuffer = Buffer.alloc(1 + lengthBuffer.length + messageBuffer.length);\n\tframeBuffer[0] = 0x80 | type;\n\tcompress && (frameBuffer[0] |= 0x40);\n\tlengthBuffer.copy(frameBuffer, 1, 0, lengthBuffer.length);\n\tmessageBuffer.copy(frameBuffer, lengthBuffer.length + 1, 0, messageBuffer.length);\n\treturn frameBuffer;\n};\n\n/**\n * Get bytes of WebSocket frame message\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} code\n * @param  {Buffer or String} message\n * @return {Buffer}\n */\nfunction getWebSocketFrameMessageBytes(code, message) {\n\n\tvar index = code ? 2 : 0;\n\tvar binary = message instanceof Int8Array || message instanceof Buffer;\n\tvar length = message.length;\n\n\tvar messageBuffer = Buffer.alloc(length + index);\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (binary)\n\t\t\tmessageBuffer[i + index] = message[i];\n\t\telse\n\t\t\tmessageBuffer[i + index] = message.charCodeAt(i);\n\t}\n\n\tif (code) {\n\t\tmessageBuffer[0] = code >> 8;\n\t\tmessageBuffer[1] = code;\n\t}\n\n\treturn messageBuffer;\n}\n\n/**\n * Get length of WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} length\n * @return {Number}\n */\nfunction getWebSocketFrameLengthBytes(length) {\n\tvar lengthBuffer = null;\n\n\tif (length <= 125) {\n\t\tlengthBuffer = Buffer.alloc(1);\n\t\tlengthBuffer[0] = length;\n\t\treturn lengthBuffer;\n\t}\n\n\tif (length <= 65535) {\n\t\tlengthBuffer = Buffer.alloc(3);\n\t\tlengthBuffer[0] = 126;\n\t\tlengthBuffer[1] = (length >> 8) & 255;\n\t\tlengthBuffer[2] = (length) & 255;\n\t\treturn lengthBuffer;\n\t}\n\n\tlengthBuffer = Buffer.alloc(9);\n\n\tlengthBuffer[0] = 127;\n\tlengthBuffer[1] = 0x00;\n\tlengthBuffer[2] = 0x00;\n\tlengthBuffer[3] = 0x00;\n\tlengthBuffer[4] = 0x00;\n\tlengthBuffer[5] = (length >> 24) & 255;\n\tlengthBuffer[6] = (length >> 16) & 255;\n\tlengthBuffer[7] = (length >> 8) & 255;\n\tlengthBuffer[8] = (length) & 255;\n\n\treturn lengthBuffer;\n}\n\n/**\n * GPS distance in KM\n * @param  {Number} lat1\n * @param  {Number} lon1\n * @param  {Number} lat2\n * @param  {Number} lon2\n * @return {Number}\n */\nexports.distance = function(lat1, lon1, lat2, lon2) {\n\tvar R = 6371;\n\tvar dLat = (lat2 - lat1).toRad();\n\tvar dLon = (lon2 - lon1).toRad();\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn (R * c).floor(3);\n};\n\nfunction ls(path, callback, advanced, filter) {\n\tvar filelist = new FileList();\n\tvar tmp;\n\n\tfilelist.advanced = advanced;\n\tfilelist.onComplete = callback;\n\n\tif (typeof(filter) === 'string') {\n\t\ttmp = filter.toLowerCase();\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : filename.toLowerCase().indexOf(tmp) !== -1;\n\t\t};\n\t} else if (exports.isRegExp(filter)) {\n\t\ttmp = filter;\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : tmp.test(filename);\n\t\t};\n\t} else\n\t\tfilelist.onFilter = filter || null;\n\n\tfilelist.walk(path);\n}\n\n/**\n * Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename, isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls = function(path, callback, filter) {\n\tls(path, callback, false, filter);\n};\n\n/**\n * Advanced Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename ,isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls2 = function(path, callback, filter) {\n\tls(path, callback, true, filter);\n};\n\nDP.setTimeZone = function(timezone) {\n\tvar dt = this.toLocaleString('en-US', { timeZone: timezone, hour12: false, dateStyle: 'short', timeStyle: 'short' });\n\treturn new Date(Date.parse(dt));\n};\n\nDP.add = function(type, value) {\n\n\tvar self = this;\n\n\tif (type.constructor === Number)\n\t\treturn new Date(self.getTime() + (type - type % 1));\n\n\tif (value === undefined) {\n\t\tvar arr = type.split(' ');\n\t\ttype = arr[1];\n\t\tvalue = exports.parseInt(arr[0]);\n\t}\n\n\tvar dt = new Date(self.getTime());\n\n\tswitch(type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'sec':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\tdt.setUTCSeconds(dt.getUTCSeconds() + value);\n\t\t\treturn dt;\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'min':\n\t\tcase 'minutes':\n\t\t\tdt.setUTCMinutes(dt.getUTCMinutes() + value);\n\t\t\treturn dt;\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\tdt.setUTCHours(dt.getUTCHours() + value);\n\t\t\treturn dt;\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + value);\n\t\t\treturn dt;\n\t\tcase 'w':\n\t\tcase 'ww':\n\t\tcase 'week':\n\t\tcase 'weeks':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + (value * 7));\n\t\t\treturn dt;\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\tdt.setUTCMonth(dt.getUTCMonth() + value);\n\t\t\treturn dt;\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\tdt.setUTCFullYear(dt.getUTCFullYear() + value);\n\t\t\treturn dt;\n\t}\n\treturn dt;\n};\n\n/**\n * Date difference\n * @param  {Date/Number/String} date Optional.\n * @param  {String} type Date type: minutes, seconds, hours, days, months, years\n * @return {Number}\n */\nDP.diff = function(date, type) {\n\n\tif (arguments.length === 1) {\n\t\ttype = date;\n\t\tdate = Date.now();\n\t} else {\n\t\tvar to = typeof(date);\n\t\tif (to === 'string')\n\t\t\tdate = Date.parse(date);\n\t\telse if (exports.isDate(date))\n\t\t\tdate = date.getTime();\n\t}\n\n\tvar r = this.getTime() - date;\n\n\tswitch (type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\treturn Math.ceil(r / 1000);\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'minutes':\n\t\t\treturn Math.ceil((r / 1000) / 60);\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\treturn Math.ceil(((r / 1000) / 60) / 60);\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / 24);\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28));\n\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28 * 12));\n\t}\n\n\treturn NaN;\n};\n\nDP.extend = function(date) {\n\tvar dt = new Date(this);\n\tvar match = date.match(regexpDATE);\n\n\tif (!match)\n\t\treturn dt;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\t\tvar m = match[i];\n\t\tvar arr, tmp;\n\n\t\tif (m.indexOf(':') !== -1) {\n\n\t\t\tarr = m.split(':');\n\t\t\ttmp = +arr[0];\n\t\t\ttmp >= 0 && dt.setUTCHours(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMinutes(tmp);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCSeconds(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('-') !== -1) {\n\t\t\tarr = m.split('-');\n\n\t\t\ttmp = +arr[0];\n\t\t\ttmp && dt.setUTCFullYear(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCDate(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('.') !== -1) {\n\t\t\tarr = m.split('.');\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\t!isNaN(tmp) && dt.setUTCFullYear(tmp);\n\t\t\t}\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\t!isNaN(tmp) && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\ttmp = +arr[0];\n\t\t\t!isNaN(tmp) && dt.setUTCDate(tmp);\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn dt;\n};\n\n/**\n * Compare dates\n * @param {Date} date\n * @return {Number} Results: -1 = current date is earlier than @date, 0 = current date is same as @date, 1 = current date is later than @date\n */\nDP.compare = function(date) {\n\n\tvar self = this;\n\tvar r = self.getTime() - date.getTime();\n\n\tif (r === 0)\n\t\treturn 0;\n\n\tif (r < 0)\n\t\treturn -1;\n\n\treturn 1;\n};\n\n/**\n * Compare two dates\n * @param {String or Date} d1\n * @param {String or Date} d2\n * @return {Number} Results: -1 = @d1 is earlier than @d2, 0 = @d1 is same as @d2, 1 = @d1 is later than @d2\n */\nDate.compare = function(d1, d2) {\n\n\tif (typeof(d1) === 'string')\n\t\td1 = d1.parseDate();\n\n\tif (typeof(d2) === 'string')\n\t\td2 = d2.parseDate();\n\n\treturn d1.compare(d2);\n};\n\n/**\n * Format datetime\n * @param {String} format\n * @return {String}\n */\nDP.format = function(format, resource) {\n\n\tif (!format)\n\t\treturn this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).toString().padLeft(2, '0') + '-' + this.getUTCDate().toString().padLeft(2, '0') + 'T' + this.getUTCHours().toString().padLeft(2, '0') + ':' + this.getUTCMinutes().toString().padLeft(2, '0') + ':' + this.getUTCSeconds().toString().padLeft(2, '0') + '.' + this.getUTCMilliseconds().toString().padLeft(3, '0') + 'Z';\n\n\tif (datetimeformat[format])\n\t\treturn datetimeformat[format](this, resource);\n\n\tvar key = format;\n\tvar half = false;\n\n\tif (format && format[0] === '!') {\n\t\thalf = true;\n\t\tformat = format.substring(1);\n\t}\n\n\tvar beg = '\\'+';\n\tvar end = '+\\'';\n\tvar before = [];\n\n\tvar ismm = false;\n\tvar isdd = false;\n\tvar isww = false;\n\n\tformat = format.replace(regexpDATEFORMAT, function(key) {\n\t\tswitch (key) {\n\t\t\tcase 'yyyy':\n\t\t\tcase 'YYYY':\n\t\t\t\treturn beg + 'd.getFullYear()' + end;\n\t\t\tcase 'yy':\n\t\t\tcase 'YY':\n\t\t\t\treturn beg + 'd.getFullYear().toString().substring(2)' + end;\n\t\t\tcase 'MMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(F.resource(resource, mm) || mm).substring(0, 3)' + end;\n\t\t\tcase 'MMMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(F.resource(resource, mm) || mm)' + end;\n\t\t\tcase 'MM':\n\t\t\t\treturn beg + '(d.getMonth() + 1).toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'M':\n\t\t\t\treturn beg + '(d.getMonth() + 1)' + end;\n\t\t\tcase 'ddd':\n\t\t\tcase 'DDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(F.resource(resource, dd) || dd).substring(0, 2).toUpperCase()' + end;\n\t\t\tcase 'dddd':\n\t\t\tcase 'DDDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(F.resource(resource, dd) || dd)' + end;\n\t\t\tcase 'dd':\n\t\t\tcase 'DD':\n\t\t\t\treturn beg + 'd.getDate().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\treturn beg + 'd.getDate()' + end;\n\t\t\tcase 'HH':\n\t\t\tcase 'hh':\n\t\t\t\treturn beg + (half ? 'framework_utils.$pmam(d.getHours()).toString().padLeft(2, \\'0\\')' : 'd.getHours().toString().padLeft(2, \\'0\\')') + end;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\treturn beg + (half ? 'framework_utils(d.getHours())' : 'd.getHours()') + end;\n\t\t\tcase 'mm':\n\t\t\t\treturn beg + 'd.getMinutes().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'm':\n\t\t\t\treturn beg + 'd.getMinutes()' + end;\n\t\t\tcase 'ss':\n\t\t\t\treturn beg + 'd.getSeconds().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 's':\n\t\t\t\treturn beg + 'd.getSeconds()' + end;\n\t\t\tcase 'w':\n\t\t\tcase 'ww':\n\t\t\t\tisww = true;\n\t\t\t\treturn beg + (key === 'ww' ? 'ww.toString().padLeft(2, \\'0\\')' : 'ww') + end;\n\t\t\tcase 'a':\n\t\t\t\tvar b = \"'PM':'AM'\";\n\t\t\t\treturn beg + '(d.getHours() >= 12 ? ' + b + ')' + end;\n\t\t}\n\t});\n\n\tismm && before.push('var mm = framework_utils.MONTHS[d.getMonth()];');\n\tisdd && before.push('var dd = framework_utils.DAYS[d.getDay()];');\n\tisww && before.push('var ww = new Date(+d);ww.setHours(0, 0, 0);ww.setDate(ww.getDate() + 4 - (ww.getDay() || 7));ww = Math.ceil((((ww - new Date(ww.getFullYear(), 0, 1)) / 8.64e7) + 1) / 7);');\n\n\tdatetimeformat[key] = new Function('d', 'resource', before.join('\\n') + 'return \\'' + format + '\\';');\n\treturn datetimeformat[key](this, resource);\n};\n\nexports.$pmam = function(value) {\n\treturn value >= 12 ? value - 12 : value;\n};\n\nDP.toUTC = function(ticks) {\n\tvar dt = this.getTime() + this.getTimezoneOffset() * 60000;\n\treturn ticks ? dt : new Date(dt);\n};\n\n// +v2.2.0 parses JSON dates as dates and this is the fallback for backward compatibility\nDP.parseDate = function() {\n\treturn this;\n};\n\nSP.isJSONDate = function() {\n\tvar l = this.length - 1;\n\treturn l > 22 && l < 30 && this[l] === 'Z' && this[10] === 'T' && this[4] === '-' && this[13] === ':' && this[16] === ':';\n};\n\nSP.ROOT = function(noremap) {\n\n\tvar str = this;\n\n\tstr = str.replace(REG_NOREMAP, function() {\n\t\tnoremap = true;\n\t\treturn '';\n\t}).replace(REG_ROOT, $urlmaker);\n\n\tif (!noremap && CONF.default_root)\n\t\tstr = str.replace(REG_REMAP, $urlremap).replace(REG_AJAX, $urlajax);\n\n\treturn str;\n};\n\nfunction $urlremap(text) {\n\tvar pos = text[0] === 'h' ? 6 : 5;\n\treturn REG_URLEXT.test(text) ? text : ((text[0] === 'h' ? 'href' : 'src') + '=\"' + CONF.default_root + (text[pos] === '/' ? text.substring(pos + 1) : text));\n}\n\nfunction $urlajax(text) {\n\treturn text.substring(0, text.length - 1) + CONF.default_root;\n}\n\nfunction $urlmaker(text) {\n\tvar c = text[4];\n\treturn CONF.default_root ? CONF.default_root : (c || '');\n}\n\nif (!SP.trim) {\n\tSP.trim = function() {\n\t\treturn this.replace(regexpTRIM, '');\n\t};\n}\n\nif (!SP.replaceAt) {\n\tSP.replaceAt = function(index, character) {\n\t\treturn this.substr(0, index) + character + this.substr(index + character.length);\n\t};\n}\n\n/**\n * Checks if the string starts with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.startsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.startsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(0, length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr(ignoreCase, length);\n\telse\n\t\ttmp = self.substring(0, length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\n/**\n * Checks if the string ends with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.endsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.endsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(self.length - length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr((self.length - ignoreCase) - length, length);\n\telse\n\t\ttmp = self.substring(self.length - length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\nSP.replacer = function(find, text) {\n\tvar self = this;\n\tvar beg = self.indexOf(find);\n\treturn beg === -1 ? self : (self.substring(0, beg) + text + self.substring(beg + find.length));\n};\n\n/**\n * Hash string\n * @param {String} type Hash type.\n * @param {String} salt Optional, salt.\n * @return {String}\n */\nSP.hash = function(type, salt) {\n\tvar str = salt ? this + salt : this;\n\tswitch (type) {\n\t\tcase 'md5':\n\t\t\treturn str.md5();\n\t\tcase 'sha1':\n\t\t\treturn str.sha1();\n\t\tcase 'sha256':\n\t\t\treturn str.sha256();\n\t\tcase 'sha512':\n\t\t\treturn str.sha512();\n\t\tcase 'crc32':\n\t\t\treturn str.crc32();\n\t\tcase 'crc32unsigned':\n\t\t\treturn str.crc32(true);\n\t\tdefault:\n\t\t\tvar val = string_hash(str);\n\t\t\treturn type === true ? val >>> 0 : val;\n\t}\n};\n\nglobal.HASH = function(value, type) {\n\treturn value.hash(type ? type : true);\n};\n\nSP.makeid = function() {\n\treturn this.hash(true).toString(16);\n};\n\nSP.crc32 = function(unsigned) {\n\tvar crc = -1;\n\tfor (var i = 0, length = this.length; i < length; i++)\n\t\tcrc = (crc >>> 8) ^ CRC32TABLE[(crc ^ this.charCodeAt(i)) & 0xFF];\n\tvar val = crc ^ (-1);\n\treturn unsigned ? val >>> 0 : val;\n};\n\nfunction string_hash(s, convert) {\n\tvar hash = 0;\n\tif (s.length === 0)\n\t\treturn convert ? '' : hash;\n\tfor (var i = 0, l = s.length; i < l; i++) {\n\t\tvar char = s.charCodeAt(i);\n\t\thash = ((hash << 5) - hash) + char;\n\t\thash |= 0;\n\t}\n\treturn hash;\n}\n\nSP.count = function(text) {\n\tvar index = 0;\n\tvar count = 0;\n\tdo {\n\t\tindex = this.indexOf(text, index + text.length);\n\t\tif (index > 0)\n\t\t\tcount++;\n\t} while (index > 0);\n\treturn count;\n};\n\nSP.parseXML = function(replace) {\n\treturn F.onParseXML(this, replace);\n};\n\nSP.parseJSON = function(date) {\n\treturn exports.parseJSON(this, date);\n};\n\nSP.parseQuery = function() {\n\treturn exports.parseQuery(this);\n};\n\nSP.parseUA = function(structured) {\n\n\tvar ua = this;\n\n\tif (!ua)\n\t\treturn '';\n\n\tvar arr = ua.match(regexpUA);\n\tvar uid = '';\n\n\tif (arr) {\n\n\t\tvar data = {};\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\n\t\t\tif (arr[i] === 'like' && arr[i + 1] === 'Gecko') {\n\t\t\t\ti += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar key = arr[i].toLowerCase();\n\t\t\tif (key === 'like')\n\t\t\t\tbreak;\n\n\t\t\tswitch (key) {\n\t\t\t\tcase 'linux':\n\t\t\t\tcase 'windows':\n\t\t\t\tcase 'mac':\n\t\t\t\tcase 'symbian':\n\t\t\t\tcase 'symbos':\n\t\t\t\tcase 'tizen':\n\t\t\t\tcase 'android':\n\t\t\t\t\tdata[arr[i]] = 2;\n\t\t\t\t\tif (key === 'tizen' || key === 'android')\n\t\t\t\t\t\tdata.Mobile = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'webos':\n\t\t\t\t\tdata.WebOS = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'media':\n\t\t\t\tcase 'center':\n\t\t\t\tcase 'tv':\n\t\t\t\tcase 'smarttv':\n\t\t\t\tcase 'smart':\n\t\t\t\t\tdata[arr[i]] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'iemobile':\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipad':\n\t\t\t\tcase 'ipod':\n\t\t\t\tcase 'iphone':\n\t\t\t\t\tdata.iOS = 2;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tif (key === 'ipad')\n\t\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'phone':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tizenbrowser':\n\t\t\t\tcase 'blackberry':\n\t\t\t\tcase 'mini':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'samsungbrowser':\n\t\t\t\tcase 'chrome':\n\t\t\t\tcase 'firefox':\n\t\t\t\tcase 'msie':\n\t\t\t\tcase 'opera':\n\t\t\t\tcase 'brave':\n\t\t\t\tcase 'vivaldi':\n\t\t\t\tcase 'outlook':\n\t\t\t\tcase 'safari':\n\t\t\t\tcase 'mail':\n\t\t\t\tcase 'edge':\n\t\t\t\tcase 'maxthon':\n\t\t\t\tcase 'electron':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'trident':\n\t\t\t\t\tdata.MSIE = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opr':\n\t\t\t\t\tdata.Opera = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tablet':\n\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data.MSIE) {\n\t\t\tdata.IE = 1;\n\t\t\tdelete data.MSIE;\n\t\t}\n\n\t\tif (data.WebOS || data.Android)\n\t\t\tdelete data.Linux;\n\n\t\tif (data.IEMobile) {\n\t\t\tif (data.Android)\n\t\t\t\tdelete data.Android;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t} else if (data.MSIE) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Edge) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Opera || data.Electron) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Chrome) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.SamsungBrowser)\n\t\t\t\tdelete data.SamsungBrowser;\n\t\t} else if (data.SamsungBrowser) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t}\n\n\t\tif (structured) {\n\t\t\tvar keys = Object.keys(data);\n\t\t\tvar output = { os: '', browser: '', device: 'desktop' };\n\n\t\t\tif (data.Tablet)\n\t\t\t\toutput.device = 'tablet';\n\t\t\telse if (data.Mobile)\n\t\t\t\toutput.device = 'mobile';\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar val = data[keys[i]];\n\t\t\t\tswitch (val) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\toutput.browser += (output.browser ? ' ' : '') + keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutput.os += (output.os ? ' ' : '') + keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\toutput.device = 'tv';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tuid = Object.keys(data).join(' ');\n\t}\n\n\treturn uid;\n};\n\nSP.parseCSV = function(delimiter) {\n\n\tif (!delimiter)\n\t\tdelimiter = ',';\n\n\tvar delimiterstring = '\"';\n\tvar t = this;\n\tvar scope;\n\tvar tmp = {};\n\tvar index = 1;\n\tvar data = [];\n\tvar current = 'a';\n\n\tfor (var i = 0; i < t.length; i++) {\n\t\tvar c = t[i];\n\n\t\tif (!scope) {\n\n\t\t\tif (c === '\\n' || c === '\\r') {\n\t\t\t\ttmp && data.push(tmp);\n\t\t\t\tindex = 1;\n\t\t\t\tcurrent = 'a';\n\t\t\t\ttmp = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === delimiter) {\n\t\t\t\tcurrent = String.fromCharCode(97 + index);\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (c === delimiterstring) {\n\t\t\t// Check escaped quotes\n\t\t\tif (scope && t[i + 1] === delimiterstring) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tscope = c === scope ? '' : c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!tmp)\n\t\t\ttmp = {};\n\n\t\tif (tmp[current])\n\t\t\ttmp[current] += c;\n\t\telse\n\t\t\ttmp[current] = c;\n\t}\n\n\ttmp && data.push(tmp);\n\treturn data;\n};\n\nSP.parseTerminal = function(fields, fn, skip, take) {\n\n\tvar lines = this.split('\\n');\n\n\tif (typeof(fields) === 'function') {\n\t\ttake = skip;\n\t\tskip = fn;\n\t\tfn = fields;\n\t\tparseTerminal2(lines, fn, skip, take);\n\t\treturn this;\n\t}\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tvar headers = [];\n\tvar indexer = 0;\n\tvar line = lines[0];\n\n\tif (!line) {\n\t\tline = lines[1];\n\t\tskip++;\n\t}\n\n\tif (!line) {\n\t\tline = lines[2];\n\t\tskip++;\n\t}\n\n\tif (!line)\n\t\treturn this;\n\n\tvar fieldslength = fields.length;\n\tvar tmp;\n\n\tfor (var i = 0, length = fieldslength; i < length; i++) {\n\t\tvar field = fields[i];\n\n\t\tvar beg = -1;\n\t\tvar end = -1;\n\t\tvar type = typeof(field);\n\n\t\tif (type === 'object' && field.test) {\n\t\t\ttmp = line.match(field);\n\t\t\tif (tmp) {\n\t\t\t\tbeg = tmp.index;\n\t\t\t\tend = beg + tmp.toString().length;\n\t\t\t} else {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t}\n\t\t} else if (type === 'string') {\n\t\t\ttmp = line.indexOf(field);\n\t\t\tif (tmp === -1) {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t} else {\n\t\t\t\tbeg = tmp;\n\t\t\t\tend = line.indexOf(' ', beg + field.length);\n\t\t\t}\n\t\t}\n\n\t\theaders.push({ beg: beg, end: end });\n\t}\n\n\tfor (var i = skip + 1, length = skip + 1 + take; i < length; i++) {\n\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\n\t\tvar arr = [];\n\t\tvar is = false;\n\t\tvar beg;\n\n\t\tfor (var j = 0; j < fieldslength; j++) {\n\t\t\tvar header = headers[j];\n\t\t\tif (header.beg !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbeg = 0;\n\n\t\t\t\tfor (var k = header.beg; k > -1; k--) {\n\t\t\t\t\tif (line[k] === ' ') {\n\t\t\t\t\t\tbeg = k + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tarr.push(line.substring(beg, header.end === -1 ? undefined : header.end).trim());\n\t\t\t} else\n\t\t\t\tarr.push('');\n\t\t}\n\n\t\tis && fn(arr, indexer++, length, i);\n\t}\n\n\treturn this;\n};\n\nfunction parseTerminal2(lines, fn, skip, take) {\n\tvar indexer = 0;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tfor (var i = skip, length = skip + take; i < length; i++) {\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\t\tvar m = line.match(regexpTERMINAL);\n\t\tm && fn(m, indexer++, length, i);\n\t}\n}\n\nfunction parseDateFormat(format, val) {\n\n\tvar tmp = [];\n\tvar tmpformat = [];\n\tvar prev = '';\n\tvar prevformat = '';\n\tvar allowed = { y: 1, Y: 1, M: 1, m: 1, d: 1, D: 1, H: 1, s: 1, a: 1, w: 1 };\n\n\tfor (var i = 0; i < format.length; i++) {\n\n\t\tvar c = format[i];\n\n\t\tif (!allowed[c])\n\t\t\tcontinue;\n\n\t\tif (prev !== c) {\n\t\t\tprevformat && tmpformat.push(prevformat);\n\t\t\tprevformat = c;\n\t\t\tprev = c;\n\t\t} else\n\t\t\tprevformat += c;\n\t}\n\n\tprev = '';\n\n\tfor (var i = 0; i < val.length; i++) {\n\t\tvar code = val.charCodeAt(i);\n\t\tif (code >= 48 && code <= 57)\n\t\t\tprev += val[i];\n\t}\n\n\tprevformat && tmpformat.push(prevformat);\n\n\tvar f = 0;\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar l = tmpformat[i].length;\n\t\ttmp.push(prev.substring(f, f + l));\n\t\tf += l;\n\t}\n\n\tvar dt = {};\n\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar type = tmpformat[i];\n\t\tif (tmp[i])\n\t\t\tdt[type[0]] = +tmp[i];\n\t}\n\n\tvar h = dt.h || dt.H;\n\n\tif (h != null) {\n\t\tvar ampm = val.match(REG_TIME);\n\t\tif (ampm && ampm[0].toLowerCase() === 'pm')\n\t\t\th += 12;\n\t}\n\n\treturn new Date((dt.y || dt.Y) || 0, (dt.M || 1) - 1, dt.d || dt.D || 0, h || 0, dt.m || 0, dt.s || 0);\n}\n\nSP.parseDate = function(format) {\n\n\tif (format)\n\t\treturn parseDateFormat(format, this);\n\n\tvar self = this.trim();\n\tvar lc = self.charCodeAt(self.length - 1);\n\n\t// Classic date\n\tif (lc === 41)\n\t\treturn new Date(self);\n\n\t// JSON format\n\tif (lc === 90)\n\t\treturn new Date(Date.parse(self));\n\n\tvar arr = self.indexOf(' ') === -1 ? self.split('T') : self.split(' ');\n\tvar index = arr[0].indexOf(':');\n\tvar length = arr[0].length;\n\n\tif (index !== -1) {\n\t\tvar tmp = arr[1];\n\t\tarr[1] = arr[0];\n\t\tarr[0] = tmp;\n\t}\n\n\tif (arr[0] === undefined)\n\t\tarr[0] = '';\n\n\tvar noTime = arr[1] === undefined ? true : arr[1].length === 0;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = arr[0].charCodeAt(i);\n\t\tif (c === 45 || c === 46 || (c > 47 && c < 58))\n\t\t\tcontinue;\n\t\tif (noTime)\n\t\t\treturn new Date(self);\n\t}\n\n\tif (arr[1] === undefined)\n\t\tarr[1] = '00:00:00';\n\n\tvar firstDay = arr[0].indexOf('-') === -1;\n\n\tvar date = (arr[0] || '').split(firstDay ? '.' : '-');\n\tvar time = (arr[1] || '').split(':');\n\tvar parsed = [];\n\n\tif (date.length < 4 && time.length < 2)\n\t\treturn new Date(self);\n\n\tindex = (time[2] || '').indexOf('.');\n\n\t// milliseconds\n\tif (index !== -1) {\n\t\ttime[3] = time[2].substring(index + 1);\n\t\ttime[2] = time[2].substring(0, index);\n\t} else\n\t\ttime[3] = '0';\n\n\tparsed.push(+date[firstDay ? 2 : 0]); // year\n\tparsed.push(+date[1]); // month\n\tparsed.push(+date[firstDay ? 0 : 2]); // day\n\tparsed.push(+time[0]); // hours\n\tparsed.push(+time[1]); // minutes\n\tparsed.push(+time[2]); // seconds\n\tparsed.push(+time[3]); // miliseconds\n\n\tvar def = new Date();\n\n\tfor (var i = 0, length = parsed.length; i < length; i++) {\n\t\tif (isNaN(parsed[i]))\n\t\t\tparsed[i] = 0;\n\n\t\tvar value = parsed[i];\n\t\tif (value !== 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getFullYear();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getMonth() + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getDate();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new Date(parsed[0], parsed[1] - 1, parsed[2], parsed[3], parsed[4] - NOW.getTimezoneOffset(), parsed[5]);\n};\n\nSP.parseDateExpiration = function() {\n\tvar self = this;\n\n\tvar arr = self.split(' ');\n\tvar dt = new Date();\n\tvar length = arr.length;\n\n\tfor (var i = 0; i < length; i += 2) {\n\t\tvar num = arr[i].parseInt();\n\t\tif (num === 0)\n\t\t\tcontinue;\n\t\tvar type = arr[i + 1];\n\t\tif (type)\n\t\t\tdt = dt.add(type, num);\n\t}\n\n\treturn dt;\n};\n\nSP.contains = function(value, mustAll) {\n\tvar str = this;\n\n\tif (typeof(value) === 'string')\n\t\treturn str.indexOf(value, typeof(mustAll) === 'number' ? mustAll : 0) !== -1;\n\n\tfor (var i = 0, length = value.length; i < length; i++) {\n\t\tvar exists = str.indexOf(value[i]) !== -1;\n\t\tif (mustAll) {\n\t\t\tif (!exists)\n\t\t\t\treturn false;\n\t\t} else if (exists)\n\t\t\treturn true;\n\t}\n\n\treturn mustAll;\n};\n\n/**\n * Same functionality as as String.localeCompare() but this method works with latin.\n * @param {String} value\n * @return {Number}\n */\nSP.localeCompare2 = function(value) {\n\treturn COMPARER(this, value);\n};\n\nvar configurereplace = function(text) {\n\tvar val = CONF[text.substring(1, text.length - 1)];\n\treturn val == null ? '' : val;\n};\n\nSP.env = function() {\n\treturn this.replace(regexpCONFIGURE, configurereplace);\n};\n\n/**\n * Parse configuration from a string\n * @param {Object} def\n * @onerr {Function} error handling\n * @return {Object}\n */\nSP.parseConfig = function(def, onerr) {\n\n\tif (typeof(def) === 'function') {\n\t\tonerr = def;\n\t\tdef = null;\n\t}\n\n\tvar arr = this.split('\\n');\n\tvar length = arr.length;\n\tvar obj = def ? exports.extend({}, def) : {};\n\tvar subtype;\n\tvar name;\n\tvar index;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 2) === '//')\n\t\t\tcontinue;\n\n\t\tindex = str.indexOf(':');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tname = str.substring(0, index).trim();\n\t\tvalue = str.substring(index + 2).trim();\n\n\t\tindex = name.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (subtype) {\n\t\t\tcase 'string':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'float':\n\t\t\tcase 'double':\n\t\t\tcase 'currency':\n\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\t\tobj[name] = CONF[value];\n\t\t\t\tbreak;\n\t\t\tcase 'eval':\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\ttry {\n\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onerr)\n\t\t\t\t\t\tonerr(e, arr[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error('A value of \"{0}\" can\\'t be converted to \"{1}\": '.format(name, subtype) + e.toString());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tobj[name] = value.parseJSON(true);\n\t\t\t\tbreak;\n\t\t\tcase 'env':\n\t\t\tcase 'environment':\n\t\t\t\tobj[name] = process.env[value];\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\tcase 'time':\n\t\t\tcase 'datetime':\n\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\tbreak;\n\t\t\tcase 'random':\n\t\t\t\tobj[name] = GUID((value || '0').parseInt() || 10);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.format = function() {\n\tvar arg = arguments;\n\treturn this.replace(regexpSTRINGFORMAT, function(text) {\n\t\tvar value = arg[+text.substring(1, text.length - 1)];\n\t\treturn value == null ? '' : value;\n\t});\n};\n\nSP.encryptUID = function(key) {\n\treturn exports.encryptUID(this, key);\n};\n\nSP.decryptUID = function(key) {\n\treturn exports.decryptUID(this, key);\n};\n\nSP.encode = function() {\n\tvar output = '';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i];\n\t\tswitch (c) {\n\t\t\tcase '<':\n\t\t\t\toutput += '&lt;';\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\toutput += '&gt;';\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\toutput += '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\toutput += '&apos;';\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\toutput += '&amp;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutput += c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn output;\n};\n\nSP.decode = function() {\n\treturn this.replace(regexpDECODE, function(s) {\n\t\tif (s.charAt(1) !== '#')\n\t\t\treturn ALPHA_INDEX[s] || s;\n\t\tvar code = s[2].toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));\n\t\treturn !code || code < -32768 || code > 65535 ? '' : String.fromCharCode(code);\n\t});\n};\n\nSP.urlEncode = function() {\n\treturn encodeURIComponent(this);\n};\n\nSP.urlDecode = function() {\n\treturn decodeURIComponent(this);\n};\n\nSP.arg = function(obj, encode, def) {\n\tif (typeof(encode) === 'string')\n\t\tdef = encode;\n\treturn this.replace(regexpARG, function(text) {\n\t\t// Is double?\n\t\tvar l = text[1] === '{' ? 2 : 1;\n\t\tvar val = obj[text.substring(l, text.length - l).trim()];\n\t\tif (encode && encode === 'json')\n\t\t\treturn JSON.stringify(val);\n\t\treturn val == null ? (def == null ? text : def) : encode ? encode === 'html' ? (val + '').encode() : encodeURIComponent(val + '') : val;\n\t});\n};\n\nSP.params = function(obj) {\n\n\tOBSOLETE('String.params()', 'The method is deprecated instead of it use F.viewCompile() or String.format().');\n\n\tvar formatted = this;\n\tif (obj == null)\n\t\treturn formatted;\n\n\treturn formatted.replace(regexpPARAM, function(prop) {\n\n\t\tvar isEncode = false;\n\t\tvar name = prop.substring(2, prop.length - 2).trim();\n\n\t\tvar format = '';\n\t\tvar index = name.indexOf('|');\n\n\t\tif (index !== -1) {\n\t\t\tformat = name.substring(index + 1, name.length).trim();\n\t\t\tname = name.substring(0, index).trim();\n\t\t}\n\n\t\tif (name[0] === '!')\n\t\t\tname = name.substring(1);\n\t\telse\n\t\t\tisEncode = true;\n\n\t\tvar val;\n\n\t\tif (name.indexOf('.') !== -1) {\n\t\t\tvar arr = name.split('.');\n\t\t\tif (arr.length === 2) {\n\t\t\t\tif (obj[arr[0]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]];\n\t\t\t} else if (arr.length === 3) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]];\n\t\t\t} else if (arr.length === 4) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]] && obj[arr[0]][arr[1]][arr[2]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]][arr[3]];\n\t\t\t} else if (arr.length === 5) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]] && obj[arr[0]][arr[1]][arr[2]] && obj[arr[0]][arr[1]][arr[2]][arr[3]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]][arr[3]][arr[4]];\n\t\t\t}\n\t\t} else\n\t\t\tval = name.length ? obj[name] : obj;\n\n\t\tif (typeof(val) === 'function')\n\t\t\tval = val(index);\n\n\t\tif (val === undefined)\n\t\t\treturn prop;\n\n\t\tif (format.length) {\n\t\t\tvar type = typeof(val);\n\t\t\tif (type === 'string') {\n\t\t\t\tvar max = +format;\n\t\t\t\tif (!isNaN(max))\n\t\t\t\t\tval = val.max(max + 3, '...');\n\n\t\t\t} else if (type === 'number' || exports.isDate(val)) {\n\t\t\t\tif (format.isNumber())\n\t\t\t\t\tformat = +format;\n\t\t\t\tval = val.format(format);\n\t\t\t}\n\t\t}\n\n\t\tval = val.toString();\n\t\treturn isEncode ? exports.encode(val) : val;\n\t});\n};\n\nSP.max = function(length, chars) {\n\tvar str = this;\n\tif (typeof(chars) !== 'string')\n\t\tchars = '...';\n\treturn str.length > length ? str.substring(0, length - chars.length) + chars : str;\n};\n\nSP.isJSON = function() {\n\tvar self = this;\n\tif (self.length <= 1)\n\t\treturn false;\n\n\tvar l = self.length - 1;\n\tvar a;\n\tvar b;\n\tvar i = 0;\n\n\twhile (true) {\n\t\ta = self[i++];\n\t\tif (a === ' ' || a === '\\n' || a === '\\r' || a === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\twhile (true) {\n\t\tb = self[l--];\n\t\tif (b === ' ' || b === '\\n' || b === '\\r' || b === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn (a === '\"' && b === '\"') || (a === '[' && b === ']') || (a === '{' && b === '}') || (a.charCodeAt(0) > 47 && b.charCodeAt(0) < 57);\n};\n\nSP.isURL = function() {\n\treturn this.length <= 7 ? false : F.validators.url.test(this);\n};\n\nSP.isZIP = function() {\n\treturn F.validators.zip.test(this);\n};\n\nSP.isEmail = function() {\n\treturn this.length <= 4 ? false : F.validators.email.test(this);\n};\n\nSP.isPhone = function() {\n\treturn this.length < 6 ? false : F.validators.phone.test(this);\n};\n\nSP.isBase64 = function() {\n\tvar str = this;\n\treturn str.length % 4 === 0 && regexpBASE64.test(str);\n};\n\nSP.isUID = function() {\n\tvar str = this;\n\n\tif (str.length < 12)\n\t\treturn false;\n\n\tvar is = DEF.validators.uid.test(str);\n\tif (is) {\n\n\t\tvar sum;\n\t\tvar beg;\n\t\tvar end;\n\t\tvar e = str[str.length - 1];\n\n\t\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = +str[str.length - 3];\n\t\t\tend = str.length - 5;\n\t\t\tvar tmp = e === 'c' || e === 'd' ? (+str.substring(beg, end)) : parseInt(str.substring(beg, end), 16);\n\t\t\treturn sum === (tmp % 2 ? '1' : '0');\n\t\t} else if (e === 'a') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = 6;\n\t\t\tend = str.length - 4;\n\t\t} else {\n\t\t\tsum = str[str.length - 1];\n\t\t\tbeg = 10;\n\t\t\tend = str.length - 4;\n\t\t}\n\n\t\twhile (beg++ < end) {\n\t\t\tif (str[beg] !== '0') {\n\t\t\t\tif (((+str.substring(beg, end)) % 2 ? '1' : '0') === sum)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nSP.parseUID = function() {\n\tvar self = this;\n\tvar obj = {};\n\tvar hash;\n\tvar e = self[self.length - 1];\n\n\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\tend = +self[self.length - 3];\n\t\tvar ticks = ((e === 'b' ? (+self.substring(0, end)) : parseInt(self.substring(0, end), e=== 'd' ? 36 : 16)) * 1000 * 60) + 1580511600000; // 1.1.2020\n\t\tobj.date = new Date(ticks);\n\t\tbeg = end;\n\t\tend = self.length - 5;\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else if (e === 'a') {\n\t\tvar ticks = ((+self.substring(0, 6)) * 1000 * 60) + 1548975600000; // old 1.1.2019\n\t\tobj.date = new Date(ticks);\n\t\tbeg = 7;\n\t\tend = self.length - 4;\n\t\thash = +self.substring(end + 2, end + 3);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else {\n\t\tvar y = self.substring(0, 2);\n\t\tvar M = self.substring(2, 4);\n\t\tvar d = self.substring(4, 6);\n\t\tvar H = self.substring(6, 8);\n\t\tvar m = self.substring(8, 10);\n\n\t\tobj.date = new Date(+('20' + y), (+M) - 1, +d, +H, +m, 0);\n\n\t\tvar beg = 0;\n\t\tvar end = 0;\n\t\tvar index = 10;\n\n\t\twhile (true) {\n\n\t\t\tvar c = self[index];\n\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\n\t\t\tif (!beg && c !== '0')\n\t\t\t\tbeg = index;\n\n\t\t\tif (c.charCodeAt(0) > 96) {\n\t\t\t\tend = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\n\t\tobj.century = self.substring(end + 4);\n\n\t\tif (obj.century) {\n\t\t\tobj.century = 20 + (+obj.century);\n\t\t\tobj.date.setYear(obj.date.getFullYear() + 100);\n\t\t} else\n\t\t\tobj.century = 21;\n\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.hash = self.substring(end, end + 3);\n\t}\n\n\tobj.index = +self.substring(beg, end);\n\tobj.valid = (obj.index % 2 ? 1 : 0) === hash;\n\treturn obj;\n};\n\nSP.parseENV = function() {\n\n\tvar arr = this.split(regexpLINES);\n\tvar obj = {};\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar line = arr[i];\n\t\tif (!line || line.substring(0, 2) === '//' || line[0] === '#')\n\t\t\tcontinue;\n\n\t\tvar index = line.indexOf('=');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar key = line.substring(0, index);\n\t\tvar val = line.substring(index + 1).replace(/\\\\n/g, '\\n');\n\t\tvar end = val.length - 1;\n\n\t\tif ((val[0] === '\"' && val[end] === '\"') || (val[0] === '\\'' && val[end] === '\\''))\n\t\t\tval = val.substring(1, end);\n\t\telse\n\t\t\tval = val.trim();\n\n\t\tobj[key] = val;\n\t}\n\n\treturn obj;\n};\n\nSP.parseInt = function(def) {\n\tvar str = this.trim();\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.parseInt2 = function(def) {\n\tvar num = this.match(regexpINTEGER);\n\treturn num ? +num[0] : (def === undefined ? 0 : def);\n};\n\nSP.parseFloat2 = function(def) {\n\tvar num = this.match(regexpFLOAT);\n\treturn num ? +num[0].toString().replace(/,/g, '.') : (def === undefined ? 0 : def);\n};\n\nSP.parseBool = SP.parseBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn self === 'true' || self === '1' || self === 'on';\n};\n\nSP.parseFloat = function(def) {\n\tvar str = this.trim();\n\tif (str.indexOf(',') !== -1)\n\t\tstr = str.replace(',', '.');\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.capitalize = function(first) {\n\n\tif (first)\n\t\treturn (this[0] || '').toUpperCase() + this.substring(1);\n\n\tvar builder = '';\n\tvar c;\n\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i - 1];\n\t\tif (!c || (c === ' ' || c === '\\t' || c === '\\n'))\n\t\t\tc = this[i].toUpperCase();\n\t\telse\n\t\t\tc = this[i];\n\t\tbuilder += c;\n\t}\n\n\treturn builder;\n};\n\nSP.toUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tvar c = this[i].charCodeAt(0);\n\t\tif(c > 126 || c < 32)\n\t\t\toutput += '\\\\u' + ('000' + c.toString(16)).substr(-4);\n\t\telse\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.fromUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tif (this[i] === '\\\\' && this[i + 1] === 'u') {\n\t\t\toutput += String.fromCharCode(parseInt(this[i + 2] + this[i + 3] + this[i + 4] + this[i + 5], 16));\n\t\t\ti += 5;\n\t\t} else\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.sha1 = function(salt) {\n\tvar hash = Crypto.createHash('sha1');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha256 = function(salt) {\n\tvar hash = Crypto.createHash('sha256');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha512 = function(salt) {\n\tvar hash = Crypto.createHash('sha512');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.md5 = function(salt) {\n\tvar hash = Crypto.createHash('md5');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.toSearch = function() {\n\tvar str = this.replace(regexpSEARCH, '').trim().toLowerCase().removeDiacritics();\n\tvar buf = [];\n\tvar prev = '';\n\tfor (var i = 0, length = str.length; i < length; i++) {\n\t\tvar c = str[i];\n\t\tif (c === 'y')\n\t\t\tc = 'i';\n\t\tif (c === prev)\n\t\t\tcontinue;\n\t\tprev = c;\n\t\tbuf.push(c);\n\t}\n\n\treturn buf.join('');\n};\n\nSP.toKeywords = SP.keywords = function(forSearch, alternative, max_count, max_length, min_length) {\n\treturn exports.keywords(this, forSearch, alternative, max_count, max_length, min_length);\n};\n\nfunction checksum(val) {\n\tvar sum = 0;\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\treturn sum;\n}\n\nSP.encrypt = function(key, isUnique, secret) {\n\tvar str = '0' + this;\n\tvar data_count = str.length;\n\tvar key_count = key.length;\n\tvar random = isUnique ? exports.random(120) + 40 : 65;\n\tvar count = data_count + (random % key_count);\n\tvar values = [];\n\tvar index = 0;\n\n\tvalues[0] = String.fromCharCode(random);\n\n\tvar counter = this.length + key.length;\n\n\tfor (var i = count - 1; i > 0; i--) {\n\t\tindex = str.charCodeAt(i % data_count);\n\t\tvalues[i] = String.fromCharCode(index ^ (key.charCodeAt(i % key_count) ^ random));\n\t}\n\n\tstr = Buffer.from(counter + '=' + values.join(''), ENCODING).toString('hex');\n\tvar sum = 0;\n\n\tfor (var i = 0; i < str.length; i++)\n\t\tsum += str.charCodeAt(i);\n\n\treturn (sum + checksum((secret || CONF.secret) + key)) + '-' + str;\n};\n\nSP.decrypt = function(key, secret) {\n\n\tvar index = this.indexOf('-');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar cs = +this.substring(0, index);\n\tif (!cs || isNaN(cs))\n\t\treturn null;\n\n\tvar hash = this.substring(index + 1);\n\tvar sum = checksum((secret || CONF.secret) + key);\n\tfor (var i = 0; i < hash.length; i++)\n\t\tsum += hash.charCodeAt(i);\n\n\tif (sum !== cs)\n\t\treturn null;\n\n\tvar values = Buffer.from(hash, 'hex').toString(ENCODING);\n\tvar index = values.indexOf('=');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar counter = +values.substring(0, index);\n\tif (isNaN(counter))\n\t\treturn null;\n\n\tvalues = values.substring(index + 1);\n\n\tvar count = values.length;\n\tvar random = values.charCodeAt(0);\n\tvar key_count = key.length;\n\tvar data_count = count - (random % key_count);\n\tvar decrypt_data = [];\n\n\tfor (var i = data_count - 1; i > 0; i--) {\n\t\tindex = values.charCodeAt(i) ^ (random ^ key.charCodeAt(i % key_count));\n\t\tdecrypt_data[i] = String.fromCharCode(index);\n\t}\n\n\tvar val = decrypt_data.join('');\n\treturn counter !== (val.length + key.length) ? null : val;\n};\n\nexports.encryptUID = function(val, key) {\n\n\tvar num = typeof(val) === 'number';\n\tvar sum = 0;\n\n\tif (!key)\n\t\tkey = CONF.secret;\n\n\tval = val + '';\n\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\n\tfor (var i = 0; i < key.length; i++)\n\t\tsum += key.charCodeAt(i);\n\n\treturn (num ? 'n' : 'x') + (CONF.secret_uid + val + sum + key).crc32(true).toString(16) + 'x' + val;\n};\n\nexports.decryptUID = function(val, key) {\n\tvar num = val[0] === 'n';\n\tvar raw = val.substring(val.indexOf('x', 1) + 1);\n\n\tif (num)\n\t\traw = +raw;\n\n\treturn exports.encryptUID(raw, key) === val ? raw : null;\n};\n\nSP.base64ToFile = function(filename, callback) {\n\tvar self = this;\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\tFs.writeFile(filename, self.substring(index), 'base64', callback || exports.noop);\n\treturn this;\n};\n\nSP.base64ToBuffer = function() {\n\tvar self = this;\n\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\n\treturn Buffer.from(self.substring(index), 'base64');\n};\n\nSP.base64ContentType = function() {\n\tvar self = this;\n\tvar index = self.indexOf(';');\n\treturn index === -1 ? '' : self.substring(5, index);\n};\n\nSP.removeDiacritics = function() {\n\treturn exports.removeDiacritics(this);\n};\n\nSP.indent = function(max, c) {\n\tvar plus = '';\n\tif (c === undefined)\n\t\tc = ' ';\n\twhile (max--)\n\t\tplus += c;\n\treturn plus + this;\n};\n\nSP.isNumber = function(isDecimal) {\n\n\tvar self = this;\n\tvar length = self.length;\n\n\tif (!length)\n\t\treturn false;\n\n\tisDecimal = isDecimal || false;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar ascii = self.charCodeAt(i);\n\n\t\tif (isDecimal) {\n\t\t\tif (ascii === 44 || ascii === 46) {\n\t\t\t\tisDecimal = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ascii < 48 || ascii > 57)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nif (!SP.padLeft) {\n\tSP.padLeft = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself = c + self;\n\t\treturn self;\n\t};\n}\n\n\nif (!SP.padRight) {\n\tSP.padRight = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself += c;\n\t\treturn self;\n\t};\n}\n\nSP.insert = function(index, value) {\n\tvar str = this;\n\tvar a = str.substring(0, index);\n\tvar b = value.toString() + str.substring(index);\n\treturn a + b;\n};\n\n/**\n * Create a link from String\n * @param  {Number} max A maximum length, default: 60 and optional.\n * @return {String}\n */\nSP.slug = SP.toSlug = SP.toLinker = SP.linker = function(max) {\n\tmax = max || 60;\n\n\tvar self = this.trim().toLowerCase().removeDiacritics();\n\tvar builder = '';\n\tvar length = self.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = self[i];\n\t\tvar code = self.charCodeAt(i);\n\n\t\tif (code > 540){\n\t\t\tbuilder = '';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (builder.length >= max)\n\t\t\tbreak;\n\n\t\tif (code > 31 && code < 48) {\n\t\t\tif (builder[builder.length - 1] !== '-')\n\t\t\t\tbuilder += '-';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((code > 47 && code < 58) || (code > 94 && code < 123))\n\t\t\tbuilder += c;\n\t}\n\n\tif (builder.length > 1) {\n\t\tlength = builder.length - 1;\n\t\treturn builder[length] === '-' ? builder.substring(0, length) : builder;\n\t} else if (!length)\n\t\treturn '';\n\n\tlength = self.length;\n\tself = self.replace(/\\s/g, '');\n\tbuilder = self.crc32(true).toString(36) + '';\n\treturn self[0].charCodeAt(0).toString(32) + builder + self[self.length - 1].charCodeAt(0).toString(32) + length;\n};\n\nSP.pluralize = function(zero, one, few, other) {\n\treturn this.parseInt().pluralize(zero, one, few, other);\n};\n\nSP.isBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn (self === 'true' || self === 'false') ? true : false;\n};\n\n/**\n * Check if the string contains only letters and numbers.\n * @return {Boolean}\n */\nSP.isAlphaNumeric = function() {\n\treturn regexpALPHA.test(this);\n};\n\nSP.soundex = function() {\n\n\tvar arr = this.toLowerCase().split('');\n\tvar first = arr.shift();\n\tvar builder = first.toUpperCase();\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar v = SOUNDEX[arr[i]];\n\t\tif (v === undefined)\n\t\t\tcontinue;\n\t\tif (i) {\n\t\t\tif (v !== arr[i - 1])\n\t\t\t\tbuilder += v;\n\t\t} else if (v !== SOUNDEX[first])\n\t\t\tbuilder += v;\n\t}\n\n\treturn (builder + '000').substring(0, 4);\n};\n\n/**\n* Remove all Html Tags from a string\n* @return {string}\n*/\nSP.removeTags = function() {\n\treturn this.replace(regexpTags, '');\n};\n\nNP.floor = function(decimals) {\n\treturn Math.floor(this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n};\n\nNP.fixed = function(decimals) {\n\treturn +this.toFixed(decimals);\n};\n\nNP.padLeft = function(max, c) {\n\treturn this.toString().padLeft(max, c || '0');\n};\n\nNP.padRight = function(max, c) {\n\treturn this.toString().padRight(max, c || '0');\n};\n\nNP.round = function(precision) {\n\tvar m = Math.pow(10, precision) || 1;\n\treturn Math.round(this * m) / m;\n};\n\nNP.currency = function(currency, a, b, c) {\n\tvar curr = DEF.currencies[currency];\n\treturn curr ? curr(this, a, b, c) : this.format(2);\n};\n\n/**\n * Async decrements\n * @param {Function(index, next)} fn\n * @param {Function} callback\n * @return {Number}\n */\nNP.async = function(fn, callback) {\n\tvar number = this;\n\tif (number)\n\t\tfn(number--, () => setImmediate(() => number.async(fn, callback)));\n\telse\n\t\tcallback && callback();\n\treturn number;\n};\n\n/**\n * Format number\n * @param {Number} decimals Maximum decimal numbers\n * @param {String} separator Number separator, default ' '\n * @param {String} separatorDecimal Decimal separator, default '.' if number separator is ',' or ' '.\n * @return {String}\n */\nNP.format = function(decimals, separator, separatorDecimal) {\n\n\tvar self = this;\n\n\tif (typeof(decimals) === 'string')\n\t\treturn self.format2(decimals);\n\n\tvar num = self.toString();\n\tvar dec = '';\n\tvar output = '';\n\tvar minus = num[0] === '-' ? '-' : '';\n\tif (minus)\n\t\tnum = num.substring(1);\n\n\tvar index = num.indexOf('.');\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = separator;\n\t\tseparator = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tif (separator === undefined)\n\t\tseparator = ' ';\n\n\tif (index !== -1) {\n\t\tdec = num.substring(index + 1);\n\t\tnum = num.substring(0, index);\n\t}\n\n\tindex = -1;\n\tfor (var i = num.length - 1; i >= 0; i--) {\n\t\tindex++;\n\t\tif (index > 0 && index % 3 === 0)\n\t\t\toutput = separator + output;\n\t\toutput = num[i] + output;\n\t}\n\n\tif (decimals || dec.length) {\n\t\tif (dec.length > decimals)\n\t\t\tdec = dec.substring(0, decimals || 0);\n\t\telse\n\t\t\tdec = dec.padRight(decimals || 0, '0');\n\t}\n\n\tif (dec.length && separatorDecimal === undefined)\n\t\tseparatorDecimal = separator === '.' ? ',' : '.';\n\n\treturn minus + output + (dec.length ? separatorDecimal + dec : '');\n};\n\nNP.add = function(value, decimals) {\n\n\tif (value == null)\n\t\treturn this;\n\n\tif (typeof(value) === 'number')\n\t\treturn this + value;\n\n\tvar first = value.charCodeAt(0);\n\tvar is = false;\n\n\tif (first < 48 || first > 57) {\n\t\tis = true;\n\t\tvalue = value.substring(1);\n\t}\n\n\tvar length = value.length;\n\tvar num;\n\n\tif (value[length - 1] === '%') {\n\t\tvalue = value.substring(0, length - 1);\n\t\tif (is) {\n\t\t\tvar val = value.parseFloat();\n\t\t\tswitch (first) {\n\t\t\t\tcase 42:\n\t\t\t\t\tnum = this * ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 43:\n\t\t\t\t\tnum = this + ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 45:\n\t\t\t\t\tnum = this - ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 47:\n\t\t\t\t\tnum = this / ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t} else {\n\t\t\tnum = (this / 100) * value.parseFloat();\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t}\n\n\t} else\n\t\tnum = value.parseFloat();\n\n\tswitch (first) {\n\t\tcase 42:\n\t\t\tnum = this * num;\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tnum = this + num;\n\t\t\tbreak;\n\t\tcase 45:\n\t\t\tnum = this - num;\n\t\t\tbreak;\n\t\tcase 47:\n\t\t\tnum = this / num;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum = this;\n\t\t\tbreak;\n\t}\n\n\tif (decimals !== undefined)\n\t\treturn num.floor(decimals);\n\n\treturn num;\n};\n\nNP.format2 = function(format) {\n\tvar index = 0;\n\tvar num = this.toString();\n\tvar beg = 0;\n\tvar end = 0;\n\tvar max = 0;\n\tvar output = '';\n\tvar length = 0;\n\n\tif (typeof(format) === 'string') {\n\n\t\tvar d = false;\n\t\tlength = format.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar c = format[i];\n\t\t\tif (c === '#') {\n\t\t\t\tif (d)\n\t\t\t\t\tend++;\n\t\t\t\telse\n\t\t\t\t\tbeg++;\n\t\t\t}\n\n\t\t\tif (c === '.')\n\t\t\t\td = true;\n\t\t}\n\n\t\tvar strBeg = num;\n\t\tvar strEnd = '';\n\n\t\tindex = num.indexOf('.');\n\n\t\tif (index !== -1) {\n\t\t\tstrBeg = num.substring(0, index);\n\t\t\tstrEnd = num.substring(index + 1);\n\t\t}\n\n\t\tif (strBeg.length > beg) {\n\t\t\tmax = strBeg.length - beg;\n\t\t\tvar tmp = '';\n\t\t\tfor (var i = 0; i < max; i++)\n\t\t\t\ttmp += '#';\n\n\t\t\tformat = tmp + format;\n\t\t}\n\n\t\tif (strBeg.length < beg)\n\t\t\tstrBeg = strBeg.padLeft(beg, ' ');\n\n\t\tif (strEnd.length < end)\n\t\t\tstrEnd = strEnd.padRight(end, '0');\n\n\t\tif (strEnd.length > end)\n\t\t\tstrEnd = strEnd.substring(0, end);\n\n\t\td = false;\n\t\tindex = 0;\n\n\t\tvar skip = true;\n\t\tlength = format.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tvar c = format[i];\n\n\t\t\tif (c !== '#') {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (c === '.') {\n\t\t\t\t\td = true;\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\n\t\t\t\toutput += c;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar value = d ? strEnd[index] : strBeg[index];\n\n\t\t\tif (skip)\n\t\t\t\tskip = [',', ' '].indexOf(value) !== -1;\n\n\t\t\tif (!skip)\n\t\t\t\toutput += value;\n\n\t\t\tindex++;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\toutput = '### ### ###';\n\tbeg = num.indexOf('.');\n\tmax = format || 0;\n\n\tif (max === 0 && beg !== -1)\n\t\tmax = num.length - (beg + 1);\n\n\tif (max > 0) {\n\t\toutput += '.';\n\t\tfor (var i = 0; i < max; i++)\n\t\t\toutput += '#';\n\t}\n\n\treturn this.format(output);\n};\n\nNP.pluralize = function(zero, one, few, other) {\n\n\tvar num = this;\n\tvar value = '';\n\n\tif (num == 0)\n\t\tvalue = zero || '';\n\telse if (num == 1)\n\t\tvalue = one || '';\n\telse if (num > 1 && num < 5)\n\t\tvalue = few || '';\n\telse\n\t\tvalue = other;\n\n\tvar beg = value.indexOf('#');\n\tif (beg === -1)\n\t\treturn value;\n\n\tvar end = value.lastIndexOf('#');\n\tvar format = value.substring(beg, end + 1);\n\treturn num.format(format) + value.replace(format, '');\n};\n\nNP.hex = function(length) {\n\tvar str = this.toString(16).toUpperCase();\n\twhile(str.length < length)\n\t\tstr = '0' + str;\n\treturn str;\n};\n\nNP.VAT = function(percentage, decimals, includedVAT) {\n\tvar num = this;\n\tvar type = typeof(decimals);\n\n\tif (type === 'boolean') {\n\t\tvar tmp = includedVAT;\n\t\tincludedVAT = decimals;\n\t\tdecimals = tmp;\n\t\ttype = typeof(decimals);\n\t}\n\n\tif (type === 'undefined')\n\t\tdecimals = 2;\n\n\tif (includedVAT === undefined)\n\t\tincludedVAT = true;\n\n\tif (!percentage || !num)\n\t\treturn num;\n\treturn includedVAT ? (num / ((percentage / 100) + 1)).round(decimals) : (num * ((percentage / 100) + 1)).round(decimals);\n};\n\nNP.discount = function(percentage, decimals) {\n\tvar num = this;\n\tif (decimals === undefined)\n\t\tdecimals = 2;\n\treturn (num - (num / 100) * percentage).floor(decimals);\n};\n\nNP.parseDate = function(plus) {\n\treturn new Date(this + (plus || 0));\n};\n\nif (!NP.toRad) {\n\tNP.toRad = function () {\n\t\treturn this * Math.PI / 180;\n\t};\n}\n\n\nNP.filesize = function(decimals, type) {\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = type;\n\t\ttype = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tvar value;\n\n\t// this === bytes\n\tswitch (type) {\n\t\tcase 'bytes':\n\t\t\tvalue = this;\n\t\t\tbreak;\n\t\tcase 'KB':\n\t\t\tvalue = this / 1024;\n\t\t\tbreak;\n\t\tcase 'MB':\n\t\t\tvalue = filesizehelper(this, 2);\n\t\t\tbreak;\n\t\tcase 'GB':\n\t\t\tvalue = filesizehelper(this, 3);\n\t\t\tbreak;\n\t\tcase 'TB':\n\t\t\tvalue = filesizehelper(this, 4);\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\ttype = 'bytes';\n\t\t\tvalue = this;\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'KB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'MB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'GB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'TB';\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\ttype = ' ' + type;\n\treturn (decimals === undefined ? value.format(2).replace('.00', '') : value.format(decimals)) + type;\n};\n\nfunction filesizehelper(number, count) {\n\twhile (count--) {\n\t\tnumber = number / 1024;\n\t\tif (number.toFixed(3) === '0.000')\n\t\t\treturn 0;\n\t}\n\treturn number;\n}\n\nvar AP = Array.prototype;\n\n/**\n * Take items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.take = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tarr.push(self[i]);\n\t\tif (arr.length >= count)\n\t\t\treturn arr;\n\t}\n\treturn arr;\n};\n\n/**\n * Extend objects in Array\n * @param {Object} obj\n * @param {Boolean} rewrite Default: false.\n * @return {Array} Returns self\n */\nAP.extend = function(obj, rewrite) {\n\tvar isFn = typeof(obj) === 'function';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tif (isFn)\n\t\t\tthis[i] = obj(this[i], i);\n\t\telse\n\t\t\tthis[i] = exports.extend(this[i], obj, rewrite);\n\t}\n\treturn this;\n};\n\n/**\n * First item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.first = function(def) {\n\tvar item = this[0];\n\treturn item === undefined ? def : item;\n};\n\n/**\n * Create object from Array\n * @param {String} name Optional, property name.\n * @return {Object}\n */\nAP.toObject = function(name) {\n\n\tvar self = this;\n\tvar obj = {};\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tvar item = self[i];\n\t\tif (name)\n\t\t\tobj[item[name]] = item;\n\t\telse\n\t\t\tobj[item] = true;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Compare two arrays\n * @param {String} id An identificator.\n * @param {Array} b Second array.\n * @param {Function(itemA, itemB, indexA, indexB)} executor\n */\nAP.compare = function(id, b, executor) {\n\n\tvar a = this;\n\tvar ak = {};\n\tvar bk = {};\n\tvar al = a.length;\n\tvar bl = b.length;\n\tvar tl = Math.max(al, bl);\n\tvar processed = {};\n\n\tfor (var i = 0; i < tl; i++) {\n\t\tvar av = a[i];\n\t\tif (av)\n\t\t\tak[av[id]] = i;\n\t\tvar bv = b[i];\n\t\tif (bv)\n\t\t\tbk[bv[id]] = i;\n\t}\n\n\tvar index = -1;\n\n\tfor (var i = 0; i < tl; i++) {\n\n\t\tvar av = a[i];\n\t\tvar bv = b[i];\n\t\tvar akk;\n\t\tvar bkk;\n\n\t\tif (av) {\n\t\t\takk = av[id];\n\t\t\tif (processed[akk])\n\t\t\t\tcontinue;\n\t\t\tprocessed[akk] = true;\n\t\t\tindex = bk[akk];\n\t\t\tif (index === undefined)\n\t\t\t\texecutor(av, undefined, i, -1);\n\t\t\telse\n\t\t\t\texecutor(av, b[index], i, index);\n\t\t}\n\n\t\tif (bv) {\n\t\t\tbkk = bv[id];\n\t\t\tif (processed[bkk])\n\t\t\t\tcontinue;\n\t\t\tprocessed[bkk] = true;\n\t\t\tindex = ak[bkk];\n\t\t\tif (index === undefined)\n\t\t\t\texecutor(undefined, bv, -1, i);\n\t\t\telse\n\t\t\t\texecutor(a[index], bv, index, i);\n\t\t}\n\t}\n\n\tOBSOLETE('Array.compare()', 'Use U.diff() insteadof Array.compare()');\n};\n\n/**\n * Pair arrays\n * @param {Array} arr\n * @param {String} property\n * @param {Function(itemA, itemB)} fn Paired items (itemA == this, itemB == arr)\n * @param {Boolean} remove Optional, remove item from this array if the item doesn't exist int arr (default: false).\n * @return {Array}\n */\nAP.pair = function(property, arr, fn, remove) {\n\n\tif (property instanceof Array) {\n\t\tvar tmp = property;\n\t\tproperty = arr;\n\t\tarr = tmp;\n\t}\n\n\tif (!arr)\n\t\tarr = new Array(0);\n\n\tvar length = arr.length;\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar item = this[index++];\n\t\tif (!item)\n\t\t\tbreak;\n\n\t\tvar is = false;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (item[property] !== arr[i][property])\n\t\t\t\tcontinue;\n\t\t\tfn(item, arr[i]);\n\t\t\tis = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is || !remove)\n\t\t\tcontinue;\n\n\t\tindex--;\n\t\tthis.splice(index, 1);\n\t}\n\n\tOBSOLETE('Array.pair()', 'The method will be removed in Total.js v4');\n\treturn this;\n};\n\n/**\n * Last item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.last = function(def) {\n\tvar item = this[this.length - 1];\n\treturn item === undefined ? def : item;\n};\n\nAP.quicksort = AP.orderBy = function(name, asc) {\n\n\tvar length = this.length;\n\tif (!length || length === 1)\n\t\treturn this;\n\n\tif (typeof(name) === 'boolean') {\n\t\tasc = name;\n\t\tname = undefined;\n\t} else if (asc === undefined)\n\t\tasc = true;\n\telse {\n\t\tswitch (asc) {\n\t\t\tcase 'asc':\n\t\t\tcase 'ASC':\n\t\t\t\tasc = true;\n\t\t\t\tbreak;\n\t\t\tcase 'desc':\n\t\t\tcase 'DESC':\n\t\t\t\tasc = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar self = this;\n\tvar type = 0;\n\tvar field = name ? self[0][name] : self[0];\n\n\tswitch (typeof(field)) {\n\t\tcase 'string':\n\t\t\tif (field.isJSONDate())\n\t\t\t\ttype = 4;\n\t\t\telse\n\t\t\t\ttype = 1;\n\t\t\tbreak;\n\t\tcase 'number':\n\t\t\ttype = 2;\n\t\t\tbreak;\n\t\tcase 'boolean':\n\t\t\ttype = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!exports.isDate(field))\n\t\t\t\treturn self;\n\t\t\ttype = 4;\n\t\t\tbreak;\n\t}\n\n\tshellsort(self, function(a, b) {\n\n\t\tvar va = name ? a[name] : a;\n\t\tvar vb = name ? b[name] : b;\n\n\t\t// String\n\t\tif (type === 1) {\n\t\t\treturn va && vb ? (asc ? COMPARER(va, vb) : COMPARER(vb, va)) : 0;\n\t\t} else if (type === 2) {\n\t\t\treturn va > vb ? (asc ? 1 : -1) : va < vb ? (asc ? -1 : 1) : 0;\n\t\t} else if (type === 3) {\n\t\t\treturn va === true && vb === false ? (asc ? 1 : -1) : va === false && vb === true ? (asc ? -1 : 1) : 0;\n\t\t} else if (type === 4) {\n\t\t\tif (!va || !vb)\n\t\t\t\treturn 0;\n\t\t\tif (!va.getTime)\n\t\t\t\tva = new Date(va);\n\t\t\tif (!vb.getTime)\n\t\t\t\tvb = new Date(vb);\n\t\t\tvar at = va.getTime();\n\t\t\tvar bt = vb.getTime();\n\t\t\treturn at > bt ? (asc ? 1 : -1) : at < bt ? (asc ? -1 : 1) : 0;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn self;\n};\n\nAP.trim = function() {\n\tvar self = this;\n\tvar output = [];\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tif (typeof(self[i]) === 'string')\n\t\t\tself[i] = self[i].trim();\n\t\tself[i] && output.push(self[i]);\n\t}\n\treturn output;\n};\n\n/**\n * Skip items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.skip = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++)\n\t\ti >= count && arr.push(self[i]);\n\treturn arr;\n};\n\n/**\n * Find items in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.where = AP.findAll = function(cb, value) {\n\n\tvar self = this;\n\tvar selected = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tcb.call(self, self[i], i) && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] === value && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] === cb && selected.push(self[i]);\n\t}\n\n\treturn selected;\n};\n\n/**\n * Find item in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.findItem = function(cb, value) {\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nvar arrfindobsolete;\n\nAP.find = function(cb, value) {\n\n\tif (!arrfindobsolete) {\n\t\tarrfindobsolete = true;\n\t\tOBSOLETE('Array.prototype.find()', 'will be removed in v4, use alternative \"Array.prototype.findItem()\"');\n\t}\n\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nAP.findIndex = function(cb, value) {\n\n\tvar self = this;\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tif (cb.call(self, self[i], i))\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tif (self[i] && self[i][cb] === value)\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (self[i] === cb)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n};\n\n/**\n * Remove items from Array\n * @param {Function(item, index) or Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.remove = function(cb, value) {\n\n\tvar self = this;\n\tvar arr = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\t!cb.call(self, self[i], i) && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] !== value && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] !== cb && arr.push(self[i]);\n\t}\n\treturn arr;\n};\n\nAP.wait = AP.waitFor = function(onItem, callback, thread, tmp) {\n\n\tvar self = this;\n\tvar init = false;\n\n\t// INIT\n\tif (!tmp) {\n\n\t\tif (typeof(callback) !== 'function') {\n\t\t\tthread = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\ttmp = {};\n\t\ttmp.pending = 0;\n\t\ttmp.index = 0;\n\t\ttmp.thread = thread;\n\n\t\t// thread === Boolean then array has to be removed item by item\n\n\t\tinit = true;\n\t}\n\n\tvar item = thread === true ? self.shift() : self[tmp.index++];\n\tif (item === undefined) {\n\t\tif (!tmp.pending) {\n\t\t\tcallback && callback();\n\t\t\ttmp.cancel = true;\n\t\t}\n\t\treturn self;\n\t}\n\n\ttmp.pending++;\n\tonItem.call(self, item, () => setImmediate(next_wait, self, onItem, callback, thread, tmp), tmp.index);\n\n\tif (!init || tmp.thread === 1)\n\t\treturn self;\n\n\tfor (var i = 1; i < tmp.thread; i++)\n\t\tself.wait(onItem, callback, 1, tmp);\n\n\treturn self;\n};\n\nfunction next_wait(self, onItem, callback, thread, tmp) {\n\ttmp.pending--;\n\tself.wait(onItem, callback, thread, tmp);\n}\n\n/**\n * Creates a function async list\n * @param {Function} callback Optional\n * @return {Array}\n */\nAP.async = function(thread, callback, pending) {\n\n\tvar self = this;\n\n\tif (typeof(thread) === 'function') {\n\t\tcallback = thread;\n\t\tthread = 1;\n\t} else if (thread === undefined)\n\t\tthread = 1;\n\n\tif (pending === undefined)\n\t\tpending = 0;\n\n\tvar item = self.shift();\n\tif (item === undefined) {\n\t\tif (!pending) {\n\t\t\tpending = undefined;\n\t\t\tcallback && callback();\n\t\t}\n\t\treturn self;\n\t}\n\n\tfor (var i = 0; i < thread; i++) {\n\n\t\tif (i)\n\t\t\titem = self.shift();\n\n\t\tpending++;\n\t\titem(function() {\n\t\t\tsetImmediate(function() {\n\t\t\t\tpending--;\n\t\t\t\tself.async(1, callback, pending);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn self;\n};\n\nAP.randomize = function() {\n\tOBSOLETE('Array.randomize()', 'Use Array.random().');\n\treturn this.random();\n};\n\n// Fisher-Yates shuffle\nAP.random = function() {\n\tfor (var i = this.length - 1; i > 0; i--) {\n\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\tvar temp = this[i];\n\t\tthis[i] = this[j];\n\t\tthis[j] = temp;\n\t}\n\treturn this;\n};\n\nAP.limit = function(max, fn, callback, index) {\n\n\tif (index === undefined)\n\t\tindex = 0;\n\n\tvar current = [];\n\tvar self = this;\n\tvar length = index + max;\n\n\tfor (var i = index; i < length; i++) {\n\t\tvar item = self[i];\n\n\t\tif (item !== undefined) {\n\t\t\tcurrent.push(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!current.length) {\n\t\t\tcallback && callback();\n\t\t\treturn self;\n\t\t}\n\n\t\tfn(current, () => callback && callback(), index, index + max);\n\t\treturn self;\n\t}\n\n\tif (!current.length) {\n\t\tcallback && callback();\n\t\treturn self;\n\t}\n\n\tfn(current, function() {\n\t\tif (length < self.length)\n\t\t\tself.limit(max, fn, callback, length);\n\t\telse\n\t\t\tcallback && callback();\n\t}, index, index + max);\n\n\treturn self;\n};\n\n/**\n * Get unique elements from Array\n * @return {[type]} [description]\n */\nAP.unique = function(property) {\n\n\tvar self = this;\n\tvar result = [];\n\tvar sublength = 0;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tvar value = self[i];\n\n\t\tif (!property) {\n\t\t\tresult.indexOf(value) === -1 && result.push(value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sublength === 0) {\n\t\t\tresult.push(value);\n\t\t\tsublength++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar is = true;\n\t\tfor (var j = 0; j < sublength; j++) {\n\t\t\tif (result[j][property] === value[property]) {\n\t\t\t\tis = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is) {\n\t\t\tresult.push(value);\n\t\t\tsublength++;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nArrayBuffer.prototype.toBuffer = function() {\n\tvar buf = new Buffer(this.byteLength);\n\tvar view = new Uint8Array(this);\n\tfor (var i = 0, length = buf.length; i < length; ++i)\n\t\tbuf[i] = view[i];\n\treturn buf;\n};\n\nfunction AsyncTask(owner, name, fn, cb, waiting) {\n\tthis.isRunning = 0;\n\tthis.owner = owner;\n\tthis.name = name;\n\tthis.fn = fn;\n\tthis.cb = cb;\n\tthis.waiting = waiting;\n\tthis.interval = null;\n\tthis.isCanceled = false;\n}\n\nAsyncTask.prototype.run = function() {\n\tvar self = this;\n\ttry\n\t{\n\n\t\tif (self.isCanceled) {\n\t\t\tself.complete();\n\t\t\treturn self;\n\t\t}\n\n\t\tself.isRunning = 1;\n\t\tself.owner.tasksWaiting[self.name] = true;\n\t\tself.owner.emit('begin', self.name);\n\n\t\tvar timeout = self.owner.tasksTimeout[self.name];\n\t\tif (timeout > 0)\n\t\t\tself.interval = setTimeout(function() { self.timeout(); }, timeout);\n\n\t\tself.fn(function() {\n\t\t\tsetImmediate(() => self.complete());\n\t\t});\n\n\t} catch (ex) {\n\t\tself.owner.emit('error', self.name, ex);\n\t\tself.complete();\n\t}\n\treturn self;\n};\n\nAsyncTask.prototype.timeout = function(timeout) {\n\n\tvar self = this;\n\n\tif (timeout > 0) {\n\t\tclearTimeout(self.interval);\n\t\tsetTimeout(function() { self.timeout(); }, timeout);\n\t\treturn self;\n\t}\n\n\tif (timeout <= 0) {\n\t\tclearTimeout(self.interval);\n\t\tsetTimeout(function() { self.timeout(); }, timeout);\n\t\treturn self;\n\t}\n\n\tsetImmediate(() => self.cancel(true));\n\treturn self;\n};\n\nAsyncTask.prototype.cancel = function(isTimeout) {\n\tvar self = this;\n\n\tself.isCanceled = true;\n\n\tif (isTimeout)\n\t\tself.owner.emit('timeout', self.name);\n\telse\n\t\tself.owner.emit('cancel', self.name);\n\n\tself.fn = null;\n\tself.cb = null;\n\tself.complete();\n\treturn self;\n};\n\nAsyncTask.prototype.complete = function() {\n\n\tvar item = this;\n\tvar self = item.owner;\n\n\titem.isRunning = 2;\n\n\tdelete self.tasksPending[item.name];\n\tdelete self.tasksWaiting[item.name];\n\n\tif (!item.isCanceled) {\n\t\ttry\n\t\t{\n\t\t\tself.emit('end', item.name);\n\t\t\titem.cb && item.cb();\n\t\t} catch (ex) {\n\t\t\tself.emit('error', ex, item.name);\n\t\t}\n\t}\n\n\tsetImmediate(function() {\n\t\tself.reload();\n\t\tself.refresh();\n\t});\n\n\treturn self;\n};\n\nfunction Async(owner) {\n\n\tthis._max = 0;\n\tthis._count = 0;\n\tthis._isRunning = false;\n\tthis._isEnd = false;\n\n\tthis.owner = owner;\n\tthis.onComplete = [];\n\n\tthis.tasksPending = {};\n\tthis.tasksWaiting = {};\n\tthis.tasksAll = [];\n\tthis.tasksTimeout = {};\n\tthis.isCanceled = false;\n\n\tEvents.EventEmitter.call(this);\n}\n\nAsync.prototype = {\n\tget count() {\n\t\treturn this._count;\n\t},\n\n\tget percentage() {\n\t\tvar p = 100 - Math.floor((this._count * 100) / this._max);\n\t\treturn p ? p : 0;\n\t}\n};\n\nconst ACP = Async.prototype;\n\nACP.__proto__ = Object.create(Events.EventEmitter.prototype, {\n\tconstructor: {\n\t\tvalue: Async,\n\t\tenumberable: false\n\t}\n});\n\nACP.reload = function() {\n\tvar self = this;\n\tself.tasksAll = Object.keys(self.tasksPending);\n\tself.emit('percentage', self.percentage);\n\treturn self;\n};\n\nACP.cancel = function(name) {\n\n\tvar self = this;\n\n\tif (name === undefined) {\n\t\tself.isCanceled = true;\n\t\tfor (var i = 0; i < self._count; i++)\n\t\t\tself.cancel(self.tasksAll[i]);\n\t\treturn true;\n\t}\n\n\tvar task = self.tasksPending[name];\n\tif (!task)\n\t\treturn false;\n\n\tdelete self.tasksPending[name];\n\tdelete self.tasksWaiting[name];\n\n\ttask.cancel();\n\ttask = null;\n\tself.reload();\n\tself.refresh();\n\n\treturn true;\n};\n\nACP.await = function(name, fn, cb) {\n\n\tvar self = this;\n\n\tif (self.isCanceled)\n\t\treturn false;\n\n\tif (typeof(name) === 'function') {\n\t\tcb = fn;\n\t\tfn = name;\n\t\tname = exports.GUID(6);\n\t}\n\n\tif (self.tasksPending[name])\n\t\treturn false;\n\n\tself.tasksPending[name] = new AsyncTask(self, name, fn, cb, null);\n\tself._max++;\n\tself.reload();\n\tself.refresh();\n\treturn true;\n};\n\nACP.wait = function(name, waitingFor, fn, cb) {\n\n\tvar self = this;\n\n\tif (self.isCanceled)\n\t\treturn false;\n\n\tif (typeof(waitingFor) === 'function') {\n\t\tcb = fn;\n\t\tfn = waitingFor;\n\t\twaitingFor = null;\n\t}\n\n\tif (self.tasksPending[name])\n\t\treturn false;\n\n\tself.tasksPending[name] = new AsyncTask(self, name, fn, cb, waitingFor);\n\tself._max++;\n\tself.reload();\n\tself.refresh();\n\treturn true;\n};\n\nACP.complete = function(fn) {\n\treturn this.run(fn);\n};\n\nACP.run = function(fn) {\n\tthis._isRunning = true;\n\tfn && this.onComplete.push(fn);\n\tthis.refresh();\n\treturn this;\n};\n\nACP.isRunning = function(name) {\n\tif (!name)\n\t\treturn this._isRunning;\n\tvar task = this.tasksPending[name];\n\treturn task ? task.isRunning === 1 : false;\n};\n\nACP.isWaiting = function(name) {\n\tvar task = this.tasksPending[name];\n\treturn task ? task.isRunning === 0 : false;\n};\n\nACP.isPending = function(name) {\n\treturn this.tasksPending[name] ? true : false;\n};\n\nACP.timeout = function(name, timeout) {\n\tif (timeout)\n\t\tthis.tasksTimeout[name] = timeout;\n\telse\n\t\tthis.tasksTimeout[name] = undefined;\n\treturn this;\n};\n\nACP.refresh = function(name) {\n\n\tvar self = this;\n\n\tif (!self._isRunning || self._isEnd)\n\t\treturn self;\n\n\tself._count = self.tasksAll.length;\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar name = self.tasksAll[index++];\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tvar task = self.tasksPending[name];\n\t\tif (!task)\n\t\t\tbreak;\n\n\t\tif (self.isCanceled || task.isCanceled) {\n\t\t\tdelete self.tasksPending[name];\n\t\t\tdelete self.tasksWaiting[name];\n\t\t\tself.tasksAll.splice(index, 1);\n\t\t\tself._count = self.tasksAll.length;\n\t\t\tindex--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (task.isRunning !== 0 || (task.waiting && self.tasksPending[task.waiting]))\n\t\t\tcontinue;\n\n\t\ttask.run();\n\t}\n\n\tif (self._count === 0) {\n\t\tself._isRunning = false;\n\t\tself._isEnd = true;\n\t\tself.emit('complete');\n\t\tself.emit('percentage', 100);\n\t\tself._max = 0;\n\t\tvar complete = self.onComplete;\n\t\tvar length = complete.length;\n\t\tself.onComplete = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcomplete[i]();\n\t\t\t} catch (ex) {\n\t\t\t\tself.emit('error', ex);\n\t\t\t}\n\t\t}\n\t\tsetImmediate(() => self._isEnd = false);\n\t}\n\n\treturn self;\n};\n\nfunction FileList() {\n\tthis.pending = [];\n\tthis.pendingDirectory = [];\n\tthis.directory = [];\n\tthis.file = [];\n\tthis.onComplete = null;\n\tthis.onFilter = null;\n\tthis.advanced = false;\n}\n\nconst FLP = FileList.prototype;\n\nFLP.reset = function() {\n\tthis.file.length = 0;\n\tthis.directory.length = 0;\n\tthis.pendingDirectory.length = 0;\n\treturn this;\n};\n\nFLP.walk = function(directory) {\n\n\tvar self = this;\n\n\tif (directory instanceof Array) {\n\t\tvar length = directory.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pendingDirectory.push(directory[i]);\n\t\tself.next();\n\t\treturn;\n\t}\n\n\tFs.readdir(directory, function(err, arr) {\n\t\tif (err)\n\t\t\treturn self.next();\n\t\tvar length = arr.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pending.push(Path.join(directory, arr[i]));\n\t\tself.next();\n\t});\n};\n\nFLP.stat = function(path) {\n\tvar self = this;\n\n\tFs.stat(path, function(err, stats) {\n\n\t\tif (err)\n\t\t\treturn self.next();\n\n\t\tif (stats.isDirectory()) {\n\t\t\tpath = self.clean(path);\n\t\t\tif (!self.onFilter || self.onFilter(path, true)) {\n\t\t\t\tself.directory.push(path);\n\t\t\t\tself.pendingDirectory.push(path);\n\t\t\t}\n\t\t} else if (!self.onFilter || self.onFilter(path, false))\n\t\t\tself.file.push(self.advanced ? { filename: path, stats: stats } : path);\n\n\t\tself.next();\n\t});\n};\n\nFLP.clean = function(path) {\n\treturn path[path.length - 1] === Path.sep ? path : path + Path.sep;\n};\n\nFLP.next = function() {\n\tvar self = this;\n\n\tif (self.pending.length) {\n\t\tvar item = self.pending.shift();\n\t\tself.stat(item);\n\t\treturn;\n\t}\n\n\tif (self.pendingDirectory.length) {\n\t\tvar directory = self.pendingDirectory.shift();\n\t\tself.walk(directory);\n\t\treturn;\n\t}\n\n\tself.onComplete(self.file, self.directory);\n};\n\nexports.Async = Async;\n\nexports.sync = function(fn, owner) {\n\treturn function() {\n\n\t\tvar args = [].slice.call(arguments);\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t};\n};\n\nexports.sync2 = function(fn, owner) {\n\treturn (function() {\n\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\t\tvar args = [].slice.call(arguments);\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t})();\n};\n\nexports.async = function(fn, isApply) {\n\tvar context = this;\n\treturn function(complete) {\n\n\t\tvar self = this;\n\t\tvar argv;\n\n\t\tif (arguments.length) {\n\n\t\t\tif (isApply) {\n\t\t\t\t// index.js/Subscribe.prototype.doExecute\n\t\t\t\targv = arguments[1];\n\t\t\t} else {\n\t\t\t\targv = [];\n\t\t\t\tfor (var i = 1; i < arguments.length; i++)\n\t\t\t\t\targv.push(arguments[i]);\n\t\t\t}\n\t\t} else\n\t\t\targv = new Array(0);\n\n\t\tvar generator = fn.apply(context, argv);\n\t\tnext(null);\n\n\t\tfunction next(err, result) {\n\n\t\t\tvar g, type;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar can = err ? false : true;\n\t\t\t\tswitch (can) {\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tg = generator.next(result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tg = generator.throw(err);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\n\t\t\t\tif (!complete)\n\t\t\t\t\treturn;\n\n\t\t\t\ttype = typeof(complete);\n\n\t\t\t\tif (type === 'object' && complete.isController) {\n\t\t\t\t\tif (e instanceof ErrorBuilder)\n\t\t\t\t\t\tcomplete.content(e);\n\t\t\t\t\telse\n\t\t\t\t\t\tcomplete.view500(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttype === 'function' && setImmediate(() => complete(e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (g.done) {\n\t\t\t\ttypeof(complete) === 'function' && complete(null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar promise = g.value instanceof Promise;\n\n\t\t\tif (typeof(g.value) !== 'function' && !promise) {\n\t\t\t\tnext.call(self, null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (promise) {\n\t\t\t\t\tg.value.then((value) => next.call(self, null, value));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tg.value.call(self, function() {\n\t\t\t\t\tnext.apply(self, arguments);\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tsetImmediate(() => next.call(self, e));\n\t\t\t}\n\t\t}\n\n\t\treturn generator.value;\n\t};\n};\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nconst CACHE_GML1 = [null, null, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nconst CACHE_GML2 = [null, null, null, null, null, null, null, null];\nexports.getMessageLength = function(data, isLE) {\n\n\tvar length = data[1] & 0x7f;\n\n\tif (length === 126) {\n\t\tif (data.length < 4)\n\t\t\treturn -1;\n\t\tCACHE_GML1[0] = data[3];\n\t\tCACHE_GML1[1] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML1, 0, isLE);\n\t}\n\n\tif (length === 127) {\n\t\tif (data.Length < 10)\n\t\t\treturn -1;\n\t\tCACHE_GML2[0] = data[9];\n\t\tCACHE_GML2[1] = data[8];\n\t\tCACHE_GML2[2] = data[7];\n\t\tCACHE_GML2[3] = data[6];\n\t\tCACHE_GML2[4] = data[5];\n\t\tCACHE_GML2[5] = data[4];\n\t\tCACHE_GML2[6] = data[3];\n\t\tCACHE_GML2[7] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML2, 0, isLE);\n\t}\n\n\treturn length;\n};\n\n// MIT\n// Written by Jozef Gula\nfunction converBytesToInt64(data, startIndex, isLE) {\n\treturn isLE ? (data[startIndex] | (data[startIndex + 1] << 0x08) | (data[startIndex + 2] << 0x10) | (data[startIndex + 3] << 0x18) | (data[startIndex + 4] << 0x20) | (data[startIndex + 5] << 0x28) | (data[startIndex + 6] << 0x30) | (data[startIndex + 7] << 0x38)) : ((data[startIndex + 7] << 0x20) | (data[startIndex + 6] << 0x28) | (data[startIndex + 5] << 0x30) | (data[startIndex + 4] << 0x38) | (data[startIndex + 3]) | (data[startIndex + 2] << 0x08) | (data[startIndex + 1] << 0x10) | (data[startIndex] << 0x18));\n}\n\nexports.queuecache = {};\n\nfunction queue_next(name) {\n\n\tvar item = exports.queuecache[name];\n\tif (!item)\n\t\treturn;\n\n\titem.running--;\n\n\tif (item.running < 0)\n\t\titem.running = 0;\n\n\tif (item.pending.length) {\n\t\tvar fn = item.pending.shift();\n\t\tif (fn) {\n\t\t\titem.running++;\n\t\t\tsetImmediate(queue_next_callback, fn, name);\n\t\t} else\n\t\t\titem.running = 0;\n\t}\n}\n\nfunction queue_next_callback(fn, name) {\n\tfn(() => queue_next(name));\n}\n\n/**\n * Queue list\n * @param {String} name\n * @param {Number} max Maximum stack.\n * @param {Function(next)} fn\n */\nexports.queue = function(name, max, fn) {\n\n\tif (!fn)\n\t\treturn false;\n\n\tif (!max) {\n\t\tfn(NOOP);\n\t\treturn true;\n\t}\n\n\tif (!exports.queuecache[name])\n\t\texports.queuecache[name] = { limit: max, running: 0, pending: [] };\n\n\tvar item = exports.queuecache[name];\n\tif (item.running >= item.limit) {\n\t\titem.pending.push(fn);\n\t\treturn false;\n\t}\n\n\titem.running++;\n\tsetImmediate(queue_next_callback, fn, name);\n\treturn true;\n};\n\nexports.minifyStyle = function(val) {\n\treturn Internal.compile_css(val);\n};\n\nexports.minifyScript = function(val) {\n\treturn Internal.compile_javascript(val);\n};\n\nexports.minifyHTML = function(val) {\n\treturn Internal.compile_html(val);\n};\n\nexports.parseTheme = function(value) {\n\tif (value[0] !== '=')\n\t\treturn '';\n\tvar index = value.indexOf('/', 2);\n\tif (index === -1)\n\t\treturn '';\n\tvalue = value.substring(1, index);\n\treturn value === '?' ? CONF.default_theme : value;\n};\n\nexports.set = function(obj, path, value) {\n\tvar cachekey = 'S+' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj, value);\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0; i < arr.length - 1; i++) {\n\t\tvar type = arr[i + 1] ? (REGISARR.test(arr[i + 1]) ? '[]' : '{}') : '{}';\n\t\tvar p = 'w' + (arr[i][0] === '[' ? '' : '.') + arr[i];\n\t\tbuilder.push('if(typeof(' + p + ')!==\\'object\\'||' + p + '==null)' + p + '=' + type + ';');\n\t}\n\n\tvar v = arr[arr.length - 1];\n\tvar ispush = v.lastIndexOf('[]') !== -1;\n\tvar a = builder.join(';') + ';var v=typeof(a)===\\'function\\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';\n\n\tif ((/__proto__|constructor|prototype/).test(a))\n\t\tthrow new Error('Prototype pollution');\n\n\tvar fn = new Function('w', 'a', 'b', a);\n\tF.temporary.other[cachekey] = fn;\n\tfn(obj, value, path);\n};\n\nexports.get = function(obj, path) {\n\n\tvar cachekey = 'G=' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj);\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0, length = arr.length - 1; i < length; i++)\n\t\tbuilder.push('if(!w' + (!arr[i] || arr[i][0] === '[' ? '' : '.') + arr[i] + ')return');\n\n\tvar v = arr[arr.length - 1];\n\tvar fn = (new Function('w', builder.join(';') + ';return w' + (v[0] === '[' ? '' : '.') + v));\n\tF.temporary.other[cachekey] = fn;\n\treturn fn(obj);\n};\n\nfunction parsepath(path) {\n\n\tvar arr = path.split('.');\n\tvar builder = [];\n\tvar all = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar p = arr[i];\n\t\tvar index = p.indexOf('[');\n\t\tif (index === -1) {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tvar a = all.splice(all.length - 1);\n\t\t\t\tall.push(a + '[\\'' + p + '\\']');\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t}\n\t\t} else {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p.substring(0, index));\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t\tall.splice(all.length - 1);\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tall.push('[\\'' + p.substring(0, index) + '\\']');\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t\tall.push(p.substring(index));\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn builder;\n}\n\nglobal.Async = global.async = exports.async;\nglobal.sync = global.SYNCHRONIZE = exports.sync;\nglobal.sync2 = exports.sync2;\n\n// =============================================\n// SHELL SORT IMPLEMENTATION OF ALGORITHM\n// =============================================\n\nfunction _shellInsertionSort(list, length, gapSize, fn) {\n\tvar temp, i, j;\n\tfor (i = gapSize; i < length; i += gapSize ) {\n\t\tj = i;\n\t\twhile(j > 0 && fn(list[j - gapSize], list[j]) === 1) {\n\t\t\ttemp = list[j];\n\t\t\tlist[j] = list[j - gapSize];\n\t\t\tlist[j - gapSize] = temp;\n\t\t\tj -= gapSize;\n\t\t}\n\t}\n}\n\nfunction shellsort(arr, fn) {\n\tvar length = arr.length;\n\tvar gapSize = Math.floor(length / 2);\n\twhile(gapSize) {\n\t\t_shellInsertionSort(arr, length, gapSize, fn);\n\t\tgapSize = Math.floor(gapSize / 2);\n\t}\n\treturn arr;\n}\n\nfunction EventEmitter2(obj) {\n\tif (obj) {\n\t\t!obj.emit && EventEmitter2.extend(obj);\n\t\treturn obj;\n\t} else\n\t\tthis.$events = {};\n}\n\nconst EE2P = EventEmitter2.prototype;\n\nEE2P.emit = function(name, a, b, c, d, e, f, g) {\n\n\tif (!this.$events)\n\t\treturn this;\n\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.on = function(name, fn) {\n\tif (!this.$events)\n\t\tthis.$events = {};\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nEE2P.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nEE2P.removeListener = function(name, fn) {\n\tif (this.$events) {\n\t\tvar evt = this.$events[name];\n\t\tif (evt) {\n\t\t\tevt = evt.remove(n => n === fn);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.removeAllListeners = function(name) {\n\tif (this.$events) {\n\t\tif (name === true)\n\t\t\tthis.$events = EMPTYOBJECT;\n\t\telse if (name)\n\t\t\tthis.$events[name] = undefined;\n\t\telse\n\t\t\tthis.$events = {};\n\t}\n\treturn this;\n};\n\nEventEmitter2.extend = function(obj) {\n\tobj.emit = EE2P.emit;\n\tobj.on = EE2P.on;\n\tobj.once = EE2P.once;\n\tobj.removeListener = EE2P.removeListener;\n\tobj.removeAllListeners = EE2P.removeAllListeners;\n};\n\nexports.EventEmitter2 = EventEmitter2;\n\nfunction Chunker(name, max) {\n\tthis.name = name;\n\tthis.max = max || 50;\n\tthis.index = 0;\n\tthis.filename = '{0}-'.format(name);\n\tthis.stack = [];\n\tthis.flushing = 0;\n\tthis.pages = 0;\n\tthis.count = 0;\n\tthis.percentage = 0;\n\tthis.autoremove = true;\n\tthis.compress = true;\n\tthis.filename = F.path.temp(this.filename);\n}\n\nconst CHP = Chunker.prototype;\n\nCHP.append = CHP.write = function(obj) {\n\tvar self = this;\n\n\tself.stack.push(obj);\n\n\tvar tmp = self.stack.length;\n\n\tif (tmp >= self.max) {\n\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.end = function() {\n\tvar self = this;\n\tvar tmp = self.stack.length;\n\tif (tmp) {\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.each = function(onItem, onEnd, indexer) {\n\n\tvar self = this;\n\n\tif (indexer == null) {\n\t\tself.percentage = 0;\n\t\tindexer = 0;\n\t}\n\n\tif (indexer >= self.index)\n\t\treturn onEnd && onEnd();\n\n\tself.read(indexer++, function(err, items) {\n\t\tself.percentage = Math.ceil((indexer / self.pages) * 100);\n\t\tonItem(items, () => self.each(onItem, onEnd, indexer), indexer - 1);\n\t});\n\n\treturn self;\n};\n\nCHP.read = function(index, callback) {\n\tvar self = this;\n\n\tif (self.flushing) {\n\t\tself.flushing_timeout = setTimeout(() => self.read(index, callback), 300);\n\t\treturn;\n\t}\n\n\tvar filename = self.filename + index + '.chunker';\n\n\tFs.readFile(filename, function(err, data) {\n\n\t\tif (err) {\n\t\t\tcallback(null, EMPTYARRAY);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.compress) {\n\t\t\tZlib.inflate(data, function(err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(null, EMPTYARRAY);\n\t\t\t\t} else {\n\t\t\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t}\n\t});\n\n\treturn self;\n};\n\nCHP.clear = function() {\n\tvar files = [];\n\tfor (var i = 0; i < this.index; i++)\n\t\tfiles.push(this.filename + i + '.chunker');\n\tfiles.wait((filename, next) => Fs.unlink(filename, next));\n\treturn this;\n};\n\nCHP.destroy = function() {\n\tthis.clear();\n\tthis.indexer = 0;\n\tthis.flushing = 0;\n\tclearTimeout(this.flushing_timeout);\n\tthis.stack = null;\n\treturn this;\n};\n\nexports.chunker = function(name, max) {\n\treturn new Chunker(name, max);\n};\n\nexports.Chunker = Chunker;\n\nexports.ObjectToArray = function(obj) {\n\tif (obj == null)\n\t\treturn EMPTYARRAY;\n\tvar keys = Object.keys(obj);\n\tvar output = [];\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toutput.push({ key: keys[i], value: obj[keys[i]]});\n\treturn output;\n};\n\nif (NODEVERSION > 699) {\n\texports.createBufferSize = (size) => Buffer.alloc(size || 0);\n\texports.createBuffer = (val, type) => Buffer.from(val || '', type);\n} else {\n\texports.createBufferSize = (size) => new Buffer(size || 0);\n\texports.createBuffer = (val, type) => new Buffer(val || '', type);\n}\n\nfunction Callback(count, callback) {\n\tthis.pending = count;\n\tthis.$callback = callback;\n}\nconst CP = Callback.prototype;\n\nCP.done = function(callback) {\n\tthis.$callback = callback;\n\treturn this;\n};\n\nCP.next = function() {\n\tvar self = this;\n\tself.pending--;\n\tif (!self.pending && self.$callback) {\n\t\tself.$callback();\n\t\tself.$callback = null;\n\t}\n\treturn self;\n};\n\nglobal.Callback = Callback;\n\nexports.Callback = function(count, callback) {\n\treturn new Callback(count, callback);\n};\n\nfunction Reader() {\n\tvar t = this;\n\tt.$add = function(builder) {\n\t\tif (t.reader)\n\t\t\tt.reader.add(builder);\n\t\telse\n\t\t\tt.reader = new framework_nosql.NoSQLReader(builder);\n\t};\n}\nconst RP = Reader.prototype;\n\nRP.done = function() {\n\tvar self = this;\n\tself.reader.done();\n\treturn self;\n};\n\nRP.reset = function() {\n\tvar self = this;\n\tself.reader.reset();\n\treturn self;\n};\n\nRP.push = function(data) {\n\tif (data == null)\n\t\tthis.reader.done();\n\telse\n\t\tthis.reader.compare(data instanceof Array ? data : [data]);\n\treturn this;\n};\n\nRP.find = function() {\n\tvar self = this;\n\tvar builder = new framework_nosql.DatabaseBuilder();\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.count = function() {\n\tvar builder = this.find();\n\tbuilder.$options.readertype = 1;\n\treturn builder;\n};\n\nRP.scalar = function(type, field) {\n\treturn this.find().scalar(type, field);\n};\n\nexports.reader = function() {\n\treturn new Reader();\n};\n\nconst BUFEMPTYJSON = Buffer.from('{}');\n\nglobal.WAIT = exports.wait;\n!global.F && require('./index');\n"], "filenames": ["utils.js"], "buggy_code_start_loc": [6623], "buggy_code_end_loc": [6623], "fixing_code_start_loc": [6624], "fixing_code_end_loc": [6628], "type": "NVD-CWE-Other", "message": "This affects the package total.js before 3.4.7. The set function can be used to set a value into the object according to the path. However the keys of the path being set are not properly sanitized, leading to a prototype pollution vulnerability. The impact depends on the application. In some cases it is possible to achieve Denial of service (DoS), Remote Code Execution or Property Injection.", "other": {"cve": {"id": "CVE-2020-28495", "sourceIdentifier": "report@snyk.io", "published": "2021-02-02T11:15:13.257", "lastModified": "2021-02-05T16:53:47.807", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package total.js before 3.4.7. The set function can be used to set a value into the object according to the path. However the keys of the path being set are not properly sanitized, leading to a prototype pollution vulnerability. The impact depends on the application. In some cases it is possible to achieve Denial of service (DoS), Remote Code Execution or Property Injection."}, {"lang": "es", "value": "Esto afecta al paquete total.js versiones anteriores a 3.4.7.&#xa0;La funci\u00f3n set puede ser usada para ajustar un valor en el objeto de acuerdo con la ruta.&#xa0;Sin embargo, las claves de ruta que se est\u00e1 ajustando no est\u00e1n propiamente saneadas, conllevando a una vulnerabilidad de contaminaci\u00f3n de prototipo.&#xa0;El impacto depende de la aplicaci\u00f3n.&#xa0;En algunos casos, es posible lograr una Denegaci\u00f3n de Servicio (DoS), una Ejecuci\u00f3n de C\u00f3digo Remota o una Inyecci\u00f3n de Propiedad"}], "metrics": {"cvssMetricV31": [{"source": "report@snyk.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:totaljs:total.js:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.4.7", "matchCriteriaId": "09C704BC-AD46-464A-B3CD-D2D54FF353BA"}]}]}], "references": [{"url": "https://docs.totaljs.com/latest/en.html%23api~FrameworkUtils~U.set", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/totaljs/framework/blob/master/utils.js%23L6606", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/totaljs/framework/blob/master/utils.js%23L6617", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/totaljs/framework/commit/b3f901561d66ab799a4a99279893b94cad7ae4ff", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-TOTALJS-1046671", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/totaljs/framework/commit/b3f901561d66ab799a4a99279893b94cad7ae4ff"}}