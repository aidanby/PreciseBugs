{"buggy_code": ["'use strict';\n\n/**\n * Module dependencies.\n */\nconst assign = require('lodash.assign');\nconst exec = require('child_process').exec;\nconst child_process = require('child_process');\nconst fs = require('fs');\nconst tmpdir = require('os').tmpdir(); // let the os take care of removing zombie tmp files\nconst uuid = require('node-uuid');\nconst path = require('path');\nconst glob = require(\"glob\");\n\nconst Tesseract = {\n\n  tmpFiles: [],\n\n  timeout: 10000,\n\n  /**\n   * options default options passed to Tesseract binary\n   * @type {Object}\n   */\n  options: {\n    'l': 'eng',\n    'psm': 3,\n    'config': null,\n    'binary': 'tesseract'\n  },\n\n  /**\n   * outputEncoding\n   * @type {String}\n   */\n  outputEncoding: 'UTF-8',\n\n  command: function (image, options) {\n    // assemble tesseract command\n    const command = [options.binary, image, options.output];\n\n    if (options.l !== null) {\n      command.push('-l ' + options.l);\n    }\n\n    if (options.psm !== null) {\n      command.push('--psm ' + options.psm);\n    }\n\n    if (options.config !== null) {\n      command.push(options.config);\n    }\n\n    const names = Object.keys(options);\n    names.forEach(function (name) {\n      if (name.indexOf('-') === 0) {\n        command.push(name + ' ' + options[name]);\n      }\n    });\n\n    return command.join(' ');\n  },\n\n  /**\n   * Runs Tesseract binary with options\n   *\n   * @param {String} image\n   * @param {Object|Function} [options] to pass to Tesseract binary\n   * @param {String} [options.binary]\n   * @param {String} [options.l] Specify language(s) used for OCR.\n   * @param {String} [options.psm] Specify page segmentation mode\n   * @param {String} [options.config] Config for OCR\n   * @param {String} [options.output] Output base dir for process\n   * @param {Function} callback\n   */\n  process: function(image, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = null;\n    }\n\n    options = assign({}, Tesseract.options, options);\n\n    // generate output file name\n    const output = options.output = path.resolve(options.output || tmpdir, 'ntesseract-' + uuid.v4());\n\n    // add the tmp file to the list\n    Tesseract.tmpFiles.push(output);\n\n    const command = Tesseract.command(image, options);\n\n    const opts = options.env || {};\n\n    let timer = setTimeout(function(){}, 100000);\n\n    // Run the tesseract command\n    const child = child_process.exec(command, opts, function(err) {\n      if (err) {\n        // Something went wrong executing the assembled command\n        callback(err, null);\n        clearTimeout(timer);\n        return;\n      }\n\n      // Find one of the three possible extension\n      glob(output + '.+(html|hocr|txt)', function(err, files){\n        if (err) {\n          callback(err, null);\n          clearTimeout(timer);\n          return;\n        }\n        fs.readFile(files[0], Tesseract.outputEncoding, function(err, data) {\n          if (err) {\n            callback(err, null);\n            clearTimeout(timer);\n            return;\n          }\n\n          const index = Tesseract.tmpFiles.indexOf(output);\n          if (~index) Tesseract.tmpFiles.splice(index, 1);\n\n          fs.unlink(files[0], function () {\n            // no-op\n          });\n\n          callback(null, data)\n          clearTimeout(timer);\n        });\n      })\n    }); // end exec\n\n    timer = setTimeout(function() {\n      exec('kill ' + child.pid, function(err, stdout, stderr) {\n        callback(\"This process was terminated for timing out\", null);\n      });\n    }, Tesseract.timeout);\n\n  }\n\n};\n\nfunction gc() {\n  for (let i = Tesseract.tmpFiles.length - 1; i >= 0; i--) {\n    try {\n      fs.unlinkSync(Tesseract.tmpFiles[i] + '.txt');\n    } catch (err) {}\n\n    const index = Tesseract.tmpFiles.indexOf(Tesseract.tmpFiles[i]);\n    if (~index) Tesseract.tmpFiles.splice(index, 1);\n  }\n}\n\nconst version = process.versions.node.split('.').map(function(value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    gc();\n    throw err;\n  });\n}\n\n// clean up the tmp files\nprocess.addListener('exit', function _exit(code) {\n  gc();\n});\n\n/**\n * Module exports.\n */\nmodule.exports = {\n  // expose for testing\n  command: Tesseract.command,\n  process: Tesseract.process\n};\n", "{\n  \"name\": \"ntesseract\",\n  \"version\": \"0.2.8\",\n  \"authors\": [\n    \"Tao Yuan <towyuan@outlook.com>\",\n    \"Desmond Morris <hi@desmondmorris.com>\"\n  ],\n  \"description\": \"A simple wrapper for the Tesseract OCR package\",\n  \"main\": \"index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/taoyuan/ntesseract/\"\n  },\n  \"keywords\": [\n    \"tesseract\",\n    \"ocr\",\n    \"text recognition\"\n  ],\n  \"dependencies\": {\n    \"glob\": \"^7.1.6\",\n    \"lodash.assign\": \"^4.2.0\",\n    \"node-uuid\": \"^1.4.7\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"^4.2.0\",\n    \"mocha\": \"~8.2.1\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\"\n  },\n  \"license\": \"MIT\",\n  \"engine\": {\n    \"node\": \">=0.6\"\n  }\n}\n"], "fixing_code": ["'use strict';\n\n/**\n * Module dependencies.\n */\nconst assign = require('lodash.assign');\nconst exec = require('child_process').exec;\nconst child_process = require('child_process');\nconst fs = require('fs');\nconst tmpdir = require('os').tmpdir(); // let the os take care of removing zombie tmp files\nconst uuid = require('node-uuid');\nconst path = require('path');\nconst glob = require(\"glob\");\n\nconst Tesseract = {\n\n  tmpFiles: [],\n\n  timeout: 10000,\n\n  /**\n   * options default options passed to Tesseract binary\n   * @type {Object}\n   */\n  options: {\n    'l': 'eng',\n    'psm': 3,\n    'config': null,\n    'binary': 'tesseract'\n  },\n\n  /**\n   * outputEncoding\n   * @type {String}\n   */\n  outputEncoding: 'UTF-8',\n\n  command: function (image, options) {\n    if (image.startsWith('\"')) {\n      image = '\"' + image + '\"';\n    }\n\n    // assemble tesseract command\n    const command = [options.binary, image, options.output];\n\n    if (options.l !== null) {\n      command.push('-l ' + options.l);\n    }\n\n    if (options.psm !== null) {\n      command.push('--psm ' + options.psm);\n    }\n\n    if (options.config !== null) {\n      command.push(options.config);\n    }\n\n    const names = Object.keys(options);\n    names.forEach(function (name) {\n      if (name.indexOf('-') === 0) {\n        command.push(name + ' ' + options[name]);\n      }\n    });\n\n    return command.join(' ');\n  },\n\n  /**\n   * Runs Tesseract binary with options\n   *\n   * @param {String} image\n   * @param {Object|Function} [options] to pass to Tesseract binary\n   * @param {String} [options.binary]\n   * @param {String} [options.l] Specify language(s) used for OCR.\n   * @param {String} [options.psm] Specify page segmentation mode\n   * @param {String} [options.config] Config for OCR\n   * @param {String} [options.output] Output base dir for process\n   * @param {Function} callback\n   */\n  process: function(image, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = null;\n    }\n\n    options = assign({}, Tesseract.options, options);\n\n    // generate output file name\n    const output = options.output = path.resolve(options.output || tmpdir, 'ntesseract-' + uuid.v4());\n\n    // add the tmp file to the list\n    Tesseract.tmpFiles.push(output);\n\n    const command = Tesseract.command(image, options);\n\n    const opts = options.env || {};\n\n    let timer = setTimeout(function(){}, 100000);\n\n    // Run the tesseract command\n    const child = child_process.exec(command, opts, function(err) {\n      if (err) {\n        // Something went wrong executing the assembled command\n        callback(err, null);\n        clearTimeout(timer);\n        return;\n      }\n\n      // Find one of the three possible extension\n      glob(output + '.+(html|hocr|txt)', function(err, files){\n        if (err) {\n          callback(err, null);\n          clearTimeout(timer);\n          return;\n        }\n        fs.readFile(files[0], Tesseract.outputEncoding, function(err, data) {\n          if (err) {\n            callback(err, null);\n            clearTimeout(timer);\n            return;\n          }\n\n          const index = Tesseract.tmpFiles.indexOf(output);\n          if (~index) Tesseract.tmpFiles.splice(index, 1);\n\n          fs.unlink(files[0], function () {\n            // no-op\n          });\n\n          callback(null, data)\n          clearTimeout(timer);\n        });\n      })\n    }); // end exec\n\n    timer = setTimeout(function() {\n      exec('kill ' + child.pid, function(err, stdout, stderr) {\n        callback(\"This process was terminated for timing out\", null);\n      });\n    }, Tesseract.timeout);\n\n  }\n\n};\n\nfunction gc() {\n  for (let i = Tesseract.tmpFiles.length - 1; i >= 0; i--) {\n    try {\n      fs.unlinkSync(Tesseract.tmpFiles[i] + '.txt');\n    } catch (err) {}\n\n    const index = Tesseract.tmpFiles.indexOf(Tesseract.tmpFiles[i]);\n    if (~index) Tesseract.tmpFiles.splice(index, 1);\n  }\n}\n\nconst version = process.versions.node.split('.').map(function(value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    gc();\n    throw err;\n  });\n}\n\n// clean up the tmp files\nprocess.addListener('exit', function _exit(code) {\n  gc();\n});\n\n/**\n * Module exports.\n */\nmodule.exports = {\n  // expose for testing\n  command: Tesseract.command,\n  process: Tesseract.process\n};\n", "{\n  \"name\": \"ntesseract\",\n  \"version\": \"0.2.8\",\n  \"authors\": [\n    \"Tao Yuan <towyuan@outlook.com>\",\n    \"Desmond Morris <hi@desmondmorris.com>\"\n  ],\n  \"description\": \"A simple wrapper for the Tesseract OCR package\",\n  \"main\": \"index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/taoyuan/ntesseract/\"\n  },\n  \"keywords\": [\n    \"tesseract\",\n    \"ocr\",\n    \"text recognition\"\n  ],\n  \"dependencies\": {\n    \"glob\": \"^7.1.6\",\n    \"lodash.assign\": \"^4.2.0\",\n    \"node-uuid\": \"^1.4.7\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"^4.2.0\",\n    \"mocha\": \"~8.2.1\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\"\n  },\n  \"license\": \"MIT\",\n  \"engine\": {\n    \"node\": \">=8.0\"\n  }\n}\n"], "filenames": ["lib/tesseract.js", "package.json"], "buggy_code_start_loc": [38, 33], "buggy_code_end_loc": [38, 34], "fixing_code_start_loc": [39, 33], "fixing_code_end_loc": [43, 34], "type": "CWE-77", "message": "The package ntesseract before 0.2.9 are vulnerable to Command Injection via lib/tesseract.js.", "other": {"cve": {"id": "CVE-2020-28446", "sourceIdentifier": "report@snyk.io", "published": "2022-07-25T14:15:09.613", "lastModified": "2022-07-28T19:16:49.943", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package ntesseract before 0.2.9 are vulnerable to Command Injection via lib/tesseract.js."}, {"lang": "es", "value": "El paquete ntesseract versiones anteriores a 0.2.9, es vulnerable a una inyecci\u00f3n de comandos por medio del archivo lib/tesseract.js"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntesseract_project:ntesseract:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.2.9", "matchCriteriaId": "7E0438D8-71BB-4D1B-ADD4-9770A04A435F"}]}]}], "references": [{"url": "https://github.com/taoyuan/ntesseract/commit/fcbc36f381798b4362179c0cdf9961b437c7b619", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-NTESSERACT-1050982", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/taoyuan/ntesseract/commit/fcbc36f381798b4362179c0cdf9961b437c7b619"}}