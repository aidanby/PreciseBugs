{"buggy_code": ["#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/scatterlist.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n\n#define SIMPLE_IO_TIMEOUT\t10000\t/* in milliseconds */\n\n/*-------------------------------------------------------------------------*/\n\nstatic int override_alt = -1;\nmodule_param_named(alt, override_alt, int, 0644);\nMODULE_PARM_DESC(alt, \">= 0 to override altsetting selection\");\nstatic void complicated_callback(struct urb *urb);\n\n/*-------------------------------------------------------------------------*/\n\n/* FIXME make these public somewhere; usbdevfs.h? */\n\n/* Parameter for usbtest driver. */\nstruct usbtest_param_32 {\n\t/* inputs */\n\t__u32\t\ttest_num;\t/* 0..(TEST_CASES-1) */\n\t__u32\t\titerations;\n\t__u32\t\tlength;\n\t__u32\t\tvary;\n\t__u32\t\tsglen;\n\n\t/* outputs */\n\t__s32\t\tduration_sec;\n\t__s32\t\tduration_usec;\n};\n\n/*\n * Compat parameter to the usbtest driver.\n * This supports older user space binaries compiled with 64 bit compiler.\n */\nstruct usbtest_param_64 {\n\t/* inputs */\n\t__u32\t\ttest_num;\t/* 0..(TEST_CASES-1) */\n\t__u32\t\titerations;\n\t__u32\t\tlength;\n\t__u32\t\tvary;\n\t__u32\t\tsglen;\n\n\t/* outputs */\n\t__s64\t\tduration_sec;\n\t__s64\t\tduration_usec;\n};\n\n/* IOCTL interface to the driver. */\n#define USBTEST_REQUEST_32    _IOWR('U', 100, struct usbtest_param_32)\n/* COMPAT IOCTL interface to the driver. */\n#define USBTEST_REQUEST_64    _IOWR('U', 100, struct usbtest_param_64)\n\n/*-------------------------------------------------------------------------*/\n\n#define\tGENERIC\t\t/* let probe() bind using module params */\n\n/* Some devices that can be used for testing will have \"real\" drivers.\n * Entries for those need to be enabled here by hand, after disabling\n * that \"real\" driver.\n */\n//#define\tIBOT2\t\t/* grab iBOT2 webcams */\n//#define\tKEYSPAN_19Qi\t/* grab un-renumerated serial adapter */\n\n/*-------------------------------------------------------------------------*/\n\nstruct usbtest_info {\n\tconst char\t\t*name;\n\tu8\t\t\tep_in;\t\t/* bulk/intr source */\n\tu8\t\t\tep_out;\t\t/* bulk/intr sink */\n\tunsigned\t\tautoconf:1;\n\tunsigned\t\tctrl_out:1;\n\tunsigned\t\tiso:1;\t\t/* try iso in/out */\n\tunsigned\t\tintr:1;\t\t/* try interrupt in/out */\n\tint\t\t\talt;\n};\n\n/* this is accessed only through usbfs ioctl calls.\n * one ioctl to issue a test ... one lock per device.\n * tests create other threads if they need them.\n * urbs and buffers are allocated dynamically,\n * and data generated deterministically.\n */\nstruct usbtest_dev {\n\tstruct usb_interface\t*intf;\n\tstruct usbtest_info\t*info;\n\tint\t\t\tin_pipe;\n\tint\t\t\tout_pipe;\n\tint\t\t\tin_iso_pipe;\n\tint\t\t\tout_iso_pipe;\n\tint\t\t\tin_int_pipe;\n\tint\t\t\tout_int_pipe;\n\tstruct usb_endpoint_descriptor\t*iso_in, *iso_out;\n\tstruct usb_endpoint_descriptor\t*int_in, *int_out;\n\tstruct mutex\t\tlock;\n\n#define TBUF_SIZE\t256\n\tu8\t\t\t*buf;\n};\n\nstatic struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)\n{\n\treturn interface_to_usbdev(test->intf);\n}\n\n/* set up all urbs so they can be used with either bulk or interrupt */\n#define\tINTERRUPT_RATE\t\t1\t/* msec/transfer */\n\n#define ERROR(tdev, fmt, args...) \\\n\tdev_err(&(tdev)->intf->dev , fmt , ## args)\n#define WARNING(tdev, fmt, args...) \\\n\tdev_warn(&(tdev)->intf->dev , fmt , ## args)\n\n#define GUARD_BYTE\t0xA5\n#define MAX_SGLEN\t128\n\n/*-------------------------------------------------------------------------*/\n\nstatic inline void endpoint_update(int edi,\n\t\t\t\t   struct usb_host_endpoint **in,\n\t\t\t\t   struct usb_host_endpoint **out,\n\t\t\t\t   struct usb_host_endpoint *e)\n{\n\tif (edi) {\n\t\tif (!*in)\n\t\t\t*in = e;\n\t} else {\n\t\tif (!*out)\n\t\t\t*out = e;\n\t}\n}\n\nstatic int\nget_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (in) {\n\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t}\n\tif (iso_in) {\n\t\tdev->iso_in = &iso_in->desc;\n\t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* Support for testing basic non-queued I/O streams.\n *\n * These just package urbs as requests that can be easily canceled.\n * Each urb's data buffer is dynamically allocated; callers can fill\n * them with non-zero test data (or test for it) when appropriate.\n */\n\nstatic void simple_callback(struct urb *urb)\n{\n\tcomplete(urb->context);\n}\n\nstatic struct urb *usbtest_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tunsigned\t\ttransfer_flags,\n\tunsigned\t\toffset,\n\tu8\t\t\tbInterval,\n\tusb_complete_t\t\tcomplete_fn)\n{\n\tstruct urb\t\t*urb;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn urb;\n\n\tif (bInterval)\n\t\tusb_fill_int_urb(urb, udev, pipe, NULL, bytes, complete_fn,\n\t\t\t\tNULL, bInterval);\n\telse\n\t\tusb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, complete_fn,\n\t\t\t\tNULL);\n\n\turb->interval = (udev->speed == USB_SPEED_HIGH)\n\t\t\t? (INTERRUPT_RATE << 3)\n\t\t\t: INTERRUPT_RATE;\n\turb->transfer_flags = transfer_flags;\n\tif (usb_pipein(pipe))\n\t\turb->transfer_flags |= URB_SHORT_NOT_OK;\n\n\tif ((bytes + offset) == 0)\n\t\treturn urb;\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\turb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,\n\t\t\tGFP_KERNEL, &urb->transfer_dma);\n\telse\n\t\turb->transfer_buffer = kmalloc(bytes + offset, GFP_KERNEL);\n\n\tif (!urb->transfer_buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\t/* To test unaligned transfers add an offset and fill the\n\t\tunused memory with a guard value */\n\tif (offset) {\n\t\tmemset(urb->transfer_buffer, GUARD_BYTE, offset);\n\t\turb->transfer_buffer += offset;\n\t\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\turb->transfer_dma += offset;\n\t}\n\n\t/* For inbound transfers use guard byte so that test fails if\n\t\tdata not correctly copied */\n\tmemset(urb->transfer_buffer,\n\t\t\tusb_pipein(urb->pipe) ? GUARD_BYTE : 0,\n\t\t\tbytes);\n\treturn urb;\n}\n\nstatic struct urb *simple_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tu8\t\t\tbInterval)\n{\n\treturn usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,\n\t\t\tbInterval, simple_callback);\n}\n\nstatic struct urb *complicated_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tu8\t\t\tbInterval)\n{\n\treturn usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,\n\t\t\tbInterval, complicated_callback);\n}\n\nstatic unsigned pattern;\nstatic unsigned mod_pattern;\nmodule_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(mod_pattern, \"i/o pattern (0 == zeroes)\");\n\nstatic unsigned get_maxpacket(struct usb_device *udev, int pipe)\n{\n\tstruct usb_host_endpoint\t*ep;\n\n\tep = usb_pipe_endpoint(udev, pipe);\n\treturn le16_to_cpup(&ep->desc.wMaxPacketSize);\n}\n\nstatic void simple_fill_buf(struct urb *urb)\n{\n\tunsigned\ti;\n\tu8\t\t*buf = urb->transfer_buffer;\n\tunsigned\tlen = urb->transfer_buffer_length;\n\tunsigned\tmaxpacket;\n\n\tswitch (pattern) {\n\tdefault:\n\t\t/* FALLTHROUGH */\n\tcase 0:\n\t\tmemset(buf, 0, len);\n\t\tbreak;\n\tcase 1:\t\t\t/* mod63 */\n\t\tmaxpacket = get_maxpacket(urb->dev, urb->pipe);\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*buf++ = (u8) ((i % maxpacket) % 63);\n\t\tbreak;\n\t}\n}\n\nstatic inline unsigned long buffer_offset(void *buf)\n{\n\treturn (unsigned long)buf & (ARCH_KMALLOC_MINALIGN - 1);\n}\n\nstatic int check_guard_bytes(struct usbtest_dev *tdev, struct urb *urb)\n{\n\tu8 *buf = urb->transfer_buffer;\n\tu8 *guard = buf - buffer_offset(buf);\n\tunsigned i;\n\n\tfor (i = 0; guard < buf; i++, guard++) {\n\t\tif (*guard != GUARD_BYTE) {\n\t\t\tERROR(tdev, \"guard byte[%d] %d (not %d)\\n\",\n\t\t\t\ti, *guard, GUARD_BYTE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)\n{\n\tunsigned\ti;\n\tu8\t\texpected;\n\tu8\t\t*buf = urb->transfer_buffer;\n\tunsigned\tlen = urb->actual_length;\n\tunsigned\tmaxpacket = get_maxpacket(urb->dev, urb->pipe);\n\n\tint ret = check_guard_bytes(tdev, urb);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++, buf++) {\n\t\tswitch (pattern) {\n\t\t/* all-zeroes has no synchronization issues */\n\t\tcase 0:\n\t\t\texpected = 0;\n\t\t\tbreak;\n\t\t/* mod63 stays in sync with short-terminated transfers,\n\t\t * or otherwise when host and gadget agree on how large\n\t\t * each usb transfer request should be.  resync is done\n\t\t * with set_interface or set_config.\n\t\t */\n\t\tcase 1:\t\t\t/* mod63 */\n\t\t\texpected = (i % maxpacket) % 63;\n\t\t\tbreak;\n\t\t/* always fail unsupported patterns */\n\t\tdefault:\n\t\t\texpected = !*buf;\n\t\t\tbreak;\n\t\t}\n\t\tif (*buf == expected)\n\t\t\tcontinue;\n\t\tERROR(tdev, \"buf[%d] = %d (not %d)\\n\", i, *buf, expected);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void simple_free_urb(struct urb *urb)\n{\n\tunsigned long offset = buffer_offset(urb->transfer_buffer);\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\tusb_free_coherent(\n\t\t\turb->dev,\n\t\t\turb->transfer_buffer_length + offset,\n\t\t\turb->transfer_buffer - offset,\n\t\t\turb->transfer_dma - offset);\n\telse\n\t\tkfree(urb->transfer_buffer - offset);\n\tusb_free_urb(urb);\n}\n\nstatic int simple_io(\n\tstruct usbtest_dev\t*tdev,\n\tstruct urb\t\t*urb,\n\tint\t\t\titerations,\n\tint\t\t\tvary,\n\tint\t\t\texpected,\n\tconst char\t\t*label\n)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tmax = urb->transfer_buffer_length;\n\tstruct completion\tcompletion;\n\tint\t\t\tretval = 0;\n\tunsigned long\t\texpire;\n\n\turb->context = &completion;\n\twhile (retval == 0 && iterations-- > 0) {\n\t\tinit_completion(&completion);\n\t\tif (usb_pipeout(urb->pipe)) {\n\t\t\tsimple_fill_buf(urb);\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (retval != 0)\n\t\t\tbreak;\n\n\t\texpire = msecs_to_jiffies(SIMPLE_IO_TIMEOUT);\n\t\tif (!wait_for_completion_timeout(&completion, expire)) {\n\t\t\tusb_kill_urb(urb);\n\t\t\tretval = (urb->status == -ENOENT ?\n\t\t\t\t  -ETIMEDOUT : urb->status);\n\t\t} else {\n\t\t\tretval = urb->status;\n\t\t}\n\n\t\turb->dev = udev;\n\t\tif (retval == 0 && usb_pipein(urb->pipe))\n\t\t\tretval = simple_check_buf(tdev, urb);\n\n\t\tif (vary) {\n\t\t\tint\tlen = urb->transfer_buffer_length;\n\n\t\t\tlen += vary;\n\t\t\tlen %= max;\n\t\t\tif (len == 0)\n\t\t\t\tlen = (vary < max) ? vary : max;\n\t\t\turb->transfer_buffer_length = len;\n\t\t}\n\n\t\t/* FIXME if endpoint halted, clear halt (and log) */\n\t}\n\turb->transfer_buffer_length = max;\n\n\tif (expected != retval)\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s failed, iterations left %d, status %d (not %d)\\n\",\n\t\t\t\tlabel, iterations, retval, expected);\n\treturn retval;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* We use scatterlist primitives to test queued I/O.\n * Yes, this also tests the scatterlist primitives.\n */\n\nstatic void free_sglist(struct scatterlist *sg, int nents)\n{\n\tunsigned\t\ti;\n\n\tif (!sg)\n\t\treturn;\n\tfor (i = 0; i < nents; i++) {\n\t\tif (!sg_page(&sg[i]))\n\t\t\tcontinue;\n\t\tkfree(sg_virt(&sg[i]));\n\t}\n\tkfree(sg);\n}\n\nstatic struct scatterlist *\nalloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)\n{\n\tstruct scatterlist\t*sg;\n\tunsigned int\t\tn_size = 0;\n\tunsigned\t\ti;\n\tunsigned\t\tsize = max;\n\tunsigned\t\tmaxpacket =\n\t\tget_maxpacket(interface_to_usbdev(dev->intf), pipe);\n\n\tif (max == 0)\n\t\treturn NULL;\n\n\tsg = kmalloc_array(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\treturn NULL;\n\tsg_init_table(sg, nents);\n\n\tfor (i = 0; i < nents; i++) {\n\t\tchar\t\t*buf;\n\t\tunsigned\tj;\n\n\t\tbuf = kzalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tfree_sglist(sg, i);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* kmalloc pages are always physically contiguous! */\n\t\tsg_set_buf(&sg[i], buf, size);\n\n\t\tswitch (pattern) {\n\t\tcase 0:\n\t\t\t/* already zeroed */\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t\t*buf++ = (u8) (((j + n_size) % maxpacket) % 63);\n\t\t\tn_size += size;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vary) {\n\t\t\tsize += vary;\n\t\t\tsize %= max;\n\t\t\tif (size == 0)\n\t\t\t\tsize = (vary < max) ? vary : max;\n\t\t}\n\t}\n\n\treturn sg;\n}\n\nstatic void sg_timeout(unsigned long _req)\n{\n\tstruct usb_sg_request\t*req = (struct usb_sg_request *) _req;\n\n\tusb_sg_cancel(req);\n}\n\nstatic int perform_sglist(\n\tstruct usbtest_dev\t*tdev,\n\tunsigned\t\titerations,\n\tint\t\t\tpipe,\n\tstruct usb_sg_request\t*req,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents\n)\n{\n\tstruct usb_device\t*udev = testdev_to_usbdev(tdev);\n\tint\t\t\tretval = 0;\n\tstruct timer_list\tsg_timer;\n\n\tsetup_timer_on_stack(&sg_timer, sg_timeout, (unsigned long) req);\n\n\twhile (retval == 0 && iterations-- > 0) {\n\t\tretval = usb_sg_init(req, udev, pipe,\n\t\t\t\t(udev->speed == USB_SPEED_HIGH)\n\t\t\t\t\t? (INTERRUPT_RATE << 3)\n\t\t\t\t\t: INTERRUPT_RATE,\n\t\t\t\tsg, nents, 0, GFP_KERNEL);\n\n\t\tif (retval)\n\t\t\tbreak;\n\t\tmod_timer(&sg_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(SIMPLE_IO_TIMEOUT));\n\t\tusb_sg_wait(req);\n\t\tif (!del_timer_sync(&sg_timer))\n\t\t\tretval = -ETIMEDOUT;\n\t\telse\n\t\t\tretval = req->status;\n\n\t\t/* FIXME check resulting data pattern */\n\n\t\t/* FIXME if endpoint halted, clear halt (and log) */\n\t}\n\n\t/* FIXME for unlink or fault handling tests, don't report\n\t * failure if retval is as we expected ...\n\t */\n\tif (retval)\n\t\tERROR(tdev, \"perform_sglist failed, \"\n\t\t\t\t\"iterations left %d, status %d\\n\",\n\t\t\t\titerations, retval);\n\treturn retval;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* unqueued control message testing\n *\n * there's a nice set of device functional requirements in chapter 9 of the\n * usb 2.0 spec, which we can apply to ANY device, even ones that don't use\n * special test firmware.\n *\n * we know the device is configured (or suspended) by the time it's visible\n * through usbfs.  we can't change that, so we won't test enumeration (which\n * worked 'well enough' to get here, this time), power management (ditto),\n * or remote wakeup (which needs human interaction).\n */\n\nstatic unsigned realworld = 1;\nmodule_param(realworld, uint, 0);\nMODULE_PARM_DESC(realworld, \"clear to demand stricter spec compliance\");\n\nstatic int get_altsetting(struct usbtest_dev *dev)\n{\n\tstruct usb_interface\t*iface = dev->intf;\n\tstruct usb_device\t*udev = interface_to_usbdev(iface);\n\tint\t\t\tretval;\n\n\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\tUSB_REQ_GET_INTERFACE, USB_DIR_IN|USB_RECIP_INTERFACE,\n\t\t\t0, iface->altsetting[0].desc.bInterfaceNumber,\n\t\t\tdev->buf, 1, USB_CTRL_GET_TIMEOUT);\n\tswitch (retval) {\n\tcase 1:\n\t\treturn dev->buf[0];\n\tcase 0:\n\t\tretval = -ERANGE;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\treturn retval;\n\t}\n}\n\nstatic int set_altsetting(struct usbtest_dev *dev, int alternate)\n{\n\tstruct usb_interface\t\t*iface = dev->intf;\n\tstruct usb_device\t\t*udev;\n\n\tif (alternate < 0 || alternate >= 256)\n\t\treturn -EINVAL;\n\n\tudev = interface_to_usbdev(iface);\n\treturn usb_set_interface(udev,\n\t\t\tiface->altsetting[0].desc.bInterfaceNumber,\n\t\t\talternate);\n}\n\nstatic int is_good_config(struct usbtest_dev *tdev, int len)\n{\n\tstruct usb_config_descriptor\t*config;\n\n\tif (len < sizeof(*config))\n\t\treturn 0;\n\tconfig = (struct usb_config_descriptor *) tdev->buf;\n\n\tswitch (config->bDescriptorType) {\n\tcase USB_DT_CONFIG:\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\tif (config->bLength != 9) {\n\t\t\tERROR(tdev, \"bogus config descriptor length\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t/* this bit 'must be 1' but often isn't */\n\t\tif (!realworld && !(config->bmAttributes & 0x80)) {\n\t\t\tERROR(tdev, \"high bit of config attributes not set\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (config->bmAttributes & 0x1f) {\t/* reserved == 0 */\n\t\t\tERROR(tdev, \"reserved config bits set\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(config->wTotalLength) == len)\t/* read it all */\n\t\treturn 1;\n\tif (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)\t/* max partial read */\n\t\treturn 1;\n\tERROR(tdev, \"bogus config descriptor read size\\n\");\n\treturn 0;\n}\n\nstatic int is_good_ext(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ext_cap_descriptor *ext;\n\tu32 attr;\n\n\text = (struct usb_ext_cap_descriptor *) buf;\n\n\tif (ext->bLength != USB_DT_USB_EXT_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus usb 2.0 extension descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\tattr = le32_to_cpu(ext->bmAttributes);\n\t/* bits[1:15] is used and others are reserved */\n\tif (attr & ~0xfffe) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_cap_descriptor *ss;\n\n\tss = (struct usb_ss_cap_descriptor *) buf;\n\n\tif (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus superspeed device capability descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * only bit[1] of bmAttributes is used for LTM and others are\n\t * reserved\n\t */\n\tif (ss->bmAttributes & ~0x02) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in bmAttributes\\n\");\n\t\treturn 0;\n\t}\n\n\t/* bits[0:3] of wSpeedSupported is used and others are reserved */\n\tif (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in wSpeedSupported\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_good_con_id(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_container_id_descriptor *con_id;\n\n\tcon_id = (struct usb_ss_container_id_descriptor *) buf;\n\n\tif (con_id->bLength != USB_DT_USB_SS_CONTN_ID_SIZE) {\n\t\tERROR(tdev, \"bogus container id descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\tif (con_id->bReserved) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* sanity test for standard requests working with usb_control_mesg() and some\n * of the utility functions which use it.\n *\n * this doesn't test how endpoint halts behave or data toggles get set, since\n * we won't do I/O to bulk/interrupt endpoints here (which is how to change\n * halt or toggle).  toggle testing is impractical without support from hcds.\n *\n * this avoids failing devices linux would normally work with, by not testing\n * config/altsetting operations for devices that only support their defaults.\n * such devices rarely support those needless operations.\n *\n * NOTE that since this is a sanity test, it's not examining boundary cases\n * to see if usbcore, hcd, and device all behave right.  such testing would\n * involve varied read sizes and other operation sequences.\n */\nstatic int ch9_postconfig(struct usbtest_dev *dev)\n{\n\tstruct usb_interface\t*iface = dev->intf;\n\tstruct usb_device\t*udev = interface_to_usbdev(iface);\n\tint\t\t\ti, alt, retval;\n\n\t/* [9.2.3] if there's more than one altsetting, we need to be able to\n\t * set and get each one.  mostly trusts the descriptors from usbcore.\n\t */\n\tfor (i = 0; i < iface->num_altsetting; i++) {\n\n\t\t/* 9.2.3 constrains the range here */\n\t\talt = iface->altsetting[i].desc.bAlternateSetting;\n\t\tif (alt < 0 || alt >= iface->num_altsetting) {\n\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\"invalid alt [%d].bAltSetting = %d\\n\",\n\t\t\t\t\ti, alt);\n\t\t}\n\n\t\t/* [real world] get/set unimplemented if there's only one */\n\t\tif (realworld && iface->num_altsetting == 1)\n\t\t\tcontinue;\n\n\t\t/* [9.4.10] set_interface */\n\t\tretval = set_altsetting(dev, alt);\n\t\tif (retval) {\n\t\t\tdev_err(&iface->dev, \"can't set_interface = %d, %d\\n\",\n\t\t\t\t\talt, retval);\n\t\t\treturn retval;\n\t\t}\n\n\t\t/* [9.4.4] get_interface always works */\n\t\tretval = get_altsetting(dev);\n\t\tif (retval != alt) {\n\t\t\tdev_err(&iface->dev, \"get alt should be %d, was %d\\n\",\n\t\t\t\t\talt, retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t}\n\n\t/* [real world] get_config unimplemented if there's only one */\n\tif (!realworld || udev->descriptor.bNumConfigurations != 1) {\n\t\tint\texpected = udev->actconfig->desc.bConfigurationValue;\n\n\t\t/* [9.4.2] get_configuration always works\n\t\t * ... although some cheap devices (like one TI Hub I've got)\n\t\t * won't return config descriptors except before set_config.\n\t\t */\n\t\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_GET_CONFIGURATION,\n\t\t\t\tUSB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);\n\t\tif (retval != 1 || dev->buf[0] != expected) {\n\t\t\tdev_err(&iface->dev, \"get config --> %d %d (1 %d)\\n\",\n\t\t\t\tretval, dev->buf[0], expected);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\t}\n\n\t/* there's always [9.4.3] a device descriptor [9.6.1] */\n\tretval = usb_get_descriptor(udev, USB_DT_DEVICE, 0,\n\t\t\tdev->buf, sizeof(udev->descriptor));\n\tif (retval != sizeof(udev->descriptor)) {\n\t\tdev_err(&iface->dev, \"dev descriptor --> %d\\n\", retval);\n\t\treturn (retval < 0) ? retval : -EDOM;\n\t}\n\n\t/*\n\t * there's always [9.4.3] a bos device descriptor [9.6.2] in USB\n\t * 3.0 spec\n\t */\n\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0210) {\n\t\tstruct usb_bos_descriptor *bos = NULL;\n\t\tstruct usb_dev_cap_header *header = NULL;\n\t\tunsigned total, num, length;\n\t\tu8 *buf;\n\n\t\tretval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,\n\t\t\t\tsizeof(*udev->bos->desc));\n\t\tif (retval != sizeof(*udev->bos->desc)) {\n\t\t\tdev_err(&iface->dev, \"bos descriptor --> %d\\n\", retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\tbos = (struct usb_bos_descriptor *)dev->buf;\n\t\ttotal = le16_to_cpu(bos->wTotalLength);\n\t\tnum = bos->bNumDeviceCaps;\n\n\t\tif (total > TBUF_SIZE)\n\t\t\ttotal = TBUF_SIZE;\n\n\t\t/*\n\t\t * get generic device-level capability descriptors [9.6.2]\n\t\t * in USB 3.0 spec\n\t\t */\n\t\tretval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,\n\t\t\t\ttotal);\n\t\tif (retval != total) {\n\t\t\tdev_err(&iface->dev, \"bos descriptor set --> %d\\n\",\n\t\t\t\t\tretval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\tlength = sizeof(*udev->bos->desc);\n\t\tbuf = dev->buf;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tbuf += length;\n\t\t\tif (buf + sizeof(struct usb_dev_cap_header) >\n\t\t\t\t\tdev->buf + total)\n\t\t\t\tbreak;\n\n\t\t\theader = (struct usb_dev_cap_header *)buf;\n\t\t\tlength = header->bLength;\n\n\t\t\tif (header->bDescriptorType !=\n\t\t\t\t\tUSB_DT_DEVICE_CAPABILITY) {\n\t\t\t\tdev_warn(&udev->dev, \"not device capability descriptor, skip\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (header->bDevCapabilityType) {\n\t\t\tcase USB_CAP_TYPE_EXT:\n\t\t\t\tif (buf + USB_DT_USB_EXT_CAP_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_ext(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus usb 2.0 extension descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_SS_CAP_TYPE:\n\t\t\t\tif (buf + USB_DT_USB_SS_CAP_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_ss_cap(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus superspeed device capability descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CONTAINER_ID_TYPE:\n\t\t\t\tif (buf + USB_DT_USB_SS_CONTN_ID_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_con_id(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus container id descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* there's always [9.4.3] at least one config descriptor [9.6.3] */\n\tfor (i = 0; i < udev->descriptor.bNumConfigurations; i++) {\n\t\tretval = usb_get_descriptor(udev, USB_DT_CONFIG, i,\n\t\t\t\tdev->buf, TBUF_SIZE);\n\t\tif (!is_good_config(dev, retval)) {\n\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\"config [%d] descriptor --> %d\\n\",\n\t\t\t\t\ti, retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\t/* FIXME cross-checking udev->config[i] to make sure usbcore\n\t\t * parsed it right (etc) would be good testing paranoia\n\t\t */\n\t}\n\n\t/* and sometimes [9.2.6.6] speed dependent descriptors */\n\tif (le16_to_cpu(udev->descriptor.bcdUSB) == 0x0200) {\n\t\tstruct usb_qualifier_descriptor *d = NULL;\n\n\t\t/* device qualifier [9.6.2] */\n\t\tretval = usb_get_descriptor(udev,\n\t\t\t\tUSB_DT_DEVICE_QUALIFIER, 0, dev->buf,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\tif (retval == -EPIPE) {\n\t\t\tif (udev->speed == USB_SPEED_HIGH) {\n\t\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\t\"hs dev qualifier --> %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\t/* usb2.0 but not high-speed capable; fine */\n\t\t} else if (retval != sizeof(struct usb_qualifier_descriptor)) {\n\t\t\tdev_err(&iface->dev, \"dev qualifier --> %d\\n\", retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t} else\n\t\t\td = (struct usb_qualifier_descriptor *) dev->buf;\n\n\t\t/* might not have [9.6.2] any other-speed configs [9.6.4] */\n\t\tif (d) {\n\t\t\tunsigned max = d->bNumConfigurations;\n\t\t\tfor (i = 0; i < max; i++) {\n\t\t\t\tretval = usb_get_descriptor(udev,\n\t\t\t\t\tUSB_DT_OTHER_SPEED_CONFIG, i,\n\t\t\t\t\tdev->buf, TBUF_SIZE);\n\t\t\t\tif (!is_good_config(dev, retval)) {\n\t\t\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\t\"other speed config --> %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* FIXME fetch strings from at least the device descriptor */\n\n\t/* [9.4.5] get_status always works */\n\tretval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev->buf);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"get dev status --> %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t/* FIXME configuration.bmAttributes says if we could try to set/clear\n\t * the device's remote wakeup feature ... if we can, test that here\n\t */\n\n\tretval = usb_get_status(udev, USB_RECIP_INTERFACE,\n\t\t\tiface->altsetting[0].desc.bInterfaceNumber, dev->buf);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"get interface status --> %d\\n\", retval);\n\t\treturn retval;\n\t}\n\t/* FIXME get status for each endpoint in the interface */\n\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* use ch9 requests to test whether:\n *   (a) queues work for control, keeping N subtests queued and\n *       active (auto-resubmit) for M loops through the queue.\n *   (b) protocol stalls (control-only) will autorecover.\n *       it's not like bulk/intr; no halt clearing.\n *   (c) short control reads are reported and handled.\n *   (d) queues are always processed in-order\n */\n\nstruct ctrl_ctx {\n\tspinlock_t\t\tlock;\n\tstruct usbtest_dev\t*dev;\n\tstruct completion\tcomplete;\n\tunsigned\t\tcount;\n\tunsigned\t\tpending;\n\tint\t\t\tstatus;\n\tstruct urb\t\t**urb;\n\tstruct usbtest_param_32\t*param;\n\tint\t\t\tlast;\n};\n\n#define NUM_SUBCASES\t16\t\t/* how many test subcases here? */\n\nstruct subcase {\n\tstruct usb_ctrlrequest\tsetup;\n\tint\t\t\tnumber;\n\tint\t\t\texpected;\n};\n\nstatic void ctrl_complete(struct urb *urb)\n{\n\tstruct ctrl_ctx\t\t*ctx = urb->context;\n\tstruct usb_ctrlrequest\t*reqp;\n\tstruct subcase\t\t*subcase;\n\tint\t\t\tstatus = urb->status;\n\n\treqp = (struct usb_ctrlrequest *)urb->setup_packet;\n\tsubcase = container_of(reqp, struct subcase, setup);\n\n\tspin_lock(&ctx->lock);\n\tctx->count--;\n\tctx->pending--;\n\n\t/* queue must transfer and complete in fifo order, unless\n\t * usb_unlink_urb() is used to unlink something not at the\n\t * physical queue head (not tested).\n\t */\n\tif (subcase->number > 0) {\n\t\tif ((subcase->number - ctx->last) != 1) {\n\t\t\tERROR(ctx->dev,\n\t\t\t\t\"subcase %d completed out of order, last %d\\n\",\n\t\t\t\tsubcase->number, ctx->last);\n\t\t\tstatus = -EDOM;\n\t\t\tctx->last = subcase->number;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tctx->last = subcase->number;\n\n\t/* succeed or fault in only one way? */\n\tif (status == subcase->expected)\n\t\tstatus = 0;\n\n\t/* async unlink for cleanup? */\n\telse if (status != -ECONNRESET) {\n\n\t\t/* some faults are allowed, not required */\n\t\tif (subcase->expected > 0 && (\n\t\t\t  ((status == -subcase->expected\t/* happened */\n\t\t\t   || status == 0))))\t\t\t/* didn't */\n\t\t\tstatus = 0;\n\t\t/* sometimes more than one fault is allowed */\n\t\telse if (subcase->number == 12 && status == -EPIPE)\n\t\t\tstatus = 0;\n\t\telse\n\t\t\tERROR(ctx->dev, \"subtest %d error, status %d\\n\",\n\t\t\t\t\tsubcase->number, status);\n\t}\n\n\t/* unexpected status codes mean errors; ideally, in hardware */\n\tif (status) {\nerror:\n\t\tif (ctx->status == 0) {\n\t\t\tint\t\ti;\n\n\t\t\tctx->status = status;\n\t\t\tERROR(ctx->dev, \"control queue %02x.%02x, err %d, \"\n\t\t\t\t\t\"%d left, subcase %d, len %d/%d\\n\",\n\t\t\t\t\treqp->bRequestType, reqp->bRequest,\n\t\t\t\t\tstatus, ctx->count, subcase->number,\n\t\t\t\t\turb->actual_length,\n\t\t\t\t\turb->transfer_buffer_length);\n\n\t\t\t/* FIXME this \"unlink everything\" exit route should\n\t\t\t * be a separate test case.\n\t\t\t */\n\n\t\t\t/* unlink whatever's still pending */\n\t\t\tfor (i = 1; i < ctx->param->sglen; i++) {\n\t\t\t\tstruct urb *u = ctx->urb[\n\t\t\t\t\t\t\t(i + subcase->number)\n\t\t\t\t\t\t\t% ctx->param->sglen];\n\n\t\t\t\tif (u == urb || !u->dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&ctx->lock);\n\t\t\t\tstatus = usb_unlink_urb(u);\n\t\t\t\tspin_lock(&ctx->lock);\n\t\t\t\tswitch (status) {\n\t\t\t\tcase -EINPROGRESS:\n\t\t\t\tcase -EBUSY:\n\t\t\t\tcase -EIDRM:\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tERROR(ctx->dev, \"urb unlink --> %d\\n\",\n\t\t\t\t\t\t\tstatus);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatus = ctx->status;\n\t\t}\n\t}\n\n\t/* resubmit if we need to, else mark this as done */\n\tif ((status == 0) && (ctx->pending < ctx->count)) {\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (status != 0) {\n\t\t\tERROR(ctx->dev,\n\t\t\t\t\"can't resubmit ctrl %02x.%02x, err %d\\n\",\n\t\t\t\treqp->bRequestType, reqp->bRequest, status);\n\t\t\turb->dev = NULL;\n\t\t} else\n\t\t\tctx->pending++;\n\t} else\n\t\turb->dev = NULL;\n\n\t/* signal completion when nothing's queued */\n\tif (ctx->pending == 0)\n\t\tcomplete(&ctx->complete);\n\tspin_unlock(&ctx->lock);\n}\n\nstatic int\ntest_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param)\n{\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tstruct urb\t\t**urb;\n\tstruct ctrl_ctx\t\tcontext;\n\tint\t\t\ti;\n\n\tif (param->sglen == 0 || param->iterations > UINT_MAX / param->sglen)\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_init(&context.lock);\n\tcontext.dev = dev;\n\tinit_completion(&context.complete);\n\tcontext.count = param->sglen * param->iterations;\n\tcontext.pending = 0;\n\tcontext.status = -ENOMEM;\n\tcontext.param = param;\n\tcontext.last = -1;\n\n\t/* allocate and init the urbs we'll queue.\n\t * as with bulk/intr sglists, sglen is the queue depth; it also\n\t * controls which subtests run (more tests than sglen) or rerun.\n\t */\n\turb = kcalloc(param->sglen, sizeof(struct urb *), GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tint\t\t\tpipe = usb_rcvctrlpipe(udev, 0);\n\t\tunsigned\t\tlen;\n\t\tstruct urb\t\t*u;\n\t\tstruct usb_ctrlrequest\treq;\n\t\tstruct subcase\t\t*reqp;\n\n\t\t/* sign of this variable means:\n\t\t *  -: tested code must return this (negative) error code\n\t\t *  +: tested code may return this (negative too) error code\n\t\t */\n\t\tint\t\t\texpected = 0;\n\n\t\t/* requests here are mostly expected to succeed on any\n\t\t * device, but some are chosen to trigger protocol stalls\n\t\t * or short reads.\n\t\t */\n\t\tmemset(&req, 0, sizeof(req));\n\t\treq.bRequest = USB_REQ_GET_DESCRIPTOR;\n\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;\n\n\t\tswitch (i % NUM_SUBCASES) {\n\t\tcase 0:\t\t/* get device descriptor */\n\t\t\treq.wValue = cpu_to_le16(USB_DT_DEVICE << 8);\n\t\t\tlen = sizeof(struct usb_device_descriptor);\n\t\t\tbreak;\n\t\tcase 1:\t\t/* get first config descriptor (only) */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = sizeof(struct usb_config_descriptor);\n\t\t\tbreak;\n\t\tcase 2:\t\t/* get altsetting (OFTEN STALLS) */\n\t\t\treq.bRequest = USB_REQ_GET_INTERFACE;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;\n\t\t\t/* index = 0 means first interface */\n\t\t\tlen = 1;\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 3:\t\t/* get interface status */\n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;\n\t\t\t/* interface 0 */\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 4:\t\t/* get device status */\n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 5:\t\t/* get device qualifier (MAY STALL) */\n\t\t\treq.wValue = cpu_to_le16 (USB_DT_DEVICE_QUALIFIER << 8);\n\t\t\tlen = sizeof(struct usb_qualifier_descriptor);\n\t\t\tif (udev->speed != USB_SPEED_HIGH)\n\t\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 6:\t\t/* get first config descriptor, plus interface */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = sizeof(struct usb_config_descriptor);\n\t\t\tlen += sizeof(struct usb_interface_descriptor);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* get interface descriptor (ALWAYS STALLS) */\n\t\t\treq.wValue = cpu_to_le16 (USB_DT_INTERFACE << 8);\n\t\t\t/* interface == 0 */\n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\texpected = -EPIPE;\n\t\t\tbreak;\n\t\t/* NOTE: two consecutive stalls in the queue here.\n\t\t *  that tests fault recovery a bit more aggressively. */\n\t\tcase 8:\t\t/* clear endpoint halt (MAY STALL) */\n\t\t\treq.bRequest = USB_REQ_CLEAR_FEATURE;\n\t\t\treq.bRequestType = USB_RECIP_ENDPOINT;\n\t\t\t/* wValue 0 == ep halt */\n\t\t\t/* wIndex 0 == ep0 (shouldn't halt!) */\n\t\t\tlen = 0;\n\t\t\tpipe = usb_sndctrlpipe(udev, 0);\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 9:\t\t/* get endpoint status */\n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_ENDPOINT;\n\t\t\t/* endpoint 0 */\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 10:\t/* trigger short read (EREMOTEIO) */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = 1024;\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\t/* NOTE: two consecutive _different_ faults in the queue. */\n\t\tcase 11:\t/* get endpoint descriptor (ALWAYS STALLS) */\n\t\t\treq.wValue = cpu_to_le16(USB_DT_ENDPOINT << 8);\n\t\t\t/* endpoint == 0 */\n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\t/* NOTE: sometimes even a third fault in the queue! */\n\t\tcase 12:\t/* get string 0 descriptor (MAY STALL) */\n\t\t\treq.wValue = cpu_to_le16(USB_DT_STRING << 8);\n\t\t\t/* string == 0, for language IDs */\n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\t/* may succeed when > 4 languages */\n\t\t\texpected = EREMOTEIO;\t/* or EPIPE, if no strings */\n\t\t\tbreak;\n\t\tcase 13:\t/* short read, resembling case 10 */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\t/* last data packet \"should\" be DATA1, not DATA0 */\n\t\t\tif (udev->speed == USB_SPEED_SUPER)\n\t\t\t\tlen = 1024 - 512;\n\t\t\telse\n\t\t\t\tlen = 1024 - udev->descriptor.bMaxPacketSize0;\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\tcase 14:\t/* short read; try to fill the last packet */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_DEVICE << 8) | 0);\n\t\t\t/* device descriptor size == 18 bytes */\n\t\t\tlen = udev->descriptor.bMaxPacketSize0;\n\t\t\tif (udev->speed == USB_SPEED_SUPER)\n\t\t\t\tlen = 512;\n\t\t\tswitch (len) {\n\t\t\tcase 8:\n\t\t\t\tlen = 24;\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tlen = 32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treq.wValue = cpu_to_le16(USB_DT_BOS << 8);\n\t\t\tif (udev->bos)\n\t\t\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\t\telse\n\t\t\t\tlen = sizeof(struct usb_bos_descriptor);\n\t\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) < 0x0201)\n\t\t\t\texpected = -EPIPE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(dev, \"bogus number of ctrl queue testcases!\\n\");\n\t\t\tcontext.status = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\treq.wLength = cpu_to_le16(len);\n\t\turb[i] = u = simple_alloc_urb(udev, pipe, len, 0);\n\t\tif (!u)\n\t\t\tgoto cleanup;\n\n\t\treqp = kmalloc(sizeof(*reqp), GFP_KERNEL);\n\t\tif (!reqp)\n\t\t\tgoto cleanup;\n\t\treqp->setup = req;\n\t\treqp->number = i % NUM_SUBCASES;\n\t\treqp->expected = expected;\n\t\tu->setup_packet = (char *) &reqp->setup;\n\n\t\tu->context = &context;\n\t\tu->complete = ctrl_complete;\n\t}\n\n\t/* queue the urbs */\n\tcontext.urb = urb;\n\tspin_lock_irq(&context.lock);\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tcontext.status = usb_submit_urb(urb[i], GFP_ATOMIC);\n\t\tif (context.status != 0) {\n\t\t\tERROR(dev, \"can't submit urb[%d], status %d\\n\",\n\t\t\t\t\ti, context.status);\n\t\t\tcontext.count = context.pending;\n\t\t\tbreak;\n\t\t}\n\t\tcontext.pending++;\n\t}\n\tspin_unlock_irq(&context.lock);\n\n\t/* FIXME  set timer and time out; provide a disconnect hook */\n\n\t/* wait for the last one to complete */\n\tif (context.pending > 0)\n\t\twait_for_completion(&context.complete);\n\ncleanup:\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (!urb[i])\n\t\t\tcontinue;\n\t\turb[i]->dev = udev;\n\t\tkfree(urb[i]->setup_packet);\n\t\tsimple_free_urb(urb[i]);\n\t}\n\tkfree(urb);\n\treturn context.status;\n}\n#undef NUM_SUBCASES\n\n\n/*-------------------------------------------------------------------------*/\n\nstatic void unlink1_callback(struct urb *urb)\n{\n\tint\tstatus = urb->status;\n\n\t/* we \"know\" -EPIPE (stall) never happens */\n\tif (!status)\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\turb->status = status;\n\t\tcomplete(urb->context);\n\t}\n}\n\nstatic int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)\n{\n\tstruct urb\t\t*urb;\n\tstruct completion\tcompletion;\n\tint\t\t\tretval = 0;\n\n\tinit_completion(&completion);\n\turb = simple_alloc_urb(testdev_to_usbdev(dev), pipe, size, 0);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\turb->context = &completion;\n\turb->complete = unlink1_callback;\n\n\tif (usb_pipeout(urb->pipe)) {\n\t\tsimple_fill_buf(urb);\n\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t}\n\n\t/* keep the endpoint busy.  there are lots of hc/hcd-internal\n\t * states, and testing should get to all of them over time.\n\t *\n\t * FIXME want additional tests for when endpoint is STALLing\n\t * due to errors, or is just NAKing requests.\n\t */\n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (retval != 0) {\n\t\tdev_err(&dev->intf->dev, \"submit fail %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t/* unlinking that should always work.  variable delay tests more\n\t * hcd states and code paths, even with little other system load.\n\t */\n\tmsleep(jiffies % (2 * INTERRUPT_RATE));\n\tif (async) {\n\t\twhile (!completion_done(&completion)) {\n\t\t\tretval = usb_unlink_urb(urb);\n\n\t\t\tif (retval == 0 && usb_pipein(urb->pipe))\n\t\t\t\tretval = simple_check_buf(dev, urb);\n\n\t\t\tswitch (retval) {\n\t\t\tcase -EBUSY:\n\t\t\tcase -EIDRM:\n\t\t\t\t/* we can't unlink urbs while they're completing\n\t\t\t\t * or if they've completed, and we haven't\n\t\t\t\t * resubmitted. \"normal\" drivers would prevent\n\t\t\t\t * resubmission, but since we're testing unlink\n\t\t\t\t * paths, we can't.\n\t\t\t\t */\n\t\t\t\tERROR(dev, \"unlink retry\\n\");\n\t\t\t\tcontinue;\n\t\t\tcase 0:\n\t\t\tcase -EINPROGRESS:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"unlink fail %d\\n\", retval);\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tusb_kill_urb(urb);\n\n\twait_for_completion(&completion);\n\tretval = urb->status;\n\tsimple_free_urb(urb);\n\n\tif (async)\n\t\treturn (retval == -ECONNRESET) ? 0 : retval - 1000;\n\telse\n\t\treturn (retval == -ENOENT || retval == -EPERM) ?\n\t\t\t\t0 : retval - 2000;\n}\n\nstatic int unlink_simple(struct usbtest_dev *dev, int pipe, int len)\n{\n\tint\t\t\tretval = 0;\n\n\t/* test sync and async paths */\n\tretval = unlink1(dev, pipe, len, 1);\n\tif (!retval)\n\t\tretval = unlink1(dev, pipe, len, 0);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstruct queued_ctx {\n\tstruct completion\tcomplete;\n\tatomic_t\t\tpending;\n\tunsigned\t\tnum;\n\tint\t\t\tstatus;\n\tstruct urb\t\t**urbs;\n};\n\nstatic void unlink_queued_callback(struct urb *urb)\n{\n\tint\t\t\tstatus = urb->status;\n\tstruct queued_ctx\t*ctx = urb->context;\n\n\tif (ctx->status)\n\t\tgoto done;\n\tif (urb == ctx->urbs[ctx->num - 4] || urb == ctx->urbs[ctx->num - 2]) {\n\t\tif (status == -ECONNRESET)\n\t\t\tgoto done;\n\t\t/* What error should we report if the URB completed normally? */\n\t}\n\tif (status != 0)\n\t\tctx->status = status;\n\n done:\n\tif (atomic_dec_and_test(&ctx->pending))\n\t\tcomplete(&ctx->complete);\n}\n\nstatic int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,\n\t\tunsigned size)\n{\n\tstruct queued_ctx\tctx;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tvoid\t\t\t*buf;\n\tdma_addr_t\t\tbuf_dma;\n\tint\t\t\ti;\n\tint\t\t\tretval = -ENOMEM;\n\n\tinit_completion(&ctx.complete);\n\tatomic_set(&ctx.pending, 1);\t/* One more than the actual value */\n\tctx.num = num;\n\tctx.status = 0;\n\n\tbuf = usb_alloc_coherent(udev, size, GFP_KERNEL, &buf_dma);\n\tif (!buf)\n\t\treturn retval;\n\tmemset(buf, 0, size);\n\n\t/* Allocate and init the urbs we'll queue */\n\tctx.urbs = kcalloc(num, sizeof(struct urb *), GFP_KERNEL);\n\tif (!ctx.urbs)\n\t\tgoto free_buf;\n\tfor (i = 0; i < num; i++) {\n\t\tctx.urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ctx.urbs[i])\n\t\t\tgoto free_urbs;\n\t\tusb_fill_bulk_urb(ctx.urbs[i], udev, pipe, buf, size,\n\t\t\t\tunlink_queued_callback, &ctx);\n\t\tctx.urbs[i]->transfer_dma = buf_dma;\n\t\tctx.urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\n\t\tif (usb_pipeout(ctx.urbs[i]->pipe)) {\n\t\t\tsimple_fill_buf(ctx.urbs[i]);\n\t\t\tctx.urbs[i]->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t}\n\n\t/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */\n\tfor (i = 0; i < num; i++) {\n\t\tatomic_inc(&ctx.pending);\n\t\tretval = usb_submit_urb(ctx.urbs[i], GFP_KERNEL);\n\t\tif (retval != 0) {\n\t\t\tdev_err(&dev->intf->dev, \"submit urbs[%d] fail %d\\n\",\n\t\t\t\t\ti, retval);\n\t\t\tatomic_dec(&ctx.pending);\n\t\t\tctx.status = retval;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == num) {\n\t\tusb_unlink_urb(ctx.urbs[num - 4]);\n\t\tusb_unlink_urb(ctx.urbs[num - 2]);\n\t} else {\n\t\twhile (--i >= 0)\n\t\t\tusb_unlink_urb(ctx.urbs[i]);\n\t}\n\n\tif (atomic_dec_and_test(&ctx.pending))\t\t/* The extra count */\n\t\tcomplete(&ctx.complete);\n\twait_for_completion(&ctx.complete);\n\tretval = ctx.status;\n\n free_urbs:\n\tfor (i = 0; i < num; i++)\n\t\tusb_free_urb(ctx.urbs[i]);\n\tkfree(ctx.urbs);\n free_buf:\n\tusb_free_coherent(udev, size, buf, buf_dma);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\tu16\tstatus;\n\n\t/* shouldn't look or act halted */\n\tretval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't get no-halt status, %d\\n\",\n\t\t\t\tep, retval);\n\t\treturn retval;\n\t}\n\tif (status != 0) {\n\t\tERROR(tdev, \"ep %02x bogus status: %04x != 0\\n\", ep, status);\n\t\treturn -EINVAL;\n\t}\n\tretval = simple_io(tdev, urb, 1, 0, 0, __func__);\n\tif (retval != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\tu16\tstatus;\n\n\t/* should look and act halted */\n\tretval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't get halt status, %d\\n\",\n\t\t\t\tep, retval);\n\t\treturn retval;\n\t}\n\tif (status != 1) {\n\t\tERROR(tdev, \"ep %02x bogus status: %04x != 1\\n\", ep, status);\n\t\treturn -EINVAL;\n\t}\n\tretval = simple_io(tdev, urb, 1, 0, -EPIPE, __func__);\n\tif (retval != -EPIPE)\n\t\treturn -EINVAL;\n\tretval = simple_io(tdev, urb, 1, 0, -EPIPE, \"verify_still_halted\");\n\tif (retval != -EPIPE)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\n\t/* shouldn't look or act halted now */\n\tretval = verify_not_halted(tdev, ep, urb);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/* set halt (protocol test only), verify it worked */\n\tretval = usb_control_msg(urb->dev, usb_sndctrlpipe(urb->dev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT,\n\t\t\tUSB_ENDPOINT_HALT, ep,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't set halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\tretval = verify_halted(tdev, ep, urb);\n\tif (retval < 0) {\n\t\tint ret;\n\n\t\t/* clear halt anyways, else further tests will fail */\n\t\tret = usb_clear_halt(urb->dev, urb->pipe);\n\t\tif (ret)\n\t\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\",\n\t\t\t      ep, ret);\n\n\t\treturn retval;\n\t}\n\n\t/* clear halt (tests API + protocol), verify it worked */\n\tretval = usb_clear_halt(urb->dev, urb->pipe);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\tretval = verify_not_halted(tdev, ep, urb);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/* NOTE:  could also verify SET_INTERFACE clear halts ... */\n\n\treturn 0;\n}\n\nstatic int halt_simple(struct usbtest_dev *dev)\n{\n\tint\t\t\tep;\n\tint\t\t\tretval = 0;\n\tstruct urb\t\t*urb;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\n\tif (udev->speed == USB_SPEED_SUPER)\n\t\turb = simple_alloc_urb(udev, 0, 1024, 0);\n\telse\n\t\turb = simple_alloc_urb(udev, 0, 512, 0);\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (dev->in_pipe) {\n\t\tep = usb_pipeendpoint(dev->in_pipe) | USB_DIR_IN;\n\t\turb->pipe = dev->in_pipe;\n\t\tretval = test_halt(dev, ep, urb);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (dev->out_pipe) {\n\t\tep = usb_pipeendpoint(dev->out_pipe);\n\t\turb->pipe = dev->out_pipe;\n\t\tretval = test_halt(dev, ep, urb);\n\t}\ndone:\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* Control OUT tests use the vendor control requests from Intel's\n * USB 2.0 compliance test device:  write a buffer, read it back.\n *\n * Intel's spec only _requires_ that it work for one packet, which\n * is pretty weak.   Some HCDs place limits here; most devices will\n * need to be able to handle more than one OUT data packet.  We'll\n * try whatever we're told to try.\n */\nstatic int ctrl_out(struct usbtest_dev *dev,\n\t\tunsigned count, unsigned length, unsigned vary, unsigned offset)\n{\n\tunsigned\t\ti, j, len;\n\tint\t\t\tretval;\n\tu8\t\t\t*buf;\n\tchar\t\t\t*what = \"?\";\n\tstruct usb_device\t*udev;\n\n\tif (length < 1 || length > 0xffff || vary >= length)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(length + offset, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf += offset;\n\tudev = testdev_to_usbdev(dev);\n\tlen = length;\n\tretval = 0;\n\n\t/* NOTE:  hardware might well act differently if we pushed it\n\t * with lots back-to-back queued requests.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\t/* write patterned data */\n\t\tfor (j = 0; j < len; j++)\n\t\t\tbuf[j] = (u8)(i + j);\n\t\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t0x5b, USB_DIR_OUT|USB_TYPE_VENDOR,\n\t\t\t\t0, 0, buf, len, USB_CTRL_SET_TIMEOUT);\n\t\tif (retval != len) {\n\t\t\twhat = \"write\";\n\t\t\tif (retval >= 0) {\n\t\t\t\tERROR(dev, \"ctrl_out, wlen %d (expected %d)\\n\",\n\t\t\t\t\t\tretval, len);\n\t\t\t\tretval = -EBADMSG;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* read it back -- assuming nothing intervened!!  */\n\t\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t0x5c, USB_DIR_IN|USB_TYPE_VENDOR,\n\t\t\t\t0, 0, buf, len, USB_CTRL_GET_TIMEOUT);\n\t\tif (retval != len) {\n\t\t\twhat = \"read\";\n\t\t\tif (retval >= 0) {\n\t\t\t\tERROR(dev, \"ctrl_out, rlen %d (expected %d)\\n\",\n\t\t\t\t\t\tretval, len);\n\t\t\t\tretval = -EBADMSG;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* fail if we can't verify */\n\t\tfor (j = 0; j < len; j++) {\n\t\t\tif (buf[j] != (u8)(i + j)) {\n\t\t\t\tERROR(dev, \"ctrl_out, byte %d is %d not %d\\n\",\n\t\t\t\t\tj, buf[j], (u8)(i + j));\n\t\t\t\tretval = -EBADMSG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (retval < 0) {\n\t\t\twhat = \"verify\";\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += vary;\n\n\t\t/* [real world] the \"zero bytes IN\" case isn't really used.\n\t\t * hardware can easily trip up in this weird case, since its\n\t\t * status stage is IN, not OUT like other ep0in transfers.\n\t\t */\n\t\tif (len > length)\n\t\t\tlen = realworld ? 1 : 0;\n\t}\n\n\tif (retval < 0)\n\t\tERROR(dev, \"ctrl_out %s failed, code %d, count %d\\n\",\n\t\t\twhat, retval, i);\n\n\tkfree(buf - offset);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* ISO/BULK tests ... mimics common usage\n *  - buffer length is split into N packets (mostly maxpacket sized)\n *  - multi-buffers according to sglen\n */\n\nstruct transfer_context {\n\tunsigned\t\tcount;\n\tunsigned\t\tpending;\n\tspinlock_t\t\tlock;\n\tstruct completion\tdone;\n\tint\t\t\tsubmit_error;\n\tunsigned long\t\terrors;\n\tunsigned long\t\tpacket_count;\n\tstruct usbtest_dev\t*dev;\n\tbool\t\t\tis_iso;\n};\n\nstatic void complicated_callback(struct urb *urb)\n{\n\tstruct transfer_context\t*ctx = urb->context;\n\n\tspin_lock(&ctx->lock);\n\tctx->count--;\n\n\tctx->packet_count += urb->number_of_packets;\n\tif (urb->error_count > 0)\n\t\tctx->errors += urb->error_count;\n\telse if (urb->status != 0)\n\t\tctx->errors += (ctx->is_iso ? urb->number_of_packets : 1);\n\telse if (urb->actual_length != urb->transfer_buffer_length)\n\t\tctx->errors++;\n\telse if (check_guard_bytes(ctx->dev, urb) != 0)\n\t\tctx->errors++;\n\n\tif (urb->status == 0 && ctx->count > (ctx->pending - 1)\n\t\t\t&& !ctx->submit_error) {\n\t\tint status = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tdev_err(&ctx->dev->intf->dev,\n\t\t\t\t\t\"resubmit err %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t/* FALLTHROUGH */\n\t\tcase -ENODEV:\t\t\t/* disconnected */\n\t\tcase -ESHUTDOWN:\t\t/* endpoint disabled */\n\t\t\tctx->submit_error = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->pending--;\n\tif (ctx->pending == 0) {\n\t\tif (ctx->errors)\n\t\t\tdev_err(&ctx->dev->intf->dev,\n\t\t\t\t\"during the test, %lu errors out of %lu\\n\",\n\t\t\t\tctx->errors, ctx->packet_count);\n\t\tcomplete(&ctx->done);\n\t}\ndone:\n\tspin_unlock(&ctx->lock);\n}\n\nstatic struct urb *iso_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tstruct usb_endpoint_descriptor\t*desc,\n\tlong\t\t\tbytes,\n\tunsigned offset\n)\n{\n\tstruct urb\t\t*urb;\n\tunsigned\t\ti, maxp, packets;\n\n\tif (bytes < 0 || !desc)\n\t\treturn NULL;\n\tmaxp = 0x7ff & usb_endpoint_maxp(desc);\n\tmaxp *= usb_endpoint_maxp_mult(desc);\n\tpackets = DIV_ROUND_UP(bytes, maxp);\n\n\turb = usb_alloc_urb(packets, GFP_KERNEL);\n\tif (!urb)\n\t\treturn urb;\n\turb->dev = udev;\n\turb->pipe = pipe;\n\n\turb->number_of_packets = packets;\n\turb->transfer_buffer_length = bytes;\n\turb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,\n\t\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t\t&urb->transfer_dma);\n\tif (!urb->transfer_buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\tif (offset) {\n\t\tmemset(urb->transfer_buffer, GUARD_BYTE, offset);\n\t\turb->transfer_buffer += offset;\n\t\turb->transfer_dma += offset;\n\t}\n\t/* For inbound transfers use guard byte so that test fails if\n\t\tdata not correctly copied */\n\tmemset(urb->transfer_buffer,\n\t\t\tusb_pipein(urb->pipe) ? GUARD_BYTE : 0,\n\t\t\tbytes);\n\n\tfor (i = 0; i < packets; i++) {\n\t\t/* here, only the last packet will be short */\n\t\turb->iso_frame_desc[i].length = min((unsigned) bytes, maxp);\n\t\tbytes -= urb->iso_frame_desc[i].length;\n\n\t\turb->iso_frame_desc[i].offset = maxp * i;\n\t}\n\n\turb->complete = complicated_callback;\n\t/* urb->context = SET BY CALLER */\n\turb->interval = 1 << (desc->bInterval - 1);\n\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\treturn urb;\n}\n\nstatic int\ntest_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,\n\t\tint pipe, struct usb_endpoint_descriptor *desc, unsigned offset)\n{\n\tstruct transfer_context\tcontext;\n\tstruct usb_device\t*udev;\n\tunsigned\t\ti;\n\tunsigned long\t\tpackets = 0;\n\tint\t\t\tstatus = 0;\n\tstruct urb\t\t*urbs[param->sglen];\n\n\tif (!param->sglen || param->iterations > UINT_MAX / param->sglen)\n\t\treturn -EINVAL;\n\n\tmemset(&context, 0, sizeof(context));\n\tcontext.count = param->iterations * param->sglen;\n\tcontext.dev = dev;\n\tcontext.is_iso = !!desc;\n\tinit_completion(&context.done);\n\tspin_lock_init(&context.lock);\n\n\tudev = testdev_to_usbdev(dev);\n\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (context.is_iso)\n\t\t\turbs[i] = iso_alloc_urb(udev, pipe, desc,\n\t\t\t\t\tparam->length, offset);\n\t\telse\n\t\t\turbs[i] = complicated_alloc_urb(udev, pipe,\n\t\t\t\t\tparam->length, 0);\n\n\t\tif (!urbs[i]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpackets += urbs[i]->number_of_packets;\n\t\turbs[i]->context = &context;\n\t}\n\tpackets *= param->iterations;\n\n\tif (context.is_iso) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t\"iso period %d %sframes, wMaxPacket %d, transactions: %d\\n\",\n\t\t\t1 << (desc->bInterval - 1),\n\t\t\t(udev->speed == USB_SPEED_HIGH) ? \"micro\" : \"\",\n\t\t\tusb_endpoint_maxp(desc),\n\t\t\tusb_endpoint_maxp_mult(desc));\n\n\t\tdev_info(&dev->intf->dev,\n\t\t\t\"total %lu msec (%lu packets)\\n\",\n\t\t\t(packets * (1 << (desc->bInterval - 1)))\n\t\t\t\t/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),\n\t\t\tpackets);\n\t}\n\n\tspin_lock_irq(&context.lock);\n\tfor (i = 0; i < param->sglen; i++) {\n\t\t++context.pending;\n\t\tstatus = usb_submit_urb(urbs[i], GFP_ATOMIC);\n\t\tif (status < 0) {\n\t\t\tERROR(dev, \"submit iso[%d], error %d\\n\", i, status);\n\t\t\tif (i == 0) {\n\t\t\t\tspin_unlock_irq(&context.lock);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsimple_free_urb(urbs[i]);\n\t\t\turbs[i] = NULL;\n\t\t\tcontext.pending--;\n\t\t\tcontext.submit_error = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&context.lock);\n\n\twait_for_completion(&context.done);\n\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (urbs[i])\n\t\t\tsimple_free_urb(urbs[i]);\n\t}\n\t/*\n\t * Isochronous transfers are expected to fail sometimes.  As an\n\t * arbitrary limit, we will report an error if any submissions\n\t * fail or if the transfer failure rate is > 10%.\n\t */\n\tif (status != 0)\n\t\t;\n\telse if (context.submit_error)\n\t\tstatus = -EACCES;\n\telse if (context.errors >\n\t\t\t(context.is_iso ? context.packet_count / 10 : 0))\n\t\tstatus = -EIO;\n\treturn status;\n\nfail:\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (urbs[i])\n\t\t\tsimple_free_urb(urbs[i]);\n\t}\n\treturn status;\n}\n\nstatic int test_unaligned_bulk(\n\tstruct usbtest_dev *tdev,\n\tint pipe,\n\tunsigned length,\n\tint iterations,\n\tunsigned transfer_flags,\n\tconst char *label)\n{\n\tint retval;\n\tstruct urb *urb = usbtest_alloc_urb(testdev_to_usbdev(tdev),\n\t\t\tpipe, length, transfer_flags, 1, 0, simple_callback);\n\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tretval = simple_io(tdev, urb, iterations, 0, 0, label);\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\n/* Run tests. */\nstatic int\nusbtest_do_ioctl(struct usb_interface *intf, struct usbtest_param_32 *param)\n{\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tstruct urb\t\t*urb;\n\tstruct scatterlist\t*sg;\n\tstruct usb_sg_request\treq;\n\tunsigned\t\ti;\n\tint\tretval = -EOPNOTSUPP;\n\n\tif (param->iterations <= 0)\n\t\treturn -EINVAL;\n\tif (param->sglen > MAX_SGLEN)\n\t\treturn -EINVAL;\n\t/*\n\t * Just a bunch of test cases that every HCD is expected to handle.\n\t *\n\t * Some may need specific firmware, though it'd be good to have\n\t * one firmware image to handle all the test cases.\n\t *\n\t * FIXME add more tests!  cancel requests, verify the data, control\n\t * queueing, concurrent read+write threads, and so on.\n\t */\n\tswitch (param->test_num) {\n\n\tcase 0:\n\t\tdev_info(&intf->dev, \"TEST 0:  NOP\\n\");\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* Simple non-queued bulk I/O tests */\n\tcase 1:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 1:  write %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test1\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 2:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 2:  read %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test2\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 3:\n\t\tif (dev->out_pipe == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 3:  write/%d 0..%d bytes %u times\\n\",\n\t\t\t\tparam->vary, param->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, param->vary,\n\t\t\t\t\t0, \"test3\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 4:\n\t\tif (dev->in_pipe == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 4:  read/%d 0..%d bytes %u times\\n\",\n\t\t\t\tparam->vary, param->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, param->vary,\n\t\t\t\t\t0, \"test4\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\n\t/* Queued bulk I/O tests */\n\tcase 5:\n\t\tif (dev->out_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 5:  write %d sglists %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\t0, dev, dev->out_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->out_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\n\tcase 6:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 6:  read %d sglists %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\t0, dev, dev->in_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->in_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\tcase 7:\n\t\tif (dev->out_pipe == 0 || param->sglen == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\\n\",\n\t\t\t\tparam->vary, param->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\tparam->vary, dev, dev->out_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->out_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\tcase 8:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\\n\",\n\t\t\t\tparam->vary, param->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\tparam->vary, dev, dev->in_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->in_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\n\t/* non-queued sanity tests for control (chapter 9 subset) */\n\tcase 9:\n\t\tretval = 0;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 9:  ch9 (subset) control tests, %d times\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = ch9_postconfig(dev);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"ch9 subset failed, \"\n\t\t\t\t\t\"iterations left %d\\n\", i);\n\t\tbreak;\n\n\t/* queued control messaging */\n\tcase 10:\n\t\tretval = 0;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 10:  queue %d control calls, %d times\\n\",\n\t\t\t\tparam->sglen,\n\t\t\t\tparam->iterations);\n\t\tretval = test_ctrl_queue(dev, param);\n\t\tbreak;\n\n\t/* simple non-queued unlinks (ring with one urb) */\n\tcase 11:\n\t\tif (dev->in_pipe == 0 || !param->length)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 11:  unlink %d reads of %d\\n\",\n\t\t\t\tparam->iterations, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = unlink_simple(dev, dev->in_pipe,\n\t\t\t\t\t\tparam->length);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"unlink reads failed %d, \"\n\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\tbreak;\n\tcase 12:\n\t\tif (dev->out_pipe == 0 || !param->length)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 12:  unlink %d writes of %d\\n\",\n\t\t\t\tparam->iterations, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = unlink_simple(dev, dev->out_pipe,\n\t\t\t\t\t\tparam->length);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"unlink writes failed %d, \"\n\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\tbreak;\n\n\t/* ep halt tests */\n\tcase 13:\n\t\tif (dev->out_pipe == 0 && dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 13:  set/clear %d halts\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = halt_simple(dev);\n\n\t\tif (retval)\n\t\t\tERROR(dev, \"halts failed, iterations left %d\\n\", i);\n\t\tbreak;\n\n\t/* control write tests */\n\tcase 14:\n\t\tif (!dev->info->ctrl_out)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev, \"TEST 14:  %d ep0out, %d..%d vary %d\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\trealworld ? 1 : 0, param->length,\n\t\t\t\tparam->vary);\n\t\tretval = ctrl_out(dev, param->iterations,\n\t\t\t\tparam->length, param->vary, 0);\n\t\tbreak;\n\n\t/* iso write tests */\n\tcase 15:\n\t\tif (dev->out_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 15:  write %d iso, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\t/* FIRMWARE:  iso sink */\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_iso_pipe, dev->iso_out, 0);\n\t\tbreak;\n\n\t/* iso read tests */\n\tcase 16:\n\t\tif (dev->in_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 16:  read %d iso, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\t/* FIRMWARE:  iso source */\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_iso_pipe, dev->iso_in, 0);\n\t\tbreak;\n\n\t/* FIXME scatterlist cancel (needs helper thread) */\n\n\t/* Tests for bulk I/O using DMA mapping by core and odd address */\n\tcase 17:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 17:  write odd addr %d bytes %u times core map\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->out_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\t0, \"test17\");\n\t\tbreak;\n\n\tcase 18:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 18:  read odd addr %d bytes %u times core map\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->in_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\t0, \"test18\");\n\t\tbreak;\n\n\t/* Tests for bulk I/O using premapped coherent buffer and odd address */\n\tcase 19:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 19:  write odd addr %d bytes %u times premapped\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->out_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\tURB_NO_TRANSFER_DMA_MAP, \"test19\");\n\t\tbreak;\n\n\tcase 20:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 20:  read odd addr %d bytes %u times premapped\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->in_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\tURB_NO_TRANSFER_DMA_MAP, \"test20\");\n\t\tbreak;\n\n\t/* control write tests with unaligned buffer */\n\tcase 21:\n\t\tif (!dev->info->ctrl_out)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 21:  %d ep0out odd addr, %d..%d vary %d\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\trealworld ? 1 : 0, param->length,\n\t\t\t\tparam->vary);\n\t\tretval = ctrl_out(dev, param->iterations,\n\t\t\t\tparam->length, param->vary, 1);\n\t\tbreak;\n\n\t/* unaligned iso tests */\n\tcase 22:\n\t\tif (dev->out_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 22:  write %d iso odd, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_iso_pipe, dev->iso_out, 1);\n\t\tbreak;\n\n\tcase 23:\n\t\tif (dev->in_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 23:  read %d iso odd, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_iso_pipe, dev->iso_in, 1);\n\t\tbreak;\n\n\t/* unlink URBs from a bulk-OUT queue */\n\tcase 24:\n\t\tif (dev->out_pipe == 0 || !param->length || param->sglen < 4)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 24:  unlink from %d queues of \"\n\t\t\t\t\"%d %d-byte writes\\n\",\n\t\t\t\tparam->iterations, param->sglen, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i > 0; --i) {\n\t\t\tretval = unlink_queued(dev, dev->out_pipe,\n\t\t\t\t\t\tparam->sglen, param->length);\n\t\t\tif (retval) {\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"unlink queued writes failed %d, \"\n\t\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t/* Simple non-queued interrupt I/O tests */\n\tcase 25:\n\t\tif (dev->out_int_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 25: write %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_int_pipe, param->length,\n\t\t\t\tdev->int_out->bInterval);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE: interrupt sink (maybe accepts short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test25\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 26:\n\t\tif (dev->in_int_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 26: read %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_int_pipe, param->length,\n\t\t\t\tdev->int_in->bInterval);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE: interrupt source (maybe generates short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test26\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 27:\n\t\t/* We do performance test, so ignore data compare */\n\t\tif (dev->out_pipe == 0 || param->sglen == 0 || pattern != 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 27: bulk write %dMbytes\\n\", (param->iterations *\n\t\t\tparam->sglen * param->length) / (1024 * 1024));\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_pipe, NULL, 0);\n\t\tbreak;\n\tcase 28:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0 || pattern != 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 28: bulk read %dMbytes\\n\", (param->iterations *\n\t\t\tparam->sglen * param->length) / (1024 * 1024));\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_pipe, NULL, 0);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* We only have this one interface to user space, through usbfs.\n * User mode code can scan usbfs to find N different devices (maybe on\n * different busses) to use when testing, and allocate one thread per\n * test.  So discovery is simplified, and we have no device naming issues.\n *\n * Don't use these only as stress/load tests.  Use them along with with\n * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,\n * video capture, and so on.  Run different tests at different times, in\n * different sequences.  Nothing here should interact with other devices,\n * except indirectly by consuming USB bandwidth and CPU resources for test\n * threads and request completion.  But the only way to know that for sure\n * is to test when HC queues are in use by many devices.\n *\n * WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),\n * it locks out usbcore in certain code paths.  Notably, if you disconnect\n * the device-under-test, hub_wq will wait block forever waiting for the\n * ioctl to complete ... so that usb_disconnect() can abort the pending\n * urbs and then call usbtest_disconnect().  To abort a test, you're best\n * off just killing the userspace task and waiting for it to exit.\n */\n\nstatic int\nusbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)\n{\n\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\tstruct usbtest_param_64 *param_64 = buf;\n\tstruct usbtest_param_32 temp;\n\tstruct usbtest_param_32 *param_32 = buf;\n\tstruct timespec64 start;\n\tstruct timespec64 end;\n\tstruct timespec64 duration;\n\tint retval = -EOPNOTSUPP;\n\n\t/* FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. */\n\n\tpattern = mod_pattern;\n\n\tif (mutex_lock_interruptible(&dev->lock))\n\t\treturn -ERESTARTSYS;\n\n\t/* FIXME: What if a system sleep starts while a test is running? */\n\n\t/* some devices, like ez-usb default devices, need a non-default\n\t * altsetting to have any active endpoints.  some tests change\n\t * altsettings; force a default so most tests don't need to check.\n\t */\n\tif (dev->info->alt >= 0) {\n\t\tif (intf->altsetting->desc.bInterfaceNumber) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_mutex;\n\t\t}\n\t\tretval = set_altsetting(dev, dev->info->alt);\n\t\tif (retval) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"set altsetting to %d failed, %d\\n\",\n\t\t\t\t\tdev->info->alt, retval);\n\t\t\tgoto free_mutex;\n\t\t}\n\t}\n\n\tswitch (code) {\n\tcase USBTEST_REQUEST_64:\n\t\ttemp.test_num = param_64->test_num;\n\t\ttemp.iterations = param_64->iterations;\n\t\ttemp.length = param_64->length;\n\t\ttemp.sglen = param_64->sglen;\n\t\ttemp.vary = param_64->vary;\n\t\tparam_32 = &temp;\n\t\tbreak;\n\n\tcase USBTEST_REQUEST_32:\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EOPNOTSUPP;\n\t\tgoto free_mutex;\n\t}\n\n\tktime_get_ts64(&start);\n\n\tretval = usbtest_do_ioctl(intf, param_32);\n\tif (retval < 0)\n\t\tgoto free_mutex;\n\n\tktime_get_ts64(&end);\n\n\tduration = timespec64_sub(end, start);\n\n\ttemp.duration_sec = duration.tv_sec;\n\ttemp.duration_usec = duration.tv_nsec/NSEC_PER_USEC;\n\n\tswitch (code) {\n\tcase USBTEST_REQUEST_32:\n\t\tparam_32->duration_sec = temp.duration_sec;\n\t\tparam_32->duration_usec = temp.duration_usec;\n\t\tbreak;\n\n\tcase USBTEST_REQUEST_64:\n\t\tparam_64->duration_sec = temp.duration_sec;\n\t\tparam_64->duration_usec = temp.duration_usec;\n\t\tbreak;\n\t}\n\nfree_mutex:\n\tmutex_unlock(&dev->lock);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic unsigned force_interrupt;\nmodule_param(force_interrupt, uint, 0);\nMODULE_PARM_DESC(force_interrupt, \"0 = test default; else interrupt\");\n\n#ifdef\tGENERIC\nstatic unsigned short vendor;\nmodule_param(vendor, ushort, 0);\nMODULE_PARM_DESC(vendor, \"vendor code (from usb-if)\");\n\nstatic unsigned short product;\nmodule_param(product, ushort, 0);\nMODULE_PARM_DESC(product, \"product code (from vendor)\");\n#endif\n\nstatic int\nusbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device\t*udev;\n\tstruct usbtest_dev\t*dev;\n\tstruct usbtest_info\t*info;\n\tchar\t\t\t*rtest, *wtest;\n\tchar\t\t\t*irtest, *iwtest;\n\tchar\t\t\t*intrtest, *intwtest;\n\n\tudev = interface_to_usbdev(intf);\n\n#ifdef\tGENERIC\n\t/* specify devices by module parameters? */\n\tif (id->match_flags == 0) {\n\t\t/* vendor match required, product match optional */\n\t\tif (!vendor || le16_to_cpu(udev->descriptor.idVendor) != (u16)vendor)\n\t\t\treturn -ENODEV;\n\t\tif (product && le16_to_cpu(udev->descriptor.idProduct) != (u16)product)\n\t\t\treturn -ENODEV;\n\t\tdev_info(&intf->dev, \"matched module params, \"\n\t\t\t\t\t\"vend=0x%04x prod=0x%04x\\n\",\n\t\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct));\n\t}\n#endif\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tinfo = (struct usbtest_info *) id->driver_info;\n\tdev->info = info;\n\tmutex_init(&dev->lock);\n\n\tdev->intf = intf;\n\n\t/* cacheline-aligned scratch for i/o */\n\tdev->buf = kmalloc(TBUF_SIZE, GFP_KERNEL);\n\tif (dev->buf == NULL) {\n\t\tkfree(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* NOTE this doesn't yet test the handful of difference that are\n\t * visible with high speed interrupts:  bigger maxpacket (1K) and\n\t * \"high bandwidth\" modes (up to 3 packets/uframe).\n\t */\n\trtest = wtest = \"\";\n\tirtest = iwtest = \"\";\n\tintrtest = intwtest = \"\";\n\tif (force_interrupt || udev->speed == USB_SPEED_LOW) {\n\t\tif (info->ep_in) {\n\t\t\tdev->in_pipe = usb_rcvintpipe(udev, info->ep_in);\n\t\t\trtest = \" intr-in\";\n\t\t}\n\t\tif (info->ep_out) {\n\t\t\tdev->out_pipe = usb_sndintpipe(udev, info->ep_out);\n\t\t\twtest = \" intr-out\";\n\t\t}\n\t} else {\n\t\tif (override_alt >= 0 || info->autoconf) {\n\t\t\tint status;\n\n\t\t\tstatus = get_endpoints(dev, intf);\n\t\t\tif (status < 0) {\n\t\t\t\tWARNING(dev, \"couldn't get endpoints, %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t\t\tkfree(dev->buf);\n\t\t\t\tkfree(dev);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\t/* may find bulk or ISO pipes */\n\t\t} else {\n\t\t\tif (info->ep_in)\n\t\t\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t\t\tinfo->ep_in);\n\t\t\tif (info->ep_out)\n\t\t\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t\t\tinfo->ep_out);\n\t\t}\n\t\tif (dev->in_pipe)\n\t\t\trtest = \" bulk-in\";\n\t\tif (dev->out_pipe)\n\t\t\twtest = \" bulk-out\";\n\t\tif (dev->in_iso_pipe)\n\t\t\tirtest = \" iso-in\";\n\t\tif (dev->out_iso_pipe)\n\t\t\tiwtest = \" iso-out\";\n\t\tif (dev->in_int_pipe)\n\t\t\tintrtest = \" int-in\";\n\t\tif (dev->out_int_pipe)\n\t\t\tintwtest = \" int-out\";\n\t}\n\n\tusb_set_intfdata(intf, dev);\n\tdev_info(&intf->dev, \"%s\\n\", info->name);\n\tdev_info(&intf->dev, \"%s {control%s%s%s%s%s%s%s} tests%s\\n\",\n\t\t\tusb_speed_string(udev->speed),\n\t\t\tinfo->ctrl_out ? \" in/out\" : \"\",\n\t\t\trtest, wtest,\n\t\t\tirtest, iwtest,\n\t\t\tintrtest, intwtest,\n\t\t\tinfo->alt >= 0 ? \" (+alt)\" : \"\");\n\treturn 0;\n}\n\nstatic int usbtest_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int usbtest_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\n\nstatic void usbtest_disconnect(struct usb_interface *intf)\n{\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tdev_dbg(&intf->dev, \"disconnect\\n\");\n\tkfree(dev);\n}\n\n/* Basic testing only needs a device that can source or sink bulk traffic.\n * Any device can test control transfers (default with GENERIC binding).\n *\n * Several entries work with the default EP0 implementation that's built\n * into EZ-USB chips.  There's a default vendor ID which can be overridden\n * by (very) small config EEPROMS, but otherwise all these devices act\n * identically until firmware is loaded:  only EP0 works.  It turns out\n * to be easy to make other endpoints work, without modifying that EP0\n * behavior.  For now, we expect that kind of firmware.\n */\n\n/* an21xx or fx versions of ez-usb */\nstatic struct usbtest_info ez1_info = {\n\t.name\t\t= \"EZ-USB device\",\n\t.ep_in\t\t= 2,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n};\n\n/* fx2 version of ez-usb */\nstatic struct usbtest_info ez2_info = {\n\t.name\t\t= \"FX2 device\",\n\t.ep_in\t\t= 6,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n};\n\n/* ezusb family device with dedicated usb test firmware,\n */\nstatic struct usbtest_info fw_info = {\n\t.name\t\t= \"usb test device\",\n\t.ep_in\t\t= 2,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n\t.autoconf\t= 1,\t\t/* iso and ctrl_out need autoconf */\n\t.ctrl_out\t= 1,\n\t.iso\t\t= 1,\t\t/* iso_ep's are #8 in/out */\n};\n\n/* peripheral running Linux and 'zero.c' test firmware, or\n * its user-mode cousin. different versions of this use\n * different hardware with the same vendor/product codes.\n * host side MUST rely on the endpoint descriptors.\n */\nstatic struct usbtest_info gz_info = {\n\t.name\t\t= \"Linux gadget zero\",\n\t.autoconf\t= 1,\n\t.ctrl_out\t= 1,\n\t.iso\t\t= 1,\n\t.intr\t\t= 1,\n\t.alt\t\t= 0,\n};\n\nstatic struct usbtest_info um_info = {\n\t.name\t\t= \"Linux user mode test driver\",\n\t.autoconf\t= 1,\n\t.alt\t\t= -1,\n};\n\nstatic struct usbtest_info um2_info = {\n\t.name\t\t= \"Linux user mode ISO test driver\",\n\t.autoconf\t= 1,\n\t.iso\t\t= 1,\n\t.alt\t\t= -1,\n};\n\n#ifdef IBOT2\n/* this is a nice source of high speed bulk data;\n * uses an FX2, with firmware provided in the device\n */\nstatic struct usbtest_info ibot2_info = {\n\t.name\t\t= \"iBOT2 webcam\",\n\t.ep_in\t\t= 2,\n\t.alt\t\t= -1,\n};\n#endif\n\n#ifdef GENERIC\n/* we can use any device to test control traffic */\nstatic struct usbtest_info generic_info = {\n\t.name\t\t= \"Generic USB device\",\n\t.alt\t\t= -1,\n};\n#endif\n\n\nstatic const struct usb_device_id id_table[] = {\n\n\t/*-------------------------------------------------------------*/\n\n\t/* EZ-USB devices which download firmware to replace (or in our\n\t * case augment) the default device implementation.\n\t */\n\n\t/* generic EZ-USB FX controller */\n\t{ USB_DEVICE(0x0547, 0x2235),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n\n\t/* CY3671 development board with EZ-USB FX */\n\t{ USB_DEVICE(0x0547, 0x0080),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n\n\t/* generic EZ-USB FX2 controller (or development board) */\n\t{ USB_DEVICE(0x04b4, 0x8613),\n\t\t.driver_info = (unsigned long) &ez2_info,\n\t},\n\n\t/* re-enumerated usb test device firmware */\n\t{ USB_DEVICE(0xfff0, 0xfff0),\n\t\t.driver_info = (unsigned long) &fw_info,\n\t},\n\n\t/* \"Gadget Zero\" firmware runs under Linux */\n\t{ USB_DEVICE(0x0525, 0xa4a0),\n\t\t.driver_info = (unsigned long) &gz_info,\n\t},\n\n\t/* so does a user-mode variant */\n\t{ USB_DEVICE(0x0525, 0xa4a4),\n\t\t.driver_info = (unsigned long) &um_info,\n\t},\n\n\t/* ... and a user-mode variant that talks iso */\n\t{ USB_DEVICE(0x0525, 0xa4a3),\n\t\t.driver_info = (unsigned long) &um2_info,\n\t},\n\n#ifdef KEYSPAN_19Qi\n\t/* Keyspan 19qi uses an21xx (original EZ-USB) */\n\t/* this does not coexist with the real Keyspan 19qi driver! */\n\t{ USB_DEVICE(0x06cd, 0x010b),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n#endif\n\n\t/*-------------------------------------------------------------*/\n\n#ifdef IBOT2\n\t/* iBOT2 makes a nice source of high speed bulk-in data */\n\t/* this does not coexist with a real iBOT2 driver! */\n\t{ USB_DEVICE(0x0b62, 0x0059),\n\t\t.driver_info = (unsigned long) &ibot2_info,\n\t},\n#endif\n\n\t/*-------------------------------------------------------------*/\n\n#ifdef GENERIC\n\t/* module params can specify devices to use for control tests */\n\t{ .driver_info = (unsigned long) &generic_info, },\n#endif\n\n\t/*-------------------------------------------------------------*/\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver usbtest_driver = {\n\t.name =\t\t\"usbtest\",\n\t.id_table =\tid_table,\n\t.probe =\tusbtest_probe,\n\t.unlocked_ioctl = usbtest_ioctl,\n\t.disconnect =\tusbtest_disconnect,\n\t.suspend =\tusbtest_suspend,\n\t.resume =\tusbtest_resume,\n};\n\n/*-------------------------------------------------------------------------*/\n\nstatic int __init usbtest_init(void)\n{\n#ifdef GENERIC\n\tif (vendor)\n\t\tpr_debug(\"params: vend=0x%04x prod=0x%04x\\n\", vendor, product);\n#endif\n\treturn usb_register(&usbtest_driver);\n}\nmodule_init(usbtest_init);\n\nstatic void __exit usbtest_exit(void)\n{\n\tusb_deregister(&usbtest_driver);\n}\nmodule_exit(usbtest_exit);\n\nMODULE_DESCRIPTION(\"USB Core/HCD Testing Driver\");\nMODULE_LICENSE(\"GPL\");\n\n"], "fixing_code": ["#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/scatterlist.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n\n#define SIMPLE_IO_TIMEOUT\t10000\t/* in milliseconds */\n\n/*-------------------------------------------------------------------------*/\n\nstatic int override_alt = -1;\nmodule_param_named(alt, override_alt, int, 0644);\nMODULE_PARM_DESC(alt, \">= 0 to override altsetting selection\");\nstatic void complicated_callback(struct urb *urb);\n\n/*-------------------------------------------------------------------------*/\n\n/* FIXME make these public somewhere; usbdevfs.h? */\n\n/* Parameter for usbtest driver. */\nstruct usbtest_param_32 {\n\t/* inputs */\n\t__u32\t\ttest_num;\t/* 0..(TEST_CASES-1) */\n\t__u32\t\titerations;\n\t__u32\t\tlength;\n\t__u32\t\tvary;\n\t__u32\t\tsglen;\n\n\t/* outputs */\n\t__s32\t\tduration_sec;\n\t__s32\t\tduration_usec;\n};\n\n/*\n * Compat parameter to the usbtest driver.\n * This supports older user space binaries compiled with 64 bit compiler.\n */\nstruct usbtest_param_64 {\n\t/* inputs */\n\t__u32\t\ttest_num;\t/* 0..(TEST_CASES-1) */\n\t__u32\t\titerations;\n\t__u32\t\tlength;\n\t__u32\t\tvary;\n\t__u32\t\tsglen;\n\n\t/* outputs */\n\t__s64\t\tduration_sec;\n\t__s64\t\tduration_usec;\n};\n\n/* IOCTL interface to the driver. */\n#define USBTEST_REQUEST_32    _IOWR('U', 100, struct usbtest_param_32)\n/* COMPAT IOCTL interface to the driver. */\n#define USBTEST_REQUEST_64    _IOWR('U', 100, struct usbtest_param_64)\n\n/*-------------------------------------------------------------------------*/\n\n#define\tGENERIC\t\t/* let probe() bind using module params */\n\n/* Some devices that can be used for testing will have \"real\" drivers.\n * Entries for those need to be enabled here by hand, after disabling\n * that \"real\" driver.\n */\n//#define\tIBOT2\t\t/* grab iBOT2 webcams */\n//#define\tKEYSPAN_19Qi\t/* grab un-renumerated serial adapter */\n\n/*-------------------------------------------------------------------------*/\n\nstruct usbtest_info {\n\tconst char\t\t*name;\n\tu8\t\t\tep_in;\t\t/* bulk/intr source */\n\tu8\t\t\tep_out;\t\t/* bulk/intr sink */\n\tunsigned\t\tautoconf:1;\n\tunsigned\t\tctrl_out:1;\n\tunsigned\t\tiso:1;\t\t/* try iso in/out */\n\tunsigned\t\tintr:1;\t\t/* try interrupt in/out */\n\tint\t\t\talt;\n};\n\n/* this is accessed only through usbfs ioctl calls.\n * one ioctl to issue a test ... one lock per device.\n * tests create other threads if they need them.\n * urbs and buffers are allocated dynamically,\n * and data generated deterministically.\n */\nstruct usbtest_dev {\n\tstruct usb_interface\t*intf;\n\tstruct usbtest_info\t*info;\n\tint\t\t\tin_pipe;\n\tint\t\t\tout_pipe;\n\tint\t\t\tin_iso_pipe;\n\tint\t\t\tout_iso_pipe;\n\tint\t\t\tin_int_pipe;\n\tint\t\t\tout_int_pipe;\n\tstruct usb_endpoint_descriptor\t*iso_in, *iso_out;\n\tstruct usb_endpoint_descriptor\t*int_in, *int_out;\n\tstruct mutex\t\tlock;\n\n#define TBUF_SIZE\t256\n\tu8\t\t\t*buf;\n};\n\nstatic struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)\n{\n\treturn interface_to_usbdev(test->intf);\n}\n\n/* set up all urbs so they can be used with either bulk or interrupt */\n#define\tINTERRUPT_RATE\t\t1\t/* msec/transfer */\n\n#define ERROR(tdev, fmt, args...) \\\n\tdev_err(&(tdev)->intf->dev , fmt , ## args)\n#define WARNING(tdev, fmt, args...) \\\n\tdev_warn(&(tdev)->intf->dev , fmt , ## args)\n\n#define GUARD_BYTE\t0xA5\n#define MAX_SGLEN\t128\n\n/*-------------------------------------------------------------------------*/\n\nstatic inline void endpoint_update(int edi,\n\t\t\t\t   struct usb_host_endpoint **in,\n\t\t\t\t   struct usb_host_endpoint **out,\n\t\t\t\t   struct usb_host_endpoint *e)\n{\n\tif (edi) {\n\t\tif (!*in)\n\t\t\t*in = e;\n\t} else {\n\t\tif (!*out)\n\t\t\t*out = e;\n\t}\n}\n\nstatic int\nget_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (in)\n\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tif (out)\n\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\n\tif (iso_in) {\n\t\tdev->iso_in = &iso_in->desc;\n\t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* Support for testing basic non-queued I/O streams.\n *\n * These just package urbs as requests that can be easily canceled.\n * Each urb's data buffer is dynamically allocated; callers can fill\n * them with non-zero test data (or test for it) when appropriate.\n */\n\nstatic void simple_callback(struct urb *urb)\n{\n\tcomplete(urb->context);\n}\n\nstatic struct urb *usbtest_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tunsigned\t\ttransfer_flags,\n\tunsigned\t\toffset,\n\tu8\t\t\tbInterval,\n\tusb_complete_t\t\tcomplete_fn)\n{\n\tstruct urb\t\t*urb;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn urb;\n\n\tif (bInterval)\n\t\tusb_fill_int_urb(urb, udev, pipe, NULL, bytes, complete_fn,\n\t\t\t\tNULL, bInterval);\n\telse\n\t\tusb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, complete_fn,\n\t\t\t\tNULL);\n\n\turb->interval = (udev->speed == USB_SPEED_HIGH)\n\t\t\t? (INTERRUPT_RATE << 3)\n\t\t\t: INTERRUPT_RATE;\n\turb->transfer_flags = transfer_flags;\n\tif (usb_pipein(pipe))\n\t\turb->transfer_flags |= URB_SHORT_NOT_OK;\n\n\tif ((bytes + offset) == 0)\n\t\treturn urb;\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\turb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,\n\t\t\tGFP_KERNEL, &urb->transfer_dma);\n\telse\n\t\turb->transfer_buffer = kmalloc(bytes + offset, GFP_KERNEL);\n\n\tif (!urb->transfer_buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\t/* To test unaligned transfers add an offset and fill the\n\t\tunused memory with a guard value */\n\tif (offset) {\n\t\tmemset(urb->transfer_buffer, GUARD_BYTE, offset);\n\t\turb->transfer_buffer += offset;\n\t\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\turb->transfer_dma += offset;\n\t}\n\n\t/* For inbound transfers use guard byte so that test fails if\n\t\tdata not correctly copied */\n\tmemset(urb->transfer_buffer,\n\t\t\tusb_pipein(urb->pipe) ? GUARD_BYTE : 0,\n\t\t\tbytes);\n\treturn urb;\n}\n\nstatic struct urb *simple_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tu8\t\t\tbInterval)\n{\n\treturn usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,\n\t\t\tbInterval, simple_callback);\n}\n\nstatic struct urb *complicated_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tu8\t\t\tbInterval)\n{\n\treturn usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,\n\t\t\tbInterval, complicated_callback);\n}\n\nstatic unsigned pattern;\nstatic unsigned mod_pattern;\nmodule_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(mod_pattern, \"i/o pattern (0 == zeroes)\");\n\nstatic unsigned get_maxpacket(struct usb_device *udev, int pipe)\n{\n\tstruct usb_host_endpoint\t*ep;\n\n\tep = usb_pipe_endpoint(udev, pipe);\n\treturn le16_to_cpup(&ep->desc.wMaxPacketSize);\n}\n\nstatic void simple_fill_buf(struct urb *urb)\n{\n\tunsigned\ti;\n\tu8\t\t*buf = urb->transfer_buffer;\n\tunsigned\tlen = urb->transfer_buffer_length;\n\tunsigned\tmaxpacket;\n\n\tswitch (pattern) {\n\tdefault:\n\t\t/* FALLTHROUGH */\n\tcase 0:\n\t\tmemset(buf, 0, len);\n\t\tbreak;\n\tcase 1:\t\t\t/* mod63 */\n\t\tmaxpacket = get_maxpacket(urb->dev, urb->pipe);\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*buf++ = (u8) ((i % maxpacket) % 63);\n\t\tbreak;\n\t}\n}\n\nstatic inline unsigned long buffer_offset(void *buf)\n{\n\treturn (unsigned long)buf & (ARCH_KMALLOC_MINALIGN - 1);\n}\n\nstatic int check_guard_bytes(struct usbtest_dev *tdev, struct urb *urb)\n{\n\tu8 *buf = urb->transfer_buffer;\n\tu8 *guard = buf - buffer_offset(buf);\n\tunsigned i;\n\n\tfor (i = 0; guard < buf; i++, guard++) {\n\t\tif (*guard != GUARD_BYTE) {\n\t\t\tERROR(tdev, \"guard byte[%d] %d (not %d)\\n\",\n\t\t\t\ti, *guard, GUARD_BYTE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)\n{\n\tunsigned\ti;\n\tu8\t\texpected;\n\tu8\t\t*buf = urb->transfer_buffer;\n\tunsigned\tlen = urb->actual_length;\n\tunsigned\tmaxpacket = get_maxpacket(urb->dev, urb->pipe);\n\n\tint ret = check_guard_bytes(tdev, urb);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++, buf++) {\n\t\tswitch (pattern) {\n\t\t/* all-zeroes has no synchronization issues */\n\t\tcase 0:\n\t\t\texpected = 0;\n\t\t\tbreak;\n\t\t/* mod63 stays in sync with short-terminated transfers,\n\t\t * or otherwise when host and gadget agree on how large\n\t\t * each usb transfer request should be.  resync is done\n\t\t * with set_interface or set_config.\n\t\t */\n\t\tcase 1:\t\t\t/* mod63 */\n\t\t\texpected = (i % maxpacket) % 63;\n\t\t\tbreak;\n\t\t/* always fail unsupported patterns */\n\t\tdefault:\n\t\t\texpected = !*buf;\n\t\t\tbreak;\n\t\t}\n\t\tif (*buf == expected)\n\t\t\tcontinue;\n\t\tERROR(tdev, \"buf[%d] = %d (not %d)\\n\", i, *buf, expected);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void simple_free_urb(struct urb *urb)\n{\n\tunsigned long offset = buffer_offset(urb->transfer_buffer);\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\tusb_free_coherent(\n\t\t\turb->dev,\n\t\t\turb->transfer_buffer_length + offset,\n\t\t\turb->transfer_buffer - offset,\n\t\t\turb->transfer_dma - offset);\n\telse\n\t\tkfree(urb->transfer_buffer - offset);\n\tusb_free_urb(urb);\n}\n\nstatic int simple_io(\n\tstruct usbtest_dev\t*tdev,\n\tstruct urb\t\t*urb,\n\tint\t\t\titerations,\n\tint\t\t\tvary,\n\tint\t\t\texpected,\n\tconst char\t\t*label\n)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tmax = urb->transfer_buffer_length;\n\tstruct completion\tcompletion;\n\tint\t\t\tretval = 0;\n\tunsigned long\t\texpire;\n\n\turb->context = &completion;\n\twhile (retval == 0 && iterations-- > 0) {\n\t\tinit_completion(&completion);\n\t\tif (usb_pipeout(urb->pipe)) {\n\t\t\tsimple_fill_buf(urb);\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (retval != 0)\n\t\t\tbreak;\n\n\t\texpire = msecs_to_jiffies(SIMPLE_IO_TIMEOUT);\n\t\tif (!wait_for_completion_timeout(&completion, expire)) {\n\t\t\tusb_kill_urb(urb);\n\t\t\tretval = (urb->status == -ENOENT ?\n\t\t\t\t  -ETIMEDOUT : urb->status);\n\t\t} else {\n\t\t\tretval = urb->status;\n\t\t}\n\n\t\turb->dev = udev;\n\t\tif (retval == 0 && usb_pipein(urb->pipe))\n\t\t\tretval = simple_check_buf(tdev, urb);\n\n\t\tif (vary) {\n\t\t\tint\tlen = urb->transfer_buffer_length;\n\n\t\t\tlen += vary;\n\t\t\tlen %= max;\n\t\t\tif (len == 0)\n\t\t\t\tlen = (vary < max) ? vary : max;\n\t\t\turb->transfer_buffer_length = len;\n\t\t}\n\n\t\t/* FIXME if endpoint halted, clear halt (and log) */\n\t}\n\turb->transfer_buffer_length = max;\n\n\tif (expected != retval)\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s failed, iterations left %d, status %d (not %d)\\n\",\n\t\t\t\tlabel, iterations, retval, expected);\n\treturn retval;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* We use scatterlist primitives to test queued I/O.\n * Yes, this also tests the scatterlist primitives.\n */\n\nstatic void free_sglist(struct scatterlist *sg, int nents)\n{\n\tunsigned\t\ti;\n\n\tif (!sg)\n\t\treturn;\n\tfor (i = 0; i < nents; i++) {\n\t\tif (!sg_page(&sg[i]))\n\t\t\tcontinue;\n\t\tkfree(sg_virt(&sg[i]));\n\t}\n\tkfree(sg);\n}\n\nstatic struct scatterlist *\nalloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)\n{\n\tstruct scatterlist\t*sg;\n\tunsigned int\t\tn_size = 0;\n\tunsigned\t\ti;\n\tunsigned\t\tsize = max;\n\tunsigned\t\tmaxpacket =\n\t\tget_maxpacket(interface_to_usbdev(dev->intf), pipe);\n\n\tif (max == 0)\n\t\treturn NULL;\n\n\tsg = kmalloc_array(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\treturn NULL;\n\tsg_init_table(sg, nents);\n\n\tfor (i = 0; i < nents; i++) {\n\t\tchar\t\t*buf;\n\t\tunsigned\tj;\n\n\t\tbuf = kzalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tfree_sglist(sg, i);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* kmalloc pages are always physically contiguous! */\n\t\tsg_set_buf(&sg[i], buf, size);\n\n\t\tswitch (pattern) {\n\t\tcase 0:\n\t\t\t/* already zeroed */\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t\t*buf++ = (u8) (((j + n_size) % maxpacket) % 63);\n\t\t\tn_size += size;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vary) {\n\t\t\tsize += vary;\n\t\t\tsize %= max;\n\t\t\tif (size == 0)\n\t\t\t\tsize = (vary < max) ? vary : max;\n\t\t}\n\t}\n\n\treturn sg;\n}\n\nstatic void sg_timeout(unsigned long _req)\n{\n\tstruct usb_sg_request\t*req = (struct usb_sg_request *) _req;\n\n\tusb_sg_cancel(req);\n}\n\nstatic int perform_sglist(\n\tstruct usbtest_dev\t*tdev,\n\tunsigned\t\titerations,\n\tint\t\t\tpipe,\n\tstruct usb_sg_request\t*req,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents\n)\n{\n\tstruct usb_device\t*udev = testdev_to_usbdev(tdev);\n\tint\t\t\tretval = 0;\n\tstruct timer_list\tsg_timer;\n\n\tsetup_timer_on_stack(&sg_timer, sg_timeout, (unsigned long) req);\n\n\twhile (retval == 0 && iterations-- > 0) {\n\t\tretval = usb_sg_init(req, udev, pipe,\n\t\t\t\t(udev->speed == USB_SPEED_HIGH)\n\t\t\t\t\t? (INTERRUPT_RATE << 3)\n\t\t\t\t\t: INTERRUPT_RATE,\n\t\t\t\tsg, nents, 0, GFP_KERNEL);\n\n\t\tif (retval)\n\t\t\tbreak;\n\t\tmod_timer(&sg_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(SIMPLE_IO_TIMEOUT));\n\t\tusb_sg_wait(req);\n\t\tif (!del_timer_sync(&sg_timer))\n\t\t\tretval = -ETIMEDOUT;\n\t\telse\n\t\t\tretval = req->status;\n\n\t\t/* FIXME check resulting data pattern */\n\n\t\t/* FIXME if endpoint halted, clear halt (and log) */\n\t}\n\n\t/* FIXME for unlink or fault handling tests, don't report\n\t * failure if retval is as we expected ...\n\t */\n\tif (retval)\n\t\tERROR(tdev, \"perform_sglist failed, \"\n\t\t\t\t\"iterations left %d, status %d\\n\",\n\t\t\t\titerations, retval);\n\treturn retval;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* unqueued control message testing\n *\n * there's a nice set of device functional requirements in chapter 9 of the\n * usb 2.0 spec, which we can apply to ANY device, even ones that don't use\n * special test firmware.\n *\n * we know the device is configured (or suspended) by the time it's visible\n * through usbfs.  we can't change that, so we won't test enumeration (which\n * worked 'well enough' to get here, this time), power management (ditto),\n * or remote wakeup (which needs human interaction).\n */\n\nstatic unsigned realworld = 1;\nmodule_param(realworld, uint, 0);\nMODULE_PARM_DESC(realworld, \"clear to demand stricter spec compliance\");\n\nstatic int get_altsetting(struct usbtest_dev *dev)\n{\n\tstruct usb_interface\t*iface = dev->intf;\n\tstruct usb_device\t*udev = interface_to_usbdev(iface);\n\tint\t\t\tretval;\n\n\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\tUSB_REQ_GET_INTERFACE, USB_DIR_IN|USB_RECIP_INTERFACE,\n\t\t\t0, iface->altsetting[0].desc.bInterfaceNumber,\n\t\t\tdev->buf, 1, USB_CTRL_GET_TIMEOUT);\n\tswitch (retval) {\n\tcase 1:\n\t\treturn dev->buf[0];\n\tcase 0:\n\t\tretval = -ERANGE;\n\t\t/* FALLTHROUGH */\n\tdefault:\n\t\treturn retval;\n\t}\n}\n\nstatic int set_altsetting(struct usbtest_dev *dev, int alternate)\n{\n\tstruct usb_interface\t\t*iface = dev->intf;\n\tstruct usb_device\t\t*udev;\n\n\tif (alternate < 0 || alternate >= 256)\n\t\treturn -EINVAL;\n\n\tudev = interface_to_usbdev(iface);\n\treturn usb_set_interface(udev,\n\t\t\tiface->altsetting[0].desc.bInterfaceNumber,\n\t\t\talternate);\n}\n\nstatic int is_good_config(struct usbtest_dev *tdev, int len)\n{\n\tstruct usb_config_descriptor\t*config;\n\n\tif (len < sizeof(*config))\n\t\treturn 0;\n\tconfig = (struct usb_config_descriptor *) tdev->buf;\n\n\tswitch (config->bDescriptorType) {\n\tcase USB_DT_CONFIG:\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\tif (config->bLength != 9) {\n\t\t\tERROR(tdev, \"bogus config descriptor length\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t/* this bit 'must be 1' but often isn't */\n\t\tif (!realworld && !(config->bmAttributes & 0x80)) {\n\t\t\tERROR(tdev, \"high bit of config attributes not set\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (config->bmAttributes & 0x1f) {\t/* reserved == 0 */\n\t\t\tERROR(tdev, \"reserved config bits set\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(config->wTotalLength) == len)\t/* read it all */\n\t\treturn 1;\n\tif (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)\t/* max partial read */\n\t\treturn 1;\n\tERROR(tdev, \"bogus config descriptor read size\\n\");\n\treturn 0;\n}\n\nstatic int is_good_ext(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ext_cap_descriptor *ext;\n\tu32 attr;\n\n\text = (struct usb_ext_cap_descriptor *) buf;\n\n\tif (ext->bLength != USB_DT_USB_EXT_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus usb 2.0 extension descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\tattr = le32_to_cpu(ext->bmAttributes);\n\t/* bits[1:15] is used and others are reserved */\n\tif (attr & ~0xfffe) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_cap_descriptor *ss;\n\n\tss = (struct usb_ss_cap_descriptor *) buf;\n\n\tif (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus superspeed device capability descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * only bit[1] of bmAttributes is used for LTM and others are\n\t * reserved\n\t */\n\tif (ss->bmAttributes & ~0x02) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in bmAttributes\\n\");\n\t\treturn 0;\n\t}\n\n\t/* bits[0:3] of wSpeedSupported is used and others are reserved */\n\tif (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set in wSpeedSupported\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_good_con_id(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_container_id_descriptor *con_id;\n\n\tcon_id = (struct usb_ss_container_id_descriptor *) buf;\n\n\tif (con_id->bLength != USB_DT_USB_SS_CONTN_ID_SIZE) {\n\t\tERROR(tdev, \"bogus container id descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\tif (con_id->bReserved) {\t/* reserved == 0 */\n\t\tERROR(tdev, \"reserved bits set\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* sanity test for standard requests working with usb_control_mesg() and some\n * of the utility functions which use it.\n *\n * this doesn't test how endpoint halts behave or data toggles get set, since\n * we won't do I/O to bulk/interrupt endpoints here (which is how to change\n * halt or toggle).  toggle testing is impractical without support from hcds.\n *\n * this avoids failing devices linux would normally work with, by not testing\n * config/altsetting operations for devices that only support their defaults.\n * such devices rarely support those needless operations.\n *\n * NOTE that since this is a sanity test, it's not examining boundary cases\n * to see if usbcore, hcd, and device all behave right.  such testing would\n * involve varied read sizes and other operation sequences.\n */\nstatic int ch9_postconfig(struct usbtest_dev *dev)\n{\n\tstruct usb_interface\t*iface = dev->intf;\n\tstruct usb_device\t*udev = interface_to_usbdev(iface);\n\tint\t\t\ti, alt, retval;\n\n\t/* [9.2.3] if there's more than one altsetting, we need to be able to\n\t * set and get each one.  mostly trusts the descriptors from usbcore.\n\t */\n\tfor (i = 0; i < iface->num_altsetting; i++) {\n\n\t\t/* 9.2.3 constrains the range here */\n\t\talt = iface->altsetting[i].desc.bAlternateSetting;\n\t\tif (alt < 0 || alt >= iface->num_altsetting) {\n\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\"invalid alt [%d].bAltSetting = %d\\n\",\n\t\t\t\t\ti, alt);\n\t\t}\n\n\t\t/* [real world] get/set unimplemented if there's only one */\n\t\tif (realworld && iface->num_altsetting == 1)\n\t\t\tcontinue;\n\n\t\t/* [9.4.10] set_interface */\n\t\tretval = set_altsetting(dev, alt);\n\t\tif (retval) {\n\t\t\tdev_err(&iface->dev, \"can't set_interface = %d, %d\\n\",\n\t\t\t\t\talt, retval);\n\t\t\treturn retval;\n\t\t}\n\n\t\t/* [9.4.4] get_interface always works */\n\t\tretval = get_altsetting(dev);\n\t\tif (retval != alt) {\n\t\t\tdev_err(&iface->dev, \"get alt should be %d, was %d\\n\",\n\t\t\t\t\talt, retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t}\n\n\t/* [real world] get_config unimplemented if there's only one */\n\tif (!realworld || udev->descriptor.bNumConfigurations != 1) {\n\t\tint\texpected = udev->actconfig->desc.bConfigurationValue;\n\n\t\t/* [9.4.2] get_configuration always works\n\t\t * ... although some cheap devices (like one TI Hub I've got)\n\t\t * won't return config descriptors except before set_config.\n\t\t */\n\t\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_GET_CONFIGURATION,\n\t\t\t\tUSB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);\n\t\tif (retval != 1 || dev->buf[0] != expected) {\n\t\t\tdev_err(&iface->dev, \"get config --> %d %d (1 %d)\\n\",\n\t\t\t\tretval, dev->buf[0], expected);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\t}\n\n\t/* there's always [9.4.3] a device descriptor [9.6.1] */\n\tretval = usb_get_descriptor(udev, USB_DT_DEVICE, 0,\n\t\t\tdev->buf, sizeof(udev->descriptor));\n\tif (retval != sizeof(udev->descriptor)) {\n\t\tdev_err(&iface->dev, \"dev descriptor --> %d\\n\", retval);\n\t\treturn (retval < 0) ? retval : -EDOM;\n\t}\n\n\t/*\n\t * there's always [9.4.3] a bos device descriptor [9.6.2] in USB\n\t * 3.0 spec\n\t */\n\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0210) {\n\t\tstruct usb_bos_descriptor *bos = NULL;\n\t\tstruct usb_dev_cap_header *header = NULL;\n\t\tunsigned total, num, length;\n\t\tu8 *buf;\n\n\t\tretval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,\n\t\t\t\tsizeof(*udev->bos->desc));\n\t\tif (retval != sizeof(*udev->bos->desc)) {\n\t\t\tdev_err(&iface->dev, \"bos descriptor --> %d\\n\", retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\tbos = (struct usb_bos_descriptor *)dev->buf;\n\t\ttotal = le16_to_cpu(bos->wTotalLength);\n\t\tnum = bos->bNumDeviceCaps;\n\n\t\tif (total > TBUF_SIZE)\n\t\t\ttotal = TBUF_SIZE;\n\n\t\t/*\n\t\t * get generic device-level capability descriptors [9.6.2]\n\t\t * in USB 3.0 spec\n\t\t */\n\t\tretval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,\n\t\t\t\ttotal);\n\t\tif (retval != total) {\n\t\t\tdev_err(&iface->dev, \"bos descriptor set --> %d\\n\",\n\t\t\t\t\tretval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\tlength = sizeof(*udev->bos->desc);\n\t\tbuf = dev->buf;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tbuf += length;\n\t\t\tif (buf + sizeof(struct usb_dev_cap_header) >\n\t\t\t\t\tdev->buf + total)\n\t\t\t\tbreak;\n\n\t\t\theader = (struct usb_dev_cap_header *)buf;\n\t\t\tlength = header->bLength;\n\n\t\t\tif (header->bDescriptorType !=\n\t\t\t\t\tUSB_DT_DEVICE_CAPABILITY) {\n\t\t\t\tdev_warn(&udev->dev, \"not device capability descriptor, skip\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (header->bDevCapabilityType) {\n\t\t\tcase USB_CAP_TYPE_EXT:\n\t\t\t\tif (buf + USB_DT_USB_EXT_CAP_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_ext(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus usb 2.0 extension descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_SS_CAP_TYPE:\n\t\t\t\tif (buf + USB_DT_USB_SS_CAP_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_ss_cap(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus superspeed device capability descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CONTAINER_ID_TYPE:\n\t\t\t\tif (buf + USB_DT_USB_SS_CONTN_ID_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_con_id(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus container id descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* there's always [9.4.3] at least one config descriptor [9.6.3] */\n\tfor (i = 0; i < udev->descriptor.bNumConfigurations; i++) {\n\t\tretval = usb_get_descriptor(udev, USB_DT_CONFIG, i,\n\t\t\t\tdev->buf, TBUF_SIZE);\n\t\tif (!is_good_config(dev, retval)) {\n\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\"config [%d] descriptor --> %d\\n\",\n\t\t\t\t\ti, retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\t/* FIXME cross-checking udev->config[i] to make sure usbcore\n\t\t * parsed it right (etc) would be good testing paranoia\n\t\t */\n\t}\n\n\t/* and sometimes [9.2.6.6] speed dependent descriptors */\n\tif (le16_to_cpu(udev->descriptor.bcdUSB) == 0x0200) {\n\t\tstruct usb_qualifier_descriptor *d = NULL;\n\n\t\t/* device qualifier [9.6.2] */\n\t\tretval = usb_get_descriptor(udev,\n\t\t\t\tUSB_DT_DEVICE_QUALIFIER, 0, dev->buf,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\tif (retval == -EPIPE) {\n\t\t\tif (udev->speed == USB_SPEED_HIGH) {\n\t\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\t\"hs dev qualifier --> %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\t/* usb2.0 but not high-speed capable; fine */\n\t\t} else if (retval != sizeof(struct usb_qualifier_descriptor)) {\n\t\t\tdev_err(&iface->dev, \"dev qualifier --> %d\\n\", retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t} else\n\t\t\td = (struct usb_qualifier_descriptor *) dev->buf;\n\n\t\t/* might not have [9.6.2] any other-speed configs [9.6.4] */\n\t\tif (d) {\n\t\t\tunsigned max = d->bNumConfigurations;\n\t\t\tfor (i = 0; i < max; i++) {\n\t\t\t\tretval = usb_get_descriptor(udev,\n\t\t\t\t\tUSB_DT_OTHER_SPEED_CONFIG, i,\n\t\t\t\t\tdev->buf, TBUF_SIZE);\n\t\t\t\tif (!is_good_config(dev, retval)) {\n\t\t\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\t\"other speed config --> %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* FIXME fetch strings from at least the device descriptor */\n\n\t/* [9.4.5] get_status always works */\n\tretval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev->buf);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"get dev status --> %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t/* FIXME configuration.bmAttributes says if we could try to set/clear\n\t * the device's remote wakeup feature ... if we can, test that here\n\t */\n\n\tretval = usb_get_status(udev, USB_RECIP_INTERFACE,\n\t\t\tiface->altsetting[0].desc.bInterfaceNumber, dev->buf);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"get interface status --> %d\\n\", retval);\n\t\treturn retval;\n\t}\n\t/* FIXME get status for each endpoint in the interface */\n\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* use ch9 requests to test whether:\n *   (a) queues work for control, keeping N subtests queued and\n *       active (auto-resubmit) for M loops through the queue.\n *   (b) protocol stalls (control-only) will autorecover.\n *       it's not like bulk/intr; no halt clearing.\n *   (c) short control reads are reported and handled.\n *   (d) queues are always processed in-order\n */\n\nstruct ctrl_ctx {\n\tspinlock_t\t\tlock;\n\tstruct usbtest_dev\t*dev;\n\tstruct completion\tcomplete;\n\tunsigned\t\tcount;\n\tunsigned\t\tpending;\n\tint\t\t\tstatus;\n\tstruct urb\t\t**urb;\n\tstruct usbtest_param_32\t*param;\n\tint\t\t\tlast;\n};\n\n#define NUM_SUBCASES\t16\t\t/* how many test subcases here? */\n\nstruct subcase {\n\tstruct usb_ctrlrequest\tsetup;\n\tint\t\t\tnumber;\n\tint\t\t\texpected;\n};\n\nstatic void ctrl_complete(struct urb *urb)\n{\n\tstruct ctrl_ctx\t\t*ctx = urb->context;\n\tstruct usb_ctrlrequest\t*reqp;\n\tstruct subcase\t\t*subcase;\n\tint\t\t\tstatus = urb->status;\n\n\treqp = (struct usb_ctrlrequest *)urb->setup_packet;\n\tsubcase = container_of(reqp, struct subcase, setup);\n\n\tspin_lock(&ctx->lock);\n\tctx->count--;\n\tctx->pending--;\n\n\t/* queue must transfer and complete in fifo order, unless\n\t * usb_unlink_urb() is used to unlink something not at the\n\t * physical queue head (not tested).\n\t */\n\tif (subcase->number > 0) {\n\t\tif ((subcase->number - ctx->last) != 1) {\n\t\t\tERROR(ctx->dev,\n\t\t\t\t\"subcase %d completed out of order, last %d\\n\",\n\t\t\t\tsubcase->number, ctx->last);\n\t\t\tstatus = -EDOM;\n\t\t\tctx->last = subcase->number;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tctx->last = subcase->number;\n\n\t/* succeed or fault in only one way? */\n\tif (status == subcase->expected)\n\t\tstatus = 0;\n\n\t/* async unlink for cleanup? */\n\telse if (status != -ECONNRESET) {\n\n\t\t/* some faults are allowed, not required */\n\t\tif (subcase->expected > 0 && (\n\t\t\t  ((status == -subcase->expected\t/* happened */\n\t\t\t   || status == 0))))\t\t\t/* didn't */\n\t\t\tstatus = 0;\n\t\t/* sometimes more than one fault is allowed */\n\t\telse if (subcase->number == 12 && status == -EPIPE)\n\t\t\tstatus = 0;\n\t\telse\n\t\t\tERROR(ctx->dev, \"subtest %d error, status %d\\n\",\n\t\t\t\t\tsubcase->number, status);\n\t}\n\n\t/* unexpected status codes mean errors; ideally, in hardware */\n\tif (status) {\nerror:\n\t\tif (ctx->status == 0) {\n\t\t\tint\t\ti;\n\n\t\t\tctx->status = status;\n\t\t\tERROR(ctx->dev, \"control queue %02x.%02x, err %d, \"\n\t\t\t\t\t\"%d left, subcase %d, len %d/%d\\n\",\n\t\t\t\t\treqp->bRequestType, reqp->bRequest,\n\t\t\t\t\tstatus, ctx->count, subcase->number,\n\t\t\t\t\turb->actual_length,\n\t\t\t\t\turb->transfer_buffer_length);\n\n\t\t\t/* FIXME this \"unlink everything\" exit route should\n\t\t\t * be a separate test case.\n\t\t\t */\n\n\t\t\t/* unlink whatever's still pending */\n\t\t\tfor (i = 1; i < ctx->param->sglen; i++) {\n\t\t\t\tstruct urb *u = ctx->urb[\n\t\t\t\t\t\t\t(i + subcase->number)\n\t\t\t\t\t\t\t% ctx->param->sglen];\n\n\t\t\t\tif (u == urb || !u->dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&ctx->lock);\n\t\t\t\tstatus = usb_unlink_urb(u);\n\t\t\t\tspin_lock(&ctx->lock);\n\t\t\t\tswitch (status) {\n\t\t\t\tcase -EINPROGRESS:\n\t\t\t\tcase -EBUSY:\n\t\t\t\tcase -EIDRM:\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tERROR(ctx->dev, \"urb unlink --> %d\\n\",\n\t\t\t\t\t\t\tstatus);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatus = ctx->status;\n\t\t}\n\t}\n\n\t/* resubmit if we need to, else mark this as done */\n\tif ((status == 0) && (ctx->pending < ctx->count)) {\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (status != 0) {\n\t\t\tERROR(ctx->dev,\n\t\t\t\t\"can't resubmit ctrl %02x.%02x, err %d\\n\",\n\t\t\t\treqp->bRequestType, reqp->bRequest, status);\n\t\t\turb->dev = NULL;\n\t\t} else\n\t\t\tctx->pending++;\n\t} else\n\t\turb->dev = NULL;\n\n\t/* signal completion when nothing's queued */\n\tif (ctx->pending == 0)\n\t\tcomplete(&ctx->complete);\n\tspin_unlock(&ctx->lock);\n}\n\nstatic int\ntest_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param)\n{\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tstruct urb\t\t**urb;\n\tstruct ctrl_ctx\t\tcontext;\n\tint\t\t\ti;\n\n\tif (param->sglen == 0 || param->iterations > UINT_MAX / param->sglen)\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_init(&context.lock);\n\tcontext.dev = dev;\n\tinit_completion(&context.complete);\n\tcontext.count = param->sglen * param->iterations;\n\tcontext.pending = 0;\n\tcontext.status = -ENOMEM;\n\tcontext.param = param;\n\tcontext.last = -1;\n\n\t/* allocate and init the urbs we'll queue.\n\t * as with bulk/intr sglists, sglen is the queue depth; it also\n\t * controls which subtests run (more tests than sglen) or rerun.\n\t */\n\turb = kcalloc(param->sglen, sizeof(struct urb *), GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tint\t\t\tpipe = usb_rcvctrlpipe(udev, 0);\n\t\tunsigned\t\tlen;\n\t\tstruct urb\t\t*u;\n\t\tstruct usb_ctrlrequest\treq;\n\t\tstruct subcase\t\t*reqp;\n\n\t\t/* sign of this variable means:\n\t\t *  -: tested code must return this (negative) error code\n\t\t *  +: tested code may return this (negative too) error code\n\t\t */\n\t\tint\t\t\texpected = 0;\n\n\t\t/* requests here are mostly expected to succeed on any\n\t\t * device, but some are chosen to trigger protocol stalls\n\t\t * or short reads.\n\t\t */\n\t\tmemset(&req, 0, sizeof(req));\n\t\treq.bRequest = USB_REQ_GET_DESCRIPTOR;\n\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;\n\n\t\tswitch (i % NUM_SUBCASES) {\n\t\tcase 0:\t\t/* get device descriptor */\n\t\t\treq.wValue = cpu_to_le16(USB_DT_DEVICE << 8);\n\t\t\tlen = sizeof(struct usb_device_descriptor);\n\t\t\tbreak;\n\t\tcase 1:\t\t/* get first config descriptor (only) */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = sizeof(struct usb_config_descriptor);\n\t\t\tbreak;\n\t\tcase 2:\t\t/* get altsetting (OFTEN STALLS) */\n\t\t\treq.bRequest = USB_REQ_GET_INTERFACE;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;\n\t\t\t/* index = 0 means first interface */\n\t\t\tlen = 1;\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 3:\t\t/* get interface status */\n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;\n\t\t\t/* interface 0 */\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 4:\t\t/* get device status */\n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 5:\t\t/* get device qualifier (MAY STALL) */\n\t\t\treq.wValue = cpu_to_le16 (USB_DT_DEVICE_QUALIFIER << 8);\n\t\t\tlen = sizeof(struct usb_qualifier_descriptor);\n\t\t\tif (udev->speed != USB_SPEED_HIGH)\n\t\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 6:\t\t/* get first config descriptor, plus interface */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = sizeof(struct usb_config_descriptor);\n\t\t\tlen += sizeof(struct usb_interface_descriptor);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* get interface descriptor (ALWAYS STALLS) */\n\t\t\treq.wValue = cpu_to_le16 (USB_DT_INTERFACE << 8);\n\t\t\t/* interface == 0 */\n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\texpected = -EPIPE;\n\t\t\tbreak;\n\t\t/* NOTE: two consecutive stalls in the queue here.\n\t\t *  that tests fault recovery a bit more aggressively. */\n\t\tcase 8:\t\t/* clear endpoint halt (MAY STALL) */\n\t\t\treq.bRequest = USB_REQ_CLEAR_FEATURE;\n\t\t\treq.bRequestType = USB_RECIP_ENDPOINT;\n\t\t\t/* wValue 0 == ep halt */\n\t\t\t/* wIndex 0 == ep0 (shouldn't halt!) */\n\t\t\tlen = 0;\n\t\t\tpipe = usb_sndctrlpipe(udev, 0);\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 9:\t\t/* get endpoint status */\n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_ENDPOINT;\n\t\t\t/* endpoint 0 */\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 10:\t/* trigger short read (EREMOTEIO) */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = 1024;\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\t/* NOTE: two consecutive _different_ faults in the queue. */\n\t\tcase 11:\t/* get endpoint descriptor (ALWAYS STALLS) */\n\t\t\treq.wValue = cpu_to_le16(USB_DT_ENDPOINT << 8);\n\t\t\t/* endpoint == 0 */\n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\t/* NOTE: sometimes even a third fault in the queue! */\n\t\tcase 12:\t/* get string 0 descriptor (MAY STALL) */\n\t\t\treq.wValue = cpu_to_le16(USB_DT_STRING << 8);\n\t\t\t/* string == 0, for language IDs */\n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\t/* may succeed when > 4 languages */\n\t\t\texpected = EREMOTEIO;\t/* or EPIPE, if no strings */\n\t\t\tbreak;\n\t\tcase 13:\t/* short read, resembling case 10 */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\t/* last data packet \"should\" be DATA1, not DATA0 */\n\t\t\tif (udev->speed == USB_SPEED_SUPER)\n\t\t\t\tlen = 1024 - 512;\n\t\t\telse\n\t\t\t\tlen = 1024 - udev->descriptor.bMaxPacketSize0;\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\tcase 14:\t/* short read; try to fill the last packet */\n\t\t\treq.wValue = cpu_to_le16((USB_DT_DEVICE << 8) | 0);\n\t\t\t/* device descriptor size == 18 bytes */\n\t\t\tlen = udev->descriptor.bMaxPacketSize0;\n\t\t\tif (udev->speed == USB_SPEED_SUPER)\n\t\t\t\tlen = 512;\n\t\t\tswitch (len) {\n\t\t\tcase 8:\n\t\t\t\tlen = 24;\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tlen = 32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treq.wValue = cpu_to_le16(USB_DT_BOS << 8);\n\t\t\tif (udev->bos)\n\t\t\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\t\telse\n\t\t\t\tlen = sizeof(struct usb_bos_descriptor);\n\t\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) < 0x0201)\n\t\t\t\texpected = -EPIPE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(dev, \"bogus number of ctrl queue testcases!\\n\");\n\t\t\tcontext.status = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\treq.wLength = cpu_to_le16(len);\n\t\turb[i] = u = simple_alloc_urb(udev, pipe, len, 0);\n\t\tif (!u)\n\t\t\tgoto cleanup;\n\n\t\treqp = kmalloc(sizeof(*reqp), GFP_KERNEL);\n\t\tif (!reqp)\n\t\t\tgoto cleanup;\n\t\treqp->setup = req;\n\t\treqp->number = i % NUM_SUBCASES;\n\t\treqp->expected = expected;\n\t\tu->setup_packet = (char *) &reqp->setup;\n\n\t\tu->context = &context;\n\t\tu->complete = ctrl_complete;\n\t}\n\n\t/* queue the urbs */\n\tcontext.urb = urb;\n\tspin_lock_irq(&context.lock);\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tcontext.status = usb_submit_urb(urb[i], GFP_ATOMIC);\n\t\tif (context.status != 0) {\n\t\t\tERROR(dev, \"can't submit urb[%d], status %d\\n\",\n\t\t\t\t\ti, context.status);\n\t\t\tcontext.count = context.pending;\n\t\t\tbreak;\n\t\t}\n\t\tcontext.pending++;\n\t}\n\tspin_unlock_irq(&context.lock);\n\n\t/* FIXME  set timer and time out; provide a disconnect hook */\n\n\t/* wait for the last one to complete */\n\tif (context.pending > 0)\n\t\twait_for_completion(&context.complete);\n\ncleanup:\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (!urb[i])\n\t\t\tcontinue;\n\t\turb[i]->dev = udev;\n\t\tkfree(urb[i]->setup_packet);\n\t\tsimple_free_urb(urb[i]);\n\t}\n\tkfree(urb);\n\treturn context.status;\n}\n#undef NUM_SUBCASES\n\n\n/*-------------------------------------------------------------------------*/\n\nstatic void unlink1_callback(struct urb *urb)\n{\n\tint\tstatus = urb->status;\n\n\t/* we \"know\" -EPIPE (stall) never happens */\n\tif (!status)\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\turb->status = status;\n\t\tcomplete(urb->context);\n\t}\n}\n\nstatic int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)\n{\n\tstruct urb\t\t*urb;\n\tstruct completion\tcompletion;\n\tint\t\t\tretval = 0;\n\n\tinit_completion(&completion);\n\turb = simple_alloc_urb(testdev_to_usbdev(dev), pipe, size, 0);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\turb->context = &completion;\n\turb->complete = unlink1_callback;\n\n\tif (usb_pipeout(urb->pipe)) {\n\t\tsimple_fill_buf(urb);\n\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t}\n\n\t/* keep the endpoint busy.  there are lots of hc/hcd-internal\n\t * states, and testing should get to all of them over time.\n\t *\n\t * FIXME want additional tests for when endpoint is STALLing\n\t * due to errors, or is just NAKing requests.\n\t */\n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (retval != 0) {\n\t\tdev_err(&dev->intf->dev, \"submit fail %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t/* unlinking that should always work.  variable delay tests more\n\t * hcd states and code paths, even with little other system load.\n\t */\n\tmsleep(jiffies % (2 * INTERRUPT_RATE));\n\tif (async) {\n\t\twhile (!completion_done(&completion)) {\n\t\t\tretval = usb_unlink_urb(urb);\n\n\t\t\tif (retval == 0 && usb_pipein(urb->pipe))\n\t\t\t\tretval = simple_check_buf(dev, urb);\n\n\t\t\tswitch (retval) {\n\t\t\tcase -EBUSY:\n\t\t\tcase -EIDRM:\n\t\t\t\t/* we can't unlink urbs while they're completing\n\t\t\t\t * or if they've completed, and we haven't\n\t\t\t\t * resubmitted. \"normal\" drivers would prevent\n\t\t\t\t * resubmission, but since we're testing unlink\n\t\t\t\t * paths, we can't.\n\t\t\t\t */\n\t\t\t\tERROR(dev, \"unlink retry\\n\");\n\t\t\t\tcontinue;\n\t\t\tcase 0:\n\t\t\tcase -EINPROGRESS:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"unlink fail %d\\n\", retval);\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tusb_kill_urb(urb);\n\n\twait_for_completion(&completion);\n\tretval = urb->status;\n\tsimple_free_urb(urb);\n\n\tif (async)\n\t\treturn (retval == -ECONNRESET) ? 0 : retval - 1000;\n\telse\n\t\treturn (retval == -ENOENT || retval == -EPERM) ?\n\t\t\t\t0 : retval - 2000;\n}\n\nstatic int unlink_simple(struct usbtest_dev *dev, int pipe, int len)\n{\n\tint\t\t\tretval = 0;\n\n\t/* test sync and async paths */\n\tretval = unlink1(dev, pipe, len, 1);\n\tif (!retval)\n\t\tretval = unlink1(dev, pipe, len, 0);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstruct queued_ctx {\n\tstruct completion\tcomplete;\n\tatomic_t\t\tpending;\n\tunsigned\t\tnum;\n\tint\t\t\tstatus;\n\tstruct urb\t\t**urbs;\n};\n\nstatic void unlink_queued_callback(struct urb *urb)\n{\n\tint\t\t\tstatus = urb->status;\n\tstruct queued_ctx\t*ctx = urb->context;\n\n\tif (ctx->status)\n\t\tgoto done;\n\tif (urb == ctx->urbs[ctx->num - 4] || urb == ctx->urbs[ctx->num - 2]) {\n\t\tif (status == -ECONNRESET)\n\t\t\tgoto done;\n\t\t/* What error should we report if the URB completed normally? */\n\t}\n\tif (status != 0)\n\t\tctx->status = status;\n\n done:\n\tif (atomic_dec_and_test(&ctx->pending))\n\t\tcomplete(&ctx->complete);\n}\n\nstatic int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,\n\t\tunsigned size)\n{\n\tstruct queued_ctx\tctx;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tvoid\t\t\t*buf;\n\tdma_addr_t\t\tbuf_dma;\n\tint\t\t\ti;\n\tint\t\t\tretval = -ENOMEM;\n\n\tinit_completion(&ctx.complete);\n\tatomic_set(&ctx.pending, 1);\t/* One more than the actual value */\n\tctx.num = num;\n\tctx.status = 0;\n\n\tbuf = usb_alloc_coherent(udev, size, GFP_KERNEL, &buf_dma);\n\tif (!buf)\n\t\treturn retval;\n\tmemset(buf, 0, size);\n\n\t/* Allocate and init the urbs we'll queue */\n\tctx.urbs = kcalloc(num, sizeof(struct urb *), GFP_KERNEL);\n\tif (!ctx.urbs)\n\t\tgoto free_buf;\n\tfor (i = 0; i < num; i++) {\n\t\tctx.urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ctx.urbs[i])\n\t\t\tgoto free_urbs;\n\t\tusb_fill_bulk_urb(ctx.urbs[i], udev, pipe, buf, size,\n\t\t\t\tunlink_queued_callback, &ctx);\n\t\tctx.urbs[i]->transfer_dma = buf_dma;\n\t\tctx.urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\n\t\tif (usb_pipeout(ctx.urbs[i]->pipe)) {\n\t\t\tsimple_fill_buf(ctx.urbs[i]);\n\t\t\tctx.urbs[i]->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t}\n\n\t/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */\n\tfor (i = 0; i < num; i++) {\n\t\tatomic_inc(&ctx.pending);\n\t\tretval = usb_submit_urb(ctx.urbs[i], GFP_KERNEL);\n\t\tif (retval != 0) {\n\t\t\tdev_err(&dev->intf->dev, \"submit urbs[%d] fail %d\\n\",\n\t\t\t\t\ti, retval);\n\t\t\tatomic_dec(&ctx.pending);\n\t\t\tctx.status = retval;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == num) {\n\t\tusb_unlink_urb(ctx.urbs[num - 4]);\n\t\tusb_unlink_urb(ctx.urbs[num - 2]);\n\t} else {\n\t\twhile (--i >= 0)\n\t\t\tusb_unlink_urb(ctx.urbs[i]);\n\t}\n\n\tif (atomic_dec_and_test(&ctx.pending))\t\t/* The extra count */\n\t\tcomplete(&ctx.complete);\n\twait_for_completion(&ctx.complete);\n\tretval = ctx.status;\n\n free_urbs:\n\tfor (i = 0; i < num; i++)\n\t\tusb_free_urb(ctx.urbs[i]);\n\tkfree(ctx.urbs);\n free_buf:\n\tusb_free_coherent(udev, size, buf, buf_dma);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\tu16\tstatus;\n\n\t/* shouldn't look or act halted */\n\tretval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't get no-halt status, %d\\n\",\n\t\t\t\tep, retval);\n\t\treturn retval;\n\t}\n\tif (status != 0) {\n\t\tERROR(tdev, \"ep %02x bogus status: %04x != 0\\n\", ep, status);\n\t\treturn -EINVAL;\n\t}\n\tretval = simple_io(tdev, urb, 1, 0, 0, __func__);\n\tif (retval != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\tu16\tstatus;\n\n\t/* should look and act halted */\n\tretval = usb_get_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't get halt status, %d\\n\",\n\t\t\t\tep, retval);\n\t\treturn retval;\n\t}\n\tif (status != 1) {\n\t\tERROR(tdev, \"ep %02x bogus status: %04x != 1\\n\", ep, status);\n\t\treturn -EINVAL;\n\t}\n\tretval = simple_io(tdev, urb, 1, 0, -EPIPE, __func__);\n\tif (retval != -EPIPE)\n\t\treturn -EINVAL;\n\tretval = simple_io(tdev, urb, 1, 0, -EPIPE, \"verify_still_halted\");\n\tif (retval != -EPIPE)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\n\t/* shouldn't look or act halted now */\n\tretval = verify_not_halted(tdev, ep, urb);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/* set halt (protocol test only), verify it worked */\n\tretval = usb_control_msg(urb->dev, usb_sndctrlpipe(urb->dev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT,\n\t\t\tUSB_ENDPOINT_HALT, ep,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't set halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\tretval = verify_halted(tdev, ep, urb);\n\tif (retval < 0) {\n\t\tint ret;\n\n\t\t/* clear halt anyways, else further tests will fail */\n\t\tret = usb_clear_halt(urb->dev, urb->pipe);\n\t\tif (ret)\n\t\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\",\n\t\t\t      ep, ret);\n\n\t\treturn retval;\n\t}\n\n\t/* clear halt (tests API + protocol), verify it worked */\n\tretval = usb_clear_halt(urb->dev, urb->pipe);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\tretval = verify_not_halted(tdev, ep, urb);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/* NOTE:  could also verify SET_INTERFACE clear halts ... */\n\n\treturn 0;\n}\n\nstatic int halt_simple(struct usbtest_dev *dev)\n{\n\tint\t\t\tep;\n\tint\t\t\tretval = 0;\n\tstruct urb\t\t*urb;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\n\tif (udev->speed == USB_SPEED_SUPER)\n\t\turb = simple_alloc_urb(udev, 0, 1024, 0);\n\telse\n\t\turb = simple_alloc_urb(udev, 0, 512, 0);\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (dev->in_pipe) {\n\t\tep = usb_pipeendpoint(dev->in_pipe) | USB_DIR_IN;\n\t\turb->pipe = dev->in_pipe;\n\t\tretval = test_halt(dev, ep, urb);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (dev->out_pipe) {\n\t\tep = usb_pipeendpoint(dev->out_pipe);\n\t\turb->pipe = dev->out_pipe;\n\t\tretval = test_halt(dev, ep, urb);\n\t}\ndone:\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* Control OUT tests use the vendor control requests from Intel's\n * USB 2.0 compliance test device:  write a buffer, read it back.\n *\n * Intel's spec only _requires_ that it work for one packet, which\n * is pretty weak.   Some HCDs place limits here; most devices will\n * need to be able to handle more than one OUT data packet.  We'll\n * try whatever we're told to try.\n */\nstatic int ctrl_out(struct usbtest_dev *dev,\n\t\tunsigned count, unsigned length, unsigned vary, unsigned offset)\n{\n\tunsigned\t\ti, j, len;\n\tint\t\t\tretval;\n\tu8\t\t\t*buf;\n\tchar\t\t\t*what = \"?\";\n\tstruct usb_device\t*udev;\n\n\tif (length < 1 || length > 0xffff || vary >= length)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(length + offset, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf += offset;\n\tudev = testdev_to_usbdev(dev);\n\tlen = length;\n\tretval = 0;\n\n\t/* NOTE:  hardware might well act differently if we pushed it\n\t * with lots back-to-back queued requests.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\t/* write patterned data */\n\t\tfor (j = 0; j < len; j++)\n\t\t\tbuf[j] = (u8)(i + j);\n\t\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t0x5b, USB_DIR_OUT|USB_TYPE_VENDOR,\n\t\t\t\t0, 0, buf, len, USB_CTRL_SET_TIMEOUT);\n\t\tif (retval != len) {\n\t\t\twhat = \"write\";\n\t\t\tif (retval >= 0) {\n\t\t\t\tERROR(dev, \"ctrl_out, wlen %d (expected %d)\\n\",\n\t\t\t\t\t\tretval, len);\n\t\t\t\tretval = -EBADMSG;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* read it back -- assuming nothing intervened!!  */\n\t\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t0x5c, USB_DIR_IN|USB_TYPE_VENDOR,\n\t\t\t\t0, 0, buf, len, USB_CTRL_GET_TIMEOUT);\n\t\tif (retval != len) {\n\t\t\twhat = \"read\";\n\t\t\tif (retval >= 0) {\n\t\t\t\tERROR(dev, \"ctrl_out, rlen %d (expected %d)\\n\",\n\t\t\t\t\t\tretval, len);\n\t\t\t\tretval = -EBADMSG;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* fail if we can't verify */\n\t\tfor (j = 0; j < len; j++) {\n\t\t\tif (buf[j] != (u8)(i + j)) {\n\t\t\t\tERROR(dev, \"ctrl_out, byte %d is %d not %d\\n\",\n\t\t\t\t\tj, buf[j], (u8)(i + j));\n\t\t\t\tretval = -EBADMSG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (retval < 0) {\n\t\t\twhat = \"verify\";\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += vary;\n\n\t\t/* [real world] the \"zero bytes IN\" case isn't really used.\n\t\t * hardware can easily trip up in this weird case, since its\n\t\t * status stage is IN, not OUT like other ep0in transfers.\n\t\t */\n\t\tif (len > length)\n\t\t\tlen = realworld ? 1 : 0;\n\t}\n\n\tif (retval < 0)\n\t\tERROR(dev, \"ctrl_out %s failed, code %d, count %d\\n\",\n\t\t\twhat, retval, i);\n\n\tkfree(buf - offset);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* ISO/BULK tests ... mimics common usage\n *  - buffer length is split into N packets (mostly maxpacket sized)\n *  - multi-buffers according to sglen\n */\n\nstruct transfer_context {\n\tunsigned\t\tcount;\n\tunsigned\t\tpending;\n\tspinlock_t\t\tlock;\n\tstruct completion\tdone;\n\tint\t\t\tsubmit_error;\n\tunsigned long\t\terrors;\n\tunsigned long\t\tpacket_count;\n\tstruct usbtest_dev\t*dev;\n\tbool\t\t\tis_iso;\n};\n\nstatic void complicated_callback(struct urb *urb)\n{\n\tstruct transfer_context\t*ctx = urb->context;\n\n\tspin_lock(&ctx->lock);\n\tctx->count--;\n\n\tctx->packet_count += urb->number_of_packets;\n\tif (urb->error_count > 0)\n\t\tctx->errors += urb->error_count;\n\telse if (urb->status != 0)\n\t\tctx->errors += (ctx->is_iso ? urb->number_of_packets : 1);\n\telse if (urb->actual_length != urb->transfer_buffer_length)\n\t\tctx->errors++;\n\telse if (check_guard_bytes(ctx->dev, urb) != 0)\n\t\tctx->errors++;\n\n\tif (urb->status == 0 && ctx->count > (ctx->pending - 1)\n\t\t\t&& !ctx->submit_error) {\n\t\tint status = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tdev_err(&ctx->dev->intf->dev,\n\t\t\t\t\t\"resubmit err %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t/* FALLTHROUGH */\n\t\tcase -ENODEV:\t\t\t/* disconnected */\n\t\tcase -ESHUTDOWN:\t\t/* endpoint disabled */\n\t\t\tctx->submit_error = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->pending--;\n\tif (ctx->pending == 0) {\n\t\tif (ctx->errors)\n\t\t\tdev_err(&ctx->dev->intf->dev,\n\t\t\t\t\"during the test, %lu errors out of %lu\\n\",\n\t\t\t\tctx->errors, ctx->packet_count);\n\t\tcomplete(&ctx->done);\n\t}\ndone:\n\tspin_unlock(&ctx->lock);\n}\n\nstatic struct urb *iso_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tstruct usb_endpoint_descriptor\t*desc,\n\tlong\t\t\tbytes,\n\tunsigned offset\n)\n{\n\tstruct urb\t\t*urb;\n\tunsigned\t\ti, maxp, packets;\n\n\tif (bytes < 0 || !desc)\n\t\treturn NULL;\n\tmaxp = 0x7ff & usb_endpoint_maxp(desc);\n\tmaxp *= usb_endpoint_maxp_mult(desc);\n\tpackets = DIV_ROUND_UP(bytes, maxp);\n\n\turb = usb_alloc_urb(packets, GFP_KERNEL);\n\tif (!urb)\n\t\treturn urb;\n\turb->dev = udev;\n\turb->pipe = pipe;\n\n\turb->number_of_packets = packets;\n\turb->transfer_buffer_length = bytes;\n\turb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,\n\t\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t\t&urb->transfer_dma);\n\tif (!urb->transfer_buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\tif (offset) {\n\t\tmemset(urb->transfer_buffer, GUARD_BYTE, offset);\n\t\turb->transfer_buffer += offset;\n\t\turb->transfer_dma += offset;\n\t}\n\t/* For inbound transfers use guard byte so that test fails if\n\t\tdata not correctly copied */\n\tmemset(urb->transfer_buffer,\n\t\t\tusb_pipein(urb->pipe) ? GUARD_BYTE : 0,\n\t\t\tbytes);\n\n\tfor (i = 0; i < packets; i++) {\n\t\t/* here, only the last packet will be short */\n\t\turb->iso_frame_desc[i].length = min((unsigned) bytes, maxp);\n\t\tbytes -= urb->iso_frame_desc[i].length;\n\n\t\turb->iso_frame_desc[i].offset = maxp * i;\n\t}\n\n\turb->complete = complicated_callback;\n\t/* urb->context = SET BY CALLER */\n\turb->interval = 1 << (desc->bInterval - 1);\n\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\treturn urb;\n}\n\nstatic int\ntest_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,\n\t\tint pipe, struct usb_endpoint_descriptor *desc, unsigned offset)\n{\n\tstruct transfer_context\tcontext;\n\tstruct usb_device\t*udev;\n\tunsigned\t\ti;\n\tunsigned long\t\tpackets = 0;\n\tint\t\t\tstatus = 0;\n\tstruct urb\t\t*urbs[param->sglen];\n\n\tif (!param->sglen || param->iterations > UINT_MAX / param->sglen)\n\t\treturn -EINVAL;\n\n\tmemset(&context, 0, sizeof(context));\n\tcontext.count = param->iterations * param->sglen;\n\tcontext.dev = dev;\n\tcontext.is_iso = !!desc;\n\tinit_completion(&context.done);\n\tspin_lock_init(&context.lock);\n\n\tudev = testdev_to_usbdev(dev);\n\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (context.is_iso)\n\t\t\turbs[i] = iso_alloc_urb(udev, pipe, desc,\n\t\t\t\t\tparam->length, offset);\n\t\telse\n\t\t\turbs[i] = complicated_alloc_urb(udev, pipe,\n\t\t\t\t\tparam->length, 0);\n\n\t\tif (!urbs[i]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpackets += urbs[i]->number_of_packets;\n\t\turbs[i]->context = &context;\n\t}\n\tpackets *= param->iterations;\n\n\tif (context.is_iso) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t\"iso period %d %sframes, wMaxPacket %d, transactions: %d\\n\",\n\t\t\t1 << (desc->bInterval - 1),\n\t\t\t(udev->speed == USB_SPEED_HIGH) ? \"micro\" : \"\",\n\t\t\tusb_endpoint_maxp(desc),\n\t\t\tusb_endpoint_maxp_mult(desc));\n\n\t\tdev_info(&dev->intf->dev,\n\t\t\t\"total %lu msec (%lu packets)\\n\",\n\t\t\t(packets * (1 << (desc->bInterval - 1)))\n\t\t\t\t/ ((udev->speed == USB_SPEED_HIGH) ? 8 : 1),\n\t\t\tpackets);\n\t}\n\n\tspin_lock_irq(&context.lock);\n\tfor (i = 0; i < param->sglen; i++) {\n\t\t++context.pending;\n\t\tstatus = usb_submit_urb(urbs[i], GFP_ATOMIC);\n\t\tif (status < 0) {\n\t\t\tERROR(dev, \"submit iso[%d], error %d\\n\", i, status);\n\t\t\tif (i == 0) {\n\t\t\t\tspin_unlock_irq(&context.lock);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsimple_free_urb(urbs[i]);\n\t\t\turbs[i] = NULL;\n\t\t\tcontext.pending--;\n\t\t\tcontext.submit_error = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&context.lock);\n\n\twait_for_completion(&context.done);\n\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (urbs[i])\n\t\t\tsimple_free_urb(urbs[i]);\n\t}\n\t/*\n\t * Isochronous transfers are expected to fail sometimes.  As an\n\t * arbitrary limit, we will report an error if any submissions\n\t * fail or if the transfer failure rate is > 10%.\n\t */\n\tif (status != 0)\n\t\t;\n\telse if (context.submit_error)\n\t\tstatus = -EACCES;\n\telse if (context.errors >\n\t\t\t(context.is_iso ? context.packet_count / 10 : 0))\n\t\tstatus = -EIO;\n\treturn status;\n\nfail:\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (urbs[i])\n\t\t\tsimple_free_urb(urbs[i]);\n\t}\n\treturn status;\n}\n\nstatic int test_unaligned_bulk(\n\tstruct usbtest_dev *tdev,\n\tint pipe,\n\tunsigned length,\n\tint iterations,\n\tunsigned transfer_flags,\n\tconst char *label)\n{\n\tint retval;\n\tstruct urb *urb = usbtest_alloc_urb(testdev_to_usbdev(tdev),\n\t\t\tpipe, length, transfer_flags, 1, 0, simple_callback);\n\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tretval = simple_io(tdev, urb, iterations, 0, 0, label);\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\n/* Run tests. */\nstatic int\nusbtest_do_ioctl(struct usb_interface *intf, struct usbtest_param_32 *param)\n{\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tstruct urb\t\t*urb;\n\tstruct scatterlist\t*sg;\n\tstruct usb_sg_request\treq;\n\tunsigned\t\ti;\n\tint\tretval = -EOPNOTSUPP;\n\n\tif (param->iterations <= 0)\n\t\treturn -EINVAL;\n\tif (param->sglen > MAX_SGLEN)\n\t\treturn -EINVAL;\n\t/*\n\t * Just a bunch of test cases that every HCD is expected to handle.\n\t *\n\t * Some may need specific firmware, though it'd be good to have\n\t * one firmware image to handle all the test cases.\n\t *\n\t * FIXME add more tests!  cancel requests, verify the data, control\n\t * queueing, concurrent read+write threads, and so on.\n\t */\n\tswitch (param->test_num) {\n\n\tcase 0:\n\t\tdev_info(&intf->dev, \"TEST 0:  NOP\\n\");\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* Simple non-queued bulk I/O tests */\n\tcase 1:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 1:  write %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test1\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 2:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 2:  read %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test2\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 3:\n\t\tif (dev->out_pipe == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 3:  write/%d 0..%d bytes %u times\\n\",\n\t\t\t\tparam->vary, param->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, param->vary,\n\t\t\t\t\t0, \"test3\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 4:\n\t\tif (dev->in_pipe == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 4:  read/%d 0..%d bytes %u times\\n\",\n\t\t\t\tparam->vary, param->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, param->vary,\n\t\t\t\t\t0, \"test4\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\n\t/* Queued bulk I/O tests */\n\tcase 5:\n\t\tif (dev->out_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 5:  write %d sglists %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\t0, dev, dev->out_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->out_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\n\tcase 6:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 6:  read %d sglists %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\t0, dev, dev->in_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->in_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\tcase 7:\n\t\tif (dev->out_pipe == 0 || param->sglen == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\\n\",\n\t\t\t\tparam->vary, param->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\tparam->vary, dev, dev->out_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk sink (maybe accepts short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->out_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\tcase 8:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\\n\",\n\t\t\t\tparam->vary, param->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\tparam->vary, dev, dev->in_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE:  bulk source (maybe generates short writes) */\n\t\tretval = perform_sglist(dev, param->iterations, dev->in_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\n\t/* non-queued sanity tests for control (chapter 9 subset) */\n\tcase 9:\n\t\tretval = 0;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 9:  ch9 (subset) control tests, %d times\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = ch9_postconfig(dev);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"ch9 subset failed, \"\n\t\t\t\t\t\"iterations left %d\\n\", i);\n\t\tbreak;\n\n\t/* queued control messaging */\n\tcase 10:\n\t\tretval = 0;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 10:  queue %d control calls, %d times\\n\",\n\t\t\t\tparam->sglen,\n\t\t\t\tparam->iterations);\n\t\tretval = test_ctrl_queue(dev, param);\n\t\tbreak;\n\n\t/* simple non-queued unlinks (ring with one urb) */\n\tcase 11:\n\t\tif (dev->in_pipe == 0 || !param->length)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 11:  unlink %d reads of %d\\n\",\n\t\t\t\tparam->iterations, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = unlink_simple(dev, dev->in_pipe,\n\t\t\t\t\t\tparam->length);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"unlink reads failed %d, \"\n\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\tbreak;\n\tcase 12:\n\t\tif (dev->out_pipe == 0 || !param->length)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 12:  unlink %d writes of %d\\n\",\n\t\t\t\tparam->iterations, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = unlink_simple(dev, dev->out_pipe,\n\t\t\t\t\t\tparam->length);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"unlink writes failed %d, \"\n\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\tbreak;\n\n\t/* ep halt tests */\n\tcase 13:\n\t\tif (dev->out_pipe == 0 && dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 13:  set/clear %d halts\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i--; /* NOP */)\n\t\t\tretval = halt_simple(dev);\n\n\t\tif (retval)\n\t\t\tERROR(dev, \"halts failed, iterations left %d\\n\", i);\n\t\tbreak;\n\n\t/* control write tests */\n\tcase 14:\n\t\tif (!dev->info->ctrl_out)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev, \"TEST 14:  %d ep0out, %d..%d vary %d\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\trealworld ? 1 : 0, param->length,\n\t\t\t\tparam->vary);\n\t\tretval = ctrl_out(dev, param->iterations,\n\t\t\t\tparam->length, param->vary, 0);\n\t\tbreak;\n\n\t/* iso write tests */\n\tcase 15:\n\t\tif (dev->out_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 15:  write %d iso, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\t/* FIRMWARE:  iso sink */\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_iso_pipe, dev->iso_out, 0);\n\t\tbreak;\n\n\t/* iso read tests */\n\tcase 16:\n\t\tif (dev->in_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 16:  read %d iso, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\t/* FIRMWARE:  iso source */\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_iso_pipe, dev->iso_in, 0);\n\t\tbreak;\n\n\t/* FIXME scatterlist cancel (needs helper thread) */\n\n\t/* Tests for bulk I/O using DMA mapping by core and odd address */\n\tcase 17:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 17:  write odd addr %d bytes %u times core map\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->out_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\t0, \"test17\");\n\t\tbreak;\n\n\tcase 18:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 18:  read odd addr %d bytes %u times core map\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->in_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\t0, \"test18\");\n\t\tbreak;\n\n\t/* Tests for bulk I/O using premapped coherent buffer and odd address */\n\tcase 19:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 19:  write odd addr %d bytes %u times premapped\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->out_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\tURB_NO_TRANSFER_DMA_MAP, \"test19\");\n\t\tbreak;\n\n\tcase 20:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 20:  read odd addr %d bytes %u times premapped\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->in_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\tURB_NO_TRANSFER_DMA_MAP, \"test20\");\n\t\tbreak;\n\n\t/* control write tests with unaligned buffer */\n\tcase 21:\n\t\tif (!dev->info->ctrl_out)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 21:  %d ep0out odd addr, %d..%d vary %d\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\trealworld ? 1 : 0, param->length,\n\t\t\t\tparam->vary);\n\t\tretval = ctrl_out(dev, param->iterations,\n\t\t\t\tparam->length, param->vary, 1);\n\t\tbreak;\n\n\t/* unaligned iso tests */\n\tcase 22:\n\t\tif (dev->out_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 22:  write %d iso odd, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_iso_pipe, dev->iso_out, 1);\n\t\tbreak;\n\n\tcase 23:\n\t\tif (dev->in_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 23:  read %d iso odd, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_iso_pipe, dev->iso_in, 1);\n\t\tbreak;\n\n\t/* unlink URBs from a bulk-OUT queue */\n\tcase 24:\n\t\tif (dev->out_pipe == 0 || !param->length || param->sglen < 4)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 24:  unlink from %d queues of \"\n\t\t\t\t\"%d %d-byte writes\\n\",\n\t\t\t\tparam->iterations, param->sglen, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i > 0; --i) {\n\t\t\tretval = unlink_queued(dev, dev->out_pipe,\n\t\t\t\t\t\tparam->sglen, param->length);\n\t\t\tif (retval) {\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"unlink queued writes failed %d, \"\n\t\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t/* Simple non-queued interrupt I/O tests */\n\tcase 25:\n\t\tif (dev->out_int_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 25: write %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_int_pipe, param->length,\n\t\t\t\tdev->int_out->bInterval);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE: interrupt sink (maybe accepts short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test25\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 26:\n\t\tif (dev->in_int_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 26: read %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_int_pipe, param->length,\n\t\t\t\tdev->int_in->bInterval);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* FIRMWARE: interrupt source (maybe generates short writes) */\n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test26\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 27:\n\t\t/* We do performance test, so ignore data compare */\n\t\tif (dev->out_pipe == 0 || param->sglen == 0 || pattern != 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 27: bulk write %dMbytes\\n\", (param->iterations *\n\t\t\tparam->sglen * param->length) / (1024 * 1024));\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_pipe, NULL, 0);\n\t\tbreak;\n\tcase 28:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0 || pattern != 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 28: bulk read %dMbytes\\n\", (param->iterations *\n\t\t\tparam->sglen * param->length) / (1024 * 1024));\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_pipe, NULL, 0);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* We only have this one interface to user space, through usbfs.\n * User mode code can scan usbfs to find N different devices (maybe on\n * different busses) to use when testing, and allocate one thread per\n * test.  So discovery is simplified, and we have no device naming issues.\n *\n * Don't use these only as stress/load tests.  Use them along with with\n * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,\n * video capture, and so on.  Run different tests at different times, in\n * different sequences.  Nothing here should interact with other devices,\n * except indirectly by consuming USB bandwidth and CPU resources for test\n * threads and request completion.  But the only way to know that for sure\n * is to test when HC queues are in use by many devices.\n *\n * WARNING:  Because usbfs grabs udev->dev.sem before calling this ioctl(),\n * it locks out usbcore in certain code paths.  Notably, if you disconnect\n * the device-under-test, hub_wq will wait block forever waiting for the\n * ioctl to complete ... so that usb_disconnect() can abort the pending\n * urbs and then call usbtest_disconnect().  To abort a test, you're best\n * off just killing the userspace task and waiting for it to exit.\n */\n\nstatic int\nusbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)\n{\n\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\tstruct usbtest_param_64 *param_64 = buf;\n\tstruct usbtest_param_32 temp;\n\tstruct usbtest_param_32 *param_32 = buf;\n\tstruct timespec64 start;\n\tstruct timespec64 end;\n\tstruct timespec64 duration;\n\tint retval = -EOPNOTSUPP;\n\n\t/* FIXME USBDEVFS_CONNECTINFO doesn't say how fast the device is. */\n\n\tpattern = mod_pattern;\n\n\tif (mutex_lock_interruptible(&dev->lock))\n\t\treturn -ERESTARTSYS;\n\n\t/* FIXME: What if a system sleep starts while a test is running? */\n\n\t/* some devices, like ez-usb default devices, need a non-default\n\t * altsetting to have any active endpoints.  some tests change\n\t * altsettings; force a default so most tests don't need to check.\n\t */\n\tif (dev->info->alt >= 0) {\n\t\tif (intf->altsetting->desc.bInterfaceNumber) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_mutex;\n\t\t}\n\t\tretval = set_altsetting(dev, dev->info->alt);\n\t\tif (retval) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"set altsetting to %d failed, %d\\n\",\n\t\t\t\t\tdev->info->alt, retval);\n\t\t\tgoto free_mutex;\n\t\t}\n\t}\n\n\tswitch (code) {\n\tcase USBTEST_REQUEST_64:\n\t\ttemp.test_num = param_64->test_num;\n\t\ttemp.iterations = param_64->iterations;\n\t\ttemp.length = param_64->length;\n\t\ttemp.sglen = param_64->sglen;\n\t\ttemp.vary = param_64->vary;\n\t\tparam_32 = &temp;\n\t\tbreak;\n\n\tcase USBTEST_REQUEST_32:\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EOPNOTSUPP;\n\t\tgoto free_mutex;\n\t}\n\n\tktime_get_ts64(&start);\n\n\tretval = usbtest_do_ioctl(intf, param_32);\n\tif (retval < 0)\n\t\tgoto free_mutex;\n\n\tktime_get_ts64(&end);\n\n\tduration = timespec64_sub(end, start);\n\n\ttemp.duration_sec = duration.tv_sec;\n\ttemp.duration_usec = duration.tv_nsec/NSEC_PER_USEC;\n\n\tswitch (code) {\n\tcase USBTEST_REQUEST_32:\n\t\tparam_32->duration_sec = temp.duration_sec;\n\t\tparam_32->duration_usec = temp.duration_usec;\n\t\tbreak;\n\n\tcase USBTEST_REQUEST_64:\n\t\tparam_64->duration_sec = temp.duration_sec;\n\t\tparam_64->duration_usec = temp.duration_usec;\n\t\tbreak;\n\t}\n\nfree_mutex:\n\tmutex_unlock(&dev->lock);\n\treturn retval;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic unsigned force_interrupt;\nmodule_param(force_interrupt, uint, 0);\nMODULE_PARM_DESC(force_interrupt, \"0 = test default; else interrupt\");\n\n#ifdef\tGENERIC\nstatic unsigned short vendor;\nmodule_param(vendor, ushort, 0);\nMODULE_PARM_DESC(vendor, \"vendor code (from usb-if)\");\n\nstatic unsigned short product;\nmodule_param(product, ushort, 0);\nMODULE_PARM_DESC(product, \"product code (from vendor)\");\n#endif\n\nstatic int\nusbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device\t*udev;\n\tstruct usbtest_dev\t*dev;\n\tstruct usbtest_info\t*info;\n\tchar\t\t\t*rtest, *wtest;\n\tchar\t\t\t*irtest, *iwtest;\n\tchar\t\t\t*intrtest, *intwtest;\n\n\tudev = interface_to_usbdev(intf);\n\n#ifdef\tGENERIC\n\t/* specify devices by module parameters? */\n\tif (id->match_flags == 0) {\n\t\t/* vendor match required, product match optional */\n\t\tif (!vendor || le16_to_cpu(udev->descriptor.idVendor) != (u16)vendor)\n\t\t\treturn -ENODEV;\n\t\tif (product && le16_to_cpu(udev->descriptor.idProduct) != (u16)product)\n\t\t\treturn -ENODEV;\n\t\tdev_info(&intf->dev, \"matched module params, \"\n\t\t\t\t\t\"vend=0x%04x prod=0x%04x\\n\",\n\t\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct));\n\t}\n#endif\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tinfo = (struct usbtest_info *) id->driver_info;\n\tdev->info = info;\n\tmutex_init(&dev->lock);\n\n\tdev->intf = intf;\n\n\t/* cacheline-aligned scratch for i/o */\n\tdev->buf = kmalloc(TBUF_SIZE, GFP_KERNEL);\n\tif (dev->buf == NULL) {\n\t\tkfree(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* NOTE this doesn't yet test the handful of difference that are\n\t * visible with high speed interrupts:  bigger maxpacket (1K) and\n\t * \"high bandwidth\" modes (up to 3 packets/uframe).\n\t */\n\trtest = wtest = \"\";\n\tirtest = iwtest = \"\";\n\tintrtest = intwtest = \"\";\n\tif (force_interrupt || udev->speed == USB_SPEED_LOW) {\n\t\tif (info->ep_in) {\n\t\t\tdev->in_pipe = usb_rcvintpipe(udev, info->ep_in);\n\t\t\trtest = \" intr-in\";\n\t\t}\n\t\tif (info->ep_out) {\n\t\t\tdev->out_pipe = usb_sndintpipe(udev, info->ep_out);\n\t\t\twtest = \" intr-out\";\n\t\t}\n\t} else {\n\t\tif (override_alt >= 0 || info->autoconf) {\n\t\t\tint status;\n\n\t\t\tstatus = get_endpoints(dev, intf);\n\t\t\tif (status < 0) {\n\t\t\t\tWARNING(dev, \"couldn't get endpoints, %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t\t\tkfree(dev->buf);\n\t\t\t\tkfree(dev);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\t/* may find bulk or ISO pipes */\n\t\t} else {\n\t\t\tif (info->ep_in)\n\t\t\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t\t\tinfo->ep_in);\n\t\t\tif (info->ep_out)\n\t\t\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t\t\tinfo->ep_out);\n\t\t}\n\t\tif (dev->in_pipe)\n\t\t\trtest = \" bulk-in\";\n\t\tif (dev->out_pipe)\n\t\t\twtest = \" bulk-out\";\n\t\tif (dev->in_iso_pipe)\n\t\t\tirtest = \" iso-in\";\n\t\tif (dev->out_iso_pipe)\n\t\t\tiwtest = \" iso-out\";\n\t\tif (dev->in_int_pipe)\n\t\t\tintrtest = \" int-in\";\n\t\tif (dev->out_int_pipe)\n\t\t\tintwtest = \" int-out\";\n\t}\n\n\tusb_set_intfdata(intf, dev);\n\tdev_info(&intf->dev, \"%s\\n\", info->name);\n\tdev_info(&intf->dev, \"%s {control%s%s%s%s%s%s%s} tests%s\\n\",\n\t\t\tusb_speed_string(udev->speed),\n\t\t\tinfo->ctrl_out ? \" in/out\" : \"\",\n\t\t\trtest, wtest,\n\t\t\tirtest, iwtest,\n\t\t\tintrtest, intwtest,\n\t\t\tinfo->alt >= 0 ? \" (+alt)\" : \"\");\n\treturn 0;\n}\n\nstatic int usbtest_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int usbtest_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\n\nstatic void usbtest_disconnect(struct usb_interface *intf)\n{\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tdev_dbg(&intf->dev, \"disconnect\\n\");\n\tkfree(dev);\n}\n\n/* Basic testing only needs a device that can source or sink bulk traffic.\n * Any device can test control transfers (default with GENERIC binding).\n *\n * Several entries work with the default EP0 implementation that's built\n * into EZ-USB chips.  There's a default vendor ID which can be overridden\n * by (very) small config EEPROMS, but otherwise all these devices act\n * identically until firmware is loaded:  only EP0 works.  It turns out\n * to be easy to make other endpoints work, without modifying that EP0\n * behavior.  For now, we expect that kind of firmware.\n */\n\n/* an21xx or fx versions of ez-usb */\nstatic struct usbtest_info ez1_info = {\n\t.name\t\t= \"EZ-USB device\",\n\t.ep_in\t\t= 2,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n};\n\n/* fx2 version of ez-usb */\nstatic struct usbtest_info ez2_info = {\n\t.name\t\t= \"FX2 device\",\n\t.ep_in\t\t= 6,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n};\n\n/* ezusb family device with dedicated usb test firmware,\n */\nstatic struct usbtest_info fw_info = {\n\t.name\t\t= \"usb test device\",\n\t.ep_in\t\t= 2,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n\t.autoconf\t= 1,\t\t/* iso and ctrl_out need autoconf */\n\t.ctrl_out\t= 1,\n\t.iso\t\t= 1,\t\t/* iso_ep's are #8 in/out */\n};\n\n/* peripheral running Linux and 'zero.c' test firmware, or\n * its user-mode cousin. different versions of this use\n * different hardware with the same vendor/product codes.\n * host side MUST rely on the endpoint descriptors.\n */\nstatic struct usbtest_info gz_info = {\n\t.name\t\t= \"Linux gadget zero\",\n\t.autoconf\t= 1,\n\t.ctrl_out\t= 1,\n\t.iso\t\t= 1,\n\t.intr\t\t= 1,\n\t.alt\t\t= 0,\n};\n\nstatic struct usbtest_info um_info = {\n\t.name\t\t= \"Linux user mode test driver\",\n\t.autoconf\t= 1,\n\t.alt\t\t= -1,\n};\n\nstatic struct usbtest_info um2_info = {\n\t.name\t\t= \"Linux user mode ISO test driver\",\n\t.autoconf\t= 1,\n\t.iso\t\t= 1,\n\t.alt\t\t= -1,\n};\n\n#ifdef IBOT2\n/* this is a nice source of high speed bulk data;\n * uses an FX2, with firmware provided in the device\n */\nstatic struct usbtest_info ibot2_info = {\n\t.name\t\t= \"iBOT2 webcam\",\n\t.ep_in\t\t= 2,\n\t.alt\t\t= -1,\n};\n#endif\n\n#ifdef GENERIC\n/* we can use any device to test control traffic */\nstatic struct usbtest_info generic_info = {\n\t.name\t\t= \"Generic USB device\",\n\t.alt\t\t= -1,\n};\n#endif\n\n\nstatic const struct usb_device_id id_table[] = {\n\n\t/*-------------------------------------------------------------*/\n\n\t/* EZ-USB devices which download firmware to replace (or in our\n\t * case augment) the default device implementation.\n\t */\n\n\t/* generic EZ-USB FX controller */\n\t{ USB_DEVICE(0x0547, 0x2235),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n\n\t/* CY3671 development board with EZ-USB FX */\n\t{ USB_DEVICE(0x0547, 0x0080),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n\n\t/* generic EZ-USB FX2 controller (or development board) */\n\t{ USB_DEVICE(0x04b4, 0x8613),\n\t\t.driver_info = (unsigned long) &ez2_info,\n\t},\n\n\t/* re-enumerated usb test device firmware */\n\t{ USB_DEVICE(0xfff0, 0xfff0),\n\t\t.driver_info = (unsigned long) &fw_info,\n\t},\n\n\t/* \"Gadget Zero\" firmware runs under Linux */\n\t{ USB_DEVICE(0x0525, 0xa4a0),\n\t\t.driver_info = (unsigned long) &gz_info,\n\t},\n\n\t/* so does a user-mode variant */\n\t{ USB_DEVICE(0x0525, 0xa4a4),\n\t\t.driver_info = (unsigned long) &um_info,\n\t},\n\n\t/* ... and a user-mode variant that talks iso */\n\t{ USB_DEVICE(0x0525, 0xa4a3),\n\t\t.driver_info = (unsigned long) &um2_info,\n\t},\n\n#ifdef KEYSPAN_19Qi\n\t/* Keyspan 19qi uses an21xx (original EZ-USB) */\n\t/* this does not coexist with the real Keyspan 19qi driver! */\n\t{ USB_DEVICE(0x06cd, 0x010b),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n#endif\n\n\t/*-------------------------------------------------------------*/\n\n#ifdef IBOT2\n\t/* iBOT2 makes a nice source of high speed bulk-in data */\n\t/* this does not coexist with a real iBOT2 driver! */\n\t{ USB_DEVICE(0x0b62, 0x0059),\n\t\t.driver_info = (unsigned long) &ibot2_info,\n\t},\n#endif\n\n\t/*-------------------------------------------------------------*/\n\n#ifdef GENERIC\n\t/* module params can specify devices to use for control tests */\n\t{ .driver_info = (unsigned long) &generic_info, },\n#endif\n\n\t/*-------------------------------------------------------------*/\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver usbtest_driver = {\n\t.name =\t\t\"usbtest\",\n\t.id_table =\tid_table,\n\t.probe =\tusbtest_probe,\n\t.unlocked_ioctl = usbtest_ioctl,\n\t.disconnect =\tusbtest_disconnect,\n\t.suspend =\tusbtest_suspend,\n\t.resume =\tusbtest_resume,\n};\n\n/*-------------------------------------------------------------------------*/\n\nstatic int __init usbtest_init(void)\n{\n#ifdef GENERIC\n\tif (vendor)\n\t\tpr_debug(\"params: vend=0x%04x prod=0x%04x\\n\", vendor, product);\n#endif\n\treturn usb_register(&usbtest_driver);\n}\nmodule_init(usbtest_init);\n\nstatic void __exit usbtest_exit(void)\n{\n\tusb_deregister(&usbtest_driver);\n}\nmodule_exit(usbtest_exit);\n\nMODULE_DESCRIPTION(\"USB Core/HCD Testing Driver\");\nMODULE_LICENSE(\"GPL\");\n\n"], "filenames": ["drivers/usb/misc/usbtest.c"], "buggy_code_start_loc": [205], "buggy_code_end_loc": [211], "fixing_code_start_loc": [205], "fixing_code_end_loc": [212], "type": "CWE-476", "message": "The get_endpoints function in drivers/usb/misc/usbtest.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16532", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:37.037", "lastModified": "2018-08-24T10:29:01.053", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The get_endpoints function in drivers/usb/misc/usbtest.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "La funci\u00f3n get_endpoints en drivers/usb/misc/usbtest.c en el kernel de Linux, en versiones hasta la 4.13.11, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.11", "matchCriteriaId": "3AB470D9-2EFD-4F2C-838A-EF9815166D69"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/7c80f9e4a588f1925b07134bb2e3689335f6c6d8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/l3870gs3LhA/y79DYQdFBAAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3617-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3617-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3617-3/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7c80f9e4a588f1925b07134bb2e3689335f6c6d8"}}