{"buggy_code": ["//     _                _      _  ____   _                           _____\n//    / \\    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___\n//   / _ \\  | '__|/ __|| '_ \\ | |\\___ \\ | __|/ _ \\ / _` || '_ ` _ \\ | |_  / _` || '__|| '_ ` _ \\\n//  / ___ \\ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |\n// /_/   \\_\\|_|   \\___||_| |_||_||____/  \\__|\\___| \\__,_||_| |_| |_||_|   \\__,_||_|   |_| |_| |_|\n// |\n// Copyright 2015-2020 \u0141ukasz \"JustArchi\" Domeradzki\n// Contact: JustArchi@JustArchi.net\n// |\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// |\n// http://www.apache.org/licenses/LICENSE-2.0\n// |\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Collections;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Collections.Specialized;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing ArchiSteamFarm.Collections;\nusing ArchiSteamFarm.Localization;\nusing ArchiSteamFarm.NLog;\nusing ArchiSteamFarm.Plugins;\nusing JetBrains.Annotations;\nusing Newtonsoft.Json;\nusing SteamKit2;\nusing SteamKit2.Internal;\n\nnamespace ArchiSteamFarm {\n\tpublic sealed class Bot : IAsyncDisposable {\n\t\tinternal const ushort CallbackSleep = 500; // In milliseconds\n\t\tinternal const ushort MaxMessagePrefixLength = MaxMessageLength - ReservedMessageLength - 2; // 2 for a minimum of 2 characters (escape one and real one)\n\t\tinternal const byte MinPlayingBlockedTTL = 60; // Delay in seconds added when account was occupied during our disconnect, to not disconnect other Steam client session too soon\n\n\t\tprivate const char DefaultBackgroundKeysRedeemerSeparator = '\\t';\n\t\tprivate const byte LoginCooldownInMinutes = 25; // Captcha disappears after around 20 minutes, so we make it 25\n\t\tprivate const uint LoginID = 1242; // This must be the same for all ASF bots and all ASF processes\n\t\tprivate const byte MaxInvalidPasswordFailures = WebBrowser.MaxTries; // Max InvalidPassword failures in a row before we determine that our password is invalid (because Steam wrongly returns those, of course)\n\t\tprivate const ushort MaxMessageLength = 5000; // This is a limitation enforced by Steam\n\t\tprivate const byte MaxTwoFactorCodeFailures = WebBrowser.MaxTries; // Max TwoFactorCodeMismatch failures in a row before we determine that our 2FA credentials are invalid (because Steam wrongly returns those, of course)\n\t\tprivate const byte RedeemCooldownInHours = 1; // 1 hour since first redeem attempt, this is a limitation enforced by Steam\n\t\tprivate const byte ReservedMessageLength = 2; // 2 for 2x optional \u2026\n\n\t\t[PublicAPI]\n\t\tpublic static IReadOnlyDictionary<string, Bot>? BotsReadOnly => Bots;\n\n\t\tinternal static ConcurrentDictionary<string, Bot>? Bots { get; private set; }\n\t\tinternal static StringComparer? BotsComparer { get; private set; }\n\t\tinternal static EOSType OSType { get; private set; } = EOSType.Unknown;\n\n\t\tprivate static readonly SemaphoreSlim BotsSemaphore = new SemaphoreSlim(1, 1);\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly Actions Actions;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly ArchiLogger ArchiLogger;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly ArchiWebHandler ArchiWebHandler;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic readonly string BotName;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic readonly CardsFarmer CardsFarmer;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly Commands Commands;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly SteamApps SteamApps;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly SteamConfiguration SteamConfiguration;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly SteamFriends SteamFriends;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic uint GamesToRedeemInBackgroundCount => BotDatabase.GamesToRedeemInBackgroundCount;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool HasMobileAuthenticator => BotDatabase.MobileAuthenticator != null;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool IsConnectedAndLoggedOn => SteamClient.SteamID != null;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool IsPlayingPossible => !PlayingBlocked && !LibraryLocked;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic IReadOnlyCollection<uint> OwnedPackageIDsReadOnly => OwnedPackageIDs.Keys.ToHashSet();\n\n\t\tinternal readonly ArchiHandler ArchiHandler;\n\t\tinternal readonly BotDatabase BotDatabase;\n\n\t\tinternal bool CanReceiveSteamCards => !IsAccountLimited && !IsAccountLocked;\n\t\tinternal bool IsAccountLimited => AccountFlags.HasFlag(EAccountFlags.LimitedUser) || AccountFlags.HasFlag(EAccountFlags.LimitedUserForce);\n\t\tinternal bool IsAccountLocked => AccountFlags.HasFlag(EAccountFlags.Lockdown);\n\n\t\tprivate readonly CallbackManager CallbackManager;\n\t\tprivate readonly SemaphoreSlim CallbackSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly SemaphoreSlim GamesRedeemerInBackgroundSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly Timer HeartBeatTimer;\n\t\tprivate readonly SemaphoreSlim InitializationSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly SemaphoreSlim MessagingSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly ConcurrentDictionary<ArchiHandler.UserNotificationsCallback.EUserNotification, uint> PastNotifications = new ConcurrentDictionary<ArchiHandler.UserNotificationsCallback.EUserNotification, uint>();\n\t\tprivate readonly Statistics? Statistics;\n\t\tprivate readonly SteamClient SteamClient;\n\t\tprivate readonly ConcurrentHashSet<ulong> SteamFamilySharingIDs = new ConcurrentHashSet<ulong>();\n\t\tprivate readonly SteamUser SteamUser;\n\t\tprivate readonly Trading Trading;\n\n#pragma warning disable CS8605\n\t\tprivate IEnumerable<(string FilePath, EFileType FileType)> RelatedFiles {\n\t\t\tget {\n\t\t\t\tforeach (EFileType fileType in Enum.GetValues(typeof(EFileType))) {\n\t\t\t\t\tstring filePath = GetFilePath(fileType);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(filePath)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(filePath));\n\n\t\t\t\t\t\tyield break;\n\t\t\t\t\t}\n\n\t\t\t\t\tyield return (filePath, fileType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#pragma warning restore CS8605\n\n#pragma warning disable IDE0051\n\t\t[JsonProperty(PropertyName = SharedInfo.UlongCompatibilityStringPrefix + nameof(SteamID))]\n\n\t\tprivate string SSteamID => SteamID.ToString();\n#pragma warning restore IDE0051\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic EAccountFlags AccountFlags { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic BotConfig BotConfig { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool KeepRunning { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic string? Nickname { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic ASF.EUserInputType RequiredInput { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic ulong SteamID { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic long WalletBalance { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic ECurrencyCode WalletCurrency { get; private set; }\n\n\t\tinternal ImmutableDictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)> OwnedPackageIDs { get; private set; } = ImmutableDictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)>.Empty;\n\t\tinternal bool PlayingBlocked { get; private set; }\n\t\tinternal bool PlayingWasBlocked { get; private set; }\n\n\t\tprivate string? AuthCode;\n\n#pragma warning disable IDE0052\n\t\t[JsonProperty]\n\t\tprivate string? AvatarHash;\n#pragma warning restore IDE0052\n\n\t\tprivate Timer? ConnectionFailureTimer;\n\t\tprivate bool FirstTradeSent;\n\t\tprivate Timer? GamesRedeemerInBackgroundTimer;\n\t\tprivate byte HeartBeatFailures;\n\t\tprivate byte InvalidPasswordFailures;\n\t\tprivate EResult LastLogOnResult;\n\t\tprivate DateTime LastLogonSessionReplaced;\n\t\tprivate bool LibraryLocked;\n\t\tprivate ulong MasterChatGroupID;\n\t\tprivate Timer? PlayingWasBlockedTimer;\n\t\tprivate bool ReconnectOnUserInitiated;\n\t\tprivate Timer? SendItemsTimer;\n\t\tprivate bool SteamParentalActive = true;\n\t\tprivate SteamSaleEvent? SteamSaleEvent;\n\t\tprivate string? TwoFactorCode;\n\t\tprivate byte TwoFactorCodeFailures;\n\n\t\tprivate Bot(string botName, BotConfig botConfig, BotDatabase botDatabase) {\n\t\t\tif (string.IsNullOrEmpty(botName) || (botConfig == null) || (botDatabase == null) || (Bots == null) || (ASF.GlobalConfig == null) || (ASF.GlobalDatabase == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(botConfig) + \" || \" + nameof(botDatabase) + \" || \" + nameof(Bots) + \" || \" + nameof(ASF.GlobalConfig) + \" || \" + nameof(ASF.GlobalDatabase));\n\t\t\t}\n\n\t\t\tBotName = botName;\n\t\t\tBotConfig = botConfig;\n\t\t\tBotDatabase = botDatabase;\n\n\t\t\tArchiLogger = new ArchiLogger(botName);\n\n\t\t\tBotDatabase.MobileAuthenticator?.Init(this);\n\n\t\t\tArchiWebHandler = new ArchiWebHandler(this);\n\n\t\t\tSteamConfiguration = SteamConfiguration.Create(builder => builder.WithProtocolTypes(ASF.GlobalConfig.SteamProtocols).WithCellID(ASF.GlobalDatabase.CellID).WithServerListProvider(ASF.GlobalDatabase.ServerListProvider).WithHttpClientFactory(ArchiWebHandler.GenerateDisposableHttpClient));\n\n\t\t\t// Initialize\n\t\t\tSteamClient = new SteamClient(SteamConfiguration, botName);\n\n\t\t\tif (Debugging.IsDebugConfigured && Directory.Exists(SharedInfo.DebugDirectory)) {\n\t\t\t\tstring debugListenerPath = Path.Combine(SharedInfo.DebugDirectory, botName);\n\n\t\t\t\ttry {\n\t\t\t\t\tDirectory.CreateDirectory(debugListenerPath);\n\t\t\t\t\tSteamClient.DebugNetworkListener = new NetHookNetworkListener(debugListenerPath, SteamClient);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSteamUnifiedMessages? steamUnifiedMessages = SteamClient.GetHandler<SteamUnifiedMessages>();\n\n\t\t\tArchiHandler = new ArchiHandler(ArchiLogger, steamUnifiedMessages ?? throw new ArgumentNullException(nameof(steamUnifiedMessages)));\n\t\t\tSteamClient.AddHandler(ArchiHandler);\n\n\t\t\tCallbackManager = new CallbackManager(SteamClient);\n\t\t\tCallbackManager.Subscribe<SteamClient.ConnectedCallback>(OnConnected);\n\t\t\tCallbackManager.Subscribe<SteamClient.DisconnectedCallback>(OnDisconnected);\n\n\t\t\tSteamApps = SteamClient.GetHandler<SteamApps>() ?? throw new ArgumentNullException(nameof(SteamApps));\n\t\t\tCallbackManager.Subscribe<SteamApps.GuestPassListCallback>(OnGuestPassList);\n\t\t\tCallbackManager.Subscribe<SteamApps.LicenseListCallback>(OnLicenseList);\n\n\t\t\tSteamFriends = SteamClient.GetHandler<SteamFriends>() ?? throw new ArgumentNullException(nameof(SteamFriends));\n\t\t\tCallbackManager.Subscribe<SteamFriends.FriendsListCallback>(OnFriendsList);\n\t\t\tCallbackManager.Subscribe<SteamFriends.PersonaStateCallback>(OnPersonaState);\n\n\t\t\tCallbackManager.Subscribe<SteamUnifiedMessages.ServiceMethodNotification>(OnServiceMethod);\n\n\t\t\tSteamUser = SteamClient.GetHandler<SteamUser>() ?? throw new ArgumentNullException(nameof(SteamUser));\n\t\t\tCallbackManager.Subscribe<SteamUser.LoggedOffCallback>(OnLoggedOff);\n\t\t\tCallbackManager.Subscribe<SteamUser.LoggedOnCallback>(OnLoggedOn);\n\t\t\tCallbackManager.Subscribe<SteamUser.LoginKeyCallback>(OnLoginKey);\n\t\t\tCallbackManager.Subscribe<SteamUser.UpdateMachineAuthCallback>(OnMachineAuth);\n\t\t\tCallbackManager.Subscribe<SteamUser.WalletInfoCallback>(OnWalletUpdate);\n\n\t\t\tCallbackManager.Subscribe<ArchiHandler.PlayingSessionStateCallback>(OnPlayingSessionState);\n\t\t\tCallbackManager.Subscribe<ArchiHandler.SharedLibraryLockStatusCallback>(OnSharedLibraryLockStatus);\n\t\t\tCallbackManager.Subscribe<ArchiHandler.UserNotificationsCallback>(OnUserNotifications);\n\t\t\tCallbackManager.Subscribe<ArchiHandler.VanityURLChangedCallback>(OnVanityURLChangedCallback);\n\n\t\t\tActions = new Actions(this);\n\t\t\tCardsFarmer = new CardsFarmer(this);\n\t\t\tCommands = new Commands(this);\n\t\t\tTrading = new Trading(this);\n\n\t\t\tif (!Debugging.IsDebugBuild && ASF.GlobalConfig.Statistics) {\n\t\t\t\tStatistics = new Statistics(this);\n\t\t\t}\n\n\t\t\tHeartBeatTimer = new Timer(\n\t\t\t\tasync e => await HeartBeat().ConfigureAwait(false),\n\t\t\t\tnull,\n\t\t\t\tTimeSpan.FromMinutes(1) + TimeSpan.FromSeconds(ASF.LoadBalancingDelay * Bots.Count), // Delay\n\t\t\t\tTimeSpan.FromMinutes(1) // Period\n\t\t\t);\n\t\t}\n\n\t\tpublic async ValueTask DisposeAsync() {\n\t\t\t// Those are objects that are always being created if constructor doesn't throw exception\n\t\t\tArchiWebHandler.Dispose();\n\t\t\tBotDatabase.Dispose();\n\t\t\tCallbackSemaphore.Dispose();\n\t\t\tGamesRedeemerInBackgroundSemaphore.Dispose();\n\t\t\tInitializationSemaphore.Dispose();\n\t\t\tMessagingSemaphore.Dispose();\n\t\t\tTrading.Dispose();\n\n\t\t\tawait Actions.DisposeAsync().ConfigureAwait(false);\n\t\t\tawait CardsFarmer.DisposeAsync().ConfigureAwait(false);\n\t\t\tawait HeartBeatTimer.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t// Those are objects that might be null and the check should be in-place\n\t\t\tif (ConnectionFailureTimer != null) {\n\t\t\t\tawait ConnectionFailureTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (GamesRedeemerInBackgroundTimer != null) {\n\t\t\t\tawait GamesRedeemerInBackgroundTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (PlayingWasBlockedTimer != null) {\n\t\t\t\tawait PlayingWasBlockedTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (SendItemsTimer != null) {\n\t\t\t\tawait SendItemsTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (Statistics != null) {\n\t\t\t\tawait Statistics.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (SteamSaleEvent != null) {\n\t\t\t\tawait SteamSaleEvent.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic static Bot? GetBot(string botName) {\n\t\t\tif (string.IsNullOrEmpty(botName) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (Bots.TryGetValue(botName, out Bot? targetBot)) {\n\t\t\t\treturn targetBot;\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(botName, out ulong steamID) || (steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn Bots.Values.FirstOrDefault(bot => bot.SteamID == steamID);\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic static HashSet<Bot>? GetBots(string args) {\n\t\t\tif (string.IsNullOrEmpty(args) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(args) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tstring[] botNames = args.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tHashSet<Bot> result = new HashSet<Bot>();\n\n\t\t\tforeach (string botName in botNames) {\n\t\t\t\tif (botName.Equals(SharedInfo.ASF, StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tIEnumerable<Bot> allBots = Bots.OrderBy(bot => bot.Key, BotsComparer).Select(bot => bot.Value);\n\t\t\t\t\tresult.UnionWith(allBots);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (botName.Contains(\"..\")) {\n\t\t\t\t\tstring[] botRange = botName.Split(new[] { \"..\" }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\t\tif (botRange.Length == 2) {\n\t\t\t\t\t\tBot? firstBot = GetBot(botRange[0]);\n\n\t\t\t\t\t\tif (firstBot != null) {\n\t\t\t\t\t\t\tBot? lastBot = GetBot(botRange[1]);\n\n\t\t\t\t\t\t\tif (lastBot != null) {\n\t\t\t\t\t\t\t\tforeach (Bot bot in Bots.OrderBy(bot => bot.Key, BotsComparer).Select(bot => bot.Value).SkipWhile(bot => bot != firstBot)) {\n\t\t\t\t\t\t\t\t\tresult.Add(bot);\n\n\t\t\t\t\t\t\t\t\tif (bot == lastBot) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (botName.StartsWith(\"r!\", StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tstring botsPattern = botName.Substring(2);\n\n\t\t\t\t\tRegexOptions botsRegex = RegexOptions.None;\n\n\t\t\t\t\tif ((BotsComparer == StringComparer.InvariantCulture) || (BotsComparer == StringComparer.Ordinal)) {\n\t\t\t\t\t\tbotsRegex |= RegexOptions.CultureInvariant;\n\t\t\t\t\t} else if ((BotsComparer == StringComparer.InvariantCultureIgnoreCase) || (BotsComparer == StringComparer.OrdinalIgnoreCase)) {\n\t\t\t\t\t\tbotsRegex |= RegexOptions.CultureInvariant | RegexOptions.IgnoreCase;\n\t\t\t\t\t}\n\n\t\t\t\t\tRegex regex;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tregex = new Regex(botsPattern, botsRegex);\n\t\t\t\t\t} catch (ArgumentException e) {\n\t\t\t\t\t\tASF.ArchiLogger.LogGenericWarningException(e);\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tIEnumerable<Bot> regexMatches = Bots.Where(kvp => regex.IsMatch(kvp.Key)).Select(kvp => kvp.Value);\n\t\t\t\t\tresult.UnionWith(regexMatches);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tBot? singleBot = GetBot(botName);\n\n\t\t\t\tif (singleBot == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresult.Add(singleBot);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic async Task<byte?> GetTradeHoldDuration(ulong steamID, ulong tradeID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (tradeID == 0) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(tradeID) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (SteamFriends.GetFriendRelationship(steamID) == EFriendRelationship.Friend) {\n\t\t\t\tbyte? tradeHoldDurationForUser = await ArchiWebHandler.GetTradeHoldDurationForUser(steamID).ConfigureAwait(false);\n\n\t\t\t\tif (tradeHoldDurationForUser.HasValue) {\n\t\t\t\t\treturn tradeHoldDurationForUser;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBot? targetBot = Bots.Values.FirstOrDefault(bot => bot.SteamID == steamID);\n\n\t\t\tif (targetBot?.IsConnectedAndLoggedOn == true) {\n\t\t\t\tstring? targetTradeToken = await targetBot.ArchiHandler.GetTradeToken().ConfigureAwait(false);\n\n\t\t\t\tif (!string.IsNullOrEmpty(targetTradeToken)) {\n\t\t\t\t\tbyte? tradeHoldDurationForUser = await ArchiWebHandler.GetTradeHoldDurationForUser(steamID, targetTradeToken).ConfigureAwait(false);\n\n\t\t\t\t\tif (tradeHoldDurationForUser.HasValue) {\n\t\t\t\t\t\treturn tradeHoldDurationForUser;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await ArchiWebHandler.GetTradeHoldDurationForTrade(tradeID).ConfigureAwait(false);\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic bool HasPermission(ulong steamID, BotConfig.EPermission permission) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (permission == BotConfig.EPermission.None) || !Enum.IsDefined(typeof(BotConfig.EPermission), permission)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(permission));\n\t\t\t}\n\n\t\t\tif (ASF.IsOwner(steamID)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn permission switch {\n\t\t\t\tBotConfig.EPermission.FamilySharing when SteamFamilySharingIDs.Contains(steamID) => true,\n\t\t\t\t_ => BotConfig.SteamUserPermissions.TryGetValue(steamID, out BotConfig.EPermission realPermission) && (realPermission >= permission)\n\t\t\t};\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic bool SetUserInput(ASF.EUserInputType inputType, string inputValue) {\n\t\t\tif ((inputType == ASF.EUserInputType.None) || !Enum.IsDefined(typeof(ASF.EUserInputType), inputType) || string.IsNullOrEmpty(inputValue)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(inputType) + \" || \" + nameof(inputValue));\n\t\t\t}\n\n\t\t\t// This switch should cover ONLY bot properties\n\t\t\tswitch (inputType) {\n\t\t\t\tcase ASF.EUserInputType.Login:\n\t\t\t\t\tBotConfig.SteamLogin = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.Password:\n\t\t\t\t\tBotConfig.DecryptedSteamPassword = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.SteamGuard:\n\t\t\t\t\tif (inputValue.Length != 5) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tAuthCode = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.SteamParentalCode:\n\t\t\t\t\tif (inputValue.Length != BotConfig.SteamParentalCodeLength) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tBotConfig.SteamParentalCode = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.TwoFactorAuthentication:\n\t\t\t\t\tswitch (inputValue.Length) {\n\t\t\t\t\t\tcase MobileAuthenticator.BackupCodeDigits:\n\t\t\t\t\t\tcase MobileAuthenticator.CodeDigits:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tinputValue = inputValue.ToUpperInvariant();\n\n\t\t\t\t\tif (inputValue.Any(character => !MobileAuthenticator.CodeCharacters.Contains(character))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tTwoFactorCode = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(nameof(inputType));\n\t\t\t}\n\n\t\t\tif (RequiredInput == inputType) {\n\t\t\t\tRequiredInput = ASF.EUserInputType.None;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal void AddGamesToRedeemInBackground(IOrderedDictionary gamesToRedeemInBackground) {\n\t\t\tif ((gamesToRedeemInBackground == null) || (gamesToRedeemInBackground.Count == 0)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(gamesToRedeemInBackground));\n\t\t\t}\n\n\t\t\tBotDatabase.AddGamesToRedeemInBackground(gamesToRedeemInBackground);\n\n\t\t\tif ((GamesRedeemerInBackgroundTimer == null) && BotDatabase.HasGamesToRedeemInBackground && IsConnectedAndLoggedOn) {\n\t\t\t\tUtilities.InBackground(RedeemGamesInBackground);\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task<bool> DeleteAllRelatedFiles() {\n\t\t\tawait BotDatabase.MakeReadOnly().ConfigureAwait(false);\n\n\t\t\tforeach (string filePath in RelatedFiles.Select(file => file.FilePath).Where(File.Exists)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(filePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal bool DeleteRedeemedKeysFiles() {\n\t\t\tstring unusedKeysFilePath = GetFilePath(EFileType.KeysToRedeemUnused);\n\n\t\t\tif (string.IsNullOrEmpty(unusedKeysFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(unusedKeysFilePath));\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (File.Exists(unusedKeysFilePath)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(unusedKeysFilePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring usedKeysFilePath = GetFilePath(EFileType.KeysToRedeemUsed);\n\n\t\t\tif (string.IsNullOrEmpty(usedKeysFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(usedKeysFilePath));\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (File.Exists(usedKeysFilePath)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(usedKeysFilePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal static string FormatBotResponse(string response, string botName) {\n\t\t\tif (string.IsNullOrEmpty(response) || string.IsNullOrEmpty(botName)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response) + \" || \" + nameof(botName));\n\t\t\t}\n\n\t\t\treturn Environment.NewLine + \"<\" + botName + \"> \" + response;\n\t\t}\n\n\t\tinternal async Task<(uint PlayableAppID, DateTime IgnoredUntil, bool IgnoredGlobally)> GetAppDataForIdling(uint appID, float hoursPlayed, bool allowRecursiveDiscovery = true, bool optimisticDiscovery = true) {\n\t\t\tif ((appID == 0) || (hoursPlayed < 0)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(appID) + \" || \" + nameof(hoursPlayed));\n\n\t\t\t\treturn (0, DateTime.MaxValue, true);\n\t\t\t}\n\n\t\t\tHashSet<uint>? packageIDs = ASF.GlobalDatabase?.GetPackageIDs(appID, OwnedPackageIDs.Keys);\n\n\t\t\tif ((packageIDs == null) || (packageIDs.Count == 0)) {\n\t\t\t\treturn (0, DateTime.MaxValue, true);\n\t\t\t}\n\n\t\t\tif ((hoursPlayed < CardsFarmer.HoursForRefund) && !BotConfig.IdleRefundableGames) {\n\t\t\t\tDateTime mostRecent = DateTime.MinValue;\n\n\t\t\t\tforeach (uint packageID in packageIDs) {\n\t\t\t\t\tif (!OwnedPackageIDs.TryGetValue(packageID, out (EPaymentMethod PaymentMethod, DateTime TimeCreated) packageData)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((packageData.PaymentMethod > EPaymentMethod.None) && IsRefundable(packageData.PaymentMethod) && (packageData.TimeCreated > mostRecent)) {\n\t\t\t\t\t\tmostRecent = packageData.TimeCreated;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mostRecent > DateTime.MinValue) {\n\t\t\t\t\tDateTime playableIn = mostRecent.AddDays(CardsFarmer.DaysForRefund);\n\n\t\t\t\t\tif (playableIn > DateTime.UtcNow) {\n\t\t\t\t\t\treturn (0, playableIn, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSteamApps.PICSTokensCallback? tokenCallback = null;\n\n\t\t\tfor (byte i = 0; (i < WebBrowser.MaxTries) && (tokenCallback == null) && IsConnectedAndLoggedOn; i++) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenCallback = await SteamApps.PICSGetAccessTokens(appID, null).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokenCallback == null) {\n\t\t\t\treturn (optimisticDiscovery ? appID : 0, DateTime.MinValue, true);\n\t\t\t}\n\n\t\t\tSteamApps.PICSRequest request = new SteamApps.PICSRequest(appID, tokenCallback.AppTokens.TryGetValue(appID, out ulong accessToken) ? accessToken : 0, false);\n\n\t\t\tAsyncJobMultiple<SteamApps.PICSProductInfoCallback>.ResultSet? productInfoResultSet = null;\n\n\t\t\tfor (byte i = 0; (i < WebBrowser.MaxTries) && (productInfoResultSet == null) && IsConnectedAndLoggedOn; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tproductInfoResultSet = await SteamApps.PICSGetProductInfo(request.ToEnumerable(), Enumerable.Empty<SteamApps.PICSRequest>()).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (productInfoResultSet?.Results == null) {\n\t\t\t\treturn (optimisticDiscovery ? appID : 0, DateTime.MinValue, true);\n\t\t\t}\n\n\t\t\tforeach (Dictionary<uint, SteamApps.PICSProductInfoCallback.PICSProductInfo> productInfoApps in productInfoResultSet.Results.Select(result => result.Apps)) {\n\t\t\t\tif (!productInfoApps.TryGetValue(appID, out SteamApps.PICSProductInfoCallback.PICSProductInfo? productInfoApp)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tKeyValue productInfo = productInfoApp.KeyValues;\n\n\t\t\t\tif (productInfo == KeyValue.Invalid) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(productInfo));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tKeyValue commonProductInfo = productInfo[\"common\"];\n\n\t\t\t\tif (commonProductInfo == KeyValue.Invalid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstring? releaseState = commonProductInfo[\"ReleaseState\"].AsString();\n\n\t\t\t\tif (!string.IsNullOrEmpty(releaseState)) {\n\t\t\t\t\t// We must convert this to uppercase, since Valve doesn't stick to any convention and we can have a case mismatch\n\t\t\t\t\tswitch (releaseState!.ToUpperInvariant()) {\n\t\t\t\t\t\tcase \"RELEASED\":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"PRELOADONLY\":\n\t\t\t\t\t\tcase \"PRERELEASE\":\n\t\t\t\t\t\t\treturn (0, DateTime.MaxValue, true);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(releaseState), releaseState));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstring? type = commonProductInfo[\"type\"].AsString();\n\n\t\t\t\tif (string.IsNullOrEmpty(type)) {\n\t\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t\t}\n\n\t\t\t\t// We must convert this to uppercase, since Valve doesn't stick to any convention and we can have a case mismatch\n\t\t\t\tswitch (type!.ToUpperInvariant()) {\n\t\t\t\t\tcase \"APPLICATION\":\n\t\t\t\t\tcase \"EPISODE\":\n\t\t\t\t\tcase \"GAME\":\n\t\t\t\t\tcase \"MOD\":\n\t\t\t\t\tcase \"MOVIE\":\n\t\t\t\t\tcase \"SERIES\":\n\t\t\t\t\tcase \"TOOL\":\n\t\t\t\t\tcase \"VIDEO\":\n\t\t\t\t\t\t// Types that can be idled\n\t\t\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t\t\tcase \"ADVERTISING\":\n\t\t\t\t\tcase \"DEMO\":\n\t\t\t\t\tcase \"DLC\":\n\t\t\t\t\tcase \"GUIDE\":\n\t\t\t\t\tcase \"HARDWARE\":\n\t\t\t\t\tcase \"MUSIC\":\n\t\t\t\t\t\t// Types that can't be idled\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(type), type));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!allowRecursiveDiscovery) {\n\t\t\t\t\treturn (0, DateTime.MinValue, true);\n\t\t\t\t}\n\n\t\t\t\tstring? listOfDlc = productInfo[\"extended\"][\"listofdlc\"].AsString();\n\n\t\t\t\tif (string.IsNullOrEmpty(listOfDlc)) {\n\t\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t\t}\n\n\t\t\t\tstring[] dlcAppIDsTexts = listOfDlc!.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\tforeach (string dlcAppIDsText in dlcAppIDsTexts) {\n\t\t\t\t\tif (!uint.TryParse(dlcAppIDsText, out uint dlcAppID) || (dlcAppID == 0)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(dlcAppID));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t(uint playableAppID, _, _) = await GetAppDataForIdling(dlcAppID, hoursPlayed, false, false).ConfigureAwait(false);\n\n\t\t\t\t\tif (playableAppID != 0) {\n\t\t\t\t\t\treturn (playableAppID, DateTime.MinValue, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t}\n\n\t\t\treturn ((productInfoResultSet.Complete && !productInfoResultSet.Failed) || optimisticDiscovery ? appID : 0, DateTime.MinValue, true);\n\t\t}\n\n\t\tinternal static string GetFilePath(string botName, EFileType fileType) {\n\t\t\tif (string.IsNullOrEmpty(botName) || !Enum.IsDefined(typeof(EFileType), fileType)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(fileType));\n\t\t\t}\n\n\t\t\tstring botPath = Path.Combine(SharedInfo.ConfigDirectory, botName);\n\n\t\t\treturn fileType switch {\n\t\t\t\tEFileType.Config => botPath + SharedInfo.JsonConfigExtension,\n\t\t\t\tEFileType.Database => botPath + SharedInfo.DatabaseExtension,\n\t\t\t\tEFileType.KeysToRedeem => botPath + SharedInfo.KeysExtension,\n\t\t\t\tEFileType.KeysToRedeemUnused => botPath + SharedInfo.KeysExtension + SharedInfo.KeysUnusedExtension,\n\t\t\t\tEFileType.KeysToRedeemUsed => botPath + SharedInfo.KeysExtension + SharedInfo.KeysUsedExtension,\n\t\t\t\tEFileType.MobileAuthenticator => botPath + SharedInfo.MobileAuthenticatorExtension,\n\t\t\t\tEFileType.SentryFile => botPath + SharedInfo.SentryHashExtension,\n\t\t\t\t_ => throw new ArgumentOutOfRangeException(nameof(fileType))\n\t\t\t};\n\t\t}\n\n\t\tinternal async Task<HashSet<uint>?> GetMarketableAppIDs() => await ArchiWebHandler.GetAppList().ConfigureAwait(false);\n\n\t\tinternal async Task<Dictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)>?> GetPackagesData(IReadOnlyCollection<uint> packageIDs) {\n\t\t\tif ((packageIDs == null) || (packageIDs.Count == 0) || (ASF.GlobalDatabase == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(packageIDs) + \" || \" + nameof(ASF.GlobalDatabase));\n\t\t\t}\n\n\t\t\tHashSet<SteamApps.PICSRequest> packageRequests = new HashSet<SteamApps.PICSRequest>();\n\n\t\t\tforeach (uint packageID in packageIDs) {\n\t\t\t\tif (!ASF.GlobalDatabase.PackageAccessTokensReadOnly.TryGetValue(packageID, out ulong packageAccessToken)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tpackageRequests.Add(new SteamApps.PICSRequest(packageID, packageAccessToken, false));\n\t\t\t}\n\n\t\t\tif (packageRequests.Count == 0) {\n\t\t\t\treturn new Dictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)>(0);\n\t\t\t}\n\n\t\t\tAsyncJobMultiple<SteamApps.PICSProductInfoCallback>.ResultSet? productInfoResultSet = null;\n\n\t\t\tfor (byte i = 0; (i < WebBrowser.MaxTries) && (productInfoResultSet == null) && IsConnectedAndLoggedOn; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tproductInfoResultSet = await SteamApps.PICSGetProductInfo(Enumerable.Empty<SteamApps.PICSRequest>(), packageRequests).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (productInfoResultSet?.Results == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tDictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)> result = new Dictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)>();\n\n\t\t\tforeach (SteamApps.PICSProductInfoCallback.PICSProductInfo productInfo in productInfoResultSet.Results.SelectMany(productInfoResult => productInfoResult.Packages).Where(productInfoPackages => productInfoPackages.Key != 0).Select(productInfoPackages => productInfoPackages.Value)) {\n\t\t\t\tif (productInfo.KeyValues == KeyValue.Invalid) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(productInfo));\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t(uint ChangeNumber, HashSet<uint>? AppIDs) value = (productInfo.ChangeNumber, null);\n\n\t\t\t\ttry {\n\t\t\t\t\tKeyValue appIDs = productInfo.KeyValues[\"appids\"];\n\n\t\t\t\t\tif (appIDs == KeyValue.Invalid) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue.AppIDs = new HashSet<uint>(appIDs.Children.Count);\n\n\t\t\t\t\tforeach (string? appIDText in appIDs.Children.Select(app => app.Value)) {\n\t\t\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\t\t\tArchiLogger.LogNullError(nameof(appID));\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue.AppIDs.Add(appID);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tresult[productInfo.ID] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tinternal async Task<(Dictionary<string, string>? UnusedKeys, Dictionary<string, string>? UsedKeys)> GetUsedAndUnusedKeys() {\n\t\t\tstring[] files = { GetFilePath(EFileType.KeysToRedeemUnused), GetFilePath(EFileType.KeysToRedeemUsed) };\n\n\t\t\tIList<Dictionary<string, string>?> results = await Utilities.InParallel(files.Select(GetKeysFromFile)).ConfigureAwait(false);\n\n\t\t\treturn (results[0], results[1]);\n\t\t}\n\n\t\tinternal async Task<bool?> HasPublicInventory() {\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tCPrivacySettings? privacySettings = await ArchiHandler.GetPrivacySettings().ConfigureAwait(false);\n\n\t\t\tif (privacySettings == null) {\n\t\t\t\tArchiLogger.LogGenericWarning(Strings.WarningFailed);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn ((ArchiHandler.EPrivacySetting) privacySettings.privacy_state == ArchiHandler.EPrivacySetting.Public) && ((ArchiHandler.EPrivacySetting) privacySettings.privacy_state_inventory == ArchiHandler.EPrivacySetting.Public);\n\t\t}\n\n\t\tinternal async Task IdleGame(CardsFarmer.Game game) {\n\t\t\tif (game == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(game));\n\t\t\t}\n\n\t\t\tstring? gameName = null;\n\n\t\t\tif (!string.IsNullOrEmpty(BotConfig.CustomGamePlayedWhileFarming)) {\n\t\t\t\tgameName = string.Format(BotConfig.CustomGamePlayedWhileFarming!, game.AppID, game.GameName);\n\t\t\t}\n\n\t\t\tawait ArchiHandler.PlayGames(game.PlayableAppID.ToEnumerable(), gameName).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task IdleGames(IReadOnlyCollection<CardsFarmer.Game> games) {\n\t\t\tif ((games == null) || (games.Count == 0)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(games));\n\t\t\t}\n\n\t\t\tstring? gameName = null;\n\n\t\t\tif (!string.IsNullOrEmpty(BotConfig.CustomGamePlayedWhileFarming)) {\n\t\t\t\tgameName = string.Format(BotConfig.CustomGamePlayedWhileFarming!, string.Join(\", \", games.Select(game => game.AppID)), string.Join(\", \", games.Select(game => game.GameName)));\n\t\t\t}\n\n\t\t\tawait ArchiHandler.PlayGames(games.Select(game => game.PlayableAppID), gameName).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task ImportKeysToRedeem(string filePath) {\n\t\t\tif (string.IsNullOrEmpty(filePath) || !File.Exists(filePath)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(filePath));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tOrderedDictionary gamesToRedeemInBackground = new OrderedDictionary();\n\n\t\t\t\tusing (StreamReader reader = new StreamReader(filePath)) {\n\t\t\t\t\tstring? line;\n\n\t\t\t\t\twhile ((line = await reader.ReadLineAsync().ConfigureAwait(false)) != null) {\n\t\t\t\t\t\tif (line.Length == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Valid formats:\n\t\t\t\t\t\t// Key (name will be the same as key and replaced from redemption result, if possible)\n\t\t\t\t\t\t// Name + Key (user provides both, if name is equal to key, above logic is used, otherwise name is kept)\n\t\t\t\t\t\t// Name + <Ignored> + Key (BGR output format, we include extra properties in the middle, those are ignored during import)\n\t\t\t\t\t\tstring[] parsedArgs = line.Split(DefaultBackgroundKeysRedeemerSeparator, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\t\t\tif (parsedArgs.Length < 1) {\n\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, line));\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstring name = parsedArgs[0];\n\t\t\t\t\t\tstring key = parsedArgs[^1];\n\n\t\t\t\t\t\tgamesToRedeemInBackground[key] = name;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (gamesToRedeemInBackground.Count > 0) {\n\t\t\t\t\tIOrderedDictionary validGamesToRedeemInBackground = ValidateGamesToRedeemInBackground(gamesToRedeemInBackground);\n\n\t\t\t\t\tif (validGamesToRedeemInBackground.Count > 0) {\n\t\t\t\t\t\tAddGamesToRedeemInBackground(validGamesToRedeemInBackground);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFile.Delete(filePath);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t}\n\t\t}\n\n\t\tinternal static void Init(StringComparer botsComparer) {\n\t\t\tif (Bots != null) {\n\t\t\t\tASF.ArchiLogger.LogGenericError(Strings.WarningFailed);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotsComparer = botsComparer ?? throw new ArgumentNullException(nameof(botsComparer));\n\t\t\tBots = new ConcurrentDictionary<string, Bot>(botsComparer);\n\t\t}\n\n\t\tinternal bool IsBlacklistedFromIdling(uint appID) {\n\t\t\tif (appID == 0) {\n\t\t\t\tthrow new ArgumentNullException(nameof(appID));\n\t\t\t}\n\n\t\t\treturn BotDatabase.IsBlacklistedFromIdling(appID);\n\t\t}\n\n\t\tinternal bool IsBlacklistedFromTrades(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn BotDatabase.IsBlacklistedFromTrades(steamID);\n\t\t}\n\n\t\tinternal bool IsPriorityIdling(uint appID) {\n\t\t\tif (appID == 0) {\n\t\t\t\tthrow new ArgumentNullException(nameof(appID));\n\t\t\t}\n\n\t\t\treturn BotDatabase.IsPriorityIdling(appID);\n\t\t}\n\n\t\tinternal async Task OnConfigChanged(bool deleted) {\n\t\t\tif (deleted) {\n\t\t\t\tawait Destroy().ConfigureAwait(false);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring configFile = GetFilePath(EFileType.Config);\n\n\t\t\tif (string.IsNullOrEmpty(configFile)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(configFile));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotConfig? botConfig = await BotConfig.Load(configFile).ConfigureAwait(false);\n\n\t\t\tif (botConfig == null) {\n\t\t\t\tawait Destroy().ConfigureAwait(false);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (botConfig == BotConfig) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait InitializationSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\ttry {\n\t\t\t\tif (botConfig == BotConfig) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tStop(botConfig.Enabled);\n\t\t\t\tBotConfig = botConfig;\n\n\t\t\t\tawait InitModules().ConfigureAwait(false);\n\t\t\t\tInitStart();\n\t\t\t} finally {\n\t\t\t\tInitializationSemaphore.Release();\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task OnFarmingFinished(bool farmedSomething) {\n\t\t\tawait OnFarmingStopped().ConfigureAwait(false);\n\n\t\t\tif (BotConfig.SendOnFarmingFinished && (BotConfig.LootableTypes.Count > 0) && (farmedSomething || !FirstTradeSent)) {\n\t\t\t\tFirstTradeSent = true;\n\n\t\t\t\tawait Actions.SendInventory(filterFunction: item => BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (BotConfig.ShutdownOnFarmingFinished) {\n\t\t\t\tStop();\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotFarmingFinished(this, farmedSomething).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task OnFarmingStopped() {\n\t\t\tawait ResetGamesPlayed().ConfigureAwait(false);\n\t\t\tawait PluginsCore.OnBotFarmingStopped(this).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task<bool> RefreshSession() {\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSteamUser.WebAPIUserNonceCallback callback;\n\n\t\t\ttry {\n\t\t\t\tcallback = await SteamUser.RequestWebAPIUserNonce().ToLongRunningTask().ConfigureAwait(false);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\tawait Connect(true).ConfigureAwait(false);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(callback.Nonce)) {\n\t\t\t\tawait Connect(true).ConfigureAwait(false);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (await ArchiWebHandler.Init(SteamID, SteamClient.Universe, callback.Nonce, SteamParentalActive ? BotConfig.SteamParentalCode : null).ConfigureAwait(false)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tawait Connect(true).ConfigureAwait(false);\n\n\t\t\treturn false;\n\t\t}\n\n\t\tinternal static async Task RegisterBot(string botName) {\n\t\t\tif (string.IsNullOrEmpty(botName) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (Bots.ContainsKey(botName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring configFilePath = GetFilePath(botName, EFileType.Config);\n\n\t\t\tif (string.IsNullOrEmpty(configFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(configFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotConfig? botConfig = await BotConfig.Load(configFilePath).ConfigureAwait(false);\n\n\t\t\tif (botConfig == null) {\n\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.ErrorBotConfigInvalid, configFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Debugging.IsDebugConfigured) {\n\t\t\t\tASF.ArchiLogger.LogGenericDebug(configFilePath + \": \" + JsonConvert.SerializeObject(botConfig, Formatting.Indented));\n\t\t\t}\n\n\t\t\tstring databaseFilePath = GetFilePath(botName, EFileType.Database);\n\n\t\t\tif (string.IsNullOrEmpty(databaseFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(databaseFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotDatabase? botDatabase = await BotDatabase.CreateOrLoad(databaseFilePath).ConfigureAwait(false);\n\n\t\t\tif (botDatabase == null) {\n\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.ErrorDatabaseInvalid, databaseFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Debugging.IsDebugConfigured) {\n\t\t\t\tASF.ArchiLogger.LogGenericDebug(databaseFilePath + \": \" + JsonConvert.SerializeObject(botDatabase, Formatting.Indented));\n\t\t\t}\n\n\t\t\tBot bot;\n\n\t\t\tawait BotsSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\ttry {\n\t\t\t\tif (Bots.ContainsKey(botName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbot = new Bot(botName, botConfig, botDatabase);\n\n\t\t\t\tif (!Bots.TryAdd(botName, bot)) {\n\t\t\t\t\tASF.ArchiLogger.LogNullError(nameof(bot));\n\n\t\t\t\t\tawait bot.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tBotsSemaphore.Release();\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotInit(bot).ConfigureAwait(false);\n\n\t\t\tHashSet<ClientMsgHandler>? customHandlers = await PluginsCore.OnBotSteamHandlersInit(bot).ConfigureAwait(false);\n\n\t\t\tif ((customHandlers != null) && (customHandlers.Count > 0)) {\n\t\t\t\tforeach (ClientMsgHandler customHandler in customHandlers) {\n\t\t\t\t\tbot.SteamClient.AddHandler(customHandler);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotSteamCallbacksInit(bot, bot.CallbackManager).ConfigureAwait(false);\n\n\t\t\tawait bot.InitModules().ConfigureAwait(false);\n\n\t\t\tbot.InitStart();\n\t\t}\n\n\t\tinternal async Task<bool> Rename(string newBotName) {\n\t\t\tif (string.IsNullOrEmpty(newBotName) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(newBotName) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (newBotName.Equals(SharedInfo.ASF) || Bots.ContainsKey(newBotName)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (KeepRunning) {\n\t\t\t\tStop(true);\n\t\t\t}\n\n\t\t\tawait BotDatabase.MakeReadOnly().ConfigureAwait(false);\n\n\t\t\t// We handle the config file last as it'll trigger new bot creation\n\t\t\tforeach ((string filePath, EFileType fileType) in RelatedFiles.Where(file => File.Exists(file.FilePath)).OrderByDescending(file => file.FileType != EFileType.Config)) {\n\t\t\t\tstring newFilePath = GetFilePath(newBotName, fileType);\n\n\t\t\t\tif (string.IsNullOrEmpty(newFilePath)) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(newFilePath));\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tFile.Move(filePath, newFilePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal void RequestPersonaStateUpdate() {\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSteamFriends.RequestFriendInfo(SteamID, EClientPersonaStateFlag.PlayerName | EClientPersonaStateFlag.Presence);\n\t\t}\n\n\t\tinternal async Task<bool> SendMessage(ulong steamID, string message) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(true, message, steamID: steamID);\n\n\t\t\tstring? steamMessagePrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.SteamMessagePrefix : GlobalConfig.DefaultSteamMessagePrefix;\n\t\t\tushort maxMessageLength = (ushort) (MaxMessageLength - ReservedMessageLength - (steamMessagePrefix?.Length ?? 0));\n\n\t\t\t// We must escape our message prior to sending it\n\t\t\tmessage = Escape(message);\n\n\t\t\tint i = 0;\n\n\t\t\twhile (i < message.Length) {\n\t\t\t\tint partLength;\n\t\t\t\tbool copyNewline = false;\n\n\t\t\t\t// ReSharper disable ArrangeMissingParentheses - conflict with Roslyn\n\t\t\t\tif (message.Length - i > maxMessageLength) {\n\t\t\t\t\tint lastNewLine = message.LastIndexOf(Environment.NewLine, i + maxMessageLength - Environment.NewLine.Length, maxMessageLength - Environment.NewLine.Length, StringComparison.Ordinal);\n\n\t\t\t\t\tif (lastNewLine > i) {\n\t\t\t\t\t\tpartLength = lastNewLine - i + Environment.NewLine.Length;\n\t\t\t\t\t\tcopyNewline = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartLength = maxMessageLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpartLength = message.Length - i;\n\t\t\t\t}\n\n\t\t\t\t// If our message is of max length and ends with a single '\\' then we can't split it here, it escapes the next character\n\t\t\t\tif ((partLength >= maxMessageLength) && (message[i + partLength - 1] == '\\\\') && (message[i + partLength - 2] != '\\\\')) {\n\t\t\t\t\t// Instead, we'll cut this message one char short and include the rest in next iteration\n\t\t\t\t\tpartLength--;\n\t\t\t\t}\n\n\t\t\t\t// ReSharper restore ArrangeMissingParentheses\n\t\t\t\tstring messagePart = message.Substring(i, partLength);\n\n\t\t\t\tmessagePart = steamMessagePrefix + (i > 0 ? \"\u2026\" : \"\") + messagePart + (maxMessageLength < message.Length - i ? \"\u2026\" : \"\");\n\n\t\t\t\tawait MessagingSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\t\ttry {\n\t\t\t\t\tbool sent = false;\n\n\t\t\t\t\tfor (byte j = 0; (j < WebBrowser.MaxTries) && !sent && IsConnectedAndLoggedOn; j++) {\n\t\t\t\t\t\t// We add a one-second delay here to avoid Steam screwup in form of a ghost notification\n\t\t\t\t\t\t// The exact cause is unknown, but the theory is that Steam is confused when dealing with more than 1 message per second from the same user\n\t\t\t\t\t\tawait Task.Delay(1000).ConfigureAwait(false);\n\n\t\t\t\t\t\tEResult result = await ArchiHandler.SendMessage(steamID, messagePart).ConfigureAwait(false);\n\n\t\t\t\t\t\tswitch (result) {\n\t\t\t\t\t\t\tcase EResult.Busy:\n\t\t\t\t\t\t\tcase EResult.Fail:\n\t\t\t\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\t\t\t\tcase EResult.Timeout:\n\t\t\t\t\t\t\t\tawait Task.Delay(5000).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcase EResult.OK:\n\t\t\t\t\t\t\t\tsent = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result), result));\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.WarningFailed);\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tMessagingSemaphore.Release();\n\t\t\t\t}\n\n\t\t\t\ti += partLength - (copyNewline ? Environment.NewLine.Length : 0);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal async Task<bool> SendMessage(ulong chatGroupID, ulong chatID, string message) {\n\t\t\tif ((chatGroupID == 0) || (chatID == 0) || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(chatGroupID) + \" || \" + nameof(chatID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(true, message, chatGroupID, chatID);\n\n\t\t\tstring? steamMessagePrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.SteamMessagePrefix : GlobalConfig.DefaultSteamMessagePrefix;\n\t\t\tushort maxMessageLength = (ushort) (MaxMessageLength - ReservedMessageLength - (steamMessagePrefix?.Length ?? 0));\n\n\t\t\t// We must escape our message prior to sending it\n\t\t\tmessage = Escape(message);\n\n\t\t\tint i = 0;\n\n\t\t\t// ReSharper disable ArrangeMissingParentheses - conflict with Roslyn\n\t\t\twhile (i < message.Length) {\n\t\t\t\tint partLength;\n\t\t\t\tbool copyNewline = false;\n\n\t\t\t\tif (message.Length - i > maxMessageLength) {\n\t\t\t\t\tint lastNewLine = message.LastIndexOf(Environment.NewLine, i + maxMessageLength - Environment.NewLine.Length, maxMessageLength - Environment.NewLine.Length, StringComparison.Ordinal);\n\n\t\t\t\t\tif (lastNewLine > i) {\n\t\t\t\t\t\tpartLength = lastNewLine - i + Environment.NewLine.Length;\n\t\t\t\t\t\tcopyNewline = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartLength = maxMessageLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpartLength = message.Length - i;\n\t\t\t\t}\n\n\t\t\t\t// If our message is of max length and ends with a single '\\' then we can't split it here, it escapes the next character\n\t\t\t\tif ((partLength >= maxMessageLength) && (message[i + partLength - 1] == '\\\\') && (message[i + partLength - 2] != '\\\\')) {\n\t\t\t\t\t// Instead, we'll cut this message one char short and include the rest in next iteration\n\t\t\t\t\tpartLength--;\n\t\t\t\t}\n\n\t\t\t\t// ReSharper restore ArrangeMissingParentheses\n\t\t\t\tstring messagePart = message.Substring(i, partLength);\n\n\t\t\t\tmessagePart = steamMessagePrefix + (i > 0 ? \"\u2026\" : \"\") + messagePart + (maxMessageLength < message.Length - i ? \"\u2026\" : \"\");\n\n\t\t\t\tawait MessagingSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\t\ttry {\n\t\t\t\t\tbool sent = false;\n\n\t\t\t\t\tfor (byte j = 0; (j < WebBrowser.MaxTries) && !sent && IsConnectedAndLoggedOn; j++) {\n\t\t\t\t\t\tEResult result = await ArchiHandler.SendMessage(chatGroupID, chatID, messagePart).ConfigureAwait(false);\n\n\t\t\t\t\t\tswitch (result) {\n\t\t\t\t\t\t\tcase EResult.Busy:\n\t\t\t\t\t\t\tcase EResult.Fail:\n\t\t\t\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\t\t\t\tcase EResult.Timeout:\n\t\t\t\t\t\t\t\tawait Task.Delay(5000).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcase EResult.OK:\n\t\t\t\t\t\t\t\tsent = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result), result));\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.WarningFailed);\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tMessagingSemaphore.Release();\n\t\t\t\t}\n\n\t\t\t\ti += partLength - (copyNewline ? Environment.NewLine.Length : 0);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal async Task<bool> SendTypingMessage(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn await ArchiHandler.SendTypingStatus(steamID).ConfigureAwait(false) == EResult.OK;\n\t\t}\n\n\t\tinternal async Task Start() {\n\t\t\tif (KeepRunning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tKeepRunning = true;\n\t\t\tUtilities.InBackground(HandleCallbacks, true);\n\t\t\tArchiLogger.LogGenericInfo(Strings.Starting);\n\n\t\t\t// Support and convert 2FA files\n\t\t\tif (!HasMobileAuthenticator) {\n\t\t\t\tstring mobileAuthenticatorFilePath = GetFilePath(EFileType.MobileAuthenticator);\n\n\t\t\t\tif (string.IsNullOrEmpty(mobileAuthenticatorFilePath)) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(mobileAuthenticatorFilePath));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (File.Exists(mobileAuthenticatorFilePath)) {\n\t\t\t\t\tawait ImportAuthenticator(mobileAuthenticatorFilePath).ConfigureAwait(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring keysToRedeemFilePath = GetFilePath(EFileType.KeysToRedeem);\n\n\t\t\tif (string.IsNullOrEmpty(keysToRedeemFilePath)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(keysToRedeemFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (File.Exists(keysToRedeemFilePath)) {\n\t\t\t\tawait ImportKeysToRedeem(keysToRedeemFilePath).ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tawait Connect().ConfigureAwait(false);\n\t\t}\n\n\t\tinternal void Stop(bool skipShutdownEvent = false) {\n\t\t\tif (!KeepRunning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tKeepRunning = false;\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotStopping);\n\n\t\t\tif (SteamClient.IsConnected) {\n\t\t\t\tDisconnect();\n\t\t\t}\n\n\t\t\tif (!skipShutdownEvent) {\n\t\t\t\tUtilities.InBackground(Events.OnBotShutdown);\n\t\t\t}\n\t\t}\n\n#pragma warning disable CS8605\n\t\tinternal static IOrderedDictionary ValidateGamesToRedeemInBackground(IOrderedDictionary gamesToRedeemInBackground) {\n\t\t\tif ((gamesToRedeemInBackground == null) || (gamesToRedeemInBackground.Count == 0)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(gamesToRedeemInBackground));\n\t\t\t}\n\n\t\t\tHashSet<object> invalidKeys = new HashSet<object>();\n\n\t\t\tforeach (DictionaryEntry game in gamesToRedeemInBackground) {\n\t\t\t\tbool invalid = false;\n\n\t\t\t\tstring? key = game.Key as string;\n\n\t\t\t\tif (string.IsNullOrEmpty(key)) {\n\t\t\t\t\tinvalid = true;\n\t\t\t\t\tASF.ArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, nameof(key)));\n\t\t\t\t} else if (!Utilities.IsValidCdKey(key!)) {\n\t\t\t\t\tinvalid = true;\n\t\t\t\t\tASF.ArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, key));\n\t\t\t\t}\n\n\t\t\t\tstring? name = game.Value as string;\n\n\t\t\t\tif (string.IsNullOrEmpty(name)) {\n\t\t\t\t\tinvalid = true;\n\t\t\t\t\tASF.ArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, nameof(name)));\n\t\t\t\t}\n\n\t\t\t\tif (invalid && (key != null)) {\n\t\t\t\t\tinvalidKeys.Add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (invalidKeys.Count > 0) {\n\t\t\t\tforeach (string invalidKey in invalidKeys) {\n\t\t\t\t\tgamesToRedeemInBackground.Remove(invalidKey);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn gamesToRedeemInBackground;\n\t\t}\n#pragma warning restore CS8605\n\n\t\tprivate async Task CheckOccupationStatus() {\n\t\t\tStopPlayingWasBlockedTimer();\n\n\t\t\tif (!IsPlayingPossible) {\n\t\t\t\tPlayingWasBlocked = true;\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotAccountOccupied);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (PlayingWasBlocked && (PlayingWasBlockedTimer == null)) {\n\t\t\t\tInitPlayingWasBlockedTimer();\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotAccountFree);\n\n\t\t\tif (!await CardsFarmer.Resume(false).ConfigureAwait(false)) {\n\t\t\t\tawait ResetGamesPlayed().ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task Connect(bool force = false) {\n\t\t\tif (!force && (!KeepRunning || SteamClient.IsConnected)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait LimitLoginRequestsAsync().ConfigureAwait(false);\n\n\t\t\tif (!force && (!KeepRunning || SteamClient.IsConnected)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotConnecting);\n\t\t\tInitConnectionFailureTimer();\n\t\t\tSteamClient.Connect();\n\t\t}\n\n\t\tprivate async Task Destroy(bool force = false) {\n\t\t\tif (Bots == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(Bots));\n\t\t\t}\n\n\t\t\tif (KeepRunning) {\n\t\t\t\tif (!force) {\n\t\t\t\t\tStop();\n\t\t\t\t} else {\n\t\t\t\t\t// Stop() will most likely block due to connection freeze, don't wait for it\n\t\t\t\t\tUtilities.InBackground(() => Stop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBots.TryRemove(BotName, out _);\n\t\t\tawait PluginsCore.OnBotDestroy(this).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void Disconnect() {\n\t\t\tStopConnectionFailureTimer();\n\t\t\tSteamClient.Disconnect();\n\t\t}\n\n\t\tprivate static string Escape(string message) {\n\t\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t\t}\n\n\t\t\treturn message.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"[\", \"\\\\[\");\n\t\t}\n\n\t\tprivate string GetFilePath(EFileType fileType) {\n\t\t\tif (!Enum.IsDefined(typeof(EFileType), fileType)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(fileType));\n\t\t\t}\n\n\t\t\treturn GetFilePath(BotName, fileType);\n\t\t}\n\n\t\tprivate async Task<Dictionary<string, string>?> GetKeysFromFile(string filePath) {\n\t\t\tif (string.IsNullOrEmpty(filePath)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(filePath));\n\t\t\t}\n\n\t\t\tif (!File.Exists(filePath)) {\n\t\t\t\treturn new Dictionary<string, string>(0, StringComparer.Ordinal);\n\t\t\t}\n\n\t\t\tDictionary<string, string> keys = new Dictionary<string, string>(StringComparer.Ordinal);\n\n\t\t\ttry {\n\t\t\t\tusing StreamReader reader = new StreamReader(filePath);\n\n\t\t\t\tstring? line;\n\n\t\t\t\twhile ((line = await reader.ReadLineAsync().ConfigureAwait(false)) != null) {\n\t\t\t\t\tif (line.Length == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring[] parsedArgs = line.Split(DefaultBackgroundKeysRedeemerSeparator, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\t\tif (parsedArgs.Length < 3) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, line));\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring key = parsedArgs[^1];\n\n\t\t\t\t\tif (!Utilities.IsValidCdKey(key)) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, key));\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring name = parsedArgs[0];\n\t\t\t\t\tkeys[key] = name;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn keys;\n\t\t}\n\n\t\tprivate void HandleCallbacks() {\n\t\t\tTimeSpan timeSpan = TimeSpan.FromMilliseconds(CallbackSleep);\n\n\t\t\twhile (KeepRunning || SteamClient.IsConnected) {\n\t\t\t\tif (!CallbackSemaphore.Wait(0)) {\n\t\t\t\t\tif (Debugging.IsUserDebugging) {\n\t\t\t\t\t\tArchiLogger.LogGenericDebug(string.Format(Strings.WarningFailedWithError, nameof(CallbackSemaphore)));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tCallbackManager.RunWaitAllCallbacks(timeSpan);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t\t} finally {\n\t\t\t\t\tCallbackSemaphore.Release();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task HeartBeat() {\n\t\t\tif (ASF.GlobalConfig == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(ASF.GlobalConfig));\n\t\t\t}\n\n\t\t\tif (!KeepRunning || !IsConnectedAndLoggedOn || (HeartBeatFailures == byte.MaxValue)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (DateTime.UtcNow.Subtract(ArchiHandler.LastPacketReceived).TotalSeconds > ASF.GlobalConfig.ConnectionTimeout) {\n\t\t\t\t\tawait SteamFriends.RequestProfileInfo(SteamID).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t}\n\n\t\t\t\tHeartBeatFailures = 0;\n\n\t\t\t\tif (Statistics != null) {\n\t\t\t\t\tUtilities.InBackground(Statistics.OnHeartBeat);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericDebuggingException(e);\n\n\t\t\t\tif (!KeepRunning || !IsConnectedAndLoggedOn || (HeartBeatFailures == byte.MaxValue)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (++HeartBeatFailures >= (byte) Math.Ceiling(ASF.GlobalConfig.ConnectionTimeout / 10.0)) {\n\t\t\t\t\tHeartBeatFailures = byte.MaxValue;\n\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.BotConnectionLost);\n\t\t\t\t\tUtilities.InBackground(() => Connect(true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task ImportAuthenticator(string maFilePath) {\n\t\t\tif (HasMobileAuthenticator || !File.Exists(maFilePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotAuthenticatorConverting);\n\n\t\t\ttry {\n\t\t\t\tstring json = await RuntimeCompatibility.File.ReadAllTextAsync(maFilePath).ConfigureAwait(false);\n\n\t\t\t\tif (string.IsNullOrEmpty(json)) {\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsEmpty, nameof(json)));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tMobileAuthenticator? authenticator = JsonConvert.DeserializeObject<MobileAuthenticator>(json);\n\n\t\t\t\t// ReSharper disable once ConditionIsAlwaysTrueOrFalse - wrong, \"null\" json serializes into null object\n\t\t\t\tif (authenticator == null) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(authenticator));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tauthenticator.Init(this);\n\t\t\t\tBotDatabase.MobileAuthenticator = authenticator;\n\n\t\t\t\tFile.Delete(maFilePath);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotAuthenticatorImportFinished);\n\t\t}\n\n\t\tprivate void InitConnectionFailureTimer() {\n\t\t\tif (ConnectionFailureTimer != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbyte connectionTimeout = ASF.GlobalConfig?.ConnectionTimeout ?? GlobalConfig.DefaultConnectionTimeout;\n\n\t\t\tConnectionFailureTimer = new Timer(\n\t\t\t\tasync e => await InitPermanentConnectionFailure().ConfigureAwait(false),\n\t\t\t\tnull,\n\t\t\t\tTimeSpan.FromMinutes(Math.Ceiling(connectionTimeout / 30.0)), // Delay\n\t\t\t\tTimeout.InfiniteTimeSpan // Period\n\t\t\t);\n\t\t}\n\n\t\tprivate async Task InitializeFamilySharing() {\n\t\t\tHashSet<ulong>? steamIDs = await ArchiWebHandler.GetFamilySharingSteamIDs().ConfigureAwait(false);\n\n\t\t\tif (steamIDs == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSteamFamilySharingIDs.ReplaceWith(steamIDs);\n\t\t}\n\n\t\tprivate async Task<bool> InitLoginAndPassword(bool requiresPassword) {\n\t\t\tif (string.IsNullOrEmpty(BotConfig.SteamLogin)) {\n\t\t\t\tRequiredInput = ASF.EUserInputType.Login;\n\n\t\t\t\tstring? steamLogin = await Logging.GetUserInput(ASF.EUserInputType.Login, BotName).ConfigureAwait(false);\n\n\t\t\t\tif (string.IsNullOrEmpty(steamLogin) || !SetUserInput(ASF.EUserInputType.Login, steamLogin!)) {\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamLogin)));\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (requiresPassword && string.IsNullOrEmpty(BotConfig.DecryptedSteamPassword)) {\n\t\t\t\tRequiredInput = ASF.EUserInputType.Password;\n\n\t\t\t\tstring? steamPassword = await Logging.GetUserInput(ASF.EUserInputType.Password, BotName).ConfigureAwait(false);\n\n\t\t\t\tif (string.IsNullOrEmpty(steamPassword) || !SetUserInput(ASF.EUserInputType.Password, steamPassword!)) {\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamPassword)));\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate async Task InitModules() {\n\t\t\tif (Bots == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(Bots));\n\t\t\t}\n\n\t\t\tAccountFlags = EAccountFlags.NormalUser;\n\t\t\tAvatarHash = Nickname = null;\n\t\t\tMasterChatGroupID = 0;\n\t\t\tRequiredInput = ASF.EUserInputType.None;\n\t\t\tWalletBalance = 0;\n\t\t\tWalletCurrency = ECurrencyCode.Invalid;\n\n\t\t\tCardsFarmer.SetInitialState(BotConfig.Paused);\n\n\t\t\tif (SendItemsTimer != null) {\n\t\t\t\tawait SendItemsTimer.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\tSendItemsTimer = null;\n\t\t\t}\n\n\t\t\tif ((BotConfig.SendTradePeriod > 0) && (BotConfig.LootableTypes.Count > 0) && BotConfig.SteamUserPermissions.Values.Any(permission => permission >= BotConfig.EPermission.Master)) {\n\t\t\t\tSendItemsTimer = new Timer(\n\t\t\t\t\tasync e => await Actions.SendInventory(filterFunction: item => BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false),\n\t\t\t\t\tnull,\n\t\t\t\t\tTimeSpan.FromHours(BotConfig.SendTradePeriod) + TimeSpan.FromSeconds(ASF.LoadBalancingDelay * Bots.Count), // Delay\n\t\t\t\t\tTimeSpan.FromHours(BotConfig.SendTradePeriod) // Period\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (SteamSaleEvent != null) {\n\t\t\t\tawait SteamSaleEvent.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\tSteamSaleEvent = null;\n\t\t\t}\n\n\t\t\tif (BotConfig.AutoSteamSaleEvent) {\n\t\t\t\tSteamSaleEvent = new SteamSaleEvent(this);\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotInitModules(this, BotConfig.AdditionalProperties).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async Task InitPermanentConnectionFailure() {\n\t\t\tif (!KeepRunning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericWarning(Strings.BotHeartBeatFailed);\n\t\t\tawait Destroy(true).ConfigureAwait(false);\n\t\t\tawait RegisterBot(BotName).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void InitPlayingWasBlockedTimer() {\n\t\t\tif (PlayingWasBlockedTimer != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPlayingWasBlockedTimer = new Timer(\n\t\t\t\te => ResetPlayingWasBlockedWithTimer(),\n\t\t\t\tnull,\n\t\t\t\tTimeSpan.FromSeconds(MinPlayingBlockedTTL), // Delay\n\t\t\t\tTimeout.InfiniteTimeSpan // Period\n\t\t\t);\n\t\t}\n\n\t\tprivate void InitStart() {\n\t\t\tif (!BotConfig.Enabled) {\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotInstanceNotStartingBecauseDisabled);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Start\n\t\t\tUtilities.InBackground(Start);\n\t\t}\n\n\t\tprivate bool IsMasterClanID(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsClanAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn steamID == BotConfig.SteamMasterClanID;\n\t\t}\n\n\t\tprivate static bool IsRefundable(EPaymentMethod paymentMethod) {\n\t\t\tif (paymentMethod == EPaymentMethod.None) {\n\t\t\t\tthrow new ArgumentNullException(nameof(paymentMethod));\n\t\t\t}\n\n\t\t\t// Complimentary is also a flag\n\t\t\treturn paymentMethod switch {\n\t\t\t\tEPaymentMethod.ActivationCode => false,\n\t\t\t\tEPaymentMethod.Complimentary => false,\n\t\t\t\tEPaymentMethod.GuestPass => false,\n\t\t\t\tEPaymentMethod.HardwarePromo => false,\n\t\t\t\t_ => !paymentMethod.HasFlag(EPaymentMethod.Complimentary)\n\t\t\t};\n\t\t}\n\n\t\tprivate async Task JoinMasterChatGroupID() {\n\t\t\tif ((BotConfig.SteamMasterClanID == 0) || IsAccountLimited) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (MasterChatGroupID == 0) {\n\t\t\t\tulong chatGroupID = await ArchiHandler.GetClanChatGroupID(BotConfig.SteamMasterClanID).ConfigureAwait(false);\n\n\t\t\t\tif (chatGroupID == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tMasterChatGroupID = chatGroupID;\n\t\t\t}\n\n\t\t\tHashSet<ulong>? chatGroupIDs = await ArchiHandler.GetMyChatGroupIDs().ConfigureAwait(false);\n\n\t\t\tif (chatGroupIDs?.Contains(MasterChatGroupID) != false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!await ArchiHandler.JoinChatRoomGroup(MasterChatGroupID).ConfigureAwait(false)) {\n\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.JoinChatRoomGroup)));\n\t\t\t}\n\t\t}\n\n\t\tprivate static async Task LimitLoginRequestsAsync() {\n\t\t\tif ((ASF.LoginSemaphore == null) || (ASF.LoginRateLimitingSemaphore == null)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(ASF.LoginSemaphore) + \" || \" + nameof(ASF.LoginRateLimitingSemaphore));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbyte loginLimiterDelay = ASF.GlobalConfig?.LoginLimiterDelay ?? GlobalConfig.DefaultLoginLimiterDelay;\n\n\t\t\tif (loginLimiterDelay == 0) {\n\t\t\t\tawait ASF.LoginRateLimitingSemaphore.WaitAsync().ConfigureAwait(false);\n\t\t\t\tASF.LoginRateLimitingSemaphore.Release();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait ASF.LoginSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\ttry {\n\t\t\t\tawait ASF.LoginRateLimitingSemaphore.WaitAsync().ConfigureAwait(false);\n\t\t\t\tASF.LoginRateLimitingSemaphore.Release();\n\t\t\t} finally {\n\t\t\t\tUtilities.InBackground(\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\tawait Task.Delay(loginLimiterDelay * 1000).ConfigureAwait(false);\n\t\t\t\t\t\tASF.LoginSemaphore.Release();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnConnected(SteamClient.ConnectedCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tHeartBeatFailures = 0;\n\t\t\tReconnectOnUserInitiated = false;\n\t\t\tStopConnectionFailureTimer();\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotConnected);\n\n\t\t\tif (!KeepRunning) {\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotDisconnecting);\n\t\t\t\tDisconnect();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring sentryFilePath = GetFilePath(EFileType.SentryFile);\n\n\t\t\tif (string.IsNullOrEmpty(sentryFilePath)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(sentryFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbyte[]? sentryFileHash = null;\n\n\t\t\tif (File.Exists(sentryFilePath)) {\n\t\t\t\ttry {\n\t\t\t\t\tbyte[] sentryFileContent = await RuntimeCompatibility.File.ReadAllBytesAsync(sentryFilePath).ConfigureAwait(false);\n\t\t\t\t\tsentryFileHash = CryptoHelper.SHAHash(sentryFileContent);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFile.Delete(sentryFilePath);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignored, we can only try to delete faulted file at best\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring? loginKey = null;\n\n\t\t\tif (BotConfig.UseLoginKeys) {\n\t\t\t\t// Login keys are not guaranteed to be valid, we should use them only if we don't have full details available from the user\n\t\t\t\tif (string.IsNullOrEmpty(BotConfig.DecryptedSteamPassword) || (string.IsNullOrEmpty(AuthCode) && string.IsNullOrEmpty(TwoFactorCode) && !HasMobileAuthenticator)) {\n\t\t\t\t\tloginKey = BotDatabase.LoginKey;\n\n\t\t\t\t\t// Decrypt login key if needed\n\t\t\t\t\tif (!string.IsNullOrEmpty(loginKey) && (loginKey!.Length > 19) && (BotConfig.PasswordFormat != ArchiCryptoHelper.ECryptoMethod.PlainText)) {\n\t\t\t\t\t\tloginKey = ArchiCryptoHelper.Decrypt(BotConfig.PasswordFormat, loginKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we're not using login keys, ensure we don't have any saved\n\t\t\t\tBotDatabase.LoginKey = null;\n\t\t\t}\n\n\t\t\tif (!await InitLoginAndPassword(string.IsNullOrEmpty(loginKey)).ConfigureAwait(false)) {\n\t\t\t\tStop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(BotConfig.SteamLogin)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(BotConfig.SteamLogin));\n\t\t\t}\n\n\t\t\t// Steam login and password fields can contain ASCII characters only, including spaces\n\t\t\tconst string nonAsciiPattern = @\"[^\\u0000-\\u007F]+\";\n\n\t\t\tstring username = Regex.Replace(BotConfig.SteamLogin!, nonAsciiPattern, \"\", RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);\n\t\t\tstring? password = BotConfig.DecryptedSteamPassword;\n\n\t\t\tif (!string.IsNullOrEmpty(password)) {\n\t\t\t\tpassword = Regex.Replace(password!, nonAsciiPattern, \"\", RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotLoggingIn);\n\n\t\t\tif (string.IsNullOrEmpty(TwoFactorCode) && (BotDatabase.MobileAuthenticator != null)) {\n\t\t\t\t// We should always include 2FA token, even if it's not required\n\t\t\t\tTwoFactorCode = await BotDatabase.MobileAuthenticator.GenerateToken().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tInitConnectionFailureTimer();\n\n\t\t\tSteamUser.LogOnDetails logOnDetails = new SteamUser.LogOnDetails {\n\t\t\t\tAuthCode = AuthCode,\n\t\t\t\tCellID = ASF.GlobalDatabase?.CellID,\n\t\t\t\tLoginID = LoginID,\n\t\t\t\tLoginKey = loginKey,\n\t\t\t\tPassword = password,\n\t\t\t\tSentryFileHash = sentryFileHash,\n\t\t\t\tShouldRememberPassword = BotConfig.UseLoginKeys,\n\t\t\t\tTwoFactorCode = TwoFactorCode,\n\t\t\t\tUsername = username\n\t\t\t};\n\n\t\t\tif (OSType == EOSType.Unknown) {\n\t\t\t\tOSType = logOnDetails.ClientOSType;\n\t\t\t}\n\n\t\t\tSteamUser.LogOn(logOnDetails);\n\t\t}\n\n\t\tprivate async void OnDisconnected(SteamClient.DisconnectedCallback callback) {\n\t\t\tif ((callback == null) || (ASF.LoginRateLimitingSemaphore == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback) + \" || \" + nameof(ASF.LoginRateLimitingSemaphore));\n\t\t\t}\n\n\t\t\tEResult lastLogOnResult = LastLogOnResult;\n\t\t\tLastLogOnResult = EResult.Invalid;\n\t\t\tHeartBeatFailures = 0;\n\t\t\tSteamParentalActive = true;\n\t\t\tStopConnectionFailureTimer();\n\t\t\tStopPlayingWasBlockedTimer();\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotDisconnected);\n\n\t\t\tPastNotifications.Clear();\n\n\t\t\tActions.OnDisconnected();\n\t\t\tArchiWebHandler.OnDisconnected();\n\t\t\tCardsFarmer.OnDisconnected();\n\t\t\tTrading.OnDisconnected();\n\n\t\t\tFirstTradeSent = false;\n\n\t\t\tawait PluginsCore.OnBotDisconnected(this, callback.UserInitiated ? EResult.OK : lastLogOnResult).ConfigureAwait(false);\n\n\t\t\t// If we initiated disconnect, do not attempt to reconnect\n\t\t\tif (callback.UserInitiated && !ReconnectOnUserInitiated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (lastLogOnResult) {\n\t\t\t\tcase EResult.AccountDisabled:\n\t\t\t\t\t// Do not attempt to reconnect, those failures are permanent\n\t\t\t\t\treturn;\n\t\t\t\tcase EResult.InvalidPassword when !string.IsNullOrEmpty(BotDatabase.LoginKey):\n\t\t\t\t\tBotDatabase.LoginKey = null;\n\t\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotRemovedExpiredLoginKey);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.InvalidPassword:\n\t\t\t\tcase EResult.NoConnection:\n\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\tcase EResult.Timeout:\n\t\t\t\tcase EResult.TryAnotherCM:\n\t\t\t\tcase EResult.TwoFactorCodeMismatch:\n\t\t\t\t\tawait Task.Delay(5000).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotRateLimitExceeded, TimeSpan.FromMinutes(LoginCooldownInMinutes).ToHumanReadable()));\n\n\t\t\t\t\tif (!await ASF.LoginRateLimitingSemaphore.WaitAsync(1000 * WebBrowser.MaxTries).ConfigureAwait(false)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait Task.Delay(LoginCooldownInMinutes * 60 * 1000).ConfigureAwait(false);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tASF.LoginRateLimitingSemaphore.Release();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!KeepRunning || SteamClient.IsConnected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotReconnecting);\n\t\t\tawait Connect().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async void OnFriendsList(SteamFriends.FriendsListCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.FriendList == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.FriendList));\n\t\t\t}\n\n\t\t\tforeach (SteamFriends.FriendsListCallback.Friend friend in callback.FriendList.Where(friend => friend.Relationship == EFriendRelationship.RequestRecipient)) {\n\t\t\t\tArchiLogger.LogInvite(friend.SteamID);\n\n\t\t\t\tswitch (friend.SteamID.AccountType) {\n\t\t\t\t\tcase EAccountType.Clan when IsMasterClanID(friend.SteamID):\n\t\t\t\t\t\tArchiHandler.AcknowledgeClanInvite(friend.SteamID, true);\n\t\t\t\t\t\tawait JoinMasterChatGroupID().ConfigureAwait(false);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EAccountType.Clan:\n\t\t\t\t\t\tbool acceptGroupRequest = await PluginsCore.OnBotFriendRequest(this, friend.SteamID).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (acceptGroupRequest) {\n\t\t\t\t\t\t\tArchiHandler.AcknowledgeClanInvite(friend.SteamID, true);\n\t\t\t\t\t\t\tawait JoinMasterChatGroupID().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.RejectInvalidGroupInvites)) {\n\t\t\t\t\t\t\tArchiHandler.AcknowledgeClanInvite(friend.SteamID, false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (HasPermission(friend.SteamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\t\t\t\tif (!await ArchiHandler.AddFriend(friend.SteamID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.AddFriend)));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool acceptFriendRequest = await PluginsCore.OnBotFriendRequest(this, friend.SteamID).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (acceptFriendRequest) {\n\t\t\t\t\t\t\tif (!await ArchiHandler.AddFriend(friend.SteamID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.AddFriend)));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.RejectInvalidFriendInvites)) {\n\t\t\t\t\t\t\tif (!await ArchiHandler.RemoveFriend(friend.SteamID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.RemoveFriend)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnGuestPassList(SteamApps.GuestPassListCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.GuestPasses == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.GuestPasses));\n\t\t\t}\n\n\t\t\tif ((callback.CountGuestPassesToRedeem == 0) || (callback.GuestPasses.Count == 0) || !BotConfig.AcceptGifts) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tHashSet<ulong> guestPassIDs = callback.GuestPasses.Select(guestPass => guestPass[\"gid\"].AsUnsignedLong()).Where(gid => gid != 0).ToHashSet();\n\n\t\t\tif (guestPassIDs.Count == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Actions.AcceptGuestPasses(guestPassIDs).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async Task OnIncomingChatMessage(CChatRoom_IncomingChatMessage_Notification notification) {\n\t\t\tif (notification == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(notification));\n\t\t\t}\n\n\t\t\t// Under normal circumstances, timestamp must always be greater than 0, but Steam already proved that it's capable of going against the logic\n\t\t\tif ((notification.steamid_sender != SteamID) && (notification.timestamp > 0)) {\n\t\t\t\tif (ShouldAckChatMessage(notification.steamid_sender)) {\n\t\t\t\t\tUtilities.InBackground(() => ArchiHandler.AckChatMessage(notification.chat_group_id, notification.chat_id, notification.timestamp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring message;\n\n\t\t\t// Prefer to use message without bbcode, but only if it's available\n\t\t\tif (!string.IsNullOrEmpty(notification.message_no_bbcode)) {\n\t\t\t\tmessage = notification.message_no_bbcode;\n\t\t\t} else if (!string.IsNullOrEmpty(notification.message)) {\n\t\t\t\tmessage = UnEscape(notification.message);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(false, message, notification.chat_group_id, notification.chat_id, notification.steamid_sender);\n\n\t\t\t// Steam network broadcasts chat events also when we don't explicitly sign into Steam community\n\t\t\t// We'll explicitly ignore those messages when using offline mode, as it was done in the first version of Steam chat when no messages were broadcasted at all before signing in\n\t\t\t// Handling messages will still work correctly in invisible mode, which is how it should work in the first place\n\t\t\t// This goes in addition to usual logic that ignores irrelevant messages from being parsed further\n\t\t\tif ((notification.chat_group_id != MasterChatGroupID) || (BotConfig.OnlineStatus == EPersonaState.Offline)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Commands.HandleMessage(notification.chat_group_id, notification.chat_id, notification.steamid_sender, message).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async Task OnIncomingMessage(CFriendMessages_IncomingMessage_Notification notification) {\n\t\t\tif (notification == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(notification));\n\t\t\t}\n\n\t\t\tif ((EChatEntryType) notification.chat_entry_type != EChatEntryType.ChatMsg) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Under normal circumstances, timestamp must always be greater than 0, but Steam already proved that it's capable of going against the logic\n\t\t\tif (!notification.local_echo && (notification.rtime32_server_timestamp > 0)) {\n\t\t\t\tif (ShouldAckChatMessage(notification.steamid_friend)) {\n\t\t\t\t\tUtilities.InBackground(() => ArchiHandler.AckMessage(notification.steamid_friend, notification.rtime32_server_timestamp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring message;\n\n\t\t\t// Prefer to use message without bbcode, but only if it's available\n\t\t\tif (!string.IsNullOrEmpty(notification.message_no_bbcode)) {\n\t\t\t\tmessage = notification.message_no_bbcode;\n\t\t\t} else if (!string.IsNullOrEmpty(notification.message)) {\n\t\t\t\tmessage = UnEscape(notification.message);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(notification.local_echo, message, steamID: notification.steamid_friend);\n\n\t\t\t// Steam network broadcasts chat events also when we don't explicitly sign into Steam community\n\t\t\t// We'll explicitly ignore those messages when using offline mode, as it was done in the first version of Steam chat when no messages were broadcasted at all before signing in\n\t\t\t// Handling messages will still work correctly in invisible mode, which is how it should work in the first place\n\t\t\t// This goes in addition to usual logic that ignores irrelevant messages from being parsed further\n\t\t\tif (notification.local_echo || (BotConfig.OnlineStatus == EPersonaState.Offline)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Commands.HandleMessage(notification.steamid_friend, message).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async void OnLicenseList(SteamApps.LicenseListCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.LicenseList == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.LicenseList));\n\t\t\t}\n\n\t\t\tif (ASF.GlobalDatabase == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(ASF.GlobalDatabase));\n\t\t\t}\n\n\t\t\tif (callback.LicenseList.Count == 0) {\n\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsEmpty, nameof(callback.LicenseList)));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCommands.OnNewLicenseList();\n\n\t\t\tDictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)> ownedPackageIDs = new Dictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)>();\n\n\t\t\tDictionary<uint, ulong> packageAccessTokens = new Dictionary<uint, ulong>();\n\t\t\tDictionary<uint, uint> packagesToRefresh = new Dictionary<uint, uint>();\n\n\t\t\tforeach (SteamApps.LicenseListCallback.License license in callback.LicenseList.GroupBy(license => license.PackageID, (packageID, licenses) => licenses.OrderByDescending(license => license.TimeCreated).First())) {\n\t\t\t\townedPackageIDs[license.PackageID] = (license.PaymentMethod, license.TimeCreated);\n\n\t\t\t\tif (!ASF.GlobalDatabase.PackageAccessTokensReadOnly.TryGetValue(license.PackageID, out ulong packageAccessToken) || (packageAccessToken != license.AccessToken)) {\n\t\t\t\t\tpackageAccessTokens[license.PackageID] = license.AccessToken;\n\n\t\t\t\t\t// Package is always due to refresh with access token change\n\t\t\t\t\tpackagesToRefresh[license.PackageID] = (uint) license.LastChangeNumber;\n\t\t\t\t} else if (!ASF.GlobalDatabase.PackagesDataReadOnly.TryGetValue(license.PackageID, out (uint ChangeNumber, HashSet<uint>? AppIDs) packageData) || (packageData.ChangeNumber < license.LastChangeNumber)) {\n\t\t\t\t\tpackagesToRefresh[license.PackageID] = (uint) license.LastChangeNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOwnedPackageIDs = ownedPackageIDs.ToImmutableDictionary();\n\n\t\t\tif (packageAccessTokens.Count > 0) {\n\t\t\t\tASF.GlobalDatabase.RefreshPackageAccessTokens(packageAccessTokens);\n\t\t\t}\n\n\t\t\tif (packagesToRefresh.Count > 0) {\n\t\t\t\tArchiLogger.LogGenericTrace(Strings.BotRefreshingPackagesData);\n\t\t\t\tawait ASF.GlobalDatabase.RefreshPackages(this, packagesToRefresh).ConfigureAwait(false);\n\t\t\t\tArchiLogger.LogGenericTrace(Strings.Done);\n\t\t\t}\n\n\t\t\tawait CardsFarmer.OnNewGameAdded().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void OnLoggedOff(SteamUser.LoggedOffCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tLastLogOnResult = callback.Result;\n\n\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotLoggedOff, callback.Result));\n\n\t\t\tswitch (callback.Result) {\n\t\t\t\tcase EResult.LoggedInElsewhere:\n\t\t\t\t\t// This result directly indicates that playing was blocked when we got (forcefully) disconnected\n\t\t\t\t\tPlayingWasBlocked = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.LogonSessionReplaced:\n\t\t\t\t\tDateTime now = DateTime.UtcNow;\n\n\t\t\t\t\tif (now.Subtract(LastLogonSessionReplaced).TotalHours < 1) {\n\t\t\t\t\t\tArchiLogger.LogGenericError(Strings.BotLogonSessionReplaced);\n\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tLastLogonSessionReplaced = now;\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tReconnectOnUserInitiated = true;\n\t\t\tSteamClient.Disconnect();\n\t\t}\n\n\t\tprivate async void OnLoggedOn(SteamUser.LoggedOnCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\t// Always reset one-time-only access tokens when we get OnLoggedOn() response\n\t\t\tAuthCode = TwoFactorCode = null;\n\n\t\t\t// Keep LastLogOnResult for OnDisconnected()\n\t\t\tLastLogOnResult = callback.Result;\n\n\t\t\tHeartBeatFailures = 0;\n\t\t\tStopConnectionFailureTimer();\n\n\t\t\tswitch (callback.Result) {\n\t\t\t\tcase EResult.AccountDisabled:\n\t\t\t\t\t// Those failures are permanent, we should Stop() the bot if any of those happen\n\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.BotUnableToLogin, callback.Result, callback.ExtendedResult));\n\t\t\t\t\tStop();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.AccountLogonDenied:\n\t\t\t\t\tRequiredInput = ASF.EUserInputType.SteamGuard;\n\n\t\t\t\t\tstring? authCode = await Logging.GetUserInput(ASF.EUserInputType.SteamGuard, BotName).ConfigureAwait(false);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(authCode) || !SetUserInput(ASF.EUserInputType.SteamGuard, authCode!)) {\n\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(authCode)));\n\n\t\t\t\t\t\tStop();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.AccountLoginDeniedNeedTwoFactor:\n\t\t\t\t\tif (!HasMobileAuthenticator) {\n\t\t\t\t\t\tRequiredInput = ASF.EUserInputType.TwoFactorAuthentication;\n\n\t\t\t\t\t\tstring? twoFactorCode = await Logging.GetUserInput(ASF.EUserInputType.TwoFactorAuthentication, BotName).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (string.IsNullOrEmpty(twoFactorCode) || !SetUserInput(ASF.EUserInputType.TwoFactorAuthentication, twoFactorCode!)) {\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(twoFactorCode)));\n\n\t\t\t\t\t\t\tStop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.OK:\n\t\t\t\t\tAccountFlags = callback.AccountFlags;\n\t\t\t\t\tSteamID = callback.ClientSteamID ?? throw new ArgumentNullException(nameof(callback.ClientSteamID));\n\n\t\t\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotLoggedOn, SteamID + (!string.IsNullOrEmpty(callback.VanityURL) ? \"/\" + callback.VanityURL : \"\")));\n\n\t\t\t\t\t// Old status for these doesn't matter, we'll update them if needed\n\t\t\t\t\tInvalidPasswordFailures = TwoFactorCodeFailures = 0;\n\t\t\t\t\tLibraryLocked = PlayingBlocked = false;\n\n\t\t\t\t\tif (PlayingWasBlocked && (PlayingWasBlockedTimer == null)) {\n\t\t\t\t\t\tInitPlayingWasBlockedTimer();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (IsAccountLimited) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.BotAccountLimited);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (IsAccountLocked) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.BotAccountLocked);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((callback.CellID != 0) && (ASF.GlobalDatabase != null) && (callback.CellID != ASF.GlobalDatabase.CellID)) {\n\t\t\t\t\t\tASF.GlobalDatabase.CellID = callback.CellID;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle steamID-based maFile\n\t\t\t\t\tif (!HasMobileAuthenticator) {\n\t\t\t\t\t\tstring maFilePath = Path.Combine(SharedInfo.ConfigDirectory, SteamID + SharedInfo.MobileAuthenticatorExtension);\n\n\t\t\t\t\t\tif (File.Exists(maFilePath)) {\n\t\t\t\t\t\t\tawait ImportAuthenticator(maFilePath).ConfigureAwait(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (callback.ParentalSettings != null) {\n\t\t\t\t\t\t(bool isSteamParentalEnabled, string? steamParentalCode) = ValidateSteamParental(callback.ParentalSettings, BotConfig.SteamParentalCode);\n\n\t\t\t\t\t\tif (isSteamParentalEnabled) {\n\t\t\t\t\t\t\tSteamParentalActive = true;\n\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(steamParentalCode)) {\n\t\t\t\t\t\t\t\tif (BotConfig.SteamParentalCode != steamParentalCode) {\n\t\t\t\t\t\t\t\t\tif (!SetUserInput(ASF.EUserInputType.SteamParentalCode, steamParentalCode!)) {\n\t\t\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamParentalCode)));\n\n\t\t\t\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (string.IsNullOrEmpty(BotConfig.SteamParentalCode) || (BotConfig.SteamParentalCode!.Length != BotConfig.SteamParentalCodeLength)) {\n\t\t\t\t\t\t\t\tRequiredInput = ASF.EUserInputType.SteamParentalCode;\n\n\t\t\t\t\t\t\t\tsteamParentalCode = await Logging.GetUserInput(ASF.EUserInputType.SteamParentalCode, BotName).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tif (string.IsNullOrEmpty(steamParentalCode) || !SetUserInput(ASF.EUserInputType.SteamParentalCode, steamParentalCode!)) {\n\t\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamParentalCode)));\n\n\t\t\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSteamParentalActive = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SteamParentalActive && !string.IsNullOrEmpty(BotConfig.SteamParentalCode) && (BotConfig.SteamParentalCode!.Length != BotConfig.SteamParentalCodeLength)) {\n\t\t\t\t\t\tRequiredInput = ASF.EUserInputType.SteamParentalCode;\n\n\t\t\t\t\t\tstring? steamParentalCode = await Logging.GetUserInput(ASF.EUserInputType.SteamParentalCode, BotName).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (string.IsNullOrEmpty(steamParentalCode) || !SetUserInput(ASF.EUserInputType.SteamParentalCode, steamParentalCode!)) {\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamParentalCode)));\n\n\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiWebHandler.OnVanityURLChanged(callback.VanityURL);\n\n\t\t\t\t\tif (!await ArchiWebHandler.Init(SteamID, SteamClient.Universe, callback.WebAPIUserNonce ?? throw new ArgumentNullException(nameof(callback.WebAPIUserNonce)), SteamParentalActive ? BotConfig.SteamParentalCode : null).ConfigureAwait(false)) {\n\t\t\t\t\t\tif (!await RefreshSession().ConfigureAwait(false)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Pre-fetch API key for future usage if possible\n\t\t\t\t\tUtilities.InBackground(ArchiWebHandler.HasValidApiKey);\n\n\t\t\t\t\tif ((GamesRedeemerInBackgroundTimer == null) && BotDatabase.HasGamesToRedeemInBackground) {\n\t\t\t\t\t\tUtilities.InBackground(RedeemGamesInBackground);\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiHandler.SetCurrentMode(2);\n\t\t\t\t\tArchiHandler.RequestItemAnnouncements();\n\n\t\t\t\t\t// Sometimes Steam won't send us our own PersonaStateCallback, so request it explicitly\n\t\t\t\t\tRequestPersonaStateUpdate();\n\n\t\t\t\t\tUtilities.InBackground(InitializeFamilySharing);\n\n\t\t\t\t\tif (Statistics != null) {\n\t\t\t\t\t\tUtilities.InBackground(Statistics.OnLoggedOn);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (BotConfig.OnlineStatus != EPersonaState.Offline) {\n\t\t\t\t\t\tSteamFriends.SetPersonaState(BotConfig.OnlineStatus);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (BotConfig.SteamMasterClanID != 0) {\n\t\t\t\t\t\tUtilities.InBackground(\n\t\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\t\tif (!await ArchiWebHandler.JoinGroup(BotConfig.SteamMasterClanID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiWebHandler.JoinGroup)));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tawait JoinMasterChatGroupID().ConfigureAwait(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (CardsFarmer.Paused) {\n\t\t\t\t\t\t// Emit initial game playing status in this case\n\t\t\t\t\t\tUtilities.InBackground(ResetGamesPlayed);\n\t\t\t\t\t}\n\n\t\t\t\t\tSteamPICSChanges.OnBotLoggedOn();\n\n\t\t\t\t\tawait PluginsCore.OnBotLoggedOn(this).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.InvalidPassword:\n\t\t\t\tcase EResult.NoConnection:\n\t\t\t\tcase EResult.PasswordRequiredToKickSession: // Not sure about this one, it seems to be just generic \"try again\"? #694\n\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\tcase EResult.Timeout:\n\t\t\t\tcase EResult.TryAnotherCM:\n\t\t\t\tcase EResult.TwoFactorCodeMismatch:\n\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.BotUnableToLogin, callback.Result, callback.ExtendedResult));\n\n\t\t\t\t\tswitch (callback.Result) {\n\t\t\t\t\t\tcase EResult.InvalidPassword when string.IsNullOrEmpty(BotDatabase.LoginKey) && (++InvalidPasswordFailures >= MaxInvalidPasswordFailures):\n\t\t\t\t\t\t\tInvalidPasswordFailures = 0;\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.BotInvalidPasswordDuringLogin, MaxInvalidPasswordFailures));\n\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EResult.TwoFactorCodeMismatch when HasMobileAuthenticator && (++TwoFactorCodeFailures >= MaxTwoFactorCodeFailures):\n\t\t\t\t\t\t\tTwoFactorCodeFailures = 0;\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.BotInvalidAuthenticatorDuringLogin, MaxTwoFactorCodeFailures));\n\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Unexpected result, shutdown immediately\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(callback.Result), callback.Result));\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.BotUnableToLogin, callback.Result, callback.ExtendedResult));\n\t\t\t\t\tStop();\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnLoginKey(SteamUser.LoginKeyCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(callback.LoginKey)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.LoginKey));\n\t\t\t}\n\n\t\t\tif (!BotConfig.UseLoginKeys) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring? loginKey = callback.LoginKey;\n\n\t\t\tif (BotConfig.PasswordFormat != ArchiCryptoHelper.ECryptoMethod.PlainText) {\n\t\t\t\tloginKey = ArchiCryptoHelper.Encrypt(BotConfig.PasswordFormat, loginKey);\n\t\t\t}\n\n\t\t\tBotDatabase.LoginKey = loginKey;\n\t\t\tSteamUser.AcceptNewLoginKey(callback);\n\t\t}\n\n\t\tprivate async void OnMachineAuth(SteamUser.UpdateMachineAuthCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tstring sentryFilePath = GetFilePath(EFileType.SentryFile);\n\n\t\t\tif (string.IsNullOrEmpty(sentryFilePath)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(sentryFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong fileSize;\n\t\t\tbyte[] sentryHash;\n\n\t\t\ttry {\n#if NETFRAMEWORK\n\t\t\t\tusing FileStream fileStream = File.Open(sentryFilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite);\n#else\n\t\t\t\tawait using FileStream fileStream = File.Open(sentryFilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite);\n#endif\n\n\t\t\t\tfileStream.Seek(callback.Offset, SeekOrigin.Begin);\n\n\t\t\t\tawait fileStream.WriteAsync(callback.Data, 0, callback.BytesToWrite).ConfigureAwait(false);\n\n\t\t\t\tfileSize = fileStream.Length;\n\t\t\t\tfileStream.Seek(0, SeekOrigin.Begin);\n\n\t\t\t\tusing SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();\n\n\t\t\t\tsentryHash = sha.ComputeHash(fileStream);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(sentryFilePath);\n\t\t\t\t} catch {\n\t\t\t\t\t// Ignored, we can only try to delete faulted file at best\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Inform the steam servers that we're accepting this sentry file\n\t\t\tSteamUser.SendMachineAuthResponse(\n\t\t\t\tnew SteamUser.MachineAuthDetails {\n\t\t\t\t\tBytesWritten = callback.BytesToWrite,\n\t\t\t\t\tFileName = callback.FileName,\n\t\t\t\t\tFileSize = (int) fileSize,\n\t\t\t\t\tJobID = callback.JobID,\n\t\t\t\t\tLastError = 0,\n\t\t\t\t\tOffset = callback.Offset,\n\t\t\t\t\tOneTimePassword = callback.OneTimePassword,\n\t\t\t\t\tResult = EResult.OK,\n\t\t\t\t\tSentryFileHash = sentryHash\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tprivate void OnPersonaState(SteamFriends.PersonaStateCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.FriendID != SteamID) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring? avatarHash = null;\n\n\t\t\tif ((callback.AvatarHash.Length > 0) && callback.AvatarHash.Any(singleByte => singleByte != 0)) {\n\t\t\t\tavatarHash = BitConverter.ToString(callback.AvatarHash).Replace(\"-\", \"\").ToLowerInvariant();\n\n\t\t\t\tif (string.IsNullOrEmpty(avatarHash) || avatarHash.All(singleChar => singleChar == '0')) {\n\t\t\t\t\tavatarHash = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAvatarHash = avatarHash;\n\t\t\tNickname = callback.Name;\n\n\t\t\tif (Statistics != null) {\n\t\t\t\tUtilities.InBackground(() => Statistics.OnPersonaState(callback.Name, avatarHash));\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnPlayingSessionState(ArchiHandler.PlayingSessionStateCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.PlayingBlocked == PlayingBlocked) {\n\t\t\t\treturn; // No status update, we're not interested\n\t\t\t}\n\n\t\t\tPlayingBlocked = callback.PlayingBlocked;\n\t\t\tawait CheckOccupationStatus().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async void OnServiceMethod(SteamUnifiedMessages.ServiceMethodNotification notification) {\n\t\t\tif (notification == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(notification));\n\t\t\t}\n\n\t\t\tswitch (notification.MethodName) {\n\t\t\t\tcase \"ChatRoomClient.NotifyIncomingChatMessage#1\":\n\t\t\t\t\tawait OnIncomingChatMessage((CChatRoom_IncomingChatMessage_Notification) notification.Body).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FriendMessagesClient.IncomingMessage#1\":\n\t\t\t\t\tawait OnIncomingMessage((CFriendMessages_IncomingMessage_Notification) notification.Body).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnSharedLibraryLockStatus(ArchiHandler.SharedLibraryLockStatusCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\t// Ignore no status updates\n\t\t\tif (LibraryLocked) {\n\t\t\t\tif ((callback.LibraryLockedBySteamID != 0) && (callback.LibraryLockedBySteamID != SteamID)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tLibraryLocked = false;\n\t\t\t} else {\n\t\t\t\tif ((callback.LibraryLockedBySteamID == 0) || (callback.LibraryLockedBySteamID == SteamID)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tLibraryLocked = true;\n\t\t\t}\n\n\t\t\tawait CheckOccupationStatus().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void OnUserNotifications(ArchiHandler.UserNotificationsCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.Notifications == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.Notifications.Count == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tHashSet<ArchiHandler.UserNotificationsCallback.EUserNotification> newPluginNotifications = new HashSet<ArchiHandler.UserNotificationsCallback.EUserNotification>();\n\n\t\t\tforeach ((ArchiHandler.UserNotificationsCallback.EUserNotification notification, uint count) in callback.Notifications) {\n\t\t\t\tbool newNotification;\n\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tnewNotification = !PastNotifications.TryGetValue(notification, out uint previousCount) || (count > previousCount);\n\t\t\t\t\tPastNotifications[notification] = count;\n\n\t\t\t\t\tif (newNotification) {\n\t\t\t\t\t\tnewPluginNotifications.Add(notification);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewNotification = false;\n\t\t\t\t\tPastNotifications.TryRemove(notification, out _);\n\t\t\t\t}\n\n\t\t\t\tArchiLogger.LogGenericTrace(notification + \" = \" + count);\n\n\t\t\t\tswitch (notification) {\n\t\t\t\t\tcase ArchiHandler.UserNotificationsCallback.EUserNotification.Gifts when newNotification && BotConfig.AcceptGifts:\n\t\t\t\t\t\tUtilities.InBackground(Actions.AcceptDigitalGiftCards);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ArchiHandler.UserNotificationsCallback.EUserNotification.Items when newNotification:\n\t\t\t\t\t\tUtilities.InBackground(CardsFarmer.OnNewItemsNotification);\n\n\t\t\t\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.DismissInventoryNotifications)) {\n\t\t\t\t\t\t\tUtilities.InBackground(ArchiWebHandler.MarkInventory);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ArchiHandler.UserNotificationsCallback.EUserNotification.Trading when newNotification:\n\t\t\t\t\t\tUtilities.InBackground(Trading.OnNewTrade);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newPluginNotifications.Count > 0) {\n\t\t\t\tUtilities.InBackground(() => PluginsCore.OnBotUserNotifications(this, newPluginNotifications));\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnVanityURLChangedCallback(ArchiHandler.VanityURLChangedCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tArchiWebHandler.OnVanityURLChanged(callback.VanityURL);\n\t\t}\n\n\t\tprivate void OnWalletUpdate(SteamUser.WalletInfoCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tWalletBalance = callback.LongBalance;\n\t\t\tWalletCurrency = callback.Currency;\n\t\t}\n\n\t\tprivate async Task RedeemGamesInBackground() {\n\t\t\tif (!await GamesRedeemerInBackgroundSemaphore.WaitAsync(0).ConfigureAwait(false)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (GamesRedeemerInBackgroundTimer != null) {\n\t\t\t\t\tawait GamesRedeemerInBackgroundTimer.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\t\tGamesRedeemerInBackgroundTimer = null;\n\t\t\t\t}\n\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.Starting);\n\n\t\t\t\tbool assumeWalletKeyOnBadActivationCode = BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.AssumeWalletKeyOnBadActivationCode);\n\n\t\t\t\twhile (IsConnectedAndLoggedOn && BotDatabase.HasGamesToRedeemInBackground) {\n\t\t\t\t\t(string? key, string? name) = BotDatabase.GetGameToRedeemInBackground();\n\n\t\t\t\t\tif (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(name)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(key) + \" || \" + nameof(name));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiHandler.PurchaseResponseCallback? result = await Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (((result.PurchaseResultDetail == EPurchaseResultDetail.CannotRedeemCodeFromClient) || ((result.PurchaseResultDetail == EPurchaseResultDetail.BadActivationCode) && assumeWalletKeyOnBadActivationCode)) && (WalletCurrency != ECurrencyCode.Invalid)) {\n\t\t\t\t\t\t// If it's a wallet code, we try to redeem it first, then handle the inner result as our primary one\n\t\t\t\t\t\t(EResult Result, EPurchaseResultDetail? PurchaseResult)? walletResult = await ArchiWebHandler.RedeemWalletKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (walletResult != null) {\n\t\t\t\t\t\t\tresult.Result = walletResult.Value.Result;\n\t\t\t\t\t\t\tresult.PurchaseResultDetail = walletResult.Value.PurchaseResult.GetValueOrDefault(walletResult.Value.Result == EResult.OK ? EPurchaseResultDetail.NoDetail : EPurchaseResultDetail.BadActivationCode); // BadActivationCode is our smart guess in this case\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.Result = EResult.Timeout;\n\t\t\t\t\t\t\tresult.PurchaseResultDetail = EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiLogger.LogGenericDebug(string.Format(Strings.BotRedeem, key, result.Result + \"/\" + result.PurchaseResultDetail));\n\n\t\t\t\t\tbool rateLimited = false;\n\t\t\t\t\tbool redeemed = false;\n\n\t\t\t\t\tswitch (result.PurchaseResultDetail) {\n\t\t\t\t\t\tcase EPurchaseResultDetail.AccountLocked:\n\t\t\t\t\t\tcase EPurchaseResultDetail.AlreadyPurchased:\n\t\t\t\t\t\tcase EPurchaseResultDetail.CannotRedeemCodeFromClient:\n\t\t\t\t\t\tcase EPurchaseResultDetail.DoesNotOwnRequiredApp:\n\t\t\t\t\t\tcase EPurchaseResultDetail.RestrictedCountry:\n\t\t\t\t\t\tcase EPurchaseResultDetail.Timeout:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\tredeemed = true;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\trateLimited = true;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result.PurchaseResultDetail), result.PurchaseResultDetail));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rateLimited) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tBotDatabase.RemoveGameToRedeemInBackground(key!);\n\n\t\t\t\t\t// If user omitted the name or intentionally provided the same name as key, replace it with the Steam result\n\t\t\t\t\tif (name!.Equals(key) && (result.Items != null) && (result.Items.Count > 0)) {\n\t\t\t\t\t\tname = string.Join(\", \", result.Items.Values);\n\t\t\t\t\t}\n\n\t\t\t\t\tstring logEntry = name + DefaultBackgroundKeysRedeemerSeparator + \"[\" + result.PurchaseResultDetail + \"]\" + ((result.Items != null) && (result.Items.Count > 0) ? DefaultBackgroundKeysRedeemerSeparator + string.Join(\", \", result.Items) : \"\") + DefaultBackgroundKeysRedeemerSeparator + key;\n\n\t\t\t\t\tstring filePath = GetFilePath(redeemed ? EFileType.KeysToRedeemUsed : EFileType.KeysToRedeemUnused);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(filePath)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(filePath));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait RuntimeCompatibility.File.AppendAllTextAsync(filePath, logEntry + Environment.NewLine).ConfigureAwait(false);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.Content, logEntry));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (IsConnectedAndLoggedOn && BotDatabase.HasGamesToRedeemInBackground) {\n\t\t\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotRateLimitExceeded, TimeSpan.FromHours(RedeemCooldownInHours).ToHumanReadable()));\n\n\t\t\t\t\tGamesRedeemerInBackgroundTimer = new Timer(\n\t\t\t\t\t\tasync e => await RedeemGamesInBackground().ConfigureAwait(false),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tTimeSpan.FromHours(RedeemCooldownInHours), // Delay\n\t\t\t\t\t\tTimeout.InfiniteTimeSpan // Period\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.Done);\n\t\t\t} finally {\n\t\t\t\tGamesRedeemerInBackgroundSemaphore.Release();\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task ResetGamesPlayed() {\n\t\t\tif (CardsFarmer.NowFarming) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (BotConfig.GamesPlayedWhileIdle.Count > 0) {\n\t\t\t\tif (!IsPlayingPossible) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// This function might be executed before PlayingSessionStateCallback/SharedLibraryLockStatusCallback, ensure proper delay in this case\n\t\t\t\tawait Task.Delay(2000).ConfigureAwait(false);\n\n\t\t\t\tif (CardsFarmer.NowFarming || !IsPlayingPossible) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait ArchiHandler.PlayGames(BotConfig.GamesPlayedWhileIdle, BotConfig.CustomGamePlayedWhileIdle).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void ResetPlayingWasBlockedWithTimer() {\n\t\t\tPlayingWasBlocked = false;\n\t\t\tStopPlayingWasBlockedTimer();\n\t\t}\n\n\t\tprivate bool ShouldAckChatMessage(ulong steamID) {\n\t\t\tif (Bots == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(Bots));\n\t\t\t}\n\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tArchiLogger.LogNullError(nameof(steamID));\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.MarkReceivedMessagesAsRead)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.MarkBotMessagesAsRead) && Bots.Values.Any(bot => bot.SteamID == steamID);\n\t\t}\n\n\t\tprivate void StopConnectionFailureTimer() {\n\t\t\tif (ConnectionFailureTimer == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tConnectionFailureTimer.Dispose();\n\t\t\tConnectionFailureTimer = null;\n\t\t}\n\n\t\tprivate void StopPlayingWasBlockedTimer() {\n\t\t\tif (PlayingWasBlockedTimer == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPlayingWasBlockedTimer.Dispose();\n\t\t\tPlayingWasBlockedTimer = null;\n\t\t}\n\n\t\tprivate static string UnEscape(string message) {\n\t\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t\t}\n\n\t\t\treturn message.Replace(\"\\\\[\", \"[\").Replace(\"\\\\\\\\\", \"\\\\\");\n\t\t}\n\n\t\tprivate (bool IsSteamParentalEnabled, string? SteamParentalCode) ValidateSteamParental(ParentalSettings settings, string? steamParentalCode = null) {\n\t\t\tif (settings == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(settings));\n\t\t\t}\n\n\t\t\tif (!settings.is_enabled) {\n\t\t\t\treturn (false, null);\n\t\t\t}\n\n\t\t\tArchiCryptoHelper.ESteamParentalAlgorithm steamParentalAlgorithm;\n\n\t\t\tswitch (settings.passwordhashtype) {\n\t\t\t\tcase 4:\n\t\t\t\t\tsteamParentalAlgorithm = ArchiCryptoHelper.ESteamParentalAlgorithm.Pbkdf2;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tsteamParentalAlgorithm = ArchiCryptoHelper.ESteamParentalAlgorithm.SCrypt;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(settings.passwordhashtype), settings.passwordhashtype));\n\n\t\t\t\t\treturn (true, null);\n\t\t\t}\n\n\t\t\tif ((steamParentalCode != null) && (steamParentalCode.Length == BotConfig.SteamParentalCodeLength)) {\n\t\t\t\tbyte i = 0;\n\t\t\t\tbyte[] password = new byte[steamParentalCode.Length];\n\n\t\t\t\tforeach (char character in steamParentalCode.TakeWhile(character => (character >= '0') && (character <= '9'))) {\n\t\t\t\t\tpassword[i++] = (byte) character;\n\t\t\t\t}\n\n\t\t\t\tif (i >= steamParentalCode.Length) {\n\t\t\t\t\tIEnumerable<byte>? passwordHash = ArchiCryptoHelper.GenerateSteamParentalHash(password, settings.salt, (byte) settings.passwordhash.Length, steamParentalAlgorithm);\n\n\t\t\t\t\tif (passwordHash?.SequenceEqual(settings.passwordhash) == true) {\n\t\t\t\t\t\treturn (true, steamParentalCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotGeneratingSteamParentalCode);\n\n\t\t\tsteamParentalCode = ArchiCryptoHelper.RecoverSteamParentalCode(settings.passwordhash, settings.salt, steamParentalAlgorithm);\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.Done);\n\n\t\t\treturn (true, steamParentalCode);\n\t\t}\n\n\t\tinternal enum EFileType : byte {\n\t\t\tConfig,\n\t\t\tDatabase,\n\t\t\tKeysToRedeem,\n\t\t\tKeysToRedeemUnused,\n\t\t\tKeysToRedeemUsed,\n\t\t\tMobileAuthenticator,\n\t\t\tSentryFile\n\t\t}\n\t}\n}\n", "//     _                _      _  ____   _                           _____\n//    / \\    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___\n//   / _ \\  | '__|/ __|| '_ \\ | |\\___ \\ | __|/ _ \\ / _` || '_ ` _ \\ | |_  / _` || '__|| '_ ` _ \\\n//  / ___ \\ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |\n// /_/   \\_\\|_|   \\___||_| |_||_||____/  \\__|\\___| \\__,_||_| |_| |_||_|   \\__,_||_|   |_| |_| |_|\n// |\n// Copyright 2015-2020 \u0141ukasz \"JustArchi\" Domeradzki\n// Contact: JustArchi@JustArchi.net\n// |\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// |\n// http://www.apache.org/licenses/LICENSE-2.0\n// |\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing ArchiSteamFarm.Json;\nusing ArchiSteamFarm.Localization;\nusing ArchiSteamFarm.Plugins;\nusing JetBrains.Annotations;\nusing SteamKit2;\n\nnamespace ArchiSteamFarm {\n\tpublic sealed class Commands {\n\t\tprivate const ushort SteamTypingStatusDelay = 10 * 1000; // Steam client broadcasts typing status each 10 seconds\n\n\t\tprivate readonly Bot Bot;\n\t\tprivate readonly Dictionary<uint, string> CachedGamesOwned = new Dictionary<uint, string>();\n\n\t\tinternal Commands(Bot bot) => Bot = bot ?? throw new ArgumentNullException(nameof(bot));\n\n\t\t[PublicAPI]\n\t\tpublic static string FormatBotResponse(string response, string botName) {\n\t\t\tif (string.IsNullOrEmpty(response) || string.IsNullOrEmpty(botName)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response) + \" || \" + nameof(botName));\n\t\t\t}\n\n\t\t\treturn Environment.NewLine + \"<\" + botName + \"> \" + response;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic string FormatBotResponse(string response) {\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t\t}\n\n\t\t\treturn \"<\" + Bot.BotName + \"> \" + response;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic static string FormatStaticResponse(string response) {\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t\t}\n\n\t\t\treturn \"<\" + SharedInfo.ASF + \"> \" + response;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic async Task<string?> Response(ulong steamID, string message) {\n\t\t\tif ((steamID == 0) || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tstring[] args = message.Split(new char[0], StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tswitch (args.Length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(nameof(args.Length));\n\t\t\t\tcase 1:\n\t\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\t\treturn await Response2FA(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\t\treturn ResponseWalletBalance(steamID);\n\t\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\t\treturn ResponseBackgroundGamesRedeemer(steamID);\n\t\t\t\t\t\tcase \"BL\":\n\t\t\t\t\t\t\treturn ResponseBlacklist(steamID);\n\t\t\t\t\t\tcase \"EXIT\":\n\t\t\t\t\t\t\treturn ResponseExit(steamID);\n\t\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\t\treturn await ResponseFarm(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"HELP\":\n\t\t\t\t\t\t\treturn ResponseHelp(steamID);\n\t\t\t\t\t\tcase \"IB\":\n\t\t\t\t\t\t\treturn ResponseIdleBlacklist(steamID);\n\t\t\t\t\t\tcase \"IQ\":\n\t\t\t\t\t\t\treturn ResponseIdleQueue(steamID);\n\t\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\t\treturn await ResponseLevel(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\t\treturn await ResponseLoot(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PASSWORD\":\n\t\t\t\t\t\t\treturn ResponsePassword(steamID);\n\t\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\t\treturn await ResponseReset(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\t\treturn ResponseResume(steamID);\n\t\t\t\t\t\tcase \"RESTART\":\n\t\t\t\t\t\t\treturn ResponseRestart(steamID);\n\t\t\t\t\t\tcase \"SA\":\n\t\t\t\t\t\t\treturn await ResponseStatus(steamID, SharedInfo.ASF).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\t\treturn ResponseStart(steamID);\n\t\t\t\t\t\tcase \"STATS\":\n\t\t\t\t\t\t\treturn ResponseStats(steamID);\n\t\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\t\treturn ResponseStatus(steamID).Response;\n\t\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\t\treturn ResponseStop(steamID);\n\t\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\t\treturn await ResponseUnpackBoosters(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"UPDATE\":\n\t\t\t\t\t\t\treturn await ResponseUpdate(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"VERSION\":\n\t\t\t\t\t\t\treturn ResponseVersion(steamID);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, steamID, message, args).ConfigureAwait(false);\n\n\t\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(steamID);\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\t\treturn await Response2FA(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, Utilities.GetArgsAsText(args, 1, \",\"), false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, Utilities.GetArgsAsText(args, 1, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"ADDLICENSE\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseAddLicense(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"ADDLICENSE\":\n\t\t\t\t\t\t\treturn await ResponseAddLicense(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\t\treturn await ResponseWalletBalance(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\t\treturn await ResponseBackgroundGamesRedeemer(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BL\":\n\t\t\t\t\t\t\treturn await ResponseBlacklist(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BLADD\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseBlacklistAdd(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BLADD\":\n\t\t\t\t\t\t\treturn ResponseBlacklistAdd(steamID, args[1]);\n\t\t\t\t\t\tcase \"BLRM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseBlacklistRemove(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BLRM\":\n\t\t\t\t\t\t\treturn ResponseBlacklistRemove(steamID, args[1]);\n\t\t\t\t\t\tcase \"ENCRYPT\" when args.Length > 2:\n\t\t\t\t\t\t\treturn ResponseEncrypt(steamID, args[1], Utilities.GetArgsAsText(message, 2));\n\t\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\t\treturn await ResponseFarm(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"INPUT\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseInput(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"INPUT\" when args.Length > 2:\n\t\t\t\t\t\t\treturn ResponseInput(steamID, args[1], args[2]);\n\t\t\t\t\t\tcase \"IB\":\n\t\t\t\t\t\t\treturn await ResponseIdleBlacklist(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IBADD\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleBlacklistAdd(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IBADD\":\n\t\t\t\t\t\t\treturn ResponseIdleBlacklistAdd(steamID, args[1]);\n\t\t\t\t\t\tcase \"IBRM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleBlacklistRemove(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IBRM\":\n\t\t\t\t\t\t\treturn ResponseIdleBlacklistRemove(steamID, args[1]);\n\t\t\t\t\t\tcase \"IQ\":\n\t\t\t\t\t\t\treturn await ResponseIdleQueue(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IQADD\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleQueueAdd(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IQADD\":\n\t\t\t\t\t\t\treturn ResponseIdleQueueAdd(steamID, args[1]);\n\t\t\t\t\t\tcase \"IQRM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleQueueRemove(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IQRM\":\n\t\t\t\t\t\t\treturn ResponseIdleQueueRemove(steamID, args[1]);\n\t\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\t\treturn await ResponseLevel(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\t\treturn await ResponseLoot(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT^\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseAdvancedLoot(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT^\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseAdvancedLoot(steamID, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT@\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT@\":\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT%\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT%\":\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1], true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"NICKNAME\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseNickname(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"NICKNAME\":\n\t\t\t\t\t\t\treturn ResponseNickname(steamID, args[1]);\n\t\t\t\t\t\tcase \"OA\":\n\t\t\t\t\t\t\treturn await ResponseOwns(steamID, SharedInfo.ASF, Utilities.GetArgsAsText(message, 1)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"OWNS\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseOwns(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"OWNS\":\n\t\t\t\t\t\t\treturn (await ResponseOwns(steamID, args[1]).ConfigureAwait(false)).Response;\n\t\t\t\t\t\tcase \"PASSWORD\":\n\t\t\t\t\t\t\treturn await ResponsePassword(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, Utilities.GetArgsAsText(args, 1, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, Utilities.GetArgsAsText(args, 1, \",\"), false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE&\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, args[1], true, Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE&\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, true, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PLAY\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponsePlay(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PLAY\":\n\t\t\t\t\t\t\treturn await ResponsePlay(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PRIVACY\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponsePrivacy(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PRIVACY\":\n\t\t\t\t\t\t\treturn await ResponsePrivacy(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R\" when args.Length > 2:\n\t\t\t\t\t\tcase \"REDEEM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseRedeem(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R\":\n\t\t\t\t\t\tcase \"REDEEM\":\n\t\t\t\t\t\t\treturn await ResponseRedeem(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R^\" when args.Length > 3:\n\t\t\t\t\t\tcase \"REDEEM^\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseAdvancedRedeem(steamID, args[1], args[2], Utilities.GetArgsAsText(args, 3, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R^\" when args.Length > 2:\n\t\t\t\t\t\tcase \"REDEEM^\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseAdvancedRedeem(steamID, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\t\treturn await ResponseReset(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\t\treturn await ResponseResume(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\t\treturn await ResponseStart(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\t\treturn await ResponseStatus(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\t\treturn await ResponseStop(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseTransfer(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER\":\n\t\t\t\t\t\t\treturn await ResponseTransfer(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 4:\n\t\t\t\t\t\t\treturn await ResponseAdvancedTransfer(steamID, args[1], args[2], args[3], Utilities.GetArgsAsText(message, 4)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseAdvancedTransfer(steamID, args[1], args[2], args[3]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2], true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\t\treturn await ResponseUnpackBoosters(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, steamID, message, args).ConfigureAwait(false);\n\n\t\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(steamID);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task HandleMessage(ulong steamID, string message) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t\tif (!await Bot.SendMessage(steamID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, pluginsResponse));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmessage = message.Substring(commandPrefix!.Length);\n\t\t\t}\n\n\t\t\tTask<string?> responseTask = Response(steamID, message);\n\n\t\t\tbool feedback = Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing);\n\n\t\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t\t}\n\n\t\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tif (!feedback) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tBot.ArchiLogger.LogNullError(nameof(response));\n\t\t\t\tresponse = FormatBotResponse(Strings.UnknownCommand);\n\t\t\t}\n\n\t\t\tif (!await Bot.SendMessage(steamID, response!).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, response));\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task HandleMessage(ulong chatGroupID, ulong chatID, ulong steamID, string message) {\n\t\t\tif ((chatGroupID == 0) || (chatID == 0) || (steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(chatGroupID) + \" || \" + nameof(chatID) + \" || \" + nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, pluginsResponse));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmessage = message.Substring(commandPrefix!.Length);\n\t\t\t}\n\n\t\t\tTask<string?> responseTask = Response(steamID, message);\n\n\t\t\tbool feedback = Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing);\n\n\t\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\t\tstring pleaseWaitMessage = FormatBotResponse(Strings.PleaseWait);\n\n\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t}\n\n\t\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tif (!feedback) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tBot.ArchiLogger.LogNullError(nameof(response));\n\t\t\t\tresponse = FormatBotResponse(Strings.UnknownCommand);\n\t\t\t}\n\n\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, response!).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, response));\n\t\t\t}\n\t\t}\n\n\t\tinternal void OnNewLicenseList() {\n\t\t\tlock (CachedGamesOwned) {\n\t\t\t\tCachedGamesOwned.Clear();\n\t\t\t\tCachedGamesOwned.TrimExcess();\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<Dictionary<uint, string>?> FetchGamesOwned(bool cachedOnly = false) {\n\t\t\tlock (CachedGamesOwned) {\n\t\t\t\tif (CachedGamesOwned.Count > 0) {\n\t\t\t\t\treturn new Dictionary<uint, string>(CachedGamesOwned);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cachedOnly) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbool? hasValidApiKey = await Bot.ArchiWebHandler.HasValidApiKey().ConfigureAwait(false);\n\n\t\t\tDictionary<uint, string>? gamesOwned = hasValidApiKey.GetValueOrDefault() ? await Bot.ArchiWebHandler.GetOwnedGames(Bot.SteamID).ConfigureAwait(false) : await Bot.ArchiWebHandler.GetMyOwnedGames().ConfigureAwait(false);\n\n\t\t\tif ((gamesOwned != null) && (gamesOwned.Count > 0)) {\n\t\t\t\tlock (CachedGamesOwned) {\n\t\t\t\t\tif (CachedGamesOwned.Count == 0) {\n\t\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned) {\n\t\t\t\t\t\t\tCachedGamesOwned[appID] = gameName;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tCachedGamesOwned.TrimExcess();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn gamesOwned;\n\t\t}\n\n\t\tprivate async Task<string?> Response2FA(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string? token, string message) = await Bot.Actions.GenerateTwoFactorAuthenticationToken().ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success && !string.IsNullOrEmpty(token) ? string.Format(Strings.BotAuthenticatorToken, token) : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> Response2FA(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FA(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> Response2FAConfirm(ulong steamID, bool confirm) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (!Bot.HasMobileAuthenticator) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNoASFAuthenticator);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.HandleTwoFactorAuthenticationConfirmations(confirm).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> Response2FAConfirm(ulong steamID, string botNames, bool confirm) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FAConfirm(steamID, confirm))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAddLicense(ulong steamID, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tStringBuilder response = new StringBuilder();\n\n\t\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tforeach (string entry in entries) {\n\t\t\t\tuint gameID;\n\t\t\t\tstring type;\n\n\t\t\t\tint index = entry.IndexOf('/');\n\n\t\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\t\tif (!uint.TryParse(entry.Substring(index + 1), out gameID) || (gameID == 0)) {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = entry.Substring(0, index);\n\t\t\t\t} else if (uint.TryParse(entry, out gameID) && (gameID > 0)) {\n\t\t\t\t\ttype = \"SUB\";\n\t\t\t\t} else {\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\t\tcase \"A\":\n\t\t\t\t\tcase \"APP\":\n\t\t\t\t\t\tSteamApps.FreeLicenseCallback callback;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback = await Bot.SteamApps.RequestFreeLicense(gameID).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotAddLicense, \"app/\" + gameID, EResult.Timeout)));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse((callback.GrantedApps.Count > 0) || (callback.GrantedPackages.Count > 0) ? string.Format(Strings.BotAddLicenseWithItems, \"app/\" + gameID, callback.Result, string.Join(\", \", callback.GrantedApps.Select(appID => \"app/\" + appID).Union(callback.GrantedPackages.Select(subID => \"sub/\" + subID)))) : string.Format(Strings.BotAddLicense, \"app/\" + gameID, callback.Result)));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (!await Bot.ArchiWebHandler.AddFreeLicense(gameID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotAddLicense, \"sub/\" + gameID, EResult.Fail)));\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotAddLicenseWithItems, gameID, EResult.OK, \"sub/\" + gameID)));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn response.Length > 0 ? response.ToString() : null;\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAddLicense(ulong steamID, string botNames, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAddLicense(steamID, query))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedLoot(ulong steamID, string targetAppID, string targetContextID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppID) || string.IsNullOrEmpty(targetContextID)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppID) + \" || \" + nameof(targetContextID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAdvancedLoot(ulong steamID, string botNames, string appID, string contextID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(appID) || string.IsNullOrEmpty(contextID)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(appID) + \" || \" + nameof(contextID));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedLoot(steamID, appID, contextID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedRedeem(ulong steamID, string options, string keys) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(options) || string.IsNullOrEmpty(keys)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(options) + \" || \" + nameof(keys));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] flags = options.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (flags.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(flags)));\n\t\t\t}\n\n\t\t\tERedeemFlags redeemFlags = ERedeemFlags.None;\n\n\t\t\tforeach (string flag in flags) {\n\t\t\t\tswitch (flag.ToUpperInvariant()) {\n\t\t\t\t\tcase \"FAWK\":\n\t\t\t\t\tcase \"FORCEASSUMEWALLETKEY\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"FD\":\n\t\t\t\t\tcase \"FORCEDISTRIBUTING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceDistributing;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"FF\":\n\t\t\t\t\tcase \"FORCEFORWARDING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceForwarding;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"FKMG\":\n\t\t\t\t\tcase \"FORCEKEEPMISSINGGAMES\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceKeepMissingGames;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SAWK\":\n\t\t\t\t\tcase \"SKIPASSUMEWALLETKEY\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SD\":\n\t\t\t\t\tcase \"SKIPDISTRIBUTING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipDistributing;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SF\":\n\t\t\t\t\tcase \"SKIPFORWARDING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipForwarding;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SI\":\n\t\t\t\t\tcase \"SKIPINITIAL\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipInitial;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SKMG\":\n\t\t\t\t\tcase \"SKIPKEEPMISSINGGAMES\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipKeepMissingGames;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"V\":\n\t\t\t\t\tcase \"VALIDATE\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.Validate;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, flag));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await ResponseRedeem(steamID, keys, redeemFlags).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAdvancedRedeem(ulong steamID, string botNames, string options, string keys) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(options) || string.IsNullOrEmpty(keys)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(options) + \" || \" + nameof(keys));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedRedeem(steamID, options, keys))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedTransfer(ulong steamID, uint appID, ulong contextID, Bot targetBot) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (appID == 0) || (contextID == 0) || (targetBot == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(appID) + \" || \" + nameof(contextID) + \" || \" + nameof(targetBot));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID, targetBot.SteamID).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedTransfer(ulong steamID, string targetAppID, string targetContextID, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppID) || string.IsNullOrEmpty(targetContextID) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppID) + \" || \" + nameof(targetContextID) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatBotResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t\t}\n\n\t\t\treturn await ResponseAdvancedTransfer(steamID, appID, contextID, targetBot).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAdvancedTransfer(ulong steamID, string botNames, string targetAppID, string targetContextID, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppID) || string.IsNullOrEmpty(targetContextID) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppID) + \" || \" + nameof(targetContextID) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedTransfer(steamID, appID, contextID, targetBot))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBackgroundGamesRedeemer(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tuint count = Bot.GamesToRedeemInBackgroundCount;\n\n\t\t\treturn FormatBotResponse(string.Format(Strings.BotGamesToRedeemInBackgroundCount, count));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBackgroundGamesRedeemer(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBackgroundGamesRedeemer(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBlacklist(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tIReadOnlyCollection<ulong> blacklist = Bot.BotDatabase.GetBlacklistedFromTradesSteamIDs();\n\n\t\t\treturn FormatBotResponse(blacklist.Count > 0 ? string.Join(\", \", blacklist) : string.Format(Strings.ErrorIsEmpty, nameof(blacklist)));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBlacklist(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBlacklist(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBlacklistAdd(ulong steamID, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<ulong> targetIDs = new HashSet<ulong>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t\t}\n\n\t\t\t\ttargetIDs.Add(targetID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.AddBlacklistedFromTradesSteamIDs(targetIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBlacklistAdd(ulong steamID, string botNames, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBlacklistAdd(steamID, targetSteamIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBlacklistRemove(ulong steamID, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<ulong> targetIDs = new HashSet<ulong>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t\t}\n\n\t\t\t\ttargetIDs.Add(targetID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.RemoveBlacklistedFromTradesSteamIDs(targetIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBlacklistRemove(ulong steamID, string botNames, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBlacklistRemove(steamID, targetSteamIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate static string? ResponseEncrypt(ulong steamID, string cryptoMethodText, string stringToEncrypt) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(cryptoMethodText) || string.IsNullOrEmpty(stringToEncrypt)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(cryptoMethodText) + \" || \" + nameof(stringToEncrypt));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Enum.TryParse(cryptoMethodText, true, out ArchiCryptoHelper.ECryptoMethod cryptoMethod)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(cryptoMethod)));\n\t\t\t}\n\n\t\t\tstring? encryptedString = Actions.Encrypt(cryptoMethod, stringToEncrypt);\n\n\t\t\treturn FormatStaticResponse(!string.IsNullOrEmpty(encryptedString) ? string.Format(Strings.Result, encryptedString) : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static string? ResponseExit(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Actions.Exit();\n\n\t\t\treturn FormatStaticResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponseFarm(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.CardsFarmer.NowFarming) {\n\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseFarm(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseFarm(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseHelp(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing) ? FormatBotResponse(SharedInfo.ProjectURL + \"/wiki/Commands\") : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleBlacklist(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tIReadOnlyCollection<uint> idleBlacklist = Bot.BotDatabase.GetIdlingBlacklistedAppIDs();\n\n\t\t\treturn FormatBotResponse(idleBlacklist.Count > 0 ? string.Join(\", \", idleBlacklist) : string.Format(Strings.ErrorIsEmpty, nameof(idleBlacklist)));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleBlacklist(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleBlacklist(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleBlacklistAdd(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.AddIdlingBlacklistedAppIDs(appIDs);\n\n\t\t\tif (Bot.CardsFarmer.NowFarming && Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID))) {\n\t\t\t\tUtilities.InBackground(\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleBlacklistAdd(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleBlacklistAdd(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleBlacklistRemove(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.RemoveIdlingBlacklistedAppIDs(appIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleBlacklistRemove(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleBlacklistRemove(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleQueue(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tIReadOnlyCollection<uint> idleQueue = Bot.BotDatabase.GetIdlingPriorityAppIDs();\n\n\t\t\treturn FormatBotResponse(idleQueue.Count > 0 ? string.Join(\", \", idleQueue) : string.Format(Strings.ErrorIsEmpty, nameof(idleQueue)));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleQueue(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleQueue(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleQueueAdd(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.AddIdlingPriorityAppIDs(appIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleQueueAdd(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleQueueAdd(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleQueueRemove(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.RemoveIdlingPriorityAppIDs(appIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleQueueRemove(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleQueueRemove(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseInput(ulong steamID, string propertyName, string inputValue) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(inputValue)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(propertyName) + \" || \" + nameof(inputValue));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbool headless = ASF.GlobalConfig?.Headless ?? GlobalConfig.DefaultHeadless;\n\n\t\t\tif (!headless) {\n\t\t\t\treturn FormatBotResponse(Strings.ErrorFunctionOnlyInHeadlessMode);\n\t\t\t}\n\n\t\t\tif (!Enum.TryParse(propertyName, true, out ASF.EUserInputType inputType) || (inputType == ASF.EUserInputType.None) || !Enum.IsDefined(typeof(ASF.EUserInputType), inputType)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(inputType)));\n\t\t\t}\n\n\t\t\tbool result = Bot.SetUserInput(inputType, inputValue);\n\n\t\t\treturn FormatBotResponse(result ? Strings.Done : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseInput(ulong steamID, string botNames, string propertyName, string inputValue) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(inputValue)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(propertyName) + \" || \" + nameof(inputValue));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseInput(steamID, propertyName, inputValue)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseLevel(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tuint? level = await Bot.ArchiHandler.GetLevel().ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(level.HasValue ? string.Format(Strings.BotLevel, level.Value) : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseLevel(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLevel(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseLoot(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseLoot(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLoot(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseLootByRealAppIDs(ulong steamID, string realAppIDsText, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(realAppIDsText));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t\t}\n\n\t\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (appIDTexts.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t\t}\n\n\t\t\tHashSet<uint> realAppIDs = new HashSet<uint>();\n\n\t\t\tforeach (string appIDText in appIDTexts) {\n\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\trealAppIDs.Add(appID);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseLootByRealAppIDs(ulong steamID, string botNames, string realAppIDsText, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(realAppIDsText));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLootByRealAppIDs(steamID, realAppIDsText, exclude))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseNickname(ulong steamID, string nickname) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(nickname)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(nickname));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tBot.SteamFriends.SetPersonaName(nickname);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseNickname(ulong steamID, string botNames, string nickname) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(nickname)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(nickname));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseNickname(steamID, nickname)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<(string? Response, Dictionary<string, string>? OwnedGames)> ResponseOwns(ulong steamID, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn (null, null);\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotNotConnected), null);\n\t\t\t}\n\n\t\t\tDictionary<uint, string>? gamesOwned = await FetchGamesOwned(true).ConfigureAwait(false);\n\n\t\t\tStringBuilder response = new StringBuilder();\n\t\t\tDictionary<string, string> result = new Dictionary<string, string>();\n\n\t\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tforeach (string entry in entries) {\n\t\t\t\tstring game;\n\t\t\t\tstring type;\n\n\t\t\t\tint index = entry.IndexOf('/');\n\n\t\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\t\tgame = entry.Substring(index + 1);\n\t\t\t\t\ttype = entry.Substring(0, index);\n\t\t\t\t} else if (uint.TryParse(entry, out uint appID) && (appID > 0)) {\n\t\t\t\t\tgame = entry;\n\t\t\t\t\ttype = \"APP\";\n\t\t\t\t} else {\n\t\t\t\t\tgame = entry;\n\t\t\t\t\ttype = \"NAME\";\n\t\t\t\t}\n\n\t\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\t\tcase \"A\" when uint.TryParse(game, out uint appID) && (appID > 0):\n\t\t\t\t\tcase \"APP\" when uint.TryParse(game, out appID) && (appID > 0):\n\t\t\t\t\t\tHashSet<uint>? packageIDs = ASF.GlobalDatabase?.GetPackageIDs(appID, Bot.OwnedPackageIDs.Keys);\n\n\t\t\t\t\t\tif ((packageIDs != null) && (packageIDs.Count > 0)) {\n\t\t\t\t\t\t\tif ((gamesOwned != null) && gamesOwned.TryGetValue(appID, out string? cachedGameName)) {\n\t\t\t\t\t\t\t\tresult[\"app/\" + appID] = cachedGameName;\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, cachedGameName)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[\"app/\" + appID] = appID.ToString();\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlready, \"app/\" + appID)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (gamesOwned.TryGetValue(appID, out string? gameName)) {\n\t\t\t\t\t\t\t\tresult[\"app/\" + appID] = gameName;\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, gameName)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, \"app/\" + appID)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"R\":\n\t\t\t\t\tcase \"REGEX\":\n\t\t\t\t\t\tRegex regex;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tregex = new Regex(game);\n\t\t\t\t\t\t} catch (ArgumentException e) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(regex))));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool foundWithRegex = false;\n\n\t\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => regex.IsMatch(gameOwned.Value))) {\n\t\t\t\t\t\t\tfoundWithRegex = true;\n\n\t\t\t\t\t\t\tresult[\"app/\" + appID] = gameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, gameName)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!foundWithRegex) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase \"S\" when uint.TryParse(game, out uint packageID) && (packageID > 0):\n\t\t\t\t\tcase \"SUB\" when uint.TryParse(game, out packageID) && (packageID > 0):\n\t\t\t\t\t\tif (Bot.OwnedPackageIDs.ContainsKey(packageID)) {\n\t\t\t\t\t\t\tresult[\"sub/\" + packageID] = packageID.ToString();\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlready, \"sub/\" + packageID)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, \"sub/\" + packageID)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool foundWithName = false;\n\n\t\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => gameOwned.Value.IndexOf(game, StringComparison.OrdinalIgnoreCase) >= 0)) {\n\t\t\t\t\t\t\tfoundWithName = true;\n\n\t\t\t\t\t\t\tresult[\"app/\" + appID] = gameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, gameName)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!foundWithName) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (response.Length > 0 ? response.ToString() : FormatBotResponse(string.Format(Strings.BotNotOwnedYet, query)), result);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseOwns(ulong steamID, string botNames, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<(string? Response, Dictionary<string, string>? OwnedGames)> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseOwns(steamID, query))).ConfigureAwait(false);\n\n\t\t\tList<(string Response, Dictionary<string, string> OwnedGames)> validResults = new List<(string Response, Dictionary<string, string> OwnedGames)>(results.Where(result => !string.IsNullOrEmpty(result.Response) && (result.OwnedGames != null))!);\n\n\t\t\tif (validResults.Count == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tDictionary<string, (ushort Count, string GameName)> ownedGamesStats = new Dictionary<string, (ushort Count, string GameName)>();\n\n\t\t\tforeach ((string gameID, string gameName) in validResults.Where(validResult => validResult.OwnedGames.Count > 0).SelectMany(validResult => validResult.OwnedGames)) {\n\t\t\t\tif (ownedGamesStats.TryGetValue(gameID, out (ushort Count, string GameName) ownedGameStats)) {\n\t\t\t\t\townedGameStats.Count++;\n\t\t\t\t} else {\n\t\t\t\t\townedGameStats.Count = 1;\n\t\t\t\t}\n\n\t\t\t\tif (!string.IsNullOrEmpty(gameName)) {\n\t\t\t\t\townedGameStats.GameName = gameName;\n\t\t\t\t}\n\n\t\t\t\townedGamesStats[gameID] = ownedGameStats;\n\t\t\t}\n\n\t\t\tIEnumerable<string> extraResponses = ownedGamesStats.Select(kv => FormatStaticResponse(string.Format(Strings.BotOwnsOverviewPerGame, kv.Value.Count, validResults.Count, kv.Key + (!string.IsNullOrEmpty(kv.Value.GameName) ? \" | \" + kv.Value.GameName : \"\"))));\n\n\t\t\treturn string.Join(Environment.NewLine, validResults.Select(result => result.Response).Concat(extraResponses));\n\t\t}\n\n\t\tprivate string? ResponsePassword(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(Bot.BotConfig.DecryptedSteamPassword)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(BotConfig.DecryptedSteamPassword)));\n\t\t\t}\n\n\t\t\tDictionary<ArchiCryptoHelper.ECryptoMethod, string> encryptedPasswords = new Dictionary<ArchiCryptoHelper.ECryptoMethod, string>(2) {\n\t\t\t\t{ ArchiCryptoHelper.ECryptoMethod.AES, ArchiCryptoHelper.Encrypt(ArchiCryptoHelper.ECryptoMethod.AES, Bot.BotConfig.DecryptedSteamPassword!) ?? \"\" },\n\t\t\t\t{ ArchiCryptoHelper.ECryptoMethod.ProtectedDataForCurrentUser, ArchiCryptoHelper.Encrypt(ArchiCryptoHelper.ECryptoMethod.ProtectedDataForCurrentUser, Bot.BotConfig.DecryptedSteamPassword!) ?? \"\" }\n\t\t\t};\n\n\t\t\treturn FormatBotResponse(string.Join(\", \", encryptedPasswords.Where(kv => !string.IsNullOrEmpty(kv.Value)).Select(kv => string.Format(Strings.BotEncryptedPassword, kv.Key, kv.Value))));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePassword(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponsePassword(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePause(ulong steamID, bool permanent, string? resumeInSecondsText = null) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (permanent && !Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t\t}\n\n\t\t\tushort resumeInSeconds = 0;\n\n\t\t\tif (!string.IsNullOrEmpty(resumeInSecondsText) && (!ushort.TryParse(resumeInSecondsText, out resumeInSeconds) || (resumeInSeconds == 0))) {\n\t\t\t\treturn string.Format(Strings.ErrorIsInvalid, nameof(resumeInSecondsText));\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.Pause(permanent, resumeInSeconds).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePause(ulong steamID, string botNames, bool permanent, string? resumeInSecondsText = null) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePause(steamID, permanent, resumeInSecondsText))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePlay(ulong steamID, IReadOnlyCollection<uint> gameIDs, string? gameName = null) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (gameIDs == null) || (gameIDs.Count > ArchiHandler.MaxGamesPlayedConcurrently)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(gameIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.Play(gameIDs, gameName).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePlay(ulong steamID, string targetGameIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetGameIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tstring[] games = targetGameIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (games.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(games)));\n\t\t\t}\n\n\t\t\tHashSet<uint> gamesToPlay = new HashSet<uint>();\n\t\t\tStringBuilder gameName = new StringBuilder();\n\n\t\t\tforeach (string game in games) {\n\t\t\t\tif (!uint.TryParse(game, out uint gameID) || (gameID == 0)) {\n\t\t\t\t\tgameName.Append((gameName.Length > 0 ? \" \" : \"\") + game);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (gamesToPlay.Count >= ArchiHandler.MaxGamesPlayedConcurrently) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.WarningFailedWithError, nameof(gamesToPlay) + \" > \" + ArchiHandler.MaxGamesPlayedConcurrently));\n\t\t\t\t}\n\n\t\t\t\tgamesToPlay.Add(gameID);\n\t\t\t}\n\n\t\t\treturn await ResponsePlay(steamID, gamesToPlay, gameName.Length > 0 ? gameName.ToString() : null).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePlay(ulong steamID, string botNames, string targetGameIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetGameIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePlay(steamID, targetGameIDs))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePrivacy(ulong steamID, string privacySettingsText) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(privacySettingsText));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tstring[] privacySettingsArgs = privacySettingsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (privacySettingsArgs.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(privacySettingsArgs)));\n\t\t\t}\n\n\t\t\t// There are only 7 privacy settings\n\t\t\tif (privacySettingsArgs.Length > 7) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t\t}\n\n\t\t\tArchiHandler.EPrivacySetting profile = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting ownedGames = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting playtime = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting friendsList = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting inventory = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting inventoryGifts = ArchiHandler.EPrivacySetting.Private;\n\t\t\tSteam.UserPrivacy.ECommentPermission comments = Steam.UserPrivacy.ECommentPermission.Private;\n\n\t\t\t// Converting digits to enum\n\t\t\tfor (byte index = 0; index < privacySettingsArgs.Length; index++) {\n\t\t\t\tif (!Enum.TryParse(privacySettingsArgs[index], true, out ArchiHandler.EPrivacySetting privacySetting) || (privacySetting == ArchiHandler.EPrivacySetting.Unknown) || !Enum.IsDefined(typeof(ArchiHandler.EPrivacySetting), privacySetting)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t\t\t}\n\n\t\t\t\t// Child setting can't be less restrictive than its parent\n\t\t\t\tswitch (index) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t// Profile\n\t\t\t\t\t\tprofile = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t// OwnedGames, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\townedGames = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t// Playtime, child of OwnedGames\n\t\t\t\t\t\tif (ownedGames < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(playtime)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplaytime = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t// FriendsList, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfriendsList = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\t// Inventory, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(inventory)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinventory = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\t// InventoryGifts, child of Inventory\n\t\t\t\t\t\tif (inventory < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(inventoryGifts)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinventoryGifts = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\t// Comments, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(comments)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Comments use different numbers than everything else, but we want to have this command consistent for end-user, so we'll map them\n\t\t\t\t\t\tswitch (privacySetting) {\n\t\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.FriendsOnly:\n\t\t\t\t\t\t\t\tcomments = Steam.UserPrivacy.ECommentPermission.FriendsOnly;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Private:\n\t\t\t\t\t\t\t\tcomments = Steam.UserPrivacy.ECommentPermission.Private;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Public:\n\t\t\t\t\t\t\t\tcomments = Steam.UserPrivacy.ECommentPermission.Public;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(privacySetting), privacySetting));\n\n\t\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(privacySetting)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(index), index));\n\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(index)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSteam.UserPrivacy userPrivacy = new Steam.UserPrivacy(new Steam.UserPrivacy.PrivacySettings(profile, ownedGames, playtime, friendsList, inventory, inventoryGifts), comments);\n\n\t\t\treturn FormatBotResponse(await Bot.ArchiWebHandler.ChangePrivacySettings(userPrivacy).ConfigureAwait(false) ? Strings.Success : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePrivacy(ulong steamID, string botNames, string privacySettingsText) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(privacySettingsText));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePrivacy(steamID, privacySettingsText))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseRedeem(ulong steamID, string keysText, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(keysText) || (Bot.Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(keysText) + \" || \" + nameof(Bot.Bots));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tstring[] keys = keysText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (keys.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(keys)));\n\t\t\t}\n\n\t\t\tbool forward = !redeemFlags.HasFlag(ERedeemFlags.SkipForwarding) && (redeemFlags.HasFlag(ERedeemFlags.ForceForwarding) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Forwarding));\n\t\t\tbool distribute = !redeemFlags.HasFlag(ERedeemFlags.SkipDistributing) && (redeemFlags.HasFlag(ERedeemFlags.ForceDistributing) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Distributing));\n\t\t\tbool keepMissingGames = !redeemFlags.HasFlag(ERedeemFlags.SkipKeepMissingGames) && (redeemFlags.HasFlag(ERedeemFlags.ForceKeepMissingGames) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.KeepMissingGames));\n\t\t\tbool assumeWalletKeyOnBadActivationCode = !redeemFlags.HasFlag(ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode) && (redeemFlags.HasFlag(ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.AssumeWalletKeyOnBadActivationCode));\n\n\t\t\tHashSet<string> pendingKeys = keys.ToHashSet(StringComparer.Ordinal);\n\t\t\tHashSet<string> unusedKeys = pendingKeys.ToHashSet(StringComparer.Ordinal);\n\n\t\t\tHashSet<Bot> rateLimitedBots = new HashSet<Bot>();\n\t\t\tHashSet<Bot> triedBots = new HashSet<Bot>();\n\n\t\t\tStringBuilder response = new StringBuilder();\n\n\t\t\tusing (HashSet<string>.Enumerator keysEnumerator = pendingKeys.GetEnumerator()) {\n\t\t\t\t// Initial key\n\t\t\t\tstring? key = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\t\tstring? previousKey = key;\n\n\t\t\t\twhile (!string.IsNullOrEmpty(key)) {\n\t\t\t\t\tstring startingKey = key!;\n\n\t\t\t\t\tusing (IEnumerator<Bot> botsEnumerator = Bot.Bots.Where(bot => (bot.Value != Bot) && bot.Value.IsConnectedAndLoggedOn && bot.Value.Commands.Bot.HasPermission(steamID, BotConfig.EPermission.Operator)).OrderByDescending(bot => Bot.BotsComparer?.Compare(bot.Key, Bot.BotName) > 0).ThenBy(bot => bot.Key, Bot.BotsComparer).Select(bot => bot.Value).GetEnumerator()) {\n\t\t\t\t\t\tBot? currentBot = Bot;\n\n\t\t\t\t\t\twhile (!string.IsNullOrEmpty(key) && (currentBot != null)) {\n\t\t\t\t\t\t\tif (previousKey != key) {\n\t\t\t\t\t\t\t\ttriedBots.Clear();\n\t\t\t\t\t\t\t\tpreviousKey = key;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (redeemFlags.HasFlag(ERedeemFlags.Validate) && !Utilities.IsValidCdKey(key!)) {\n\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((currentBot == Bot) && redeemFlags.HasFlag(ERedeemFlags.SkipInitial)) {\n\t\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbool skipRequest = triedBots.Contains(currentBot) || rateLimitedBots.Contains(currentBot);\n\n\t\t\t\t\t\t\t\tArchiHandler.PurchaseResponseCallback? result = skipRequest ? new ArchiHandler.PurchaseResponseCallback(EResult.Fail, EPurchaseResultDetail.CancelledByUser) : await currentBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, EPurchaseResultDetail.Timeout), currentBot.BotName));\n\n\t\t\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttriedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\t\tif (((result.PurchaseResultDetail == EPurchaseResultDetail.CannotRedeemCodeFromClient) || ((result.PurchaseResultDetail == EPurchaseResultDetail.BadActivationCode) && assumeWalletKeyOnBadActivationCode)) && (Bot.WalletCurrency != ECurrencyCode.Invalid)) {\n\t\t\t\t\t\t\t\t\t\t// If it's a wallet code, we try to redeem it first, then handle the inner result as our primary one\n\t\t\t\t\t\t\t\t\t\t(EResult Result, EPurchaseResultDetail? PurchaseResult)? walletResult = await currentBot.ArchiWebHandler.RedeemWalletKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\tif (walletResult != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult.Result = walletResult.Value.Result;\n\n\t\t\t\t\t\t\t\t\t\t\t// BadActivationCode is our smart guess in this case\n\t\t\t\t\t\t\t\t\t\t\tresult.PurchaseResultDetail = walletResult.Value.PurchaseResult.GetValueOrDefault(walletResult.Value.Result == EResult.OK ? EPurchaseResultDetail.NoDetail : EPurchaseResultDetail.BadActivationCode);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tresult.Result = EResult.Timeout;\n\t\t\t\t\t\t\t\t\t\t\tresult.PurchaseResultDetail = EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ((result.Items != null) && (result.Items.Count > 0)) {\n\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeemWithItems, key, result.Result + \"/\" + result.PurchaseResultDetail, string.Join(\", \", result.Items)), currentBot.BotName));\n\t\t\t\t\t\t\t\t\t} else if (!skipRequest) {\n\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, result.Result + \"/\" + result.PurchaseResultDetail), currentBot.BotName));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tswitch (result.PurchaseResultDetail) {\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CannotRedeemCodeFromClient:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.Timeout:\n\t\t\t\t\t\t\t\t\t\t\tif ((result.Result != EResult.Timeout) && (result.PurchaseResultDetail != EPurchaseResultDetail.Timeout)) {\n\t\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\tif (result.PurchaseResultDetail == EPurchaseResultDetail.NoDetail) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AccountLocked:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AlreadyPurchased:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CancelledByUser:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DoesNotOwnRequiredApp:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RestrictedCountry:\n\t\t\t\t\t\t\t\t\t\t\tif (!forward || (keepMissingGames && (result.PurchaseResultDetail != EPurchaseResultDetail.AlreadyPurchased))) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (distribute) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Next bot, without changing key\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tDictionary<uint, string> items = result.Items ?? new Dictionary<uint, string>();\n\n\t\t\t\t\t\t\t\t\t\t\tbool alreadyHandled = false;\n\n\t\t\t\t\t\t\t\t\t\t\tforeach (Bot innerBot in Bot.Bots.Where(bot => (bot.Value != currentBot) && (!redeemFlags.HasFlag(ERedeemFlags.SkipInitial) || (bot.Value != Bot)) && !triedBots.Contains(bot.Value) && !rateLimitedBots.Contains(bot.Value) && bot.Value.IsConnectedAndLoggedOn && bot.Value.Commands.Bot.HasPermission(steamID, BotConfig.EPermission.Operator) && ((items.Count == 0) || items.Keys.Any(packageID => !bot.Value.OwnedPackageIDs.ContainsKey(packageID)))).OrderBy(bot => bot.Key, Bot.BotsComparer).Select(bot => bot.Value)) {\n\t\t\t\t\t\t\t\t\t\t\t\tArchiHandler.PurchaseResponseCallback? otherResult = await innerBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (otherResult == null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, EResult.Timeout + \"/\" + EPurchaseResultDetail.Timeout), innerBot.BotName));\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\ttriedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (otherResult.PurchaseResultDetail) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This key is already handled, as we either redeemed it or we're sure it's dupe/invalid\n\t\t\t\t\t\t\t\t\t\t\t\t\t\talreadyHandled = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ((otherResult.Items != null) && (otherResult.Items.Count > 0)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeemWithItems, key, otherResult.Result + \"/\" + otherResult.PurchaseResultDetail, string.Join(\", \", otherResult.Items)), innerBot.BotName));\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, otherResult.Result + \"/\" + otherResult.PurchaseResultDetail), innerBot.BotName));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (alreadyHandled) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (otherResult.Items == null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tforeach ((uint packageID, string packageName) in otherResult.Items.Where(item => !items.ContainsKey(item.Key))) {\n\t\t\t\t\t\t\t\t\t\t\t\t\titems[packageID] = packageName;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\t\t\t\tgoto case EPurchaseResultDetail.CancelledByUser;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result.PurchaseResultDetail), result.PurchaseResultDetail));\n\n\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// We want to change bot in two cases:\n\t\t\t\t\t\t\t// a) When we have distribution enabled, obviously\n\t\t\t\t\t\t\t// b) When we're skipping initial bot AND we have forwarding enabled, otherwise we won't get down to other accounts\n\t\t\t\t\t\t\tif (distribute || (forward && redeemFlags.HasFlag(ERedeemFlags.SkipInitial))) {\n\t\t\t\t\t\t\t\tcurrentBot = botsEnumerator.MoveNext() ? botsEnumerator.Current : null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key == startingKey) {\n\t\t\t\t\t\t// We ran out of bots to try for this key, so change it to avoid infinite loop, next key\n\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unusedKeys.Count > 0) {\n\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.UnusedKeys, string.Join(\", \", unusedKeys))));\n\t\t\t}\n\n\t\t\treturn response.Length > 0 ? response.ToString() : null;\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseRedeem(ulong steamID, string botNames, string keys, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(keys)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(keys));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseRedeem(steamID, keys, redeemFlags))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseReset(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.Play(Enumerable.Empty<uint>(), Bot.BotConfig.CustomGamePlayedWhileIdle).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseReset(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseReset(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate static string? ResponseRestart(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Actions.Restart();\n\n\t\t\treturn FormatStaticResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate string? ResponseResume(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Bot.Actions.Resume();\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseResume(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseResume(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseStart(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Bot.Actions.Start();\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseStart(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStart(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseStats(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tushort memoryInMegabytes = (ushort) (GC.GetTotalMemory(false) / 1024 / 1024);\n\t\t\tTimeSpan uptime = DateTime.UtcNow.Subtract(RuntimeCompatibility.ProcessStartTime.ToUniversalTime());\n\n\t\t\treturn FormatBotResponse(string.Format(Strings.BotStats, memoryInMegabytes, uptime.ToHumanReadable()));\n\t\t}\n\n\t\tprivate (string? Response, Bot Bot) ResponseStatus(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\treturn (null, Bot);\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn (FormatBotResponse(Bot.KeepRunning ? Strings.BotStatusConnecting : Strings.BotStatusNotRunning), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.PlayingBlocked) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusPlayingNotAvailable), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.CardsFarmer.Paused) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusPaused), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.IsAccountLimited) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusLimited), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.IsAccountLocked) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusLocked), Bot);\n\t\t\t}\n\n\t\t\tif (!Bot.CardsFarmer.NowFarming || (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count == 0)) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusNotIdling), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count > 1) {\n\t\t\t\treturn (FormatBotResponse(string.Format(Strings.BotStatusIdlingList, string.Join(\", \", Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Select(game => game.AppID + \" (\" + game.GameName + \")\")), Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t\t\t}\n\n\t\t\tCardsFarmer.Game soloGame = Bot.CardsFarmer.CurrentGamesFarmingReadOnly.First();\n\n\t\t\treturn (FormatBotResponse(string.Format(Strings.BotStatusIdling, soloGame.AppID, soloGame.GameName, soloGame.CardsRemaining, Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseStatus(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<(string? Response, Bot Bot)> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStatus(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<(string Response, Bot Bot)> validResults = new List<(string Response, Bot Bot)>(results.Where(result => !string.IsNullOrEmpty(result.Response))!);\n\n\t\t\tif (validResults.Count == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tHashSet<Bot> botsRunning = validResults.Where(result => result.Bot.KeepRunning).Select(result => result.Bot).ToHashSet();\n\n\t\t\tstring extraResponse = string.Format(Strings.BotStatusOverview, botsRunning.Count, validResults.Count, botsRunning.Sum(bot => bot.CardsFarmer.GamesToFarmReadOnly.Count), botsRunning.Sum(bot => bot.CardsFarmer.GamesToFarmReadOnly.Sum(game => game.CardsRemaining)));\n\n\t\t\treturn string.Join(Environment.NewLine, validResults.Select(result => result.Response).Union(extraResponse.ToEnumerable()));\n\t\t}\n\n\t\tprivate string? ResponseStop(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Bot.Actions.Stop();\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseStop(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStop(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseTransfer(ulong steamID, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatBotResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t\t}\n\n\t\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseTransfer(ulong steamID, string botNames, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransfer(steamID, botNameTo))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseTransferByRealAppIDs(ulong steamID, IReadOnlyCollection<uint> realAppIDs, Bot targetBot, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (realAppIDs == null) || (realAppIDs.Count == 0) || (targetBot == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(realAppIDs) + \" || \" + nameof(targetBot));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t\t}\n\n\t\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t\t}\n\n\t\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponseTransferByRealAppIDs(ulong steamID, string realAppIDsText, string botNameTo, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(realAppIDsText) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(realAppIDsText) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatBotResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (appIDTexts.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t\t}\n\n\t\t\tHashSet<uint> realAppIDs = new HashSet<uint>();\n\n\t\t\tforeach (string appIDText in appIDTexts) {\n\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\trealAppIDs.Add(appID);\n\t\t\t}\n\n\t\t\treturn await ResponseTransferByRealAppIDs(steamID, realAppIDs, targetBot, exclude).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseTransferByRealAppIDs(ulong steamID, string botNames, string realAppIDsText, string botNameTo, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(realAppIDsText) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(realAppIDsText) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (appIDTexts.Length == 0) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t\t}\n\n\t\t\tHashSet<uint> realAppIDs = new HashSet<uint>();\n\n\t\t\tforeach (string appIDText in appIDTexts) {\n\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\trealAppIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransferByRealAppIDs(steamID, realAppIDs, targetBot, exclude))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseUnknown(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn Bot.HasPermission(steamID, BotConfig.EPermission.Operator) ? FormatBotResponse(Strings.UnknownCommand) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseUnpackBoosters(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\t// It'd make sense here to actually check return code of ArchiWebHandler.UnpackBooster(), but it lies most of the time | https://github.com/JustArchi/ArchiSteamFarm/issues/704\n\t\t\tbool completeSuccess = true;\n\n\t\t\t// It'd also make sense to run all of this in parallel, but it seems that Steam has a lot of problems with inventory-related parallel requests | https://steamcommunity.com/groups/ascfarm/discussions/1/3559414588264550284/\n\t\t\ttry {\n\t\t\t\tawait foreach (Steam.Asset item in Bot.ArchiWebHandler.GetInventoryAsync(Bot.SteamID).Where(item => item.Type == Steam.Asset.EType.BoosterPack).ConfigureAwait(false)) {\n\t\t\t\t\tif (!await Bot.ArchiWebHandler.UnpackBooster(item.RealAppID, item.AssetID).ConfigureAwait(false)) {\n\t\t\t\t\t\tcompleteSuccess = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (HttpRequestException e) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\n\t\t\t\tcompleteSuccess = false;\n\t\t\t} catch (Exception e) {\n\t\t\t\tBot.ArchiLogger.LogGenericException(e);\n\n\t\t\t\tcompleteSuccess = false;\n\t\t\t}\n\n\t\t\treturn FormatBotResponse(completeSuccess ? Strings.Success : Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseUnpackBoosters(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseUnpackBoosters(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseUpdate(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string? message, Version? version) = await Actions.Update().ConfigureAwait(false);\n\n\t\t\treturn FormatStaticResponse((success ? Strings.Success : Strings.WarningFailed) + (!string.IsNullOrEmpty(message) ? \" \" + message : version != null ? \" \" + version : \"\"));\n\t\t}\n\n\t\tprivate string? ResponseVersion(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn Bot.HasPermission(steamID, BotConfig.EPermission.Operator) ? FormatBotResponse(string.Format(Strings.BotVersion, SharedInfo.ASF, SharedInfo.Version)) : null;\n\t\t}\n\n\t\tprivate string? ResponseWalletBalance(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn !Bot.IsConnectedAndLoggedOn ? FormatBotResponse(Strings.BotNotConnected) : FormatBotResponse(Bot.WalletCurrency != ECurrencyCode.Invalid ? string.Format(Strings.BotWalletBalance, Bot.WalletBalance / 100.0, Bot.WalletCurrency.ToString()) : Strings.BotHasNoWallet);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseWalletBalance(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseWalletBalance(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\t[Flags]\n\t\tprivate enum ERedeemFlags : ushort {\n\t\t\tNone = 0,\n\t\t\tValidate = 1,\n\t\t\tForceForwarding = 2,\n\t\t\tSkipForwarding = 4,\n\t\t\tForceDistributing = 8,\n\t\t\tSkipDistributing = 16,\n\t\t\tSkipInitial = 32,\n\t\t\tForceKeepMissingGames = 64,\n\t\t\tSkipKeepMissingGames = 128,\n\t\t\tForceAssumeWalletKeyOnBadActivationCode = 256,\n\t\t\tSkipAssumeWalletKeyOnBadActivationCode = 512\n\t\t}\n\t}\n}\n"], "fixing_code": ["//     _                _      _  ____   _                           _____\n//    / \\    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___\n//   / _ \\  | '__|/ __|| '_ \\ | |\\___ \\ | __|/ _ \\ / _` || '_ ` _ \\ | |_  / _` || '__|| '_ ` _ \\\n//  / ___ \\ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |\n// /_/   \\_\\|_|   \\___||_| |_||_||____/  \\__|\\___| \\__,_||_| |_| |_||_|   \\__,_||_|   |_| |_| |_|\n// |\n// Copyright 2015-2020 \u0141ukasz \"JustArchi\" Domeradzki\n// Contact: JustArchi@JustArchi.net\n// |\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// |\n// http://www.apache.org/licenses/LICENSE-2.0\n// |\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Collections;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Collections.Specialized;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing ArchiSteamFarm.Collections;\nusing ArchiSteamFarm.Localization;\nusing ArchiSteamFarm.NLog;\nusing ArchiSteamFarm.Plugins;\nusing JetBrains.Annotations;\nusing Newtonsoft.Json;\nusing SteamKit2;\nusing SteamKit2.Internal;\n\nnamespace ArchiSteamFarm {\n\tpublic sealed class Bot : IAsyncDisposable {\n\t\tinternal const ushort CallbackSleep = 500; // In milliseconds\n\t\tinternal const ushort MaxMessagePrefixLength = MaxMessageLength - ReservedMessageLength - 2; // 2 for a minimum of 2 characters (escape one and real one)\n\t\tinternal const byte MinPlayingBlockedTTL = 60; // Delay in seconds added when account was occupied during our disconnect, to not disconnect other Steam client session too soon\n\n\t\tprivate const char DefaultBackgroundKeysRedeemerSeparator = '\\t';\n\t\tprivate const byte LoginCooldownInMinutes = 25; // Captcha disappears after around 20 minutes, so we make it 25\n\t\tprivate const uint LoginID = 1242; // This must be the same for all ASF bots and all ASF processes\n\t\tprivate const byte MaxInvalidPasswordFailures = WebBrowser.MaxTries; // Max InvalidPassword failures in a row before we determine that our password is invalid (because Steam wrongly returns those, of course)\n\t\tprivate const ushort MaxMessageLength = 5000; // This is a limitation enforced by Steam\n\t\tprivate const byte MaxTwoFactorCodeFailures = WebBrowser.MaxTries; // Max TwoFactorCodeMismatch failures in a row before we determine that our 2FA credentials are invalid (because Steam wrongly returns those, of course)\n\t\tprivate const byte RedeemCooldownInHours = 1; // 1 hour since first redeem attempt, this is a limitation enforced by Steam\n\t\tprivate const byte ReservedMessageLength = 2; // 2 for 2x optional \u2026\n\n\t\t[PublicAPI]\n\t\tpublic static IReadOnlyDictionary<string, Bot>? BotsReadOnly => Bots;\n\n\t\tinternal static ConcurrentDictionary<string, Bot>? Bots { get; private set; }\n\t\tinternal static StringComparer? BotsComparer { get; private set; }\n\t\tinternal static EOSType OSType { get; private set; } = EOSType.Unknown;\n\n\t\tprivate static readonly SemaphoreSlim BotsSemaphore = new SemaphoreSlim(1, 1);\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly Actions Actions;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly ArchiLogger ArchiLogger;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly ArchiWebHandler ArchiWebHandler;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic readonly string BotName;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic readonly CardsFarmer CardsFarmer;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly Commands Commands;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly SteamApps SteamApps;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly SteamConfiguration SteamConfiguration;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic readonly SteamFriends SteamFriends;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic uint GamesToRedeemInBackgroundCount => BotDatabase.GamesToRedeemInBackgroundCount;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool HasMobileAuthenticator => BotDatabase.MobileAuthenticator != null;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool IsConnectedAndLoggedOn => SteamClient.SteamID != null;\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool IsPlayingPossible => !PlayingBlocked && !LibraryLocked;\n\n\t\t[JsonIgnore]\n\t\t[PublicAPI]\n\t\tpublic IReadOnlyCollection<uint> OwnedPackageIDsReadOnly => OwnedPackageIDs.Keys.ToHashSet();\n\n\t\tinternal readonly ArchiHandler ArchiHandler;\n\t\tinternal readonly BotDatabase BotDatabase;\n\n\t\tinternal bool CanReceiveSteamCards => !IsAccountLimited && !IsAccountLocked;\n\t\tinternal bool IsAccountLimited => AccountFlags.HasFlag(EAccountFlags.LimitedUser) || AccountFlags.HasFlag(EAccountFlags.LimitedUserForce);\n\t\tinternal bool IsAccountLocked => AccountFlags.HasFlag(EAccountFlags.Lockdown);\n\n\t\tprivate readonly CallbackManager CallbackManager;\n\t\tprivate readonly SemaphoreSlim CallbackSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly SemaphoreSlim GamesRedeemerInBackgroundSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly Timer HeartBeatTimer;\n\t\tprivate readonly SemaphoreSlim InitializationSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly SemaphoreSlim MessagingSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate readonly ConcurrentDictionary<ArchiHandler.UserNotificationsCallback.EUserNotification, uint> PastNotifications = new ConcurrentDictionary<ArchiHandler.UserNotificationsCallback.EUserNotification, uint>();\n\t\tprivate readonly Statistics? Statistics;\n\t\tprivate readonly SteamClient SteamClient;\n\t\tprivate readonly ConcurrentHashSet<ulong> SteamFamilySharingIDs = new ConcurrentHashSet<ulong>();\n\t\tprivate readonly SteamUser SteamUser;\n\t\tprivate readonly Trading Trading;\n\n#pragma warning disable CS8605\n\t\tprivate IEnumerable<(string FilePath, EFileType FileType)> RelatedFiles {\n\t\t\tget {\n\t\t\t\tforeach (EFileType fileType in Enum.GetValues(typeof(EFileType))) {\n\t\t\t\t\tstring filePath = GetFilePath(fileType);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(filePath)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(filePath));\n\n\t\t\t\t\t\tyield break;\n\t\t\t\t\t}\n\n\t\t\t\t\tyield return (filePath, fileType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#pragma warning restore CS8605\n\n#pragma warning disable IDE0051\n\t\t[JsonProperty(PropertyName = SharedInfo.UlongCompatibilityStringPrefix + nameof(SteamID))]\n\n\t\tprivate string SSteamID => SteamID.ToString();\n#pragma warning restore IDE0051\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic EAccountFlags AccountFlags { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic BotConfig BotConfig { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic bool KeepRunning { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic string? Nickname { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic ASF.EUserInputType RequiredInput { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic ulong SteamID { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic long WalletBalance { get; private set; }\n\n\t\t[JsonProperty]\n\t\t[PublicAPI]\n\t\tpublic ECurrencyCode WalletCurrency { get; private set; }\n\n\t\tinternal ImmutableDictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)> OwnedPackageIDs { get; private set; } = ImmutableDictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)>.Empty;\n\t\tinternal bool PlayingBlocked { get; private set; }\n\t\tinternal bool PlayingWasBlocked { get; private set; }\n\n\t\tprivate string? AuthCode;\n\n#pragma warning disable IDE0052\n\t\t[JsonProperty]\n\t\tprivate string? AvatarHash;\n#pragma warning restore IDE0052\n\n\t\tprivate Timer? ConnectionFailureTimer;\n\t\tprivate bool FirstTradeSent;\n\t\tprivate Timer? GamesRedeemerInBackgroundTimer;\n\t\tprivate byte HeartBeatFailures;\n\t\tprivate byte InvalidPasswordFailures;\n\t\tprivate EResult LastLogOnResult;\n\t\tprivate DateTime LastLogonSessionReplaced;\n\t\tprivate bool LibraryLocked;\n\t\tprivate ulong MasterChatGroupID;\n\t\tprivate Timer? PlayingWasBlockedTimer;\n\t\tprivate bool ReconnectOnUserInitiated;\n\t\tprivate Timer? SendItemsTimer;\n\t\tprivate bool SteamParentalActive = true;\n\t\tprivate SteamSaleEvent? SteamSaleEvent;\n\t\tprivate string? TwoFactorCode;\n\t\tprivate byte TwoFactorCodeFailures;\n\n\t\tprivate Bot(string botName, BotConfig botConfig, BotDatabase botDatabase) {\n\t\t\tif (string.IsNullOrEmpty(botName) || (botConfig == null) || (botDatabase == null) || (Bots == null) || (ASF.GlobalConfig == null) || (ASF.GlobalDatabase == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(botConfig) + \" || \" + nameof(botDatabase) + \" || \" + nameof(Bots) + \" || \" + nameof(ASF.GlobalConfig) + \" || \" + nameof(ASF.GlobalDatabase));\n\t\t\t}\n\n\t\t\tBotName = botName;\n\t\t\tBotConfig = botConfig;\n\t\t\tBotDatabase = botDatabase;\n\n\t\t\tArchiLogger = new ArchiLogger(botName);\n\n\t\t\tBotDatabase.MobileAuthenticator?.Init(this);\n\n\t\t\tArchiWebHandler = new ArchiWebHandler(this);\n\n\t\t\tSteamConfiguration = SteamConfiguration.Create(builder => builder.WithProtocolTypes(ASF.GlobalConfig.SteamProtocols).WithCellID(ASF.GlobalDatabase.CellID).WithServerListProvider(ASF.GlobalDatabase.ServerListProvider).WithHttpClientFactory(ArchiWebHandler.GenerateDisposableHttpClient));\n\n\t\t\t// Initialize\n\t\t\tSteamClient = new SteamClient(SteamConfiguration, botName);\n\n\t\t\tif (Debugging.IsDebugConfigured && Directory.Exists(SharedInfo.DebugDirectory)) {\n\t\t\t\tstring debugListenerPath = Path.Combine(SharedInfo.DebugDirectory, botName);\n\n\t\t\t\ttry {\n\t\t\t\t\tDirectory.CreateDirectory(debugListenerPath);\n\t\t\t\t\tSteamClient.DebugNetworkListener = new NetHookNetworkListener(debugListenerPath, SteamClient);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSteamUnifiedMessages? steamUnifiedMessages = SteamClient.GetHandler<SteamUnifiedMessages>();\n\n\t\t\tArchiHandler = new ArchiHandler(ArchiLogger, steamUnifiedMessages ?? throw new ArgumentNullException(nameof(steamUnifiedMessages)));\n\t\t\tSteamClient.AddHandler(ArchiHandler);\n\n\t\t\tCallbackManager = new CallbackManager(SteamClient);\n\t\t\tCallbackManager.Subscribe<SteamClient.ConnectedCallback>(OnConnected);\n\t\t\tCallbackManager.Subscribe<SteamClient.DisconnectedCallback>(OnDisconnected);\n\n\t\t\tSteamApps = SteamClient.GetHandler<SteamApps>() ?? throw new ArgumentNullException(nameof(SteamApps));\n\t\t\tCallbackManager.Subscribe<SteamApps.GuestPassListCallback>(OnGuestPassList);\n\t\t\tCallbackManager.Subscribe<SteamApps.LicenseListCallback>(OnLicenseList);\n\n\t\t\tSteamFriends = SteamClient.GetHandler<SteamFriends>() ?? throw new ArgumentNullException(nameof(SteamFriends));\n\t\t\tCallbackManager.Subscribe<SteamFriends.FriendsListCallback>(OnFriendsList);\n\t\t\tCallbackManager.Subscribe<SteamFriends.PersonaStateCallback>(OnPersonaState);\n\n\t\t\tCallbackManager.Subscribe<SteamUnifiedMessages.ServiceMethodNotification>(OnServiceMethod);\n\n\t\t\tSteamUser = SteamClient.GetHandler<SteamUser>() ?? throw new ArgumentNullException(nameof(SteamUser));\n\t\t\tCallbackManager.Subscribe<SteamUser.LoggedOffCallback>(OnLoggedOff);\n\t\t\tCallbackManager.Subscribe<SteamUser.LoggedOnCallback>(OnLoggedOn);\n\t\t\tCallbackManager.Subscribe<SteamUser.LoginKeyCallback>(OnLoginKey);\n\t\t\tCallbackManager.Subscribe<SteamUser.UpdateMachineAuthCallback>(OnMachineAuth);\n\t\t\tCallbackManager.Subscribe<SteamUser.WalletInfoCallback>(OnWalletUpdate);\n\n\t\t\tCallbackManager.Subscribe<ArchiHandler.PlayingSessionStateCallback>(OnPlayingSessionState);\n\t\t\tCallbackManager.Subscribe<ArchiHandler.SharedLibraryLockStatusCallback>(OnSharedLibraryLockStatus);\n\t\t\tCallbackManager.Subscribe<ArchiHandler.UserNotificationsCallback>(OnUserNotifications);\n\t\t\tCallbackManager.Subscribe<ArchiHandler.VanityURLChangedCallback>(OnVanityURLChangedCallback);\n\n\t\t\tActions = new Actions(this);\n\t\t\tCardsFarmer = new CardsFarmer(this);\n\t\t\tCommands = new Commands(this);\n\t\t\tTrading = new Trading(this);\n\n\t\t\tif (!Debugging.IsDebugBuild && ASF.GlobalConfig.Statistics) {\n\t\t\t\tStatistics = new Statistics(this);\n\t\t\t}\n\n\t\t\tHeartBeatTimer = new Timer(\n\t\t\t\tasync e => await HeartBeat().ConfigureAwait(false),\n\t\t\t\tnull,\n\t\t\t\tTimeSpan.FromMinutes(1) + TimeSpan.FromSeconds(ASF.LoadBalancingDelay * Bots.Count), // Delay\n\t\t\t\tTimeSpan.FromMinutes(1) // Period\n\t\t\t);\n\t\t}\n\n\t\tpublic async ValueTask DisposeAsync() {\n\t\t\t// Those are objects that are always being created if constructor doesn't throw exception\n\t\t\tArchiWebHandler.Dispose();\n\t\t\tBotDatabase.Dispose();\n\t\t\tCallbackSemaphore.Dispose();\n\t\t\tGamesRedeemerInBackgroundSemaphore.Dispose();\n\t\t\tInitializationSemaphore.Dispose();\n\t\t\tMessagingSemaphore.Dispose();\n\t\t\tTrading.Dispose();\n\n\t\t\tawait Actions.DisposeAsync().ConfigureAwait(false);\n\t\t\tawait CardsFarmer.DisposeAsync().ConfigureAwait(false);\n\t\t\tawait HeartBeatTimer.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t// Those are objects that might be null and the check should be in-place\n\t\t\tif (ConnectionFailureTimer != null) {\n\t\t\t\tawait ConnectionFailureTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (GamesRedeemerInBackgroundTimer != null) {\n\t\t\t\tawait GamesRedeemerInBackgroundTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (PlayingWasBlockedTimer != null) {\n\t\t\t\tawait PlayingWasBlockedTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (SendItemsTimer != null) {\n\t\t\t\tawait SendItemsTimer.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (Statistics != null) {\n\t\t\t\tawait Statistics.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (SteamSaleEvent != null) {\n\t\t\t\tawait SteamSaleEvent.DisposeAsync().ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic static Bot? GetBot(string botName) {\n\t\t\tif (string.IsNullOrEmpty(botName) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (Bots.TryGetValue(botName, out Bot? targetBot)) {\n\t\t\t\treturn targetBot;\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(botName, out ulong steamID) || (steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn Bots.Values.FirstOrDefault(bot => bot.SteamID == steamID);\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic static HashSet<Bot>? GetBots(string args) {\n\t\t\tif (string.IsNullOrEmpty(args) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(args) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tstring[] botNames = args.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tHashSet<Bot> result = new HashSet<Bot>();\n\n\t\t\tforeach (string botName in botNames) {\n\t\t\t\tif (botName.Equals(SharedInfo.ASF, StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tIEnumerable<Bot> allBots = Bots.OrderBy(bot => bot.Key, BotsComparer).Select(bot => bot.Value);\n\t\t\t\t\tresult.UnionWith(allBots);\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (botName.Contains(\"..\")) {\n\t\t\t\t\tstring[] botRange = botName.Split(new[] { \"..\" }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\t\tif (botRange.Length == 2) {\n\t\t\t\t\t\tBot? firstBot = GetBot(botRange[0]);\n\n\t\t\t\t\t\tif (firstBot != null) {\n\t\t\t\t\t\t\tBot? lastBot = GetBot(botRange[1]);\n\n\t\t\t\t\t\t\tif (lastBot != null) {\n\t\t\t\t\t\t\t\tforeach (Bot bot in Bots.OrderBy(bot => bot.Key, BotsComparer).Select(bot => bot.Value).SkipWhile(bot => bot != firstBot)) {\n\t\t\t\t\t\t\t\t\tresult.Add(bot);\n\n\t\t\t\t\t\t\t\t\tif (bot == lastBot) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (botName.StartsWith(\"r!\", StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tstring botsPattern = botName.Substring(2);\n\n\t\t\t\t\tRegexOptions botsRegex = RegexOptions.None;\n\n\t\t\t\t\tif ((BotsComparer == StringComparer.InvariantCulture) || (BotsComparer == StringComparer.Ordinal)) {\n\t\t\t\t\t\tbotsRegex |= RegexOptions.CultureInvariant;\n\t\t\t\t\t} else if ((BotsComparer == StringComparer.InvariantCultureIgnoreCase) || (BotsComparer == StringComparer.OrdinalIgnoreCase)) {\n\t\t\t\t\t\tbotsRegex |= RegexOptions.CultureInvariant | RegexOptions.IgnoreCase;\n\t\t\t\t\t}\n\n\t\t\t\t\tRegex regex;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tregex = new Regex(botsPattern, botsRegex);\n\t\t\t\t\t} catch (ArgumentException e) {\n\t\t\t\t\t\tASF.ArchiLogger.LogGenericWarningException(e);\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tIEnumerable<Bot> regexMatches = Bots.Where(kvp => regex.IsMatch(kvp.Key)).Select(kvp => kvp.Value);\n\t\t\t\t\tresult.UnionWith(regexMatches);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tBot? singleBot = GetBot(botName);\n\n\t\t\t\tif (singleBot == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tresult.Add(singleBot);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic async Task<byte?> GetTradeHoldDuration(ulong steamID, ulong tradeID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (tradeID == 0) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(tradeID) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (SteamFriends.GetFriendRelationship(steamID) == EFriendRelationship.Friend) {\n\t\t\t\tbyte? tradeHoldDurationForUser = await ArchiWebHandler.GetTradeHoldDurationForUser(steamID).ConfigureAwait(false);\n\n\t\t\t\tif (tradeHoldDurationForUser.HasValue) {\n\t\t\t\t\treturn tradeHoldDurationForUser;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBot? targetBot = Bots.Values.FirstOrDefault(bot => bot.SteamID == steamID);\n\n\t\t\tif (targetBot?.IsConnectedAndLoggedOn == true) {\n\t\t\t\tstring? targetTradeToken = await targetBot.ArchiHandler.GetTradeToken().ConfigureAwait(false);\n\n\t\t\t\tif (!string.IsNullOrEmpty(targetTradeToken)) {\n\t\t\t\t\tbyte? tradeHoldDurationForUser = await ArchiWebHandler.GetTradeHoldDurationForUser(steamID, targetTradeToken).ConfigureAwait(false);\n\n\t\t\t\t\tif (tradeHoldDurationForUser.HasValue) {\n\t\t\t\t\t\treturn tradeHoldDurationForUser;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await ArchiWebHandler.GetTradeHoldDurationForTrade(tradeID).ConfigureAwait(false);\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic bool HasPermission(ulong steamID, BotConfig.EPermission permission) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (permission == BotConfig.EPermission.None) || !Enum.IsDefined(typeof(BotConfig.EPermission), permission)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(permission));\n\t\t\t}\n\n\t\t\tif (ASF.IsOwner(steamID)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn permission switch {\n\t\t\t\tBotConfig.EPermission.FamilySharing when SteamFamilySharingIDs.Contains(steamID) => true,\n\t\t\t\t_ => BotConfig.SteamUserPermissions.TryGetValue(steamID, out BotConfig.EPermission realPermission) && (realPermission >= permission)\n\t\t\t};\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic bool SetUserInput(ASF.EUserInputType inputType, string inputValue) {\n\t\t\tif ((inputType == ASF.EUserInputType.None) || !Enum.IsDefined(typeof(ASF.EUserInputType), inputType) || string.IsNullOrEmpty(inputValue)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(inputType) + \" || \" + nameof(inputValue));\n\t\t\t}\n\n\t\t\t// This switch should cover ONLY bot properties\n\t\t\tswitch (inputType) {\n\t\t\t\tcase ASF.EUserInputType.Login:\n\t\t\t\t\tBotConfig.SteamLogin = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.Password:\n\t\t\t\t\tBotConfig.DecryptedSteamPassword = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.SteamGuard:\n\t\t\t\t\tif (inputValue.Length != 5) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tAuthCode = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.SteamParentalCode:\n\t\t\t\t\tif (inputValue.Length != BotConfig.SteamParentalCodeLength) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tBotConfig.SteamParentalCode = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ASF.EUserInputType.TwoFactorAuthentication:\n\t\t\t\t\tswitch (inputValue.Length) {\n\t\t\t\t\t\tcase MobileAuthenticator.BackupCodeDigits:\n\t\t\t\t\t\tcase MobileAuthenticator.CodeDigits:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tinputValue = inputValue.ToUpperInvariant();\n\n\t\t\t\t\tif (inputValue.Any(character => !MobileAuthenticator.CodeCharacters.Contains(character))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tTwoFactorCode = inputValue;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(nameof(inputType));\n\t\t\t}\n\n\t\t\tif (RequiredInput == inputType) {\n\t\t\t\tRequiredInput = ASF.EUserInputType.None;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal void AddGamesToRedeemInBackground(IOrderedDictionary gamesToRedeemInBackground) {\n\t\t\tif ((gamesToRedeemInBackground == null) || (gamesToRedeemInBackground.Count == 0)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(gamesToRedeemInBackground));\n\t\t\t}\n\n\t\t\tBotDatabase.AddGamesToRedeemInBackground(gamesToRedeemInBackground);\n\n\t\t\tif ((GamesRedeemerInBackgroundTimer == null) && BotDatabase.HasGamesToRedeemInBackground && IsConnectedAndLoggedOn) {\n\t\t\t\tUtilities.InBackground(RedeemGamesInBackground);\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task<bool> DeleteAllRelatedFiles() {\n\t\t\tawait BotDatabase.MakeReadOnly().ConfigureAwait(false);\n\n\t\t\tforeach (string filePath in RelatedFiles.Select(file => file.FilePath).Where(File.Exists)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(filePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal bool DeleteRedeemedKeysFiles() {\n\t\t\tstring unusedKeysFilePath = GetFilePath(EFileType.KeysToRedeemUnused);\n\n\t\t\tif (string.IsNullOrEmpty(unusedKeysFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(unusedKeysFilePath));\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (File.Exists(unusedKeysFilePath)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(unusedKeysFilePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring usedKeysFilePath = GetFilePath(EFileType.KeysToRedeemUsed);\n\n\t\t\tif (string.IsNullOrEmpty(usedKeysFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(usedKeysFilePath));\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (File.Exists(usedKeysFilePath)) {\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(usedKeysFilePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal static string FormatBotResponse(string response, string botName) {\n\t\t\tif (string.IsNullOrEmpty(response) || string.IsNullOrEmpty(botName)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response) + \" || \" + nameof(botName));\n\t\t\t}\n\n\t\t\treturn Environment.NewLine + \"<\" + botName + \"> \" + response;\n\t\t}\n\n\t\tinternal async Task<(uint PlayableAppID, DateTime IgnoredUntil, bool IgnoredGlobally)> GetAppDataForIdling(uint appID, float hoursPlayed, bool allowRecursiveDiscovery = true, bool optimisticDiscovery = true) {\n\t\t\tif ((appID == 0) || (hoursPlayed < 0)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(appID) + \" || \" + nameof(hoursPlayed));\n\n\t\t\t\treturn (0, DateTime.MaxValue, true);\n\t\t\t}\n\n\t\t\tHashSet<uint>? packageIDs = ASF.GlobalDatabase?.GetPackageIDs(appID, OwnedPackageIDs.Keys);\n\n\t\t\tif ((packageIDs == null) || (packageIDs.Count == 0)) {\n\t\t\t\treturn (0, DateTime.MaxValue, true);\n\t\t\t}\n\n\t\t\tif ((hoursPlayed < CardsFarmer.HoursForRefund) && !BotConfig.IdleRefundableGames) {\n\t\t\t\tDateTime mostRecent = DateTime.MinValue;\n\n\t\t\t\tforeach (uint packageID in packageIDs) {\n\t\t\t\t\tif (!OwnedPackageIDs.TryGetValue(packageID, out (EPaymentMethod PaymentMethod, DateTime TimeCreated) packageData)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((packageData.PaymentMethod > EPaymentMethod.None) && IsRefundable(packageData.PaymentMethod) && (packageData.TimeCreated > mostRecent)) {\n\t\t\t\t\t\tmostRecent = packageData.TimeCreated;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mostRecent > DateTime.MinValue) {\n\t\t\t\t\tDateTime playableIn = mostRecent.AddDays(CardsFarmer.DaysForRefund);\n\n\t\t\t\t\tif (playableIn > DateTime.UtcNow) {\n\t\t\t\t\t\treturn (0, playableIn, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSteamApps.PICSTokensCallback? tokenCallback = null;\n\n\t\t\tfor (byte i = 0; (i < WebBrowser.MaxTries) && (tokenCallback == null) && IsConnectedAndLoggedOn; i++) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenCallback = await SteamApps.PICSGetAccessTokens(appID, null).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokenCallback == null) {\n\t\t\t\treturn (optimisticDiscovery ? appID : 0, DateTime.MinValue, true);\n\t\t\t}\n\n\t\t\tSteamApps.PICSRequest request = new SteamApps.PICSRequest(appID, tokenCallback.AppTokens.TryGetValue(appID, out ulong accessToken) ? accessToken : 0, false);\n\n\t\t\tAsyncJobMultiple<SteamApps.PICSProductInfoCallback>.ResultSet? productInfoResultSet = null;\n\n\t\t\tfor (byte i = 0; (i < WebBrowser.MaxTries) && (productInfoResultSet == null) && IsConnectedAndLoggedOn; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tproductInfoResultSet = await SteamApps.PICSGetProductInfo(request.ToEnumerable(), Enumerable.Empty<SteamApps.PICSRequest>()).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (productInfoResultSet?.Results == null) {\n\t\t\t\treturn (optimisticDiscovery ? appID : 0, DateTime.MinValue, true);\n\t\t\t}\n\n\t\t\tforeach (Dictionary<uint, SteamApps.PICSProductInfoCallback.PICSProductInfo> productInfoApps in productInfoResultSet.Results.Select(result => result.Apps)) {\n\t\t\t\tif (!productInfoApps.TryGetValue(appID, out SteamApps.PICSProductInfoCallback.PICSProductInfo? productInfoApp)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tKeyValue productInfo = productInfoApp.KeyValues;\n\n\t\t\t\tif (productInfo == KeyValue.Invalid) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(productInfo));\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tKeyValue commonProductInfo = productInfo[\"common\"];\n\n\t\t\t\tif (commonProductInfo == KeyValue.Invalid) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstring? releaseState = commonProductInfo[\"ReleaseState\"].AsString();\n\n\t\t\t\tif (!string.IsNullOrEmpty(releaseState)) {\n\t\t\t\t\t// We must convert this to uppercase, since Valve doesn't stick to any convention and we can have a case mismatch\n\t\t\t\t\tswitch (releaseState!.ToUpperInvariant()) {\n\t\t\t\t\t\tcase \"RELEASED\":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"PRELOADONLY\":\n\t\t\t\t\t\tcase \"PRERELEASE\":\n\t\t\t\t\t\t\treturn (0, DateTime.MaxValue, true);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(releaseState), releaseState));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstring? type = commonProductInfo[\"type\"].AsString();\n\n\t\t\t\tif (string.IsNullOrEmpty(type)) {\n\t\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t\t}\n\n\t\t\t\t// We must convert this to uppercase, since Valve doesn't stick to any convention and we can have a case mismatch\n\t\t\t\tswitch (type!.ToUpperInvariant()) {\n\t\t\t\t\tcase \"APPLICATION\":\n\t\t\t\t\tcase \"EPISODE\":\n\t\t\t\t\tcase \"GAME\":\n\t\t\t\t\tcase \"MOD\":\n\t\t\t\t\tcase \"MOVIE\":\n\t\t\t\t\tcase \"SERIES\":\n\t\t\t\t\tcase \"TOOL\":\n\t\t\t\t\tcase \"VIDEO\":\n\t\t\t\t\t\t// Types that can be idled\n\t\t\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t\t\tcase \"ADVERTISING\":\n\t\t\t\t\tcase \"DEMO\":\n\t\t\t\t\tcase \"DLC\":\n\t\t\t\t\tcase \"GUIDE\":\n\t\t\t\t\tcase \"HARDWARE\":\n\t\t\t\t\tcase \"MUSIC\":\n\t\t\t\t\t\t// Types that can't be idled\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(type), type));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!allowRecursiveDiscovery) {\n\t\t\t\t\treturn (0, DateTime.MinValue, true);\n\t\t\t\t}\n\n\t\t\t\tstring? listOfDlc = productInfo[\"extended\"][\"listofdlc\"].AsString();\n\n\t\t\t\tif (string.IsNullOrEmpty(listOfDlc)) {\n\t\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t\t}\n\n\t\t\t\tstring[] dlcAppIDsTexts = listOfDlc!.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\tforeach (string dlcAppIDsText in dlcAppIDsTexts) {\n\t\t\t\t\tif (!uint.TryParse(dlcAppIDsText, out uint dlcAppID) || (dlcAppID == 0)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(dlcAppID));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t(uint playableAppID, _, _) = await GetAppDataForIdling(dlcAppID, hoursPlayed, false, false).ConfigureAwait(false);\n\n\t\t\t\t\tif (playableAppID != 0) {\n\t\t\t\t\t\treturn (playableAppID, DateTime.MinValue, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn (appID, DateTime.MinValue, true);\n\t\t\t}\n\n\t\t\treturn ((productInfoResultSet.Complete && !productInfoResultSet.Failed) || optimisticDiscovery ? appID : 0, DateTime.MinValue, true);\n\t\t}\n\n\t\tinternal static string GetFilePath(string botName, EFileType fileType) {\n\t\t\tif (string.IsNullOrEmpty(botName) || !Enum.IsDefined(typeof(EFileType), fileType)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(fileType));\n\t\t\t}\n\n\t\t\tstring botPath = Path.Combine(SharedInfo.ConfigDirectory, botName);\n\n\t\t\treturn fileType switch {\n\t\t\t\tEFileType.Config => botPath + SharedInfo.JsonConfigExtension,\n\t\t\t\tEFileType.Database => botPath + SharedInfo.DatabaseExtension,\n\t\t\t\tEFileType.KeysToRedeem => botPath + SharedInfo.KeysExtension,\n\t\t\t\tEFileType.KeysToRedeemUnused => botPath + SharedInfo.KeysExtension + SharedInfo.KeysUnusedExtension,\n\t\t\t\tEFileType.KeysToRedeemUsed => botPath + SharedInfo.KeysExtension + SharedInfo.KeysUsedExtension,\n\t\t\t\tEFileType.MobileAuthenticator => botPath + SharedInfo.MobileAuthenticatorExtension,\n\t\t\t\tEFileType.SentryFile => botPath + SharedInfo.SentryHashExtension,\n\t\t\t\t_ => throw new ArgumentOutOfRangeException(nameof(fileType))\n\t\t\t};\n\t\t}\n\n\t\tinternal async Task<HashSet<uint>?> GetMarketableAppIDs() => await ArchiWebHandler.GetAppList().ConfigureAwait(false);\n\n\t\tinternal async Task<Dictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)>?> GetPackagesData(IReadOnlyCollection<uint> packageIDs) {\n\t\t\tif ((packageIDs == null) || (packageIDs.Count == 0) || (ASF.GlobalDatabase == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(packageIDs) + \" || \" + nameof(ASF.GlobalDatabase));\n\t\t\t}\n\n\t\t\tHashSet<SteamApps.PICSRequest> packageRequests = new HashSet<SteamApps.PICSRequest>();\n\n\t\t\tforeach (uint packageID in packageIDs) {\n\t\t\t\tif (!ASF.GlobalDatabase.PackageAccessTokensReadOnly.TryGetValue(packageID, out ulong packageAccessToken)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tpackageRequests.Add(new SteamApps.PICSRequest(packageID, packageAccessToken, false));\n\t\t\t}\n\n\t\t\tif (packageRequests.Count == 0) {\n\t\t\t\treturn new Dictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)>(0);\n\t\t\t}\n\n\t\t\tAsyncJobMultiple<SteamApps.PICSProductInfoCallback>.ResultSet? productInfoResultSet = null;\n\n\t\t\tfor (byte i = 0; (i < WebBrowser.MaxTries) && (productInfoResultSet == null) && IsConnectedAndLoggedOn; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tproductInfoResultSet = await SteamApps.PICSGetProductInfo(Enumerable.Empty<SteamApps.PICSRequest>(), packageRequests).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (productInfoResultSet?.Results == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tDictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)> result = new Dictionary<uint, (uint ChangeNumber, HashSet<uint>? AppIDs)>();\n\n\t\t\tforeach (SteamApps.PICSProductInfoCallback.PICSProductInfo productInfo in productInfoResultSet.Results.SelectMany(productInfoResult => productInfoResult.Packages).Where(productInfoPackages => productInfoPackages.Key != 0).Select(productInfoPackages => productInfoPackages.Value)) {\n\t\t\t\tif (productInfo.KeyValues == KeyValue.Invalid) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(productInfo));\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t(uint ChangeNumber, HashSet<uint>? AppIDs) value = (productInfo.ChangeNumber, null);\n\n\t\t\t\ttry {\n\t\t\t\t\tKeyValue appIDs = productInfo.KeyValues[\"appids\"];\n\n\t\t\t\t\tif (appIDs == KeyValue.Invalid) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue.AppIDs = new HashSet<uint>(appIDs.Children.Count);\n\n\t\t\t\t\tforeach (string? appIDText in appIDs.Children.Select(app => app.Value)) {\n\t\t\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\t\t\tArchiLogger.LogNullError(nameof(appID));\n\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue.AppIDs.Add(appID);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tresult[productInfo.ID] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tinternal async Task<(Dictionary<string, string>? UnusedKeys, Dictionary<string, string>? UsedKeys)> GetUsedAndUnusedKeys() {\n\t\t\tstring[] files = { GetFilePath(EFileType.KeysToRedeemUnused), GetFilePath(EFileType.KeysToRedeemUsed) };\n\n\t\t\tIList<Dictionary<string, string>?> results = await Utilities.InParallel(files.Select(GetKeysFromFile)).ConfigureAwait(false);\n\n\t\t\treturn (results[0], results[1]);\n\t\t}\n\n\t\tinternal async Task<bool?> HasPublicInventory() {\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tCPrivacySettings? privacySettings = await ArchiHandler.GetPrivacySettings().ConfigureAwait(false);\n\n\t\t\tif (privacySettings == null) {\n\t\t\t\tArchiLogger.LogGenericWarning(Strings.WarningFailed);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn ((ArchiHandler.EPrivacySetting) privacySettings.privacy_state == ArchiHandler.EPrivacySetting.Public) && ((ArchiHandler.EPrivacySetting) privacySettings.privacy_state_inventory == ArchiHandler.EPrivacySetting.Public);\n\t\t}\n\n\t\tinternal async Task IdleGame(CardsFarmer.Game game) {\n\t\t\tif (game == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(game));\n\t\t\t}\n\n\t\t\tstring? gameName = null;\n\n\t\t\tif (!string.IsNullOrEmpty(BotConfig.CustomGamePlayedWhileFarming)) {\n\t\t\t\tgameName = string.Format(BotConfig.CustomGamePlayedWhileFarming!, game.AppID, game.GameName);\n\t\t\t}\n\n\t\t\tawait ArchiHandler.PlayGames(game.PlayableAppID.ToEnumerable(), gameName).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task IdleGames(IReadOnlyCollection<CardsFarmer.Game> games) {\n\t\t\tif ((games == null) || (games.Count == 0)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(games));\n\t\t\t}\n\n\t\t\tstring? gameName = null;\n\n\t\t\tif (!string.IsNullOrEmpty(BotConfig.CustomGamePlayedWhileFarming)) {\n\t\t\t\tgameName = string.Format(BotConfig.CustomGamePlayedWhileFarming!, string.Join(\", \", games.Select(game => game.AppID)), string.Join(\", \", games.Select(game => game.GameName)));\n\t\t\t}\n\n\t\t\tawait ArchiHandler.PlayGames(games.Select(game => game.PlayableAppID), gameName).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task ImportKeysToRedeem(string filePath) {\n\t\t\tif (string.IsNullOrEmpty(filePath) || !File.Exists(filePath)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(filePath));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tOrderedDictionary gamesToRedeemInBackground = new OrderedDictionary();\n\n\t\t\t\tusing (StreamReader reader = new StreamReader(filePath)) {\n\t\t\t\t\tstring? line;\n\n\t\t\t\t\twhile ((line = await reader.ReadLineAsync().ConfigureAwait(false)) != null) {\n\t\t\t\t\t\tif (line.Length == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Valid formats:\n\t\t\t\t\t\t// Key (name will be the same as key and replaced from redemption result, if possible)\n\t\t\t\t\t\t// Name + Key (user provides both, if name is equal to key, above logic is used, otherwise name is kept)\n\t\t\t\t\t\t// Name + <Ignored> + Key (BGR output format, we include extra properties in the middle, those are ignored during import)\n\t\t\t\t\t\tstring[] parsedArgs = line.Split(DefaultBackgroundKeysRedeemerSeparator, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\t\t\tif (parsedArgs.Length < 1) {\n\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, line));\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstring name = parsedArgs[0];\n\t\t\t\t\t\tstring key = parsedArgs[^1];\n\n\t\t\t\t\t\tgamesToRedeemInBackground[key] = name;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (gamesToRedeemInBackground.Count > 0) {\n\t\t\t\t\tIOrderedDictionary validGamesToRedeemInBackground = ValidateGamesToRedeemInBackground(gamesToRedeemInBackground);\n\n\t\t\t\t\tif (validGamesToRedeemInBackground.Count > 0) {\n\t\t\t\t\t\tAddGamesToRedeemInBackground(validGamesToRedeemInBackground);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFile.Delete(filePath);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t}\n\t\t}\n\n\t\tinternal static void Init(StringComparer botsComparer) {\n\t\t\tif (Bots != null) {\n\t\t\t\tASF.ArchiLogger.LogGenericError(Strings.WarningFailed);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotsComparer = botsComparer ?? throw new ArgumentNullException(nameof(botsComparer));\n\t\t\tBots = new ConcurrentDictionary<string, Bot>(botsComparer);\n\t\t}\n\n\t\tinternal bool IsBlacklistedFromIdling(uint appID) {\n\t\t\tif (appID == 0) {\n\t\t\t\tthrow new ArgumentNullException(nameof(appID));\n\t\t\t}\n\n\t\t\treturn BotDatabase.IsBlacklistedFromIdling(appID);\n\t\t}\n\n\t\tinternal bool IsBlacklistedFromTrades(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn BotDatabase.IsBlacklistedFromTrades(steamID);\n\t\t}\n\n\t\tinternal bool IsPriorityIdling(uint appID) {\n\t\t\tif (appID == 0) {\n\t\t\t\tthrow new ArgumentNullException(nameof(appID));\n\t\t\t}\n\n\t\t\treturn BotDatabase.IsPriorityIdling(appID);\n\t\t}\n\n\t\tinternal async Task OnConfigChanged(bool deleted) {\n\t\t\tif (deleted) {\n\t\t\t\tawait Destroy().ConfigureAwait(false);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring configFile = GetFilePath(EFileType.Config);\n\n\t\t\tif (string.IsNullOrEmpty(configFile)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(configFile));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotConfig? botConfig = await BotConfig.Load(configFile).ConfigureAwait(false);\n\n\t\t\tif (botConfig == null) {\n\t\t\t\tawait Destroy().ConfigureAwait(false);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (botConfig == BotConfig) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait InitializationSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\ttry {\n\t\t\t\tif (botConfig == BotConfig) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tStop(botConfig.Enabled);\n\t\t\t\tBotConfig = botConfig;\n\n\t\t\t\tawait InitModules().ConfigureAwait(false);\n\t\t\t\tInitStart();\n\t\t\t} finally {\n\t\t\t\tInitializationSemaphore.Release();\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task OnFarmingFinished(bool farmedSomething) {\n\t\t\tawait OnFarmingStopped().ConfigureAwait(false);\n\n\t\t\tif (BotConfig.SendOnFarmingFinished && (BotConfig.LootableTypes.Count > 0) && (farmedSomething || !FirstTradeSent)) {\n\t\t\t\tFirstTradeSent = true;\n\n\t\t\t\tawait Actions.SendInventory(filterFunction: item => BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tif (BotConfig.ShutdownOnFarmingFinished) {\n\t\t\t\tStop();\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotFarmingFinished(this, farmedSomething).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task OnFarmingStopped() {\n\t\t\tawait ResetGamesPlayed().ConfigureAwait(false);\n\t\t\tawait PluginsCore.OnBotFarmingStopped(this).ConfigureAwait(false);\n\t\t}\n\n\t\tinternal async Task<bool> RefreshSession() {\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSteamUser.WebAPIUserNonceCallback callback;\n\n\t\t\ttry {\n\t\t\t\tcallback = await SteamUser.RequestWebAPIUserNonce().ToLongRunningTask().ConfigureAwait(false);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericWarningException(e);\n\t\t\t\tawait Connect(true).ConfigureAwait(false);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(callback.Nonce)) {\n\t\t\t\tawait Connect(true).ConfigureAwait(false);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (await ArchiWebHandler.Init(SteamID, SteamClient.Universe, callback.Nonce, SteamParentalActive ? BotConfig.SteamParentalCode : null).ConfigureAwait(false)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tawait Connect(true).ConfigureAwait(false);\n\n\t\t\treturn false;\n\t\t}\n\n\t\tinternal static async Task RegisterBot(string botName) {\n\t\t\tif (string.IsNullOrEmpty(botName) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(botName) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (Bots.ContainsKey(botName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring configFilePath = GetFilePath(botName, EFileType.Config);\n\n\t\t\tif (string.IsNullOrEmpty(configFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(configFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotConfig? botConfig = await BotConfig.Load(configFilePath).ConfigureAwait(false);\n\n\t\t\tif (botConfig == null) {\n\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.ErrorBotConfigInvalid, configFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Debugging.IsDebugConfigured) {\n\t\t\t\tASF.ArchiLogger.LogGenericDebug(configFilePath + \": \" + JsonConvert.SerializeObject(botConfig, Formatting.Indented));\n\t\t\t}\n\n\t\t\tstring databaseFilePath = GetFilePath(botName, EFileType.Database);\n\n\t\t\tif (string.IsNullOrEmpty(databaseFilePath)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(databaseFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBotDatabase? botDatabase = await BotDatabase.CreateOrLoad(databaseFilePath).ConfigureAwait(false);\n\n\t\t\tif (botDatabase == null) {\n\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.ErrorDatabaseInvalid, databaseFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Debugging.IsDebugConfigured) {\n\t\t\t\tASF.ArchiLogger.LogGenericDebug(databaseFilePath + \": \" + JsonConvert.SerializeObject(botDatabase, Formatting.Indented));\n\t\t\t}\n\n\t\t\tBot bot;\n\n\t\t\tawait BotsSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\ttry {\n\t\t\t\tif (Bots.ContainsKey(botName)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbot = new Bot(botName, botConfig, botDatabase);\n\n\t\t\t\tif (!Bots.TryAdd(botName, bot)) {\n\t\t\t\t\tASF.ArchiLogger.LogNullError(nameof(bot));\n\n\t\t\t\t\tawait bot.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tBotsSemaphore.Release();\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotInit(bot).ConfigureAwait(false);\n\n\t\t\tHashSet<ClientMsgHandler>? customHandlers = await PluginsCore.OnBotSteamHandlersInit(bot).ConfigureAwait(false);\n\n\t\t\tif ((customHandlers != null) && (customHandlers.Count > 0)) {\n\t\t\t\tforeach (ClientMsgHandler customHandler in customHandlers) {\n\t\t\t\t\tbot.SteamClient.AddHandler(customHandler);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotSteamCallbacksInit(bot, bot.CallbackManager).ConfigureAwait(false);\n\n\t\t\tawait bot.InitModules().ConfigureAwait(false);\n\n\t\t\tbot.InitStart();\n\t\t}\n\n\t\tinternal async Task<bool> Rename(string newBotName) {\n\t\t\tif (string.IsNullOrEmpty(newBotName) || (Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(newBotName) + \" || \" + nameof(Bots));\n\t\t\t}\n\n\t\t\tif (newBotName.Equals(SharedInfo.ASF) || Bots.ContainsKey(newBotName)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (KeepRunning) {\n\t\t\t\tStop(true);\n\t\t\t}\n\n\t\t\tawait BotDatabase.MakeReadOnly().ConfigureAwait(false);\n\n\t\t\t// We handle the config file last as it'll trigger new bot creation\n\t\t\tforeach ((string filePath, EFileType fileType) in RelatedFiles.Where(file => File.Exists(file.FilePath)).OrderByDescending(file => file.FileType != EFileType.Config)) {\n\t\t\t\tstring newFilePath = GetFilePath(newBotName, fileType);\n\n\t\t\t\tif (string.IsNullOrEmpty(newFilePath)) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(newFilePath));\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tFile.Move(filePath, newFilePath);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal void RequestPersonaStateUpdate() {\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSteamFriends.RequestFriendInfo(SteamID, EClientPersonaStateFlag.PlayerName | EClientPersonaStateFlag.Presence);\n\t\t}\n\n\t\tinternal async Task<bool> SendMessage(ulong steamID, string message) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(true, message, steamID: steamID);\n\n\t\t\tstring? steamMessagePrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.SteamMessagePrefix : GlobalConfig.DefaultSteamMessagePrefix;\n\t\t\tushort maxMessageLength = (ushort) (MaxMessageLength - ReservedMessageLength - (steamMessagePrefix?.Length ?? 0));\n\n\t\t\t// We must escape our message prior to sending it\n\t\t\tmessage = Escape(message);\n\n\t\t\tint i = 0;\n\n\t\t\twhile (i < message.Length) {\n\t\t\t\tint partLength;\n\t\t\t\tbool copyNewline = false;\n\n\t\t\t\t// ReSharper disable ArrangeMissingParentheses - conflict with Roslyn\n\t\t\t\tif (message.Length - i > maxMessageLength) {\n\t\t\t\t\tint lastNewLine = message.LastIndexOf(Environment.NewLine, i + maxMessageLength - Environment.NewLine.Length, maxMessageLength - Environment.NewLine.Length, StringComparison.Ordinal);\n\n\t\t\t\t\tif (lastNewLine > i) {\n\t\t\t\t\t\tpartLength = lastNewLine - i + Environment.NewLine.Length;\n\t\t\t\t\t\tcopyNewline = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartLength = maxMessageLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpartLength = message.Length - i;\n\t\t\t\t}\n\n\t\t\t\t// If our message is of max length and ends with a single '\\' then we can't split it here, it escapes the next character\n\t\t\t\tif ((partLength >= maxMessageLength) && (message[i + partLength - 1] == '\\\\') && (message[i + partLength - 2] != '\\\\')) {\n\t\t\t\t\t// Instead, we'll cut this message one char short and include the rest in next iteration\n\t\t\t\t\tpartLength--;\n\t\t\t\t}\n\n\t\t\t\t// ReSharper restore ArrangeMissingParentheses\n\t\t\t\tstring messagePart = message.Substring(i, partLength);\n\n\t\t\t\tmessagePart = steamMessagePrefix + (i > 0 ? \"\u2026\" : \"\") + messagePart + (maxMessageLength < message.Length - i ? \"\u2026\" : \"\");\n\n\t\t\t\tawait MessagingSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\t\ttry {\n\t\t\t\t\tbool sent = false;\n\n\t\t\t\t\tfor (byte j = 0; (j < WebBrowser.MaxTries) && !sent && IsConnectedAndLoggedOn; j++) {\n\t\t\t\t\t\t// We add a one-second delay here to avoid Steam screwup in form of a ghost notification\n\t\t\t\t\t\t// The exact cause is unknown, but the theory is that Steam is confused when dealing with more than 1 message per second from the same user\n\t\t\t\t\t\tawait Task.Delay(1000).ConfigureAwait(false);\n\n\t\t\t\t\t\tEResult result = await ArchiHandler.SendMessage(steamID, messagePart).ConfigureAwait(false);\n\n\t\t\t\t\t\tswitch (result) {\n\t\t\t\t\t\t\tcase EResult.Busy:\n\t\t\t\t\t\t\tcase EResult.Fail:\n\t\t\t\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\t\t\t\tcase EResult.Timeout:\n\t\t\t\t\t\t\t\tawait Task.Delay(5000).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcase EResult.OK:\n\t\t\t\t\t\t\t\tsent = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result), result));\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.WarningFailed);\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tMessagingSemaphore.Release();\n\t\t\t\t}\n\n\t\t\t\ti += partLength - (copyNewline ? Environment.NewLine.Length : 0);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal async Task<bool> SendMessage(ulong chatGroupID, ulong chatID, string message) {\n\t\t\tif ((chatGroupID == 0) || (chatID == 0) || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(chatGroupID) + \" || \" + nameof(chatID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(true, message, chatGroupID, chatID);\n\n\t\t\tstring? steamMessagePrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.SteamMessagePrefix : GlobalConfig.DefaultSteamMessagePrefix;\n\t\t\tushort maxMessageLength = (ushort) (MaxMessageLength - ReservedMessageLength - (steamMessagePrefix?.Length ?? 0));\n\n\t\t\t// We must escape our message prior to sending it\n\t\t\tmessage = Escape(message);\n\n\t\t\tint i = 0;\n\n\t\t\t// ReSharper disable ArrangeMissingParentheses - conflict with Roslyn\n\t\t\twhile (i < message.Length) {\n\t\t\t\tint partLength;\n\t\t\t\tbool copyNewline = false;\n\n\t\t\t\tif (message.Length - i > maxMessageLength) {\n\t\t\t\t\tint lastNewLine = message.LastIndexOf(Environment.NewLine, i + maxMessageLength - Environment.NewLine.Length, maxMessageLength - Environment.NewLine.Length, StringComparison.Ordinal);\n\n\t\t\t\t\tif (lastNewLine > i) {\n\t\t\t\t\t\tpartLength = lastNewLine - i + Environment.NewLine.Length;\n\t\t\t\t\t\tcopyNewline = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpartLength = maxMessageLength;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpartLength = message.Length - i;\n\t\t\t\t}\n\n\t\t\t\t// If our message is of max length and ends with a single '\\' then we can't split it here, it escapes the next character\n\t\t\t\tif ((partLength >= maxMessageLength) && (message[i + partLength - 1] == '\\\\') && (message[i + partLength - 2] != '\\\\')) {\n\t\t\t\t\t// Instead, we'll cut this message one char short and include the rest in next iteration\n\t\t\t\t\tpartLength--;\n\t\t\t\t}\n\n\t\t\t\t// ReSharper restore ArrangeMissingParentheses\n\t\t\t\tstring messagePart = message.Substring(i, partLength);\n\n\t\t\t\tmessagePart = steamMessagePrefix + (i > 0 ? \"\u2026\" : \"\") + messagePart + (maxMessageLength < message.Length - i ? \"\u2026\" : \"\");\n\n\t\t\t\tawait MessagingSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\t\ttry {\n\t\t\t\t\tbool sent = false;\n\n\t\t\t\t\tfor (byte j = 0; (j < WebBrowser.MaxTries) && !sent && IsConnectedAndLoggedOn; j++) {\n\t\t\t\t\t\tEResult result = await ArchiHandler.SendMessage(chatGroupID, chatID, messagePart).ConfigureAwait(false);\n\n\t\t\t\t\t\tswitch (result) {\n\t\t\t\t\t\t\tcase EResult.Busy:\n\t\t\t\t\t\t\tcase EResult.Fail:\n\t\t\t\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\t\t\t\tcase EResult.Timeout:\n\t\t\t\t\t\t\t\tawait Task.Delay(5000).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tcase EResult.OK:\n\t\t\t\t\t\t\t\tsent = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result), result));\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.WarningFailed);\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tMessagingSemaphore.Release();\n\t\t\t\t}\n\n\t\t\t\ti += partLength - (copyNewline ? Environment.NewLine.Length : 0);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tinternal async Task<bool> SendTypingMessage(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!IsConnectedAndLoggedOn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn await ArchiHandler.SendTypingStatus(steamID).ConfigureAwait(false) == EResult.OK;\n\t\t}\n\n\t\tinternal async Task Start() {\n\t\t\tif (KeepRunning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tKeepRunning = true;\n\t\t\tUtilities.InBackground(HandleCallbacks, true);\n\t\t\tArchiLogger.LogGenericInfo(Strings.Starting);\n\n\t\t\t// Support and convert 2FA files\n\t\t\tif (!HasMobileAuthenticator) {\n\t\t\t\tstring mobileAuthenticatorFilePath = GetFilePath(EFileType.MobileAuthenticator);\n\n\t\t\t\tif (string.IsNullOrEmpty(mobileAuthenticatorFilePath)) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(mobileAuthenticatorFilePath));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (File.Exists(mobileAuthenticatorFilePath)) {\n\t\t\t\t\tawait ImportAuthenticator(mobileAuthenticatorFilePath).ConfigureAwait(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring keysToRedeemFilePath = GetFilePath(EFileType.KeysToRedeem);\n\n\t\t\tif (string.IsNullOrEmpty(keysToRedeemFilePath)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(keysToRedeemFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (File.Exists(keysToRedeemFilePath)) {\n\t\t\t\tawait ImportKeysToRedeem(keysToRedeemFilePath).ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tawait Connect().ConfigureAwait(false);\n\t\t}\n\n\t\tinternal void Stop(bool skipShutdownEvent = false) {\n\t\t\tif (!KeepRunning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tKeepRunning = false;\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotStopping);\n\n\t\t\tif (SteamClient.IsConnected) {\n\t\t\t\tDisconnect();\n\t\t\t}\n\n\t\t\tif (!skipShutdownEvent) {\n\t\t\t\tUtilities.InBackground(Events.OnBotShutdown);\n\t\t\t}\n\t\t}\n\n#pragma warning disable CS8605\n\t\tinternal static IOrderedDictionary ValidateGamesToRedeemInBackground(IOrderedDictionary gamesToRedeemInBackground) {\n\t\t\tif ((gamesToRedeemInBackground == null) || (gamesToRedeemInBackground.Count == 0)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(gamesToRedeemInBackground));\n\t\t\t}\n\n\t\t\tHashSet<object> invalidKeys = new HashSet<object>();\n\n\t\t\tforeach (DictionaryEntry game in gamesToRedeemInBackground) {\n\t\t\t\tbool invalid = false;\n\n\t\t\t\tstring? key = game.Key as string;\n\n\t\t\t\tif (string.IsNullOrEmpty(key)) {\n\t\t\t\t\tinvalid = true;\n\t\t\t\t\tASF.ArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, nameof(key)));\n\t\t\t\t} else if (!Utilities.IsValidCdKey(key!)) {\n\t\t\t\t\tinvalid = true;\n\t\t\t\t\tASF.ArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, key));\n\t\t\t\t}\n\n\t\t\t\tstring? name = game.Value as string;\n\n\t\t\t\tif (string.IsNullOrEmpty(name)) {\n\t\t\t\t\tinvalid = true;\n\t\t\t\t\tASF.ArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, nameof(name)));\n\t\t\t\t}\n\n\t\t\t\tif (invalid && (key != null)) {\n\t\t\t\t\tinvalidKeys.Add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (invalidKeys.Count > 0) {\n\t\t\t\tforeach (string invalidKey in invalidKeys) {\n\t\t\t\t\tgamesToRedeemInBackground.Remove(invalidKey);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn gamesToRedeemInBackground;\n\t\t}\n#pragma warning restore CS8605\n\n\t\tprivate async Task CheckOccupationStatus() {\n\t\t\tStopPlayingWasBlockedTimer();\n\n\t\t\tif (!IsPlayingPossible) {\n\t\t\t\tPlayingWasBlocked = true;\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotAccountOccupied);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (PlayingWasBlocked && (PlayingWasBlockedTimer == null)) {\n\t\t\t\tInitPlayingWasBlockedTimer();\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotAccountFree);\n\n\t\t\tif (!await CardsFarmer.Resume(false).ConfigureAwait(false)) {\n\t\t\t\tawait ResetGamesPlayed().ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task Connect(bool force = false) {\n\t\t\tif (!force && (!KeepRunning || SteamClient.IsConnected)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait LimitLoginRequestsAsync().ConfigureAwait(false);\n\n\t\t\tif (!force && (!KeepRunning || SteamClient.IsConnected)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotConnecting);\n\t\t\tInitConnectionFailureTimer();\n\t\t\tSteamClient.Connect();\n\t\t}\n\n\t\tprivate async Task Destroy(bool force = false) {\n\t\t\tif (Bots == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(Bots));\n\t\t\t}\n\n\t\t\tif (KeepRunning) {\n\t\t\t\tif (!force) {\n\t\t\t\t\tStop();\n\t\t\t\t} else {\n\t\t\t\t\t// Stop() will most likely block due to connection freeze, don't wait for it\n\t\t\t\t\tUtilities.InBackground(() => Stop());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBots.TryRemove(BotName, out _);\n\t\t\tawait PluginsCore.OnBotDestroy(this).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void Disconnect() {\n\t\t\tStopConnectionFailureTimer();\n\t\t\tSteamClient.Disconnect();\n\t\t}\n\n\t\tprivate static string Escape(string message) {\n\t\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t\t}\n\n\t\t\treturn message.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"[\", \"\\\\[\");\n\t\t}\n\n\t\tprivate string GetFilePath(EFileType fileType) {\n\t\t\tif (!Enum.IsDefined(typeof(EFileType), fileType)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(fileType));\n\t\t\t}\n\n\t\t\treturn GetFilePath(BotName, fileType);\n\t\t}\n\n\t\tprivate async Task<Dictionary<string, string>?> GetKeysFromFile(string filePath) {\n\t\t\tif (string.IsNullOrEmpty(filePath)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(filePath));\n\t\t\t}\n\n\t\t\tif (!File.Exists(filePath)) {\n\t\t\t\treturn new Dictionary<string, string>(0, StringComparer.Ordinal);\n\t\t\t}\n\n\t\t\tDictionary<string, string> keys = new Dictionary<string, string>(StringComparer.Ordinal);\n\n\t\t\ttry {\n\t\t\t\tusing StreamReader reader = new StreamReader(filePath);\n\n\t\t\t\tstring? line;\n\n\t\t\t\twhile ((line = await reader.ReadLineAsync().ConfigureAwait(false)) != null) {\n\t\t\t\t\tif (line.Length == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring[] parsedArgs = line.Split(DefaultBackgroundKeysRedeemerSeparator, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\t\t\tif (parsedArgs.Length < 3) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, line));\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring key = parsedArgs[^1];\n\n\t\t\t\t\tif (!Utilities.IsValidCdKey(key)) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.ErrorIsInvalid, key));\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring name = parsedArgs[0];\n\t\t\t\t\tkeys[key] = name;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn keys;\n\t\t}\n\n\t\tprivate void HandleCallbacks() {\n\t\t\tTimeSpan timeSpan = TimeSpan.FromMilliseconds(CallbackSleep);\n\n\t\t\twhile (KeepRunning || SteamClient.IsConnected) {\n\t\t\t\tif (!CallbackSemaphore.Wait(0)) {\n\t\t\t\t\tif (Debugging.IsUserDebugging) {\n\t\t\t\t\t\tArchiLogger.LogGenericDebug(string.Format(Strings.WarningFailedWithError, nameof(CallbackSemaphore)));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tCallbackManager.RunWaitAllCallbacks(timeSpan);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t\t} finally {\n\t\t\t\t\tCallbackSemaphore.Release();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task HeartBeat() {\n\t\t\tif (ASF.GlobalConfig == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(ASF.GlobalConfig));\n\t\t\t}\n\n\t\t\tif (!KeepRunning || !IsConnectedAndLoggedOn || (HeartBeatFailures == byte.MaxValue)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (DateTime.UtcNow.Subtract(ArchiHandler.LastPacketReceived).TotalSeconds > ASF.GlobalConfig.ConnectionTimeout) {\n\t\t\t\t\tawait SteamFriends.RequestProfileInfo(SteamID).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t}\n\n\t\t\t\tHeartBeatFailures = 0;\n\n\t\t\t\tif (Statistics != null) {\n\t\t\t\t\tUtilities.InBackground(Statistics.OnHeartBeat);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericDebuggingException(e);\n\n\t\t\t\tif (!KeepRunning || !IsConnectedAndLoggedOn || (HeartBeatFailures == byte.MaxValue)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (++HeartBeatFailures >= (byte) Math.Ceiling(ASF.GlobalConfig.ConnectionTimeout / 10.0)) {\n\t\t\t\t\tHeartBeatFailures = byte.MaxValue;\n\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.BotConnectionLost);\n\t\t\t\t\tUtilities.InBackground(() => Connect(true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task ImportAuthenticator(string maFilePath) {\n\t\t\tif (HasMobileAuthenticator || !File.Exists(maFilePath)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotAuthenticatorConverting);\n\n\t\t\ttry {\n\t\t\t\tstring json = await RuntimeCompatibility.File.ReadAllTextAsync(maFilePath).ConfigureAwait(false);\n\n\t\t\t\tif (string.IsNullOrEmpty(json)) {\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsEmpty, nameof(json)));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tMobileAuthenticator? authenticator = JsonConvert.DeserializeObject<MobileAuthenticator>(json);\n\n\t\t\t\t// ReSharper disable once ConditionIsAlwaysTrueOrFalse - wrong, \"null\" json serializes into null object\n\t\t\t\tif (authenticator == null) {\n\t\t\t\t\tArchiLogger.LogNullError(nameof(authenticator));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tauthenticator.Init(this);\n\t\t\t\tBotDatabase.MobileAuthenticator = authenticator;\n\n\t\t\t\tFile.Delete(maFilePath);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotAuthenticatorImportFinished);\n\t\t}\n\n\t\tprivate void InitConnectionFailureTimer() {\n\t\t\tif (ConnectionFailureTimer != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbyte connectionTimeout = ASF.GlobalConfig?.ConnectionTimeout ?? GlobalConfig.DefaultConnectionTimeout;\n\n\t\t\tConnectionFailureTimer = new Timer(\n\t\t\t\tasync e => await InitPermanentConnectionFailure().ConfigureAwait(false),\n\t\t\t\tnull,\n\t\t\t\tTimeSpan.FromMinutes(Math.Ceiling(connectionTimeout / 30.0)), // Delay\n\t\t\t\tTimeout.InfiniteTimeSpan // Period\n\t\t\t);\n\t\t}\n\n\t\tprivate async Task InitializeFamilySharing() {\n\t\t\tHashSet<ulong>? steamIDs = await ArchiWebHandler.GetFamilySharingSteamIDs().ConfigureAwait(false);\n\n\t\t\tif (steamIDs == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSteamFamilySharingIDs.ReplaceWith(steamIDs);\n\t\t}\n\n\t\tprivate async Task<bool> InitLoginAndPassword(bool requiresPassword) {\n\t\t\tif (string.IsNullOrEmpty(BotConfig.SteamLogin)) {\n\t\t\t\tRequiredInput = ASF.EUserInputType.Login;\n\n\t\t\t\tstring? steamLogin = await Logging.GetUserInput(ASF.EUserInputType.Login, BotName).ConfigureAwait(false);\n\n\t\t\t\tif (string.IsNullOrEmpty(steamLogin) || !SetUserInput(ASF.EUserInputType.Login, steamLogin!)) {\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamLogin)));\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (requiresPassword && string.IsNullOrEmpty(BotConfig.DecryptedSteamPassword)) {\n\t\t\t\tRequiredInput = ASF.EUserInputType.Password;\n\n\t\t\t\tstring? steamPassword = await Logging.GetUserInput(ASF.EUserInputType.Password, BotName).ConfigureAwait(false);\n\n\t\t\t\tif (string.IsNullOrEmpty(steamPassword) || !SetUserInput(ASF.EUserInputType.Password, steamPassword!)) {\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamPassword)));\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate async Task InitModules() {\n\t\t\tif (Bots == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(Bots));\n\t\t\t}\n\n\t\t\tAccountFlags = EAccountFlags.NormalUser;\n\t\t\tAvatarHash = Nickname = null;\n\t\t\tMasterChatGroupID = 0;\n\t\t\tRequiredInput = ASF.EUserInputType.None;\n\t\t\tWalletBalance = 0;\n\t\t\tWalletCurrency = ECurrencyCode.Invalid;\n\n\t\t\tCardsFarmer.SetInitialState(BotConfig.Paused);\n\n\t\t\tif (SendItemsTimer != null) {\n\t\t\t\tawait SendItemsTimer.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\tSendItemsTimer = null;\n\t\t\t}\n\n\t\t\tif ((BotConfig.SendTradePeriod > 0) && (BotConfig.LootableTypes.Count > 0) && BotConfig.SteamUserPermissions.Values.Any(permission => permission >= BotConfig.EPermission.Master)) {\n\t\t\t\tSendItemsTimer = new Timer(\n\t\t\t\t\tasync e => await Actions.SendInventory(filterFunction: item => BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false),\n\t\t\t\t\tnull,\n\t\t\t\t\tTimeSpan.FromHours(BotConfig.SendTradePeriod) + TimeSpan.FromSeconds(ASF.LoadBalancingDelay * Bots.Count), // Delay\n\t\t\t\t\tTimeSpan.FromHours(BotConfig.SendTradePeriod) // Period\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (SteamSaleEvent != null) {\n\t\t\t\tawait SteamSaleEvent.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\tSteamSaleEvent = null;\n\t\t\t}\n\n\t\t\tif (BotConfig.AutoSteamSaleEvent) {\n\t\t\t\tSteamSaleEvent = new SteamSaleEvent(this);\n\t\t\t}\n\n\t\t\tawait PluginsCore.OnBotInitModules(this, BotConfig.AdditionalProperties).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async Task InitPermanentConnectionFailure() {\n\t\t\tif (!KeepRunning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericWarning(Strings.BotHeartBeatFailed);\n\t\t\tawait Destroy(true).ConfigureAwait(false);\n\t\t\tawait RegisterBot(BotName).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void InitPlayingWasBlockedTimer() {\n\t\t\tif (PlayingWasBlockedTimer != null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPlayingWasBlockedTimer = new Timer(\n\t\t\t\te => ResetPlayingWasBlockedWithTimer(),\n\t\t\t\tnull,\n\t\t\t\tTimeSpan.FromSeconds(MinPlayingBlockedTTL), // Delay\n\t\t\t\tTimeout.InfiniteTimeSpan // Period\n\t\t\t);\n\t\t}\n\n\t\tprivate void InitStart() {\n\t\t\tif (!BotConfig.Enabled) {\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotInstanceNotStartingBecauseDisabled);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Start\n\t\t\tUtilities.InBackground(Start);\n\t\t}\n\n\t\tprivate bool IsMasterClanID(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsClanAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn steamID == BotConfig.SteamMasterClanID;\n\t\t}\n\n\t\tprivate static bool IsRefundable(EPaymentMethod paymentMethod) {\n\t\t\tif (paymentMethod == EPaymentMethod.None) {\n\t\t\t\tthrow new ArgumentNullException(nameof(paymentMethod));\n\t\t\t}\n\n\t\t\t// Complimentary is also a flag\n\t\t\treturn paymentMethod switch {\n\t\t\t\tEPaymentMethod.ActivationCode => false,\n\t\t\t\tEPaymentMethod.Complimentary => false,\n\t\t\t\tEPaymentMethod.GuestPass => false,\n\t\t\t\tEPaymentMethod.HardwarePromo => false,\n\t\t\t\t_ => !paymentMethod.HasFlag(EPaymentMethod.Complimentary)\n\t\t\t};\n\t\t}\n\n\t\tprivate async Task JoinMasterChatGroupID() {\n\t\t\tif ((BotConfig.SteamMasterClanID == 0) || IsAccountLimited) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (MasterChatGroupID == 0) {\n\t\t\t\tulong chatGroupID = await ArchiHandler.GetClanChatGroupID(BotConfig.SteamMasterClanID).ConfigureAwait(false);\n\n\t\t\t\tif (chatGroupID == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tMasterChatGroupID = chatGroupID;\n\t\t\t}\n\n\t\t\tHashSet<ulong>? chatGroupIDs = await ArchiHandler.GetMyChatGroupIDs().ConfigureAwait(false);\n\n\t\t\tif (chatGroupIDs?.Contains(MasterChatGroupID) != false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!await ArchiHandler.JoinChatRoomGroup(MasterChatGroupID).ConfigureAwait(false)) {\n\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.JoinChatRoomGroup)));\n\t\t\t}\n\t\t}\n\n\t\tprivate static async Task LimitLoginRequestsAsync() {\n\t\t\tif ((ASF.LoginSemaphore == null) || (ASF.LoginRateLimitingSemaphore == null)) {\n\t\t\t\tASF.ArchiLogger.LogNullError(nameof(ASF.LoginSemaphore) + \" || \" + nameof(ASF.LoginRateLimitingSemaphore));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbyte loginLimiterDelay = ASF.GlobalConfig?.LoginLimiterDelay ?? GlobalConfig.DefaultLoginLimiterDelay;\n\n\t\t\tif (loginLimiterDelay == 0) {\n\t\t\t\tawait ASF.LoginRateLimitingSemaphore.WaitAsync().ConfigureAwait(false);\n\t\t\t\tASF.LoginRateLimitingSemaphore.Release();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait ASF.LoginSemaphore.WaitAsync().ConfigureAwait(false);\n\n\t\t\ttry {\n\t\t\t\tawait ASF.LoginRateLimitingSemaphore.WaitAsync().ConfigureAwait(false);\n\t\t\t\tASF.LoginRateLimitingSemaphore.Release();\n\t\t\t} finally {\n\t\t\t\tUtilities.InBackground(\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\tawait Task.Delay(loginLimiterDelay * 1000).ConfigureAwait(false);\n\t\t\t\t\t\tASF.LoginSemaphore.Release();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnConnected(SteamClient.ConnectedCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tHeartBeatFailures = 0;\n\t\t\tReconnectOnUserInitiated = false;\n\t\t\tStopConnectionFailureTimer();\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotConnected);\n\n\t\t\tif (!KeepRunning) {\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotDisconnecting);\n\t\t\t\tDisconnect();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring sentryFilePath = GetFilePath(EFileType.SentryFile);\n\n\t\t\tif (string.IsNullOrEmpty(sentryFilePath)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(sentryFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbyte[]? sentryFileHash = null;\n\n\t\t\tif (File.Exists(sentryFilePath)) {\n\t\t\t\ttry {\n\t\t\t\t\tbyte[] sentryFileContent = await RuntimeCompatibility.File.ReadAllBytesAsync(sentryFilePath).ConfigureAwait(false);\n\t\t\t\t\tsentryFileHash = CryptoHelper.SHAHash(sentryFileContent);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFile.Delete(sentryFilePath);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignored, we can only try to delete faulted file at best\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring? loginKey = null;\n\n\t\t\tif (BotConfig.UseLoginKeys) {\n\t\t\t\t// Login keys are not guaranteed to be valid, we should use them only if we don't have full details available from the user\n\t\t\t\tif (string.IsNullOrEmpty(BotConfig.DecryptedSteamPassword) || (string.IsNullOrEmpty(AuthCode) && string.IsNullOrEmpty(TwoFactorCode) && !HasMobileAuthenticator)) {\n\t\t\t\t\tloginKey = BotDatabase.LoginKey;\n\n\t\t\t\t\t// Decrypt login key if needed\n\t\t\t\t\tif (!string.IsNullOrEmpty(loginKey) && (loginKey!.Length > 19) && (BotConfig.PasswordFormat != ArchiCryptoHelper.ECryptoMethod.PlainText)) {\n\t\t\t\t\t\tloginKey = ArchiCryptoHelper.Decrypt(BotConfig.PasswordFormat, loginKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we're not using login keys, ensure we don't have any saved\n\t\t\t\tBotDatabase.LoginKey = null;\n\t\t\t}\n\n\t\t\tif (!await InitLoginAndPassword(string.IsNullOrEmpty(loginKey)).ConfigureAwait(false)) {\n\t\t\t\tStop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(BotConfig.SteamLogin)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(BotConfig.SteamLogin));\n\t\t\t}\n\n\t\t\t// Steam login and password fields can contain ASCII characters only, including spaces\n\t\t\tconst string nonAsciiPattern = @\"[^\\u0000-\\u007F]+\";\n\n\t\t\tstring username = Regex.Replace(BotConfig.SteamLogin!, nonAsciiPattern, \"\", RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);\n\t\t\tstring? password = BotConfig.DecryptedSteamPassword;\n\n\t\t\tif (!string.IsNullOrEmpty(password)) {\n\t\t\t\tpassword = Regex.Replace(password!, nonAsciiPattern, \"\", RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotLoggingIn);\n\n\t\t\tif (string.IsNullOrEmpty(TwoFactorCode) && (BotDatabase.MobileAuthenticator != null)) {\n\t\t\t\t// We should always include 2FA token, even if it's not required\n\t\t\t\tTwoFactorCode = await BotDatabase.MobileAuthenticator.GenerateToken().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tInitConnectionFailureTimer();\n\n\t\t\tSteamUser.LogOnDetails logOnDetails = new SteamUser.LogOnDetails {\n\t\t\t\tAuthCode = AuthCode,\n\t\t\t\tCellID = ASF.GlobalDatabase?.CellID,\n\t\t\t\tLoginID = LoginID,\n\t\t\t\tLoginKey = loginKey,\n\t\t\t\tPassword = password,\n\t\t\t\tSentryFileHash = sentryFileHash,\n\t\t\t\tShouldRememberPassword = BotConfig.UseLoginKeys,\n\t\t\t\tTwoFactorCode = TwoFactorCode,\n\t\t\t\tUsername = username\n\t\t\t};\n\n\t\t\tif (OSType == EOSType.Unknown) {\n\t\t\t\tOSType = logOnDetails.ClientOSType;\n\t\t\t}\n\n\t\t\tSteamUser.LogOn(logOnDetails);\n\t\t}\n\n\t\tprivate async void OnDisconnected(SteamClient.DisconnectedCallback callback) {\n\t\t\tif ((callback == null) || (ASF.LoginRateLimitingSemaphore == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback) + \" || \" + nameof(ASF.LoginRateLimitingSemaphore));\n\t\t\t}\n\n\t\t\tEResult lastLogOnResult = LastLogOnResult;\n\t\t\tLastLogOnResult = EResult.Invalid;\n\t\t\tHeartBeatFailures = 0;\n\t\t\tSteamParentalActive = true;\n\t\t\tStopConnectionFailureTimer();\n\t\t\tStopPlayingWasBlockedTimer();\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotDisconnected);\n\n\t\t\tPastNotifications.Clear();\n\n\t\t\tActions.OnDisconnected();\n\t\t\tArchiWebHandler.OnDisconnected();\n\t\t\tCardsFarmer.OnDisconnected();\n\t\t\tTrading.OnDisconnected();\n\n\t\t\tFirstTradeSent = false;\n\n\t\t\tawait PluginsCore.OnBotDisconnected(this, callback.UserInitiated ? EResult.OK : lastLogOnResult).ConfigureAwait(false);\n\n\t\t\t// If we initiated disconnect, do not attempt to reconnect\n\t\t\tif (callback.UserInitiated && !ReconnectOnUserInitiated) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (lastLogOnResult) {\n\t\t\t\tcase EResult.AccountDisabled:\n\t\t\t\t\t// Do not attempt to reconnect, those failures are permanent\n\t\t\t\t\treturn;\n\t\t\t\tcase EResult.InvalidPassword when !string.IsNullOrEmpty(BotDatabase.LoginKey):\n\t\t\t\t\tBotDatabase.LoginKey = null;\n\t\t\t\t\tArchiLogger.LogGenericInfo(Strings.BotRemovedExpiredLoginKey);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.InvalidPassword:\n\t\t\t\tcase EResult.NoConnection:\n\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\tcase EResult.Timeout:\n\t\t\t\tcase EResult.TryAnotherCM:\n\t\t\t\tcase EResult.TwoFactorCodeMismatch:\n\t\t\t\t\tawait Task.Delay(5000).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotRateLimitExceeded, TimeSpan.FromMinutes(LoginCooldownInMinutes).ToHumanReadable()));\n\n\t\t\t\t\tif (!await ASF.LoginRateLimitingSemaphore.WaitAsync(1000 * WebBrowser.MaxTries).ConfigureAwait(false)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait Task.Delay(LoginCooldownInMinutes * 60 * 1000).ConfigureAwait(false);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tASF.LoginRateLimitingSemaphore.Release();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!KeepRunning || SteamClient.IsConnected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotReconnecting);\n\t\t\tawait Connect().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async void OnFriendsList(SteamFriends.FriendsListCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.FriendList == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.FriendList));\n\t\t\t}\n\n\t\t\tforeach (SteamFriends.FriendsListCallback.Friend friend in callback.FriendList.Where(friend => friend.Relationship == EFriendRelationship.RequestRecipient)) {\n\t\t\t\tArchiLogger.LogInvite(friend.SteamID);\n\n\t\t\t\tswitch (friend.SteamID.AccountType) {\n\t\t\t\t\tcase EAccountType.Clan when IsMasterClanID(friend.SteamID):\n\t\t\t\t\t\tArchiHandler.AcknowledgeClanInvite(friend.SteamID, true);\n\t\t\t\t\t\tawait JoinMasterChatGroupID().ConfigureAwait(false);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EAccountType.Clan:\n\t\t\t\t\t\tbool acceptGroupRequest = await PluginsCore.OnBotFriendRequest(this, friend.SteamID).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (acceptGroupRequest) {\n\t\t\t\t\t\t\tArchiHandler.AcknowledgeClanInvite(friend.SteamID, true);\n\t\t\t\t\t\t\tawait JoinMasterChatGroupID().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.RejectInvalidGroupInvites)) {\n\t\t\t\t\t\t\tArchiHandler.AcknowledgeClanInvite(friend.SteamID, false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (HasPermission(friend.SteamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\t\t\t\tif (!await ArchiHandler.AddFriend(friend.SteamID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.AddFriend)));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool acceptFriendRequest = await PluginsCore.OnBotFriendRequest(this, friend.SteamID).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (acceptFriendRequest) {\n\t\t\t\t\t\t\tif (!await ArchiHandler.AddFriend(friend.SteamID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.AddFriend)));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.RejectInvalidFriendInvites)) {\n\t\t\t\t\t\t\tif (!await ArchiHandler.RemoveFriend(friend.SteamID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiHandler.RemoveFriend)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnGuestPassList(SteamApps.GuestPassListCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.GuestPasses == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.GuestPasses));\n\t\t\t}\n\n\t\t\tif ((callback.CountGuestPassesToRedeem == 0) || (callback.GuestPasses.Count == 0) || !BotConfig.AcceptGifts) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tHashSet<ulong> guestPassIDs = callback.GuestPasses.Select(guestPass => guestPass[\"gid\"].AsUnsignedLong()).Where(gid => gid != 0).ToHashSet();\n\n\t\t\tif (guestPassIDs.Count == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Actions.AcceptGuestPasses(guestPassIDs).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async Task OnIncomingChatMessage(CChatRoom_IncomingChatMessage_Notification notification) {\n\t\t\tif (notification == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(notification));\n\t\t\t}\n\n\t\t\tif ((notification.chat_group_id == 0) || (notification.chat_id == 0) || (notification.steamid_sender == 0)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(notification.chat_group_id) + \" || \" + nameof(notification.chat_id) + \" || \" + nameof(notification.steamid_sender));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Under normal circumstances, timestamp must always be greater than 0, but Steam already proved that it's capable of going against the logic\n\t\t\tif ((notification.steamid_sender != SteamID) && (notification.timestamp > 0)) {\n\t\t\t\tif (ShouldAckChatMessage(notification.steamid_sender)) {\n\t\t\t\t\tUtilities.InBackground(() => ArchiHandler.AckChatMessage(notification.chat_group_id, notification.chat_id, notification.timestamp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring message;\n\n\t\t\t// Prefer to use message without bbcode, but only if it's available\n\t\t\tif (!string.IsNullOrEmpty(notification.message_no_bbcode)) {\n\t\t\t\tmessage = notification.message_no_bbcode;\n\t\t\t} else if (!string.IsNullOrEmpty(notification.message)) {\n\t\t\t\tmessage = UnEscape(notification.message);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(false, message, notification.chat_group_id, notification.chat_id, notification.steamid_sender);\n\n\t\t\t// Steam network broadcasts chat events also when we don't explicitly sign into Steam community\n\t\t\t// We'll explicitly ignore those messages when using offline mode, as it was done in the first version of Steam chat when no messages were broadcasted at all before signing in\n\t\t\t// Handling messages will still work correctly in invisible mode, which is how it should work in the first place\n\t\t\t// This goes in addition to usual logic that ignores irrelevant messages from being parsed further\n\t\t\tif ((notification.chat_group_id != MasterChatGroupID) || (BotConfig.OnlineStatus == EPersonaState.Offline)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Commands.HandleMessage(notification.chat_group_id, notification.chat_id, notification.steamid_sender, message).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async Task OnIncomingMessage(CFriendMessages_IncomingMessage_Notification notification) {\n\t\t\tif (notification == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(notification));\n\t\t\t}\n\n\t\t\tif (notification.steamid_friend == 0) {\n\t\t\t\tArchiLogger.LogNullError(nameof(notification.steamid_friend));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((EChatEntryType) notification.chat_entry_type != EChatEntryType.ChatMsg) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Under normal circumstances, timestamp must always be greater than 0, but Steam already proved that it's capable of going against the logic\n\t\t\tif (!notification.local_echo && (notification.rtime32_server_timestamp > 0)) {\n\t\t\t\tif (ShouldAckChatMessage(notification.steamid_friend)) {\n\t\t\t\t\tUtilities.InBackground(() => ArchiHandler.AckMessage(notification.steamid_friend, notification.rtime32_server_timestamp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring message;\n\n\t\t\t// Prefer to use message without bbcode, but only if it's available\n\t\t\tif (!string.IsNullOrEmpty(notification.message_no_bbcode)) {\n\t\t\t\tmessage = notification.message_no_bbcode;\n\t\t\t} else if (!string.IsNullOrEmpty(notification.message)) {\n\t\t\t\tmessage = UnEscape(notification.message);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tArchiLogger.LogChatMessage(notification.local_echo, message, steamID: notification.steamid_friend);\n\n\t\t\t// Steam network broadcasts chat events also when we don't explicitly sign into Steam community\n\t\t\t// We'll explicitly ignore those messages when using offline mode, as it was done in the first version of Steam chat when no messages were broadcasted at all before signing in\n\t\t\t// Handling messages will still work correctly in invisible mode, which is how it should work in the first place\n\t\t\t// This goes in addition to usual logic that ignores irrelevant messages from being parsed further\n\t\t\tif (notification.local_echo || (BotConfig.OnlineStatus == EPersonaState.Offline)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait Commands.HandleMessage(notification.steamid_friend, message).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async void OnLicenseList(SteamApps.LicenseListCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.LicenseList == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.LicenseList));\n\t\t\t}\n\n\t\t\tif (ASF.GlobalDatabase == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(ASF.GlobalDatabase));\n\t\t\t}\n\n\t\t\tif (callback.LicenseList.Count == 0) {\n\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsEmpty, nameof(callback.LicenseList)));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tCommands.OnNewLicenseList();\n\n\t\t\tDictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)> ownedPackageIDs = new Dictionary<uint, (EPaymentMethod PaymentMethod, DateTime TimeCreated)>();\n\n\t\t\tDictionary<uint, ulong> packageAccessTokens = new Dictionary<uint, ulong>();\n\t\t\tDictionary<uint, uint> packagesToRefresh = new Dictionary<uint, uint>();\n\n\t\t\tforeach (SteamApps.LicenseListCallback.License license in callback.LicenseList.GroupBy(license => license.PackageID, (packageID, licenses) => licenses.OrderByDescending(license => license.TimeCreated).First())) {\n\t\t\t\townedPackageIDs[license.PackageID] = (license.PaymentMethod, license.TimeCreated);\n\n\t\t\t\tif (!ASF.GlobalDatabase.PackageAccessTokensReadOnly.TryGetValue(license.PackageID, out ulong packageAccessToken) || (packageAccessToken != license.AccessToken)) {\n\t\t\t\t\tpackageAccessTokens[license.PackageID] = license.AccessToken;\n\n\t\t\t\t\t// Package is always due to refresh with access token change\n\t\t\t\t\tpackagesToRefresh[license.PackageID] = (uint) license.LastChangeNumber;\n\t\t\t\t} else if (!ASF.GlobalDatabase.PackagesDataReadOnly.TryGetValue(license.PackageID, out (uint ChangeNumber, HashSet<uint>? AppIDs) packageData) || (packageData.ChangeNumber < license.LastChangeNumber)) {\n\t\t\t\t\tpackagesToRefresh[license.PackageID] = (uint) license.LastChangeNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOwnedPackageIDs = ownedPackageIDs.ToImmutableDictionary();\n\n\t\t\tif (packageAccessTokens.Count > 0) {\n\t\t\t\tASF.GlobalDatabase.RefreshPackageAccessTokens(packageAccessTokens);\n\t\t\t}\n\n\t\t\tif (packagesToRefresh.Count > 0) {\n\t\t\t\tArchiLogger.LogGenericTrace(Strings.BotRefreshingPackagesData);\n\t\t\t\tawait ASF.GlobalDatabase.RefreshPackages(this, packagesToRefresh).ConfigureAwait(false);\n\t\t\t\tArchiLogger.LogGenericTrace(Strings.Done);\n\t\t\t}\n\n\t\t\tawait CardsFarmer.OnNewGameAdded().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void OnLoggedOff(SteamUser.LoggedOffCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tLastLogOnResult = callback.Result;\n\n\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotLoggedOff, callback.Result));\n\n\t\t\tswitch (callback.Result) {\n\t\t\t\tcase EResult.LoggedInElsewhere:\n\t\t\t\t\t// This result directly indicates that playing was blocked when we got (forcefully) disconnected\n\t\t\t\t\tPlayingWasBlocked = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.LogonSessionReplaced:\n\t\t\t\t\tDateTime now = DateTime.UtcNow;\n\n\t\t\t\t\tif (now.Subtract(LastLogonSessionReplaced).TotalHours < 1) {\n\t\t\t\t\t\tArchiLogger.LogGenericError(Strings.BotLogonSessionReplaced);\n\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tLastLogonSessionReplaced = now;\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tReconnectOnUserInitiated = true;\n\t\t\tSteamClient.Disconnect();\n\t\t}\n\n\t\tprivate async void OnLoggedOn(SteamUser.LoggedOnCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\t// Always reset one-time-only access tokens when we get OnLoggedOn() response\n\t\t\tAuthCode = TwoFactorCode = null;\n\n\t\t\t// Keep LastLogOnResult for OnDisconnected()\n\t\t\tLastLogOnResult = callback.Result;\n\n\t\t\tHeartBeatFailures = 0;\n\t\t\tStopConnectionFailureTimer();\n\n\t\t\tswitch (callback.Result) {\n\t\t\t\tcase EResult.AccountDisabled:\n\t\t\t\t\t// Those failures are permanent, we should Stop() the bot if any of those happen\n\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.BotUnableToLogin, callback.Result, callback.ExtendedResult));\n\t\t\t\t\tStop();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.AccountLogonDenied:\n\t\t\t\t\tRequiredInput = ASF.EUserInputType.SteamGuard;\n\n\t\t\t\t\tstring? authCode = await Logging.GetUserInput(ASF.EUserInputType.SteamGuard, BotName).ConfigureAwait(false);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(authCode) || !SetUserInput(ASF.EUserInputType.SteamGuard, authCode!)) {\n\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(authCode)));\n\n\t\t\t\t\t\tStop();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.AccountLoginDeniedNeedTwoFactor:\n\t\t\t\t\tif (!HasMobileAuthenticator) {\n\t\t\t\t\t\tRequiredInput = ASF.EUserInputType.TwoFactorAuthentication;\n\n\t\t\t\t\t\tstring? twoFactorCode = await Logging.GetUserInput(ASF.EUserInputType.TwoFactorAuthentication, BotName).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (string.IsNullOrEmpty(twoFactorCode) || !SetUserInput(ASF.EUserInputType.TwoFactorAuthentication, twoFactorCode!)) {\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(twoFactorCode)));\n\n\t\t\t\t\t\t\tStop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.OK:\n\t\t\t\t\tAccountFlags = callback.AccountFlags;\n\t\t\t\t\tSteamID = callback.ClientSteamID ?? throw new ArgumentNullException(nameof(callback.ClientSteamID));\n\n\t\t\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotLoggedOn, SteamID + (!string.IsNullOrEmpty(callback.VanityURL) ? \"/\" + callback.VanityURL : \"\")));\n\n\t\t\t\t\t// Old status for these doesn't matter, we'll update them if needed\n\t\t\t\t\tInvalidPasswordFailures = TwoFactorCodeFailures = 0;\n\t\t\t\t\tLibraryLocked = PlayingBlocked = false;\n\n\t\t\t\t\tif (PlayingWasBlocked && (PlayingWasBlockedTimer == null)) {\n\t\t\t\t\t\tInitPlayingWasBlockedTimer();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (IsAccountLimited) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.BotAccountLimited);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (IsAccountLocked) {\n\t\t\t\t\t\tArchiLogger.LogGenericWarning(Strings.BotAccountLocked);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((callback.CellID != 0) && (ASF.GlobalDatabase != null) && (callback.CellID != ASF.GlobalDatabase.CellID)) {\n\t\t\t\t\t\tASF.GlobalDatabase.CellID = callback.CellID;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle steamID-based maFile\n\t\t\t\t\tif (!HasMobileAuthenticator) {\n\t\t\t\t\t\tstring maFilePath = Path.Combine(SharedInfo.ConfigDirectory, SteamID + SharedInfo.MobileAuthenticatorExtension);\n\n\t\t\t\t\t\tif (File.Exists(maFilePath)) {\n\t\t\t\t\t\t\tawait ImportAuthenticator(maFilePath).ConfigureAwait(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (callback.ParentalSettings != null) {\n\t\t\t\t\t\t(bool isSteamParentalEnabled, string? steamParentalCode) = ValidateSteamParental(callback.ParentalSettings, BotConfig.SteamParentalCode);\n\n\t\t\t\t\t\tif (isSteamParentalEnabled) {\n\t\t\t\t\t\t\tSteamParentalActive = true;\n\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(steamParentalCode)) {\n\t\t\t\t\t\t\t\tif (BotConfig.SteamParentalCode != steamParentalCode) {\n\t\t\t\t\t\t\t\t\tif (!SetUserInput(ASF.EUserInputType.SteamParentalCode, steamParentalCode!)) {\n\t\t\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamParentalCode)));\n\n\t\t\t\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (string.IsNullOrEmpty(BotConfig.SteamParentalCode) || (BotConfig.SteamParentalCode!.Length != BotConfig.SteamParentalCodeLength)) {\n\t\t\t\t\t\t\t\tRequiredInput = ASF.EUserInputType.SteamParentalCode;\n\n\t\t\t\t\t\t\t\tsteamParentalCode = await Logging.GetUserInput(ASF.EUserInputType.SteamParentalCode, BotName).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tif (string.IsNullOrEmpty(steamParentalCode) || !SetUserInput(ASF.EUserInputType.SteamParentalCode, steamParentalCode!)) {\n\t\t\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamParentalCode)));\n\n\t\t\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSteamParentalActive = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SteamParentalActive && !string.IsNullOrEmpty(BotConfig.SteamParentalCode) && (BotConfig.SteamParentalCode!.Length != BotConfig.SteamParentalCodeLength)) {\n\t\t\t\t\t\tRequiredInput = ASF.EUserInputType.SteamParentalCode;\n\n\t\t\t\t\t\tstring? steamParentalCode = await Logging.GetUserInput(ASF.EUserInputType.SteamParentalCode, BotName).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (string.IsNullOrEmpty(steamParentalCode) || !SetUserInput(ASF.EUserInputType.SteamParentalCode, steamParentalCode!)) {\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.ErrorIsInvalid, nameof(steamParentalCode)));\n\n\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiWebHandler.OnVanityURLChanged(callback.VanityURL);\n\n\t\t\t\t\tif (!await ArchiWebHandler.Init(SteamID, SteamClient.Universe, callback.WebAPIUserNonce ?? throw new ArgumentNullException(nameof(callback.WebAPIUserNonce)), SteamParentalActive ? BotConfig.SteamParentalCode : null).ConfigureAwait(false)) {\n\t\t\t\t\t\tif (!await RefreshSession().ConfigureAwait(false)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Pre-fetch API key for future usage if possible\n\t\t\t\t\tUtilities.InBackground(ArchiWebHandler.HasValidApiKey);\n\n\t\t\t\t\tif ((GamesRedeemerInBackgroundTimer == null) && BotDatabase.HasGamesToRedeemInBackground) {\n\t\t\t\t\t\tUtilities.InBackground(RedeemGamesInBackground);\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiHandler.SetCurrentMode(2);\n\t\t\t\t\tArchiHandler.RequestItemAnnouncements();\n\n\t\t\t\t\t// Sometimes Steam won't send us our own PersonaStateCallback, so request it explicitly\n\t\t\t\t\tRequestPersonaStateUpdate();\n\n\t\t\t\t\tUtilities.InBackground(InitializeFamilySharing);\n\n\t\t\t\t\tif (Statistics != null) {\n\t\t\t\t\t\tUtilities.InBackground(Statistics.OnLoggedOn);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (BotConfig.OnlineStatus != EPersonaState.Offline) {\n\t\t\t\t\t\tSteamFriends.SetPersonaState(BotConfig.OnlineStatus);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (BotConfig.SteamMasterClanID != 0) {\n\t\t\t\t\t\tUtilities.InBackground(\n\t\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\t\tif (!await ArchiWebHandler.JoinGroup(BotConfig.SteamMasterClanID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(ArchiWebHandler.JoinGroup)));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tawait JoinMasterChatGroupID().ConfigureAwait(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (CardsFarmer.Paused) {\n\t\t\t\t\t\t// Emit initial game playing status in this case\n\t\t\t\t\t\tUtilities.InBackground(ResetGamesPlayed);\n\t\t\t\t\t}\n\n\t\t\t\t\tSteamPICSChanges.OnBotLoggedOn();\n\n\t\t\t\t\tawait PluginsCore.OnBotLoggedOn(this).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EResult.InvalidPassword:\n\t\t\t\tcase EResult.NoConnection:\n\t\t\t\tcase EResult.PasswordRequiredToKickSession: // Not sure about this one, it seems to be just generic \"try again\"? #694\n\t\t\t\tcase EResult.RateLimitExceeded:\n\t\t\t\tcase EResult.ServiceUnavailable:\n\t\t\t\tcase EResult.Timeout:\n\t\t\t\tcase EResult.TryAnotherCM:\n\t\t\t\tcase EResult.TwoFactorCodeMismatch:\n\t\t\t\t\tArchiLogger.LogGenericWarning(string.Format(Strings.BotUnableToLogin, callback.Result, callback.ExtendedResult));\n\n\t\t\t\t\tswitch (callback.Result) {\n\t\t\t\t\t\tcase EResult.InvalidPassword when string.IsNullOrEmpty(BotDatabase.LoginKey) && (++InvalidPasswordFailures >= MaxInvalidPasswordFailures):\n\t\t\t\t\t\t\tInvalidPasswordFailures = 0;\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.BotInvalidPasswordDuringLogin, MaxInvalidPasswordFailures));\n\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EResult.TwoFactorCodeMismatch when HasMobileAuthenticator && (++TwoFactorCodeFailures >= MaxTwoFactorCodeFailures):\n\t\t\t\t\t\t\tTwoFactorCodeFailures = 0;\n\t\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.BotInvalidAuthenticatorDuringLogin, MaxTwoFactorCodeFailures));\n\t\t\t\t\t\t\tStop();\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Unexpected result, shutdown immediately\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(callback.Result), callback.Result));\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.BotUnableToLogin, callback.Result, callback.ExtendedResult));\n\t\t\t\t\tStop();\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnLoginKey(SteamUser.LoginKeyCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(callback.LoginKey)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback.LoginKey));\n\t\t\t}\n\n\t\t\tif (!BotConfig.UseLoginKeys) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring? loginKey = callback.LoginKey;\n\n\t\t\tif (BotConfig.PasswordFormat != ArchiCryptoHelper.ECryptoMethod.PlainText) {\n\t\t\t\tloginKey = ArchiCryptoHelper.Encrypt(BotConfig.PasswordFormat, loginKey);\n\t\t\t}\n\n\t\t\tBotDatabase.LoginKey = loginKey;\n\t\t\tSteamUser.AcceptNewLoginKey(callback);\n\t\t}\n\n\t\tprivate async void OnMachineAuth(SteamUser.UpdateMachineAuthCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tstring sentryFilePath = GetFilePath(EFileType.SentryFile);\n\n\t\t\tif (string.IsNullOrEmpty(sentryFilePath)) {\n\t\t\t\tArchiLogger.LogNullError(nameof(sentryFilePath));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong fileSize;\n\t\t\tbyte[] sentryHash;\n\n\t\t\ttry {\n#if NETFRAMEWORK\n\t\t\t\tusing FileStream fileStream = File.Open(sentryFilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite);\n#else\n\t\t\t\tawait using FileStream fileStream = File.Open(sentryFilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite);\n#endif\n\n\t\t\t\tfileStream.Seek(callback.Offset, SeekOrigin.Begin);\n\n\t\t\t\tawait fileStream.WriteAsync(callback.Data, 0, callback.BytesToWrite).ConfigureAwait(false);\n\n\t\t\t\tfileSize = fileStream.Length;\n\t\t\t\tfileStream.Seek(0, SeekOrigin.Begin);\n\n\t\t\t\tusing SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();\n\n\t\t\t\tsentryHash = sha.ComputeHash(fileStream);\n\t\t\t} catch (Exception e) {\n\t\t\t\tArchiLogger.LogGenericException(e);\n\n\t\t\t\ttry {\n\t\t\t\t\tFile.Delete(sentryFilePath);\n\t\t\t\t} catch {\n\t\t\t\t\t// Ignored, we can only try to delete faulted file at best\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Inform the steam servers that we're accepting this sentry file\n\t\t\tSteamUser.SendMachineAuthResponse(\n\t\t\t\tnew SteamUser.MachineAuthDetails {\n\t\t\t\t\tBytesWritten = callback.BytesToWrite,\n\t\t\t\t\tFileName = callback.FileName,\n\t\t\t\t\tFileSize = (int) fileSize,\n\t\t\t\t\tJobID = callback.JobID,\n\t\t\t\t\tLastError = 0,\n\t\t\t\t\tOffset = callback.Offset,\n\t\t\t\t\tOneTimePassword = callback.OneTimePassword,\n\t\t\t\t\tResult = EResult.OK,\n\t\t\t\t\tSentryFileHash = sentryHash\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tprivate void OnPersonaState(SteamFriends.PersonaStateCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.FriendID != SteamID) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring? avatarHash = null;\n\n\t\t\tif ((callback.AvatarHash.Length > 0) && callback.AvatarHash.Any(singleByte => singleByte != 0)) {\n\t\t\t\tavatarHash = BitConverter.ToString(callback.AvatarHash).Replace(\"-\", \"\").ToLowerInvariant();\n\n\t\t\t\tif (string.IsNullOrEmpty(avatarHash) || avatarHash.All(singleChar => singleChar == '0')) {\n\t\t\t\t\tavatarHash = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAvatarHash = avatarHash;\n\t\t\tNickname = callback.Name;\n\n\t\t\tif (Statistics != null) {\n\t\t\t\tUtilities.InBackground(() => Statistics.OnPersonaState(callback.Name, avatarHash));\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnPlayingSessionState(ArchiHandler.PlayingSessionStateCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.PlayingBlocked == PlayingBlocked) {\n\t\t\t\treturn; // No status update, we're not interested\n\t\t\t}\n\n\t\t\tPlayingBlocked = callback.PlayingBlocked;\n\t\t\tawait CheckOccupationStatus().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate async void OnServiceMethod(SteamUnifiedMessages.ServiceMethodNotification notification) {\n\t\t\tif (notification == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(notification));\n\t\t\t}\n\n\t\t\tswitch (notification.MethodName) {\n\t\t\t\tcase \"ChatRoomClient.NotifyIncomingChatMessage#1\":\n\t\t\t\t\tawait OnIncomingChatMessage((CChatRoom_IncomingChatMessage_Notification) notification.Body).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"FriendMessagesClient.IncomingMessage#1\":\n\t\t\t\t\tawait OnIncomingMessage((CFriendMessages_IncomingMessage_Notification) notification.Body).ConfigureAwait(false);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprivate async void OnSharedLibraryLockStatus(ArchiHandler.SharedLibraryLockStatusCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\t// Ignore no status updates\n\t\t\tif (LibraryLocked) {\n\t\t\t\tif ((callback.LibraryLockedBySteamID != 0) && (callback.LibraryLockedBySteamID != SteamID)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tLibraryLocked = false;\n\t\t\t} else {\n\t\t\t\tif ((callback.LibraryLockedBySteamID == 0) || (callback.LibraryLockedBySteamID == SteamID)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tLibraryLocked = true;\n\t\t\t}\n\n\t\t\tawait CheckOccupationStatus().ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void OnUserNotifications(ArchiHandler.UserNotificationsCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.Notifications == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tif (callback.Notifications.Count == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tHashSet<ArchiHandler.UserNotificationsCallback.EUserNotification> newPluginNotifications = new HashSet<ArchiHandler.UserNotificationsCallback.EUserNotification>();\n\n\t\t\tforeach ((ArchiHandler.UserNotificationsCallback.EUserNotification notification, uint count) in callback.Notifications) {\n\t\t\t\tbool newNotification;\n\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tnewNotification = !PastNotifications.TryGetValue(notification, out uint previousCount) || (count > previousCount);\n\t\t\t\t\tPastNotifications[notification] = count;\n\n\t\t\t\t\tif (newNotification) {\n\t\t\t\t\t\tnewPluginNotifications.Add(notification);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewNotification = false;\n\t\t\t\t\tPastNotifications.TryRemove(notification, out _);\n\t\t\t\t}\n\n\t\t\t\tArchiLogger.LogGenericTrace(notification + \" = \" + count);\n\n\t\t\t\tswitch (notification) {\n\t\t\t\t\tcase ArchiHandler.UserNotificationsCallback.EUserNotification.Gifts when newNotification && BotConfig.AcceptGifts:\n\t\t\t\t\t\tUtilities.InBackground(Actions.AcceptDigitalGiftCards);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ArchiHandler.UserNotificationsCallback.EUserNotification.Items when newNotification:\n\t\t\t\t\t\tUtilities.InBackground(CardsFarmer.OnNewItemsNotification);\n\n\t\t\t\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.DismissInventoryNotifications)) {\n\t\t\t\t\t\t\tUtilities.InBackground(ArchiWebHandler.MarkInventory);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ArchiHandler.UserNotificationsCallback.EUserNotification.Trading when newNotification:\n\t\t\t\t\t\tUtilities.InBackground(Trading.OnNewTrade);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newPluginNotifications.Count > 0) {\n\t\t\t\tUtilities.InBackground(() => PluginsCore.OnBotUserNotifications(this, newPluginNotifications));\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnVanityURLChangedCallback(ArchiHandler.VanityURLChangedCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tArchiWebHandler.OnVanityURLChanged(callback.VanityURL);\n\t\t}\n\n\t\tprivate void OnWalletUpdate(SteamUser.WalletInfoCallback callback) {\n\t\t\tif (callback == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(callback));\n\t\t\t}\n\n\t\t\tWalletBalance = callback.LongBalance;\n\t\t\tWalletCurrency = callback.Currency;\n\t\t}\n\n\t\tprivate async Task RedeemGamesInBackground() {\n\t\t\tif (!await GamesRedeemerInBackgroundSemaphore.WaitAsync(0).ConfigureAwait(false)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (GamesRedeemerInBackgroundTimer != null) {\n\t\t\t\t\tawait GamesRedeemerInBackgroundTimer.DisposeAsync().ConfigureAwait(false);\n\n\t\t\t\t\tGamesRedeemerInBackgroundTimer = null;\n\t\t\t\t}\n\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.Starting);\n\n\t\t\t\tbool assumeWalletKeyOnBadActivationCode = BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.AssumeWalletKeyOnBadActivationCode);\n\n\t\t\t\twhile (IsConnectedAndLoggedOn && BotDatabase.HasGamesToRedeemInBackground) {\n\t\t\t\t\t(string? key, string? name) = BotDatabase.GetGameToRedeemInBackground();\n\n\t\t\t\t\tif (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(name)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(key) + \" || \" + nameof(name));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiHandler.PurchaseResponseCallback? result = await Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (((result.PurchaseResultDetail == EPurchaseResultDetail.CannotRedeemCodeFromClient) || ((result.PurchaseResultDetail == EPurchaseResultDetail.BadActivationCode) && assumeWalletKeyOnBadActivationCode)) && (WalletCurrency != ECurrencyCode.Invalid)) {\n\t\t\t\t\t\t// If it's a wallet code, we try to redeem it first, then handle the inner result as our primary one\n\t\t\t\t\t\t(EResult Result, EPurchaseResultDetail? PurchaseResult)? walletResult = await ArchiWebHandler.RedeemWalletKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\tif (walletResult != null) {\n\t\t\t\t\t\t\tresult.Result = walletResult.Value.Result;\n\t\t\t\t\t\t\tresult.PurchaseResultDetail = walletResult.Value.PurchaseResult.GetValueOrDefault(walletResult.Value.Result == EResult.OK ? EPurchaseResultDetail.NoDetail : EPurchaseResultDetail.BadActivationCode); // BadActivationCode is our smart guess in this case\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.Result = EResult.Timeout;\n\t\t\t\t\t\t\tresult.PurchaseResultDetail = EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tArchiLogger.LogGenericDebug(string.Format(Strings.BotRedeem, key, result.Result + \"/\" + result.PurchaseResultDetail));\n\n\t\t\t\t\tbool rateLimited = false;\n\t\t\t\t\tbool redeemed = false;\n\n\t\t\t\t\tswitch (result.PurchaseResultDetail) {\n\t\t\t\t\t\tcase EPurchaseResultDetail.AccountLocked:\n\t\t\t\t\t\tcase EPurchaseResultDetail.AlreadyPurchased:\n\t\t\t\t\t\tcase EPurchaseResultDetail.CannotRedeemCodeFromClient:\n\t\t\t\t\t\tcase EPurchaseResultDetail.DoesNotOwnRequiredApp:\n\t\t\t\t\t\tcase EPurchaseResultDetail.RestrictedCountry:\n\t\t\t\t\t\tcase EPurchaseResultDetail.Timeout:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\tredeemed = true;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\trateLimited = true;\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result.PurchaseResultDetail), result.PurchaseResultDetail));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rateLimited) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tBotDatabase.RemoveGameToRedeemInBackground(key!);\n\n\t\t\t\t\t// If user omitted the name or intentionally provided the same name as key, replace it with the Steam result\n\t\t\t\t\tif (name!.Equals(key) && (result.Items != null) && (result.Items.Count > 0)) {\n\t\t\t\t\t\tname = string.Join(\", \", result.Items.Values);\n\t\t\t\t\t}\n\n\t\t\t\t\tstring logEntry = name + DefaultBackgroundKeysRedeemerSeparator + \"[\" + result.PurchaseResultDetail + \"]\" + ((result.Items != null) && (result.Items.Count > 0) ? DefaultBackgroundKeysRedeemerSeparator + string.Join(\", \", result.Items) : \"\") + DefaultBackgroundKeysRedeemerSeparator + key;\n\n\t\t\t\t\tstring filePath = GetFilePath(redeemed ? EFileType.KeysToRedeemUsed : EFileType.KeysToRedeemUnused);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(filePath)) {\n\t\t\t\t\t\tArchiLogger.LogNullError(nameof(filePath));\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait RuntimeCompatibility.File.AppendAllTextAsync(filePath, logEntry + Environment.NewLine).ConfigureAwait(false);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tArchiLogger.LogGenericException(e);\n\t\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.Content, logEntry));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (IsConnectedAndLoggedOn && BotDatabase.HasGamesToRedeemInBackground) {\n\t\t\t\t\tArchiLogger.LogGenericInfo(string.Format(Strings.BotRateLimitExceeded, TimeSpan.FromHours(RedeemCooldownInHours).ToHumanReadable()));\n\n\t\t\t\t\tGamesRedeemerInBackgroundTimer = new Timer(\n\t\t\t\t\t\tasync e => await RedeemGamesInBackground().ConfigureAwait(false),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tTimeSpan.FromHours(RedeemCooldownInHours), // Delay\n\t\t\t\t\t\tTimeout.InfiniteTimeSpan // Period\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tArchiLogger.LogGenericInfo(Strings.Done);\n\t\t\t} finally {\n\t\t\t\tGamesRedeemerInBackgroundSemaphore.Release();\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task ResetGamesPlayed() {\n\t\t\tif (CardsFarmer.NowFarming) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (BotConfig.GamesPlayedWhileIdle.Count > 0) {\n\t\t\t\tif (!IsPlayingPossible) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// This function might be executed before PlayingSessionStateCallback/SharedLibraryLockStatusCallback, ensure proper delay in this case\n\t\t\t\tawait Task.Delay(2000).ConfigureAwait(false);\n\n\t\t\t\tif (CardsFarmer.NowFarming || !IsPlayingPossible) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait ArchiHandler.PlayGames(BotConfig.GamesPlayedWhileIdle, BotConfig.CustomGamePlayedWhileIdle).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void ResetPlayingWasBlockedWithTimer() {\n\t\t\tPlayingWasBlocked = false;\n\t\t\tStopPlayingWasBlockedTimer();\n\t\t}\n\n\t\tprivate bool ShouldAckChatMessage(ulong steamID) {\n\t\t\tif (Bots == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(Bots));\n\t\t\t}\n\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tArchiLogger.LogNullError(nameof(steamID));\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.MarkReceivedMessagesAsRead)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn BotConfig.BotBehaviour.HasFlag(BotConfig.EBotBehaviour.MarkBotMessagesAsRead) && Bots.Values.Any(bot => bot.SteamID == steamID);\n\t\t}\n\n\t\tprivate void StopConnectionFailureTimer() {\n\t\t\tif (ConnectionFailureTimer == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tConnectionFailureTimer.Dispose();\n\t\t\tConnectionFailureTimer = null;\n\t\t}\n\n\t\tprivate void StopPlayingWasBlockedTimer() {\n\t\t\tif (PlayingWasBlockedTimer == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPlayingWasBlockedTimer.Dispose();\n\t\t\tPlayingWasBlockedTimer = null;\n\t\t}\n\n\t\tprivate static string UnEscape(string message) {\n\t\t\tif (string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(message));\n\t\t\t}\n\n\t\t\treturn message.Replace(\"\\\\[\", \"[\").Replace(\"\\\\\\\\\", \"\\\\\");\n\t\t}\n\n\t\tprivate (bool IsSteamParentalEnabled, string? SteamParentalCode) ValidateSteamParental(ParentalSettings settings, string? steamParentalCode = null) {\n\t\t\tif (settings == null) {\n\t\t\t\tthrow new ArgumentNullException(nameof(settings));\n\t\t\t}\n\n\t\t\tif (!settings.is_enabled) {\n\t\t\t\treturn (false, null);\n\t\t\t}\n\n\t\t\tArchiCryptoHelper.ESteamParentalAlgorithm steamParentalAlgorithm;\n\n\t\t\tswitch (settings.passwordhashtype) {\n\t\t\t\tcase 4:\n\t\t\t\t\tsteamParentalAlgorithm = ArchiCryptoHelper.ESteamParentalAlgorithm.Pbkdf2;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tsteamParentalAlgorithm = ArchiCryptoHelper.ESteamParentalAlgorithm.SCrypt;\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(settings.passwordhashtype), settings.passwordhashtype));\n\n\t\t\t\t\treturn (true, null);\n\t\t\t}\n\n\t\t\tif ((steamParentalCode != null) && (steamParentalCode.Length == BotConfig.SteamParentalCodeLength)) {\n\t\t\t\tbyte i = 0;\n\t\t\t\tbyte[] password = new byte[steamParentalCode.Length];\n\n\t\t\t\tforeach (char character in steamParentalCode.TakeWhile(character => (character >= '0') && (character <= '9'))) {\n\t\t\t\t\tpassword[i++] = (byte) character;\n\t\t\t\t}\n\n\t\t\t\tif (i >= steamParentalCode.Length) {\n\t\t\t\t\tIEnumerable<byte>? passwordHash = ArchiCryptoHelper.GenerateSteamParentalHash(password, settings.salt, (byte) settings.passwordhash.Length, steamParentalAlgorithm);\n\n\t\t\t\t\tif (passwordHash?.SequenceEqual(settings.passwordhash) == true) {\n\t\t\t\t\t\treturn (true, steamParentalCode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.BotGeneratingSteamParentalCode);\n\n\t\t\tsteamParentalCode = ArchiCryptoHelper.RecoverSteamParentalCode(settings.passwordhash, settings.salt, steamParentalAlgorithm);\n\n\t\t\tArchiLogger.LogGenericInfo(Strings.Done);\n\n\t\t\treturn (true, steamParentalCode);\n\t\t}\n\n\t\tinternal enum EFileType : byte {\n\t\t\tConfig,\n\t\t\tDatabase,\n\t\t\tKeysToRedeem,\n\t\t\tKeysToRedeemUnused,\n\t\t\tKeysToRedeemUsed,\n\t\t\tMobileAuthenticator,\n\t\t\tSentryFile\n\t\t}\n\t}\n}\n", "//     _                _      _  ____   _                           _____\n//    / \\    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___\n//   / _ \\  | '__|/ __|| '_ \\ | |\\___ \\ | __|/ _ \\ / _` || '_ ` _ \\ | |_  / _` || '__|| '_ ` _ \\\n//  / ___ \\ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |\n// /_/   \\_\\|_|   \\___||_| |_||_||____/  \\__|\\___| \\__,_||_| |_| |_||_|   \\__,_||_|   |_| |_| |_|\n// |\n// Copyright 2015-2020 \u0141ukasz \"JustArchi\" Domeradzki\n// Contact: JustArchi@JustArchi.net\n// |\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// |\n// http://www.apache.org/licenses/LICENSE-2.0\n// |\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing ArchiSteamFarm.Json;\nusing ArchiSteamFarm.Localization;\nusing ArchiSteamFarm.Plugins;\nusing JetBrains.Annotations;\nusing SteamKit2;\n\nnamespace ArchiSteamFarm {\n\tpublic sealed class Commands {\n\t\tprivate const ushort SteamTypingStatusDelay = 10 * 1000; // Steam client broadcasts typing status each 10 seconds\n\n\t\tprivate readonly Bot Bot;\n\t\tprivate readonly Dictionary<uint, string> CachedGamesOwned = new Dictionary<uint, string>();\n\n\t\tinternal Commands(Bot bot) => Bot = bot ?? throw new ArgumentNullException(nameof(bot));\n\n\t\t[PublicAPI]\n\t\tpublic static string FormatBotResponse(string response, string botName) {\n\t\t\tif (string.IsNullOrEmpty(response) || string.IsNullOrEmpty(botName)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response) + \" || \" + nameof(botName));\n\t\t\t}\n\n\t\t\treturn Environment.NewLine + \"<\" + botName + \"> \" + response;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic string FormatBotResponse(string response) {\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t\t}\n\n\t\t\treturn \"<\" + Bot.BotName + \"> \" + response;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic static string FormatStaticResponse(string response) {\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(response));\n\t\t\t}\n\n\t\t\treturn \"<\" + SharedInfo.ASF + \"> \" + response;\n\t\t}\n\n\t\t[PublicAPI]\n\t\tpublic async Task<string?> Response(ulong steamID, string message) {\n\t\t\tif ((steamID == 0) || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tstring[] args = message.Split(new char[0], StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tswitch (args.Length) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(nameof(args.Length));\n\t\t\t\tcase 1:\n\t\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\t\treturn await Response2FA(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\t\treturn ResponseWalletBalance(steamID);\n\t\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\t\treturn ResponseBackgroundGamesRedeemer(steamID);\n\t\t\t\t\t\tcase \"BL\":\n\t\t\t\t\t\t\treturn ResponseBlacklist(steamID);\n\t\t\t\t\t\tcase \"EXIT\":\n\t\t\t\t\t\t\treturn ResponseExit(steamID);\n\t\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\t\treturn await ResponseFarm(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"HELP\":\n\t\t\t\t\t\t\treturn ResponseHelp(steamID);\n\t\t\t\t\t\tcase \"IB\":\n\t\t\t\t\t\t\treturn ResponseIdleBlacklist(steamID);\n\t\t\t\t\t\tcase \"IQ\":\n\t\t\t\t\t\t\treturn ResponseIdleQueue(steamID);\n\t\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\t\treturn await ResponseLevel(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\t\treturn await ResponseLoot(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PASSWORD\":\n\t\t\t\t\t\t\treturn ResponsePassword(steamID);\n\t\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\t\treturn await ResponseReset(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\t\treturn ResponseResume(steamID);\n\t\t\t\t\t\tcase \"RESTART\":\n\t\t\t\t\t\t\treturn ResponseRestart(steamID);\n\t\t\t\t\t\tcase \"SA\":\n\t\t\t\t\t\t\treturn await ResponseStatus(steamID, SharedInfo.ASF).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\t\treturn ResponseStart(steamID);\n\t\t\t\t\t\tcase \"STATS\":\n\t\t\t\t\t\t\treturn ResponseStats(steamID);\n\t\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\t\treturn ResponseStatus(steamID).Response;\n\t\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\t\treturn ResponseStop(steamID);\n\t\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\t\treturn await ResponseUnpackBoosters(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"UPDATE\":\n\t\t\t\t\t\t\treturn await ResponseUpdate(steamID).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"VERSION\":\n\t\t\t\t\t\t\treturn ResponseVersion(steamID);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, steamID, message, args).ConfigureAwait(false);\n\n\t\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(steamID);\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tswitch (args[0].ToUpperInvariant()) {\n\t\t\t\t\t\tcase \"2FA\":\n\t\t\t\t\t\t\treturn await Response2FA(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FANO\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, Utilities.GetArgsAsText(args, 1, \",\"), false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"2FAOK\":\n\t\t\t\t\t\t\treturn await Response2FAConfirm(steamID, Utilities.GetArgsAsText(args, 1, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"ADDLICENSE\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseAddLicense(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"ADDLICENSE\":\n\t\t\t\t\t\t\treturn await ResponseAddLicense(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BALANCE\":\n\t\t\t\t\t\t\treturn await ResponseWalletBalance(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BGR\":\n\t\t\t\t\t\t\treturn await ResponseBackgroundGamesRedeemer(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BL\":\n\t\t\t\t\t\t\treturn await ResponseBlacklist(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BLADD\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseBlacklistAdd(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BLADD\":\n\t\t\t\t\t\t\treturn ResponseBlacklistAdd(steamID, args[1]);\n\t\t\t\t\t\tcase \"BLRM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseBlacklistRemove(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"BLRM\":\n\t\t\t\t\t\t\treturn ResponseBlacklistRemove(steamID, args[1]);\n\t\t\t\t\t\tcase \"ENCRYPT\" when args.Length > 2:\n\t\t\t\t\t\t\treturn ResponseEncrypt(steamID, args[1], Utilities.GetArgsAsText(message, 2));\n\t\t\t\t\t\tcase \"FARM\":\n\t\t\t\t\t\t\treturn await ResponseFarm(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"INPUT\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseInput(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"INPUT\" when args.Length > 2:\n\t\t\t\t\t\t\treturn ResponseInput(steamID, args[1], args[2]);\n\t\t\t\t\t\tcase \"IB\":\n\t\t\t\t\t\t\treturn await ResponseIdleBlacklist(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IBADD\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleBlacklistAdd(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IBADD\":\n\t\t\t\t\t\t\treturn ResponseIdleBlacklistAdd(steamID, args[1]);\n\t\t\t\t\t\tcase \"IBRM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleBlacklistRemove(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IBRM\":\n\t\t\t\t\t\t\treturn ResponseIdleBlacklistRemove(steamID, args[1]);\n\t\t\t\t\t\tcase \"IQ\":\n\t\t\t\t\t\t\treturn await ResponseIdleQueue(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IQADD\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleQueueAdd(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IQADD\":\n\t\t\t\t\t\t\treturn ResponseIdleQueueAdd(steamID, args[1]);\n\t\t\t\t\t\tcase \"IQRM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseIdleQueueRemove(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"IQRM\":\n\t\t\t\t\t\t\treturn ResponseIdleQueueRemove(steamID, args[1]);\n\t\t\t\t\t\tcase \"LEVEL\":\n\t\t\t\t\t\t\treturn await ResponseLevel(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT\":\n\t\t\t\t\t\t\treturn await ResponseLoot(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT^\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseAdvancedLoot(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT^\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseAdvancedLoot(steamID, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT@\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT@\":\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT%\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"LOOT%\":\n\t\t\t\t\t\t\treturn await ResponseLootByRealAppIDs(steamID, args[1], true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"NICKNAME\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseNickname(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"NICKNAME\":\n\t\t\t\t\t\t\treturn ResponseNickname(steamID, args[1]);\n\t\t\t\t\t\tcase \"OA\":\n\t\t\t\t\t\t\treturn await ResponseOwns(steamID, SharedInfo.ASF, Utilities.GetArgsAsText(message, 1)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"OWNS\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseOwns(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"OWNS\":\n\t\t\t\t\t\t\treturn (await ResponseOwns(steamID, args[1]).ConfigureAwait(false)).Response;\n\t\t\t\t\t\tcase \"PASSWORD\":\n\t\t\t\t\t\t\treturn await ResponsePassword(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, Utilities.GetArgsAsText(args, 1, \",\"), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE~\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, Utilities.GetArgsAsText(args, 1, \",\"), false).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE&\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, args[1], true, Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PAUSE&\":\n\t\t\t\t\t\t\treturn await ResponsePause(steamID, true, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PLAY\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponsePlay(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PLAY\":\n\t\t\t\t\t\t\treturn await ResponsePlay(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PRIVACY\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponsePrivacy(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"PRIVACY\":\n\t\t\t\t\t\t\treturn await ResponsePrivacy(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R\" when args.Length > 2:\n\t\t\t\t\t\tcase \"REDEEM\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseRedeem(steamID, args[1], Utilities.GetArgsAsText(args, 2, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R\":\n\t\t\t\t\t\tcase \"REDEEM\":\n\t\t\t\t\t\t\treturn await ResponseRedeem(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R^\" when args.Length > 3:\n\t\t\t\t\t\tcase \"REDEEM^\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseAdvancedRedeem(steamID, args[1], args[2], Utilities.GetArgsAsText(args, 3, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"R^\" when args.Length > 2:\n\t\t\t\t\t\tcase \"REDEEM^\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseAdvancedRedeem(steamID, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESET\":\n\t\t\t\t\t\t\treturn await ResponseReset(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"RESUME\":\n\t\t\t\t\t\t\treturn await ResponseResume(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"START\":\n\t\t\t\t\t\t\treturn await ResponseStart(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"STATUS\":\n\t\t\t\t\t\t\treturn await ResponseStatus(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"STOP\":\n\t\t\t\t\t\t\treturn await ResponseStop(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseTransfer(steamID, args[1], Utilities.GetArgsAsText(message, 2)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER\":\n\t\t\t\t\t\t\treturn await ResponseTransfer(steamID, args[1]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 4:\n\t\t\t\t\t\t\treturn await ResponseAdvancedTransfer(steamID, args[1], args[2], args[3], Utilities.GetArgsAsText(message, 4)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER^\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseAdvancedTransfer(steamID, args[1], args[2], args[3]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3)).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER@\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2]).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 3:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2], Utilities.GetArgsAsText(message, 3), true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"TRANSFER%\" when args.Length > 2:\n\t\t\t\t\t\t\treturn await ResponseTransferByRealAppIDs(steamID, args[1], args[2], true).ConfigureAwait(false);\n\t\t\t\t\t\tcase \"UNPACK\":\n\t\t\t\t\t\t\treturn await ResponseUnpackBoosters(steamID, Utilities.GetArgsAsText(args, 1, \",\")).ConfigureAwait(false);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotCommand(Bot, steamID, message, args).ConfigureAwait(false);\n\n\t\t\t\t\t\t\treturn !string.IsNullOrEmpty(pluginsResponse) ? pluginsResponse : ResponseUnknown(steamID);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task HandleMessage(ulong steamID, string message) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t\tif (!await Bot.SendMessage(steamID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, pluginsResponse));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.Length == commandPrefix!.Length) {\n\t\t\t\t\t// If the message starts with command prefix and is of the same length as command prefix, then it's just empty command trigger, useless\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmessage = message.Substring(commandPrefix.Length);\n\t\t\t}\n\n\t\t\tTask<string?> responseTask = Response(steamID, message);\n\n\t\t\tbool feedback = Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing);\n\n\t\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t\t}\n\n\t\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\t\tif (!await Bot.SendTypingMessage(steamID).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendTypingMessage)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tif (!feedback) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tBot.ArchiLogger.LogNullError(nameof(response));\n\t\t\t\tresponse = FormatBotResponse(Strings.UnknownCommand);\n\t\t\t}\n\n\t\t\tif (!await Bot.SendMessage(steamID, response!).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, response));\n\t\t\t}\n\t\t}\n\n\t\tinternal async Task HandleMessage(ulong chatGroupID, ulong chatID, ulong steamID, string message) {\n\t\t\tif ((chatGroupID == 0) || (chatID == 0) || (steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(message)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(chatGroupID) + \" || \" + nameof(chatID) + \" || \" + nameof(steamID) + \" || \" + nameof(message));\n\t\t\t}\n\n\t\t\tstring? commandPrefix = ASF.GlobalConfig != null ? ASF.GlobalConfig.CommandPrefix : GlobalConfig.DefaultCommandPrefix;\n\n\t\t\tif (!string.IsNullOrEmpty(commandPrefix)) {\n\t\t\t\tif (!message.StartsWith(commandPrefix!, StringComparison.OrdinalIgnoreCase)) {\n\t\t\t\t\tstring? pluginsResponse = await PluginsCore.OnBotMessage(Bot, steamID, message).ConfigureAwait(false);\n\n\t\t\t\t\tif (!string.IsNullOrEmpty(pluginsResponse)) {\n\t\t\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pluginsResponse!).ConfigureAwait(false)) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, pluginsResponse));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (message.Length == commandPrefix!.Length) {\n\t\t\t\t\t// If the message starts with command prefix and is of the same length as command prefix, then it's just empty command trigger, useless\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmessage = message.Substring(commandPrefix.Length);\n\t\t\t}\n\n\t\t\tTask<string?> responseTask = Response(steamID, message);\n\n\t\t\tbool feedback = Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing);\n\n\t\t\tif (feedback && !responseTask.IsCompleted) {\n\t\t\t\tstring pleaseWaitMessage = FormatBotResponse(Strings.PleaseWait);\n\n\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t}\n\n\t\t\t\twhile (!responseTask.IsCompleted && (await Task.WhenAny(responseTask, Task.Delay(SteamTypingStatusDelay)).ConfigureAwait(false) != responseTask)) {\n\t\t\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, pleaseWaitMessage).ConfigureAwait(false)) {\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring? response = await responseTask.ConfigureAwait(false);\n\n\t\t\tif (string.IsNullOrEmpty(response)) {\n\t\t\t\tif (!feedback) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tBot.ArchiLogger.LogNullError(nameof(response));\n\t\t\t\tresponse = FormatBotResponse(Strings.UnknownCommand);\n\t\t\t}\n\n\t\t\tif (!await Bot.SendMessage(chatGroupID, chatID, response!).ConfigureAwait(false)) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarning(string.Format(Strings.WarningFailedWithError, nameof(Bot.SendMessage)));\n\t\t\t\tBot.ArchiLogger.LogGenericDebug(string.Format(Strings.Content, response));\n\t\t\t}\n\t\t}\n\n\t\tinternal void OnNewLicenseList() {\n\t\t\tlock (CachedGamesOwned) {\n\t\t\t\tCachedGamesOwned.Clear();\n\t\t\t\tCachedGamesOwned.TrimExcess();\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<Dictionary<uint, string>?> FetchGamesOwned(bool cachedOnly = false) {\n\t\t\tlock (CachedGamesOwned) {\n\t\t\t\tif (CachedGamesOwned.Count > 0) {\n\t\t\t\t\treturn new Dictionary<uint, string>(CachedGamesOwned);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cachedOnly) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbool? hasValidApiKey = await Bot.ArchiWebHandler.HasValidApiKey().ConfigureAwait(false);\n\n\t\t\tDictionary<uint, string>? gamesOwned = hasValidApiKey.GetValueOrDefault() ? await Bot.ArchiWebHandler.GetOwnedGames(Bot.SteamID).ConfigureAwait(false) : await Bot.ArchiWebHandler.GetMyOwnedGames().ConfigureAwait(false);\n\n\t\t\tif ((gamesOwned != null) && (gamesOwned.Count > 0)) {\n\t\t\t\tlock (CachedGamesOwned) {\n\t\t\t\t\tif (CachedGamesOwned.Count == 0) {\n\t\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned) {\n\t\t\t\t\t\t\tCachedGamesOwned[appID] = gameName;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tCachedGamesOwned.TrimExcess();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn gamesOwned;\n\t\t}\n\n\t\tprivate async Task<string?> Response2FA(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string? token, string message) = await Bot.Actions.GenerateTwoFactorAuthenticationToken().ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success && !string.IsNullOrEmpty(token) ? string.Format(Strings.BotAuthenticatorToken, token) : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> Response2FA(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FA(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> Response2FAConfirm(ulong steamID, bool confirm) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (!Bot.HasMobileAuthenticator) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNoASFAuthenticator);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.HandleTwoFactorAuthenticationConfirmations(confirm).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> Response2FAConfirm(ulong steamID, string botNames, bool confirm) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.Response2FAConfirm(steamID, confirm))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAddLicense(ulong steamID, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tStringBuilder response = new StringBuilder();\n\n\t\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tforeach (string entry in entries) {\n\t\t\t\tuint gameID;\n\t\t\t\tstring type;\n\n\t\t\t\tint index = entry.IndexOf('/');\n\n\t\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\t\tif (!uint.TryParse(entry.Substring(index + 1), out gameID) || (gameID == 0)) {\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = entry.Substring(0, index);\n\t\t\t\t} else if (uint.TryParse(entry, out gameID) && (gameID > 0)) {\n\t\t\t\t\ttype = \"SUB\";\n\t\t\t\t} else {\n\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(gameID))));\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\t\tcase \"A\":\n\t\t\t\t\tcase \"APP\":\n\t\t\t\t\t\tSteamApps.FreeLicenseCallback callback;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcallback = await Bot.SteamApps.RequestFreeLicense(gameID).ToLongRunningTask().ConfigureAwait(false);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotAddLicense, \"app/\" + gameID, EResult.Timeout)));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse((callback.GrantedApps.Count > 0) || (callback.GrantedPackages.Count > 0) ? string.Format(Strings.BotAddLicenseWithItems, \"app/\" + gameID, callback.Result, string.Join(\", \", callback.GrantedApps.Select(appID => \"app/\" + appID).Union(callback.GrantedPackages.Select(subID => \"sub/\" + subID)))) : string.Format(Strings.BotAddLicense, \"app/\" + gameID, callback.Result)));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (!await Bot.ArchiWebHandler.AddFreeLicense(gameID).ConfigureAwait(false)) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotAddLicense, \"sub/\" + gameID, EResult.Fail)));\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotAddLicenseWithItems, gameID, EResult.OK, \"sub/\" + gameID)));\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn response.Length > 0 ? response.ToString() : null;\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAddLicense(ulong steamID, string botNames, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAddLicense(steamID, query))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedLoot(ulong steamID, string targetAppID, string targetContextID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppID) || string.IsNullOrEmpty(targetContextID)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppID) + \" || \" + nameof(targetContextID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAdvancedLoot(ulong steamID, string botNames, string appID, string contextID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(appID) || string.IsNullOrEmpty(contextID)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(appID) + \" || \" + nameof(contextID));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedLoot(steamID, appID, contextID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedRedeem(ulong steamID, string options, string keys) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(options) || string.IsNullOrEmpty(keys)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(options) + \" || \" + nameof(keys));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] flags = options.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (flags.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(flags)));\n\t\t\t}\n\n\t\t\tERedeemFlags redeemFlags = ERedeemFlags.None;\n\n\t\t\tforeach (string flag in flags) {\n\t\t\t\tswitch (flag.ToUpperInvariant()) {\n\t\t\t\t\tcase \"FAWK\":\n\t\t\t\t\tcase \"FORCEASSUMEWALLETKEY\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"FD\":\n\t\t\t\t\tcase \"FORCEDISTRIBUTING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceDistributing;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"FF\":\n\t\t\t\t\tcase \"FORCEFORWARDING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceForwarding;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"FKMG\":\n\t\t\t\t\tcase \"FORCEKEEPMISSINGGAMES\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.ForceKeepMissingGames;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SAWK\":\n\t\t\t\t\tcase \"SKIPASSUMEWALLETKEY\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SD\":\n\t\t\t\t\tcase \"SKIPDISTRIBUTING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipDistributing;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SF\":\n\t\t\t\t\tcase \"SKIPFORWARDING\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipForwarding;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SI\":\n\t\t\t\t\tcase \"SKIPINITIAL\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipInitial;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"SKMG\":\n\t\t\t\t\tcase \"SKIPKEEPMISSINGGAMES\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.SkipKeepMissingGames;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"V\":\n\t\t\t\t\tcase \"VALIDATE\":\n\t\t\t\t\t\tredeemFlags |= ERedeemFlags.Validate;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, flag));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn await ResponseRedeem(steamID, keys, redeemFlags).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAdvancedRedeem(ulong steamID, string botNames, string options, string keys) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(options) || string.IsNullOrEmpty(keys)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(options) + \" || \" + nameof(keys));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedRedeem(steamID, options, keys))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedTransfer(ulong steamID, uint appID, ulong contextID, Bot targetBot) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (appID == 0) || (contextID == 0) || (targetBot == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(appID) + \" || \" + nameof(contextID) + \" || \" + nameof(targetBot));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(appID, contextID, targetBot.SteamID).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponseAdvancedTransfer(ulong steamID, string targetAppID, string targetContextID, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppID) || string.IsNullOrEmpty(targetContextID) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppID) + \" || \" + nameof(targetContextID) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatBotResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t\t}\n\n\t\t\treturn await ResponseAdvancedTransfer(steamID, appID, contextID, targetBot).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseAdvancedTransfer(ulong steamID, string botNames, string targetAppID, string targetContextID, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppID) || string.IsNullOrEmpty(targetContextID) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppID) + \" || \" + nameof(targetContextID) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tif (!uint.TryParse(targetAppID, out uint appID) || (appID == 0)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t}\n\n\t\t\tif (!ulong.TryParse(targetContextID, out ulong contextID) || (contextID == 0)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(contextID)));\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseAdvancedTransfer(steamID, appID, contextID, targetBot))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBackgroundGamesRedeemer(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tuint count = Bot.GamesToRedeemInBackgroundCount;\n\n\t\t\treturn FormatBotResponse(string.Format(Strings.BotGamesToRedeemInBackgroundCount, count));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBackgroundGamesRedeemer(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBackgroundGamesRedeemer(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBlacklist(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tIReadOnlyCollection<ulong> blacklist = Bot.BotDatabase.GetBlacklistedFromTradesSteamIDs();\n\n\t\t\treturn FormatBotResponse(blacklist.Count > 0 ? string.Join(\", \", blacklist) : string.Format(Strings.ErrorIsEmpty, nameof(blacklist)));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBlacklist(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBlacklist(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBlacklistAdd(ulong steamID, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<ulong> targetIDs = new HashSet<ulong>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t\t}\n\n\t\t\t\ttargetIDs.Add(targetID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.AddBlacklistedFromTradesSteamIDs(targetIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBlacklistAdd(ulong steamID, string botNames, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBlacklistAdd(steamID, targetSteamIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseBlacklistRemove(ulong steamID, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetSteamIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<ulong> targetIDs = new HashSet<ulong>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!ulong.TryParse(target, out ulong targetID) || (targetID == 0) || !new SteamID(targetID).IsIndividualAccount) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(targetID)));\n\t\t\t\t}\n\n\t\t\t\ttargetIDs.Add(targetID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.RemoveBlacklistedFromTradesSteamIDs(targetIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseBlacklistRemove(ulong steamID, string botNames, string targetSteamIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetSteamIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetSteamIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseBlacklistRemove(steamID, targetSteamIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate static string? ResponseEncrypt(ulong steamID, string cryptoMethodText, string stringToEncrypt) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(cryptoMethodText) || string.IsNullOrEmpty(stringToEncrypt)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(cryptoMethodText) + \" || \" + nameof(stringToEncrypt));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Enum.TryParse(cryptoMethodText, true, out ArchiCryptoHelper.ECryptoMethod cryptoMethod)) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(cryptoMethod)));\n\t\t\t}\n\n\t\t\tstring? encryptedString = Actions.Encrypt(cryptoMethod, stringToEncrypt);\n\n\t\t\treturn FormatStaticResponse(!string.IsNullOrEmpty(encryptedString) ? string.Format(Strings.Result, encryptedString) : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static string? ResponseExit(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Actions.Exit();\n\n\t\t\treturn FormatStaticResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponseFarm(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.CardsFarmer.NowFarming) {\n\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t}\n\n\t\t\tUtilities.InBackground(Bot.CardsFarmer.StartFarming);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseFarm(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseFarm(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseHelp(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing) ? FormatBotResponse(SharedInfo.ProjectURL + \"/wiki/Commands\") : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleBlacklist(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tIReadOnlyCollection<uint> idleBlacklist = Bot.BotDatabase.GetIdlingBlacklistedAppIDs();\n\n\t\t\treturn FormatBotResponse(idleBlacklist.Count > 0 ? string.Join(\", \", idleBlacklist) : string.Format(Strings.ErrorIsEmpty, nameof(idleBlacklist)));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleBlacklist(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleBlacklist(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleBlacklistAdd(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.AddIdlingBlacklistedAppIDs(appIDs);\n\n\t\t\tif (Bot.CardsFarmer.NowFarming && Bot.CardsFarmer.GamesToFarmReadOnly.Any(game => appIDs.Contains(game.AppID))) {\n\t\t\t\tUtilities.InBackground(\n\t\t\t\t\tasync () => {\n\t\t\t\t\t\tawait Bot.CardsFarmer.StopFarming().ConfigureAwait(false);\n\t\t\t\t\t\tawait Bot.CardsFarmer.StartFarming().ConfigureAwait(false);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleBlacklistAdd(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleBlacklistAdd(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleBlacklistRemove(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.RemoveIdlingBlacklistedAppIDs(appIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleBlacklistRemove(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleBlacklistRemove(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleQueue(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tIReadOnlyCollection<uint> idleQueue = Bot.BotDatabase.GetIdlingPriorityAppIDs();\n\n\t\t\treturn FormatBotResponse(idleQueue.Count > 0 ? string.Join(\", \", idleQueue) : string.Format(Strings.ErrorIsEmpty, nameof(idleQueue)));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleQueue(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleQueue(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleQueueAdd(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.AddIdlingPriorityAppIDs(appIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleQueueAdd(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleQueueAdd(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseIdleQueueRemove(ulong steamID, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tstring[] targets = targetAppIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (targets.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(targets)));\n\t\t\t}\n\n\t\t\tHashSet<uint> appIDs = new HashSet<uint>();\n\n\t\t\tforeach (string target in targets) {\n\t\t\t\tif (!uint.TryParse(target, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorParsingObject, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\tappIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot.BotDatabase.RemoveIdlingPriorityAppIDs(appIDs);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseIdleQueueRemove(ulong steamID, string botNames, string targetAppIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetAppIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetAppIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseIdleQueueRemove(steamID, targetAppIDs)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseInput(ulong steamID, string propertyName, string inputValue) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(inputValue)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(propertyName) + \" || \" + nameof(inputValue));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tbool headless = ASF.GlobalConfig?.Headless ?? GlobalConfig.DefaultHeadless;\n\n\t\t\tif (!headless) {\n\t\t\t\treturn FormatBotResponse(Strings.ErrorFunctionOnlyInHeadlessMode);\n\t\t\t}\n\n\t\t\tif (!Enum.TryParse(propertyName, true, out ASF.EUserInputType inputType) || (inputType == ASF.EUserInputType.None) || !Enum.IsDefined(typeof(ASF.EUserInputType), inputType)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(inputType)));\n\t\t\t}\n\n\t\t\tbool result = Bot.SetUserInput(inputType, inputValue);\n\n\t\t\treturn FormatBotResponse(result ? Strings.Done : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseInput(ulong steamID, string botNames, string propertyName, string inputValue) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(inputValue)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(propertyName) + \" || \" + nameof(inputValue));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseInput(steamID, propertyName, inputValue)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseLevel(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tuint? level = await Bot.ArchiHandler.GetLevel().ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(level.HasValue ? string.Format(Strings.BotLevel, level.Value) : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseLevel(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLevel(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseLoot(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseLoot(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLoot(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseLootByRealAppIDs(ulong steamID, string realAppIDsText, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(realAppIDsText));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.LootableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.LootableTypes)));\n\t\t\t}\n\n\t\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (appIDTexts.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t\t}\n\n\t\t\tHashSet<uint> realAppIDs = new HashSet<uint>();\n\n\t\t\tforeach (string appIDText in appIDTexts) {\n\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\trealAppIDs.Add(appID);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(filterFunction: item => Bot.BotConfig.LootableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseLootByRealAppIDs(ulong steamID, string botNames, string realAppIDsText, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(realAppIDsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(realAppIDsText));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseLootByRealAppIDs(steamID, realAppIDsText, exclude))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseNickname(ulong steamID, string nickname) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(nickname)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(nickname));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tBot.SteamFriends.SetPersonaName(nickname);\n\n\t\t\treturn FormatBotResponse(Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseNickname(ulong steamID, string botNames, string nickname) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(nickname)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(nickname));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseNickname(steamID, nickname)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<(string? Response, Dictionary<string, string>? OwnedGames)> ResponseOwns(ulong steamID, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn (null, null);\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotNotConnected), null);\n\t\t\t}\n\n\t\t\tDictionary<uint, string>? gamesOwned = await FetchGamesOwned(true).ConfigureAwait(false);\n\n\t\t\tStringBuilder response = new StringBuilder();\n\t\t\tDictionary<string, string> result = new Dictionary<string, string>();\n\n\t\t\tstring[] entries = query.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tforeach (string entry in entries) {\n\t\t\t\tstring game;\n\t\t\t\tstring type;\n\n\t\t\t\tint index = entry.IndexOf('/');\n\n\t\t\t\tif ((index > 0) && (entry.Length > index + 1)) {\n\t\t\t\t\tgame = entry.Substring(index + 1);\n\t\t\t\t\ttype = entry.Substring(0, index);\n\t\t\t\t} else if (uint.TryParse(entry, out uint appID) && (appID > 0)) {\n\t\t\t\t\tgame = entry;\n\t\t\t\t\ttype = \"APP\";\n\t\t\t\t} else {\n\t\t\t\t\tgame = entry;\n\t\t\t\t\ttype = \"NAME\";\n\t\t\t\t}\n\n\t\t\t\tswitch (type.ToUpperInvariant()) {\n\t\t\t\t\tcase \"A\" when uint.TryParse(game, out uint appID) && (appID > 0):\n\t\t\t\t\tcase \"APP\" when uint.TryParse(game, out appID) && (appID > 0):\n\t\t\t\t\t\tHashSet<uint>? packageIDs = ASF.GlobalDatabase?.GetPackageIDs(appID, Bot.OwnedPackageIDs.Keys);\n\n\t\t\t\t\t\tif ((packageIDs != null) && (packageIDs.Count > 0)) {\n\t\t\t\t\t\t\tif ((gamesOwned != null) && gamesOwned.TryGetValue(appID, out string? cachedGameName)) {\n\t\t\t\t\t\t\t\tresult[\"app/\" + appID] = cachedGameName;\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, cachedGameName)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult[\"app/\" + appID] = appID.ToString();\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlready, \"app/\" + appID)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (gamesOwned.TryGetValue(appID, out string? gameName)) {\n\t\t\t\t\t\t\t\tresult[\"app/\" + appID] = gameName;\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, gameName)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, \"app/\" + appID)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"R\":\n\t\t\t\t\tcase \"REGEX\":\n\t\t\t\t\t\tRegex regex;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tregex = new Regex(game);\n\t\t\t\t\t\t} catch (ArgumentException e) {\n\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(regex))));\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool foundWithRegex = false;\n\n\t\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => regex.IsMatch(gameOwned.Value))) {\n\t\t\t\t\t\t\tfoundWithRegex = true;\n\n\t\t\t\t\t\t\tresult[\"app/\" + appID] = gameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, gameName)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!foundWithRegex) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase \"S\" when uint.TryParse(game, out uint packageID) && (packageID > 0):\n\t\t\t\t\tcase \"SUB\" when uint.TryParse(game, out packageID) && (packageID > 0):\n\t\t\t\t\t\tif (Bot.OwnedPackageIDs.ContainsKey(packageID)) {\n\t\t\t\t\t\t\tresult[\"sub/\" + packageID] = packageID.ToString();\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlready, \"sub/\" + packageID)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, \"sub/\" + packageID)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\tgamesOwned = await FetchGamesOwned().ConfigureAwait(false);\n\n\t\t\t\t\t\t\tif (gamesOwned == null) {\n\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(gamesOwned))));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbool foundWithName = false;\n\n\t\t\t\t\t\tforeach ((uint appID, string gameName) in gamesOwned.Where(gameOwned => gameOwned.Value.IndexOf(game, StringComparison.OrdinalIgnoreCase) >= 0)) {\n\t\t\t\t\t\t\tfoundWithName = true;\n\n\t\t\t\t\t\t\tresult[\"app/\" + appID] = gameName;\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotOwnedAlreadyWithName, \"app/\" + appID, gameName)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!foundWithName) {\n\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotNotOwnedYet, entry)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (response.Length > 0 ? response.ToString() : FormatBotResponse(string.Format(Strings.BotNotOwnedYet, query)), result);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseOwns(ulong steamID, string botNames, string query) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(query)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(query));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<(string? Response, Dictionary<string, string>? OwnedGames)> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseOwns(steamID, query))).ConfigureAwait(false);\n\n\t\t\tList<(string Response, Dictionary<string, string> OwnedGames)> validResults = new List<(string Response, Dictionary<string, string> OwnedGames)>(results.Where(result => !string.IsNullOrEmpty(result.Response) && (result.OwnedGames != null))!);\n\n\t\t\tif (validResults.Count == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tDictionary<string, (ushort Count, string GameName)> ownedGamesStats = new Dictionary<string, (ushort Count, string GameName)>();\n\n\t\t\tforeach ((string gameID, string gameName) in validResults.Where(validResult => validResult.OwnedGames.Count > 0).SelectMany(validResult => validResult.OwnedGames)) {\n\t\t\t\tif (ownedGamesStats.TryGetValue(gameID, out (ushort Count, string GameName) ownedGameStats)) {\n\t\t\t\t\townedGameStats.Count++;\n\t\t\t\t} else {\n\t\t\t\t\townedGameStats.Count = 1;\n\t\t\t\t}\n\n\t\t\t\tif (!string.IsNullOrEmpty(gameName)) {\n\t\t\t\t\townedGameStats.GameName = gameName;\n\t\t\t\t}\n\n\t\t\t\townedGamesStats[gameID] = ownedGameStats;\n\t\t\t}\n\n\t\t\tIEnumerable<string> extraResponses = ownedGamesStats.Select(kv => FormatStaticResponse(string.Format(Strings.BotOwnsOverviewPerGame, kv.Value.Count, validResults.Count, kv.Key + (!string.IsNullOrEmpty(kv.Value.GameName) ? \" | \" + kv.Value.GameName : \"\"))));\n\n\t\t\treturn string.Join(Environment.NewLine, validResults.Select(result => result.Response).Concat(extraResponses));\n\t\t}\n\n\t\tprivate string? ResponsePassword(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(Bot.BotConfig.DecryptedSteamPassword)) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(BotConfig.DecryptedSteamPassword)));\n\t\t\t}\n\n\t\t\tDictionary<ArchiCryptoHelper.ECryptoMethod, string> encryptedPasswords = new Dictionary<ArchiCryptoHelper.ECryptoMethod, string>(2) {\n\t\t\t\t{ ArchiCryptoHelper.ECryptoMethod.AES, ArchiCryptoHelper.Encrypt(ArchiCryptoHelper.ECryptoMethod.AES, Bot.BotConfig.DecryptedSteamPassword!) ?? \"\" },\n\t\t\t\t{ ArchiCryptoHelper.ECryptoMethod.ProtectedDataForCurrentUser, ArchiCryptoHelper.Encrypt(ArchiCryptoHelper.ECryptoMethod.ProtectedDataForCurrentUser, Bot.BotConfig.DecryptedSteamPassword!) ?? \"\" }\n\t\t\t};\n\n\t\t\treturn FormatBotResponse(string.Join(\", \", encryptedPasswords.Where(kv => !string.IsNullOrEmpty(kv.Value)).Select(kv => string.Format(Strings.BotEncryptedPassword, kv.Key, kv.Value))));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePassword(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponsePassword(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePause(ulong steamID, bool permanent, string? resumeInSecondsText = null) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (permanent && !Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn FormatBotResponse(Strings.ErrorAccessDenied);\n\t\t\t}\n\n\t\t\tushort resumeInSeconds = 0;\n\n\t\t\tif (!string.IsNullOrEmpty(resumeInSecondsText) && (!ushort.TryParse(resumeInSecondsText, out resumeInSeconds) || (resumeInSeconds == 0))) {\n\t\t\t\treturn string.Format(Strings.ErrorIsInvalid, nameof(resumeInSecondsText));\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.Pause(permanent, resumeInSeconds).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePause(ulong steamID, string botNames, bool permanent, string? resumeInSecondsText = null) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePause(steamID, permanent, resumeInSecondsText))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePlay(ulong steamID, IReadOnlyCollection<uint> gameIDs, string? gameName = null) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (gameIDs == null) || (gameIDs.Count > ArchiHandler.MaxGamesPlayedConcurrently)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(gameIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.Play(gameIDs, gameName).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePlay(ulong steamID, string targetGameIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(targetGameIDs));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tstring[] games = targetGameIDs.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (games.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(games)));\n\t\t\t}\n\n\t\t\tHashSet<uint> gamesToPlay = new HashSet<uint>();\n\t\t\tStringBuilder gameName = new StringBuilder();\n\n\t\t\tforeach (string game in games) {\n\t\t\t\tif (!uint.TryParse(game, out uint gameID) || (gameID == 0)) {\n\t\t\t\t\tgameName.Append((gameName.Length > 0 ? \" \" : \"\") + game);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (gamesToPlay.Count >= ArchiHandler.MaxGamesPlayedConcurrently) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.WarningFailedWithError, nameof(gamesToPlay) + \" > \" + ArchiHandler.MaxGamesPlayedConcurrently));\n\t\t\t\t}\n\n\t\t\t\tgamesToPlay.Add(gameID);\n\t\t\t}\n\n\t\t\treturn await ResponsePlay(steamID, gamesToPlay, gameName.Length > 0 ? gameName.ToString() : null).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePlay(ulong steamID, string botNames, string targetGameIDs) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(targetGameIDs)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(targetGameIDs));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePlay(steamID, targetGameIDs))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponsePrivacy(ulong steamID, string privacySettingsText) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(privacySettingsText));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tstring[] privacySettingsArgs = privacySettingsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (privacySettingsArgs.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(privacySettingsArgs)));\n\t\t\t}\n\n\t\t\t// There are only 7 privacy settings\n\t\t\tif (privacySettingsArgs.Length > 7) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t\t}\n\n\t\t\tArchiHandler.EPrivacySetting profile = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting ownedGames = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting playtime = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting friendsList = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting inventory = ArchiHandler.EPrivacySetting.Private;\n\t\t\tArchiHandler.EPrivacySetting inventoryGifts = ArchiHandler.EPrivacySetting.Private;\n\t\t\tSteam.UserPrivacy.ECommentPermission comments = Steam.UserPrivacy.ECommentPermission.Private;\n\n\t\t\t// Converting digits to enum\n\t\t\tfor (byte index = 0; index < privacySettingsArgs.Length; index++) {\n\t\t\t\tif (!Enum.TryParse(privacySettingsArgs[index], true, out ArchiHandler.EPrivacySetting privacySetting) || (privacySetting == ArchiHandler.EPrivacySetting.Unknown) || !Enum.IsDefined(typeof(ArchiHandler.EPrivacySetting), privacySetting)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(privacySettingsArgs)));\n\t\t\t\t}\n\n\t\t\t\t// Child setting can't be less restrictive than its parent\n\t\t\t\tswitch (index) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\t// Profile\n\t\t\t\t\t\tprofile = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t// OwnedGames, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\townedGames = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t// Playtime, child of OwnedGames\n\t\t\t\t\t\tif (ownedGames < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(playtime)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplaytime = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t// FriendsList, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(ownedGames)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfriendsList = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\t// Inventory, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(inventory)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinventory = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\t// InventoryGifts, child of Inventory\n\t\t\t\t\t\tif (inventory < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(inventoryGifts)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinventoryGifts = privacySetting;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\t// Comments, child of Profile\n\t\t\t\t\t\tif (profile < privacySetting) {\n\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(comments)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Comments use different numbers than everything else, but we want to have this command consistent for end-user, so we'll map them\n\t\t\t\t\t\tswitch (privacySetting) {\n\t\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.FriendsOnly:\n\t\t\t\t\t\t\t\tcomments = Steam.UserPrivacy.ECommentPermission.FriendsOnly;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Private:\n\t\t\t\t\t\t\t\tcomments = Steam.UserPrivacy.ECommentPermission.Private;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ArchiHandler.EPrivacySetting.Public:\n\t\t\t\t\t\t\t\tcomments = Steam.UserPrivacy.ECommentPermission.Public;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(privacySetting), privacySetting));\n\n\t\t\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(privacySetting)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tBot.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(index), index));\n\n\t\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(index)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSteam.UserPrivacy userPrivacy = new Steam.UserPrivacy(new Steam.UserPrivacy.PrivacySettings(profile, ownedGames, playtime, friendsList, inventory, inventoryGifts), comments);\n\n\t\t\treturn FormatBotResponse(await Bot.ArchiWebHandler.ChangePrivacySettings(userPrivacy).ConfigureAwait(false) ? Strings.Success : Strings.WarningFailed);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponsePrivacy(ulong steamID, string botNames, string privacySettingsText) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(privacySettingsText)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(privacySettingsText));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponsePrivacy(steamID, privacySettingsText))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseRedeem(ulong steamID, string keysText, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(keysText) || (Bot.Bots == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(keysText) + \" || \" + nameof(Bot.Bots));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Operator)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tstring[] keys = keysText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (keys.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(keys)));\n\t\t\t}\n\n\t\t\tbool forward = !redeemFlags.HasFlag(ERedeemFlags.SkipForwarding) && (redeemFlags.HasFlag(ERedeemFlags.ForceForwarding) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Forwarding));\n\t\t\tbool distribute = !redeemFlags.HasFlag(ERedeemFlags.SkipDistributing) && (redeemFlags.HasFlag(ERedeemFlags.ForceDistributing) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.Distributing));\n\t\t\tbool keepMissingGames = !redeemFlags.HasFlag(ERedeemFlags.SkipKeepMissingGames) && (redeemFlags.HasFlag(ERedeemFlags.ForceKeepMissingGames) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.KeepMissingGames));\n\t\t\tbool assumeWalletKeyOnBadActivationCode = !redeemFlags.HasFlag(ERedeemFlags.SkipAssumeWalletKeyOnBadActivationCode) && (redeemFlags.HasFlag(ERedeemFlags.ForceAssumeWalletKeyOnBadActivationCode) || Bot.BotConfig.RedeemingPreferences.HasFlag(BotConfig.ERedeemingPreferences.AssumeWalletKeyOnBadActivationCode));\n\n\t\t\tHashSet<string> pendingKeys = keys.ToHashSet(StringComparer.Ordinal);\n\t\t\tHashSet<string> unusedKeys = pendingKeys.ToHashSet(StringComparer.Ordinal);\n\n\t\t\tHashSet<Bot> rateLimitedBots = new HashSet<Bot>();\n\t\t\tHashSet<Bot> triedBots = new HashSet<Bot>();\n\n\t\t\tStringBuilder response = new StringBuilder();\n\n\t\t\tusing (HashSet<string>.Enumerator keysEnumerator = pendingKeys.GetEnumerator()) {\n\t\t\t\t// Initial key\n\t\t\t\tstring? key = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\t\tstring? previousKey = key;\n\n\t\t\t\twhile (!string.IsNullOrEmpty(key)) {\n\t\t\t\t\tstring startingKey = key!;\n\n\t\t\t\t\tusing (IEnumerator<Bot> botsEnumerator = Bot.Bots.Where(bot => (bot.Value != Bot) && bot.Value.IsConnectedAndLoggedOn && bot.Value.Commands.Bot.HasPermission(steamID, BotConfig.EPermission.Operator)).OrderByDescending(bot => Bot.BotsComparer?.Compare(bot.Key, Bot.BotName) > 0).ThenBy(bot => bot.Key, Bot.BotsComparer).Select(bot => bot.Value).GetEnumerator()) {\n\t\t\t\t\t\tBot? currentBot = Bot;\n\n\t\t\t\t\t\twhile (!string.IsNullOrEmpty(key) && (currentBot != null)) {\n\t\t\t\t\t\t\tif (previousKey != key) {\n\t\t\t\t\t\t\t\ttriedBots.Clear();\n\t\t\t\t\t\t\t\tpreviousKey = key;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (redeemFlags.HasFlag(ERedeemFlags.Validate) && !Utilities.IsValidCdKey(key!)) {\n\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((currentBot == Bot) && redeemFlags.HasFlag(ERedeemFlags.SkipInitial)) {\n\t\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbool skipRequest = triedBots.Contains(currentBot) || rateLimitedBots.Contains(currentBot);\n\n\t\t\t\t\t\t\t\tArchiHandler.PurchaseResponseCallback? result = skipRequest ? new ArchiHandler.PurchaseResponseCallback(EResult.Fail, EPurchaseResultDetail.CancelledByUser) : await currentBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, EPurchaseResultDetail.Timeout), currentBot.BotName));\n\n\t\t\t\t\t\t\t\t\t// Either bot will be changed, or loop aborted\n\t\t\t\t\t\t\t\t\tcurrentBot = null;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttriedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\t\tif (((result.PurchaseResultDetail == EPurchaseResultDetail.CannotRedeemCodeFromClient) || ((result.PurchaseResultDetail == EPurchaseResultDetail.BadActivationCode) && assumeWalletKeyOnBadActivationCode)) && (Bot.WalletCurrency != ECurrencyCode.Invalid)) {\n\t\t\t\t\t\t\t\t\t\t// If it's a wallet code, we try to redeem it first, then handle the inner result as our primary one\n\t\t\t\t\t\t\t\t\t\t(EResult Result, EPurchaseResultDetail? PurchaseResult)? walletResult = await currentBot.ArchiWebHandler.RedeemWalletKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\tif (walletResult != null) {\n\t\t\t\t\t\t\t\t\t\t\tresult.Result = walletResult.Value.Result;\n\n\t\t\t\t\t\t\t\t\t\t\t// BadActivationCode is our smart guess in this case\n\t\t\t\t\t\t\t\t\t\t\tresult.PurchaseResultDetail = walletResult.Value.PurchaseResult.GetValueOrDefault(walletResult.Value.Result == EResult.OK ? EPurchaseResultDetail.NoDetail : EPurchaseResultDetail.BadActivationCode);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tresult.Result = EResult.Timeout;\n\t\t\t\t\t\t\t\t\t\t\tresult.PurchaseResultDetail = EPurchaseResultDetail.Timeout;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ((result.Items != null) && (result.Items.Count > 0)) {\n\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeemWithItems, key, result.Result + \"/\" + result.PurchaseResultDetail, string.Join(\", \", result.Items)), currentBot.BotName));\n\t\t\t\t\t\t\t\t\t} else if (!skipRequest) {\n\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, result.Result + \"/\" + result.PurchaseResultDetail), currentBot.BotName));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tswitch (result.PurchaseResultDetail) {\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CannotRedeemCodeFromClient:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.Timeout:\n\t\t\t\t\t\t\t\t\t\t\tif ((result.Result != EResult.Timeout) && (result.PurchaseResultDetail != EPurchaseResultDetail.Timeout)) {\n\t\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\tif (result.PurchaseResultDetail == EPurchaseResultDetail.NoDetail) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Keep current bot\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AccountLocked:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.AlreadyPurchased:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.CancelledByUser:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DoesNotOwnRequiredApp:\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RestrictedCountry:\n\t\t\t\t\t\t\t\t\t\t\tif (!forward || (keepMissingGames && (result.PurchaseResultDetail != EPurchaseResultDetail.AlreadyPurchased))) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (distribute) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Next bot, without changing key\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tDictionary<uint, string> items = result.Items ?? new Dictionary<uint, string>();\n\n\t\t\t\t\t\t\t\t\t\t\tbool alreadyHandled = false;\n\n\t\t\t\t\t\t\t\t\t\t\tforeach (Bot innerBot in Bot.Bots.Where(bot => (bot.Value != currentBot) && (!redeemFlags.HasFlag(ERedeemFlags.SkipInitial) || (bot.Value != Bot)) && !triedBots.Contains(bot.Value) && !rateLimitedBots.Contains(bot.Value) && bot.Value.IsConnectedAndLoggedOn && bot.Value.Commands.Bot.HasPermission(steamID, BotConfig.EPermission.Operator) && ((items.Count == 0) || items.Keys.Any(packageID => !bot.Value.OwnedPackageIDs.ContainsKey(packageID)))).OrderBy(bot => bot.Key, Bot.BotsComparer).Select(bot => bot.Value)) {\n\t\t\t\t\t\t\t\t\t\t\t\tArchiHandler.PurchaseResponseCallback? otherResult = await innerBot.Actions.RedeemKey(key!).ConfigureAwait(false);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (otherResult == null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, EResult.Timeout + \"/\" + EPurchaseResultDetail.Timeout), innerBot.BotName));\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\ttriedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (otherResult.PurchaseResultDetail) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.BadActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.DuplicateActivationCode:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.NoDetail: // OK\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This key is already handled, as we either redeemed it or we're sure it's dupe/invalid\n\t\t\t\t\t\t\t\t\t\t\t\t\t\talreadyHandled = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(innerBot);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ((otherResult.Items != null) && (otherResult.Items.Count > 0)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeemWithItems, key, otherResult.Result + \"/\" + otherResult.PurchaseResultDetail, string.Join(\", \", otherResult.Items)), innerBot.BotName));\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.BotRedeem, key, otherResult.Result + \"/\" + otherResult.PurchaseResultDetail), innerBot.BotName));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (alreadyHandled) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (otherResult.Items == null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tforeach ((uint packageID, string packageName) in otherResult.Items.Where(item => !items.ContainsKey(item.Key))) {\n\t\t\t\t\t\t\t\t\t\t\t\t\titems[packageID] = packageName;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase EPurchaseResultDetail.RateLimited:\n\t\t\t\t\t\t\t\t\t\t\trateLimitedBots.Add(currentBot);\n\n\t\t\t\t\t\t\t\t\t\t\tgoto case EPurchaseResultDetail.CancelledByUser;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tASF.ArchiLogger.LogGenericError(string.Format(Strings.WarningUnknownValuePleaseReport, nameof(result.PurchaseResultDetail), result.PurchaseResultDetail));\n\n\t\t\t\t\t\t\t\t\t\t\tunusedKeys.Remove(key!);\n\n\t\t\t\t\t\t\t\t\t\t\t// Next key\n\t\t\t\t\t\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\n\t\t\t\t\t\t\t\t\t\t\t// Next bot (if needed)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// We want to change bot in two cases:\n\t\t\t\t\t\t\t// a) When we have distribution enabled, obviously\n\t\t\t\t\t\t\t// b) When we're skipping initial bot AND we have forwarding enabled, otherwise we won't get down to other accounts\n\t\t\t\t\t\t\tif (distribute || (forward && redeemFlags.HasFlag(ERedeemFlags.SkipInitial))) {\n\t\t\t\t\t\t\t\tcurrentBot = botsEnumerator.MoveNext() ? botsEnumerator.Current : null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key == startingKey) {\n\t\t\t\t\t\t// We ran out of bots to try for this key, so change it to avoid infinite loop, next key\n\t\t\t\t\t\tkey = keysEnumerator.MoveNext() ? keysEnumerator.Current : null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unusedKeys.Count > 0) {\n\t\t\t\tresponse.AppendLine(FormatBotResponse(string.Format(Strings.UnusedKeys, string.Join(\", \", unusedKeys))));\n\t\t\t}\n\n\t\t\treturn response.Length > 0 ? response.ToString() : null;\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseRedeem(ulong steamID, string botNames, string keys, ERedeemFlags redeemFlags = ERedeemFlags.None) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(keys)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(keys));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseRedeem(steamID, keys, redeemFlags))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseReset(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.Play(Enumerable.Empty<uint>(), Bot.BotConfig.CustomGamePlayedWhileIdle).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseReset(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseReset(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate static string? ResponseRestart(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Actions.Restart();\n\n\t\t\treturn FormatStaticResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate string? ResponseResume(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Bot.Actions.Resume();\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseResume(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseResume(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseStart(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Bot.Actions.Start();\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseStart(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStart(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseStats(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tushort memoryInMegabytes = (ushort) (GC.GetTotalMemory(false) / 1024 / 1024);\n\t\t\tTimeSpan uptime = DateTime.UtcNow.Subtract(RuntimeCompatibility.ProcessStartTime.ToUniversalTime());\n\n\t\t\treturn FormatBotResponse(string.Format(Strings.BotStats, memoryInMegabytes, uptime.ToHumanReadable()));\n\t\t}\n\n\t\tprivate (string? Response, Bot Bot) ResponseStatus(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.FamilySharing)) {\n\t\t\t\treturn (null, Bot);\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn (FormatBotResponse(Bot.KeepRunning ? Strings.BotStatusConnecting : Strings.BotStatusNotRunning), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.PlayingBlocked) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusPlayingNotAvailable), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.CardsFarmer.Paused) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusPaused), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.IsAccountLimited) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusLimited), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.IsAccountLocked) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusLocked), Bot);\n\t\t\t}\n\n\t\t\tif (!Bot.CardsFarmer.NowFarming || (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count == 0)) {\n\t\t\t\treturn (FormatBotResponse(Strings.BotStatusNotIdling), Bot);\n\t\t\t}\n\n\t\t\tif (Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Count > 1) {\n\t\t\t\treturn (FormatBotResponse(string.Format(Strings.BotStatusIdlingList, string.Join(\", \", Bot.CardsFarmer.CurrentGamesFarmingReadOnly.Select(game => game.AppID + \" (\" + game.GameName + \")\")), Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t\t\t}\n\n\t\t\tCardsFarmer.Game soloGame = Bot.CardsFarmer.CurrentGamesFarmingReadOnly.First();\n\n\t\t\treturn (FormatBotResponse(string.Format(Strings.BotStatusIdling, soloGame.AppID, soloGame.GameName, soloGame.CardsRemaining, Bot.CardsFarmer.GamesToFarmReadOnly.Count, Bot.CardsFarmer.GamesToFarmReadOnly.Sum(game => game.CardsRemaining), Bot.CardsFarmer.TimeRemaining.ToHumanReadable())), Bot);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseStatus(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<(string? Response, Bot Bot)> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStatus(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<(string Response, Bot Bot)> validResults = new List<(string Response, Bot Bot)>(results.Where(result => !string.IsNullOrEmpty(result.Response))!);\n\n\t\t\tif (validResults.Count == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tHashSet<Bot> botsRunning = validResults.Where(result => result.Bot.KeepRunning).Select(result => result.Bot).ToHashSet();\n\n\t\t\tstring extraResponse = string.Format(Strings.BotStatusOverview, botsRunning.Count, validResults.Count, botsRunning.Sum(bot => bot.CardsFarmer.GamesToFarmReadOnly.Count), botsRunning.Sum(bot => bot.CardsFarmer.GamesToFarmReadOnly.Sum(game => game.CardsRemaining)));\n\n\t\t\treturn string.Join(Environment.NewLine, validResults.Select(result => result.Response).Union(extraResponse.ToEnumerable()));\n\t\t}\n\n\t\tprivate string? ResponseStop(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string message) = Bot.Actions.Stop();\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseStop(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseStop(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseTransfer(ulong steamID, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatBotResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t\t}\n\n\t\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type)).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseTransfer(ulong steamID, string botNames, string botNameTo) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransfer(steamID, botNameTo))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseTransferByRealAppIDs(ulong steamID, IReadOnlyCollection<uint> realAppIDs, Bot targetBot, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || (realAppIDs == null) || (realAppIDs.Count == 0) || (targetBot == null)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(realAppIDs) + \" || \" + nameof(targetBot));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\tif (Bot.BotConfig.TransferableTypes.Count == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(Bot.BotConfig.TransferableTypes)));\n\t\t\t}\n\n\t\t\tif (!targetBot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.TargetBotNotConnected);\n\t\t\t}\n\n\t\t\tif (targetBot.SteamID == Bot.SteamID) {\n\t\t\t\treturn FormatBotResponse(Strings.BotSendingTradeToYourself);\n\t\t\t}\n\n\t\t\t(bool success, string message) = await Bot.Actions.SendInventory(targetSteamID: targetBot.SteamID, filterFunction: item => Bot.BotConfig.TransferableTypes.Contains(item.Type) && (exclude ^ realAppIDs.Contains(item.RealAppID))).ConfigureAwait(false);\n\n\t\t\treturn FormatBotResponse(success ? message : string.Format(Strings.WarningFailedWithError, message));\n\t\t}\n\n\t\tprivate async Task<string?> ResponseTransferByRealAppIDs(ulong steamID, string realAppIDsText, string botNameTo, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(realAppIDsText) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(realAppIDsText) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatBotResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (appIDTexts.Length == 0) {\n\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t\t}\n\n\t\t\tHashSet<uint> realAppIDs = new HashSet<uint>();\n\n\t\t\tforeach (string appIDText in appIDTexts) {\n\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatBotResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\trealAppIDs.Add(appID);\n\t\t\t}\n\n\t\t\treturn await ResponseTransferByRealAppIDs(steamID, realAppIDs, targetBot, exclude).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseTransferByRealAppIDs(ulong steamID, string botNames, string realAppIDsText, string botNameTo, bool exclude = false) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames) || string.IsNullOrEmpty(realAppIDsText) || string.IsNullOrEmpty(botNameTo)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames) + \" || \" + nameof(realAppIDsText) + \" || \" + nameof(botNameTo));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tstring[] appIDTexts = realAppIDsText.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n\n\t\t\tif (appIDTexts.Length == 0) {\n\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsEmpty, nameof(appIDTexts)));\n\t\t\t}\n\n\t\t\tHashSet<uint> realAppIDs = new HashSet<uint>();\n\n\t\t\tforeach (string appIDText in appIDTexts) {\n\t\t\t\tif (!uint.TryParse(appIDText, out uint appID) || (appID == 0)) {\n\t\t\t\t\treturn FormatStaticResponse(string.Format(Strings.ErrorIsInvalid, nameof(appID)));\n\t\t\t\t}\n\n\t\t\t\trealAppIDs.Add(appID);\n\t\t\t}\n\n\t\t\tBot? targetBot = Bot.GetBot(botNameTo);\n\n\t\t\tif (targetBot == null) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNameTo)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseTransferByRealAppIDs(steamID, realAppIDs, targetBot, exclude))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate string? ResponseUnknown(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn Bot.HasPermission(steamID, BotConfig.EPermission.Operator) ? FormatBotResponse(Strings.UnknownCommand) : null;\n\t\t}\n\n\t\tprivate async Task<string?> ResponseUnpackBoosters(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!Bot.IsConnectedAndLoggedOn) {\n\t\t\t\treturn FormatBotResponse(Strings.BotNotConnected);\n\t\t\t}\n\n\t\t\t// It'd make sense here to actually check return code of ArchiWebHandler.UnpackBooster(), but it lies most of the time | https://github.com/JustArchi/ArchiSteamFarm/issues/704\n\t\t\tbool completeSuccess = true;\n\n\t\t\t// It'd also make sense to run all of this in parallel, but it seems that Steam has a lot of problems with inventory-related parallel requests | https://steamcommunity.com/groups/ascfarm/discussions/1/3559414588264550284/\n\t\t\ttry {\n\t\t\t\tawait foreach (Steam.Asset item in Bot.ArchiWebHandler.GetInventoryAsync(Bot.SteamID).Where(item => item.Type == Steam.Asset.EType.BoosterPack).ConfigureAwait(false)) {\n\t\t\t\t\tif (!await Bot.ArchiWebHandler.UnpackBooster(item.RealAppID, item.AssetID).ConfigureAwait(false)) {\n\t\t\t\t\t\tcompleteSuccess = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (HttpRequestException e) {\n\t\t\t\tBot.ArchiLogger.LogGenericWarningException(e);\n\n\t\t\t\tcompleteSuccess = false;\n\t\t\t} catch (Exception e) {\n\t\t\t\tBot.ArchiLogger.LogGenericException(e);\n\n\t\t\t\tcompleteSuccess = false;\n\t\t\t}\n\n\t\t\treturn FormatBotResponse(completeSuccess ? Strings.Success : Strings.Done);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseUnpackBoosters(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => bot.Commands.ResponseUnpackBoosters(steamID))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseUpdate(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!ASF.IsOwner(steamID)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t(bool success, string? message, Version? version) = await Actions.Update().ConfigureAwait(false);\n\n\t\t\treturn FormatStaticResponse((success ? Strings.Success : Strings.WarningFailed) + (!string.IsNullOrEmpty(message) ? \" \" + message : version != null ? \" \" + version : \"\"));\n\t\t}\n\n\t\tprivate string? ResponseVersion(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\treturn Bot.HasPermission(steamID, BotConfig.EPermission.Operator) ? FormatBotResponse(string.Format(Strings.BotVersion, SharedInfo.ASF, SharedInfo.Version)) : null;\n\t\t}\n\n\t\tprivate string? ResponseWalletBalance(ulong steamID) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID));\n\t\t\t}\n\n\t\t\tif (!Bot.HasPermission(steamID, BotConfig.EPermission.Master)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn !Bot.IsConnectedAndLoggedOn ? FormatBotResponse(Strings.BotNotConnected) : FormatBotResponse(Bot.WalletCurrency != ECurrencyCode.Invalid ? string.Format(Strings.BotWalletBalance, Bot.WalletBalance / 100.0, Bot.WalletCurrency.ToString()) : Strings.BotHasNoWallet);\n\t\t}\n\n\t\tprivate static async Task<string?> ResponseWalletBalance(ulong steamID, string botNames) {\n\t\t\tif ((steamID == 0) || !new SteamID(steamID).IsIndividualAccount || string.IsNullOrEmpty(botNames)) {\n\t\t\t\tthrow new ArgumentNullException(nameof(steamID) + \" || \" + nameof(botNames));\n\t\t\t}\n\n\t\t\tHashSet<Bot>? bots = Bot.GetBots(botNames);\n\n\t\t\tif ((bots == null) || (bots.Count == 0)) {\n\t\t\t\treturn ASF.IsOwner(steamID) ? FormatStaticResponse(string.Format(Strings.BotNotFound, botNames)) : null;\n\t\t\t}\n\n\t\t\tIList<string?> results = await Utilities.InParallel(bots.Select(bot => Task.Run(() => bot.Commands.ResponseWalletBalance(steamID)))).ConfigureAwait(false);\n\n\t\t\tList<string> responses = new List<string>(results.Where(result => !string.IsNullOrEmpty(result))!);\n\n\t\t\treturn responses.Count > 0 ? string.Join(Environment.NewLine, responses) : null;\n\t\t}\n\n\t\t[Flags]\n\t\tprivate enum ERedeemFlags : ushort {\n\t\t\tNone = 0,\n\t\t\tValidate = 1,\n\t\t\tForceForwarding = 2,\n\t\t\tSkipForwarding = 4,\n\t\t\tForceDistributing = 8,\n\t\t\tSkipDistributing = 16,\n\t\t\tSkipInitial = 32,\n\t\t\tForceKeepMissingGames = 64,\n\t\t\tSkipKeepMissingGames = 128,\n\t\t\tForceAssumeWalletKeyOnBadActivationCode = 256,\n\t\t\tSkipAssumeWalletKeyOnBadActivationCode = 512\n\t\t}\n\t}\n}\n"], "filenames": ["ArchiSteamFarm/Bot.cs", "ArchiSteamFarm/Commands.cs"], "buggy_code_start_loc": [2243, 310], "buggy_code_end_loc": [2277, 368], "fixing_code_start_loc": [2244, 310], "fixing_code_end_loc": [2290, 378], "type": "CWE-20", "message": "ArchiSteamFarm is a C# application with primary purpose of idling Steam cards from multiple accounts simultaneously. In versions prior to 4.3.1.0 a Denial of Service (aka DoS) vulnerability which allows attacker to remotely crash running ASF instance through sending a specifically-crafted Steam chat message exists. The user sending the message does not need to be authorized within the bot or ASF process. The attacker needs to know ASF's `CommandPrefix` in advance, but majority of ASF setups run with an unchanged default value. This attack does not allow attacker to gain any potentially-sensitive information, such as logins or passwords, does not allow to execute arbitrary commands and otherwise exploit the crash further. The issue is patched in ASF V4.3.1.0. The only workaround which guarantees complete protection is running all bots with `OnlineStatus` of `0` (Offline). In this setup, ASF is able to ignore even the specifically-crafted message without attempting to interpret it.", "other": {"cve": {"id": "CVE-2021-32795", "sourceIdentifier": "security-advisories@github.com", "published": "2021-07-26T20:15:08.527", "lastModified": "2021-08-13T18:23:52.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ArchiSteamFarm is a C# application with primary purpose of idling Steam cards from multiple accounts simultaneously. In versions prior to 4.3.1.0 a Denial of Service (aka DoS) vulnerability which allows attacker to remotely crash running ASF instance through sending a specifically-crafted Steam chat message exists. The user sending the message does not need to be authorized within the bot or ASF process. The attacker needs to know ASF's `CommandPrefix` in advance, but majority of ASF setups run with an unchanged default value. This attack does not allow attacker to gain any potentially-sensitive information, such as logins or passwords, does not allow to execute arbitrary commands and otherwise exploit the crash further. The issue is patched in ASF V4.3.1.0. The only workaround which guarantees complete protection is running all bots with `OnlineStatus` of `0` (Offline). In this setup, ASF is able to ignore even the specifically-crafted message without attempting to interpret it."}, {"lang": "es", "value": "ArchiSteamFarm es una aplicaci\u00f3n C# con el prop\u00f3sito principal de ralentizar las tarjetas de Steam de m\u00faltiples cuentas simult\u00e1neamente. En las versiones anteriores a 4.3.1.0 se presenta una vulnerabilidad de denegaci\u00f3n de servicio (tambi\u00e9n se conoce como DoS) que permite a un atacante bloquear remotamente una instancia de ASF en ejecuci\u00f3n mediante el env\u00edo de un mensaje de chat de Steam espec\u00edficamente dise\u00f1ado. El usuario que env\u00eda el mensaje no necesita estar autorizado dentro del proceso del bot o del ASF. El atacante necesita conocer el \"CommandPrefix\" de ASF de antemano, pero la mayor\u00eda de las configuraciones de ASF se ejecutan con un valor predeterminado sin cambios. Este ataque no permite al atacante obtener ninguna informaci\u00f3n potencialmente confidencial, como inicios de sesi\u00f3n o contrase\u00f1as, no permite ejecutar comandos arbitrarios y de otra manera explotar el bloqueo m\u00e1s. El problema est\u00e1 parcheado en ASF versi\u00f3n V4.3.1.0. La \u00fanica soluci\u00f3n que garantiza una protecci\u00f3n completa es ejecutar todos los bots con \"OnlineStatus\" de \"0\" (Offline). En esta configuraci\u00f3n, ASF es capaz de ignorar incluso el mensaje espec\u00edficamente dise\u00f1ado sin intentar interpretarlo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:archisteamfarm_project:archisteamfarm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.1.0", "matchCriteriaId": "F2ACD67C-272F-4186-A024-EE8451D456F4"}]}]}], "references": [{"url": "https://github.com/JustArchiNET/ArchiSteamFarm/commit/4cd581ec041912cf199c5512fe6d1dcaec0594c0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JustArchiNET/ArchiSteamFarm/security/advisories/GHSA-5v34-4prm-9474", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://steamcommunity.com/groups/archiasf/discussions/1/2935742047969570844/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/JustArchiNET/ArchiSteamFarm/commit/4cd581ec041912cf199c5512fe6d1dcaec0594c0"}}